
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:23:12.926] plan(): Setting new future strategy stack:
[13:23:12.926] List of future strategies:
[13:23:12.926] 1. sequential:
[13:23:12.926]    - args: function (..., envir = parent.frame())
[13:23:12.926]    - tweaked: FALSE
[13:23:12.926]    - call: future::plan("sequential")
[13:23:12.942] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[13:23:13.004] plan(): Setting new future strategy stack:
[13:23:13.004] List of future strategies:
[13:23:13.004] 1. sequential:
[13:23:13.004]    - args: function (..., envir = parent.frame())
[13:23:13.004]    - tweaked: FALSE
[13:23:13.004]    - call: plan(strategy)
[13:23:13.018] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[13:23:13.019] getGlobalsAndPackages() ...
[13:23:13.019] Searching for globals...
[13:23:13.027] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.027] Searching for globals ... DONE
[13:23:13.027] Resolving globals: FALSE
[13:23:13.028] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.029] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.029] - globals: [2] ‘weight’, ‘group’
[13:23:13.029] - packages: [1] ‘stats’
[13:23:13.029] getGlobalsAndPackages() ... DONE
[13:23:13.030] run() for ‘Future’ ...
[13:23:13.030] - state: ‘created’
[13:23:13.030] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.031]   - Field: ‘label’
[13:23:13.031]   - Field: ‘local’
[13:23:13.031]   - Field: ‘owner’
[13:23:13.031]   - Field: ‘envir’
[13:23:13.031]   - Field: ‘packages’
[13:23:13.031]   - Field: ‘gc’
[13:23:13.031]   - Field: ‘conditions’
[13:23:13.031]   - Field: ‘expr’
[13:23:13.031]   - Field: ‘uuid’
[13:23:13.032]   - Field: ‘seed’
[13:23:13.032]   - Field: ‘version’
[13:23:13.032]   - Field: ‘result’
[13:23:13.032]   - Field: ‘asynchronous’
[13:23:13.032]   - Field: ‘calls’
[13:23:13.032]   - Field: ‘globals’
[13:23:13.032]   - Field: ‘stdout’
[13:23:13.032]   - Field: ‘earlySignal’
[13:23:13.032]   - Field: ‘lazy’
[13:23:13.032]   - Field: ‘state’
[13:23:13.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.033] - Launch lazy future ...
[13:23:13.033] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.034] Packages needed by future strategies (n = 0): <none>
[13:23:13.034] {
[13:23:13.034]     {
[13:23:13.034]         {
[13:23:13.034]             ...future.startTime <- base::Sys.time()
[13:23:13.034]             {
[13:23:13.034]                 {
[13:23:13.034]                   {
[13:23:13.034]                     {
[13:23:13.034]                       base::local({
[13:23:13.034]                         has_future <- base::requireNamespace("future", 
[13:23:13.034]                           quietly = TRUE)
[13:23:13.034]                         if (has_future) {
[13:23:13.034]                           ns <- base::getNamespace("future")
[13:23:13.034]                           version <- ns[[".package"]][["version"]]
[13:23:13.034]                           if (is.null(version)) 
[13:23:13.034]                             version <- utils::packageVersion("future")
[13:23:13.034]                         }
[13:23:13.034]                         else {
[13:23:13.034]                           version <- NULL
[13:23:13.034]                         }
[13:23:13.034]                         if (!has_future || version < "1.8.0") {
[13:23:13.034]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.034]                             "", base::R.version$version.string), 
[13:23:13.034]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.034]                               "release", "version")], collapse = " "), 
[13:23:13.034]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.034]                             info)
[13:23:13.034]                           info <- base::paste(info, collapse = "; ")
[13:23:13.034]                           if (!has_future) {
[13:23:13.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.034]                               info)
[13:23:13.034]                           }
[13:23:13.034]                           else {
[13:23:13.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.034]                               info, version)
[13:23:13.034]                           }
[13:23:13.034]                           base::stop(msg)
[13:23:13.034]                         }
[13:23:13.034]                       })
[13:23:13.034]                     }
[13:23:13.034]                     base::local({
[13:23:13.034]                       for (pkg in "stats") {
[13:23:13.034]                         base::loadNamespace(pkg)
[13:23:13.034]                         base::library(pkg, character.only = TRUE)
[13:23:13.034]                       }
[13:23:13.034]                     })
[13:23:13.034]                   }
[13:23:13.034]                   options(future.plan = NULL)
[13:23:13.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.034]                 }
[13:23:13.034]                 ...future.workdir <- getwd()
[13:23:13.034]             }
[13:23:13.034]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.034]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.034]         }
[13:23:13.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.034]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.034]             base::names(...future.oldOptions))
[13:23:13.034]     }
[13:23:13.034]     if (FALSE) {
[13:23:13.034]     }
[13:23:13.034]     else {
[13:23:13.034]         if (TRUE) {
[13:23:13.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.034]                 open = "w")
[13:23:13.034]         }
[13:23:13.034]         else {
[13:23:13.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.034]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.034]         }
[13:23:13.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.034]             base::sink(type = "output", split = FALSE)
[13:23:13.034]             base::close(...future.stdout)
[13:23:13.034]         }, add = TRUE)
[13:23:13.034]     }
[13:23:13.034]     ...future.frame <- base::sys.nframe()
[13:23:13.034]     ...future.conditions <- base::list()
[13:23:13.034]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.034]     if (FALSE) {
[13:23:13.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.034]     }
[13:23:13.034]     ...future.result <- base::tryCatch({
[13:23:13.034]         base::withCallingHandlers({
[13:23:13.034]             ...future.value <- base::withVisible(base::local({
[13:23:13.034]                 lm(weight ~ group - 1)
[13:23:13.034]             }))
[13:23:13.034]             future::FutureResult(value = ...future.value$value, 
[13:23:13.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.034]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.034]                     ...future.globalenv.names))
[13:23:13.034]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.034]         }, condition = base::local({
[13:23:13.034]             c <- base::c
[13:23:13.034]             inherits <- base::inherits
[13:23:13.034]             invokeRestart <- base::invokeRestart
[13:23:13.034]             length <- base::length
[13:23:13.034]             list <- base::list
[13:23:13.034]             seq.int <- base::seq.int
[13:23:13.034]             signalCondition <- base::signalCondition
[13:23:13.034]             sys.calls <- base::sys.calls
[13:23:13.034]             `[[` <- base::`[[`
[13:23:13.034]             `+` <- base::`+`
[13:23:13.034]             `<<-` <- base::`<<-`
[13:23:13.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.034]                   3L)]
[13:23:13.034]             }
[13:23:13.034]             function(cond) {
[13:23:13.034]                 is_error <- inherits(cond, "error")
[13:23:13.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.034]                   NULL)
[13:23:13.034]                 if (is_error) {
[13:23:13.034]                   sessionInformation <- function() {
[13:23:13.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.034]                       search = base::search(), system = base::Sys.info())
[13:23:13.034]                   }
[13:23:13.034]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.034]                     cond$call), session = sessionInformation(), 
[13:23:13.034]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.034]                   signalCondition(cond)
[13:23:13.034]                 }
[13:23:13.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.034]                 "immediateCondition"))) {
[13:23:13.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.034]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.034]                   if (TRUE && !signal) {
[13:23:13.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.034]                     {
[13:23:13.034]                       inherits <- base::inherits
[13:23:13.034]                       invokeRestart <- base::invokeRestart
[13:23:13.034]                       is.null <- base::is.null
[13:23:13.034]                       muffled <- FALSE
[13:23:13.034]                       if (inherits(cond, "message")) {
[13:23:13.034]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.034]                         if (muffled) 
[13:23:13.034]                           invokeRestart("muffleMessage")
[13:23:13.034]                       }
[13:23:13.034]                       else if (inherits(cond, "warning")) {
[13:23:13.034]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.034]                         if (muffled) 
[13:23:13.034]                           invokeRestart("muffleWarning")
[13:23:13.034]                       }
[13:23:13.034]                       else if (inherits(cond, "condition")) {
[13:23:13.034]                         if (!is.null(pattern)) {
[13:23:13.034]                           computeRestarts <- base::computeRestarts
[13:23:13.034]                           grepl <- base::grepl
[13:23:13.034]                           restarts <- computeRestarts(cond)
[13:23:13.034]                           for (restart in restarts) {
[13:23:13.034]                             name <- restart$name
[13:23:13.034]                             if (is.null(name)) 
[13:23:13.034]                               next
[13:23:13.034]                             if (!grepl(pattern, name)) 
[13:23:13.034]                               next
[13:23:13.034]                             invokeRestart(restart)
[13:23:13.034]                             muffled <- TRUE
[13:23:13.034]                             break
[13:23:13.034]                           }
[13:23:13.034]                         }
[13:23:13.034]                       }
[13:23:13.034]                       invisible(muffled)
[13:23:13.034]                     }
[13:23:13.034]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.034]                   }
[13:23:13.034]                 }
[13:23:13.034]                 else {
[13:23:13.034]                   if (TRUE) {
[13:23:13.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.034]                     {
[13:23:13.034]                       inherits <- base::inherits
[13:23:13.034]                       invokeRestart <- base::invokeRestart
[13:23:13.034]                       is.null <- base::is.null
[13:23:13.034]                       muffled <- FALSE
[13:23:13.034]                       if (inherits(cond, "message")) {
[13:23:13.034]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.034]                         if (muffled) 
[13:23:13.034]                           invokeRestart("muffleMessage")
[13:23:13.034]                       }
[13:23:13.034]                       else if (inherits(cond, "warning")) {
[13:23:13.034]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.034]                         if (muffled) 
[13:23:13.034]                           invokeRestart("muffleWarning")
[13:23:13.034]                       }
[13:23:13.034]                       else if (inherits(cond, "condition")) {
[13:23:13.034]                         if (!is.null(pattern)) {
[13:23:13.034]                           computeRestarts <- base::computeRestarts
[13:23:13.034]                           grepl <- base::grepl
[13:23:13.034]                           restarts <- computeRestarts(cond)
[13:23:13.034]                           for (restart in restarts) {
[13:23:13.034]                             name <- restart$name
[13:23:13.034]                             if (is.null(name)) 
[13:23:13.034]                               next
[13:23:13.034]                             if (!grepl(pattern, name)) 
[13:23:13.034]                               next
[13:23:13.034]                             invokeRestart(restart)
[13:23:13.034]                             muffled <- TRUE
[13:23:13.034]                             break
[13:23:13.034]                           }
[13:23:13.034]                         }
[13:23:13.034]                       }
[13:23:13.034]                       invisible(muffled)
[13:23:13.034]                     }
[13:23:13.034]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.034]                   }
[13:23:13.034]                 }
[13:23:13.034]             }
[13:23:13.034]         }))
[13:23:13.034]     }, error = function(ex) {
[13:23:13.034]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.034]                 ...future.rng), started = ...future.startTime, 
[13:23:13.034]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.034]             version = "1.8"), class = "FutureResult")
[13:23:13.034]     }, finally = {
[13:23:13.034]         if (!identical(...future.workdir, getwd())) 
[13:23:13.034]             setwd(...future.workdir)
[13:23:13.034]         {
[13:23:13.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.034]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.034]             }
[13:23:13.034]             base::options(...future.oldOptions)
[13:23:13.034]             if (.Platform$OS.type == "windows") {
[13:23:13.034]                 old_names <- names(...future.oldEnvVars)
[13:23:13.034]                 envs <- base::Sys.getenv()
[13:23:13.034]                 names <- names(envs)
[13:23:13.034]                 common <- intersect(names, old_names)
[13:23:13.034]                 added <- setdiff(names, old_names)
[13:23:13.034]                 removed <- setdiff(old_names, names)
[13:23:13.034]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.034]                   envs[common]]
[13:23:13.034]                 NAMES <- toupper(changed)
[13:23:13.034]                 args <- list()
[13:23:13.034]                 for (kk in seq_along(NAMES)) {
[13:23:13.034]                   name <- changed[[kk]]
[13:23:13.034]                   NAME <- NAMES[[kk]]
[13:23:13.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.034]                     next
[13:23:13.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.034]                 }
[13:23:13.034]                 NAMES <- toupper(added)
[13:23:13.034]                 for (kk in seq_along(NAMES)) {
[13:23:13.034]                   name <- added[[kk]]
[13:23:13.034]                   NAME <- NAMES[[kk]]
[13:23:13.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.034]                     next
[13:23:13.034]                   args[[name]] <- ""
[13:23:13.034]                 }
[13:23:13.034]                 NAMES <- toupper(removed)
[13:23:13.034]                 for (kk in seq_along(NAMES)) {
[13:23:13.034]                   name <- removed[[kk]]
[13:23:13.034]                   NAME <- NAMES[[kk]]
[13:23:13.034]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.034]                     next
[13:23:13.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.034]                 }
[13:23:13.034]                 if (length(args) > 0) 
[13:23:13.034]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.034]             }
[13:23:13.034]             else {
[13:23:13.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.034]             }
[13:23:13.034]             {
[13:23:13.034]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.034]                   0L) {
[13:23:13.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.034]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.034]                   base::options(opts)
[13:23:13.034]                 }
[13:23:13.034]                 {
[13:23:13.034]                   {
[13:23:13.034]                     NULL
[13:23:13.034]                     RNGkind("Mersenne-Twister")
[13:23:13.034]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.034]                       inherits = FALSE)
[13:23:13.034]                   }
[13:23:13.034]                   options(future.plan = NULL)
[13:23:13.034]                   if (is.na(NA_character_)) 
[13:23:13.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.034]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.034]                   {
[13:23:13.034]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.034]                     if (!future$lazy) 
[13:23:13.034]                       future <- run(future)
[13:23:13.034]                     invisible(future)
[13:23:13.034]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.034]                 }
[13:23:13.034]             }
[13:23:13.034]         }
[13:23:13.034]     })
[13:23:13.034]     if (TRUE) {
[13:23:13.034]         base::sink(type = "output", split = FALSE)
[13:23:13.034]         if (TRUE) {
[13:23:13.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.034]         }
[13:23:13.034]         else {
[13:23:13.034]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.034]         }
[13:23:13.034]         base::close(...future.stdout)
[13:23:13.034]         ...future.stdout <- NULL
[13:23:13.034]     }
[13:23:13.034]     ...future.result$conditions <- ...future.conditions
[13:23:13.034]     ...future.result$finished <- base::Sys.time()
[13:23:13.034]     ...future.result
[13:23:13.034] }
[13:23:13.036] assign_globals() ...
[13:23:13.037] List of 2
[13:23:13.037]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.037]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.037]  - attr(*, "where")=List of 2
[13:23:13.037]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.037]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.037]  - attr(*, "resolved")= logi FALSE
[13:23:13.037]  - attr(*, "total_size")= num 896
[13:23:13.037]  - attr(*, "already-done")= logi TRUE
[13:23:13.040] - copied ‘weight’ to environment
[13:23:13.040] - copied ‘group’ to environment
[13:23:13.040] assign_globals() ... done
[13:23:13.041] plan(): Setting new future strategy stack:
[13:23:13.041] List of future strategies:
[13:23:13.041] 1. sequential:
[13:23:13.041]    - args: function (..., envir = parent.frame())
[13:23:13.041]    - tweaked: FALSE
[13:23:13.041]    - call: NULL
[13:23:13.041] plan(): nbrOfWorkers() = 1
[13:23:13.044] plan(): Setting new future strategy stack:
[13:23:13.044] List of future strategies:
[13:23:13.044] 1. sequential:
[13:23:13.044]    - args: function (..., envir = parent.frame())
[13:23:13.044]    - tweaked: FALSE
[13:23:13.044]    - call: plan(strategy)
[13:23:13.044] plan(): nbrOfWorkers() = 1
[13:23:13.044] SequentialFuture started (and completed)
[13:23:13.045] - Launch lazy future ... done
[13:23:13.045] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.051] getGlobalsAndPackages() ...
[13:23:13.051] Searching for globals...
[13:23:13.052] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.053] Searching for globals ... DONE
[13:23:13.053] Resolving globals: FALSE
[13:23:13.053] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.054] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.054] - globals: [2] ‘weight’, ‘group’
[13:23:13.054] - packages: [1] ‘stats’
[13:23:13.054] getGlobalsAndPackages() ... DONE
[13:23:13.054] run() for ‘Future’ ...
[13:23:13.054] - state: ‘created’
[13:23:13.055] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.055] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.055]   - Field: ‘label’
[13:23:13.055]   - Field: ‘local’
[13:23:13.055]   - Field: ‘owner’
[13:23:13.055]   - Field: ‘envir’
[13:23:13.056]   - Field: ‘packages’
[13:23:13.056]   - Field: ‘gc’
[13:23:13.056]   - Field: ‘conditions’
[13:23:13.056]   - Field: ‘expr’
[13:23:13.056]   - Field: ‘uuid’
[13:23:13.056]   - Field: ‘seed’
[13:23:13.056]   - Field: ‘version’
[13:23:13.056]   - Field: ‘result’
[13:23:13.056]   - Field: ‘asynchronous’
[13:23:13.056]   - Field: ‘calls’
[13:23:13.057]   - Field: ‘globals’
[13:23:13.057]   - Field: ‘stdout’
[13:23:13.057]   - Field: ‘earlySignal’
[13:23:13.057]   - Field: ‘lazy’
[13:23:13.057]   - Field: ‘state’
[13:23:13.057] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.057] - Launch lazy future ...
[13:23:13.057] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.057] Packages needed by future strategies (n = 0): <none>
[13:23:13.058] {
[13:23:13.058]     {
[13:23:13.058]         {
[13:23:13.058]             ...future.startTime <- base::Sys.time()
[13:23:13.058]             {
[13:23:13.058]                 {
[13:23:13.058]                   {
[13:23:13.058]                     {
[13:23:13.058]                       base::local({
[13:23:13.058]                         has_future <- base::requireNamespace("future", 
[13:23:13.058]                           quietly = TRUE)
[13:23:13.058]                         if (has_future) {
[13:23:13.058]                           ns <- base::getNamespace("future")
[13:23:13.058]                           version <- ns[[".package"]][["version"]]
[13:23:13.058]                           if (is.null(version)) 
[13:23:13.058]                             version <- utils::packageVersion("future")
[13:23:13.058]                         }
[13:23:13.058]                         else {
[13:23:13.058]                           version <- NULL
[13:23:13.058]                         }
[13:23:13.058]                         if (!has_future || version < "1.8.0") {
[13:23:13.058]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.058]                             "", base::R.version$version.string), 
[13:23:13.058]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.058]                               "release", "version")], collapse = " "), 
[13:23:13.058]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.058]                             info)
[13:23:13.058]                           info <- base::paste(info, collapse = "; ")
[13:23:13.058]                           if (!has_future) {
[13:23:13.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.058]                               info)
[13:23:13.058]                           }
[13:23:13.058]                           else {
[13:23:13.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.058]                               info, version)
[13:23:13.058]                           }
[13:23:13.058]                           base::stop(msg)
[13:23:13.058]                         }
[13:23:13.058]                       })
[13:23:13.058]                     }
[13:23:13.058]                     base::local({
[13:23:13.058]                       for (pkg in "stats") {
[13:23:13.058]                         base::loadNamespace(pkg)
[13:23:13.058]                         base::library(pkg, character.only = TRUE)
[13:23:13.058]                       }
[13:23:13.058]                     })
[13:23:13.058]                   }
[13:23:13.058]                   options(future.plan = NULL)
[13:23:13.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.058]                 }
[13:23:13.058]                 ...future.workdir <- getwd()
[13:23:13.058]             }
[13:23:13.058]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.058]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.058]         }
[13:23:13.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.058]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.058]             base::names(...future.oldOptions))
[13:23:13.058]     }
[13:23:13.058]     if (FALSE) {
[13:23:13.058]     }
[13:23:13.058]     else {
[13:23:13.058]         if (TRUE) {
[13:23:13.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.058]                 open = "w")
[13:23:13.058]         }
[13:23:13.058]         else {
[13:23:13.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.058]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.058]         }
[13:23:13.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.058]             base::sink(type = "output", split = FALSE)
[13:23:13.058]             base::close(...future.stdout)
[13:23:13.058]         }, add = TRUE)
[13:23:13.058]     }
[13:23:13.058]     ...future.frame <- base::sys.nframe()
[13:23:13.058]     ...future.conditions <- base::list()
[13:23:13.058]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.058]     if (FALSE) {
[13:23:13.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.058]     }
[13:23:13.058]     ...future.result <- base::tryCatch({
[13:23:13.058]         base::withCallingHandlers({
[13:23:13.058]             ...future.value <- base::withVisible(base::local({
[13:23:13.058]                 lm(weight ~ group - 1)
[13:23:13.058]             }))
[13:23:13.058]             future::FutureResult(value = ...future.value$value, 
[13:23:13.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.058]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.058]                     ...future.globalenv.names))
[13:23:13.058]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.058]         }, condition = base::local({
[13:23:13.058]             c <- base::c
[13:23:13.058]             inherits <- base::inherits
[13:23:13.058]             invokeRestart <- base::invokeRestart
[13:23:13.058]             length <- base::length
[13:23:13.058]             list <- base::list
[13:23:13.058]             seq.int <- base::seq.int
[13:23:13.058]             signalCondition <- base::signalCondition
[13:23:13.058]             sys.calls <- base::sys.calls
[13:23:13.058]             `[[` <- base::`[[`
[13:23:13.058]             `+` <- base::`+`
[13:23:13.058]             `<<-` <- base::`<<-`
[13:23:13.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.058]                   3L)]
[13:23:13.058]             }
[13:23:13.058]             function(cond) {
[13:23:13.058]                 is_error <- inherits(cond, "error")
[13:23:13.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.058]                   NULL)
[13:23:13.058]                 if (is_error) {
[13:23:13.058]                   sessionInformation <- function() {
[13:23:13.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.058]                       search = base::search(), system = base::Sys.info())
[13:23:13.058]                   }
[13:23:13.058]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.058]                     cond$call), session = sessionInformation(), 
[13:23:13.058]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.058]                   signalCondition(cond)
[13:23:13.058]                 }
[13:23:13.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.058]                 "immediateCondition"))) {
[13:23:13.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.058]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.058]                   if (TRUE && !signal) {
[13:23:13.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.058]                     {
[13:23:13.058]                       inherits <- base::inherits
[13:23:13.058]                       invokeRestart <- base::invokeRestart
[13:23:13.058]                       is.null <- base::is.null
[13:23:13.058]                       muffled <- FALSE
[13:23:13.058]                       if (inherits(cond, "message")) {
[13:23:13.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.058]                         if (muffled) 
[13:23:13.058]                           invokeRestart("muffleMessage")
[13:23:13.058]                       }
[13:23:13.058]                       else if (inherits(cond, "warning")) {
[13:23:13.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.058]                         if (muffled) 
[13:23:13.058]                           invokeRestart("muffleWarning")
[13:23:13.058]                       }
[13:23:13.058]                       else if (inherits(cond, "condition")) {
[13:23:13.058]                         if (!is.null(pattern)) {
[13:23:13.058]                           computeRestarts <- base::computeRestarts
[13:23:13.058]                           grepl <- base::grepl
[13:23:13.058]                           restarts <- computeRestarts(cond)
[13:23:13.058]                           for (restart in restarts) {
[13:23:13.058]                             name <- restart$name
[13:23:13.058]                             if (is.null(name)) 
[13:23:13.058]                               next
[13:23:13.058]                             if (!grepl(pattern, name)) 
[13:23:13.058]                               next
[13:23:13.058]                             invokeRestart(restart)
[13:23:13.058]                             muffled <- TRUE
[13:23:13.058]                             break
[13:23:13.058]                           }
[13:23:13.058]                         }
[13:23:13.058]                       }
[13:23:13.058]                       invisible(muffled)
[13:23:13.058]                     }
[13:23:13.058]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.058]                   }
[13:23:13.058]                 }
[13:23:13.058]                 else {
[13:23:13.058]                   if (TRUE) {
[13:23:13.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.058]                     {
[13:23:13.058]                       inherits <- base::inherits
[13:23:13.058]                       invokeRestart <- base::invokeRestart
[13:23:13.058]                       is.null <- base::is.null
[13:23:13.058]                       muffled <- FALSE
[13:23:13.058]                       if (inherits(cond, "message")) {
[13:23:13.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.058]                         if (muffled) 
[13:23:13.058]                           invokeRestart("muffleMessage")
[13:23:13.058]                       }
[13:23:13.058]                       else if (inherits(cond, "warning")) {
[13:23:13.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.058]                         if (muffled) 
[13:23:13.058]                           invokeRestart("muffleWarning")
[13:23:13.058]                       }
[13:23:13.058]                       else if (inherits(cond, "condition")) {
[13:23:13.058]                         if (!is.null(pattern)) {
[13:23:13.058]                           computeRestarts <- base::computeRestarts
[13:23:13.058]                           grepl <- base::grepl
[13:23:13.058]                           restarts <- computeRestarts(cond)
[13:23:13.058]                           for (restart in restarts) {
[13:23:13.058]                             name <- restart$name
[13:23:13.058]                             if (is.null(name)) 
[13:23:13.058]                               next
[13:23:13.058]                             if (!grepl(pattern, name)) 
[13:23:13.058]                               next
[13:23:13.058]                             invokeRestart(restart)
[13:23:13.058]                             muffled <- TRUE
[13:23:13.058]                             break
[13:23:13.058]                           }
[13:23:13.058]                         }
[13:23:13.058]                       }
[13:23:13.058]                       invisible(muffled)
[13:23:13.058]                     }
[13:23:13.058]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.058]                   }
[13:23:13.058]                 }
[13:23:13.058]             }
[13:23:13.058]         }))
[13:23:13.058]     }, error = function(ex) {
[13:23:13.058]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.058]                 ...future.rng), started = ...future.startTime, 
[13:23:13.058]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.058]             version = "1.8"), class = "FutureResult")
[13:23:13.058]     }, finally = {
[13:23:13.058]         if (!identical(...future.workdir, getwd())) 
[13:23:13.058]             setwd(...future.workdir)
[13:23:13.058]         {
[13:23:13.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.058]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.058]             }
[13:23:13.058]             base::options(...future.oldOptions)
[13:23:13.058]             if (.Platform$OS.type == "windows") {
[13:23:13.058]                 old_names <- names(...future.oldEnvVars)
[13:23:13.058]                 envs <- base::Sys.getenv()
[13:23:13.058]                 names <- names(envs)
[13:23:13.058]                 common <- intersect(names, old_names)
[13:23:13.058]                 added <- setdiff(names, old_names)
[13:23:13.058]                 removed <- setdiff(old_names, names)
[13:23:13.058]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.058]                   envs[common]]
[13:23:13.058]                 NAMES <- toupper(changed)
[13:23:13.058]                 args <- list()
[13:23:13.058]                 for (kk in seq_along(NAMES)) {
[13:23:13.058]                   name <- changed[[kk]]
[13:23:13.058]                   NAME <- NAMES[[kk]]
[13:23:13.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.058]                     next
[13:23:13.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.058]                 }
[13:23:13.058]                 NAMES <- toupper(added)
[13:23:13.058]                 for (kk in seq_along(NAMES)) {
[13:23:13.058]                   name <- added[[kk]]
[13:23:13.058]                   NAME <- NAMES[[kk]]
[13:23:13.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.058]                     next
[13:23:13.058]                   args[[name]] <- ""
[13:23:13.058]                 }
[13:23:13.058]                 NAMES <- toupper(removed)
[13:23:13.058]                 for (kk in seq_along(NAMES)) {
[13:23:13.058]                   name <- removed[[kk]]
[13:23:13.058]                   NAME <- NAMES[[kk]]
[13:23:13.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.058]                     next
[13:23:13.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.058]                 }
[13:23:13.058]                 if (length(args) > 0) 
[13:23:13.058]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.058]             }
[13:23:13.058]             else {
[13:23:13.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.058]             }
[13:23:13.058]             {
[13:23:13.058]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.058]                   0L) {
[13:23:13.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.058]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.058]                   base::options(opts)
[13:23:13.058]                 }
[13:23:13.058]                 {
[13:23:13.058]                   {
[13:23:13.058]                     NULL
[13:23:13.058]                     RNGkind("Mersenne-Twister")
[13:23:13.058]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.058]                       inherits = FALSE)
[13:23:13.058]                   }
[13:23:13.058]                   options(future.plan = NULL)
[13:23:13.058]                   if (is.na(NA_character_)) 
[13:23:13.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.058]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.058]                   {
[13:23:13.058]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.058]                     if (!future$lazy) 
[13:23:13.058]                       future <- run(future)
[13:23:13.058]                     invisible(future)
[13:23:13.058]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.058]                 }
[13:23:13.058]             }
[13:23:13.058]         }
[13:23:13.058]     })
[13:23:13.058]     if (TRUE) {
[13:23:13.058]         base::sink(type = "output", split = FALSE)
[13:23:13.058]         if (TRUE) {
[13:23:13.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.058]         }
[13:23:13.058]         else {
[13:23:13.058]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.058]         }
[13:23:13.058]         base::close(...future.stdout)
[13:23:13.058]         ...future.stdout <- NULL
[13:23:13.058]     }
[13:23:13.058]     ...future.result$conditions <- ...future.conditions
[13:23:13.058]     ...future.result$finished <- base::Sys.time()
[13:23:13.058]     ...future.result
[13:23:13.058] }
[13:23:13.060] assign_globals() ...
[13:23:13.060] List of 2
[13:23:13.060]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.060]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.060]  - attr(*, "where")=List of 2
[13:23:13.060]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.060]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.060]  - attr(*, "resolved")= logi FALSE
[13:23:13.060]  - attr(*, "total_size")= num 896
[13:23:13.060]  - attr(*, "already-done")= logi TRUE
[13:23:13.063] - copied ‘weight’ to environment
[13:23:13.063] - copied ‘group’ to environment
[13:23:13.063] assign_globals() ... done
[13:23:13.064] plan(): Setting new future strategy stack:
[13:23:13.064] List of future strategies:
[13:23:13.064] 1. sequential:
[13:23:13.064]    - args: function (..., envir = parent.frame())
[13:23:13.064]    - tweaked: FALSE
[13:23:13.064]    - call: NULL
[13:23:13.064] plan(): nbrOfWorkers() = 1
[13:23:13.066] plan(): Setting new future strategy stack:
[13:23:13.066] List of future strategies:
[13:23:13.066] 1. sequential:
[13:23:13.066]    - args: function (..., envir = parent.frame())
[13:23:13.066]    - tweaked: FALSE
[13:23:13.066]    - call: plan(strategy)
[13:23:13.067] plan(): nbrOfWorkers() = 1
[13:23:13.067] SequentialFuture started (and completed)
[13:23:13.067] - Launch lazy future ... done
[13:23:13.067] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.070] getGlobalsAndPackages() ...
[13:23:13.070] Searching for globals...
[13:23:13.071] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.072] Searching for globals ... DONE
[13:23:13.072] Resolving globals: FALSE
[13:23:13.072] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.073] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.073] - globals: [2] ‘weight’, ‘group’
[13:23:13.073] - packages: [1] ‘stats’
[13:23:13.073] getGlobalsAndPackages() ... DONE
[13:23:13.073] run() for ‘Future’ ...
[13:23:13.073] - state: ‘created’
[13:23:13.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.074]   - Field: ‘label’
[13:23:13.074]   - Field: ‘local’
[13:23:13.074]   - Field: ‘owner’
[13:23:13.074]   - Field: ‘envir’
[13:23:13.074]   - Field: ‘packages’
[13:23:13.075]   - Field: ‘gc’
[13:23:13.075]   - Field: ‘conditions’
[13:23:13.075]   - Field: ‘expr’
[13:23:13.075]   - Field: ‘uuid’
[13:23:13.075]   - Field: ‘seed’
[13:23:13.075]   - Field: ‘version’
[13:23:13.075]   - Field: ‘result’
[13:23:13.075]   - Field: ‘asynchronous’
[13:23:13.075]   - Field: ‘calls’
[13:23:13.075]   - Field: ‘globals’
[13:23:13.076]   - Field: ‘stdout’
[13:23:13.076]   - Field: ‘earlySignal’
[13:23:13.076]   - Field: ‘lazy’
[13:23:13.076]   - Field: ‘state’
[13:23:13.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.076] - Launch lazy future ...
[13:23:13.076] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.076] Packages needed by future strategies (n = 0): <none>
[13:23:13.079] {
[13:23:13.079]     {
[13:23:13.079]         {
[13:23:13.079]             ...future.startTime <- base::Sys.time()
[13:23:13.079]             {
[13:23:13.079]                 {
[13:23:13.079]                   {
[13:23:13.079]                     {
[13:23:13.079]                       base::local({
[13:23:13.079]                         has_future <- base::requireNamespace("future", 
[13:23:13.079]                           quietly = TRUE)
[13:23:13.079]                         if (has_future) {
[13:23:13.079]                           ns <- base::getNamespace("future")
[13:23:13.079]                           version <- ns[[".package"]][["version"]]
[13:23:13.079]                           if (is.null(version)) 
[13:23:13.079]                             version <- utils::packageVersion("future")
[13:23:13.079]                         }
[13:23:13.079]                         else {
[13:23:13.079]                           version <- NULL
[13:23:13.079]                         }
[13:23:13.079]                         if (!has_future || version < "1.8.0") {
[13:23:13.079]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.079]                             "", base::R.version$version.string), 
[13:23:13.079]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.079]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.079]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.079]                               "release", "version")], collapse = " "), 
[13:23:13.079]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.079]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.079]                             info)
[13:23:13.079]                           info <- base::paste(info, collapse = "; ")
[13:23:13.079]                           if (!has_future) {
[13:23:13.079]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.079]                               info)
[13:23:13.079]                           }
[13:23:13.079]                           else {
[13:23:13.079]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.079]                               info, version)
[13:23:13.079]                           }
[13:23:13.079]                           base::stop(msg)
[13:23:13.079]                         }
[13:23:13.079]                       })
[13:23:13.079]                     }
[13:23:13.079]                     base::local({
[13:23:13.079]                       for (pkg in "stats") {
[13:23:13.079]                         base::loadNamespace(pkg)
[13:23:13.079]                         base::library(pkg, character.only = TRUE)
[13:23:13.079]                       }
[13:23:13.079]                     })
[13:23:13.079]                   }
[13:23:13.079]                   options(future.plan = NULL)
[13:23:13.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.079]                 }
[13:23:13.079]                 ...future.workdir <- getwd()
[13:23:13.079]             }
[13:23:13.079]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.079]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.079]         }
[13:23:13.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.079]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.079]             base::names(...future.oldOptions))
[13:23:13.079]     }
[13:23:13.079]     if (FALSE) {
[13:23:13.079]     }
[13:23:13.079]     else {
[13:23:13.079]         if (TRUE) {
[13:23:13.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.079]                 open = "w")
[13:23:13.079]         }
[13:23:13.079]         else {
[13:23:13.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.079]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.079]         }
[13:23:13.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.079]             base::sink(type = "output", split = FALSE)
[13:23:13.079]             base::close(...future.stdout)
[13:23:13.079]         }, add = TRUE)
[13:23:13.079]     }
[13:23:13.079]     ...future.frame <- base::sys.nframe()
[13:23:13.079]     ...future.conditions <- base::list()
[13:23:13.079]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.079]     if (FALSE) {
[13:23:13.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.079]     }
[13:23:13.079]     ...future.result <- base::tryCatch({
[13:23:13.079]         base::withCallingHandlers({
[13:23:13.079]             ...future.value <- base::withVisible(base::local({
[13:23:13.079]                 lm(weight ~ group - 1)
[13:23:13.079]             }))
[13:23:13.079]             future::FutureResult(value = ...future.value$value, 
[13:23:13.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.079]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.079]                     ...future.globalenv.names))
[13:23:13.079]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.079]         }, condition = base::local({
[13:23:13.079]             c <- base::c
[13:23:13.079]             inherits <- base::inherits
[13:23:13.079]             invokeRestart <- base::invokeRestart
[13:23:13.079]             length <- base::length
[13:23:13.079]             list <- base::list
[13:23:13.079]             seq.int <- base::seq.int
[13:23:13.079]             signalCondition <- base::signalCondition
[13:23:13.079]             sys.calls <- base::sys.calls
[13:23:13.079]             `[[` <- base::`[[`
[13:23:13.079]             `+` <- base::`+`
[13:23:13.079]             `<<-` <- base::`<<-`
[13:23:13.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.079]                   3L)]
[13:23:13.079]             }
[13:23:13.079]             function(cond) {
[13:23:13.079]                 is_error <- inherits(cond, "error")
[13:23:13.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.079]                   NULL)
[13:23:13.079]                 if (is_error) {
[13:23:13.079]                   sessionInformation <- function() {
[13:23:13.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.079]                       search = base::search(), system = base::Sys.info())
[13:23:13.079]                   }
[13:23:13.079]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.079]                     cond$call), session = sessionInformation(), 
[13:23:13.079]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.079]                   signalCondition(cond)
[13:23:13.079]                 }
[13:23:13.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.079]                 "immediateCondition"))) {
[13:23:13.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.079]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.079]                   if (TRUE && !signal) {
[13:23:13.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.079]                     {
[13:23:13.079]                       inherits <- base::inherits
[13:23:13.079]                       invokeRestart <- base::invokeRestart
[13:23:13.079]                       is.null <- base::is.null
[13:23:13.079]                       muffled <- FALSE
[13:23:13.079]                       if (inherits(cond, "message")) {
[13:23:13.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.079]                         if (muffled) 
[13:23:13.079]                           invokeRestart("muffleMessage")
[13:23:13.079]                       }
[13:23:13.079]                       else if (inherits(cond, "warning")) {
[13:23:13.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.079]                         if (muffled) 
[13:23:13.079]                           invokeRestart("muffleWarning")
[13:23:13.079]                       }
[13:23:13.079]                       else if (inherits(cond, "condition")) {
[13:23:13.079]                         if (!is.null(pattern)) {
[13:23:13.079]                           computeRestarts <- base::computeRestarts
[13:23:13.079]                           grepl <- base::grepl
[13:23:13.079]                           restarts <- computeRestarts(cond)
[13:23:13.079]                           for (restart in restarts) {
[13:23:13.079]                             name <- restart$name
[13:23:13.079]                             if (is.null(name)) 
[13:23:13.079]                               next
[13:23:13.079]                             if (!grepl(pattern, name)) 
[13:23:13.079]                               next
[13:23:13.079]                             invokeRestart(restart)
[13:23:13.079]                             muffled <- TRUE
[13:23:13.079]                             break
[13:23:13.079]                           }
[13:23:13.079]                         }
[13:23:13.079]                       }
[13:23:13.079]                       invisible(muffled)
[13:23:13.079]                     }
[13:23:13.079]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.079]                   }
[13:23:13.079]                 }
[13:23:13.079]                 else {
[13:23:13.079]                   if (TRUE) {
[13:23:13.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.079]                     {
[13:23:13.079]                       inherits <- base::inherits
[13:23:13.079]                       invokeRestart <- base::invokeRestart
[13:23:13.079]                       is.null <- base::is.null
[13:23:13.079]                       muffled <- FALSE
[13:23:13.079]                       if (inherits(cond, "message")) {
[13:23:13.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.079]                         if (muffled) 
[13:23:13.079]                           invokeRestart("muffleMessage")
[13:23:13.079]                       }
[13:23:13.079]                       else if (inherits(cond, "warning")) {
[13:23:13.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.079]                         if (muffled) 
[13:23:13.079]                           invokeRestart("muffleWarning")
[13:23:13.079]                       }
[13:23:13.079]                       else if (inherits(cond, "condition")) {
[13:23:13.079]                         if (!is.null(pattern)) {
[13:23:13.079]                           computeRestarts <- base::computeRestarts
[13:23:13.079]                           grepl <- base::grepl
[13:23:13.079]                           restarts <- computeRestarts(cond)
[13:23:13.079]                           for (restart in restarts) {
[13:23:13.079]                             name <- restart$name
[13:23:13.079]                             if (is.null(name)) 
[13:23:13.079]                               next
[13:23:13.079]                             if (!grepl(pattern, name)) 
[13:23:13.079]                               next
[13:23:13.079]                             invokeRestart(restart)
[13:23:13.079]                             muffled <- TRUE
[13:23:13.079]                             break
[13:23:13.079]                           }
[13:23:13.079]                         }
[13:23:13.079]                       }
[13:23:13.079]                       invisible(muffled)
[13:23:13.079]                     }
[13:23:13.079]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.079]                   }
[13:23:13.079]                 }
[13:23:13.079]             }
[13:23:13.079]         }))
[13:23:13.079]     }, error = function(ex) {
[13:23:13.079]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.079]                 ...future.rng), started = ...future.startTime, 
[13:23:13.079]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.079]             version = "1.8"), class = "FutureResult")
[13:23:13.079]     }, finally = {
[13:23:13.079]         if (!identical(...future.workdir, getwd())) 
[13:23:13.079]             setwd(...future.workdir)
[13:23:13.079]         {
[13:23:13.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.079]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.079]             }
[13:23:13.079]             base::options(...future.oldOptions)
[13:23:13.079]             if (.Platform$OS.type == "windows") {
[13:23:13.079]                 old_names <- names(...future.oldEnvVars)
[13:23:13.079]                 envs <- base::Sys.getenv()
[13:23:13.079]                 names <- names(envs)
[13:23:13.079]                 common <- intersect(names, old_names)
[13:23:13.079]                 added <- setdiff(names, old_names)
[13:23:13.079]                 removed <- setdiff(old_names, names)
[13:23:13.079]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.079]                   envs[common]]
[13:23:13.079]                 NAMES <- toupper(changed)
[13:23:13.079]                 args <- list()
[13:23:13.079]                 for (kk in seq_along(NAMES)) {
[13:23:13.079]                   name <- changed[[kk]]
[13:23:13.079]                   NAME <- NAMES[[kk]]
[13:23:13.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.079]                     next
[13:23:13.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.079]                 }
[13:23:13.079]                 NAMES <- toupper(added)
[13:23:13.079]                 for (kk in seq_along(NAMES)) {
[13:23:13.079]                   name <- added[[kk]]
[13:23:13.079]                   NAME <- NAMES[[kk]]
[13:23:13.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.079]                     next
[13:23:13.079]                   args[[name]] <- ""
[13:23:13.079]                 }
[13:23:13.079]                 NAMES <- toupper(removed)
[13:23:13.079]                 for (kk in seq_along(NAMES)) {
[13:23:13.079]                   name <- removed[[kk]]
[13:23:13.079]                   NAME <- NAMES[[kk]]
[13:23:13.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.079]                     next
[13:23:13.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.079]                 }
[13:23:13.079]                 if (length(args) > 0) 
[13:23:13.079]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.079]             }
[13:23:13.079]             else {
[13:23:13.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.079]             }
[13:23:13.079]             {
[13:23:13.079]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.079]                   0L) {
[13:23:13.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.079]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.079]                   base::options(opts)
[13:23:13.079]                 }
[13:23:13.079]                 {
[13:23:13.079]                   {
[13:23:13.079]                     NULL
[13:23:13.079]                     RNGkind("Mersenne-Twister")
[13:23:13.079]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.079]                       inherits = FALSE)
[13:23:13.079]                   }
[13:23:13.079]                   options(future.plan = NULL)
[13:23:13.079]                   if (is.na(NA_character_)) 
[13:23:13.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.079]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.079]                   {
[13:23:13.079]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.079]                     if (!future$lazy) 
[13:23:13.079]                       future <- run(future)
[13:23:13.079]                     invisible(future)
[13:23:13.079]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.079]                 }
[13:23:13.079]             }
[13:23:13.079]         }
[13:23:13.079]     })
[13:23:13.079]     if (TRUE) {
[13:23:13.079]         base::sink(type = "output", split = FALSE)
[13:23:13.079]         if (TRUE) {
[13:23:13.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.079]         }
[13:23:13.079]         else {
[13:23:13.079]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.079]         }
[13:23:13.079]         base::close(...future.stdout)
[13:23:13.079]         ...future.stdout <- NULL
[13:23:13.079]     }
[13:23:13.079]     ...future.result$conditions <- ...future.conditions
[13:23:13.079]     ...future.result$finished <- base::Sys.time()
[13:23:13.079]     ...future.result
[13:23:13.079] }
[13:23:13.081] assign_globals() ...
[13:23:13.081] List of 2
[13:23:13.081]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.081]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.081]  - attr(*, "where")=List of 2
[13:23:13.081]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.081]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.081]  - attr(*, "resolved")= logi FALSE
[13:23:13.081]  - attr(*, "total_size")= num 896
[13:23:13.081]  - attr(*, "already-done")= logi TRUE
[13:23:13.084] - copied ‘weight’ to environment
[13:23:13.084] - copied ‘group’ to environment
[13:23:13.085] assign_globals() ... done
[13:23:13.085] plan(): Setting new future strategy stack:
[13:23:13.085] List of future strategies:
[13:23:13.085] 1. sequential:
[13:23:13.085]    - args: function (..., envir = parent.frame())
[13:23:13.085]    - tweaked: FALSE
[13:23:13.085]    - call: NULL
[13:23:13.085] plan(): nbrOfWorkers() = 1
[13:23:13.087] plan(): Setting new future strategy stack:
[13:23:13.087] List of future strategies:
[13:23:13.087] 1. sequential:
[13:23:13.087]    - args: function (..., envir = parent.frame())
[13:23:13.087]    - tweaked: FALSE
[13:23:13.087]    - call: plan(strategy)
[13:23:13.088] plan(): nbrOfWorkers() = 1
[13:23:13.088] SequentialFuture started (and completed)
[13:23:13.088] - Launch lazy future ... done
[13:23:13.088] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.090] getGlobalsAndPackages() ...
[13:23:13.090] Searching for globals...
[13:23:13.092] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.092] Searching for globals ... DONE
[13:23:13.092] Resolving globals: FALSE
[13:23:13.092] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.093] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.093] - globals: [2] ‘weight’, ‘group’
[13:23:13.093] - packages: [1] ‘stats’
[13:23:13.093] getGlobalsAndPackages() ... DONE
[13:23:13.093] run() for ‘Future’ ...
[13:23:13.094] - state: ‘created’
[13:23:13.094] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.094] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.094]   - Field: ‘label’
[13:23:13.094]   - Field: ‘local’
[13:23:13.094]   - Field: ‘owner’
[13:23:13.095]   - Field: ‘envir’
[13:23:13.095]   - Field: ‘packages’
[13:23:13.095]   - Field: ‘gc’
[13:23:13.095]   - Field: ‘conditions’
[13:23:13.095]   - Field: ‘expr’
[13:23:13.095]   - Field: ‘uuid’
[13:23:13.095]   - Field: ‘seed’
[13:23:13.095]   - Field: ‘version’
[13:23:13.095]   - Field: ‘result’
[13:23:13.095]   - Field: ‘asynchronous’
[13:23:13.095]   - Field: ‘calls’
[13:23:13.096]   - Field: ‘globals’
[13:23:13.096]   - Field: ‘stdout’
[13:23:13.096]   - Field: ‘earlySignal’
[13:23:13.096]   - Field: ‘lazy’
[13:23:13.096]   - Field: ‘state’
[13:23:13.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.096] - Launch lazy future ...
[13:23:13.096] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.097] Packages needed by future strategies (n = 0): <none>
[13:23:13.097] {
[13:23:13.097]     {
[13:23:13.097]         {
[13:23:13.097]             ...future.startTime <- base::Sys.time()
[13:23:13.097]             {
[13:23:13.097]                 {
[13:23:13.097]                   {
[13:23:13.097]                     {
[13:23:13.097]                       base::local({
[13:23:13.097]                         has_future <- base::requireNamespace("future", 
[13:23:13.097]                           quietly = TRUE)
[13:23:13.097]                         if (has_future) {
[13:23:13.097]                           ns <- base::getNamespace("future")
[13:23:13.097]                           version <- ns[[".package"]][["version"]]
[13:23:13.097]                           if (is.null(version)) 
[13:23:13.097]                             version <- utils::packageVersion("future")
[13:23:13.097]                         }
[13:23:13.097]                         else {
[13:23:13.097]                           version <- NULL
[13:23:13.097]                         }
[13:23:13.097]                         if (!has_future || version < "1.8.0") {
[13:23:13.097]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.097]                             "", base::R.version$version.string), 
[13:23:13.097]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.097]                               "release", "version")], collapse = " "), 
[13:23:13.097]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.097]                             info)
[13:23:13.097]                           info <- base::paste(info, collapse = "; ")
[13:23:13.097]                           if (!has_future) {
[13:23:13.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.097]                               info)
[13:23:13.097]                           }
[13:23:13.097]                           else {
[13:23:13.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.097]                               info, version)
[13:23:13.097]                           }
[13:23:13.097]                           base::stop(msg)
[13:23:13.097]                         }
[13:23:13.097]                       })
[13:23:13.097]                     }
[13:23:13.097]                     base::local({
[13:23:13.097]                       for (pkg in "stats") {
[13:23:13.097]                         base::loadNamespace(pkg)
[13:23:13.097]                         base::library(pkg, character.only = TRUE)
[13:23:13.097]                       }
[13:23:13.097]                     })
[13:23:13.097]                   }
[13:23:13.097]                   options(future.plan = NULL)
[13:23:13.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.097]                 }
[13:23:13.097]                 ...future.workdir <- getwd()
[13:23:13.097]             }
[13:23:13.097]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.097]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.097]         }
[13:23:13.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.097]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.097]             base::names(...future.oldOptions))
[13:23:13.097]     }
[13:23:13.097]     if (FALSE) {
[13:23:13.097]     }
[13:23:13.097]     else {
[13:23:13.097]         if (TRUE) {
[13:23:13.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.097]                 open = "w")
[13:23:13.097]         }
[13:23:13.097]         else {
[13:23:13.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.097]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.097]         }
[13:23:13.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.097]             base::sink(type = "output", split = FALSE)
[13:23:13.097]             base::close(...future.stdout)
[13:23:13.097]         }, add = TRUE)
[13:23:13.097]     }
[13:23:13.097]     ...future.frame <- base::sys.nframe()
[13:23:13.097]     ...future.conditions <- base::list()
[13:23:13.097]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.097]     if (FALSE) {
[13:23:13.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.097]     }
[13:23:13.097]     ...future.result <- base::tryCatch({
[13:23:13.097]         base::withCallingHandlers({
[13:23:13.097]             ...future.value <- base::withVisible(base::local({
[13:23:13.097]                 lm(weight ~ group - 1)
[13:23:13.097]             }))
[13:23:13.097]             future::FutureResult(value = ...future.value$value, 
[13:23:13.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.097]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.097]                     ...future.globalenv.names))
[13:23:13.097]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.097]         }, condition = base::local({
[13:23:13.097]             c <- base::c
[13:23:13.097]             inherits <- base::inherits
[13:23:13.097]             invokeRestart <- base::invokeRestart
[13:23:13.097]             length <- base::length
[13:23:13.097]             list <- base::list
[13:23:13.097]             seq.int <- base::seq.int
[13:23:13.097]             signalCondition <- base::signalCondition
[13:23:13.097]             sys.calls <- base::sys.calls
[13:23:13.097]             `[[` <- base::`[[`
[13:23:13.097]             `+` <- base::`+`
[13:23:13.097]             `<<-` <- base::`<<-`
[13:23:13.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.097]                   3L)]
[13:23:13.097]             }
[13:23:13.097]             function(cond) {
[13:23:13.097]                 is_error <- inherits(cond, "error")
[13:23:13.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.097]                   NULL)
[13:23:13.097]                 if (is_error) {
[13:23:13.097]                   sessionInformation <- function() {
[13:23:13.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.097]                       search = base::search(), system = base::Sys.info())
[13:23:13.097]                   }
[13:23:13.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.097]                     cond$call), session = sessionInformation(), 
[13:23:13.097]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.097]                   signalCondition(cond)
[13:23:13.097]                 }
[13:23:13.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.097]                 "immediateCondition"))) {
[13:23:13.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.097]                   if (TRUE && !signal) {
[13:23:13.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.097]                     {
[13:23:13.097]                       inherits <- base::inherits
[13:23:13.097]                       invokeRestart <- base::invokeRestart
[13:23:13.097]                       is.null <- base::is.null
[13:23:13.097]                       muffled <- FALSE
[13:23:13.097]                       if (inherits(cond, "message")) {
[13:23:13.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.097]                         if (muffled) 
[13:23:13.097]                           invokeRestart("muffleMessage")
[13:23:13.097]                       }
[13:23:13.097]                       else if (inherits(cond, "warning")) {
[13:23:13.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.097]                         if (muffled) 
[13:23:13.097]                           invokeRestart("muffleWarning")
[13:23:13.097]                       }
[13:23:13.097]                       else if (inherits(cond, "condition")) {
[13:23:13.097]                         if (!is.null(pattern)) {
[13:23:13.097]                           computeRestarts <- base::computeRestarts
[13:23:13.097]                           grepl <- base::grepl
[13:23:13.097]                           restarts <- computeRestarts(cond)
[13:23:13.097]                           for (restart in restarts) {
[13:23:13.097]                             name <- restart$name
[13:23:13.097]                             if (is.null(name)) 
[13:23:13.097]                               next
[13:23:13.097]                             if (!grepl(pattern, name)) 
[13:23:13.097]                               next
[13:23:13.097]                             invokeRestart(restart)
[13:23:13.097]                             muffled <- TRUE
[13:23:13.097]                             break
[13:23:13.097]                           }
[13:23:13.097]                         }
[13:23:13.097]                       }
[13:23:13.097]                       invisible(muffled)
[13:23:13.097]                     }
[13:23:13.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.097]                   }
[13:23:13.097]                 }
[13:23:13.097]                 else {
[13:23:13.097]                   if (TRUE) {
[13:23:13.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.097]                     {
[13:23:13.097]                       inherits <- base::inherits
[13:23:13.097]                       invokeRestart <- base::invokeRestart
[13:23:13.097]                       is.null <- base::is.null
[13:23:13.097]                       muffled <- FALSE
[13:23:13.097]                       if (inherits(cond, "message")) {
[13:23:13.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.097]                         if (muffled) 
[13:23:13.097]                           invokeRestart("muffleMessage")
[13:23:13.097]                       }
[13:23:13.097]                       else if (inherits(cond, "warning")) {
[13:23:13.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.097]                         if (muffled) 
[13:23:13.097]                           invokeRestart("muffleWarning")
[13:23:13.097]                       }
[13:23:13.097]                       else if (inherits(cond, "condition")) {
[13:23:13.097]                         if (!is.null(pattern)) {
[13:23:13.097]                           computeRestarts <- base::computeRestarts
[13:23:13.097]                           grepl <- base::grepl
[13:23:13.097]                           restarts <- computeRestarts(cond)
[13:23:13.097]                           for (restart in restarts) {
[13:23:13.097]                             name <- restart$name
[13:23:13.097]                             if (is.null(name)) 
[13:23:13.097]                               next
[13:23:13.097]                             if (!grepl(pattern, name)) 
[13:23:13.097]                               next
[13:23:13.097]                             invokeRestart(restart)
[13:23:13.097]                             muffled <- TRUE
[13:23:13.097]                             break
[13:23:13.097]                           }
[13:23:13.097]                         }
[13:23:13.097]                       }
[13:23:13.097]                       invisible(muffled)
[13:23:13.097]                     }
[13:23:13.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.097]                   }
[13:23:13.097]                 }
[13:23:13.097]             }
[13:23:13.097]         }))
[13:23:13.097]     }, error = function(ex) {
[13:23:13.097]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.097]                 ...future.rng), started = ...future.startTime, 
[13:23:13.097]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.097]             version = "1.8"), class = "FutureResult")
[13:23:13.097]     }, finally = {
[13:23:13.097]         if (!identical(...future.workdir, getwd())) 
[13:23:13.097]             setwd(...future.workdir)
[13:23:13.097]         {
[13:23:13.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.097]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.097]             }
[13:23:13.097]             base::options(...future.oldOptions)
[13:23:13.097]             if (.Platform$OS.type == "windows") {
[13:23:13.097]                 old_names <- names(...future.oldEnvVars)
[13:23:13.097]                 envs <- base::Sys.getenv()
[13:23:13.097]                 names <- names(envs)
[13:23:13.097]                 common <- intersect(names, old_names)
[13:23:13.097]                 added <- setdiff(names, old_names)
[13:23:13.097]                 removed <- setdiff(old_names, names)
[13:23:13.097]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.097]                   envs[common]]
[13:23:13.097]                 NAMES <- toupper(changed)
[13:23:13.097]                 args <- list()
[13:23:13.097]                 for (kk in seq_along(NAMES)) {
[13:23:13.097]                   name <- changed[[kk]]
[13:23:13.097]                   NAME <- NAMES[[kk]]
[13:23:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.097]                     next
[13:23:13.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.097]                 }
[13:23:13.097]                 NAMES <- toupper(added)
[13:23:13.097]                 for (kk in seq_along(NAMES)) {
[13:23:13.097]                   name <- added[[kk]]
[13:23:13.097]                   NAME <- NAMES[[kk]]
[13:23:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.097]                     next
[13:23:13.097]                   args[[name]] <- ""
[13:23:13.097]                 }
[13:23:13.097]                 NAMES <- toupper(removed)
[13:23:13.097]                 for (kk in seq_along(NAMES)) {
[13:23:13.097]                   name <- removed[[kk]]
[13:23:13.097]                   NAME <- NAMES[[kk]]
[13:23:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.097]                     next
[13:23:13.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.097]                 }
[13:23:13.097]                 if (length(args) > 0) 
[13:23:13.097]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.097]             }
[13:23:13.097]             else {
[13:23:13.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.097]             }
[13:23:13.097]             {
[13:23:13.097]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.097]                   0L) {
[13:23:13.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.097]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.097]                   base::options(opts)
[13:23:13.097]                 }
[13:23:13.097]                 {
[13:23:13.097]                   {
[13:23:13.097]                     NULL
[13:23:13.097]                     RNGkind("Mersenne-Twister")
[13:23:13.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.097]                       inherits = FALSE)
[13:23:13.097]                   }
[13:23:13.097]                   options(future.plan = NULL)
[13:23:13.097]                   if (is.na(NA_character_)) 
[13:23:13.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.097]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.097]                   {
[13:23:13.097]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.097]                     if (!future$lazy) 
[13:23:13.097]                       future <- run(future)
[13:23:13.097]                     invisible(future)
[13:23:13.097]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.097]                 }
[13:23:13.097]             }
[13:23:13.097]         }
[13:23:13.097]     })
[13:23:13.097]     if (TRUE) {
[13:23:13.097]         base::sink(type = "output", split = FALSE)
[13:23:13.097]         if (TRUE) {
[13:23:13.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.097]         }
[13:23:13.097]         else {
[13:23:13.097]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.097]         }
[13:23:13.097]         base::close(...future.stdout)
[13:23:13.097]         ...future.stdout <- NULL
[13:23:13.097]     }
[13:23:13.097]     ...future.result$conditions <- ...future.conditions
[13:23:13.097]     ...future.result$finished <- base::Sys.time()
[13:23:13.097]     ...future.result
[13:23:13.097] }
[13:23:13.099] assign_globals() ...
[13:23:13.099] List of 2
[13:23:13.099]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.099]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.099]  - attr(*, "where")=List of 2
[13:23:13.099]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.099]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.099]  - attr(*, "resolved")= logi FALSE
[13:23:13.099]  - attr(*, "total_size")= num 896
[13:23:13.099]  - attr(*, "already-done")= logi TRUE
[13:23:13.102] - copied ‘weight’ to environment
[13:23:13.102] - copied ‘group’ to environment
[13:23:13.102] assign_globals() ... done
[13:23:13.103] plan(): Setting new future strategy stack:
[13:23:13.103] List of future strategies:
[13:23:13.103] 1. sequential:
[13:23:13.103]    - args: function (..., envir = parent.frame())
[13:23:13.103]    - tweaked: FALSE
[13:23:13.103]    - call: NULL
[13:23:13.103] plan(): nbrOfWorkers() = 1
[13:23:13.105] plan(): Setting new future strategy stack:
[13:23:13.105] List of future strategies:
[13:23:13.105] 1. sequential:
[13:23:13.105]    - args: function (..., envir = parent.frame())
[13:23:13.105]    - tweaked: FALSE
[13:23:13.105]    - call: plan(strategy)
[13:23:13.106] plan(): nbrOfWorkers() = 1
[13:23:13.106] SequentialFuture started (and completed)
[13:23:13.106] - Launch lazy future ... done
[13:23:13.106] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.110] getGlobalsAndPackages() ...
[13:23:13.110] Searching for globals...
[13:23:13.112] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.112] Searching for globals ... DONE
[13:23:13.112] Resolving globals: FALSE
[13:23:13.112] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.113] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.113] - globals: [2] ‘weight’, ‘group’
[13:23:13.113] - packages: [1] ‘stats’
[13:23:13.113] getGlobalsAndPackages() ... DONE
[13:23:13.114] run() for ‘Future’ ...
[13:23:13.114] - state: ‘created’
[13:23:13.114] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.114] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.114]   - Field: ‘label’
[13:23:13.115]   - Field: ‘local’
[13:23:13.115]   - Field: ‘owner’
[13:23:13.115]   - Field: ‘envir’
[13:23:13.115]   - Field: ‘packages’
[13:23:13.115]   - Field: ‘gc’
[13:23:13.115]   - Field: ‘conditions’
[13:23:13.115]   - Field: ‘expr’
[13:23:13.115]   - Field: ‘uuid’
[13:23:13.115]   - Field: ‘seed’
[13:23:13.115]   - Field: ‘version’
[13:23:13.116]   - Field: ‘result’
[13:23:13.116]   - Field: ‘asynchronous’
[13:23:13.116]   - Field: ‘calls’
[13:23:13.116]   - Field: ‘globals’
[13:23:13.116]   - Field: ‘stdout’
[13:23:13.116]   - Field: ‘earlySignal’
[13:23:13.116]   - Field: ‘lazy’
[13:23:13.116]   - Field: ‘state’
[13:23:13.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.116] - Launch lazy future ...
[13:23:13.117] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.117] Packages needed by future strategies (n = 0): <none>
[13:23:13.117] {
[13:23:13.117]     {
[13:23:13.117]         {
[13:23:13.117]             ...future.startTime <- base::Sys.time()
[13:23:13.117]             {
[13:23:13.117]                 {
[13:23:13.117]                   {
[13:23:13.117]                     {
[13:23:13.117]                       base::local({
[13:23:13.117]                         has_future <- base::requireNamespace("future", 
[13:23:13.117]                           quietly = TRUE)
[13:23:13.117]                         if (has_future) {
[13:23:13.117]                           ns <- base::getNamespace("future")
[13:23:13.117]                           version <- ns[[".package"]][["version"]]
[13:23:13.117]                           if (is.null(version)) 
[13:23:13.117]                             version <- utils::packageVersion("future")
[13:23:13.117]                         }
[13:23:13.117]                         else {
[13:23:13.117]                           version <- NULL
[13:23:13.117]                         }
[13:23:13.117]                         if (!has_future || version < "1.8.0") {
[13:23:13.117]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.117]                             "", base::R.version$version.string), 
[13:23:13.117]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.117]                               "release", "version")], collapse = " "), 
[13:23:13.117]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.117]                             info)
[13:23:13.117]                           info <- base::paste(info, collapse = "; ")
[13:23:13.117]                           if (!has_future) {
[13:23:13.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.117]                               info)
[13:23:13.117]                           }
[13:23:13.117]                           else {
[13:23:13.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.117]                               info, version)
[13:23:13.117]                           }
[13:23:13.117]                           base::stop(msg)
[13:23:13.117]                         }
[13:23:13.117]                       })
[13:23:13.117]                     }
[13:23:13.117]                     base::local({
[13:23:13.117]                       for (pkg in "stats") {
[13:23:13.117]                         base::loadNamespace(pkg)
[13:23:13.117]                         base::library(pkg, character.only = TRUE)
[13:23:13.117]                       }
[13:23:13.117]                     })
[13:23:13.117]                   }
[13:23:13.117]                   options(future.plan = NULL)
[13:23:13.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.117]                 }
[13:23:13.117]                 ...future.workdir <- getwd()
[13:23:13.117]             }
[13:23:13.117]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.117]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.117]         }
[13:23:13.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.117]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.117]             base::names(...future.oldOptions))
[13:23:13.117]     }
[13:23:13.117]     if (FALSE) {
[13:23:13.117]     }
[13:23:13.117]     else {
[13:23:13.117]         if (TRUE) {
[13:23:13.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.117]                 open = "w")
[13:23:13.117]         }
[13:23:13.117]         else {
[13:23:13.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.117]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.117]         }
[13:23:13.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.117]             base::sink(type = "output", split = FALSE)
[13:23:13.117]             base::close(...future.stdout)
[13:23:13.117]         }, add = TRUE)
[13:23:13.117]     }
[13:23:13.117]     ...future.frame <- base::sys.nframe()
[13:23:13.117]     ...future.conditions <- base::list()
[13:23:13.117]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.117]     if (FALSE) {
[13:23:13.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.117]     }
[13:23:13.117]     ...future.result <- base::tryCatch({
[13:23:13.117]         base::withCallingHandlers({
[13:23:13.117]             ...future.value <- base::withVisible(base::local({
[13:23:13.117]                 lm(weight ~ group - 1)
[13:23:13.117]             }))
[13:23:13.117]             future::FutureResult(value = ...future.value$value, 
[13:23:13.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.117]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.117]                     ...future.globalenv.names))
[13:23:13.117]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.117]         }, condition = base::local({
[13:23:13.117]             c <- base::c
[13:23:13.117]             inherits <- base::inherits
[13:23:13.117]             invokeRestart <- base::invokeRestart
[13:23:13.117]             length <- base::length
[13:23:13.117]             list <- base::list
[13:23:13.117]             seq.int <- base::seq.int
[13:23:13.117]             signalCondition <- base::signalCondition
[13:23:13.117]             sys.calls <- base::sys.calls
[13:23:13.117]             `[[` <- base::`[[`
[13:23:13.117]             `+` <- base::`+`
[13:23:13.117]             `<<-` <- base::`<<-`
[13:23:13.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.117]                   3L)]
[13:23:13.117]             }
[13:23:13.117]             function(cond) {
[13:23:13.117]                 is_error <- inherits(cond, "error")
[13:23:13.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.117]                   NULL)
[13:23:13.117]                 if (is_error) {
[13:23:13.117]                   sessionInformation <- function() {
[13:23:13.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.117]                       search = base::search(), system = base::Sys.info())
[13:23:13.117]                   }
[13:23:13.117]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.117]                     cond$call), session = sessionInformation(), 
[13:23:13.117]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.117]                   signalCondition(cond)
[13:23:13.117]                 }
[13:23:13.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.117]                 "immediateCondition"))) {
[13:23:13.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.117]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.117]                   if (TRUE && !signal) {
[13:23:13.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.117]                     {
[13:23:13.117]                       inherits <- base::inherits
[13:23:13.117]                       invokeRestart <- base::invokeRestart
[13:23:13.117]                       is.null <- base::is.null
[13:23:13.117]                       muffled <- FALSE
[13:23:13.117]                       if (inherits(cond, "message")) {
[13:23:13.117]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.117]                         if (muffled) 
[13:23:13.117]                           invokeRestart("muffleMessage")
[13:23:13.117]                       }
[13:23:13.117]                       else if (inherits(cond, "warning")) {
[13:23:13.117]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.117]                         if (muffled) 
[13:23:13.117]                           invokeRestart("muffleWarning")
[13:23:13.117]                       }
[13:23:13.117]                       else if (inherits(cond, "condition")) {
[13:23:13.117]                         if (!is.null(pattern)) {
[13:23:13.117]                           computeRestarts <- base::computeRestarts
[13:23:13.117]                           grepl <- base::grepl
[13:23:13.117]                           restarts <- computeRestarts(cond)
[13:23:13.117]                           for (restart in restarts) {
[13:23:13.117]                             name <- restart$name
[13:23:13.117]                             if (is.null(name)) 
[13:23:13.117]                               next
[13:23:13.117]                             if (!grepl(pattern, name)) 
[13:23:13.117]                               next
[13:23:13.117]                             invokeRestart(restart)
[13:23:13.117]                             muffled <- TRUE
[13:23:13.117]                             break
[13:23:13.117]                           }
[13:23:13.117]                         }
[13:23:13.117]                       }
[13:23:13.117]                       invisible(muffled)
[13:23:13.117]                     }
[13:23:13.117]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.117]                   }
[13:23:13.117]                 }
[13:23:13.117]                 else {
[13:23:13.117]                   if (TRUE) {
[13:23:13.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.117]                     {
[13:23:13.117]                       inherits <- base::inherits
[13:23:13.117]                       invokeRestart <- base::invokeRestart
[13:23:13.117]                       is.null <- base::is.null
[13:23:13.117]                       muffled <- FALSE
[13:23:13.117]                       if (inherits(cond, "message")) {
[13:23:13.117]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.117]                         if (muffled) 
[13:23:13.117]                           invokeRestart("muffleMessage")
[13:23:13.117]                       }
[13:23:13.117]                       else if (inherits(cond, "warning")) {
[13:23:13.117]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.117]                         if (muffled) 
[13:23:13.117]                           invokeRestart("muffleWarning")
[13:23:13.117]                       }
[13:23:13.117]                       else if (inherits(cond, "condition")) {
[13:23:13.117]                         if (!is.null(pattern)) {
[13:23:13.117]                           computeRestarts <- base::computeRestarts
[13:23:13.117]                           grepl <- base::grepl
[13:23:13.117]                           restarts <- computeRestarts(cond)
[13:23:13.117]                           for (restart in restarts) {
[13:23:13.117]                             name <- restart$name
[13:23:13.117]                             if (is.null(name)) 
[13:23:13.117]                               next
[13:23:13.117]                             if (!grepl(pattern, name)) 
[13:23:13.117]                               next
[13:23:13.117]                             invokeRestart(restart)
[13:23:13.117]                             muffled <- TRUE
[13:23:13.117]                             break
[13:23:13.117]                           }
[13:23:13.117]                         }
[13:23:13.117]                       }
[13:23:13.117]                       invisible(muffled)
[13:23:13.117]                     }
[13:23:13.117]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.117]                   }
[13:23:13.117]                 }
[13:23:13.117]             }
[13:23:13.117]         }))
[13:23:13.117]     }, error = function(ex) {
[13:23:13.117]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.117]                 ...future.rng), started = ...future.startTime, 
[13:23:13.117]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.117]             version = "1.8"), class = "FutureResult")
[13:23:13.117]     }, finally = {
[13:23:13.117]         if (!identical(...future.workdir, getwd())) 
[13:23:13.117]             setwd(...future.workdir)
[13:23:13.117]         {
[13:23:13.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.117]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.117]             }
[13:23:13.117]             base::options(...future.oldOptions)
[13:23:13.117]             if (.Platform$OS.type == "windows") {
[13:23:13.117]                 old_names <- names(...future.oldEnvVars)
[13:23:13.117]                 envs <- base::Sys.getenv()
[13:23:13.117]                 names <- names(envs)
[13:23:13.117]                 common <- intersect(names, old_names)
[13:23:13.117]                 added <- setdiff(names, old_names)
[13:23:13.117]                 removed <- setdiff(old_names, names)
[13:23:13.117]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.117]                   envs[common]]
[13:23:13.117]                 NAMES <- toupper(changed)
[13:23:13.117]                 args <- list()
[13:23:13.117]                 for (kk in seq_along(NAMES)) {
[13:23:13.117]                   name <- changed[[kk]]
[13:23:13.117]                   NAME <- NAMES[[kk]]
[13:23:13.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.117]                     next
[13:23:13.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.117]                 }
[13:23:13.117]                 NAMES <- toupper(added)
[13:23:13.117]                 for (kk in seq_along(NAMES)) {
[13:23:13.117]                   name <- added[[kk]]
[13:23:13.117]                   NAME <- NAMES[[kk]]
[13:23:13.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.117]                     next
[13:23:13.117]                   args[[name]] <- ""
[13:23:13.117]                 }
[13:23:13.117]                 NAMES <- toupper(removed)
[13:23:13.117]                 for (kk in seq_along(NAMES)) {
[13:23:13.117]                   name <- removed[[kk]]
[13:23:13.117]                   NAME <- NAMES[[kk]]
[13:23:13.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.117]                     next
[13:23:13.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.117]                 }
[13:23:13.117]                 if (length(args) > 0) 
[13:23:13.117]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.117]             }
[13:23:13.117]             else {
[13:23:13.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.117]             }
[13:23:13.117]             {
[13:23:13.117]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.117]                   0L) {
[13:23:13.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.117]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.117]                   base::options(opts)
[13:23:13.117]                 }
[13:23:13.117]                 {
[13:23:13.117]                   {
[13:23:13.117]                     NULL
[13:23:13.117]                     RNGkind("Mersenne-Twister")
[13:23:13.117]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.117]                       inherits = FALSE)
[13:23:13.117]                   }
[13:23:13.117]                   options(future.plan = NULL)
[13:23:13.117]                   if (is.na(NA_character_)) 
[13:23:13.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.117]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.117]                   {
[13:23:13.117]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.117]                     if (!future$lazy) 
[13:23:13.117]                       future <- run(future)
[13:23:13.117]                     invisible(future)
[13:23:13.117]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.117]                 }
[13:23:13.117]             }
[13:23:13.117]         }
[13:23:13.117]     })
[13:23:13.117]     if (TRUE) {
[13:23:13.117]         base::sink(type = "output", split = FALSE)
[13:23:13.117]         if (TRUE) {
[13:23:13.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.117]         }
[13:23:13.117]         else {
[13:23:13.117]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.117]         }
[13:23:13.117]         base::close(...future.stdout)
[13:23:13.117]         ...future.stdout <- NULL
[13:23:13.117]     }
[13:23:13.117]     ...future.result$conditions <- ...future.conditions
[13:23:13.117]     ...future.result$finished <- base::Sys.time()
[13:23:13.117]     ...future.result
[13:23:13.117] }
[13:23:13.119] assign_globals() ...
[13:23:13.119] List of 2
[13:23:13.119]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.119]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.119]  - attr(*, "where")=List of 2
[13:23:13.119]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.119]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.119]  - attr(*, "resolved")= logi FALSE
[13:23:13.119]  - attr(*, "total_size")= num 896
[13:23:13.119]  - attr(*, "already-done")= logi TRUE
[13:23:13.123] - copied ‘weight’ to environment
[13:23:13.123] - copied ‘group’ to environment
[13:23:13.123] assign_globals() ... done
[13:23:13.123] plan(): Setting new future strategy stack:
[13:23:13.123] List of future strategies:
[13:23:13.123] 1. sequential:
[13:23:13.123]    - args: function (..., envir = parent.frame())
[13:23:13.123]    - tweaked: FALSE
[13:23:13.123]    - call: NULL
[13:23:13.124] plan(): nbrOfWorkers() = 1
[13:23:13.125] plan(): Setting new future strategy stack:
[13:23:13.126] List of future strategies:
[13:23:13.126] 1. sequential:
[13:23:13.126]    - args: function (..., envir = parent.frame())
[13:23:13.126]    - tweaked: FALSE
[13:23:13.126]    - call: plan(strategy)
[13:23:13.126] plan(): nbrOfWorkers() = 1
[13:23:13.126] SequentialFuture started (and completed)
[13:23:13.126] - Launch lazy future ... done
[13:23:13.126] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:23:13.128] getGlobalsAndPackages() ...
[13:23:13.128] Searching for globals...
[13:23:13.130] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:13.130] Searching for globals ... DONE
[13:23:13.130] Resolving globals: FALSE
[13:23:13.130] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:13.131] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:13.131] - globals: [1] ‘x’
[13:23:13.131] - packages: [1] ‘stats’
[13:23:13.131] getGlobalsAndPackages() ... DONE
[13:23:13.131] run() for ‘Future’ ...
[13:23:13.131] - state: ‘created’
[13:23:13.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.132]   - Field: ‘label’
[13:23:13.132]   - Field: ‘local’
[13:23:13.132]   - Field: ‘owner’
[13:23:13.132]   - Field: ‘envir’
[13:23:13.133]   - Field: ‘packages’
[13:23:13.133]   - Field: ‘gc’
[13:23:13.133]   - Field: ‘conditions’
[13:23:13.133]   - Field: ‘expr’
[13:23:13.133]   - Field: ‘uuid’
[13:23:13.133]   - Field: ‘seed’
[13:23:13.133]   - Field: ‘version’
[13:23:13.133]   - Field: ‘result’
[13:23:13.133]   - Field: ‘asynchronous’
[13:23:13.133]   - Field: ‘calls’
[13:23:13.135]   - Field: ‘globals’
[13:23:13.136]   - Field: ‘stdout’
[13:23:13.136]   - Field: ‘earlySignal’
[13:23:13.136]   - Field: ‘lazy’
[13:23:13.136]   - Field: ‘state’
[13:23:13.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.136] - Launch lazy future ...
[13:23:13.136] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.137] Packages needed by future strategies (n = 0): <none>
[13:23:13.137] {
[13:23:13.137]     {
[13:23:13.137]         {
[13:23:13.137]             ...future.startTime <- base::Sys.time()
[13:23:13.137]             {
[13:23:13.137]                 {
[13:23:13.137]                   {
[13:23:13.137]                     {
[13:23:13.137]                       base::local({
[13:23:13.137]                         has_future <- base::requireNamespace("future", 
[13:23:13.137]                           quietly = TRUE)
[13:23:13.137]                         if (has_future) {
[13:23:13.137]                           ns <- base::getNamespace("future")
[13:23:13.137]                           version <- ns[[".package"]][["version"]]
[13:23:13.137]                           if (is.null(version)) 
[13:23:13.137]                             version <- utils::packageVersion("future")
[13:23:13.137]                         }
[13:23:13.137]                         else {
[13:23:13.137]                           version <- NULL
[13:23:13.137]                         }
[13:23:13.137]                         if (!has_future || version < "1.8.0") {
[13:23:13.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.137]                             "", base::R.version$version.string), 
[13:23:13.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.137]                               "release", "version")], collapse = " "), 
[13:23:13.137]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.137]                             info)
[13:23:13.137]                           info <- base::paste(info, collapse = "; ")
[13:23:13.137]                           if (!has_future) {
[13:23:13.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.137]                               info)
[13:23:13.137]                           }
[13:23:13.137]                           else {
[13:23:13.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.137]                               info, version)
[13:23:13.137]                           }
[13:23:13.137]                           base::stop(msg)
[13:23:13.137]                         }
[13:23:13.137]                       })
[13:23:13.137]                     }
[13:23:13.137]                     base::local({
[13:23:13.137]                       for (pkg in "stats") {
[13:23:13.137]                         base::loadNamespace(pkg)
[13:23:13.137]                         base::library(pkg, character.only = TRUE)
[13:23:13.137]                       }
[13:23:13.137]                     })
[13:23:13.137]                   }
[13:23:13.137]                   options(future.plan = NULL)
[13:23:13.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.137]                 }
[13:23:13.137]                 ...future.workdir <- getwd()
[13:23:13.137]             }
[13:23:13.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.137]         }
[13:23:13.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.137]             base::names(...future.oldOptions))
[13:23:13.137]     }
[13:23:13.137]     if (FALSE) {
[13:23:13.137]     }
[13:23:13.137]     else {
[13:23:13.137]         if (TRUE) {
[13:23:13.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.137]                 open = "w")
[13:23:13.137]         }
[13:23:13.137]         else {
[13:23:13.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.137]         }
[13:23:13.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.137]             base::sink(type = "output", split = FALSE)
[13:23:13.137]             base::close(...future.stdout)
[13:23:13.137]         }, add = TRUE)
[13:23:13.137]     }
[13:23:13.137]     ...future.frame <- base::sys.nframe()
[13:23:13.137]     ...future.conditions <- base::list()
[13:23:13.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.137]     if (FALSE) {
[13:23:13.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.137]     }
[13:23:13.137]     ...future.result <- base::tryCatch({
[13:23:13.137]         base::withCallingHandlers({
[13:23:13.137]             ...future.value <- base::withVisible(base::local({
[13:23:13.137]                 xtabs(~x)
[13:23:13.137]             }))
[13:23:13.137]             future::FutureResult(value = ...future.value$value, 
[13:23:13.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.137]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.137]                     ...future.globalenv.names))
[13:23:13.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.137]         }, condition = base::local({
[13:23:13.137]             c <- base::c
[13:23:13.137]             inherits <- base::inherits
[13:23:13.137]             invokeRestart <- base::invokeRestart
[13:23:13.137]             length <- base::length
[13:23:13.137]             list <- base::list
[13:23:13.137]             seq.int <- base::seq.int
[13:23:13.137]             signalCondition <- base::signalCondition
[13:23:13.137]             sys.calls <- base::sys.calls
[13:23:13.137]             `[[` <- base::`[[`
[13:23:13.137]             `+` <- base::`+`
[13:23:13.137]             `<<-` <- base::`<<-`
[13:23:13.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.137]                   3L)]
[13:23:13.137]             }
[13:23:13.137]             function(cond) {
[13:23:13.137]                 is_error <- inherits(cond, "error")
[13:23:13.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.137]                   NULL)
[13:23:13.137]                 if (is_error) {
[13:23:13.137]                   sessionInformation <- function() {
[13:23:13.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.137]                       search = base::search(), system = base::Sys.info())
[13:23:13.137]                   }
[13:23:13.137]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.137]                     cond$call), session = sessionInformation(), 
[13:23:13.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.137]                   signalCondition(cond)
[13:23:13.137]                 }
[13:23:13.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.137]                 "immediateCondition"))) {
[13:23:13.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.137]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.137]                   if (TRUE && !signal) {
[13:23:13.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.137]                     {
[13:23:13.137]                       inherits <- base::inherits
[13:23:13.137]                       invokeRestart <- base::invokeRestart
[13:23:13.137]                       is.null <- base::is.null
[13:23:13.137]                       muffled <- FALSE
[13:23:13.137]                       if (inherits(cond, "message")) {
[13:23:13.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.137]                         if (muffled) 
[13:23:13.137]                           invokeRestart("muffleMessage")
[13:23:13.137]                       }
[13:23:13.137]                       else if (inherits(cond, "warning")) {
[13:23:13.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.137]                         if (muffled) 
[13:23:13.137]                           invokeRestart("muffleWarning")
[13:23:13.137]                       }
[13:23:13.137]                       else if (inherits(cond, "condition")) {
[13:23:13.137]                         if (!is.null(pattern)) {
[13:23:13.137]                           computeRestarts <- base::computeRestarts
[13:23:13.137]                           grepl <- base::grepl
[13:23:13.137]                           restarts <- computeRestarts(cond)
[13:23:13.137]                           for (restart in restarts) {
[13:23:13.137]                             name <- restart$name
[13:23:13.137]                             if (is.null(name)) 
[13:23:13.137]                               next
[13:23:13.137]                             if (!grepl(pattern, name)) 
[13:23:13.137]                               next
[13:23:13.137]                             invokeRestart(restart)
[13:23:13.137]                             muffled <- TRUE
[13:23:13.137]                             break
[13:23:13.137]                           }
[13:23:13.137]                         }
[13:23:13.137]                       }
[13:23:13.137]                       invisible(muffled)
[13:23:13.137]                     }
[13:23:13.137]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.137]                   }
[13:23:13.137]                 }
[13:23:13.137]                 else {
[13:23:13.137]                   if (TRUE) {
[13:23:13.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.137]                     {
[13:23:13.137]                       inherits <- base::inherits
[13:23:13.137]                       invokeRestart <- base::invokeRestart
[13:23:13.137]                       is.null <- base::is.null
[13:23:13.137]                       muffled <- FALSE
[13:23:13.137]                       if (inherits(cond, "message")) {
[13:23:13.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.137]                         if (muffled) 
[13:23:13.137]                           invokeRestart("muffleMessage")
[13:23:13.137]                       }
[13:23:13.137]                       else if (inherits(cond, "warning")) {
[13:23:13.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.137]                         if (muffled) 
[13:23:13.137]                           invokeRestart("muffleWarning")
[13:23:13.137]                       }
[13:23:13.137]                       else if (inherits(cond, "condition")) {
[13:23:13.137]                         if (!is.null(pattern)) {
[13:23:13.137]                           computeRestarts <- base::computeRestarts
[13:23:13.137]                           grepl <- base::grepl
[13:23:13.137]                           restarts <- computeRestarts(cond)
[13:23:13.137]                           for (restart in restarts) {
[13:23:13.137]                             name <- restart$name
[13:23:13.137]                             if (is.null(name)) 
[13:23:13.137]                               next
[13:23:13.137]                             if (!grepl(pattern, name)) 
[13:23:13.137]                               next
[13:23:13.137]                             invokeRestart(restart)
[13:23:13.137]                             muffled <- TRUE
[13:23:13.137]                             break
[13:23:13.137]                           }
[13:23:13.137]                         }
[13:23:13.137]                       }
[13:23:13.137]                       invisible(muffled)
[13:23:13.137]                     }
[13:23:13.137]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.137]                   }
[13:23:13.137]                 }
[13:23:13.137]             }
[13:23:13.137]         }))
[13:23:13.137]     }, error = function(ex) {
[13:23:13.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.137]                 ...future.rng), started = ...future.startTime, 
[13:23:13.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.137]             version = "1.8"), class = "FutureResult")
[13:23:13.137]     }, finally = {
[13:23:13.137]         if (!identical(...future.workdir, getwd())) 
[13:23:13.137]             setwd(...future.workdir)
[13:23:13.137]         {
[13:23:13.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.137]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.137]             }
[13:23:13.137]             base::options(...future.oldOptions)
[13:23:13.137]             if (.Platform$OS.type == "windows") {
[13:23:13.137]                 old_names <- names(...future.oldEnvVars)
[13:23:13.137]                 envs <- base::Sys.getenv()
[13:23:13.137]                 names <- names(envs)
[13:23:13.137]                 common <- intersect(names, old_names)
[13:23:13.137]                 added <- setdiff(names, old_names)
[13:23:13.137]                 removed <- setdiff(old_names, names)
[13:23:13.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.137]                   envs[common]]
[13:23:13.137]                 NAMES <- toupper(changed)
[13:23:13.137]                 args <- list()
[13:23:13.137]                 for (kk in seq_along(NAMES)) {
[13:23:13.137]                   name <- changed[[kk]]
[13:23:13.137]                   NAME <- NAMES[[kk]]
[13:23:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.137]                     next
[13:23:13.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.137]                 }
[13:23:13.137]                 NAMES <- toupper(added)
[13:23:13.137]                 for (kk in seq_along(NAMES)) {
[13:23:13.137]                   name <- added[[kk]]
[13:23:13.137]                   NAME <- NAMES[[kk]]
[13:23:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.137]                     next
[13:23:13.137]                   args[[name]] <- ""
[13:23:13.137]                 }
[13:23:13.137]                 NAMES <- toupper(removed)
[13:23:13.137]                 for (kk in seq_along(NAMES)) {
[13:23:13.137]                   name <- removed[[kk]]
[13:23:13.137]                   NAME <- NAMES[[kk]]
[13:23:13.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.137]                     next
[13:23:13.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.137]                 }
[13:23:13.137]                 if (length(args) > 0) 
[13:23:13.137]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.137]             }
[13:23:13.137]             else {
[13:23:13.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.137]             }
[13:23:13.137]             {
[13:23:13.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.137]                   0L) {
[13:23:13.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.137]                   base::options(opts)
[13:23:13.137]                 }
[13:23:13.137]                 {
[13:23:13.137]                   {
[13:23:13.137]                     NULL
[13:23:13.137]                     RNGkind("Mersenne-Twister")
[13:23:13.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.137]                       inherits = FALSE)
[13:23:13.137]                   }
[13:23:13.137]                   options(future.plan = NULL)
[13:23:13.137]                   if (is.na(NA_character_)) 
[13:23:13.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.137]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.137]                   {
[13:23:13.137]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.137]                     if (!future$lazy) 
[13:23:13.137]                       future <- run(future)
[13:23:13.137]                     invisible(future)
[13:23:13.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.137]                 }
[13:23:13.137]             }
[13:23:13.137]         }
[13:23:13.137]     })
[13:23:13.137]     if (TRUE) {
[13:23:13.137]         base::sink(type = "output", split = FALSE)
[13:23:13.137]         if (TRUE) {
[13:23:13.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.137]         }
[13:23:13.137]         else {
[13:23:13.137]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.137]         }
[13:23:13.137]         base::close(...future.stdout)
[13:23:13.137]         ...future.stdout <- NULL
[13:23:13.137]     }
[13:23:13.137]     ...future.result$conditions <- ...future.conditions
[13:23:13.137]     ...future.result$finished <- base::Sys.time()
[13:23:13.137]     ...future.result
[13:23:13.137] }
[13:23:13.139] assign_globals() ...
[13:23:13.139] List of 1
[13:23:13.139]  $ x: num [1:5] 1 1 2 2 2
[13:23:13.139]  - attr(*, "where")=List of 1
[13:23:13.139]   ..$ x:<environment: R_EmptyEnv> 
[13:23:13.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.139]  - attr(*, "resolved")= logi FALSE
[13:23:13.139]  - attr(*, "total_size")= num 96
[13:23:13.139]  - attr(*, "already-done")= logi TRUE
[13:23:13.142] - copied ‘x’ to environment
[13:23:13.142] assign_globals() ... done
[13:23:13.142] plan(): Setting new future strategy stack:
[13:23:13.143] List of future strategies:
[13:23:13.143] 1. sequential:
[13:23:13.143]    - args: function (..., envir = parent.frame())
[13:23:13.143]    - tweaked: FALSE
[13:23:13.143]    - call: NULL
[13:23:13.143] plan(): nbrOfWorkers() = 1
[13:23:13.144] plan(): Setting new future strategy stack:
[13:23:13.144] List of future strategies:
[13:23:13.144] 1. sequential:
[13:23:13.144]    - args: function (..., envir = parent.frame())
[13:23:13.144]    - tweaked: FALSE
[13:23:13.144]    - call: plan(strategy)
[13:23:13.145] plan(): nbrOfWorkers() = 1
[13:23:13.145] SequentialFuture started (and completed)
[13:23:13.145] - Launch lazy future ... done
[13:23:13.145] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[13:23:13.146] getGlobalsAndPackages() ...
[13:23:13.146] Searching for globals...
[13:23:13.147] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:13.148] Searching for globals ... DONE
[13:23:13.148] Resolving globals: FALSE
[13:23:13.148] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:13.148] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:13.149] - globals: [1] ‘x’
[13:23:13.149] - packages: [1] ‘stats’
[13:23:13.149] getGlobalsAndPackages() ... DONE
[13:23:13.149] run() for ‘Future’ ...
[13:23:13.149] - state: ‘created’
[13:23:13.149] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.150] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.150] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.150]   - Field: ‘label’
[13:23:13.150]   - Field: ‘local’
[13:23:13.150]   - Field: ‘owner’
[13:23:13.150]   - Field: ‘envir’
[13:23:13.150]   - Field: ‘packages’
[13:23:13.150]   - Field: ‘gc’
[13:23:13.151]   - Field: ‘conditions’
[13:23:13.151]   - Field: ‘expr’
[13:23:13.151]   - Field: ‘uuid’
[13:23:13.151]   - Field: ‘seed’
[13:23:13.151]   - Field: ‘version’
[13:23:13.151]   - Field: ‘result’
[13:23:13.151]   - Field: ‘asynchronous’
[13:23:13.151]   - Field: ‘calls’
[13:23:13.151]   - Field: ‘globals’
[13:23:13.151]   - Field: ‘stdout’
[13:23:13.152]   - Field: ‘earlySignal’
[13:23:13.152]   - Field: ‘lazy’
[13:23:13.152]   - Field: ‘state’
[13:23:13.152] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.152] - Launch lazy future ...
[13:23:13.152] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.152] Packages needed by future strategies (n = 0): <none>
[13:23:13.153] {
[13:23:13.153]     {
[13:23:13.153]         {
[13:23:13.153]             ...future.startTime <- base::Sys.time()
[13:23:13.153]             {
[13:23:13.153]                 {
[13:23:13.153]                   {
[13:23:13.153]                     {
[13:23:13.153]                       base::local({
[13:23:13.153]                         has_future <- base::requireNamespace("future", 
[13:23:13.153]                           quietly = TRUE)
[13:23:13.153]                         if (has_future) {
[13:23:13.153]                           ns <- base::getNamespace("future")
[13:23:13.153]                           version <- ns[[".package"]][["version"]]
[13:23:13.153]                           if (is.null(version)) 
[13:23:13.153]                             version <- utils::packageVersion("future")
[13:23:13.153]                         }
[13:23:13.153]                         else {
[13:23:13.153]                           version <- NULL
[13:23:13.153]                         }
[13:23:13.153]                         if (!has_future || version < "1.8.0") {
[13:23:13.153]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.153]                             "", base::R.version$version.string), 
[13:23:13.153]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.153]                               "release", "version")], collapse = " "), 
[13:23:13.153]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.153]                             info)
[13:23:13.153]                           info <- base::paste(info, collapse = "; ")
[13:23:13.153]                           if (!has_future) {
[13:23:13.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.153]                               info)
[13:23:13.153]                           }
[13:23:13.153]                           else {
[13:23:13.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.153]                               info, version)
[13:23:13.153]                           }
[13:23:13.153]                           base::stop(msg)
[13:23:13.153]                         }
[13:23:13.153]                       })
[13:23:13.153]                     }
[13:23:13.153]                     base::local({
[13:23:13.153]                       for (pkg in "stats") {
[13:23:13.153]                         base::loadNamespace(pkg)
[13:23:13.153]                         base::library(pkg, character.only = TRUE)
[13:23:13.153]                       }
[13:23:13.153]                     })
[13:23:13.153]                   }
[13:23:13.153]                   options(future.plan = NULL)
[13:23:13.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.153]                 }
[13:23:13.153]                 ...future.workdir <- getwd()
[13:23:13.153]             }
[13:23:13.153]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.153]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.153]         }
[13:23:13.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.153]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.153]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.153]             base::names(...future.oldOptions))
[13:23:13.153]     }
[13:23:13.153]     if (FALSE) {
[13:23:13.153]     }
[13:23:13.153]     else {
[13:23:13.153]         if (TRUE) {
[13:23:13.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.153]                 open = "w")
[13:23:13.153]         }
[13:23:13.153]         else {
[13:23:13.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.153]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.153]         }
[13:23:13.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.153]             base::sink(type = "output", split = FALSE)
[13:23:13.153]             base::close(...future.stdout)
[13:23:13.153]         }, add = TRUE)
[13:23:13.153]     }
[13:23:13.153]     ...future.frame <- base::sys.nframe()
[13:23:13.153]     ...future.conditions <- base::list()
[13:23:13.153]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.153]     if (FALSE) {
[13:23:13.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.153]     }
[13:23:13.153]     ...future.result <- base::tryCatch({
[13:23:13.153]         base::withCallingHandlers({
[13:23:13.153]             ...future.value <- base::withVisible(base::local({
[13:23:13.153]                 xtabs(~x)
[13:23:13.153]             }))
[13:23:13.153]             future::FutureResult(value = ...future.value$value, 
[13:23:13.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.153]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.153]                     ...future.globalenv.names))
[13:23:13.153]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.153]         }, condition = base::local({
[13:23:13.153]             c <- base::c
[13:23:13.153]             inherits <- base::inherits
[13:23:13.153]             invokeRestart <- base::invokeRestart
[13:23:13.153]             length <- base::length
[13:23:13.153]             list <- base::list
[13:23:13.153]             seq.int <- base::seq.int
[13:23:13.153]             signalCondition <- base::signalCondition
[13:23:13.153]             sys.calls <- base::sys.calls
[13:23:13.153]             `[[` <- base::`[[`
[13:23:13.153]             `+` <- base::`+`
[13:23:13.153]             `<<-` <- base::`<<-`
[13:23:13.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.153]                   3L)]
[13:23:13.153]             }
[13:23:13.153]             function(cond) {
[13:23:13.153]                 is_error <- inherits(cond, "error")
[13:23:13.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.153]                   NULL)
[13:23:13.153]                 if (is_error) {
[13:23:13.153]                   sessionInformation <- function() {
[13:23:13.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.153]                       search = base::search(), system = base::Sys.info())
[13:23:13.153]                   }
[13:23:13.153]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.153]                     cond$call), session = sessionInformation(), 
[13:23:13.153]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.153]                   signalCondition(cond)
[13:23:13.153]                 }
[13:23:13.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.153]                 "immediateCondition"))) {
[13:23:13.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.153]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.153]                   if (TRUE && !signal) {
[13:23:13.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.153]                     {
[13:23:13.153]                       inherits <- base::inherits
[13:23:13.153]                       invokeRestart <- base::invokeRestart
[13:23:13.153]                       is.null <- base::is.null
[13:23:13.153]                       muffled <- FALSE
[13:23:13.153]                       if (inherits(cond, "message")) {
[13:23:13.153]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.153]                         if (muffled) 
[13:23:13.153]                           invokeRestart("muffleMessage")
[13:23:13.153]                       }
[13:23:13.153]                       else if (inherits(cond, "warning")) {
[13:23:13.153]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.153]                         if (muffled) 
[13:23:13.153]                           invokeRestart("muffleWarning")
[13:23:13.153]                       }
[13:23:13.153]                       else if (inherits(cond, "condition")) {
[13:23:13.153]                         if (!is.null(pattern)) {
[13:23:13.153]                           computeRestarts <- base::computeRestarts
[13:23:13.153]                           grepl <- base::grepl
[13:23:13.153]                           restarts <- computeRestarts(cond)
[13:23:13.153]                           for (restart in restarts) {
[13:23:13.153]                             name <- restart$name
[13:23:13.153]                             if (is.null(name)) 
[13:23:13.153]                               next
[13:23:13.153]                             if (!grepl(pattern, name)) 
[13:23:13.153]                               next
[13:23:13.153]                             invokeRestart(restart)
[13:23:13.153]                             muffled <- TRUE
[13:23:13.153]                             break
[13:23:13.153]                           }
[13:23:13.153]                         }
[13:23:13.153]                       }
[13:23:13.153]                       invisible(muffled)
[13:23:13.153]                     }
[13:23:13.153]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.153]                   }
[13:23:13.153]                 }
[13:23:13.153]                 else {
[13:23:13.153]                   if (TRUE) {
[13:23:13.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.153]                     {
[13:23:13.153]                       inherits <- base::inherits
[13:23:13.153]                       invokeRestart <- base::invokeRestart
[13:23:13.153]                       is.null <- base::is.null
[13:23:13.153]                       muffled <- FALSE
[13:23:13.153]                       if (inherits(cond, "message")) {
[13:23:13.153]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.153]                         if (muffled) 
[13:23:13.153]                           invokeRestart("muffleMessage")
[13:23:13.153]                       }
[13:23:13.153]                       else if (inherits(cond, "warning")) {
[13:23:13.153]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.153]                         if (muffled) 
[13:23:13.153]                           invokeRestart("muffleWarning")
[13:23:13.153]                       }
[13:23:13.153]                       else if (inherits(cond, "condition")) {
[13:23:13.153]                         if (!is.null(pattern)) {
[13:23:13.153]                           computeRestarts <- base::computeRestarts
[13:23:13.153]                           grepl <- base::grepl
[13:23:13.153]                           restarts <- computeRestarts(cond)
[13:23:13.153]                           for (restart in restarts) {
[13:23:13.153]                             name <- restart$name
[13:23:13.153]                             if (is.null(name)) 
[13:23:13.153]                               next
[13:23:13.153]                             if (!grepl(pattern, name)) 
[13:23:13.153]                               next
[13:23:13.153]                             invokeRestart(restart)
[13:23:13.153]                             muffled <- TRUE
[13:23:13.153]                             break
[13:23:13.153]                           }
[13:23:13.153]                         }
[13:23:13.153]                       }
[13:23:13.153]                       invisible(muffled)
[13:23:13.153]                     }
[13:23:13.153]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.153]                   }
[13:23:13.153]                 }
[13:23:13.153]             }
[13:23:13.153]         }))
[13:23:13.153]     }, error = function(ex) {
[13:23:13.153]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.153]                 ...future.rng), started = ...future.startTime, 
[13:23:13.153]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.153]             version = "1.8"), class = "FutureResult")
[13:23:13.153]     }, finally = {
[13:23:13.153]         if (!identical(...future.workdir, getwd())) 
[13:23:13.153]             setwd(...future.workdir)
[13:23:13.153]         {
[13:23:13.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.153]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.153]             }
[13:23:13.153]             base::options(...future.oldOptions)
[13:23:13.153]             if (.Platform$OS.type == "windows") {
[13:23:13.153]                 old_names <- names(...future.oldEnvVars)
[13:23:13.153]                 envs <- base::Sys.getenv()
[13:23:13.153]                 names <- names(envs)
[13:23:13.153]                 common <- intersect(names, old_names)
[13:23:13.153]                 added <- setdiff(names, old_names)
[13:23:13.153]                 removed <- setdiff(old_names, names)
[13:23:13.153]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.153]                   envs[common]]
[13:23:13.153]                 NAMES <- toupper(changed)
[13:23:13.153]                 args <- list()
[13:23:13.153]                 for (kk in seq_along(NAMES)) {
[13:23:13.153]                   name <- changed[[kk]]
[13:23:13.153]                   NAME <- NAMES[[kk]]
[13:23:13.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.153]                     next
[13:23:13.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.153]                 }
[13:23:13.153]                 NAMES <- toupper(added)
[13:23:13.153]                 for (kk in seq_along(NAMES)) {
[13:23:13.153]                   name <- added[[kk]]
[13:23:13.153]                   NAME <- NAMES[[kk]]
[13:23:13.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.153]                     next
[13:23:13.153]                   args[[name]] <- ""
[13:23:13.153]                 }
[13:23:13.153]                 NAMES <- toupper(removed)
[13:23:13.153]                 for (kk in seq_along(NAMES)) {
[13:23:13.153]                   name <- removed[[kk]]
[13:23:13.153]                   NAME <- NAMES[[kk]]
[13:23:13.153]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.153]                     next
[13:23:13.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.153]                 }
[13:23:13.153]                 if (length(args) > 0) 
[13:23:13.153]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.153]             }
[13:23:13.153]             else {
[13:23:13.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.153]             }
[13:23:13.153]             {
[13:23:13.153]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.153]                   0L) {
[13:23:13.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.153]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.153]                   base::options(opts)
[13:23:13.153]                 }
[13:23:13.153]                 {
[13:23:13.153]                   {
[13:23:13.153]                     NULL
[13:23:13.153]                     RNGkind("Mersenne-Twister")
[13:23:13.153]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.153]                       inherits = FALSE)
[13:23:13.153]                   }
[13:23:13.153]                   options(future.plan = NULL)
[13:23:13.153]                   if (is.na(NA_character_)) 
[13:23:13.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.153]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.153]                   {
[13:23:13.153]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.153]                     if (!future$lazy) 
[13:23:13.153]                       future <- run(future)
[13:23:13.153]                     invisible(future)
[13:23:13.153]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.153]                 }
[13:23:13.153]             }
[13:23:13.153]         }
[13:23:13.153]     })
[13:23:13.153]     if (TRUE) {
[13:23:13.153]         base::sink(type = "output", split = FALSE)
[13:23:13.153]         if (TRUE) {
[13:23:13.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.153]         }
[13:23:13.153]         else {
[13:23:13.153]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.153]         }
[13:23:13.153]         base::close(...future.stdout)
[13:23:13.153]         ...future.stdout <- NULL
[13:23:13.153]     }
[13:23:13.153]     ...future.result$conditions <- ...future.conditions
[13:23:13.153]     ...future.result$finished <- base::Sys.time()
[13:23:13.153]     ...future.result
[13:23:13.153] }
[13:23:13.155] assign_globals() ...
[13:23:13.155] List of 1
[13:23:13.155]  $ x: num [1:5] 1 1 2 2 2
[13:23:13.155]  - attr(*, "where")=List of 1
[13:23:13.155]   ..$ x:<environment: R_EmptyEnv> 
[13:23:13.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.155]  - attr(*, "resolved")= logi FALSE
[13:23:13.155]  - attr(*, "total_size")= num 96
[13:23:13.155]  - attr(*, "already-done")= logi TRUE
[13:23:13.158] - copied ‘x’ to environment
[13:23:13.158] assign_globals() ... done
[13:23:13.158] plan(): Setting new future strategy stack:
[13:23:13.158] List of future strategies:
[13:23:13.158] 1. sequential:
[13:23:13.158]    - args: function (..., envir = parent.frame())
[13:23:13.158]    - tweaked: FALSE
[13:23:13.158]    - call: NULL
[13:23:13.159] plan(): nbrOfWorkers() = 1
[13:23:13.160] plan(): Setting new future strategy stack:
[13:23:13.160] List of future strategies:
[13:23:13.160] 1. sequential:
[13:23:13.160]    - args: function (..., envir = parent.frame())
[13:23:13.160]    - tweaked: FALSE
[13:23:13.160]    - call: plan(strategy)
[13:23:13.160] plan(): nbrOfWorkers() = 1
[13:23:13.161] SequentialFuture started (and completed)
[13:23:13.161] - Launch lazy future ... done
[13:23:13.161] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:23:13.163] getGlobalsAndPackages() ...
[13:23:13.163] Searching for globals...
[13:23:13.167] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:23:13.167] Searching for globals ... DONE
[13:23:13.167] Resolving globals: FALSE
[13:23:13.168] 
[13:23:13.168] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.168] getGlobalsAndPackages() ... DONE
[13:23:13.168] run() for ‘Future’ ...
[13:23:13.169] - state: ‘created’
[13:23:13.169] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.169]   - Field: ‘label’
[13:23:13.169]   - Field: ‘local’
[13:23:13.169]   - Field: ‘owner’
[13:23:13.170]   - Field: ‘envir’
[13:23:13.170]   - Field: ‘packages’
[13:23:13.170]   - Field: ‘gc’
[13:23:13.170]   - Field: ‘conditions’
[13:23:13.170]   - Field: ‘expr’
[13:23:13.170]   - Field: ‘uuid’
[13:23:13.170]   - Field: ‘seed’
[13:23:13.170]   - Field: ‘version’
[13:23:13.170]   - Field: ‘result’
[13:23:13.170]   - Field: ‘asynchronous’
[13:23:13.171]   - Field: ‘calls’
[13:23:13.171]   - Field: ‘globals’
[13:23:13.171]   - Field: ‘stdout’
[13:23:13.171]   - Field: ‘earlySignal’
[13:23:13.171]   - Field: ‘lazy’
[13:23:13.171]   - Field: ‘state’
[13:23:13.171] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.171] - Launch lazy future ...
[13:23:13.171] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.172] Packages needed by future strategies (n = 0): <none>
[13:23:13.172] {
[13:23:13.172]     {
[13:23:13.172]         {
[13:23:13.172]             ...future.startTime <- base::Sys.time()
[13:23:13.172]             {
[13:23:13.172]                 {
[13:23:13.172]                   {
[13:23:13.172]                     {
[13:23:13.172]                       base::local({
[13:23:13.172]                         has_future <- base::requireNamespace("future", 
[13:23:13.172]                           quietly = TRUE)
[13:23:13.172]                         if (has_future) {
[13:23:13.172]                           ns <- base::getNamespace("future")
[13:23:13.172]                           version <- ns[[".package"]][["version"]]
[13:23:13.172]                           if (is.null(version)) 
[13:23:13.172]                             version <- utils::packageVersion("future")
[13:23:13.172]                         }
[13:23:13.172]                         else {
[13:23:13.172]                           version <- NULL
[13:23:13.172]                         }
[13:23:13.172]                         if (!has_future || version < "1.8.0") {
[13:23:13.172]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.172]                             "", base::R.version$version.string), 
[13:23:13.172]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.172]                               "release", "version")], collapse = " "), 
[13:23:13.172]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.172]                             info)
[13:23:13.172]                           info <- base::paste(info, collapse = "; ")
[13:23:13.172]                           if (!has_future) {
[13:23:13.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.172]                               info)
[13:23:13.172]                           }
[13:23:13.172]                           else {
[13:23:13.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.172]                               info, version)
[13:23:13.172]                           }
[13:23:13.172]                           base::stop(msg)
[13:23:13.172]                         }
[13:23:13.172]                       })
[13:23:13.172]                     }
[13:23:13.172]                     base::local({
[13:23:13.172]                       for (pkg in c("stats", "datasets")) {
[13:23:13.172]                         base::loadNamespace(pkg)
[13:23:13.172]                         base::library(pkg, character.only = TRUE)
[13:23:13.172]                       }
[13:23:13.172]                     })
[13:23:13.172]                   }
[13:23:13.172]                   options(future.plan = NULL)
[13:23:13.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.172]                 }
[13:23:13.172]                 ...future.workdir <- getwd()
[13:23:13.172]             }
[13:23:13.172]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.172]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.172]         }
[13:23:13.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.172]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.172]             base::names(...future.oldOptions))
[13:23:13.172]     }
[13:23:13.172]     if (FALSE) {
[13:23:13.172]     }
[13:23:13.172]     else {
[13:23:13.172]         if (TRUE) {
[13:23:13.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.172]                 open = "w")
[13:23:13.172]         }
[13:23:13.172]         else {
[13:23:13.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.172]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.172]         }
[13:23:13.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.172]             base::sink(type = "output", split = FALSE)
[13:23:13.172]             base::close(...future.stdout)
[13:23:13.172]         }, add = TRUE)
[13:23:13.172]     }
[13:23:13.172]     ...future.frame <- base::sys.nframe()
[13:23:13.172]     ...future.conditions <- base::list()
[13:23:13.172]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.172]     if (FALSE) {
[13:23:13.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.172]     }
[13:23:13.172]     ...future.result <- base::tryCatch({
[13:23:13.172]         base::withCallingHandlers({
[13:23:13.172]             ...future.value <- base::withVisible(base::local({
[13:23:13.172]                 lm(dist ~ . - 1, data = cars)
[13:23:13.172]             }))
[13:23:13.172]             future::FutureResult(value = ...future.value$value, 
[13:23:13.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.172]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.172]                     ...future.globalenv.names))
[13:23:13.172]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.172]         }, condition = base::local({
[13:23:13.172]             c <- base::c
[13:23:13.172]             inherits <- base::inherits
[13:23:13.172]             invokeRestart <- base::invokeRestart
[13:23:13.172]             length <- base::length
[13:23:13.172]             list <- base::list
[13:23:13.172]             seq.int <- base::seq.int
[13:23:13.172]             signalCondition <- base::signalCondition
[13:23:13.172]             sys.calls <- base::sys.calls
[13:23:13.172]             `[[` <- base::`[[`
[13:23:13.172]             `+` <- base::`+`
[13:23:13.172]             `<<-` <- base::`<<-`
[13:23:13.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.172]                   3L)]
[13:23:13.172]             }
[13:23:13.172]             function(cond) {
[13:23:13.172]                 is_error <- inherits(cond, "error")
[13:23:13.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.172]                   NULL)
[13:23:13.172]                 if (is_error) {
[13:23:13.172]                   sessionInformation <- function() {
[13:23:13.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.172]                       search = base::search(), system = base::Sys.info())
[13:23:13.172]                   }
[13:23:13.172]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.172]                     cond$call), session = sessionInformation(), 
[13:23:13.172]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.172]                   signalCondition(cond)
[13:23:13.172]                 }
[13:23:13.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.172]                 "immediateCondition"))) {
[13:23:13.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.172]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.172]                   if (TRUE && !signal) {
[13:23:13.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.172]                     {
[13:23:13.172]                       inherits <- base::inherits
[13:23:13.172]                       invokeRestart <- base::invokeRestart
[13:23:13.172]                       is.null <- base::is.null
[13:23:13.172]                       muffled <- FALSE
[13:23:13.172]                       if (inherits(cond, "message")) {
[13:23:13.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.172]                         if (muffled) 
[13:23:13.172]                           invokeRestart("muffleMessage")
[13:23:13.172]                       }
[13:23:13.172]                       else if (inherits(cond, "warning")) {
[13:23:13.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.172]                         if (muffled) 
[13:23:13.172]                           invokeRestart("muffleWarning")
[13:23:13.172]                       }
[13:23:13.172]                       else if (inherits(cond, "condition")) {
[13:23:13.172]                         if (!is.null(pattern)) {
[13:23:13.172]                           computeRestarts <- base::computeRestarts
[13:23:13.172]                           grepl <- base::grepl
[13:23:13.172]                           restarts <- computeRestarts(cond)
[13:23:13.172]                           for (restart in restarts) {
[13:23:13.172]                             name <- restart$name
[13:23:13.172]                             if (is.null(name)) 
[13:23:13.172]                               next
[13:23:13.172]                             if (!grepl(pattern, name)) 
[13:23:13.172]                               next
[13:23:13.172]                             invokeRestart(restart)
[13:23:13.172]                             muffled <- TRUE
[13:23:13.172]                             break
[13:23:13.172]                           }
[13:23:13.172]                         }
[13:23:13.172]                       }
[13:23:13.172]                       invisible(muffled)
[13:23:13.172]                     }
[13:23:13.172]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.172]                   }
[13:23:13.172]                 }
[13:23:13.172]                 else {
[13:23:13.172]                   if (TRUE) {
[13:23:13.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.172]                     {
[13:23:13.172]                       inherits <- base::inherits
[13:23:13.172]                       invokeRestart <- base::invokeRestart
[13:23:13.172]                       is.null <- base::is.null
[13:23:13.172]                       muffled <- FALSE
[13:23:13.172]                       if (inherits(cond, "message")) {
[13:23:13.172]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.172]                         if (muffled) 
[13:23:13.172]                           invokeRestart("muffleMessage")
[13:23:13.172]                       }
[13:23:13.172]                       else if (inherits(cond, "warning")) {
[13:23:13.172]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.172]                         if (muffled) 
[13:23:13.172]                           invokeRestart("muffleWarning")
[13:23:13.172]                       }
[13:23:13.172]                       else if (inherits(cond, "condition")) {
[13:23:13.172]                         if (!is.null(pattern)) {
[13:23:13.172]                           computeRestarts <- base::computeRestarts
[13:23:13.172]                           grepl <- base::grepl
[13:23:13.172]                           restarts <- computeRestarts(cond)
[13:23:13.172]                           for (restart in restarts) {
[13:23:13.172]                             name <- restart$name
[13:23:13.172]                             if (is.null(name)) 
[13:23:13.172]                               next
[13:23:13.172]                             if (!grepl(pattern, name)) 
[13:23:13.172]                               next
[13:23:13.172]                             invokeRestart(restart)
[13:23:13.172]                             muffled <- TRUE
[13:23:13.172]                             break
[13:23:13.172]                           }
[13:23:13.172]                         }
[13:23:13.172]                       }
[13:23:13.172]                       invisible(muffled)
[13:23:13.172]                     }
[13:23:13.172]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.172]                   }
[13:23:13.172]                 }
[13:23:13.172]             }
[13:23:13.172]         }))
[13:23:13.172]     }, error = function(ex) {
[13:23:13.172]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.172]                 ...future.rng), started = ...future.startTime, 
[13:23:13.172]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.172]             version = "1.8"), class = "FutureResult")
[13:23:13.172]     }, finally = {
[13:23:13.172]         if (!identical(...future.workdir, getwd())) 
[13:23:13.172]             setwd(...future.workdir)
[13:23:13.172]         {
[13:23:13.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.172]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.172]             }
[13:23:13.172]             base::options(...future.oldOptions)
[13:23:13.172]             if (.Platform$OS.type == "windows") {
[13:23:13.172]                 old_names <- names(...future.oldEnvVars)
[13:23:13.172]                 envs <- base::Sys.getenv()
[13:23:13.172]                 names <- names(envs)
[13:23:13.172]                 common <- intersect(names, old_names)
[13:23:13.172]                 added <- setdiff(names, old_names)
[13:23:13.172]                 removed <- setdiff(old_names, names)
[13:23:13.172]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.172]                   envs[common]]
[13:23:13.172]                 NAMES <- toupper(changed)
[13:23:13.172]                 args <- list()
[13:23:13.172]                 for (kk in seq_along(NAMES)) {
[13:23:13.172]                   name <- changed[[kk]]
[13:23:13.172]                   NAME <- NAMES[[kk]]
[13:23:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.172]                     next
[13:23:13.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.172]                 }
[13:23:13.172]                 NAMES <- toupper(added)
[13:23:13.172]                 for (kk in seq_along(NAMES)) {
[13:23:13.172]                   name <- added[[kk]]
[13:23:13.172]                   NAME <- NAMES[[kk]]
[13:23:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.172]                     next
[13:23:13.172]                   args[[name]] <- ""
[13:23:13.172]                 }
[13:23:13.172]                 NAMES <- toupper(removed)
[13:23:13.172]                 for (kk in seq_along(NAMES)) {
[13:23:13.172]                   name <- removed[[kk]]
[13:23:13.172]                   NAME <- NAMES[[kk]]
[13:23:13.172]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.172]                     next
[13:23:13.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.172]                 }
[13:23:13.172]                 if (length(args) > 0) 
[13:23:13.172]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.172]             }
[13:23:13.172]             else {
[13:23:13.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.172]             }
[13:23:13.172]             {
[13:23:13.172]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.172]                   0L) {
[13:23:13.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.172]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.172]                   base::options(opts)
[13:23:13.172]                 }
[13:23:13.172]                 {
[13:23:13.172]                   {
[13:23:13.172]                     NULL
[13:23:13.172]                     RNGkind("Mersenne-Twister")
[13:23:13.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.172]                       inherits = FALSE)
[13:23:13.172]                   }
[13:23:13.172]                   options(future.plan = NULL)
[13:23:13.172]                   if (is.na(NA_character_)) 
[13:23:13.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.172]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.172]                   {
[13:23:13.172]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.172]                     if (!future$lazy) 
[13:23:13.172]                       future <- run(future)
[13:23:13.172]                     invisible(future)
[13:23:13.172]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.172]                 }
[13:23:13.172]             }
[13:23:13.172]         }
[13:23:13.172]     })
[13:23:13.172]     if (TRUE) {
[13:23:13.172]         base::sink(type = "output", split = FALSE)
[13:23:13.172]         if (TRUE) {
[13:23:13.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.172]         }
[13:23:13.172]         else {
[13:23:13.172]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.172]         }
[13:23:13.172]         base::close(...future.stdout)
[13:23:13.172]         ...future.stdout <- NULL
[13:23:13.172]     }
[13:23:13.172]     ...future.result$conditions <- ...future.conditions
[13:23:13.172]     ...future.result$finished <- base::Sys.time()
[13:23:13.172]     ...future.result
[13:23:13.172] }
[13:23:13.174] plan(): Setting new future strategy stack:
[13:23:13.174] List of future strategies:
[13:23:13.174] 1. sequential:
[13:23:13.174]    - args: function (..., envir = parent.frame())
[13:23:13.174]    - tweaked: FALSE
[13:23:13.174]    - call: NULL
[13:23:13.175] plan(): nbrOfWorkers() = 1
[13:23:13.176] plan(): Setting new future strategy stack:
[13:23:13.177] List of future strategies:
[13:23:13.177] 1. sequential:
[13:23:13.177]    - args: function (..., envir = parent.frame())
[13:23:13.177]    - tweaked: FALSE
[13:23:13.177]    - call: plan(strategy)
[13:23:13.177] plan(): nbrOfWorkers() = 1
[13:23:13.177] SequentialFuture started (and completed)
[13:23:13.177] - Launch lazy future ... done
[13:23:13.177] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:23:13.180] getGlobalsAndPackages() ...
[13:23:13.180] Searching for globals...
[13:23:13.182] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:23:13.182] Searching for globals ... DONE
[13:23:13.182] Resolving globals: FALSE
[13:23:13.183] 
[13:23:13.183] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.183] getGlobalsAndPackages() ... DONE
[13:23:13.183] run() for ‘Future’ ...
[13:23:13.183] - state: ‘created’
[13:23:13.183] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.184] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.184]   - Field: ‘label’
[13:23:13.184]   - Field: ‘local’
[13:23:13.184]   - Field: ‘owner’
[13:23:13.184]   - Field: ‘envir’
[13:23:13.184]   - Field: ‘packages’
[13:23:13.184]   - Field: ‘gc’
[13:23:13.184]   - Field: ‘conditions’
[13:23:13.185]   - Field: ‘expr’
[13:23:13.185]   - Field: ‘uuid’
[13:23:13.185]   - Field: ‘seed’
[13:23:13.185]   - Field: ‘version’
[13:23:13.185]   - Field: ‘result’
[13:23:13.185]   - Field: ‘asynchronous’
[13:23:13.185]   - Field: ‘calls’
[13:23:13.185]   - Field: ‘globals’
[13:23:13.185]   - Field: ‘stdout’
[13:23:13.185]   - Field: ‘earlySignal’
[13:23:13.186]   - Field: ‘lazy’
[13:23:13.186]   - Field: ‘state’
[13:23:13.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.186] - Launch lazy future ...
[13:23:13.186] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.186] Packages needed by future strategies (n = 0): <none>
[13:23:13.187] {
[13:23:13.187]     {
[13:23:13.187]         {
[13:23:13.187]             ...future.startTime <- base::Sys.time()
[13:23:13.187]             {
[13:23:13.187]                 {
[13:23:13.187]                   {
[13:23:13.187]                     {
[13:23:13.187]                       base::local({
[13:23:13.187]                         has_future <- base::requireNamespace("future", 
[13:23:13.187]                           quietly = TRUE)
[13:23:13.187]                         if (has_future) {
[13:23:13.187]                           ns <- base::getNamespace("future")
[13:23:13.187]                           version <- ns[[".package"]][["version"]]
[13:23:13.187]                           if (is.null(version)) 
[13:23:13.187]                             version <- utils::packageVersion("future")
[13:23:13.187]                         }
[13:23:13.187]                         else {
[13:23:13.187]                           version <- NULL
[13:23:13.187]                         }
[13:23:13.187]                         if (!has_future || version < "1.8.0") {
[13:23:13.187]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.187]                             "", base::R.version$version.string), 
[13:23:13.187]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.187]                               "release", "version")], collapse = " "), 
[13:23:13.187]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.187]                             info)
[13:23:13.187]                           info <- base::paste(info, collapse = "; ")
[13:23:13.187]                           if (!has_future) {
[13:23:13.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.187]                               info)
[13:23:13.187]                           }
[13:23:13.187]                           else {
[13:23:13.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.187]                               info, version)
[13:23:13.187]                           }
[13:23:13.187]                           base::stop(msg)
[13:23:13.187]                         }
[13:23:13.187]                       })
[13:23:13.187]                     }
[13:23:13.187]                     base::local({
[13:23:13.187]                       for (pkg in c("stats", "datasets")) {
[13:23:13.187]                         base::loadNamespace(pkg)
[13:23:13.187]                         base::library(pkg, character.only = TRUE)
[13:23:13.187]                       }
[13:23:13.187]                     })
[13:23:13.187]                   }
[13:23:13.187]                   options(future.plan = NULL)
[13:23:13.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.187]                 }
[13:23:13.187]                 ...future.workdir <- getwd()
[13:23:13.187]             }
[13:23:13.187]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.187]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.187]         }
[13:23:13.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.187]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.187]             base::names(...future.oldOptions))
[13:23:13.187]     }
[13:23:13.187]     if (FALSE) {
[13:23:13.187]     }
[13:23:13.187]     else {
[13:23:13.187]         if (TRUE) {
[13:23:13.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.187]                 open = "w")
[13:23:13.187]         }
[13:23:13.187]         else {
[13:23:13.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.187]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.187]         }
[13:23:13.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.187]             base::sink(type = "output", split = FALSE)
[13:23:13.187]             base::close(...future.stdout)
[13:23:13.187]         }, add = TRUE)
[13:23:13.187]     }
[13:23:13.187]     ...future.frame <- base::sys.nframe()
[13:23:13.187]     ...future.conditions <- base::list()
[13:23:13.187]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.187]     if (FALSE) {
[13:23:13.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.187]     }
[13:23:13.187]     ...future.result <- base::tryCatch({
[13:23:13.187]         base::withCallingHandlers({
[13:23:13.187]             ...future.value <- base::withVisible(base::local({
[13:23:13.187]                 lm(dist ~ . + 0, data = cars)
[13:23:13.187]             }))
[13:23:13.187]             future::FutureResult(value = ...future.value$value, 
[13:23:13.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.187]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.187]                     ...future.globalenv.names))
[13:23:13.187]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.187]         }, condition = base::local({
[13:23:13.187]             c <- base::c
[13:23:13.187]             inherits <- base::inherits
[13:23:13.187]             invokeRestart <- base::invokeRestart
[13:23:13.187]             length <- base::length
[13:23:13.187]             list <- base::list
[13:23:13.187]             seq.int <- base::seq.int
[13:23:13.187]             signalCondition <- base::signalCondition
[13:23:13.187]             sys.calls <- base::sys.calls
[13:23:13.187]             `[[` <- base::`[[`
[13:23:13.187]             `+` <- base::`+`
[13:23:13.187]             `<<-` <- base::`<<-`
[13:23:13.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.187]                   3L)]
[13:23:13.187]             }
[13:23:13.187]             function(cond) {
[13:23:13.187]                 is_error <- inherits(cond, "error")
[13:23:13.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.187]                   NULL)
[13:23:13.187]                 if (is_error) {
[13:23:13.187]                   sessionInformation <- function() {
[13:23:13.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.187]                       search = base::search(), system = base::Sys.info())
[13:23:13.187]                   }
[13:23:13.187]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.187]                     cond$call), session = sessionInformation(), 
[13:23:13.187]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.187]                   signalCondition(cond)
[13:23:13.187]                 }
[13:23:13.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.187]                 "immediateCondition"))) {
[13:23:13.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.187]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.187]                   if (TRUE && !signal) {
[13:23:13.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.187]                     {
[13:23:13.187]                       inherits <- base::inherits
[13:23:13.187]                       invokeRestart <- base::invokeRestart
[13:23:13.187]                       is.null <- base::is.null
[13:23:13.187]                       muffled <- FALSE
[13:23:13.187]                       if (inherits(cond, "message")) {
[13:23:13.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.187]                         if (muffled) 
[13:23:13.187]                           invokeRestart("muffleMessage")
[13:23:13.187]                       }
[13:23:13.187]                       else if (inherits(cond, "warning")) {
[13:23:13.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.187]                         if (muffled) 
[13:23:13.187]                           invokeRestart("muffleWarning")
[13:23:13.187]                       }
[13:23:13.187]                       else if (inherits(cond, "condition")) {
[13:23:13.187]                         if (!is.null(pattern)) {
[13:23:13.187]                           computeRestarts <- base::computeRestarts
[13:23:13.187]                           grepl <- base::grepl
[13:23:13.187]                           restarts <- computeRestarts(cond)
[13:23:13.187]                           for (restart in restarts) {
[13:23:13.187]                             name <- restart$name
[13:23:13.187]                             if (is.null(name)) 
[13:23:13.187]                               next
[13:23:13.187]                             if (!grepl(pattern, name)) 
[13:23:13.187]                               next
[13:23:13.187]                             invokeRestart(restart)
[13:23:13.187]                             muffled <- TRUE
[13:23:13.187]                             break
[13:23:13.187]                           }
[13:23:13.187]                         }
[13:23:13.187]                       }
[13:23:13.187]                       invisible(muffled)
[13:23:13.187]                     }
[13:23:13.187]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.187]                   }
[13:23:13.187]                 }
[13:23:13.187]                 else {
[13:23:13.187]                   if (TRUE) {
[13:23:13.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.187]                     {
[13:23:13.187]                       inherits <- base::inherits
[13:23:13.187]                       invokeRestart <- base::invokeRestart
[13:23:13.187]                       is.null <- base::is.null
[13:23:13.187]                       muffled <- FALSE
[13:23:13.187]                       if (inherits(cond, "message")) {
[13:23:13.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.187]                         if (muffled) 
[13:23:13.187]                           invokeRestart("muffleMessage")
[13:23:13.187]                       }
[13:23:13.187]                       else if (inherits(cond, "warning")) {
[13:23:13.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.187]                         if (muffled) 
[13:23:13.187]                           invokeRestart("muffleWarning")
[13:23:13.187]                       }
[13:23:13.187]                       else if (inherits(cond, "condition")) {
[13:23:13.187]                         if (!is.null(pattern)) {
[13:23:13.187]                           computeRestarts <- base::computeRestarts
[13:23:13.187]                           grepl <- base::grepl
[13:23:13.187]                           restarts <- computeRestarts(cond)
[13:23:13.187]                           for (restart in restarts) {
[13:23:13.187]                             name <- restart$name
[13:23:13.187]                             if (is.null(name)) 
[13:23:13.187]                               next
[13:23:13.187]                             if (!grepl(pattern, name)) 
[13:23:13.187]                               next
[13:23:13.187]                             invokeRestart(restart)
[13:23:13.187]                             muffled <- TRUE
[13:23:13.187]                             break
[13:23:13.187]                           }
[13:23:13.187]                         }
[13:23:13.187]                       }
[13:23:13.187]                       invisible(muffled)
[13:23:13.187]                     }
[13:23:13.187]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.187]                   }
[13:23:13.187]                 }
[13:23:13.187]             }
[13:23:13.187]         }))
[13:23:13.187]     }, error = function(ex) {
[13:23:13.187]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.187]                 ...future.rng), started = ...future.startTime, 
[13:23:13.187]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.187]             version = "1.8"), class = "FutureResult")
[13:23:13.187]     }, finally = {
[13:23:13.187]         if (!identical(...future.workdir, getwd())) 
[13:23:13.187]             setwd(...future.workdir)
[13:23:13.187]         {
[13:23:13.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.187]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.187]             }
[13:23:13.187]             base::options(...future.oldOptions)
[13:23:13.187]             if (.Platform$OS.type == "windows") {
[13:23:13.187]                 old_names <- names(...future.oldEnvVars)
[13:23:13.187]                 envs <- base::Sys.getenv()
[13:23:13.187]                 names <- names(envs)
[13:23:13.187]                 common <- intersect(names, old_names)
[13:23:13.187]                 added <- setdiff(names, old_names)
[13:23:13.187]                 removed <- setdiff(old_names, names)
[13:23:13.187]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.187]                   envs[common]]
[13:23:13.187]                 NAMES <- toupper(changed)
[13:23:13.187]                 args <- list()
[13:23:13.187]                 for (kk in seq_along(NAMES)) {
[13:23:13.187]                   name <- changed[[kk]]
[13:23:13.187]                   NAME <- NAMES[[kk]]
[13:23:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.187]                     next
[13:23:13.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.187]                 }
[13:23:13.187]                 NAMES <- toupper(added)
[13:23:13.187]                 for (kk in seq_along(NAMES)) {
[13:23:13.187]                   name <- added[[kk]]
[13:23:13.187]                   NAME <- NAMES[[kk]]
[13:23:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.187]                     next
[13:23:13.187]                   args[[name]] <- ""
[13:23:13.187]                 }
[13:23:13.187]                 NAMES <- toupper(removed)
[13:23:13.187]                 for (kk in seq_along(NAMES)) {
[13:23:13.187]                   name <- removed[[kk]]
[13:23:13.187]                   NAME <- NAMES[[kk]]
[13:23:13.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.187]                     next
[13:23:13.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.187]                 }
[13:23:13.187]                 if (length(args) > 0) 
[13:23:13.187]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.187]             }
[13:23:13.187]             else {
[13:23:13.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.187]             }
[13:23:13.187]             {
[13:23:13.187]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.187]                   0L) {
[13:23:13.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.187]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.187]                   base::options(opts)
[13:23:13.187]                 }
[13:23:13.187]                 {
[13:23:13.187]                   {
[13:23:13.187]                     NULL
[13:23:13.187]                     RNGkind("Mersenne-Twister")
[13:23:13.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.187]                       inherits = FALSE)
[13:23:13.187]                   }
[13:23:13.187]                   options(future.plan = NULL)
[13:23:13.187]                   if (is.na(NA_character_)) 
[13:23:13.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.187]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.187]                   {
[13:23:13.187]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.187]                     if (!future$lazy) 
[13:23:13.187]                       future <- run(future)
[13:23:13.187]                     invisible(future)
[13:23:13.187]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.187]                 }
[13:23:13.187]             }
[13:23:13.187]         }
[13:23:13.187]     })
[13:23:13.187]     if (TRUE) {
[13:23:13.187]         base::sink(type = "output", split = FALSE)
[13:23:13.187]         if (TRUE) {
[13:23:13.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.187]         }
[13:23:13.187]         else {
[13:23:13.187]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.187]         }
[13:23:13.187]         base::close(...future.stdout)
[13:23:13.187]         ...future.stdout <- NULL
[13:23:13.187]     }
[13:23:13.187]     ...future.result$conditions <- ...future.conditions
[13:23:13.187]     ...future.result$finished <- base::Sys.time()
[13:23:13.187]     ...future.result
[13:23:13.187] }
[13:23:13.189] plan(): Setting new future strategy stack:
[13:23:13.189] List of future strategies:
[13:23:13.189] 1. sequential:
[13:23:13.189]    - args: function (..., envir = parent.frame())
[13:23:13.189]    - tweaked: FALSE
[13:23:13.189]    - call: NULL
[13:23:13.189] plan(): nbrOfWorkers() = 1
[13:23:13.191] plan(): Setting new future strategy stack:
[13:23:13.191] List of future strategies:
[13:23:13.191] 1. sequential:
[13:23:13.191]    - args: function (..., envir = parent.frame())
[13:23:13.191]    - tweaked: FALSE
[13:23:13.191]    - call: plan(strategy)
[13:23:13.191] plan(): nbrOfWorkers() = 1
[13:23:13.192] SequentialFuture started (and completed)
[13:23:13.192] - Launch lazy future ... done
[13:23:13.192] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:23:13.197] getGlobalsAndPackages() ...
[13:23:13.197] Searching for globals...
[13:23:13.199] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:23:13.199] Searching for globals ... DONE
[13:23:13.199] Resolving globals: FALSE
[13:23:13.199] 
[13:23:13.200] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.200] getGlobalsAndPackages() ... DONE
[13:23:13.200] run() for ‘Future’ ...
[13:23:13.200] - state: ‘created’
[13:23:13.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.201]   - Field: ‘label’
[13:23:13.201]   - Field: ‘local’
[13:23:13.201]   - Field: ‘owner’
[13:23:13.201]   - Field: ‘envir’
[13:23:13.201]   - Field: ‘packages’
[13:23:13.201]   - Field: ‘gc’
[13:23:13.201]   - Field: ‘conditions’
[13:23:13.202]   - Field: ‘expr’
[13:23:13.202]   - Field: ‘uuid’
[13:23:13.202]   - Field: ‘seed’
[13:23:13.202]   - Field: ‘version’
[13:23:13.202]   - Field: ‘result’
[13:23:13.202]   - Field: ‘asynchronous’
[13:23:13.202]   - Field: ‘calls’
[13:23:13.202]   - Field: ‘globals’
[13:23:13.202]   - Field: ‘stdout’
[13:23:13.202]   - Field: ‘earlySignal’
[13:23:13.202]   - Field: ‘lazy’
[13:23:13.203]   - Field: ‘state’
[13:23:13.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.203] - Launch lazy future ...
[13:23:13.203] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.203] Packages needed by future strategies (n = 0): <none>
[13:23:13.204] {
[13:23:13.204]     {
[13:23:13.204]         {
[13:23:13.204]             ...future.startTime <- base::Sys.time()
[13:23:13.204]             {
[13:23:13.204]                 {
[13:23:13.204]                   {
[13:23:13.204]                     {
[13:23:13.204]                       base::local({
[13:23:13.204]                         has_future <- base::requireNamespace("future", 
[13:23:13.204]                           quietly = TRUE)
[13:23:13.204]                         if (has_future) {
[13:23:13.204]                           ns <- base::getNamespace("future")
[13:23:13.204]                           version <- ns[[".package"]][["version"]]
[13:23:13.204]                           if (is.null(version)) 
[13:23:13.204]                             version <- utils::packageVersion("future")
[13:23:13.204]                         }
[13:23:13.204]                         else {
[13:23:13.204]                           version <- NULL
[13:23:13.204]                         }
[13:23:13.204]                         if (!has_future || version < "1.8.0") {
[13:23:13.204]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.204]                             "", base::R.version$version.string), 
[13:23:13.204]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.204]                               "release", "version")], collapse = " "), 
[13:23:13.204]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.204]                             info)
[13:23:13.204]                           info <- base::paste(info, collapse = "; ")
[13:23:13.204]                           if (!has_future) {
[13:23:13.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.204]                               info)
[13:23:13.204]                           }
[13:23:13.204]                           else {
[13:23:13.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.204]                               info, version)
[13:23:13.204]                           }
[13:23:13.204]                           base::stop(msg)
[13:23:13.204]                         }
[13:23:13.204]                       })
[13:23:13.204]                     }
[13:23:13.204]                     base::local({
[13:23:13.204]                       for (pkg in c("stats", "datasets")) {
[13:23:13.204]                         base::loadNamespace(pkg)
[13:23:13.204]                         base::library(pkg, character.only = TRUE)
[13:23:13.204]                       }
[13:23:13.204]                     })
[13:23:13.204]                   }
[13:23:13.204]                   options(future.plan = NULL)
[13:23:13.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.204]                 }
[13:23:13.204]                 ...future.workdir <- getwd()
[13:23:13.204]             }
[13:23:13.204]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.204]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.204]         }
[13:23:13.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.204]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.204]             base::names(...future.oldOptions))
[13:23:13.204]     }
[13:23:13.204]     if (FALSE) {
[13:23:13.204]     }
[13:23:13.204]     else {
[13:23:13.204]         if (TRUE) {
[13:23:13.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.204]                 open = "w")
[13:23:13.204]         }
[13:23:13.204]         else {
[13:23:13.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.204]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.204]         }
[13:23:13.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.204]             base::sink(type = "output", split = FALSE)
[13:23:13.204]             base::close(...future.stdout)
[13:23:13.204]         }, add = TRUE)
[13:23:13.204]     }
[13:23:13.204]     ...future.frame <- base::sys.nframe()
[13:23:13.204]     ...future.conditions <- base::list()
[13:23:13.204]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.204]     if (FALSE) {
[13:23:13.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.204]     }
[13:23:13.204]     ...future.result <- base::tryCatch({
[13:23:13.204]         base::withCallingHandlers({
[13:23:13.204]             ...future.value <- base::withVisible(base::local({
[13:23:13.204]                 lm(dist ~ speed + speed^2, data = cars)
[13:23:13.204]             }))
[13:23:13.204]             future::FutureResult(value = ...future.value$value, 
[13:23:13.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.204]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.204]                     ...future.globalenv.names))
[13:23:13.204]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.204]         }, condition = base::local({
[13:23:13.204]             c <- base::c
[13:23:13.204]             inherits <- base::inherits
[13:23:13.204]             invokeRestart <- base::invokeRestart
[13:23:13.204]             length <- base::length
[13:23:13.204]             list <- base::list
[13:23:13.204]             seq.int <- base::seq.int
[13:23:13.204]             signalCondition <- base::signalCondition
[13:23:13.204]             sys.calls <- base::sys.calls
[13:23:13.204]             `[[` <- base::`[[`
[13:23:13.204]             `+` <- base::`+`
[13:23:13.204]             `<<-` <- base::`<<-`
[13:23:13.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.204]                   3L)]
[13:23:13.204]             }
[13:23:13.204]             function(cond) {
[13:23:13.204]                 is_error <- inherits(cond, "error")
[13:23:13.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.204]                   NULL)
[13:23:13.204]                 if (is_error) {
[13:23:13.204]                   sessionInformation <- function() {
[13:23:13.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.204]                       search = base::search(), system = base::Sys.info())
[13:23:13.204]                   }
[13:23:13.204]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.204]                     cond$call), session = sessionInformation(), 
[13:23:13.204]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.204]                   signalCondition(cond)
[13:23:13.204]                 }
[13:23:13.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.204]                 "immediateCondition"))) {
[13:23:13.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.204]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.204]                   if (TRUE && !signal) {
[13:23:13.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.204]                     {
[13:23:13.204]                       inherits <- base::inherits
[13:23:13.204]                       invokeRestart <- base::invokeRestart
[13:23:13.204]                       is.null <- base::is.null
[13:23:13.204]                       muffled <- FALSE
[13:23:13.204]                       if (inherits(cond, "message")) {
[13:23:13.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.204]                         if (muffled) 
[13:23:13.204]                           invokeRestart("muffleMessage")
[13:23:13.204]                       }
[13:23:13.204]                       else if (inherits(cond, "warning")) {
[13:23:13.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.204]                         if (muffled) 
[13:23:13.204]                           invokeRestart("muffleWarning")
[13:23:13.204]                       }
[13:23:13.204]                       else if (inherits(cond, "condition")) {
[13:23:13.204]                         if (!is.null(pattern)) {
[13:23:13.204]                           computeRestarts <- base::computeRestarts
[13:23:13.204]                           grepl <- base::grepl
[13:23:13.204]                           restarts <- computeRestarts(cond)
[13:23:13.204]                           for (restart in restarts) {
[13:23:13.204]                             name <- restart$name
[13:23:13.204]                             if (is.null(name)) 
[13:23:13.204]                               next
[13:23:13.204]                             if (!grepl(pattern, name)) 
[13:23:13.204]                               next
[13:23:13.204]                             invokeRestart(restart)
[13:23:13.204]                             muffled <- TRUE
[13:23:13.204]                             break
[13:23:13.204]                           }
[13:23:13.204]                         }
[13:23:13.204]                       }
[13:23:13.204]                       invisible(muffled)
[13:23:13.204]                     }
[13:23:13.204]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.204]                   }
[13:23:13.204]                 }
[13:23:13.204]                 else {
[13:23:13.204]                   if (TRUE) {
[13:23:13.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.204]                     {
[13:23:13.204]                       inherits <- base::inherits
[13:23:13.204]                       invokeRestart <- base::invokeRestart
[13:23:13.204]                       is.null <- base::is.null
[13:23:13.204]                       muffled <- FALSE
[13:23:13.204]                       if (inherits(cond, "message")) {
[13:23:13.204]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.204]                         if (muffled) 
[13:23:13.204]                           invokeRestart("muffleMessage")
[13:23:13.204]                       }
[13:23:13.204]                       else if (inherits(cond, "warning")) {
[13:23:13.204]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.204]                         if (muffled) 
[13:23:13.204]                           invokeRestart("muffleWarning")
[13:23:13.204]                       }
[13:23:13.204]                       else if (inherits(cond, "condition")) {
[13:23:13.204]                         if (!is.null(pattern)) {
[13:23:13.204]                           computeRestarts <- base::computeRestarts
[13:23:13.204]                           grepl <- base::grepl
[13:23:13.204]                           restarts <- computeRestarts(cond)
[13:23:13.204]                           for (restart in restarts) {
[13:23:13.204]                             name <- restart$name
[13:23:13.204]                             if (is.null(name)) 
[13:23:13.204]                               next
[13:23:13.204]                             if (!grepl(pattern, name)) 
[13:23:13.204]                               next
[13:23:13.204]                             invokeRestart(restart)
[13:23:13.204]                             muffled <- TRUE
[13:23:13.204]                             break
[13:23:13.204]                           }
[13:23:13.204]                         }
[13:23:13.204]                       }
[13:23:13.204]                       invisible(muffled)
[13:23:13.204]                     }
[13:23:13.204]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.204]                   }
[13:23:13.204]                 }
[13:23:13.204]             }
[13:23:13.204]         }))
[13:23:13.204]     }, error = function(ex) {
[13:23:13.204]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.204]                 ...future.rng), started = ...future.startTime, 
[13:23:13.204]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.204]             version = "1.8"), class = "FutureResult")
[13:23:13.204]     }, finally = {
[13:23:13.204]         if (!identical(...future.workdir, getwd())) 
[13:23:13.204]             setwd(...future.workdir)
[13:23:13.204]         {
[13:23:13.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.204]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.204]             }
[13:23:13.204]             base::options(...future.oldOptions)
[13:23:13.204]             if (.Platform$OS.type == "windows") {
[13:23:13.204]                 old_names <- names(...future.oldEnvVars)
[13:23:13.204]                 envs <- base::Sys.getenv()
[13:23:13.204]                 names <- names(envs)
[13:23:13.204]                 common <- intersect(names, old_names)
[13:23:13.204]                 added <- setdiff(names, old_names)
[13:23:13.204]                 removed <- setdiff(old_names, names)
[13:23:13.204]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.204]                   envs[common]]
[13:23:13.204]                 NAMES <- toupper(changed)
[13:23:13.204]                 args <- list()
[13:23:13.204]                 for (kk in seq_along(NAMES)) {
[13:23:13.204]                   name <- changed[[kk]]
[13:23:13.204]                   NAME <- NAMES[[kk]]
[13:23:13.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.204]                     next
[13:23:13.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.204]                 }
[13:23:13.204]                 NAMES <- toupper(added)
[13:23:13.204]                 for (kk in seq_along(NAMES)) {
[13:23:13.204]                   name <- added[[kk]]
[13:23:13.204]                   NAME <- NAMES[[kk]]
[13:23:13.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.204]                     next
[13:23:13.204]                   args[[name]] <- ""
[13:23:13.204]                 }
[13:23:13.204]                 NAMES <- toupper(removed)
[13:23:13.204]                 for (kk in seq_along(NAMES)) {
[13:23:13.204]                   name <- removed[[kk]]
[13:23:13.204]                   NAME <- NAMES[[kk]]
[13:23:13.204]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.204]                     next
[13:23:13.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.204]                 }
[13:23:13.204]                 if (length(args) > 0) 
[13:23:13.204]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.204]             }
[13:23:13.204]             else {
[13:23:13.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.204]             }
[13:23:13.204]             {
[13:23:13.204]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.204]                   0L) {
[13:23:13.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.204]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.204]                   base::options(opts)
[13:23:13.204]                 }
[13:23:13.204]                 {
[13:23:13.204]                   {
[13:23:13.204]                     NULL
[13:23:13.204]                     RNGkind("Mersenne-Twister")
[13:23:13.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.204]                       inherits = FALSE)
[13:23:13.204]                   }
[13:23:13.204]                   options(future.plan = NULL)
[13:23:13.204]                   if (is.na(NA_character_)) 
[13:23:13.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.204]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.204]                   {
[13:23:13.204]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.204]                     if (!future$lazy) 
[13:23:13.204]                       future <- run(future)
[13:23:13.204]                     invisible(future)
[13:23:13.204]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.204]                 }
[13:23:13.204]             }
[13:23:13.204]         }
[13:23:13.204]     })
[13:23:13.204]     if (TRUE) {
[13:23:13.204]         base::sink(type = "output", split = FALSE)
[13:23:13.204]         if (TRUE) {
[13:23:13.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.204]         }
[13:23:13.204]         else {
[13:23:13.204]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.204]         }
[13:23:13.204]         base::close(...future.stdout)
[13:23:13.204]         ...future.stdout <- NULL
[13:23:13.204]     }
[13:23:13.204]     ...future.result$conditions <- ...future.conditions
[13:23:13.204]     ...future.result$finished <- base::Sys.time()
[13:23:13.204]     ...future.result
[13:23:13.204] }
[13:23:13.206] plan(): Setting new future strategy stack:
[13:23:13.206] List of future strategies:
[13:23:13.206] 1. sequential:
[13:23:13.206]    - args: function (..., envir = parent.frame())
[13:23:13.206]    - tweaked: FALSE
[13:23:13.206]    - call: NULL
[13:23:13.206] plan(): nbrOfWorkers() = 1
[13:23:13.208] plan(): Setting new future strategy stack:
[13:23:13.208] List of future strategies:
[13:23:13.208] 1. sequential:
[13:23:13.208]    - args: function (..., envir = parent.frame())
[13:23:13.208]    - tweaked: FALSE
[13:23:13.208]    - call: plan(strategy)
[13:23:13.208] plan(): nbrOfWorkers() = 1
[13:23:13.209] SequentialFuture started (and completed)
[13:23:13.209] - Launch lazy future ... done
[13:23:13.209] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:23:13.212] getGlobalsAndPackages() ...
[13:23:13.212] Searching for globals...
[13:23:13.214] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:23:13.214] Searching for globals ... DONE
[13:23:13.214] Resolving globals: FALSE
[13:23:13.215] 
[13:23:13.215] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.215] getGlobalsAndPackages() ... DONE
[13:23:13.215] run() for ‘Future’ ...
[13:23:13.215] - state: ‘created’
[13:23:13.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.216]   - Field: ‘label’
[13:23:13.216]   - Field: ‘local’
[13:23:13.216]   - Field: ‘owner’
[13:23:13.216]   - Field: ‘envir’
[13:23:13.217]   - Field: ‘packages’
[13:23:13.217]   - Field: ‘gc’
[13:23:13.217]   - Field: ‘conditions’
[13:23:13.217]   - Field: ‘expr’
[13:23:13.217]   - Field: ‘uuid’
[13:23:13.217]   - Field: ‘seed’
[13:23:13.217]   - Field: ‘version’
[13:23:13.217]   - Field: ‘result’
[13:23:13.217]   - Field: ‘asynchronous’
[13:23:13.217]   - Field: ‘calls’
[13:23:13.217]   - Field: ‘globals’
[13:23:13.218]   - Field: ‘stdout’
[13:23:13.218]   - Field: ‘earlySignal’
[13:23:13.218]   - Field: ‘lazy’
[13:23:13.218]   - Field: ‘state’
[13:23:13.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.218] - Launch lazy future ...
[13:23:13.218] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.218] Packages needed by future strategies (n = 0): <none>
[13:23:13.219] {
[13:23:13.219]     {
[13:23:13.219]         {
[13:23:13.219]             ...future.startTime <- base::Sys.time()
[13:23:13.219]             {
[13:23:13.219]                 {
[13:23:13.219]                   {
[13:23:13.219]                     {
[13:23:13.219]                       base::local({
[13:23:13.219]                         has_future <- base::requireNamespace("future", 
[13:23:13.219]                           quietly = TRUE)
[13:23:13.219]                         if (has_future) {
[13:23:13.219]                           ns <- base::getNamespace("future")
[13:23:13.219]                           version <- ns[[".package"]][["version"]]
[13:23:13.219]                           if (is.null(version)) 
[13:23:13.219]                             version <- utils::packageVersion("future")
[13:23:13.219]                         }
[13:23:13.219]                         else {
[13:23:13.219]                           version <- NULL
[13:23:13.219]                         }
[13:23:13.219]                         if (!has_future || version < "1.8.0") {
[13:23:13.219]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.219]                             "", base::R.version$version.string), 
[13:23:13.219]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.219]                               "release", "version")], collapse = " "), 
[13:23:13.219]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.219]                             info)
[13:23:13.219]                           info <- base::paste(info, collapse = "; ")
[13:23:13.219]                           if (!has_future) {
[13:23:13.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.219]                               info)
[13:23:13.219]                           }
[13:23:13.219]                           else {
[13:23:13.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.219]                               info, version)
[13:23:13.219]                           }
[13:23:13.219]                           base::stop(msg)
[13:23:13.219]                         }
[13:23:13.219]                       })
[13:23:13.219]                     }
[13:23:13.219]                     base::local({
[13:23:13.219]                       for (pkg in c("stats", "datasets")) {
[13:23:13.219]                         base::loadNamespace(pkg)
[13:23:13.219]                         base::library(pkg, character.only = TRUE)
[13:23:13.219]                       }
[13:23:13.219]                     })
[13:23:13.219]                   }
[13:23:13.219]                   options(future.plan = NULL)
[13:23:13.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.219]                 }
[13:23:13.219]                 ...future.workdir <- getwd()
[13:23:13.219]             }
[13:23:13.219]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.219]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.219]         }
[13:23:13.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.219]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.219]             base::names(...future.oldOptions))
[13:23:13.219]     }
[13:23:13.219]     if (FALSE) {
[13:23:13.219]     }
[13:23:13.219]     else {
[13:23:13.219]         if (TRUE) {
[13:23:13.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.219]                 open = "w")
[13:23:13.219]         }
[13:23:13.219]         else {
[13:23:13.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.219]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.219]         }
[13:23:13.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.219]             base::sink(type = "output", split = FALSE)
[13:23:13.219]             base::close(...future.stdout)
[13:23:13.219]         }, add = TRUE)
[13:23:13.219]     }
[13:23:13.219]     ...future.frame <- base::sys.nframe()
[13:23:13.219]     ...future.conditions <- base::list()
[13:23:13.219]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.219]     if (FALSE) {
[13:23:13.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.219]     }
[13:23:13.219]     ...future.result <- base::tryCatch({
[13:23:13.219]         base::withCallingHandlers({
[13:23:13.219]             ...future.value <- base::withVisible(base::local({
[13:23:13.219]                 lm(dist ~ speed + I(speed^2), data = cars)
[13:23:13.219]             }))
[13:23:13.219]             future::FutureResult(value = ...future.value$value, 
[13:23:13.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.219]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.219]                     ...future.globalenv.names))
[13:23:13.219]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.219]         }, condition = base::local({
[13:23:13.219]             c <- base::c
[13:23:13.219]             inherits <- base::inherits
[13:23:13.219]             invokeRestart <- base::invokeRestart
[13:23:13.219]             length <- base::length
[13:23:13.219]             list <- base::list
[13:23:13.219]             seq.int <- base::seq.int
[13:23:13.219]             signalCondition <- base::signalCondition
[13:23:13.219]             sys.calls <- base::sys.calls
[13:23:13.219]             `[[` <- base::`[[`
[13:23:13.219]             `+` <- base::`+`
[13:23:13.219]             `<<-` <- base::`<<-`
[13:23:13.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.219]                   3L)]
[13:23:13.219]             }
[13:23:13.219]             function(cond) {
[13:23:13.219]                 is_error <- inherits(cond, "error")
[13:23:13.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.219]                   NULL)
[13:23:13.219]                 if (is_error) {
[13:23:13.219]                   sessionInformation <- function() {
[13:23:13.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.219]                       search = base::search(), system = base::Sys.info())
[13:23:13.219]                   }
[13:23:13.219]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.219]                     cond$call), session = sessionInformation(), 
[13:23:13.219]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.219]                   signalCondition(cond)
[13:23:13.219]                 }
[13:23:13.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.219]                 "immediateCondition"))) {
[13:23:13.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.219]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.219]                   if (TRUE && !signal) {
[13:23:13.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.219]                     {
[13:23:13.219]                       inherits <- base::inherits
[13:23:13.219]                       invokeRestart <- base::invokeRestart
[13:23:13.219]                       is.null <- base::is.null
[13:23:13.219]                       muffled <- FALSE
[13:23:13.219]                       if (inherits(cond, "message")) {
[13:23:13.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.219]                         if (muffled) 
[13:23:13.219]                           invokeRestart("muffleMessage")
[13:23:13.219]                       }
[13:23:13.219]                       else if (inherits(cond, "warning")) {
[13:23:13.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.219]                         if (muffled) 
[13:23:13.219]                           invokeRestart("muffleWarning")
[13:23:13.219]                       }
[13:23:13.219]                       else if (inherits(cond, "condition")) {
[13:23:13.219]                         if (!is.null(pattern)) {
[13:23:13.219]                           computeRestarts <- base::computeRestarts
[13:23:13.219]                           grepl <- base::grepl
[13:23:13.219]                           restarts <- computeRestarts(cond)
[13:23:13.219]                           for (restart in restarts) {
[13:23:13.219]                             name <- restart$name
[13:23:13.219]                             if (is.null(name)) 
[13:23:13.219]                               next
[13:23:13.219]                             if (!grepl(pattern, name)) 
[13:23:13.219]                               next
[13:23:13.219]                             invokeRestart(restart)
[13:23:13.219]                             muffled <- TRUE
[13:23:13.219]                             break
[13:23:13.219]                           }
[13:23:13.219]                         }
[13:23:13.219]                       }
[13:23:13.219]                       invisible(muffled)
[13:23:13.219]                     }
[13:23:13.219]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.219]                   }
[13:23:13.219]                 }
[13:23:13.219]                 else {
[13:23:13.219]                   if (TRUE) {
[13:23:13.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.219]                     {
[13:23:13.219]                       inherits <- base::inherits
[13:23:13.219]                       invokeRestart <- base::invokeRestart
[13:23:13.219]                       is.null <- base::is.null
[13:23:13.219]                       muffled <- FALSE
[13:23:13.219]                       if (inherits(cond, "message")) {
[13:23:13.219]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.219]                         if (muffled) 
[13:23:13.219]                           invokeRestart("muffleMessage")
[13:23:13.219]                       }
[13:23:13.219]                       else if (inherits(cond, "warning")) {
[13:23:13.219]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.219]                         if (muffled) 
[13:23:13.219]                           invokeRestart("muffleWarning")
[13:23:13.219]                       }
[13:23:13.219]                       else if (inherits(cond, "condition")) {
[13:23:13.219]                         if (!is.null(pattern)) {
[13:23:13.219]                           computeRestarts <- base::computeRestarts
[13:23:13.219]                           grepl <- base::grepl
[13:23:13.219]                           restarts <- computeRestarts(cond)
[13:23:13.219]                           for (restart in restarts) {
[13:23:13.219]                             name <- restart$name
[13:23:13.219]                             if (is.null(name)) 
[13:23:13.219]                               next
[13:23:13.219]                             if (!grepl(pattern, name)) 
[13:23:13.219]                               next
[13:23:13.219]                             invokeRestart(restart)
[13:23:13.219]                             muffled <- TRUE
[13:23:13.219]                             break
[13:23:13.219]                           }
[13:23:13.219]                         }
[13:23:13.219]                       }
[13:23:13.219]                       invisible(muffled)
[13:23:13.219]                     }
[13:23:13.219]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.219]                   }
[13:23:13.219]                 }
[13:23:13.219]             }
[13:23:13.219]         }))
[13:23:13.219]     }, error = function(ex) {
[13:23:13.219]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.219]                 ...future.rng), started = ...future.startTime, 
[13:23:13.219]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.219]             version = "1.8"), class = "FutureResult")
[13:23:13.219]     }, finally = {
[13:23:13.219]         if (!identical(...future.workdir, getwd())) 
[13:23:13.219]             setwd(...future.workdir)
[13:23:13.219]         {
[13:23:13.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.219]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.219]             }
[13:23:13.219]             base::options(...future.oldOptions)
[13:23:13.219]             if (.Platform$OS.type == "windows") {
[13:23:13.219]                 old_names <- names(...future.oldEnvVars)
[13:23:13.219]                 envs <- base::Sys.getenv()
[13:23:13.219]                 names <- names(envs)
[13:23:13.219]                 common <- intersect(names, old_names)
[13:23:13.219]                 added <- setdiff(names, old_names)
[13:23:13.219]                 removed <- setdiff(old_names, names)
[13:23:13.219]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.219]                   envs[common]]
[13:23:13.219]                 NAMES <- toupper(changed)
[13:23:13.219]                 args <- list()
[13:23:13.219]                 for (kk in seq_along(NAMES)) {
[13:23:13.219]                   name <- changed[[kk]]
[13:23:13.219]                   NAME <- NAMES[[kk]]
[13:23:13.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.219]                     next
[13:23:13.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.219]                 }
[13:23:13.219]                 NAMES <- toupper(added)
[13:23:13.219]                 for (kk in seq_along(NAMES)) {
[13:23:13.219]                   name <- added[[kk]]
[13:23:13.219]                   NAME <- NAMES[[kk]]
[13:23:13.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.219]                     next
[13:23:13.219]                   args[[name]] <- ""
[13:23:13.219]                 }
[13:23:13.219]                 NAMES <- toupper(removed)
[13:23:13.219]                 for (kk in seq_along(NAMES)) {
[13:23:13.219]                   name <- removed[[kk]]
[13:23:13.219]                   NAME <- NAMES[[kk]]
[13:23:13.219]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.219]                     next
[13:23:13.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.219]                 }
[13:23:13.219]                 if (length(args) > 0) 
[13:23:13.219]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.219]             }
[13:23:13.219]             else {
[13:23:13.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.219]             }
[13:23:13.219]             {
[13:23:13.219]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.219]                   0L) {
[13:23:13.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.219]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.219]                   base::options(opts)
[13:23:13.219]                 }
[13:23:13.219]                 {
[13:23:13.219]                   {
[13:23:13.219]                     NULL
[13:23:13.219]                     RNGkind("Mersenne-Twister")
[13:23:13.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.219]                       inherits = FALSE)
[13:23:13.219]                   }
[13:23:13.219]                   options(future.plan = NULL)
[13:23:13.219]                   if (is.na(NA_character_)) 
[13:23:13.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.219]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.219]                   {
[13:23:13.219]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.219]                     if (!future$lazy) 
[13:23:13.219]                       future <- run(future)
[13:23:13.219]                     invisible(future)
[13:23:13.219]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.219]                 }
[13:23:13.219]             }
[13:23:13.219]         }
[13:23:13.219]     })
[13:23:13.219]     if (TRUE) {
[13:23:13.219]         base::sink(type = "output", split = FALSE)
[13:23:13.219]         if (TRUE) {
[13:23:13.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.219]         }
[13:23:13.219]         else {
[13:23:13.219]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.219]         }
[13:23:13.219]         base::close(...future.stdout)
[13:23:13.219]         ...future.stdout <- NULL
[13:23:13.219]     }
[13:23:13.219]     ...future.result$conditions <- ...future.conditions
[13:23:13.219]     ...future.result$finished <- base::Sys.time()
[13:23:13.219]     ...future.result
[13:23:13.219] }
[13:23:13.221] plan(): Setting new future strategy stack:
[13:23:13.221] List of future strategies:
[13:23:13.221] 1. sequential:
[13:23:13.221]    - args: function (..., envir = parent.frame())
[13:23:13.221]    - tweaked: FALSE
[13:23:13.221]    - call: NULL
[13:23:13.222] plan(): nbrOfWorkers() = 1
[13:23:13.226] plan(): Setting new future strategy stack:
[13:23:13.226] List of future strategies:
[13:23:13.226] 1. sequential:
[13:23:13.226]    - args: function (..., envir = parent.frame())
[13:23:13.226]    - tweaked: FALSE
[13:23:13.226]    - call: plan(strategy)
[13:23:13.227] plan(): nbrOfWorkers() = 1
[13:23:13.227] SequentialFuture started (and completed)
[13:23:13.227] - Launch lazy future ... done
[13:23:13.227] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:23:13.231] getGlobalsAndPackages() ...
[13:23:13.231] Searching for globals...
[13:23:13.233] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:23:13.233] Searching for globals ... DONE
[13:23:13.233] Resolving globals: FALSE
[13:23:13.234] 
[13:23:13.234] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.234] getGlobalsAndPackages() ... DONE
[13:23:13.234] run() for ‘Future’ ...
[13:23:13.234] - state: ‘created’
[13:23:13.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.235] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.235]   - Field: ‘label’
[13:23:13.235]   - Field: ‘local’
[13:23:13.235]   - Field: ‘owner’
[13:23:13.235]   - Field: ‘envir’
[13:23:13.235]   - Field: ‘packages’
[13:23:13.235]   - Field: ‘gc’
[13:23:13.235]   - Field: ‘conditions’
[13:23:13.236]   - Field: ‘expr’
[13:23:13.236]   - Field: ‘uuid’
[13:23:13.236]   - Field: ‘seed’
[13:23:13.236]   - Field: ‘version’
[13:23:13.236]   - Field: ‘result’
[13:23:13.236]   - Field: ‘asynchronous’
[13:23:13.236]   - Field: ‘calls’
[13:23:13.236]   - Field: ‘globals’
[13:23:13.236]   - Field: ‘stdout’
[13:23:13.236]   - Field: ‘earlySignal’
[13:23:13.237]   - Field: ‘lazy’
[13:23:13.237]   - Field: ‘state’
[13:23:13.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.237] - Launch lazy future ...
[13:23:13.237] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.237] Packages needed by future strategies (n = 0): <none>
[13:23:13.238] {
[13:23:13.238]     {
[13:23:13.238]         {
[13:23:13.238]             ...future.startTime <- base::Sys.time()
[13:23:13.238]             {
[13:23:13.238]                 {
[13:23:13.238]                   {
[13:23:13.238]                     {
[13:23:13.238]                       base::local({
[13:23:13.238]                         has_future <- base::requireNamespace("future", 
[13:23:13.238]                           quietly = TRUE)
[13:23:13.238]                         if (has_future) {
[13:23:13.238]                           ns <- base::getNamespace("future")
[13:23:13.238]                           version <- ns[[".package"]][["version"]]
[13:23:13.238]                           if (is.null(version)) 
[13:23:13.238]                             version <- utils::packageVersion("future")
[13:23:13.238]                         }
[13:23:13.238]                         else {
[13:23:13.238]                           version <- NULL
[13:23:13.238]                         }
[13:23:13.238]                         if (!has_future || version < "1.8.0") {
[13:23:13.238]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.238]                             "", base::R.version$version.string), 
[13:23:13.238]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.238]                               "release", "version")], collapse = " "), 
[13:23:13.238]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.238]                             info)
[13:23:13.238]                           info <- base::paste(info, collapse = "; ")
[13:23:13.238]                           if (!has_future) {
[13:23:13.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.238]                               info)
[13:23:13.238]                           }
[13:23:13.238]                           else {
[13:23:13.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.238]                               info, version)
[13:23:13.238]                           }
[13:23:13.238]                           base::stop(msg)
[13:23:13.238]                         }
[13:23:13.238]                       })
[13:23:13.238]                     }
[13:23:13.238]                     base::local({
[13:23:13.238]                       for (pkg in c("stats", "datasets")) {
[13:23:13.238]                         base::loadNamespace(pkg)
[13:23:13.238]                         base::library(pkg, character.only = TRUE)
[13:23:13.238]                       }
[13:23:13.238]                     })
[13:23:13.238]                   }
[13:23:13.238]                   options(future.plan = NULL)
[13:23:13.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.238]                 }
[13:23:13.238]                 ...future.workdir <- getwd()
[13:23:13.238]             }
[13:23:13.238]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.238]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.238]         }
[13:23:13.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.238]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.238]             base::names(...future.oldOptions))
[13:23:13.238]     }
[13:23:13.238]     if (FALSE) {
[13:23:13.238]     }
[13:23:13.238]     else {
[13:23:13.238]         if (TRUE) {
[13:23:13.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.238]                 open = "w")
[13:23:13.238]         }
[13:23:13.238]         else {
[13:23:13.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.238]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.238]         }
[13:23:13.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.238]             base::sink(type = "output", split = FALSE)
[13:23:13.238]             base::close(...future.stdout)
[13:23:13.238]         }, add = TRUE)
[13:23:13.238]     }
[13:23:13.238]     ...future.frame <- base::sys.nframe()
[13:23:13.238]     ...future.conditions <- base::list()
[13:23:13.238]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.238]     if (FALSE) {
[13:23:13.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.238]     }
[13:23:13.238]     ...future.result <- base::tryCatch({
[13:23:13.238]         base::withCallingHandlers({
[13:23:13.238]             ...future.value <- base::withVisible(base::local({
[13:23:13.238]                 lm(dist ~ poly(speed, 2), data = cars)
[13:23:13.238]             }))
[13:23:13.238]             future::FutureResult(value = ...future.value$value, 
[13:23:13.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.238]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.238]                     ...future.globalenv.names))
[13:23:13.238]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.238]         }, condition = base::local({
[13:23:13.238]             c <- base::c
[13:23:13.238]             inherits <- base::inherits
[13:23:13.238]             invokeRestart <- base::invokeRestart
[13:23:13.238]             length <- base::length
[13:23:13.238]             list <- base::list
[13:23:13.238]             seq.int <- base::seq.int
[13:23:13.238]             signalCondition <- base::signalCondition
[13:23:13.238]             sys.calls <- base::sys.calls
[13:23:13.238]             `[[` <- base::`[[`
[13:23:13.238]             `+` <- base::`+`
[13:23:13.238]             `<<-` <- base::`<<-`
[13:23:13.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.238]                   3L)]
[13:23:13.238]             }
[13:23:13.238]             function(cond) {
[13:23:13.238]                 is_error <- inherits(cond, "error")
[13:23:13.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.238]                   NULL)
[13:23:13.238]                 if (is_error) {
[13:23:13.238]                   sessionInformation <- function() {
[13:23:13.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.238]                       search = base::search(), system = base::Sys.info())
[13:23:13.238]                   }
[13:23:13.238]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.238]                     cond$call), session = sessionInformation(), 
[13:23:13.238]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.238]                   signalCondition(cond)
[13:23:13.238]                 }
[13:23:13.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.238]                 "immediateCondition"))) {
[13:23:13.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.238]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.238]                   if (TRUE && !signal) {
[13:23:13.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.238]                     {
[13:23:13.238]                       inherits <- base::inherits
[13:23:13.238]                       invokeRestart <- base::invokeRestart
[13:23:13.238]                       is.null <- base::is.null
[13:23:13.238]                       muffled <- FALSE
[13:23:13.238]                       if (inherits(cond, "message")) {
[13:23:13.238]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.238]                         if (muffled) 
[13:23:13.238]                           invokeRestart("muffleMessage")
[13:23:13.238]                       }
[13:23:13.238]                       else if (inherits(cond, "warning")) {
[13:23:13.238]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.238]                         if (muffled) 
[13:23:13.238]                           invokeRestart("muffleWarning")
[13:23:13.238]                       }
[13:23:13.238]                       else if (inherits(cond, "condition")) {
[13:23:13.238]                         if (!is.null(pattern)) {
[13:23:13.238]                           computeRestarts <- base::computeRestarts
[13:23:13.238]                           grepl <- base::grepl
[13:23:13.238]                           restarts <- computeRestarts(cond)
[13:23:13.238]                           for (restart in restarts) {
[13:23:13.238]                             name <- restart$name
[13:23:13.238]                             if (is.null(name)) 
[13:23:13.238]                               next
[13:23:13.238]                             if (!grepl(pattern, name)) 
[13:23:13.238]                               next
[13:23:13.238]                             invokeRestart(restart)
[13:23:13.238]                             muffled <- TRUE
[13:23:13.238]                             break
[13:23:13.238]                           }
[13:23:13.238]                         }
[13:23:13.238]                       }
[13:23:13.238]                       invisible(muffled)
[13:23:13.238]                     }
[13:23:13.238]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.238]                   }
[13:23:13.238]                 }
[13:23:13.238]                 else {
[13:23:13.238]                   if (TRUE) {
[13:23:13.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.238]                     {
[13:23:13.238]                       inherits <- base::inherits
[13:23:13.238]                       invokeRestart <- base::invokeRestart
[13:23:13.238]                       is.null <- base::is.null
[13:23:13.238]                       muffled <- FALSE
[13:23:13.238]                       if (inherits(cond, "message")) {
[13:23:13.238]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.238]                         if (muffled) 
[13:23:13.238]                           invokeRestart("muffleMessage")
[13:23:13.238]                       }
[13:23:13.238]                       else if (inherits(cond, "warning")) {
[13:23:13.238]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.238]                         if (muffled) 
[13:23:13.238]                           invokeRestart("muffleWarning")
[13:23:13.238]                       }
[13:23:13.238]                       else if (inherits(cond, "condition")) {
[13:23:13.238]                         if (!is.null(pattern)) {
[13:23:13.238]                           computeRestarts <- base::computeRestarts
[13:23:13.238]                           grepl <- base::grepl
[13:23:13.238]                           restarts <- computeRestarts(cond)
[13:23:13.238]                           for (restart in restarts) {
[13:23:13.238]                             name <- restart$name
[13:23:13.238]                             if (is.null(name)) 
[13:23:13.238]                               next
[13:23:13.238]                             if (!grepl(pattern, name)) 
[13:23:13.238]                               next
[13:23:13.238]                             invokeRestart(restart)
[13:23:13.238]                             muffled <- TRUE
[13:23:13.238]                             break
[13:23:13.238]                           }
[13:23:13.238]                         }
[13:23:13.238]                       }
[13:23:13.238]                       invisible(muffled)
[13:23:13.238]                     }
[13:23:13.238]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.238]                   }
[13:23:13.238]                 }
[13:23:13.238]             }
[13:23:13.238]         }))
[13:23:13.238]     }, error = function(ex) {
[13:23:13.238]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.238]                 ...future.rng), started = ...future.startTime, 
[13:23:13.238]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.238]             version = "1.8"), class = "FutureResult")
[13:23:13.238]     }, finally = {
[13:23:13.238]         if (!identical(...future.workdir, getwd())) 
[13:23:13.238]             setwd(...future.workdir)
[13:23:13.238]         {
[13:23:13.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.238]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.238]             }
[13:23:13.238]             base::options(...future.oldOptions)
[13:23:13.238]             if (.Platform$OS.type == "windows") {
[13:23:13.238]                 old_names <- names(...future.oldEnvVars)
[13:23:13.238]                 envs <- base::Sys.getenv()
[13:23:13.238]                 names <- names(envs)
[13:23:13.238]                 common <- intersect(names, old_names)
[13:23:13.238]                 added <- setdiff(names, old_names)
[13:23:13.238]                 removed <- setdiff(old_names, names)
[13:23:13.238]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.238]                   envs[common]]
[13:23:13.238]                 NAMES <- toupper(changed)
[13:23:13.238]                 args <- list()
[13:23:13.238]                 for (kk in seq_along(NAMES)) {
[13:23:13.238]                   name <- changed[[kk]]
[13:23:13.238]                   NAME <- NAMES[[kk]]
[13:23:13.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.238]                     next
[13:23:13.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.238]                 }
[13:23:13.238]                 NAMES <- toupper(added)
[13:23:13.238]                 for (kk in seq_along(NAMES)) {
[13:23:13.238]                   name <- added[[kk]]
[13:23:13.238]                   NAME <- NAMES[[kk]]
[13:23:13.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.238]                     next
[13:23:13.238]                   args[[name]] <- ""
[13:23:13.238]                 }
[13:23:13.238]                 NAMES <- toupper(removed)
[13:23:13.238]                 for (kk in seq_along(NAMES)) {
[13:23:13.238]                   name <- removed[[kk]]
[13:23:13.238]                   NAME <- NAMES[[kk]]
[13:23:13.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.238]                     next
[13:23:13.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.238]                 }
[13:23:13.238]                 if (length(args) > 0) 
[13:23:13.238]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.238]             }
[13:23:13.238]             else {
[13:23:13.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.238]             }
[13:23:13.238]             {
[13:23:13.238]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.238]                   0L) {
[13:23:13.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.238]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.238]                   base::options(opts)
[13:23:13.238]                 }
[13:23:13.238]                 {
[13:23:13.238]                   {
[13:23:13.238]                     NULL
[13:23:13.238]                     RNGkind("Mersenne-Twister")
[13:23:13.238]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.238]                       inherits = FALSE)
[13:23:13.238]                   }
[13:23:13.238]                   options(future.plan = NULL)
[13:23:13.238]                   if (is.na(NA_character_)) 
[13:23:13.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.238]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.238]                   {
[13:23:13.238]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.238]                     if (!future$lazy) 
[13:23:13.238]                       future <- run(future)
[13:23:13.238]                     invisible(future)
[13:23:13.238]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.238]                 }
[13:23:13.238]             }
[13:23:13.238]         }
[13:23:13.238]     })
[13:23:13.238]     if (TRUE) {
[13:23:13.238]         base::sink(type = "output", split = FALSE)
[13:23:13.238]         if (TRUE) {
[13:23:13.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.238]         }
[13:23:13.238]         else {
[13:23:13.238]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.238]         }
[13:23:13.238]         base::close(...future.stdout)
[13:23:13.238]         ...future.stdout <- NULL
[13:23:13.238]     }
[13:23:13.238]     ...future.result$conditions <- ...future.conditions
[13:23:13.238]     ...future.result$finished <- base::Sys.time()
[13:23:13.238]     ...future.result
[13:23:13.238] }
[13:23:13.240] plan(): Setting new future strategy stack:
[13:23:13.240] List of future strategies:
[13:23:13.240] 1. sequential:
[13:23:13.240]    - args: function (..., envir = parent.frame())
[13:23:13.240]    - tweaked: FALSE
[13:23:13.240]    - call: NULL
[13:23:13.241] plan(): nbrOfWorkers() = 1
[13:23:13.242] plan(): Setting new future strategy stack:
[13:23:13.243] List of future strategies:
[13:23:13.243] 1. sequential:
[13:23:13.243]    - args: function (..., envir = parent.frame())
[13:23:13.243]    - tweaked: FALSE
[13:23:13.243]    - call: plan(strategy)
[13:23:13.243] plan(): nbrOfWorkers() = 1
[13:23:13.243] SequentialFuture started (and completed)
[13:23:13.243] - Launch lazy future ... done
[13:23:13.243] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:23:13.245] getGlobalsAndPackages() ...
[13:23:13.246] Searching for globals...
[13:23:13.253] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:13.253] Searching for globals ... DONE
[13:23:13.253] Resolving globals: FALSE
[13:23:13.254] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:13.254] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:13.255] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:13.255] 
[13:23:13.255] getGlobalsAndPackages() ... DONE
[13:23:13.255] run() for ‘Future’ ...
[13:23:13.255] - state: ‘created’
[13:23:13.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.256] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.256]   - Field: ‘label’
[13:23:13.256]   - Field: ‘local’
[13:23:13.256]   - Field: ‘owner’
[13:23:13.256]   - Field: ‘envir’
[13:23:13.256]   - Field: ‘packages’
[13:23:13.256]   - Field: ‘gc’
[13:23:13.257]   - Field: ‘conditions’
[13:23:13.257]   - Field: ‘expr’
[13:23:13.257]   - Field: ‘uuid’
[13:23:13.257]   - Field: ‘seed’
[13:23:13.257]   - Field: ‘version’
[13:23:13.257]   - Field: ‘result’
[13:23:13.257]   - Field: ‘asynchronous’
[13:23:13.257]   - Field: ‘calls’
[13:23:13.257]   - Field: ‘globals’
[13:23:13.257]   - Field: ‘stdout’
[13:23:13.258]   - Field: ‘earlySignal’
[13:23:13.258]   - Field: ‘lazy’
[13:23:13.258]   - Field: ‘state’
[13:23:13.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.258] - Launch lazy future ...
[13:23:13.258] Packages needed by the future expression (n = 0): <none>
[13:23:13.258] Packages needed by future strategies (n = 0): <none>
[13:23:13.259] {
[13:23:13.259]     {
[13:23:13.259]         {
[13:23:13.259]             ...future.startTime <- base::Sys.time()
[13:23:13.259]             {
[13:23:13.259]                 {
[13:23:13.259]                   {
[13:23:13.259]                     base::local({
[13:23:13.259]                       has_future <- base::requireNamespace("future", 
[13:23:13.259]                         quietly = TRUE)
[13:23:13.259]                       if (has_future) {
[13:23:13.259]                         ns <- base::getNamespace("future")
[13:23:13.259]                         version <- ns[[".package"]][["version"]]
[13:23:13.259]                         if (is.null(version)) 
[13:23:13.259]                           version <- utils::packageVersion("future")
[13:23:13.259]                       }
[13:23:13.259]                       else {
[13:23:13.259]                         version <- NULL
[13:23:13.259]                       }
[13:23:13.259]                       if (!has_future || version < "1.8.0") {
[13:23:13.259]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.259]                           "", base::R.version$version.string), 
[13:23:13.259]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:13.259]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.259]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.259]                             "release", "version")], collapse = " "), 
[13:23:13.259]                           hostname = base::Sys.info()[["nodename"]])
[13:23:13.259]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.259]                           info)
[13:23:13.259]                         info <- base::paste(info, collapse = "; ")
[13:23:13.259]                         if (!has_future) {
[13:23:13.259]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.259]                             info)
[13:23:13.259]                         }
[13:23:13.259]                         else {
[13:23:13.259]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.259]                             info, version)
[13:23:13.259]                         }
[13:23:13.259]                         base::stop(msg)
[13:23:13.259]                       }
[13:23:13.259]                     })
[13:23:13.259]                   }
[13:23:13.259]                   options(future.plan = NULL)
[13:23:13.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.259]                 }
[13:23:13.259]                 ...future.workdir <- getwd()
[13:23:13.259]             }
[13:23:13.259]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.259]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.259]         }
[13:23:13.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.259]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.259]             base::names(...future.oldOptions))
[13:23:13.259]     }
[13:23:13.259]     if (FALSE) {
[13:23:13.259]     }
[13:23:13.259]     else {
[13:23:13.259]         if (TRUE) {
[13:23:13.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.259]                 open = "w")
[13:23:13.259]         }
[13:23:13.259]         else {
[13:23:13.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.259]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.259]         }
[13:23:13.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.259]             base::sink(type = "output", split = FALSE)
[13:23:13.259]             base::close(...future.stdout)
[13:23:13.259]         }, add = TRUE)
[13:23:13.259]     }
[13:23:13.259]     ...future.frame <- base::sys.nframe()
[13:23:13.259]     ...future.conditions <- base::list()
[13:23:13.259]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.259]     if (FALSE) {
[13:23:13.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.259]     }
[13:23:13.259]     ...future.result <- base::tryCatch({
[13:23:13.259]         base::withCallingHandlers({
[13:23:13.259]             ...future.value <- base::withVisible(base::local({
[13:23:13.259]                 outer_function(1L)
[13:23:13.259]             }))
[13:23:13.259]             future::FutureResult(value = ...future.value$value, 
[13:23:13.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.259]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.259]                     ...future.globalenv.names))
[13:23:13.259]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.259]         }, condition = base::local({
[13:23:13.259]             c <- base::c
[13:23:13.259]             inherits <- base::inherits
[13:23:13.259]             invokeRestart <- base::invokeRestart
[13:23:13.259]             length <- base::length
[13:23:13.259]             list <- base::list
[13:23:13.259]             seq.int <- base::seq.int
[13:23:13.259]             signalCondition <- base::signalCondition
[13:23:13.259]             sys.calls <- base::sys.calls
[13:23:13.259]             `[[` <- base::`[[`
[13:23:13.259]             `+` <- base::`+`
[13:23:13.259]             `<<-` <- base::`<<-`
[13:23:13.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.259]                   3L)]
[13:23:13.259]             }
[13:23:13.259]             function(cond) {
[13:23:13.259]                 is_error <- inherits(cond, "error")
[13:23:13.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.259]                   NULL)
[13:23:13.259]                 if (is_error) {
[13:23:13.259]                   sessionInformation <- function() {
[13:23:13.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.259]                       search = base::search(), system = base::Sys.info())
[13:23:13.259]                   }
[13:23:13.259]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.259]                     cond$call), session = sessionInformation(), 
[13:23:13.259]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.259]                   signalCondition(cond)
[13:23:13.259]                 }
[13:23:13.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.259]                 "immediateCondition"))) {
[13:23:13.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.259]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.259]                   if (TRUE && !signal) {
[13:23:13.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.259]                     {
[13:23:13.259]                       inherits <- base::inherits
[13:23:13.259]                       invokeRestart <- base::invokeRestart
[13:23:13.259]                       is.null <- base::is.null
[13:23:13.259]                       muffled <- FALSE
[13:23:13.259]                       if (inherits(cond, "message")) {
[13:23:13.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.259]                         if (muffled) 
[13:23:13.259]                           invokeRestart("muffleMessage")
[13:23:13.259]                       }
[13:23:13.259]                       else if (inherits(cond, "warning")) {
[13:23:13.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.259]                         if (muffled) 
[13:23:13.259]                           invokeRestart("muffleWarning")
[13:23:13.259]                       }
[13:23:13.259]                       else if (inherits(cond, "condition")) {
[13:23:13.259]                         if (!is.null(pattern)) {
[13:23:13.259]                           computeRestarts <- base::computeRestarts
[13:23:13.259]                           grepl <- base::grepl
[13:23:13.259]                           restarts <- computeRestarts(cond)
[13:23:13.259]                           for (restart in restarts) {
[13:23:13.259]                             name <- restart$name
[13:23:13.259]                             if (is.null(name)) 
[13:23:13.259]                               next
[13:23:13.259]                             if (!grepl(pattern, name)) 
[13:23:13.259]                               next
[13:23:13.259]                             invokeRestart(restart)
[13:23:13.259]                             muffled <- TRUE
[13:23:13.259]                             break
[13:23:13.259]                           }
[13:23:13.259]                         }
[13:23:13.259]                       }
[13:23:13.259]                       invisible(muffled)
[13:23:13.259]                     }
[13:23:13.259]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.259]                   }
[13:23:13.259]                 }
[13:23:13.259]                 else {
[13:23:13.259]                   if (TRUE) {
[13:23:13.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.259]                     {
[13:23:13.259]                       inherits <- base::inherits
[13:23:13.259]                       invokeRestart <- base::invokeRestart
[13:23:13.259]                       is.null <- base::is.null
[13:23:13.259]                       muffled <- FALSE
[13:23:13.259]                       if (inherits(cond, "message")) {
[13:23:13.259]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.259]                         if (muffled) 
[13:23:13.259]                           invokeRestart("muffleMessage")
[13:23:13.259]                       }
[13:23:13.259]                       else if (inherits(cond, "warning")) {
[13:23:13.259]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.259]                         if (muffled) 
[13:23:13.259]                           invokeRestart("muffleWarning")
[13:23:13.259]                       }
[13:23:13.259]                       else if (inherits(cond, "condition")) {
[13:23:13.259]                         if (!is.null(pattern)) {
[13:23:13.259]                           computeRestarts <- base::computeRestarts
[13:23:13.259]                           grepl <- base::grepl
[13:23:13.259]                           restarts <- computeRestarts(cond)
[13:23:13.259]                           for (restart in restarts) {
[13:23:13.259]                             name <- restart$name
[13:23:13.259]                             if (is.null(name)) 
[13:23:13.259]                               next
[13:23:13.259]                             if (!grepl(pattern, name)) 
[13:23:13.259]                               next
[13:23:13.259]                             invokeRestart(restart)
[13:23:13.259]                             muffled <- TRUE
[13:23:13.259]                             break
[13:23:13.259]                           }
[13:23:13.259]                         }
[13:23:13.259]                       }
[13:23:13.259]                       invisible(muffled)
[13:23:13.259]                     }
[13:23:13.259]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.259]                   }
[13:23:13.259]                 }
[13:23:13.259]             }
[13:23:13.259]         }))
[13:23:13.259]     }, error = function(ex) {
[13:23:13.259]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.259]                 ...future.rng), started = ...future.startTime, 
[13:23:13.259]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.259]             version = "1.8"), class = "FutureResult")
[13:23:13.259]     }, finally = {
[13:23:13.259]         if (!identical(...future.workdir, getwd())) 
[13:23:13.259]             setwd(...future.workdir)
[13:23:13.259]         {
[13:23:13.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.259]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.259]             }
[13:23:13.259]             base::options(...future.oldOptions)
[13:23:13.259]             if (.Platform$OS.type == "windows") {
[13:23:13.259]                 old_names <- names(...future.oldEnvVars)
[13:23:13.259]                 envs <- base::Sys.getenv()
[13:23:13.259]                 names <- names(envs)
[13:23:13.259]                 common <- intersect(names, old_names)
[13:23:13.259]                 added <- setdiff(names, old_names)
[13:23:13.259]                 removed <- setdiff(old_names, names)
[13:23:13.259]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.259]                   envs[common]]
[13:23:13.259]                 NAMES <- toupper(changed)
[13:23:13.259]                 args <- list()
[13:23:13.259]                 for (kk in seq_along(NAMES)) {
[13:23:13.259]                   name <- changed[[kk]]
[13:23:13.259]                   NAME <- NAMES[[kk]]
[13:23:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.259]                     next
[13:23:13.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.259]                 }
[13:23:13.259]                 NAMES <- toupper(added)
[13:23:13.259]                 for (kk in seq_along(NAMES)) {
[13:23:13.259]                   name <- added[[kk]]
[13:23:13.259]                   NAME <- NAMES[[kk]]
[13:23:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.259]                     next
[13:23:13.259]                   args[[name]] <- ""
[13:23:13.259]                 }
[13:23:13.259]                 NAMES <- toupper(removed)
[13:23:13.259]                 for (kk in seq_along(NAMES)) {
[13:23:13.259]                   name <- removed[[kk]]
[13:23:13.259]                   NAME <- NAMES[[kk]]
[13:23:13.259]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.259]                     next
[13:23:13.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.259]                 }
[13:23:13.259]                 if (length(args) > 0) 
[13:23:13.259]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.259]             }
[13:23:13.259]             else {
[13:23:13.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.259]             }
[13:23:13.259]             {
[13:23:13.259]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.259]                   0L) {
[13:23:13.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.259]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.259]                   base::options(opts)
[13:23:13.259]                 }
[13:23:13.259]                 {
[13:23:13.259]                   {
[13:23:13.259]                     NULL
[13:23:13.259]                     RNGkind("Mersenne-Twister")
[13:23:13.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.259]                       inherits = FALSE)
[13:23:13.259]                   }
[13:23:13.259]                   options(future.plan = NULL)
[13:23:13.259]                   if (is.na(NA_character_)) 
[13:23:13.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.259]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.259]                   {
[13:23:13.259]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.259]                     if (!future$lazy) 
[13:23:13.259]                       future <- run(future)
[13:23:13.259]                     invisible(future)
[13:23:13.259]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.259]                 }
[13:23:13.259]             }
[13:23:13.259]         }
[13:23:13.259]     })
[13:23:13.259]     if (TRUE) {
[13:23:13.259]         base::sink(type = "output", split = FALSE)
[13:23:13.259]         if (TRUE) {
[13:23:13.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.259]         }
[13:23:13.259]         else {
[13:23:13.259]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.259]         }
[13:23:13.259]         base::close(...future.stdout)
[13:23:13.259]         ...future.stdout <- NULL
[13:23:13.259]     }
[13:23:13.259]     ...future.result$conditions <- ...future.conditions
[13:23:13.259]     ...future.result$finished <- base::Sys.time()
[13:23:13.259]     ...future.result
[13:23:13.259] }
[13:23:13.261] assign_globals() ...
[13:23:13.261] List of 3
[13:23:13.261]  $ outer_function:function (x)  
[13:23:13.261]  $ map           :function (.x, .f, ...)  
[13:23:13.261]  $ inner_function:function (x)  
[13:23:13.261]  - attr(*, "where")=List of 3
[13:23:13.261]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:23:13.261]   ..$ map           :<environment: R_EmptyEnv> 
[13:23:13.261]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:23:13.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.261]  - attr(*, "resolved")= logi FALSE
[13:23:13.261]  - attr(*, "total_size")= num 7704
[13:23:13.261]  - attr(*, "already-done")= logi TRUE
[13:23:13.264] - reassign environment for ‘outer_function’
[13:23:13.264] - copied ‘outer_function’ to environment
[13:23:13.264] - reassign environment for ‘map’
[13:23:13.264] - copied ‘map’ to environment
[13:23:13.265] - reassign environment for ‘inner_function’
[13:23:13.265] - copied ‘inner_function’ to environment
[13:23:13.265] assign_globals() ... done
[13:23:13.265] plan(): Setting new future strategy stack:
[13:23:13.265] List of future strategies:
[13:23:13.265] 1. sequential:
[13:23:13.265]    - args: function (..., envir = parent.frame())
[13:23:13.265]    - tweaked: FALSE
[13:23:13.265]    - call: NULL
[13:23:13.266] plan(): nbrOfWorkers() = 1
[13:23:13.271] plan(): Setting new future strategy stack:
[13:23:13.271] List of future strategies:
[13:23:13.271] 1. sequential:
[13:23:13.271]    - args: function (..., envir = parent.frame())
[13:23:13.271]    - tweaked: FALSE
[13:23:13.271]    - call: plan(strategy)
[13:23:13.271] plan(): nbrOfWorkers() = 1
[13:23:13.272] SequentialFuture started (and completed)
[13:23:13.272] - Launch lazy future ... done
[13:23:13.272] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:23:13.273] getGlobalsAndPackages() ...
[13:23:13.273] Searching for globals...
[13:23:13.280] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:13.280] Searching for globals ... DONE
[13:23:13.280] Resolving globals: FALSE
[13:23:13.281] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:13.281] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:13.282] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:13.282] 
[13:23:13.282] getGlobalsAndPackages() ... DONE
[13:23:13.282] run() for ‘Future’ ...
[13:23:13.282] - state: ‘created’
[13:23:13.282] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:23:13.283] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:13.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:23:13.283]   - Field: ‘label’
[13:23:13.283]   - Field: ‘local’
[13:23:13.283]   - Field: ‘owner’
[13:23:13.283]   - Field: ‘envir’
[13:23:13.283]   - Field: ‘packages’
[13:23:13.283]   - Field: ‘gc’
[13:23:13.283]   - Field: ‘conditions’
[13:23:13.284]   - Field: ‘expr’
[13:23:13.284]   - Field: ‘uuid’
[13:23:13.284]   - Field: ‘seed’
[13:23:13.284]   - Field: ‘version’
[13:23:13.284]   - Field: ‘result’
[13:23:13.284]   - Field: ‘asynchronous’
[13:23:13.284]   - Field: ‘calls’
[13:23:13.284]   - Field: ‘globals’
[13:23:13.284]   - Field: ‘stdout’
[13:23:13.285]   - Field: ‘earlySignal’
[13:23:13.285]   - Field: ‘lazy’
[13:23:13.285]   - Field: ‘state’
[13:23:13.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:23:13.285] - Launch lazy future ...
[13:23:13.285] Packages needed by the future expression (n = 0): <none>
[13:23:13.285] Packages needed by future strategies (n = 0): <none>
[13:23:13.286] {
[13:23:13.286]     {
[13:23:13.286]         {
[13:23:13.286]             ...future.startTime <- base::Sys.time()
[13:23:13.286]             {
[13:23:13.286]                 {
[13:23:13.286]                   {
[13:23:13.286]                     base::local({
[13:23:13.286]                       has_future <- base::requireNamespace("future", 
[13:23:13.286]                         quietly = TRUE)
[13:23:13.286]                       if (has_future) {
[13:23:13.286]                         ns <- base::getNamespace("future")
[13:23:13.286]                         version <- ns[[".package"]][["version"]]
[13:23:13.286]                         if (is.null(version)) 
[13:23:13.286]                           version <- utils::packageVersion("future")
[13:23:13.286]                       }
[13:23:13.286]                       else {
[13:23:13.286]                         version <- NULL
[13:23:13.286]                       }
[13:23:13.286]                       if (!has_future || version < "1.8.0") {
[13:23:13.286]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.286]                           "", base::R.version$version.string), 
[13:23:13.286]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:13.286]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.286]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.286]                             "release", "version")], collapse = " "), 
[13:23:13.286]                           hostname = base::Sys.info()[["nodename"]])
[13:23:13.286]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.286]                           info)
[13:23:13.286]                         info <- base::paste(info, collapse = "; ")
[13:23:13.286]                         if (!has_future) {
[13:23:13.286]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.286]                             info)
[13:23:13.286]                         }
[13:23:13.286]                         else {
[13:23:13.286]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.286]                             info, version)
[13:23:13.286]                         }
[13:23:13.286]                         base::stop(msg)
[13:23:13.286]                       }
[13:23:13.286]                     })
[13:23:13.286]                   }
[13:23:13.286]                   options(future.plan = NULL)
[13:23:13.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.286]                 }
[13:23:13.286]                 ...future.workdir <- getwd()
[13:23:13.286]             }
[13:23:13.286]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.286]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.286]         }
[13:23:13.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.286]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.286]             base::names(...future.oldOptions))
[13:23:13.286]     }
[13:23:13.286]     if (FALSE) {
[13:23:13.286]     }
[13:23:13.286]     else {
[13:23:13.286]         if (TRUE) {
[13:23:13.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.286]                 open = "w")
[13:23:13.286]         }
[13:23:13.286]         else {
[13:23:13.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.286]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.286]         }
[13:23:13.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.286]             base::sink(type = "output", split = FALSE)
[13:23:13.286]             base::close(...future.stdout)
[13:23:13.286]         }, add = TRUE)
[13:23:13.286]     }
[13:23:13.286]     ...future.frame <- base::sys.nframe()
[13:23:13.286]     ...future.conditions <- base::list()
[13:23:13.286]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.286]     if (FALSE) {
[13:23:13.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.286]     }
[13:23:13.286]     ...future.result <- base::tryCatch({
[13:23:13.286]         base::withCallingHandlers({
[13:23:13.286]             ...future.value <- base::withVisible(base::local({
[13:23:13.286]                 outer_function(1L)
[13:23:13.286]             }))
[13:23:13.286]             future::FutureResult(value = ...future.value$value, 
[13:23:13.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.286]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.286]                     ...future.globalenv.names))
[13:23:13.286]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.286]         }, condition = base::local({
[13:23:13.286]             c <- base::c
[13:23:13.286]             inherits <- base::inherits
[13:23:13.286]             invokeRestart <- base::invokeRestart
[13:23:13.286]             length <- base::length
[13:23:13.286]             list <- base::list
[13:23:13.286]             seq.int <- base::seq.int
[13:23:13.286]             signalCondition <- base::signalCondition
[13:23:13.286]             sys.calls <- base::sys.calls
[13:23:13.286]             `[[` <- base::`[[`
[13:23:13.286]             `+` <- base::`+`
[13:23:13.286]             `<<-` <- base::`<<-`
[13:23:13.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.286]                   3L)]
[13:23:13.286]             }
[13:23:13.286]             function(cond) {
[13:23:13.286]                 is_error <- inherits(cond, "error")
[13:23:13.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.286]                   NULL)
[13:23:13.286]                 if (is_error) {
[13:23:13.286]                   sessionInformation <- function() {
[13:23:13.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.286]                       search = base::search(), system = base::Sys.info())
[13:23:13.286]                   }
[13:23:13.286]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.286]                     cond$call), session = sessionInformation(), 
[13:23:13.286]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.286]                   signalCondition(cond)
[13:23:13.286]                 }
[13:23:13.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.286]                 "immediateCondition"))) {
[13:23:13.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.286]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.286]                   if (TRUE && !signal) {
[13:23:13.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.286]                     {
[13:23:13.286]                       inherits <- base::inherits
[13:23:13.286]                       invokeRestart <- base::invokeRestart
[13:23:13.286]                       is.null <- base::is.null
[13:23:13.286]                       muffled <- FALSE
[13:23:13.286]                       if (inherits(cond, "message")) {
[13:23:13.286]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.286]                         if (muffled) 
[13:23:13.286]                           invokeRestart("muffleMessage")
[13:23:13.286]                       }
[13:23:13.286]                       else if (inherits(cond, "warning")) {
[13:23:13.286]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.286]                         if (muffled) 
[13:23:13.286]                           invokeRestart("muffleWarning")
[13:23:13.286]                       }
[13:23:13.286]                       else if (inherits(cond, "condition")) {
[13:23:13.286]                         if (!is.null(pattern)) {
[13:23:13.286]                           computeRestarts <- base::computeRestarts
[13:23:13.286]                           grepl <- base::grepl
[13:23:13.286]                           restarts <- computeRestarts(cond)
[13:23:13.286]                           for (restart in restarts) {
[13:23:13.286]                             name <- restart$name
[13:23:13.286]                             if (is.null(name)) 
[13:23:13.286]                               next
[13:23:13.286]                             if (!grepl(pattern, name)) 
[13:23:13.286]                               next
[13:23:13.286]                             invokeRestart(restart)
[13:23:13.286]                             muffled <- TRUE
[13:23:13.286]                             break
[13:23:13.286]                           }
[13:23:13.286]                         }
[13:23:13.286]                       }
[13:23:13.286]                       invisible(muffled)
[13:23:13.286]                     }
[13:23:13.286]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.286]                   }
[13:23:13.286]                 }
[13:23:13.286]                 else {
[13:23:13.286]                   if (TRUE) {
[13:23:13.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.286]                     {
[13:23:13.286]                       inherits <- base::inherits
[13:23:13.286]                       invokeRestart <- base::invokeRestart
[13:23:13.286]                       is.null <- base::is.null
[13:23:13.286]                       muffled <- FALSE
[13:23:13.286]                       if (inherits(cond, "message")) {
[13:23:13.286]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.286]                         if (muffled) 
[13:23:13.286]                           invokeRestart("muffleMessage")
[13:23:13.286]                       }
[13:23:13.286]                       else if (inherits(cond, "warning")) {
[13:23:13.286]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.286]                         if (muffled) 
[13:23:13.286]                           invokeRestart("muffleWarning")
[13:23:13.286]                       }
[13:23:13.286]                       else if (inherits(cond, "condition")) {
[13:23:13.286]                         if (!is.null(pattern)) {
[13:23:13.286]                           computeRestarts <- base::computeRestarts
[13:23:13.286]                           grepl <- base::grepl
[13:23:13.286]                           restarts <- computeRestarts(cond)
[13:23:13.286]                           for (restart in restarts) {
[13:23:13.286]                             name <- restart$name
[13:23:13.286]                             if (is.null(name)) 
[13:23:13.286]                               next
[13:23:13.286]                             if (!grepl(pattern, name)) 
[13:23:13.286]                               next
[13:23:13.286]                             invokeRestart(restart)
[13:23:13.286]                             muffled <- TRUE
[13:23:13.286]                             break
[13:23:13.286]                           }
[13:23:13.286]                         }
[13:23:13.286]                       }
[13:23:13.286]                       invisible(muffled)
[13:23:13.286]                     }
[13:23:13.286]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.286]                   }
[13:23:13.286]                 }
[13:23:13.286]             }
[13:23:13.286]         }))
[13:23:13.286]     }, error = function(ex) {
[13:23:13.286]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.286]                 ...future.rng), started = ...future.startTime, 
[13:23:13.286]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.286]             version = "1.8"), class = "FutureResult")
[13:23:13.286]     }, finally = {
[13:23:13.286]         if (!identical(...future.workdir, getwd())) 
[13:23:13.286]             setwd(...future.workdir)
[13:23:13.286]         {
[13:23:13.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.286]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.286]             }
[13:23:13.286]             base::options(...future.oldOptions)
[13:23:13.286]             if (.Platform$OS.type == "windows") {
[13:23:13.286]                 old_names <- names(...future.oldEnvVars)
[13:23:13.286]                 envs <- base::Sys.getenv()
[13:23:13.286]                 names <- names(envs)
[13:23:13.286]                 common <- intersect(names, old_names)
[13:23:13.286]                 added <- setdiff(names, old_names)
[13:23:13.286]                 removed <- setdiff(old_names, names)
[13:23:13.286]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.286]                   envs[common]]
[13:23:13.286]                 NAMES <- toupper(changed)
[13:23:13.286]                 args <- list()
[13:23:13.286]                 for (kk in seq_along(NAMES)) {
[13:23:13.286]                   name <- changed[[kk]]
[13:23:13.286]                   NAME <- NAMES[[kk]]
[13:23:13.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.286]                     next
[13:23:13.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.286]                 }
[13:23:13.286]                 NAMES <- toupper(added)
[13:23:13.286]                 for (kk in seq_along(NAMES)) {
[13:23:13.286]                   name <- added[[kk]]
[13:23:13.286]                   NAME <- NAMES[[kk]]
[13:23:13.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.286]                     next
[13:23:13.286]                   args[[name]] <- ""
[13:23:13.286]                 }
[13:23:13.286]                 NAMES <- toupper(removed)
[13:23:13.286]                 for (kk in seq_along(NAMES)) {
[13:23:13.286]                   name <- removed[[kk]]
[13:23:13.286]                   NAME <- NAMES[[kk]]
[13:23:13.286]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.286]                     next
[13:23:13.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.286]                 }
[13:23:13.286]                 if (length(args) > 0) 
[13:23:13.286]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.286]             }
[13:23:13.286]             else {
[13:23:13.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.286]             }
[13:23:13.286]             {
[13:23:13.286]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.286]                   0L) {
[13:23:13.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.286]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.286]                   base::options(opts)
[13:23:13.286]                 }
[13:23:13.286]                 {
[13:23:13.286]                   {
[13:23:13.286]                     NULL
[13:23:13.286]                     RNGkind("Mersenne-Twister")
[13:23:13.286]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:13.286]                       inherits = FALSE)
[13:23:13.286]                   }
[13:23:13.286]                   options(future.plan = NULL)
[13:23:13.286]                   if (is.na(NA_character_)) 
[13:23:13.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.286]                   future::plan(list(function (..., envir = parent.frame()) 
[13:23:13.286]                   {
[13:23:13.286]                     future <- SequentialFuture(..., envir = envir)
[13:23:13.286]                     if (!future$lazy) 
[13:23:13.286]                       future <- run(future)
[13:23:13.286]                     invisible(future)
[13:23:13.286]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.286]                 }
[13:23:13.286]             }
[13:23:13.286]         }
[13:23:13.286]     })
[13:23:13.286]     if (TRUE) {
[13:23:13.286]         base::sink(type = "output", split = FALSE)
[13:23:13.286]         if (TRUE) {
[13:23:13.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.286]         }
[13:23:13.286]         else {
[13:23:13.286]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.286]         }
[13:23:13.286]         base::close(...future.stdout)
[13:23:13.286]         ...future.stdout <- NULL
[13:23:13.286]     }
[13:23:13.286]     ...future.result$conditions <- ...future.conditions
[13:23:13.286]     ...future.result$finished <- base::Sys.time()
[13:23:13.286]     ...future.result
[13:23:13.286] }
[13:23:13.288] assign_globals() ...
[13:23:13.288] List of 3
[13:23:13.288]  $ outer_function:function (x)  
[13:23:13.288]  $ map           :function (.x, .f, ...)  
[13:23:13.288]  $ inner_function:function (x)  
[13:23:13.288]  - attr(*, "where")=List of 3
[13:23:13.288]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:23:13.288]   ..$ map           :<environment: R_EmptyEnv> 
[13:23:13.288]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:23:13.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.288]  - attr(*, "resolved")= logi FALSE
[13:23:13.288]  - attr(*, "total_size")= num 7704
[13:23:13.288]  - attr(*, "already-done")= logi TRUE
[13:23:13.291] - reassign environment for ‘outer_function’
[13:23:13.291] - copied ‘outer_function’ to environment
[13:23:13.291] - reassign environment for ‘map’
[13:23:13.291] - copied ‘map’ to environment
[13:23:13.292] - reassign environment for ‘inner_function’
[13:23:13.292] - copied ‘inner_function’ to environment
[13:23:13.292] assign_globals() ... done
[13:23:13.292] plan(): Setting new future strategy stack:
[13:23:13.292] List of future strategies:
[13:23:13.292] 1. sequential:
[13:23:13.292]    - args: function (..., envir = parent.frame())
[13:23:13.292]    - tweaked: FALSE
[13:23:13.292]    - call: NULL
[13:23:13.292] plan(): nbrOfWorkers() = 1
[13:23:13.293] plan(): Setting new future strategy stack:
[13:23:13.293] List of future strategies:
[13:23:13.293] 1. sequential:
[13:23:13.293]    - args: function (..., envir = parent.frame())
[13:23:13.293]    - tweaked: FALSE
[13:23:13.293]    - call: plan(strategy)
[13:23:13.294] plan(): nbrOfWorkers() = 1
[13:23:13.294] SequentialFuture started (and completed)
[13:23:13.294] - Launch lazy future ... done
[13:23:13.294] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[13:23:13.307] plan(): Setting new future strategy stack:
[13:23:13.307] List of future strategies:
[13:23:13.307] 1. multicore:
[13:23:13.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.307]    - tweaked: FALSE
[13:23:13.307]    - call: plan(strategy)
[13:23:13.311] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:23:13.311] getGlobalsAndPackages() ...
[13:23:13.311] Searching for globals...
[13:23:13.313] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.313] Searching for globals ... DONE
[13:23:13.313] Resolving globals: FALSE
[13:23:13.314] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.314] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.314] - globals: [2] ‘weight’, ‘group’
[13:23:13.314] - packages: [1] ‘stats’
[13:23:13.315] getGlobalsAndPackages() ... DONE
[13:23:13.315] run() for ‘Future’ ...
[13:23:13.315] - state: ‘created’
[13:23:13.315] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.319] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.320]   - Field: ‘label’
[13:23:13.320]   - Field: ‘local’
[13:23:13.320]   - Field: ‘owner’
[13:23:13.320]   - Field: ‘envir’
[13:23:13.320]   - Field: ‘workers’
[13:23:13.320]   - Field: ‘packages’
[13:23:13.320]   - Field: ‘gc’
[13:23:13.320]   - Field: ‘job’
[13:23:13.320]   - Field: ‘conditions’
[13:23:13.320]   - Field: ‘expr’
[13:23:13.321]   - Field: ‘uuid’
[13:23:13.321]   - Field: ‘seed’
[13:23:13.321]   - Field: ‘version’
[13:23:13.321]   - Field: ‘result’
[13:23:13.321]   - Field: ‘asynchronous’
[13:23:13.321]   - Field: ‘calls’
[13:23:13.321]   - Field: ‘globals’
[13:23:13.321]   - Field: ‘stdout’
[13:23:13.321]   - Field: ‘earlySignal’
[13:23:13.321]   - Field: ‘lazy’
[13:23:13.322]   - Field: ‘state’
[13:23:13.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.322] - Launch lazy future ...
[13:23:13.323] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.323] Packages needed by future strategies (n = 0): <none>
[13:23:13.324] {
[13:23:13.324]     {
[13:23:13.324]         {
[13:23:13.324]             ...future.startTime <- base::Sys.time()
[13:23:13.324]             {
[13:23:13.324]                 {
[13:23:13.324]                   {
[13:23:13.324]                     {
[13:23:13.324]                       {
[13:23:13.324]                         base::local({
[13:23:13.324]                           has_future <- base::requireNamespace("future", 
[13:23:13.324]                             quietly = TRUE)
[13:23:13.324]                           if (has_future) {
[13:23:13.324]                             ns <- base::getNamespace("future")
[13:23:13.324]                             version <- ns[[".package"]][["version"]]
[13:23:13.324]                             if (is.null(version)) 
[13:23:13.324]                               version <- utils::packageVersion("future")
[13:23:13.324]                           }
[13:23:13.324]                           else {
[13:23:13.324]                             version <- NULL
[13:23:13.324]                           }
[13:23:13.324]                           if (!has_future || version < "1.8.0") {
[13:23:13.324]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.324]                               "", base::R.version$version.string), 
[13:23:13.324]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.324]                                 base::R.version$platform, 8 * 
[13:23:13.324]                                   base::.Machine$sizeof.pointer), 
[13:23:13.324]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.324]                                 "release", "version")], collapse = " "), 
[13:23:13.324]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.324]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.324]                               info)
[13:23:13.324]                             info <- base::paste(info, collapse = "; ")
[13:23:13.324]                             if (!has_future) {
[13:23:13.324]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.324]                                 info)
[13:23:13.324]                             }
[13:23:13.324]                             else {
[13:23:13.324]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.324]                                 info, version)
[13:23:13.324]                             }
[13:23:13.324]                             base::stop(msg)
[13:23:13.324]                           }
[13:23:13.324]                         })
[13:23:13.324]                       }
[13:23:13.324]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.324]                       base::options(mc.cores = 1L)
[13:23:13.324]                     }
[13:23:13.324]                     base::local({
[13:23:13.324]                       for (pkg in "stats") {
[13:23:13.324]                         base::loadNamespace(pkg)
[13:23:13.324]                         base::library(pkg, character.only = TRUE)
[13:23:13.324]                       }
[13:23:13.324]                     })
[13:23:13.324]                   }
[13:23:13.324]                   options(future.plan = NULL)
[13:23:13.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.324]                 }
[13:23:13.324]                 ...future.workdir <- getwd()
[13:23:13.324]             }
[13:23:13.324]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.324]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.324]         }
[13:23:13.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.324]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.324]             base::names(...future.oldOptions))
[13:23:13.324]     }
[13:23:13.324]     if (FALSE) {
[13:23:13.324]     }
[13:23:13.324]     else {
[13:23:13.324]         if (TRUE) {
[13:23:13.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.324]                 open = "w")
[13:23:13.324]         }
[13:23:13.324]         else {
[13:23:13.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.324]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.324]         }
[13:23:13.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.324]             base::sink(type = "output", split = FALSE)
[13:23:13.324]             base::close(...future.stdout)
[13:23:13.324]         }, add = TRUE)
[13:23:13.324]     }
[13:23:13.324]     ...future.frame <- base::sys.nframe()
[13:23:13.324]     ...future.conditions <- base::list()
[13:23:13.324]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.324]     if (FALSE) {
[13:23:13.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.324]     }
[13:23:13.324]     ...future.result <- base::tryCatch({
[13:23:13.324]         base::withCallingHandlers({
[13:23:13.324]             ...future.value <- base::withVisible(base::local({
[13:23:13.324]                 withCallingHandlers({
[13:23:13.324]                   {
[13:23:13.324]                     lm(weight ~ group - 1)
[13:23:13.324]                   }
[13:23:13.324]                 }, immediateCondition = function(cond) {
[13:23:13.324]                   save_rds <- function (object, pathname, ...) 
[13:23:13.324]                   {
[13:23:13.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.324]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.324]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.324]                         fi_tmp[["mtime"]])
[13:23:13.324]                     }
[13:23:13.324]                     tryCatch({
[13:23:13.324]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.324]                     }, error = function(ex) {
[13:23:13.324]                       msg <- conditionMessage(ex)
[13:23:13.324]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.324]                         fi_tmp[["mtime"]], msg)
[13:23:13.324]                       ex$message <- msg
[13:23:13.324]                       stop(ex)
[13:23:13.324]                     })
[13:23:13.324]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.324]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.324]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.324]                       fi <- file.info(pathname)
[13:23:13.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.324]                         fi[["size"]], fi[["mtime"]])
[13:23:13.324]                       stop(msg)
[13:23:13.324]                     }
[13:23:13.324]                     invisible(pathname)
[13:23:13.324]                   }
[13:23:13.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.324]                     rootPath = tempdir()) 
[13:23:13.324]                   {
[13:23:13.324]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.324]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.324]                       tmpdir = path, fileext = ".rds")
[13:23:13.324]                     save_rds(obj, file)
[13:23:13.324]                   }
[13:23:13.324]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.324]                   {
[13:23:13.324]                     inherits <- base::inherits
[13:23:13.324]                     invokeRestart <- base::invokeRestart
[13:23:13.324]                     is.null <- base::is.null
[13:23:13.324]                     muffled <- FALSE
[13:23:13.324]                     if (inherits(cond, "message")) {
[13:23:13.324]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.324]                       if (muffled) 
[13:23:13.324]                         invokeRestart("muffleMessage")
[13:23:13.324]                     }
[13:23:13.324]                     else if (inherits(cond, "warning")) {
[13:23:13.324]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.324]                       if (muffled) 
[13:23:13.324]                         invokeRestart("muffleWarning")
[13:23:13.324]                     }
[13:23:13.324]                     else if (inherits(cond, "condition")) {
[13:23:13.324]                       if (!is.null(pattern)) {
[13:23:13.324]                         computeRestarts <- base::computeRestarts
[13:23:13.324]                         grepl <- base::grepl
[13:23:13.324]                         restarts <- computeRestarts(cond)
[13:23:13.324]                         for (restart in restarts) {
[13:23:13.324]                           name <- restart$name
[13:23:13.324]                           if (is.null(name)) 
[13:23:13.324]                             next
[13:23:13.324]                           if (!grepl(pattern, name)) 
[13:23:13.324]                             next
[13:23:13.324]                           invokeRestart(restart)
[13:23:13.324]                           muffled <- TRUE
[13:23:13.324]                           break
[13:23:13.324]                         }
[13:23:13.324]                       }
[13:23:13.324]                     }
[13:23:13.324]                     invisible(muffled)
[13:23:13.324]                   }
[13:23:13.324]                   muffleCondition(cond)
[13:23:13.324]                 })
[13:23:13.324]             }))
[13:23:13.324]             future::FutureResult(value = ...future.value$value, 
[13:23:13.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.324]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.324]                     ...future.globalenv.names))
[13:23:13.324]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.324]         }, condition = base::local({
[13:23:13.324]             c <- base::c
[13:23:13.324]             inherits <- base::inherits
[13:23:13.324]             invokeRestart <- base::invokeRestart
[13:23:13.324]             length <- base::length
[13:23:13.324]             list <- base::list
[13:23:13.324]             seq.int <- base::seq.int
[13:23:13.324]             signalCondition <- base::signalCondition
[13:23:13.324]             sys.calls <- base::sys.calls
[13:23:13.324]             `[[` <- base::`[[`
[13:23:13.324]             `+` <- base::`+`
[13:23:13.324]             `<<-` <- base::`<<-`
[13:23:13.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.324]                   3L)]
[13:23:13.324]             }
[13:23:13.324]             function(cond) {
[13:23:13.324]                 is_error <- inherits(cond, "error")
[13:23:13.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.324]                   NULL)
[13:23:13.324]                 if (is_error) {
[13:23:13.324]                   sessionInformation <- function() {
[13:23:13.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.324]                       search = base::search(), system = base::Sys.info())
[13:23:13.324]                   }
[13:23:13.324]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.324]                     cond$call), session = sessionInformation(), 
[13:23:13.324]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.324]                   signalCondition(cond)
[13:23:13.324]                 }
[13:23:13.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.324]                 "immediateCondition"))) {
[13:23:13.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.324]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.324]                   if (TRUE && !signal) {
[13:23:13.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.324]                     {
[13:23:13.324]                       inherits <- base::inherits
[13:23:13.324]                       invokeRestart <- base::invokeRestart
[13:23:13.324]                       is.null <- base::is.null
[13:23:13.324]                       muffled <- FALSE
[13:23:13.324]                       if (inherits(cond, "message")) {
[13:23:13.324]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.324]                         if (muffled) 
[13:23:13.324]                           invokeRestart("muffleMessage")
[13:23:13.324]                       }
[13:23:13.324]                       else if (inherits(cond, "warning")) {
[13:23:13.324]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.324]                         if (muffled) 
[13:23:13.324]                           invokeRestart("muffleWarning")
[13:23:13.324]                       }
[13:23:13.324]                       else if (inherits(cond, "condition")) {
[13:23:13.324]                         if (!is.null(pattern)) {
[13:23:13.324]                           computeRestarts <- base::computeRestarts
[13:23:13.324]                           grepl <- base::grepl
[13:23:13.324]                           restarts <- computeRestarts(cond)
[13:23:13.324]                           for (restart in restarts) {
[13:23:13.324]                             name <- restart$name
[13:23:13.324]                             if (is.null(name)) 
[13:23:13.324]                               next
[13:23:13.324]                             if (!grepl(pattern, name)) 
[13:23:13.324]                               next
[13:23:13.324]                             invokeRestart(restart)
[13:23:13.324]                             muffled <- TRUE
[13:23:13.324]                             break
[13:23:13.324]                           }
[13:23:13.324]                         }
[13:23:13.324]                       }
[13:23:13.324]                       invisible(muffled)
[13:23:13.324]                     }
[13:23:13.324]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.324]                   }
[13:23:13.324]                 }
[13:23:13.324]                 else {
[13:23:13.324]                   if (TRUE) {
[13:23:13.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.324]                     {
[13:23:13.324]                       inherits <- base::inherits
[13:23:13.324]                       invokeRestart <- base::invokeRestart
[13:23:13.324]                       is.null <- base::is.null
[13:23:13.324]                       muffled <- FALSE
[13:23:13.324]                       if (inherits(cond, "message")) {
[13:23:13.324]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.324]                         if (muffled) 
[13:23:13.324]                           invokeRestart("muffleMessage")
[13:23:13.324]                       }
[13:23:13.324]                       else if (inherits(cond, "warning")) {
[13:23:13.324]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.324]                         if (muffled) 
[13:23:13.324]                           invokeRestart("muffleWarning")
[13:23:13.324]                       }
[13:23:13.324]                       else if (inherits(cond, "condition")) {
[13:23:13.324]                         if (!is.null(pattern)) {
[13:23:13.324]                           computeRestarts <- base::computeRestarts
[13:23:13.324]                           grepl <- base::grepl
[13:23:13.324]                           restarts <- computeRestarts(cond)
[13:23:13.324]                           for (restart in restarts) {
[13:23:13.324]                             name <- restart$name
[13:23:13.324]                             if (is.null(name)) 
[13:23:13.324]                               next
[13:23:13.324]                             if (!grepl(pattern, name)) 
[13:23:13.324]                               next
[13:23:13.324]                             invokeRestart(restart)
[13:23:13.324]                             muffled <- TRUE
[13:23:13.324]                             break
[13:23:13.324]                           }
[13:23:13.324]                         }
[13:23:13.324]                       }
[13:23:13.324]                       invisible(muffled)
[13:23:13.324]                     }
[13:23:13.324]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.324]                   }
[13:23:13.324]                 }
[13:23:13.324]             }
[13:23:13.324]         }))
[13:23:13.324]     }, error = function(ex) {
[13:23:13.324]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.324]                 ...future.rng), started = ...future.startTime, 
[13:23:13.324]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.324]             version = "1.8"), class = "FutureResult")
[13:23:13.324]     }, finally = {
[13:23:13.324]         if (!identical(...future.workdir, getwd())) 
[13:23:13.324]             setwd(...future.workdir)
[13:23:13.324]         {
[13:23:13.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.324]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.324]             }
[13:23:13.324]             base::options(...future.oldOptions)
[13:23:13.324]             if (.Platform$OS.type == "windows") {
[13:23:13.324]                 old_names <- names(...future.oldEnvVars)
[13:23:13.324]                 envs <- base::Sys.getenv()
[13:23:13.324]                 names <- names(envs)
[13:23:13.324]                 common <- intersect(names, old_names)
[13:23:13.324]                 added <- setdiff(names, old_names)
[13:23:13.324]                 removed <- setdiff(old_names, names)
[13:23:13.324]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.324]                   envs[common]]
[13:23:13.324]                 NAMES <- toupper(changed)
[13:23:13.324]                 args <- list()
[13:23:13.324]                 for (kk in seq_along(NAMES)) {
[13:23:13.324]                   name <- changed[[kk]]
[13:23:13.324]                   NAME <- NAMES[[kk]]
[13:23:13.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.324]                     next
[13:23:13.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.324]                 }
[13:23:13.324]                 NAMES <- toupper(added)
[13:23:13.324]                 for (kk in seq_along(NAMES)) {
[13:23:13.324]                   name <- added[[kk]]
[13:23:13.324]                   NAME <- NAMES[[kk]]
[13:23:13.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.324]                     next
[13:23:13.324]                   args[[name]] <- ""
[13:23:13.324]                 }
[13:23:13.324]                 NAMES <- toupper(removed)
[13:23:13.324]                 for (kk in seq_along(NAMES)) {
[13:23:13.324]                   name <- removed[[kk]]
[13:23:13.324]                   NAME <- NAMES[[kk]]
[13:23:13.324]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.324]                     next
[13:23:13.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.324]                 }
[13:23:13.324]                 if (length(args) > 0) 
[13:23:13.324]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.324]             }
[13:23:13.324]             else {
[13:23:13.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.324]             }
[13:23:13.324]             {
[13:23:13.324]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.324]                   0L) {
[13:23:13.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.324]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.324]                   base::options(opts)
[13:23:13.324]                 }
[13:23:13.324]                 {
[13:23:13.324]                   {
[13:23:13.324]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.324]                     NULL
[13:23:13.324]                   }
[13:23:13.324]                   options(future.plan = NULL)
[13:23:13.324]                   if (is.na(NA_character_)) 
[13:23:13.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.324]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.324]                     envir = parent.frame()) 
[13:23:13.324]                   {
[13:23:13.324]                     default_workers <- missing(workers)
[13:23:13.324]                     if (is.function(workers)) 
[13:23:13.324]                       workers <- workers()
[13:23:13.324]                     workers <- structure(as.integer(workers), 
[13:23:13.324]                       class = class(workers))
[13:23:13.324]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.324]                       1L)
[13:23:13.324]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.324]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.324]                       if (default_workers) 
[13:23:13.324]                         supportsMulticore(warn = TRUE)
[13:23:13.324]                       return(sequential(..., envir = envir))
[13:23:13.324]                     }
[13:23:13.324]                     oopts <- options(mc.cores = workers)
[13:23:13.324]                     on.exit(options(oopts))
[13:23:13.324]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.324]                       envir = envir)
[13:23:13.324]                     if (!future$lazy) 
[13:23:13.324]                       future <- run(future)
[13:23:13.324]                     invisible(future)
[13:23:13.324]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.324]                 }
[13:23:13.324]             }
[13:23:13.324]         }
[13:23:13.324]     })
[13:23:13.324]     if (TRUE) {
[13:23:13.324]         base::sink(type = "output", split = FALSE)
[13:23:13.324]         if (TRUE) {
[13:23:13.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.324]         }
[13:23:13.324]         else {
[13:23:13.324]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.324]         }
[13:23:13.324]         base::close(...future.stdout)
[13:23:13.324]         ...future.stdout <- NULL
[13:23:13.324]     }
[13:23:13.324]     ...future.result$conditions <- ...future.conditions
[13:23:13.324]     ...future.result$finished <- base::Sys.time()
[13:23:13.324]     ...future.result
[13:23:13.324] }
[13:23:13.326] assign_globals() ...
[13:23:13.326] List of 2
[13:23:13.326]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.326]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.326]  - attr(*, "where")=List of 2
[13:23:13.326]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.326]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.326]  - attr(*, "resolved")= logi FALSE
[13:23:13.326]  - attr(*, "total_size")= num 896
[13:23:13.326]  - attr(*, "already-done")= logi TRUE
[13:23:13.330] - copied ‘weight’ to environment
[13:23:13.330] - copied ‘group’ to environment
[13:23:13.330] assign_globals() ... done
[13:23:13.330] requestCore(): workers = 2
[13:23:13.333] MulticoreFuture started
[13:23:13.334] - Launch lazy future ... done
[13:23:13.334] run() for ‘MulticoreFuture’ ... done
[13:23:13.334] plan(): Setting new future strategy stack:
[13:23:13.335] result() for MulticoreFuture ...
[13:23:13.335] List of future strategies:
[13:23:13.335] 1. sequential:
[13:23:13.335]    - args: function (..., envir = parent.frame())
[13:23:13.335]    - tweaked: FALSE
[13:23:13.335]    - call: NULL
[13:23:13.336] plan(): nbrOfWorkers() = 1
[13:23:13.339] plan(): Setting new future strategy stack:
[13:23:13.340] List of future strategies:
[13:23:13.340] 1. multicore:
[13:23:13.340]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.340]    - tweaked: FALSE
[13:23:13.340]    - call: plan(strategy)
[13:23:13.345] plan(): nbrOfWorkers() = 2
[13:23:13.359] result() for MulticoreFuture ...
[13:23:13.359] result() for MulticoreFuture ... done
[13:23:13.359] result() for MulticoreFuture ... done
[13:23:13.359] result() for MulticoreFuture ...
[13:23:13.360] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.362] getGlobalsAndPackages() ...
[13:23:13.362] Searching for globals...
[13:23:13.364] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.365] Searching for globals ... DONE
[13:23:13.365] Resolving globals: FALSE
[13:23:13.365] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.366] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.366] - globals: [2] ‘weight’, ‘group’
[13:23:13.366] - packages: [1] ‘stats’
[13:23:13.366] getGlobalsAndPackages() ... DONE
[13:23:13.367] run() for ‘Future’ ...
[13:23:13.367] - state: ‘created’
[13:23:13.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.372] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.372]   - Field: ‘label’
[13:23:13.372]   - Field: ‘local’
[13:23:13.372]   - Field: ‘owner’
[13:23:13.372]   - Field: ‘envir’
[13:23:13.372]   - Field: ‘workers’
[13:23:13.373]   - Field: ‘packages’
[13:23:13.373]   - Field: ‘gc’
[13:23:13.373]   - Field: ‘job’
[13:23:13.373]   - Field: ‘conditions’
[13:23:13.373]   - Field: ‘expr’
[13:23:13.373]   - Field: ‘uuid’
[13:23:13.373]   - Field: ‘seed’
[13:23:13.373]   - Field: ‘version’
[13:23:13.373]   - Field: ‘result’
[13:23:13.374]   - Field: ‘asynchronous’
[13:23:13.374]   - Field: ‘calls’
[13:23:13.374]   - Field: ‘globals’
[13:23:13.374]   - Field: ‘stdout’
[13:23:13.374]   - Field: ‘earlySignal’
[13:23:13.374]   - Field: ‘lazy’
[13:23:13.374]   - Field: ‘state’
[13:23:13.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.374] - Launch lazy future ...
[13:23:13.375] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.375] Packages needed by future strategies (n = 0): <none>
[13:23:13.376] {
[13:23:13.376]     {
[13:23:13.376]         {
[13:23:13.376]             ...future.startTime <- base::Sys.time()
[13:23:13.376]             {
[13:23:13.376]                 {
[13:23:13.376]                   {
[13:23:13.376]                     {
[13:23:13.376]                       {
[13:23:13.376]                         base::local({
[13:23:13.376]                           has_future <- base::requireNamespace("future", 
[13:23:13.376]                             quietly = TRUE)
[13:23:13.376]                           if (has_future) {
[13:23:13.376]                             ns <- base::getNamespace("future")
[13:23:13.376]                             version <- ns[[".package"]][["version"]]
[13:23:13.376]                             if (is.null(version)) 
[13:23:13.376]                               version <- utils::packageVersion("future")
[13:23:13.376]                           }
[13:23:13.376]                           else {
[13:23:13.376]                             version <- NULL
[13:23:13.376]                           }
[13:23:13.376]                           if (!has_future || version < "1.8.0") {
[13:23:13.376]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.376]                               "", base::R.version$version.string), 
[13:23:13.376]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.376]                                 base::R.version$platform, 8 * 
[13:23:13.376]                                   base::.Machine$sizeof.pointer), 
[13:23:13.376]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.376]                                 "release", "version")], collapse = " "), 
[13:23:13.376]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.376]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.376]                               info)
[13:23:13.376]                             info <- base::paste(info, collapse = "; ")
[13:23:13.376]                             if (!has_future) {
[13:23:13.376]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.376]                                 info)
[13:23:13.376]                             }
[13:23:13.376]                             else {
[13:23:13.376]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.376]                                 info, version)
[13:23:13.376]                             }
[13:23:13.376]                             base::stop(msg)
[13:23:13.376]                           }
[13:23:13.376]                         })
[13:23:13.376]                       }
[13:23:13.376]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.376]                       base::options(mc.cores = 1L)
[13:23:13.376]                     }
[13:23:13.376]                     base::local({
[13:23:13.376]                       for (pkg in "stats") {
[13:23:13.376]                         base::loadNamespace(pkg)
[13:23:13.376]                         base::library(pkg, character.only = TRUE)
[13:23:13.376]                       }
[13:23:13.376]                     })
[13:23:13.376]                   }
[13:23:13.376]                   options(future.plan = NULL)
[13:23:13.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.376]                 }
[13:23:13.376]                 ...future.workdir <- getwd()
[13:23:13.376]             }
[13:23:13.376]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.376]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.376]         }
[13:23:13.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.376]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.376]             base::names(...future.oldOptions))
[13:23:13.376]     }
[13:23:13.376]     if (FALSE) {
[13:23:13.376]     }
[13:23:13.376]     else {
[13:23:13.376]         if (TRUE) {
[13:23:13.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.376]                 open = "w")
[13:23:13.376]         }
[13:23:13.376]         else {
[13:23:13.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.376]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.376]         }
[13:23:13.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.376]             base::sink(type = "output", split = FALSE)
[13:23:13.376]             base::close(...future.stdout)
[13:23:13.376]         }, add = TRUE)
[13:23:13.376]     }
[13:23:13.376]     ...future.frame <- base::sys.nframe()
[13:23:13.376]     ...future.conditions <- base::list()
[13:23:13.376]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.376]     if (FALSE) {
[13:23:13.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.376]     }
[13:23:13.376]     ...future.result <- base::tryCatch({
[13:23:13.376]         base::withCallingHandlers({
[13:23:13.376]             ...future.value <- base::withVisible(base::local({
[13:23:13.376]                 withCallingHandlers({
[13:23:13.376]                   {
[13:23:13.376]                     lm(weight ~ group - 1)
[13:23:13.376]                   }
[13:23:13.376]                 }, immediateCondition = function(cond) {
[13:23:13.376]                   save_rds <- function (object, pathname, ...) 
[13:23:13.376]                   {
[13:23:13.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.376]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.376]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.376]                         fi_tmp[["mtime"]])
[13:23:13.376]                     }
[13:23:13.376]                     tryCatch({
[13:23:13.376]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.376]                     }, error = function(ex) {
[13:23:13.376]                       msg <- conditionMessage(ex)
[13:23:13.376]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.376]                         fi_tmp[["mtime"]], msg)
[13:23:13.376]                       ex$message <- msg
[13:23:13.376]                       stop(ex)
[13:23:13.376]                     })
[13:23:13.376]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.376]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.376]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.376]                       fi <- file.info(pathname)
[13:23:13.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.376]                         fi[["size"]], fi[["mtime"]])
[13:23:13.376]                       stop(msg)
[13:23:13.376]                     }
[13:23:13.376]                     invisible(pathname)
[13:23:13.376]                   }
[13:23:13.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.376]                     rootPath = tempdir()) 
[13:23:13.376]                   {
[13:23:13.376]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.376]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.376]                       tmpdir = path, fileext = ".rds")
[13:23:13.376]                     save_rds(obj, file)
[13:23:13.376]                   }
[13:23:13.376]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.376]                   {
[13:23:13.376]                     inherits <- base::inherits
[13:23:13.376]                     invokeRestart <- base::invokeRestart
[13:23:13.376]                     is.null <- base::is.null
[13:23:13.376]                     muffled <- FALSE
[13:23:13.376]                     if (inherits(cond, "message")) {
[13:23:13.376]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.376]                       if (muffled) 
[13:23:13.376]                         invokeRestart("muffleMessage")
[13:23:13.376]                     }
[13:23:13.376]                     else if (inherits(cond, "warning")) {
[13:23:13.376]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.376]                       if (muffled) 
[13:23:13.376]                         invokeRestart("muffleWarning")
[13:23:13.376]                     }
[13:23:13.376]                     else if (inherits(cond, "condition")) {
[13:23:13.376]                       if (!is.null(pattern)) {
[13:23:13.376]                         computeRestarts <- base::computeRestarts
[13:23:13.376]                         grepl <- base::grepl
[13:23:13.376]                         restarts <- computeRestarts(cond)
[13:23:13.376]                         for (restart in restarts) {
[13:23:13.376]                           name <- restart$name
[13:23:13.376]                           if (is.null(name)) 
[13:23:13.376]                             next
[13:23:13.376]                           if (!grepl(pattern, name)) 
[13:23:13.376]                             next
[13:23:13.376]                           invokeRestart(restart)
[13:23:13.376]                           muffled <- TRUE
[13:23:13.376]                           break
[13:23:13.376]                         }
[13:23:13.376]                       }
[13:23:13.376]                     }
[13:23:13.376]                     invisible(muffled)
[13:23:13.376]                   }
[13:23:13.376]                   muffleCondition(cond)
[13:23:13.376]                 })
[13:23:13.376]             }))
[13:23:13.376]             future::FutureResult(value = ...future.value$value, 
[13:23:13.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.376]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.376]                     ...future.globalenv.names))
[13:23:13.376]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.376]         }, condition = base::local({
[13:23:13.376]             c <- base::c
[13:23:13.376]             inherits <- base::inherits
[13:23:13.376]             invokeRestart <- base::invokeRestart
[13:23:13.376]             length <- base::length
[13:23:13.376]             list <- base::list
[13:23:13.376]             seq.int <- base::seq.int
[13:23:13.376]             signalCondition <- base::signalCondition
[13:23:13.376]             sys.calls <- base::sys.calls
[13:23:13.376]             `[[` <- base::`[[`
[13:23:13.376]             `+` <- base::`+`
[13:23:13.376]             `<<-` <- base::`<<-`
[13:23:13.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.376]                   3L)]
[13:23:13.376]             }
[13:23:13.376]             function(cond) {
[13:23:13.376]                 is_error <- inherits(cond, "error")
[13:23:13.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.376]                   NULL)
[13:23:13.376]                 if (is_error) {
[13:23:13.376]                   sessionInformation <- function() {
[13:23:13.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.376]                       search = base::search(), system = base::Sys.info())
[13:23:13.376]                   }
[13:23:13.376]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.376]                     cond$call), session = sessionInformation(), 
[13:23:13.376]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.376]                   signalCondition(cond)
[13:23:13.376]                 }
[13:23:13.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.376]                 "immediateCondition"))) {
[13:23:13.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.376]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.376]                   if (TRUE && !signal) {
[13:23:13.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.376]                     {
[13:23:13.376]                       inherits <- base::inherits
[13:23:13.376]                       invokeRestart <- base::invokeRestart
[13:23:13.376]                       is.null <- base::is.null
[13:23:13.376]                       muffled <- FALSE
[13:23:13.376]                       if (inherits(cond, "message")) {
[13:23:13.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.376]                         if (muffled) 
[13:23:13.376]                           invokeRestart("muffleMessage")
[13:23:13.376]                       }
[13:23:13.376]                       else if (inherits(cond, "warning")) {
[13:23:13.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.376]                         if (muffled) 
[13:23:13.376]                           invokeRestart("muffleWarning")
[13:23:13.376]                       }
[13:23:13.376]                       else if (inherits(cond, "condition")) {
[13:23:13.376]                         if (!is.null(pattern)) {
[13:23:13.376]                           computeRestarts <- base::computeRestarts
[13:23:13.376]                           grepl <- base::grepl
[13:23:13.376]                           restarts <- computeRestarts(cond)
[13:23:13.376]                           for (restart in restarts) {
[13:23:13.376]                             name <- restart$name
[13:23:13.376]                             if (is.null(name)) 
[13:23:13.376]                               next
[13:23:13.376]                             if (!grepl(pattern, name)) 
[13:23:13.376]                               next
[13:23:13.376]                             invokeRestart(restart)
[13:23:13.376]                             muffled <- TRUE
[13:23:13.376]                             break
[13:23:13.376]                           }
[13:23:13.376]                         }
[13:23:13.376]                       }
[13:23:13.376]                       invisible(muffled)
[13:23:13.376]                     }
[13:23:13.376]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.376]                   }
[13:23:13.376]                 }
[13:23:13.376]                 else {
[13:23:13.376]                   if (TRUE) {
[13:23:13.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.376]                     {
[13:23:13.376]                       inherits <- base::inherits
[13:23:13.376]                       invokeRestart <- base::invokeRestart
[13:23:13.376]                       is.null <- base::is.null
[13:23:13.376]                       muffled <- FALSE
[13:23:13.376]                       if (inherits(cond, "message")) {
[13:23:13.376]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.376]                         if (muffled) 
[13:23:13.376]                           invokeRestart("muffleMessage")
[13:23:13.376]                       }
[13:23:13.376]                       else if (inherits(cond, "warning")) {
[13:23:13.376]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.376]                         if (muffled) 
[13:23:13.376]                           invokeRestart("muffleWarning")
[13:23:13.376]                       }
[13:23:13.376]                       else if (inherits(cond, "condition")) {
[13:23:13.376]                         if (!is.null(pattern)) {
[13:23:13.376]                           computeRestarts <- base::computeRestarts
[13:23:13.376]                           grepl <- base::grepl
[13:23:13.376]                           restarts <- computeRestarts(cond)
[13:23:13.376]                           for (restart in restarts) {
[13:23:13.376]                             name <- restart$name
[13:23:13.376]                             if (is.null(name)) 
[13:23:13.376]                               next
[13:23:13.376]                             if (!grepl(pattern, name)) 
[13:23:13.376]                               next
[13:23:13.376]                             invokeRestart(restart)
[13:23:13.376]                             muffled <- TRUE
[13:23:13.376]                             break
[13:23:13.376]                           }
[13:23:13.376]                         }
[13:23:13.376]                       }
[13:23:13.376]                       invisible(muffled)
[13:23:13.376]                     }
[13:23:13.376]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.376]                   }
[13:23:13.376]                 }
[13:23:13.376]             }
[13:23:13.376]         }))
[13:23:13.376]     }, error = function(ex) {
[13:23:13.376]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.376]                 ...future.rng), started = ...future.startTime, 
[13:23:13.376]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.376]             version = "1.8"), class = "FutureResult")
[13:23:13.376]     }, finally = {
[13:23:13.376]         if (!identical(...future.workdir, getwd())) 
[13:23:13.376]             setwd(...future.workdir)
[13:23:13.376]         {
[13:23:13.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.376]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.376]             }
[13:23:13.376]             base::options(...future.oldOptions)
[13:23:13.376]             if (.Platform$OS.type == "windows") {
[13:23:13.376]                 old_names <- names(...future.oldEnvVars)
[13:23:13.376]                 envs <- base::Sys.getenv()
[13:23:13.376]                 names <- names(envs)
[13:23:13.376]                 common <- intersect(names, old_names)
[13:23:13.376]                 added <- setdiff(names, old_names)
[13:23:13.376]                 removed <- setdiff(old_names, names)
[13:23:13.376]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.376]                   envs[common]]
[13:23:13.376]                 NAMES <- toupper(changed)
[13:23:13.376]                 args <- list()
[13:23:13.376]                 for (kk in seq_along(NAMES)) {
[13:23:13.376]                   name <- changed[[kk]]
[13:23:13.376]                   NAME <- NAMES[[kk]]
[13:23:13.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.376]                     next
[13:23:13.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.376]                 }
[13:23:13.376]                 NAMES <- toupper(added)
[13:23:13.376]                 for (kk in seq_along(NAMES)) {
[13:23:13.376]                   name <- added[[kk]]
[13:23:13.376]                   NAME <- NAMES[[kk]]
[13:23:13.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.376]                     next
[13:23:13.376]                   args[[name]] <- ""
[13:23:13.376]                 }
[13:23:13.376]                 NAMES <- toupper(removed)
[13:23:13.376]                 for (kk in seq_along(NAMES)) {
[13:23:13.376]                   name <- removed[[kk]]
[13:23:13.376]                   NAME <- NAMES[[kk]]
[13:23:13.376]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.376]                     next
[13:23:13.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.376]                 }
[13:23:13.376]                 if (length(args) > 0) 
[13:23:13.376]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.376]             }
[13:23:13.376]             else {
[13:23:13.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.376]             }
[13:23:13.376]             {
[13:23:13.376]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.376]                   0L) {
[13:23:13.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.376]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.376]                   base::options(opts)
[13:23:13.376]                 }
[13:23:13.376]                 {
[13:23:13.376]                   {
[13:23:13.376]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.376]                     NULL
[13:23:13.376]                   }
[13:23:13.376]                   options(future.plan = NULL)
[13:23:13.376]                   if (is.na(NA_character_)) 
[13:23:13.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.376]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.376]                     envir = parent.frame()) 
[13:23:13.376]                   {
[13:23:13.376]                     default_workers <- missing(workers)
[13:23:13.376]                     if (is.function(workers)) 
[13:23:13.376]                       workers <- workers()
[13:23:13.376]                     workers <- structure(as.integer(workers), 
[13:23:13.376]                       class = class(workers))
[13:23:13.376]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.376]                       1L)
[13:23:13.376]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.376]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.376]                       if (default_workers) 
[13:23:13.376]                         supportsMulticore(warn = TRUE)
[13:23:13.376]                       return(sequential(..., envir = envir))
[13:23:13.376]                     }
[13:23:13.376]                     oopts <- options(mc.cores = workers)
[13:23:13.376]                     on.exit(options(oopts))
[13:23:13.376]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.376]                       envir = envir)
[13:23:13.376]                     if (!future$lazy) 
[13:23:13.376]                       future <- run(future)
[13:23:13.376]                     invisible(future)
[13:23:13.376]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.376]                 }
[13:23:13.376]             }
[13:23:13.376]         }
[13:23:13.376]     })
[13:23:13.376]     if (TRUE) {
[13:23:13.376]         base::sink(type = "output", split = FALSE)
[13:23:13.376]         if (TRUE) {
[13:23:13.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.376]         }
[13:23:13.376]         else {
[13:23:13.376]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.376]         }
[13:23:13.376]         base::close(...future.stdout)
[13:23:13.376]         ...future.stdout <- NULL
[13:23:13.376]     }
[13:23:13.376]     ...future.result$conditions <- ...future.conditions
[13:23:13.376]     ...future.result$finished <- base::Sys.time()
[13:23:13.376]     ...future.result
[13:23:13.376] }
[13:23:13.378] assign_globals() ...
[13:23:13.378] List of 2
[13:23:13.378]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.378]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.378]  - attr(*, "where")=List of 2
[13:23:13.378]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.378]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.378]  - attr(*, "resolved")= logi FALSE
[13:23:13.378]  - attr(*, "total_size")= num 896
[13:23:13.378]  - attr(*, "already-done")= logi TRUE
[13:23:13.382] - copied ‘weight’ to environment
[13:23:13.383] - copied ‘group’ to environment
[13:23:13.383] assign_globals() ... done
[13:23:13.383] requestCore(): workers = 2
[13:23:13.385] MulticoreFuture started
[13:23:13.386] - Launch lazy future ... done
[13:23:13.386] run() for ‘MulticoreFuture’ ... done
[13:23:13.386] result() for MulticoreFuture ...
[13:23:13.387] plan(): Setting new future strategy stack:
[13:23:13.387] List of future strategies:
[13:23:13.387] 1. sequential:
[13:23:13.387]    - args: function (..., envir = parent.frame())
[13:23:13.387]    - tweaked: FALSE
[13:23:13.387]    - call: NULL
[13:23:13.388] plan(): nbrOfWorkers() = 1
[13:23:13.392] plan(): Setting new future strategy stack:
[13:23:13.392] List of future strategies:
[13:23:13.392] 1. multicore:
[13:23:13.392]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.392]    - tweaked: FALSE
[13:23:13.392]    - call: plan(strategy)
[13:23:13.398] plan(): nbrOfWorkers() = 2
[13:23:13.401] result() for MulticoreFuture ...
[13:23:13.401] result() for MulticoreFuture ... done
[13:23:13.401] result() for MulticoreFuture ... done
[13:23:13.401] result() for MulticoreFuture ...
[13:23:13.401] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.404] getGlobalsAndPackages() ...
[13:23:13.404] Searching for globals...
[13:23:13.409] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.410] Searching for globals ... DONE
[13:23:13.410] Resolving globals: FALSE
[13:23:13.411] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.411] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.411] - globals: [2] ‘weight’, ‘group’
[13:23:13.411] - packages: [1] ‘stats’
[13:23:13.412] getGlobalsAndPackages() ... DONE
[13:23:13.412] run() for ‘Future’ ...
[13:23:13.412] - state: ‘created’
[13:23:13.412] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.417]   - Field: ‘label’
[13:23:13.418]   - Field: ‘local’
[13:23:13.418]   - Field: ‘owner’
[13:23:13.418]   - Field: ‘envir’
[13:23:13.418]   - Field: ‘workers’
[13:23:13.418]   - Field: ‘packages’
[13:23:13.418]   - Field: ‘gc’
[13:23:13.418]   - Field: ‘job’
[13:23:13.418]   - Field: ‘conditions’
[13:23:13.419]   - Field: ‘expr’
[13:23:13.419]   - Field: ‘uuid’
[13:23:13.419]   - Field: ‘seed’
[13:23:13.419]   - Field: ‘version’
[13:23:13.419]   - Field: ‘result’
[13:23:13.419]   - Field: ‘asynchronous’
[13:23:13.419]   - Field: ‘calls’
[13:23:13.419]   - Field: ‘globals’
[13:23:13.419]   - Field: ‘stdout’
[13:23:13.420]   - Field: ‘earlySignal’
[13:23:13.420]   - Field: ‘lazy’
[13:23:13.420]   - Field: ‘state’
[13:23:13.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.420] - Launch lazy future ...
[13:23:13.421] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.421] Packages needed by future strategies (n = 0): <none>
[13:23:13.421] {
[13:23:13.421]     {
[13:23:13.421]         {
[13:23:13.421]             ...future.startTime <- base::Sys.time()
[13:23:13.421]             {
[13:23:13.421]                 {
[13:23:13.421]                   {
[13:23:13.421]                     {
[13:23:13.421]                       {
[13:23:13.421]                         base::local({
[13:23:13.421]                           has_future <- base::requireNamespace("future", 
[13:23:13.421]                             quietly = TRUE)
[13:23:13.421]                           if (has_future) {
[13:23:13.421]                             ns <- base::getNamespace("future")
[13:23:13.421]                             version <- ns[[".package"]][["version"]]
[13:23:13.421]                             if (is.null(version)) 
[13:23:13.421]                               version <- utils::packageVersion("future")
[13:23:13.421]                           }
[13:23:13.421]                           else {
[13:23:13.421]                             version <- NULL
[13:23:13.421]                           }
[13:23:13.421]                           if (!has_future || version < "1.8.0") {
[13:23:13.421]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.421]                               "", base::R.version$version.string), 
[13:23:13.421]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.421]                                 base::R.version$platform, 8 * 
[13:23:13.421]                                   base::.Machine$sizeof.pointer), 
[13:23:13.421]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.421]                                 "release", "version")], collapse = " "), 
[13:23:13.421]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.421]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.421]                               info)
[13:23:13.421]                             info <- base::paste(info, collapse = "; ")
[13:23:13.421]                             if (!has_future) {
[13:23:13.421]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.421]                                 info)
[13:23:13.421]                             }
[13:23:13.421]                             else {
[13:23:13.421]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.421]                                 info, version)
[13:23:13.421]                             }
[13:23:13.421]                             base::stop(msg)
[13:23:13.421]                           }
[13:23:13.421]                         })
[13:23:13.421]                       }
[13:23:13.421]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.421]                       base::options(mc.cores = 1L)
[13:23:13.421]                     }
[13:23:13.421]                     base::local({
[13:23:13.421]                       for (pkg in "stats") {
[13:23:13.421]                         base::loadNamespace(pkg)
[13:23:13.421]                         base::library(pkg, character.only = TRUE)
[13:23:13.421]                       }
[13:23:13.421]                     })
[13:23:13.421]                   }
[13:23:13.421]                   options(future.plan = NULL)
[13:23:13.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.421]                 }
[13:23:13.421]                 ...future.workdir <- getwd()
[13:23:13.421]             }
[13:23:13.421]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.421]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.421]         }
[13:23:13.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.421]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.421]             base::names(...future.oldOptions))
[13:23:13.421]     }
[13:23:13.421]     if (FALSE) {
[13:23:13.421]     }
[13:23:13.421]     else {
[13:23:13.421]         if (TRUE) {
[13:23:13.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.421]                 open = "w")
[13:23:13.421]         }
[13:23:13.421]         else {
[13:23:13.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.421]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.421]         }
[13:23:13.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.421]             base::sink(type = "output", split = FALSE)
[13:23:13.421]             base::close(...future.stdout)
[13:23:13.421]         }, add = TRUE)
[13:23:13.421]     }
[13:23:13.421]     ...future.frame <- base::sys.nframe()
[13:23:13.421]     ...future.conditions <- base::list()
[13:23:13.421]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.421]     if (FALSE) {
[13:23:13.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.421]     }
[13:23:13.421]     ...future.result <- base::tryCatch({
[13:23:13.421]         base::withCallingHandlers({
[13:23:13.421]             ...future.value <- base::withVisible(base::local({
[13:23:13.421]                 withCallingHandlers({
[13:23:13.421]                   {
[13:23:13.421]                     lm(weight ~ group - 1)
[13:23:13.421]                   }
[13:23:13.421]                 }, immediateCondition = function(cond) {
[13:23:13.421]                   save_rds <- function (object, pathname, ...) 
[13:23:13.421]                   {
[13:23:13.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.421]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.421]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.421]                         fi_tmp[["mtime"]])
[13:23:13.421]                     }
[13:23:13.421]                     tryCatch({
[13:23:13.421]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.421]                     }, error = function(ex) {
[13:23:13.421]                       msg <- conditionMessage(ex)
[13:23:13.421]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.421]                         fi_tmp[["mtime"]], msg)
[13:23:13.421]                       ex$message <- msg
[13:23:13.421]                       stop(ex)
[13:23:13.421]                     })
[13:23:13.421]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.421]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.421]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.421]                       fi <- file.info(pathname)
[13:23:13.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.421]                         fi[["size"]], fi[["mtime"]])
[13:23:13.421]                       stop(msg)
[13:23:13.421]                     }
[13:23:13.421]                     invisible(pathname)
[13:23:13.421]                   }
[13:23:13.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.421]                     rootPath = tempdir()) 
[13:23:13.421]                   {
[13:23:13.421]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.421]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.421]                       tmpdir = path, fileext = ".rds")
[13:23:13.421]                     save_rds(obj, file)
[13:23:13.421]                   }
[13:23:13.421]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.421]                   {
[13:23:13.421]                     inherits <- base::inherits
[13:23:13.421]                     invokeRestart <- base::invokeRestart
[13:23:13.421]                     is.null <- base::is.null
[13:23:13.421]                     muffled <- FALSE
[13:23:13.421]                     if (inherits(cond, "message")) {
[13:23:13.421]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.421]                       if (muffled) 
[13:23:13.421]                         invokeRestart("muffleMessage")
[13:23:13.421]                     }
[13:23:13.421]                     else if (inherits(cond, "warning")) {
[13:23:13.421]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.421]                       if (muffled) 
[13:23:13.421]                         invokeRestart("muffleWarning")
[13:23:13.421]                     }
[13:23:13.421]                     else if (inherits(cond, "condition")) {
[13:23:13.421]                       if (!is.null(pattern)) {
[13:23:13.421]                         computeRestarts <- base::computeRestarts
[13:23:13.421]                         grepl <- base::grepl
[13:23:13.421]                         restarts <- computeRestarts(cond)
[13:23:13.421]                         for (restart in restarts) {
[13:23:13.421]                           name <- restart$name
[13:23:13.421]                           if (is.null(name)) 
[13:23:13.421]                             next
[13:23:13.421]                           if (!grepl(pattern, name)) 
[13:23:13.421]                             next
[13:23:13.421]                           invokeRestart(restart)
[13:23:13.421]                           muffled <- TRUE
[13:23:13.421]                           break
[13:23:13.421]                         }
[13:23:13.421]                       }
[13:23:13.421]                     }
[13:23:13.421]                     invisible(muffled)
[13:23:13.421]                   }
[13:23:13.421]                   muffleCondition(cond)
[13:23:13.421]                 })
[13:23:13.421]             }))
[13:23:13.421]             future::FutureResult(value = ...future.value$value, 
[13:23:13.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.421]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.421]                     ...future.globalenv.names))
[13:23:13.421]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.421]         }, condition = base::local({
[13:23:13.421]             c <- base::c
[13:23:13.421]             inherits <- base::inherits
[13:23:13.421]             invokeRestart <- base::invokeRestart
[13:23:13.421]             length <- base::length
[13:23:13.421]             list <- base::list
[13:23:13.421]             seq.int <- base::seq.int
[13:23:13.421]             signalCondition <- base::signalCondition
[13:23:13.421]             sys.calls <- base::sys.calls
[13:23:13.421]             `[[` <- base::`[[`
[13:23:13.421]             `+` <- base::`+`
[13:23:13.421]             `<<-` <- base::`<<-`
[13:23:13.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.421]                   3L)]
[13:23:13.421]             }
[13:23:13.421]             function(cond) {
[13:23:13.421]                 is_error <- inherits(cond, "error")
[13:23:13.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.421]                   NULL)
[13:23:13.421]                 if (is_error) {
[13:23:13.421]                   sessionInformation <- function() {
[13:23:13.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.421]                       search = base::search(), system = base::Sys.info())
[13:23:13.421]                   }
[13:23:13.421]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.421]                     cond$call), session = sessionInformation(), 
[13:23:13.421]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.421]                   signalCondition(cond)
[13:23:13.421]                 }
[13:23:13.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.421]                 "immediateCondition"))) {
[13:23:13.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.421]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.421]                   if (TRUE && !signal) {
[13:23:13.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.421]                     {
[13:23:13.421]                       inherits <- base::inherits
[13:23:13.421]                       invokeRestart <- base::invokeRestart
[13:23:13.421]                       is.null <- base::is.null
[13:23:13.421]                       muffled <- FALSE
[13:23:13.421]                       if (inherits(cond, "message")) {
[13:23:13.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.421]                         if (muffled) 
[13:23:13.421]                           invokeRestart("muffleMessage")
[13:23:13.421]                       }
[13:23:13.421]                       else if (inherits(cond, "warning")) {
[13:23:13.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.421]                         if (muffled) 
[13:23:13.421]                           invokeRestart("muffleWarning")
[13:23:13.421]                       }
[13:23:13.421]                       else if (inherits(cond, "condition")) {
[13:23:13.421]                         if (!is.null(pattern)) {
[13:23:13.421]                           computeRestarts <- base::computeRestarts
[13:23:13.421]                           grepl <- base::grepl
[13:23:13.421]                           restarts <- computeRestarts(cond)
[13:23:13.421]                           for (restart in restarts) {
[13:23:13.421]                             name <- restart$name
[13:23:13.421]                             if (is.null(name)) 
[13:23:13.421]                               next
[13:23:13.421]                             if (!grepl(pattern, name)) 
[13:23:13.421]                               next
[13:23:13.421]                             invokeRestart(restart)
[13:23:13.421]                             muffled <- TRUE
[13:23:13.421]                             break
[13:23:13.421]                           }
[13:23:13.421]                         }
[13:23:13.421]                       }
[13:23:13.421]                       invisible(muffled)
[13:23:13.421]                     }
[13:23:13.421]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.421]                   }
[13:23:13.421]                 }
[13:23:13.421]                 else {
[13:23:13.421]                   if (TRUE) {
[13:23:13.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.421]                     {
[13:23:13.421]                       inherits <- base::inherits
[13:23:13.421]                       invokeRestart <- base::invokeRestart
[13:23:13.421]                       is.null <- base::is.null
[13:23:13.421]                       muffled <- FALSE
[13:23:13.421]                       if (inherits(cond, "message")) {
[13:23:13.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.421]                         if (muffled) 
[13:23:13.421]                           invokeRestart("muffleMessage")
[13:23:13.421]                       }
[13:23:13.421]                       else if (inherits(cond, "warning")) {
[13:23:13.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.421]                         if (muffled) 
[13:23:13.421]                           invokeRestart("muffleWarning")
[13:23:13.421]                       }
[13:23:13.421]                       else if (inherits(cond, "condition")) {
[13:23:13.421]                         if (!is.null(pattern)) {
[13:23:13.421]                           computeRestarts <- base::computeRestarts
[13:23:13.421]                           grepl <- base::grepl
[13:23:13.421]                           restarts <- computeRestarts(cond)
[13:23:13.421]                           for (restart in restarts) {
[13:23:13.421]                             name <- restart$name
[13:23:13.421]                             if (is.null(name)) 
[13:23:13.421]                               next
[13:23:13.421]                             if (!grepl(pattern, name)) 
[13:23:13.421]                               next
[13:23:13.421]                             invokeRestart(restart)
[13:23:13.421]                             muffled <- TRUE
[13:23:13.421]                             break
[13:23:13.421]                           }
[13:23:13.421]                         }
[13:23:13.421]                       }
[13:23:13.421]                       invisible(muffled)
[13:23:13.421]                     }
[13:23:13.421]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.421]                   }
[13:23:13.421]                 }
[13:23:13.421]             }
[13:23:13.421]         }))
[13:23:13.421]     }, error = function(ex) {
[13:23:13.421]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.421]                 ...future.rng), started = ...future.startTime, 
[13:23:13.421]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.421]             version = "1.8"), class = "FutureResult")
[13:23:13.421]     }, finally = {
[13:23:13.421]         if (!identical(...future.workdir, getwd())) 
[13:23:13.421]             setwd(...future.workdir)
[13:23:13.421]         {
[13:23:13.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.421]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.421]             }
[13:23:13.421]             base::options(...future.oldOptions)
[13:23:13.421]             if (.Platform$OS.type == "windows") {
[13:23:13.421]                 old_names <- names(...future.oldEnvVars)
[13:23:13.421]                 envs <- base::Sys.getenv()
[13:23:13.421]                 names <- names(envs)
[13:23:13.421]                 common <- intersect(names, old_names)
[13:23:13.421]                 added <- setdiff(names, old_names)
[13:23:13.421]                 removed <- setdiff(old_names, names)
[13:23:13.421]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.421]                   envs[common]]
[13:23:13.421]                 NAMES <- toupper(changed)
[13:23:13.421]                 args <- list()
[13:23:13.421]                 for (kk in seq_along(NAMES)) {
[13:23:13.421]                   name <- changed[[kk]]
[13:23:13.421]                   NAME <- NAMES[[kk]]
[13:23:13.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.421]                     next
[13:23:13.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.421]                 }
[13:23:13.421]                 NAMES <- toupper(added)
[13:23:13.421]                 for (kk in seq_along(NAMES)) {
[13:23:13.421]                   name <- added[[kk]]
[13:23:13.421]                   NAME <- NAMES[[kk]]
[13:23:13.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.421]                     next
[13:23:13.421]                   args[[name]] <- ""
[13:23:13.421]                 }
[13:23:13.421]                 NAMES <- toupper(removed)
[13:23:13.421]                 for (kk in seq_along(NAMES)) {
[13:23:13.421]                   name <- removed[[kk]]
[13:23:13.421]                   NAME <- NAMES[[kk]]
[13:23:13.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.421]                     next
[13:23:13.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.421]                 }
[13:23:13.421]                 if (length(args) > 0) 
[13:23:13.421]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.421]             }
[13:23:13.421]             else {
[13:23:13.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.421]             }
[13:23:13.421]             {
[13:23:13.421]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.421]                   0L) {
[13:23:13.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.421]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.421]                   base::options(opts)
[13:23:13.421]                 }
[13:23:13.421]                 {
[13:23:13.421]                   {
[13:23:13.421]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.421]                     NULL
[13:23:13.421]                   }
[13:23:13.421]                   options(future.plan = NULL)
[13:23:13.421]                   if (is.na(NA_character_)) 
[13:23:13.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.421]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.421]                     envir = parent.frame()) 
[13:23:13.421]                   {
[13:23:13.421]                     default_workers <- missing(workers)
[13:23:13.421]                     if (is.function(workers)) 
[13:23:13.421]                       workers <- workers()
[13:23:13.421]                     workers <- structure(as.integer(workers), 
[13:23:13.421]                       class = class(workers))
[13:23:13.421]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.421]                       1L)
[13:23:13.421]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.421]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.421]                       if (default_workers) 
[13:23:13.421]                         supportsMulticore(warn = TRUE)
[13:23:13.421]                       return(sequential(..., envir = envir))
[13:23:13.421]                     }
[13:23:13.421]                     oopts <- options(mc.cores = workers)
[13:23:13.421]                     on.exit(options(oopts))
[13:23:13.421]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.421]                       envir = envir)
[13:23:13.421]                     if (!future$lazy) 
[13:23:13.421]                       future <- run(future)
[13:23:13.421]                     invisible(future)
[13:23:13.421]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.421]                 }
[13:23:13.421]             }
[13:23:13.421]         }
[13:23:13.421]     })
[13:23:13.421]     if (TRUE) {
[13:23:13.421]         base::sink(type = "output", split = FALSE)
[13:23:13.421]         if (TRUE) {
[13:23:13.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.421]         }
[13:23:13.421]         else {
[13:23:13.421]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.421]         }
[13:23:13.421]         base::close(...future.stdout)
[13:23:13.421]         ...future.stdout <- NULL
[13:23:13.421]     }
[13:23:13.421]     ...future.result$conditions <- ...future.conditions
[13:23:13.421]     ...future.result$finished <- base::Sys.time()
[13:23:13.421]     ...future.result
[13:23:13.421] }
[13:23:13.424] assign_globals() ...
[13:23:13.424] List of 2
[13:23:13.424]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.424]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.424]  - attr(*, "where")=List of 2
[13:23:13.424]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.424]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.424]  - attr(*, "resolved")= logi FALSE
[13:23:13.424]  - attr(*, "total_size")= num 896
[13:23:13.424]  - attr(*, "already-done")= logi TRUE
[13:23:13.428] - copied ‘weight’ to environment
[13:23:13.428] - copied ‘group’ to environment
[13:23:13.429] assign_globals() ... done
[13:23:13.429] requestCore(): workers = 2
[13:23:13.431] MulticoreFuture started
[13:23:13.432] - Launch lazy future ... done
[13:23:13.432] run() for ‘MulticoreFuture’ ... done
[13:23:13.432] result() for MulticoreFuture ...
[13:23:13.433] plan(): Setting new future strategy stack:
[13:23:13.433] List of future strategies:
[13:23:13.433] 1. sequential:
[13:23:13.433]    - args: function (..., envir = parent.frame())
[13:23:13.433]    - tweaked: FALSE
[13:23:13.433]    - call: NULL
[13:23:13.434] plan(): nbrOfWorkers() = 1
[13:23:13.438] plan(): Setting new future strategy stack:
[13:23:13.438] List of future strategies:
[13:23:13.438] 1. multicore:
[13:23:13.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.438]    - tweaked: FALSE
[13:23:13.438]    - call: plan(strategy)
[13:23:13.444] plan(): nbrOfWorkers() = 2
[13:23:13.446] result() for MulticoreFuture ...
[13:23:13.446] result() for MulticoreFuture ... done
[13:23:13.447] result() for MulticoreFuture ... done
[13:23:13.447] result() for MulticoreFuture ...
[13:23:13.447] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.450] getGlobalsAndPackages() ...
[13:23:13.450] Searching for globals...
[13:23:13.452] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.452] Searching for globals ... DONE
[13:23:13.452] Resolving globals: FALSE
[13:23:13.453] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.454] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.454] - globals: [2] ‘weight’, ‘group’
[13:23:13.454] - packages: [1] ‘stats’
[13:23:13.454] getGlobalsAndPackages() ... DONE
[13:23:13.455] run() for ‘Future’ ...
[13:23:13.455] - state: ‘created’
[13:23:13.455] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.462] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.463] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.463]   - Field: ‘label’
[13:23:13.463]   - Field: ‘local’
[13:23:13.463]   - Field: ‘owner’
[13:23:13.463]   - Field: ‘envir’
[13:23:13.464]   - Field: ‘workers’
[13:23:13.464]   - Field: ‘packages’
[13:23:13.464]   - Field: ‘gc’
[13:23:13.464]   - Field: ‘job’
[13:23:13.464]   - Field: ‘conditions’
[13:23:13.464]   - Field: ‘expr’
[13:23:13.464]   - Field: ‘uuid’
[13:23:13.465]   - Field: ‘seed’
[13:23:13.465]   - Field: ‘version’
[13:23:13.465]   - Field: ‘result’
[13:23:13.465]   - Field: ‘asynchronous’
[13:23:13.465]   - Field: ‘calls’
[13:23:13.465]   - Field: ‘globals’
[13:23:13.465]   - Field: ‘stdout’
[13:23:13.465]   - Field: ‘earlySignal’
[13:23:13.466]   - Field: ‘lazy’
[13:23:13.466]   - Field: ‘state’
[13:23:13.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.466] - Launch lazy future ...
[13:23:13.466] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.466] Packages needed by future strategies (n = 0): <none>
[13:23:13.467] {
[13:23:13.467]     {
[13:23:13.467]         {
[13:23:13.467]             ...future.startTime <- base::Sys.time()
[13:23:13.467]             {
[13:23:13.467]                 {
[13:23:13.467]                   {
[13:23:13.467]                     {
[13:23:13.467]                       {
[13:23:13.467]                         base::local({
[13:23:13.467]                           has_future <- base::requireNamespace("future", 
[13:23:13.467]                             quietly = TRUE)
[13:23:13.467]                           if (has_future) {
[13:23:13.467]                             ns <- base::getNamespace("future")
[13:23:13.467]                             version <- ns[[".package"]][["version"]]
[13:23:13.467]                             if (is.null(version)) 
[13:23:13.467]                               version <- utils::packageVersion("future")
[13:23:13.467]                           }
[13:23:13.467]                           else {
[13:23:13.467]                             version <- NULL
[13:23:13.467]                           }
[13:23:13.467]                           if (!has_future || version < "1.8.0") {
[13:23:13.467]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.467]                               "", base::R.version$version.string), 
[13:23:13.467]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.467]                                 base::R.version$platform, 8 * 
[13:23:13.467]                                   base::.Machine$sizeof.pointer), 
[13:23:13.467]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.467]                                 "release", "version")], collapse = " "), 
[13:23:13.467]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.467]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.467]                               info)
[13:23:13.467]                             info <- base::paste(info, collapse = "; ")
[13:23:13.467]                             if (!has_future) {
[13:23:13.467]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.467]                                 info)
[13:23:13.467]                             }
[13:23:13.467]                             else {
[13:23:13.467]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.467]                                 info, version)
[13:23:13.467]                             }
[13:23:13.467]                             base::stop(msg)
[13:23:13.467]                           }
[13:23:13.467]                         })
[13:23:13.467]                       }
[13:23:13.467]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.467]                       base::options(mc.cores = 1L)
[13:23:13.467]                     }
[13:23:13.467]                     base::local({
[13:23:13.467]                       for (pkg in "stats") {
[13:23:13.467]                         base::loadNamespace(pkg)
[13:23:13.467]                         base::library(pkg, character.only = TRUE)
[13:23:13.467]                       }
[13:23:13.467]                     })
[13:23:13.467]                   }
[13:23:13.467]                   options(future.plan = NULL)
[13:23:13.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.467]                 }
[13:23:13.467]                 ...future.workdir <- getwd()
[13:23:13.467]             }
[13:23:13.467]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.467]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.467]         }
[13:23:13.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.467]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.467]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.467]             base::names(...future.oldOptions))
[13:23:13.467]     }
[13:23:13.467]     if (FALSE) {
[13:23:13.467]     }
[13:23:13.467]     else {
[13:23:13.467]         if (TRUE) {
[13:23:13.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.467]                 open = "w")
[13:23:13.467]         }
[13:23:13.467]         else {
[13:23:13.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.467]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.467]         }
[13:23:13.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.467]             base::sink(type = "output", split = FALSE)
[13:23:13.467]             base::close(...future.stdout)
[13:23:13.467]         }, add = TRUE)
[13:23:13.467]     }
[13:23:13.467]     ...future.frame <- base::sys.nframe()
[13:23:13.467]     ...future.conditions <- base::list()
[13:23:13.467]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.467]     if (FALSE) {
[13:23:13.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.467]     }
[13:23:13.467]     ...future.result <- base::tryCatch({
[13:23:13.467]         base::withCallingHandlers({
[13:23:13.467]             ...future.value <- base::withVisible(base::local({
[13:23:13.467]                 withCallingHandlers({
[13:23:13.467]                   {
[13:23:13.467]                     lm(weight ~ group - 1)
[13:23:13.467]                   }
[13:23:13.467]                 }, immediateCondition = function(cond) {
[13:23:13.467]                   save_rds <- function (object, pathname, ...) 
[13:23:13.467]                   {
[13:23:13.467]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.467]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.467]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.467]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.467]                         fi_tmp[["mtime"]])
[13:23:13.467]                     }
[13:23:13.467]                     tryCatch({
[13:23:13.467]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.467]                     }, error = function(ex) {
[13:23:13.467]                       msg <- conditionMessage(ex)
[13:23:13.467]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.467]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.467]                         fi_tmp[["mtime"]], msg)
[13:23:13.467]                       ex$message <- msg
[13:23:13.467]                       stop(ex)
[13:23:13.467]                     })
[13:23:13.467]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.467]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.467]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.467]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.467]                       fi <- file.info(pathname)
[13:23:13.467]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.467]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.467]                         fi[["size"]], fi[["mtime"]])
[13:23:13.467]                       stop(msg)
[13:23:13.467]                     }
[13:23:13.467]                     invisible(pathname)
[13:23:13.467]                   }
[13:23:13.467]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.467]                     rootPath = tempdir()) 
[13:23:13.467]                   {
[13:23:13.467]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.467]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.467]                       tmpdir = path, fileext = ".rds")
[13:23:13.467]                     save_rds(obj, file)
[13:23:13.467]                   }
[13:23:13.467]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.467]                   {
[13:23:13.467]                     inherits <- base::inherits
[13:23:13.467]                     invokeRestart <- base::invokeRestart
[13:23:13.467]                     is.null <- base::is.null
[13:23:13.467]                     muffled <- FALSE
[13:23:13.467]                     if (inherits(cond, "message")) {
[13:23:13.467]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.467]                       if (muffled) 
[13:23:13.467]                         invokeRestart("muffleMessage")
[13:23:13.467]                     }
[13:23:13.467]                     else if (inherits(cond, "warning")) {
[13:23:13.467]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.467]                       if (muffled) 
[13:23:13.467]                         invokeRestart("muffleWarning")
[13:23:13.467]                     }
[13:23:13.467]                     else if (inherits(cond, "condition")) {
[13:23:13.467]                       if (!is.null(pattern)) {
[13:23:13.467]                         computeRestarts <- base::computeRestarts
[13:23:13.467]                         grepl <- base::grepl
[13:23:13.467]                         restarts <- computeRestarts(cond)
[13:23:13.467]                         for (restart in restarts) {
[13:23:13.467]                           name <- restart$name
[13:23:13.467]                           if (is.null(name)) 
[13:23:13.467]                             next
[13:23:13.467]                           if (!grepl(pattern, name)) 
[13:23:13.467]                             next
[13:23:13.467]                           invokeRestart(restart)
[13:23:13.467]                           muffled <- TRUE
[13:23:13.467]                           break
[13:23:13.467]                         }
[13:23:13.467]                       }
[13:23:13.467]                     }
[13:23:13.467]                     invisible(muffled)
[13:23:13.467]                   }
[13:23:13.467]                   muffleCondition(cond)
[13:23:13.467]                 })
[13:23:13.467]             }))
[13:23:13.467]             future::FutureResult(value = ...future.value$value, 
[13:23:13.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.467]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.467]                     ...future.globalenv.names))
[13:23:13.467]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.467]         }, condition = base::local({
[13:23:13.467]             c <- base::c
[13:23:13.467]             inherits <- base::inherits
[13:23:13.467]             invokeRestart <- base::invokeRestart
[13:23:13.467]             length <- base::length
[13:23:13.467]             list <- base::list
[13:23:13.467]             seq.int <- base::seq.int
[13:23:13.467]             signalCondition <- base::signalCondition
[13:23:13.467]             sys.calls <- base::sys.calls
[13:23:13.467]             `[[` <- base::`[[`
[13:23:13.467]             `+` <- base::`+`
[13:23:13.467]             `<<-` <- base::`<<-`
[13:23:13.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.467]                   3L)]
[13:23:13.467]             }
[13:23:13.467]             function(cond) {
[13:23:13.467]                 is_error <- inherits(cond, "error")
[13:23:13.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.467]                   NULL)
[13:23:13.467]                 if (is_error) {
[13:23:13.467]                   sessionInformation <- function() {
[13:23:13.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.467]                       search = base::search(), system = base::Sys.info())
[13:23:13.467]                   }
[13:23:13.467]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.467]                     cond$call), session = sessionInformation(), 
[13:23:13.467]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.467]                   signalCondition(cond)
[13:23:13.467]                 }
[13:23:13.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.467]                 "immediateCondition"))) {
[13:23:13.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.467]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.467]                   if (TRUE && !signal) {
[13:23:13.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.467]                     {
[13:23:13.467]                       inherits <- base::inherits
[13:23:13.467]                       invokeRestart <- base::invokeRestart
[13:23:13.467]                       is.null <- base::is.null
[13:23:13.467]                       muffled <- FALSE
[13:23:13.467]                       if (inherits(cond, "message")) {
[13:23:13.467]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.467]                         if (muffled) 
[13:23:13.467]                           invokeRestart("muffleMessage")
[13:23:13.467]                       }
[13:23:13.467]                       else if (inherits(cond, "warning")) {
[13:23:13.467]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.467]                         if (muffled) 
[13:23:13.467]                           invokeRestart("muffleWarning")
[13:23:13.467]                       }
[13:23:13.467]                       else if (inherits(cond, "condition")) {
[13:23:13.467]                         if (!is.null(pattern)) {
[13:23:13.467]                           computeRestarts <- base::computeRestarts
[13:23:13.467]                           grepl <- base::grepl
[13:23:13.467]                           restarts <- computeRestarts(cond)
[13:23:13.467]                           for (restart in restarts) {
[13:23:13.467]                             name <- restart$name
[13:23:13.467]                             if (is.null(name)) 
[13:23:13.467]                               next
[13:23:13.467]                             if (!grepl(pattern, name)) 
[13:23:13.467]                               next
[13:23:13.467]                             invokeRestart(restart)
[13:23:13.467]                             muffled <- TRUE
[13:23:13.467]                             break
[13:23:13.467]                           }
[13:23:13.467]                         }
[13:23:13.467]                       }
[13:23:13.467]                       invisible(muffled)
[13:23:13.467]                     }
[13:23:13.467]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.467]                   }
[13:23:13.467]                 }
[13:23:13.467]                 else {
[13:23:13.467]                   if (TRUE) {
[13:23:13.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.467]                     {
[13:23:13.467]                       inherits <- base::inherits
[13:23:13.467]                       invokeRestart <- base::invokeRestart
[13:23:13.467]                       is.null <- base::is.null
[13:23:13.467]                       muffled <- FALSE
[13:23:13.467]                       if (inherits(cond, "message")) {
[13:23:13.467]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.467]                         if (muffled) 
[13:23:13.467]                           invokeRestart("muffleMessage")
[13:23:13.467]                       }
[13:23:13.467]                       else if (inherits(cond, "warning")) {
[13:23:13.467]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.467]                         if (muffled) 
[13:23:13.467]                           invokeRestart("muffleWarning")
[13:23:13.467]                       }
[13:23:13.467]                       else if (inherits(cond, "condition")) {
[13:23:13.467]                         if (!is.null(pattern)) {
[13:23:13.467]                           computeRestarts <- base::computeRestarts
[13:23:13.467]                           grepl <- base::grepl
[13:23:13.467]                           restarts <- computeRestarts(cond)
[13:23:13.467]                           for (restart in restarts) {
[13:23:13.467]                             name <- restart$name
[13:23:13.467]                             if (is.null(name)) 
[13:23:13.467]                               next
[13:23:13.467]                             if (!grepl(pattern, name)) 
[13:23:13.467]                               next
[13:23:13.467]                             invokeRestart(restart)
[13:23:13.467]                             muffled <- TRUE
[13:23:13.467]                             break
[13:23:13.467]                           }
[13:23:13.467]                         }
[13:23:13.467]                       }
[13:23:13.467]                       invisible(muffled)
[13:23:13.467]                     }
[13:23:13.467]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.467]                   }
[13:23:13.467]                 }
[13:23:13.467]             }
[13:23:13.467]         }))
[13:23:13.467]     }, error = function(ex) {
[13:23:13.467]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.467]                 ...future.rng), started = ...future.startTime, 
[13:23:13.467]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.467]             version = "1.8"), class = "FutureResult")
[13:23:13.467]     }, finally = {
[13:23:13.467]         if (!identical(...future.workdir, getwd())) 
[13:23:13.467]             setwd(...future.workdir)
[13:23:13.467]         {
[13:23:13.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.467]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.467]             }
[13:23:13.467]             base::options(...future.oldOptions)
[13:23:13.467]             if (.Platform$OS.type == "windows") {
[13:23:13.467]                 old_names <- names(...future.oldEnvVars)
[13:23:13.467]                 envs <- base::Sys.getenv()
[13:23:13.467]                 names <- names(envs)
[13:23:13.467]                 common <- intersect(names, old_names)
[13:23:13.467]                 added <- setdiff(names, old_names)
[13:23:13.467]                 removed <- setdiff(old_names, names)
[13:23:13.467]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.467]                   envs[common]]
[13:23:13.467]                 NAMES <- toupper(changed)
[13:23:13.467]                 args <- list()
[13:23:13.467]                 for (kk in seq_along(NAMES)) {
[13:23:13.467]                   name <- changed[[kk]]
[13:23:13.467]                   NAME <- NAMES[[kk]]
[13:23:13.467]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.467]                     next
[13:23:13.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.467]                 }
[13:23:13.467]                 NAMES <- toupper(added)
[13:23:13.467]                 for (kk in seq_along(NAMES)) {
[13:23:13.467]                   name <- added[[kk]]
[13:23:13.467]                   NAME <- NAMES[[kk]]
[13:23:13.467]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.467]                     next
[13:23:13.467]                   args[[name]] <- ""
[13:23:13.467]                 }
[13:23:13.467]                 NAMES <- toupper(removed)
[13:23:13.467]                 for (kk in seq_along(NAMES)) {
[13:23:13.467]                   name <- removed[[kk]]
[13:23:13.467]                   NAME <- NAMES[[kk]]
[13:23:13.467]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.467]                     next
[13:23:13.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.467]                 }
[13:23:13.467]                 if (length(args) > 0) 
[13:23:13.467]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.467]             }
[13:23:13.467]             else {
[13:23:13.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.467]             }
[13:23:13.467]             {
[13:23:13.467]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.467]                   0L) {
[13:23:13.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.467]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.467]                   base::options(opts)
[13:23:13.467]                 }
[13:23:13.467]                 {
[13:23:13.467]                   {
[13:23:13.467]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.467]                     NULL
[13:23:13.467]                   }
[13:23:13.467]                   options(future.plan = NULL)
[13:23:13.467]                   if (is.na(NA_character_)) 
[13:23:13.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.467]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.467]                     envir = parent.frame()) 
[13:23:13.467]                   {
[13:23:13.467]                     default_workers <- missing(workers)
[13:23:13.467]                     if (is.function(workers)) 
[13:23:13.467]                       workers <- workers()
[13:23:13.467]                     workers <- structure(as.integer(workers), 
[13:23:13.467]                       class = class(workers))
[13:23:13.467]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.467]                       1L)
[13:23:13.467]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.467]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.467]                       if (default_workers) 
[13:23:13.467]                         supportsMulticore(warn = TRUE)
[13:23:13.467]                       return(sequential(..., envir = envir))
[13:23:13.467]                     }
[13:23:13.467]                     oopts <- options(mc.cores = workers)
[13:23:13.467]                     on.exit(options(oopts))
[13:23:13.467]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.467]                       envir = envir)
[13:23:13.467]                     if (!future$lazy) 
[13:23:13.467]                       future <- run(future)
[13:23:13.467]                     invisible(future)
[13:23:13.467]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.467]                 }
[13:23:13.467]             }
[13:23:13.467]         }
[13:23:13.467]     })
[13:23:13.467]     if (TRUE) {
[13:23:13.467]         base::sink(type = "output", split = FALSE)
[13:23:13.467]         if (TRUE) {
[13:23:13.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.467]         }
[13:23:13.467]         else {
[13:23:13.467]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.467]         }
[13:23:13.467]         base::close(...future.stdout)
[13:23:13.467]         ...future.stdout <- NULL
[13:23:13.467]     }
[13:23:13.467]     ...future.result$conditions <- ...future.conditions
[13:23:13.467]     ...future.result$finished <- base::Sys.time()
[13:23:13.467]     ...future.result
[13:23:13.467] }
[13:23:13.470] assign_globals() ...
[13:23:13.470] List of 2
[13:23:13.470]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.470]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.470]  - attr(*, "where")=List of 2
[13:23:13.470]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.470]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.470]  - attr(*, "resolved")= logi FALSE
[13:23:13.470]  - attr(*, "total_size")= num 896
[13:23:13.470]  - attr(*, "already-done")= logi TRUE
[13:23:13.474] - copied ‘weight’ to environment
[13:23:13.474] - copied ‘group’ to environment
[13:23:13.474] assign_globals() ... done
[13:23:13.475] requestCore(): workers = 2
[13:23:13.477] MulticoreFuture started
[13:23:13.477] - Launch lazy future ... done
[13:23:13.477] run() for ‘MulticoreFuture’ ... done
[13:23:13.478] result() for MulticoreFuture ...
[13:23:13.478] plan(): Setting new future strategy stack:
[13:23:13.479] List of future strategies:
[13:23:13.479] 1. sequential:
[13:23:13.479]    - args: function (..., envir = parent.frame())
[13:23:13.479]    - tweaked: FALSE
[13:23:13.479]    - call: NULL
[13:23:13.480] plan(): nbrOfWorkers() = 1
[13:23:13.484] plan(): Setting new future strategy stack:
[13:23:13.484] List of future strategies:
[13:23:13.484] 1. multicore:
[13:23:13.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.484]    - tweaked: FALSE
[13:23:13.484]    - call: plan(strategy)
[13:23:13.489] plan(): nbrOfWorkers() = 2
[13:23:13.491] result() for MulticoreFuture ...
[13:23:13.491] result() for MulticoreFuture ... done
[13:23:13.492] result() for MulticoreFuture ... done
[13:23:13.492] result() for MulticoreFuture ...
[13:23:13.492] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:13.495] getGlobalsAndPackages() ...
[13:23:13.495] Searching for globals...
[13:23:13.497] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:13.497] Searching for globals ... DONE
[13:23:13.497] Resolving globals: FALSE
[13:23:13.498] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:13.499] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:13.499] - globals: [2] ‘weight’, ‘group’
[13:23:13.499] - packages: [1] ‘stats’
[13:23:13.499] getGlobalsAndPackages() ... DONE
[13:23:13.499] run() for ‘Future’ ...
[13:23:13.500] - state: ‘created’
[13:23:13.500] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.504] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.505] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.505]   - Field: ‘label’
[13:23:13.505]   - Field: ‘local’
[13:23:13.505]   - Field: ‘owner’
[13:23:13.505]   - Field: ‘envir’
[13:23:13.505]   - Field: ‘workers’
[13:23:13.505]   - Field: ‘packages’
[13:23:13.505]   - Field: ‘gc’
[13:23:13.506]   - Field: ‘job’
[13:23:13.506]   - Field: ‘conditions’
[13:23:13.506]   - Field: ‘expr’
[13:23:13.506]   - Field: ‘uuid’
[13:23:13.506]   - Field: ‘seed’
[13:23:13.506]   - Field: ‘version’
[13:23:13.506]   - Field: ‘result’
[13:23:13.506]   - Field: ‘asynchronous’
[13:23:13.506]   - Field: ‘calls’
[13:23:13.507]   - Field: ‘globals’
[13:23:13.507]   - Field: ‘stdout’
[13:23:13.507]   - Field: ‘earlySignal’
[13:23:13.510]   - Field: ‘lazy’
[13:23:13.510]   - Field: ‘state’
[13:23:13.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.510] - Launch lazy future ...
[13:23:13.511] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.511] Packages needed by future strategies (n = 0): <none>
[13:23:13.512] {
[13:23:13.512]     {
[13:23:13.512]         {
[13:23:13.512]             ...future.startTime <- base::Sys.time()
[13:23:13.512]             {
[13:23:13.512]                 {
[13:23:13.512]                   {
[13:23:13.512]                     {
[13:23:13.512]                       {
[13:23:13.512]                         base::local({
[13:23:13.512]                           has_future <- base::requireNamespace("future", 
[13:23:13.512]                             quietly = TRUE)
[13:23:13.512]                           if (has_future) {
[13:23:13.512]                             ns <- base::getNamespace("future")
[13:23:13.512]                             version <- ns[[".package"]][["version"]]
[13:23:13.512]                             if (is.null(version)) 
[13:23:13.512]                               version <- utils::packageVersion("future")
[13:23:13.512]                           }
[13:23:13.512]                           else {
[13:23:13.512]                             version <- NULL
[13:23:13.512]                           }
[13:23:13.512]                           if (!has_future || version < "1.8.0") {
[13:23:13.512]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.512]                               "", base::R.version$version.string), 
[13:23:13.512]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.512]                                 base::R.version$platform, 8 * 
[13:23:13.512]                                   base::.Machine$sizeof.pointer), 
[13:23:13.512]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.512]                                 "release", "version")], collapse = " "), 
[13:23:13.512]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.512]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.512]                               info)
[13:23:13.512]                             info <- base::paste(info, collapse = "; ")
[13:23:13.512]                             if (!has_future) {
[13:23:13.512]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.512]                                 info)
[13:23:13.512]                             }
[13:23:13.512]                             else {
[13:23:13.512]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.512]                                 info, version)
[13:23:13.512]                             }
[13:23:13.512]                             base::stop(msg)
[13:23:13.512]                           }
[13:23:13.512]                         })
[13:23:13.512]                       }
[13:23:13.512]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.512]                       base::options(mc.cores = 1L)
[13:23:13.512]                     }
[13:23:13.512]                     base::local({
[13:23:13.512]                       for (pkg in "stats") {
[13:23:13.512]                         base::loadNamespace(pkg)
[13:23:13.512]                         base::library(pkg, character.only = TRUE)
[13:23:13.512]                       }
[13:23:13.512]                     })
[13:23:13.512]                   }
[13:23:13.512]                   options(future.plan = NULL)
[13:23:13.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.512]                 }
[13:23:13.512]                 ...future.workdir <- getwd()
[13:23:13.512]             }
[13:23:13.512]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.512]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.512]         }
[13:23:13.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.512]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.512]             base::names(...future.oldOptions))
[13:23:13.512]     }
[13:23:13.512]     if (FALSE) {
[13:23:13.512]     }
[13:23:13.512]     else {
[13:23:13.512]         if (TRUE) {
[13:23:13.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.512]                 open = "w")
[13:23:13.512]         }
[13:23:13.512]         else {
[13:23:13.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.512]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.512]         }
[13:23:13.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.512]             base::sink(type = "output", split = FALSE)
[13:23:13.512]             base::close(...future.stdout)
[13:23:13.512]         }, add = TRUE)
[13:23:13.512]     }
[13:23:13.512]     ...future.frame <- base::sys.nframe()
[13:23:13.512]     ...future.conditions <- base::list()
[13:23:13.512]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.512]     if (FALSE) {
[13:23:13.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.512]     }
[13:23:13.512]     ...future.result <- base::tryCatch({
[13:23:13.512]         base::withCallingHandlers({
[13:23:13.512]             ...future.value <- base::withVisible(base::local({
[13:23:13.512]                 withCallingHandlers({
[13:23:13.512]                   {
[13:23:13.512]                     lm(weight ~ group - 1)
[13:23:13.512]                   }
[13:23:13.512]                 }, immediateCondition = function(cond) {
[13:23:13.512]                   save_rds <- function (object, pathname, ...) 
[13:23:13.512]                   {
[13:23:13.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.512]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.512]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.512]                         fi_tmp[["mtime"]])
[13:23:13.512]                     }
[13:23:13.512]                     tryCatch({
[13:23:13.512]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.512]                     }, error = function(ex) {
[13:23:13.512]                       msg <- conditionMessage(ex)
[13:23:13.512]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.512]                         fi_tmp[["mtime"]], msg)
[13:23:13.512]                       ex$message <- msg
[13:23:13.512]                       stop(ex)
[13:23:13.512]                     })
[13:23:13.512]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.512]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.512]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.512]                       fi <- file.info(pathname)
[13:23:13.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.512]                         fi[["size"]], fi[["mtime"]])
[13:23:13.512]                       stop(msg)
[13:23:13.512]                     }
[13:23:13.512]                     invisible(pathname)
[13:23:13.512]                   }
[13:23:13.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.512]                     rootPath = tempdir()) 
[13:23:13.512]                   {
[13:23:13.512]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.512]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.512]                       tmpdir = path, fileext = ".rds")
[13:23:13.512]                     save_rds(obj, file)
[13:23:13.512]                   }
[13:23:13.512]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.512]                   {
[13:23:13.512]                     inherits <- base::inherits
[13:23:13.512]                     invokeRestart <- base::invokeRestart
[13:23:13.512]                     is.null <- base::is.null
[13:23:13.512]                     muffled <- FALSE
[13:23:13.512]                     if (inherits(cond, "message")) {
[13:23:13.512]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.512]                       if (muffled) 
[13:23:13.512]                         invokeRestart("muffleMessage")
[13:23:13.512]                     }
[13:23:13.512]                     else if (inherits(cond, "warning")) {
[13:23:13.512]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.512]                       if (muffled) 
[13:23:13.512]                         invokeRestart("muffleWarning")
[13:23:13.512]                     }
[13:23:13.512]                     else if (inherits(cond, "condition")) {
[13:23:13.512]                       if (!is.null(pattern)) {
[13:23:13.512]                         computeRestarts <- base::computeRestarts
[13:23:13.512]                         grepl <- base::grepl
[13:23:13.512]                         restarts <- computeRestarts(cond)
[13:23:13.512]                         for (restart in restarts) {
[13:23:13.512]                           name <- restart$name
[13:23:13.512]                           if (is.null(name)) 
[13:23:13.512]                             next
[13:23:13.512]                           if (!grepl(pattern, name)) 
[13:23:13.512]                             next
[13:23:13.512]                           invokeRestart(restart)
[13:23:13.512]                           muffled <- TRUE
[13:23:13.512]                           break
[13:23:13.512]                         }
[13:23:13.512]                       }
[13:23:13.512]                     }
[13:23:13.512]                     invisible(muffled)
[13:23:13.512]                   }
[13:23:13.512]                   muffleCondition(cond)
[13:23:13.512]                 })
[13:23:13.512]             }))
[13:23:13.512]             future::FutureResult(value = ...future.value$value, 
[13:23:13.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.512]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.512]                     ...future.globalenv.names))
[13:23:13.512]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.512]         }, condition = base::local({
[13:23:13.512]             c <- base::c
[13:23:13.512]             inherits <- base::inherits
[13:23:13.512]             invokeRestart <- base::invokeRestart
[13:23:13.512]             length <- base::length
[13:23:13.512]             list <- base::list
[13:23:13.512]             seq.int <- base::seq.int
[13:23:13.512]             signalCondition <- base::signalCondition
[13:23:13.512]             sys.calls <- base::sys.calls
[13:23:13.512]             `[[` <- base::`[[`
[13:23:13.512]             `+` <- base::`+`
[13:23:13.512]             `<<-` <- base::`<<-`
[13:23:13.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.512]                   3L)]
[13:23:13.512]             }
[13:23:13.512]             function(cond) {
[13:23:13.512]                 is_error <- inherits(cond, "error")
[13:23:13.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.512]                   NULL)
[13:23:13.512]                 if (is_error) {
[13:23:13.512]                   sessionInformation <- function() {
[13:23:13.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.512]                       search = base::search(), system = base::Sys.info())
[13:23:13.512]                   }
[13:23:13.512]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.512]                     cond$call), session = sessionInformation(), 
[13:23:13.512]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.512]                   signalCondition(cond)
[13:23:13.512]                 }
[13:23:13.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.512]                 "immediateCondition"))) {
[13:23:13.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.512]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.512]                   if (TRUE && !signal) {
[13:23:13.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.512]                     {
[13:23:13.512]                       inherits <- base::inherits
[13:23:13.512]                       invokeRestart <- base::invokeRestart
[13:23:13.512]                       is.null <- base::is.null
[13:23:13.512]                       muffled <- FALSE
[13:23:13.512]                       if (inherits(cond, "message")) {
[13:23:13.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.512]                         if (muffled) 
[13:23:13.512]                           invokeRestart("muffleMessage")
[13:23:13.512]                       }
[13:23:13.512]                       else if (inherits(cond, "warning")) {
[13:23:13.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.512]                         if (muffled) 
[13:23:13.512]                           invokeRestart("muffleWarning")
[13:23:13.512]                       }
[13:23:13.512]                       else if (inherits(cond, "condition")) {
[13:23:13.512]                         if (!is.null(pattern)) {
[13:23:13.512]                           computeRestarts <- base::computeRestarts
[13:23:13.512]                           grepl <- base::grepl
[13:23:13.512]                           restarts <- computeRestarts(cond)
[13:23:13.512]                           for (restart in restarts) {
[13:23:13.512]                             name <- restart$name
[13:23:13.512]                             if (is.null(name)) 
[13:23:13.512]                               next
[13:23:13.512]                             if (!grepl(pattern, name)) 
[13:23:13.512]                               next
[13:23:13.512]                             invokeRestart(restart)
[13:23:13.512]                             muffled <- TRUE
[13:23:13.512]                             break
[13:23:13.512]                           }
[13:23:13.512]                         }
[13:23:13.512]                       }
[13:23:13.512]                       invisible(muffled)
[13:23:13.512]                     }
[13:23:13.512]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.512]                   }
[13:23:13.512]                 }
[13:23:13.512]                 else {
[13:23:13.512]                   if (TRUE) {
[13:23:13.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.512]                     {
[13:23:13.512]                       inherits <- base::inherits
[13:23:13.512]                       invokeRestart <- base::invokeRestart
[13:23:13.512]                       is.null <- base::is.null
[13:23:13.512]                       muffled <- FALSE
[13:23:13.512]                       if (inherits(cond, "message")) {
[13:23:13.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.512]                         if (muffled) 
[13:23:13.512]                           invokeRestart("muffleMessage")
[13:23:13.512]                       }
[13:23:13.512]                       else if (inherits(cond, "warning")) {
[13:23:13.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.512]                         if (muffled) 
[13:23:13.512]                           invokeRestart("muffleWarning")
[13:23:13.512]                       }
[13:23:13.512]                       else if (inherits(cond, "condition")) {
[13:23:13.512]                         if (!is.null(pattern)) {
[13:23:13.512]                           computeRestarts <- base::computeRestarts
[13:23:13.512]                           grepl <- base::grepl
[13:23:13.512]                           restarts <- computeRestarts(cond)
[13:23:13.512]                           for (restart in restarts) {
[13:23:13.512]                             name <- restart$name
[13:23:13.512]                             if (is.null(name)) 
[13:23:13.512]                               next
[13:23:13.512]                             if (!grepl(pattern, name)) 
[13:23:13.512]                               next
[13:23:13.512]                             invokeRestart(restart)
[13:23:13.512]                             muffled <- TRUE
[13:23:13.512]                             break
[13:23:13.512]                           }
[13:23:13.512]                         }
[13:23:13.512]                       }
[13:23:13.512]                       invisible(muffled)
[13:23:13.512]                     }
[13:23:13.512]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.512]                   }
[13:23:13.512]                 }
[13:23:13.512]             }
[13:23:13.512]         }))
[13:23:13.512]     }, error = function(ex) {
[13:23:13.512]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.512]                 ...future.rng), started = ...future.startTime, 
[13:23:13.512]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.512]             version = "1.8"), class = "FutureResult")
[13:23:13.512]     }, finally = {
[13:23:13.512]         if (!identical(...future.workdir, getwd())) 
[13:23:13.512]             setwd(...future.workdir)
[13:23:13.512]         {
[13:23:13.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.512]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.512]             }
[13:23:13.512]             base::options(...future.oldOptions)
[13:23:13.512]             if (.Platform$OS.type == "windows") {
[13:23:13.512]                 old_names <- names(...future.oldEnvVars)
[13:23:13.512]                 envs <- base::Sys.getenv()
[13:23:13.512]                 names <- names(envs)
[13:23:13.512]                 common <- intersect(names, old_names)
[13:23:13.512]                 added <- setdiff(names, old_names)
[13:23:13.512]                 removed <- setdiff(old_names, names)
[13:23:13.512]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.512]                   envs[common]]
[13:23:13.512]                 NAMES <- toupper(changed)
[13:23:13.512]                 args <- list()
[13:23:13.512]                 for (kk in seq_along(NAMES)) {
[13:23:13.512]                   name <- changed[[kk]]
[13:23:13.512]                   NAME <- NAMES[[kk]]
[13:23:13.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.512]                     next
[13:23:13.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.512]                 }
[13:23:13.512]                 NAMES <- toupper(added)
[13:23:13.512]                 for (kk in seq_along(NAMES)) {
[13:23:13.512]                   name <- added[[kk]]
[13:23:13.512]                   NAME <- NAMES[[kk]]
[13:23:13.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.512]                     next
[13:23:13.512]                   args[[name]] <- ""
[13:23:13.512]                 }
[13:23:13.512]                 NAMES <- toupper(removed)
[13:23:13.512]                 for (kk in seq_along(NAMES)) {
[13:23:13.512]                   name <- removed[[kk]]
[13:23:13.512]                   NAME <- NAMES[[kk]]
[13:23:13.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.512]                     next
[13:23:13.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.512]                 }
[13:23:13.512]                 if (length(args) > 0) 
[13:23:13.512]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.512]             }
[13:23:13.512]             else {
[13:23:13.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.512]             }
[13:23:13.512]             {
[13:23:13.512]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.512]                   0L) {
[13:23:13.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.512]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.512]                   base::options(opts)
[13:23:13.512]                 }
[13:23:13.512]                 {
[13:23:13.512]                   {
[13:23:13.512]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.512]                     NULL
[13:23:13.512]                   }
[13:23:13.512]                   options(future.plan = NULL)
[13:23:13.512]                   if (is.na(NA_character_)) 
[13:23:13.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.512]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.512]                     envir = parent.frame()) 
[13:23:13.512]                   {
[13:23:13.512]                     default_workers <- missing(workers)
[13:23:13.512]                     if (is.function(workers)) 
[13:23:13.512]                       workers <- workers()
[13:23:13.512]                     workers <- structure(as.integer(workers), 
[13:23:13.512]                       class = class(workers))
[13:23:13.512]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.512]                       1L)
[13:23:13.512]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.512]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.512]                       if (default_workers) 
[13:23:13.512]                         supportsMulticore(warn = TRUE)
[13:23:13.512]                       return(sequential(..., envir = envir))
[13:23:13.512]                     }
[13:23:13.512]                     oopts <- options(mc.cores = workers)
[13:23:13.512]                     on.exit(options(oopts))
[13:23:13.512]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.512]                       envir = envir)
[13:23:13.512]                     if (!future$lazy) 
[13:23:13.512]                       future <- run(future)
[13:23:13.512]                     invisible(future)
[13:23:13.512]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.512]                 }
[13:23:13.512]             }
[13:23:13.512]         }
[13:23:13.512]     })
[13:23:13.512]     if (TRUE) {
[13:23:13.512]         base::sink(type = "output", split = FALSE)
[13:23:13.512]         if (TRUE) {
[13:23:13.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.512]         }
[13:23:13.512]         else {
[13:23:13.512]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.512]         }
[13:23:13.512]         base::close(...future.stdout)
[13:23:13.512]         ...future.stdout <- NULL
[13:23:13.512]     }
[13:23:13.512]     ...future.result$conditions <- ...future.conditions
[13:23:13.512]     ...future.result$finished <- base::Sys.time()
[13:23:13.512]     ...future.result
[13:23:13.512] }
[13:23:13.514] assign_globals() ...
[13:23:13.515] List of 2
[13:23:13.515]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[13:23:13.515]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[13:23:13.515]  - attr(*, "where")=List of 2
[13:23:13.515]   ..$ weight:<environment: R_EmptyEnv> 
[13:23:13.515]   ..$ group :<environment: R_EmptyEnv> 
[13:23:13.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.515]  - attr(*, "resolved")= logi FALSE
[13:23:13.515]  - attr(*, "total_size")= num 896
[13:23:13.515]  - attr(*, "already-done")= logi TRUE
[13:23:13.519] - copied ‘weight’ to environment
[13:23:13.519] - copied ‘group’ to environment
[13:23:13.519] assign_globals() ... done
[13:23:13.519] requestCore(): workers = 2
[13:23:13.522] MulticoreFuture started
[13:23:13.522] - Launch lazy future ... done
[13:23:13.522] run() for ‘MulticoreFuture’ ... done
[13:23:13.523] result() for MulticoreFuture ...
[13:23:13.523] plan(): Setting new future strategy stack:
[13:23:13.524] List of future strategies:
[13:23:13.524] 1. sequential:
[13:23:13.524]    - args: function (..., envir = parent.frame())
[13:23:13.524]    - tweaked: FALSE
[13:23:13.524]    - call: NULL
[13:23:13.525] plan(): nbrOfWorkers() = 1
[13:23:13.529] plan(): Setting new future strategy stack:
[13:23:13.529] List of future strategies:
[13:23:13.529] 1. multicore:
[13:23:13.529]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.529]    - tweaked: FALSE
[13:23:13.529]    - call: plan(strategy)
[13:23:13.534] plan(): nbrOfWorkers() = 2
[13:23:13.536] result() for MulticoreFuture ...
[13:23:13.537] result() for MulticoreFuture ... done
[13:23:13.537] result() for MulticoreFuture ... done
[13:23:13.537] result() for MulticoreFuture ...
[13:23:13.537] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:23:13.540] getGlobalsAndPackages() ...
[13:23:13.540] Searching for globals...
[13:23:13.542] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:13.542] Searching for globals ... DONE
[13:23:13.542] Resolving globals: FALSE
[13:23:13.542] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:13.543] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:13.543] - globals: [1] ‘x’
[13:23:13.543] - packages: [1] ‘stats’
[13:23:13.543] getGlobalsAndPackages() ... DONE
[13:23:13.544] run() for ‘Future’ ...
[13:23:13.544] - state: ‘created’
[13:23:13.544] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.549]   - Field: ‘label’
[13:23:13.549]   - Field: ‘local’
[13:23:13.549]   - Field: ‘owner’
[13:23:13.550]   - Field: ‘envir’
[13:23:13.550]   - Field: ‘workers’
[13:23:13.550]   - Field: ‘packages’
[13:23:13.550]   - Field: ‘gc’
[13:23:13.550]   - Field: ‘job’
[13:23:13.550]   - Field: ‘conditions’
[13:23:13.550]   - Field: ‘expr’
[13:23:13.550]   - Field: ‘uuid’
[13:23:13.551]   - Field: ‘seed’
[13:23:13.551]   - Field: ‘version’
[13:23:13.551]   - Field: ‘result’
[13:23:13.551]   - Field: ‘asynchronous’
[13:23:13.551]   - Field: ‘calls’
[13:23:13.551]   - Field: ‘globals’
[13:23:13.551]   - Field: ‘stdout’
[13:23:13.551]   - Field: ‘earlySignal’
[13:23:13.551]   - Field: ‘lazy’
[13:23:13.552]   - Field: ‘state’
[13:23:13.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.552] - Launch lazy future ...
[13:23:13.552] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.552] Packages needed by future strategies (n = 0): <none>
[13:23:13.553] {
[13:23:13.553]     {
[13:23:13.553]         {
[13:23:13.553]             ...future.startTime <- base::Sys.time()
[13:23:13.553]             {
[13:23:13.553]                 {
[13:23:13.553]                   {
[13:23:13.553]                     {
[13:23:13.553]                       {
[13:23:13.553]                         base::local({
[13:23:13.553]                           has_future <- base::requireNamespace("future", 
[13:23:13.553]                             quietly = TRUE)
[13:23:13.553]                           if (has_future) {
[13:23:13.553]                             ns <- base::getNamespace("future")
[13:23:13.553]                             version <- ns[[".package"]][["version"]]
[13:23:13.553]                             if (is.null(version)) 
[13:23:13.553]                               version <- utils::packageVersion("future")
[13:23:13.553]                           }
[13:23:13.553]                           else {
[13:23:13.553]                             version <- NULL
[13:23:13.553]                           }
[13:23:13.553]                           if (!has_future || version < "1.8.0") {
[13:23:13.553]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.553]                               "", base::R.version$version.string), 
[13:23:13.553]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.553]                                 base::R.version$platform, 8 * 
[13:23:13.553]                                   base::.Machine$sizeof.pointer), 
[13:23:13.553]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.553]                                 "release", "version")], collapse = " "), 
[13:23:13.553]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.553]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.553]                               info)
[13:23:13.553]                             info <- base::paste(info, collapse = "; ")
[13:23:13.553]                             if (!has_future) {
[13:23:13.553]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.553]                                 info)
[13:23:13.553]                             }
[13:23:13.553]                             else {
[13:23:13.553]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.553]                                 info, version)
[13:23:13.553]                             }
[13:23:13.553]                             base::stop(msg)
[13:23:13.553]                           }
[13:23:13.553]                         })
[13:23:13.553]                       }
[13:23:13.553]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.553]                       base::options(mc.cores = 1L)
[13:23:13.553]                     }
[13:23:13.553]                     base::local({
[13:23:13.553]                       for (pkg in "stats") {
[13:23:13.553]                         base::loadNamespace(pkg)
[13:23:13.553]                         base::library(pkg, character.only = TRUE)
[13:23:13.553]                       }
[13:23:13.553]                     })
[13:23:13.553]                   }
[13:23:13.553]                   options(future.plan = NULL)
[13:23:13.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.553]                 }
[13:23:13.553]                 ...future.workdir <- getwd()
[13:23:13.553]             }
[13:23:13.553]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.553]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.553]         }
[13:23:13.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.553]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.553]             base::names(...future.oldOptions))
[13:23:13.553]     }
[13:23:13.553]     if (FALSE) {
[13:23:13.553]     }
[13:23:13.553]     else {
[13:23:13.553]         if (TRUE) {
[13:23:13.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.553]                 open = "w")
[13:23:13.553]         }
[13:23:13.553]         else {
[13:23:13.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.553]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.553]         }
[13:23:13.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.553]             base::sink(type = "output", split = FALSE)
[13:23:13.553]             base::close(...future.stdout)
[13:23:13.553]         }, add = TRUE)
[13:23:13.553]     }
[13:23:13.553]     ...future.frame <- base::sys.nframe()
[13:23:13.553]     ...future.conditions <- base::list()
[13:23:13.553]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.553]     if (FALSE) {
[13:23:13.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.553]     }
[13:23:13.553]     ...future.result <- base::tryCatch({
[13:23:13.553]         base::withCallingHandlers({
[13:23:13.553]             ...future.value <- base::withVisible(base::local({
[13:23:13.553]                 withCallingHandlers({
[13:23:13.553]                   {
[13:23:13.553]                     xtabs(~x)
[13:23:13.553]                   }
[13:23:13.553]                 }, immediateCondition = function(cond) {
[13:23:13.553]                   save_rds <- function (object, pathname, ...) 
[13:23:13.553]                   {
[13:23:13.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.553]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.553]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.553]                         fi_tmp[["mtime"]])
[13:23:13.553]                     }
[13:23:13.553]                     tryCatch({
[13:23:13.553]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.553]                     }, error = function(ex) {
[13:23:13.553]                       msg <- conditionMessage(ex)
[13:23:13.553]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.553]                         fi_tmp[["mtime"]], msg)
[13:23:13.553]                       ex$message <- msg
[13:23:13.553]                       stop(ex)
[13:23:13.553]                     })
[13:23:13.553]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.553]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.553]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.553]                       fi <- file.info(pathname)
[13:23:13.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.553]                         fi[["size"]], fi[["mtime"]])
[13:23:13.553]                       stop(msg)
[13:23:13.553]                     }
[13:23:13.553]                     invisible(pathname)
[13:23:13.553]                   }
[13:23:13.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.553]                     rootPath = tempdir()) 
[13:23:13.553]                   {
[13:23:13.553]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.553]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.553]                       tmpdir = path, fileext = ".rds")
[13:23:13.553]                     save_rds(obj, file)
[13:23:13.553]                   }
[13:23:13.553]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.553]                   {
[13:23:13.553]                     inherits <- base::inherits
[13:23:13.553]                     invokeRestart <- base::invokeRestart
[13:23:13.553]                     is.null <- base::is.null
[13:23:13.553]                     muffled <- FALSE
[13:23:13.553]                     if (inherits(cond, "message")) {
[13:23:13.553]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.553]                       if (muffled) 
[13:23:13.553]                         invokeRestart("muffleMessage")
[13:23:13.553]                     }
[13:23:13.553]                     else if (inherits(cond, "warning")) {
[13:23:13.553]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.553]                       if (muffled) 
[13:23:13.553]                         invokeRestart("muffleWarning")
[13:23:13.553]                     }
[13:23:13.553]                     else if (inherits(cond, "condition")) {
[13:23:13.553]                       if (!is.null(pattern)) {
[13:23:13.553]                         computeRestarts <- base::computeRestarts
[13:23:13.553]                         grepl <- base::grepl
[13:23:13.553]                         restarts <- computeRestarts(cond)
[13:23:13.553]                         for (restart in restarts) {
[13:23:13.553]                           name <- restart$name
[13:23:13.553]                           if (is.null(name)) 
[13:23:13.553]                             next
[13:23:13.553]                           if (!grepl(pattern, name)) 
[13:23:13.553]                             next
[13:23:13.553]                           invokeRestart(restart)
[13:23:13.553]                           muffled <- TRUE
[13:23:13.553]                           break
[13:23:13.553]                         }
[13:23:13.553]                       }
[13:23:13.553]                     }
[13:23:13.553]                     invisible(muffled)
[13:23:13.553]                   }
[13:23:13.553]                   muffleCondition(cond)
[13:23:13.553]                 })
[13:23:13.553]             }))
[13:23:13.553]             future::FutureResult(value = ...future.value$value, 
[13:23:13.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.553]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.553]                     ...future.globalenv.names))
[13:23:13.553]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.553]         }, condition = base::local({
[13:23:13.553]             c <- base::c
[13:23:13.553]             inherits <- base::inherits
[13:23:13.553]             invokeRestart <- base::invokeRestart
[13:23:13.553]             length <- base::length
[13:23:13.553]             list <- base::list
[13:23:13.553]             seq.int <- base::seq.int
[13:23:13.553]             signalCondition <- base::signalCondition
[13:23:13.553]             sys.calls <- base::sys.calls
[13:23:13.553]             `[[` <- base::`[[`
[13:23:13.553]             `+` <- base::`+`
[13:23:13.553]             `<<-` <- base::`<<-`
[13:23:13.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.553]                   3L)]
[13:23:13.553]             }
[13:23:13.553]             function(cond) {
[13:23:13.553]                 is_error <- inherits(cond, "error")
[13:23:13.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.553]                   NULL)
[13:23:13.553]                 if (is_error) {
[13:23:13.553]                   sessionInformation <- function() {
[13:23:13.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.553]                       search = base::search(), system = base::Sys.info())
[13:23:13.553]                   }
[13:23:13.553]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.553]                     cond$call), session = sessionInformation(), 
[13:23:13.553]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.553]                   signalCondition(cond)
[13:23:13.553]                 }
[13:23:13.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.553]                 "immediateCondition"))) {
[13:23:13.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.553]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.553]                   if (TRUE && !signal) {
[13:23:13.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.553]                     {
[13:23:13.553]                       inherits <- base::inherits
[13:23:13.553]                       invokeRestart <- base::invokeRestart
[13:23:13.553]                       is.null <- base::is.null
[13:23:13.553]                       muffled <- FALSE
[13:23:13.553]                       if (inherits(cond, "message")) {
[13:23:13.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.553]                         if (muffled) 
[13:23:13.553]                           invokeRestart("muffleMessage")
[13:23:13.553]                       }
[13:23:13.553]                       else if (inherits(cond, "warning")) {
[13:23:13.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.553]                         if (muffled) 
[13:23:13.553]                           invokeRestart("muffleWarning")
[13:23:13.553]                       }
[13:23:13.553]                       else if (inherits(cond, "condition")) {
[13:23:13.553]                         if (!is.null(pattern)) {
[13:23:13.553]                           computeRestarts <- base::computeRestarts
[13:23:13.553]                           grepl <- base::grepl
[13:23:13.553]                           restarts <- computeRestarts(cond)
[13:23:13.553]                           for (restart in restarts) {
[13:23:13.553]                             name <- restart$name
[13:23:13.553]                             if (is.null(name)) 
[13:23:13.553]                               next
[13:23:13.553]                             if (!grepl(pattern, name)) 
[13:23:13.553]                               next
[13:23:13.553]                             invokeRestart(restart)
[13:23:13.553]                             muffled <- TRUE
[13:23:13.553]                             break
[13:23:13.553]                           }
[13:23:13.553]                         }
[13:23:13.553]                       }
[13:23:13.553]                       invisible(muffled)
[13:23:13.553]                     }
[13:23:13.553]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.553]                   }
[13:23:13.553]                 }
[13:23:13.553]                 else {
[13:23:13.553]                   if (TRUE) {
[13:23:13.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.553]                     {
[13:23:13.553]                       inherits <- base::inherits
[13:23:13.553]                       invokeRestart <- base::invokeRestart
[13:23:13.553]                       is.null <- base::is.null
[13:23:13.553]                       muffled <- FALSE
[13:23:13.553]                       if (inherits(cond, "message")) {
[13:23:13.553]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.553]                         if (muffled) 
[13:23:13.553]                           invokeRestart("muffleMessage")
[13:23:13.553]                       }
[13:23:13.553]                       else if (inherits(cond, "warning")) {
[13:23:13.553]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.553]                         if (muffled) 
[13:23:13.553]                           invokeRestart("muffleWarning")
[13:23:13.553]                       }
[13:23:13.553]                       else if (inherits(cond, "condition")) {
[13:23:13.553]                         if (!is.null(pattern)) {
[13:23:13.553]                           computeRestarts <- base::computeRestarts
[13:23:13.553]                           grepl <- base::grepl
[13:23:13.553]                           restarts <- computeRestarts(cond)
[13:23:13.553]                           for (restart in restarts) {
[13:23:13.553]                             name <- restart$name
[13:23:13.553]                             if (is.null(name)) 
[13:23:13.553]                               next
[13:23:13.553]                             if (!grepl(pattern, name)) 
[13:23:13.553]                               next
[13:23:13.553]                             invokeRestart(restart)
[13:23:13.553]                             muffled <- TRUE
[13:23:13.553]                             break
[13:23:13.553]                           }
[13:23:13.553]                         }
[13:23:13.553]                       }
[13:23:13.553]                       invisible(muffled)
[13:23:13.553]                     }
[13:23:13.553]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.553]                   }
[13:23:13.553]                 }
[13:23:13.553]             }
[13:23:13.553]         }))
[13:23:13.553]     }, error = function(ex) {
[13:23:13.553]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.553]                 ...future.rng), started = ...future.startTime, 
[13:23:13.553]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.553]             version = "1.8"), class = "FutureResult")
[13:23:13.553]     }, finally = {
[13:23:13.553]         if (!identical(...future.workdir, getwd())) 
[13:23:13.553]             setwd(...future.workdir)
[13:23:13.553]         {
[13:23:13.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.553]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.553]             }
[13:23:13.553]             base::options(...future.oldOptions)
[13:23:13.553]             if (.Platform$OS.type == "windows") {
[13:23:13.553]                 old_names <- names(...future.oldEnvVars)
[13:23:13.553]                 envs <- base::Sys.getenv()
[13:23:13.553]                 names <- names(envs)
[13:23:13.553]                 common <- intersect(names, old_names)
[13:23:13.553]                 added <- setdiff(names, old_names)
[13:23:13.553]                 removed <- setdiff(old_names, names)
[13:23:13.553]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.553]                   envs[common]]
[13:23:13.553]                 NAMES <- toupper(changed)
[13:23:13.553]                 args <- list()
[13:23:13.553]                 for (kk in seq_along(NAMES)) {
[13:23:13.553]                   name <- changed[[kk]]
[13:23:13.553]                   NAME <- NAMES[[kk]]
[13:23:13.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.553]                     next
[13:23:13.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.553]                 }
[13:23:13.553]                 NAMES <- toupper(added)
[13:23:13.553]                 for (kk in seq_along(NAMES)) {
[13:23:13.553]                   name <- added[[kk]]
[13:23:13.553]                   NAME <- NAMES[[kk]]
[13:23:13.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.553]                     next
[13:23:13.553]                   args[[name]] <- ""
[13:23:13.553]                 }
[13:23:13.553]                 NAMES <- toupper(removed)
[13:23:13.553]                 for (kk in seq_along(NAMES)) {
[13:23:13.553]                   name <- removed[[kk]]
[13:23:13.553]                   NAME <- NAMES[[kk]]
[13:23:13.553]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.553]                     next
[13:23:13.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.553]                 }
[13:23:13.553]                 if (length(args) > 0) 
[13:23:13.553]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.553]             }
[13:23:13.553]             else {
[13:23:13.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.553]             }
[13:23:13.553]             {
[13:23:13.553]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.553]                   0L) {
[13:23:13.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.553]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.553]                   base::options(opts)
[13:23:13.553]                 }
[13:23:13.553]                 {
[13:23:13.553]                   {
[13:23:13.553]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.553]                     NULL
[13:23:13.553]                   }
[13:23:13.553]                   options(future.plan = NULL)
[13:23:13.553]                   if (is.na(NA_character_)) 
[13:23:13.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.553]                     envir = parent.frame()) 
[13:23:13.553]                   {
[13:23:13.553]                     default_workers <- missing(workers)
[13:23:13.553]                     if (is.function(workers)) 
[13:23:13.553]                       workers <- workers()
[13:23:13.553]                     workers <- structure(as.integer(workers), 
[13:23:13.553]                       class = class(workers))
[13:23:13.553]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.553]                       1L)
[13:23:13.553]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.553]                       if (default_workers) 
[13:23:13.553]                         supportsMulticore(warn = TRUE)
[13:23:13.553]                       return(sequential(..., envir = envir))
[13:23:13.553]                     }
[13:23:13.553]                     oopts <- options(mc.cores = workers)
[13:23:13.553]                     on.exit(options(oopts))
[13:23:13.553]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.553]                       envir = envir)
[13:23:13.553]                     if (!future$lazy) 
[13:23:13.553]                       future <- run(future)
[13:23:13.553]                     invisible(future)
[13:23:13.553]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.553]                 }
[13:23:13.553]             }
[13:23:13.553]         }
[13:23:13.553]     })
[13:23:13.553]     if (TRUE) {
[13:23:13.553]         base::sink(type = "output", split = FALSE)
[13:23:13.553]         if (TRUE) {
[13:23:13.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.553]         }
[13:23:13.553]         else {
[13:23:13.553]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.553]         }
[13:23:13.553]         base::close(...future.stdout)
[13:23:13.553]         ...future.stdout <- NULL
[13:23:13.553]     }
[13:23:13.553]     ...future.result$conditions <- ...future.conditions
[13:23:13.553]     ...future.result$finished <- base::Sys.time()
[13:23:13.553]     ...future.result
[13:23:13.553] }
[13:23:13.556] assign_globals() ...
[13:23:13.556] List of 1
[13:23:13.556]  $ x: num [1:5] 1 1 2 2 2
[13:23:13.556]  - attr(*, "where")=List of 1
[13:23:13.556]   ..$ x:<environment: R_EmptyEnv> 
[13:23:13.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.556]  - attr(*, "resolved")= logi FALSE
[13:23:13.556]  - attr(*, "total_size")= num 96
[13:23:13.556]  - attr(*, "already-done")= logi TRUE
[13:23:13.563] - copied ‘x’ to environment
[13:23:13.563] assign_globals() ... done
[13:23:13.563] requestCore(): workers = 2
[13:23:13.566] MulticoreFuture started
[13:23:13.566] - Launch lazy future ... done
[13:23:13.566] run() for ‘MulticoreFuture’ ... done
[13:23:13.567] result() for MulticoreFuture ...
[13:23:13.567] plan(): Setting new future strategy stack:
[13:23:13.568] List of future strategies:
[13:23:13.568] 1. sequential:
[13:23:13.568]    - args: function (..., envir = parent.frame())
[13:23:13.568]    - tweaked: FALSE
[13:23:13.568]    - call: NULL
[13:23:13.569] plan(): nbrOfWorkers() = 1
[13:23:13.572] plan(): Setting new future strategy stack:
[13:23:13.572] List of future strategies:
[13:23:13.572] 1. multicore:
[13:23:13.572]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.572]    - tweaked: FALSE
[13:23:13.572]    - call: plan(strategy)
[13:23:13.578] plan(): nbrOfWorkers() = 2
[13:23:13.580] result() for MulticoreFuture ...
[13:23:13.580] result() for MulticoreFuture ... done
[13:23:13.580] result() for MulticoreFuture ... done
[13:23:13.580] result() for MulticoreFuture ...
[13:23:13.580] result() for MulticoreFuture ... done
x
1 2 
2 3 
[13:23:13.582] getGlobalsAndPackages() ...
[13:23:13.582] Searching for globals...
[13:23:13.584] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:13.584] Searching for globals ... DONE
[13:23:13.584] Resolving globals: FALSE
[13:23:13.585] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:13.585] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:13.585] - globals: [1] ‘x’
[13:23:13.585] - packages: [1] ‘stats’
[13:23:13.586] getGlobalsAndPackages() ... DONE
[13:23:13.586] run() for ‘Future’ ...
[13:23:13.586] - state: ‘created’
[13:23:13.586] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.591] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.591]   - Field: ‘label’
[13:23:13.591]   - Field: ‘local’
[13:23:13.592]   - Field: ‘owner’
[13:23:13.592]   - Field: ‘envir’
[13:23:13.592]   - Field: ‘workers’
[13:23:13.592]   - Field: ‘packages’
[13:23:13.592]   - Field: ‘gc’
[13:23:13.592]   - Field: ‘job’
[13:23:13.592]   - Field: ‘conditions’
[13:23:13.592]   - Field: ‘expr’
[13:23:13.593]   - Field: ‘uuid’
[13:23:13.593]   - Field: ‘seed’
[13:23:13.593]   - Field: ‘version’
[13:23:13.593]   - Field: ‘result’
[13:23:13.593]   - Field: ‘asynchronous’
[13:23:13.593]   - Field: ‘calls’
[13:23:13.593]   - Field: ‘globals’
[13:23:13.593]   - Field: ‘stdout’
[13:23:13.593]   - Field: ‘earlySignal’
[13:23:13.594]   - Field: ‘lazy’
[13:23:13.594]   - Field: ‘state’
[13:23:13.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.594] - Launch lazy future ...
[13:23:13.594] Packages needed by the future expression (n = 1): ‘stats’
[13:23:13.594] Packages needed by future strategies (n = 0): <none>
[13:23:13.595] {
[13:23:13.595]     {
[13:23:13.595]         {
[13:23:13.595]             ...future.startTime <- base::Sys.time()
[13:23:13.595]             {
[13:23:13.595]                 {
[13:23:13.595]                   {
[13:23:13.595]                     {
[13:23:13.595]                       {
[13:23:13.595]                         base::local({
[13:23:13.595]                           has_future <- base::requireNamespace("future", 
[13:23:13.595]                             quietly = TRUE)
[13:23:13.595]                           if (has_future) {
[13:23:13.595]                             ns <- base::getNamespace("future")
[13:23:13.595]                             version <- ns[[".package"]][["version"]]
[13:23:13.595]                             if (is.null(version)) 
[13:23:13.595]                               version <- utils::packageVersion("future")
[13:23:13.595]                           }
[13:23:13.595]                           else {
[13:23:13.595]                             version <- NULL
[13:23:13.595]                           }
[13:23:13.595]                           if (!has_future || version < "1.8.0") {
[13:23:13.595]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.595]                               "", base::R.version$version.string), 
[13:23:13.595]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.595]                                 base::R.version$platform, 8 * 
[13:23:13.595]                                   base::.Machine$sizeof.pointer), 
[13:23:13.595]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.595]                                 "release", "version")], collapse = " "), 
[13:23:13.595]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.595]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.595]                               info)
[13:23:13.595]                             info <- base::paste(info, collapse = "; ")
[13:23:13.595]                             if (!has_future) {
[13:23:13.595]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.595]                                 info)
[13:23:13.595]                             }
[13:23:13.595]                             else {
[13:23:13.595]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.595]                                 info, version)
[13:23:13.595]                             }
[13:23:13.595]                             base::stop(msg)
[13:23:13.595]                           }
[13:23:13.595]                         })
[13:23:13.595]                       }
[13:23:13.595]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.595]                       base::options(mc.cores = 1L)
[13:23:13.595]                     }
[13:23:13.595]                     base::local({
[13:23:13.595]                       for (pkg in "stats") {
[13:23:13.595]                         base::loadNamespace(pkg)
[13:23:13.595]                         base::library(pkg, character.only = TRUE)
[13:23:13.595]                       }
[13:23:13.595]                     })
[13:23:13.595]                   }
[13:23:13.595]                   options(future.plan = NULL)
[13:23:13.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.595]                 }
[13:23:13.595]                 ...future.workdir <- getwd()
[13:23:13.595]             }
[13:23:13.595]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.595]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.595]         }
[13:23:13.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.595]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.595]             base::names(...future.oldOptions))
[13:23:13.595]     }
[13:23:13.595]     if (FALSE) {
[13:23:13.595]     }
[13:23:13.595]     else {
[13:23:13.595]         if (TRUE) {
[13:23:13.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.595]                 open = "w")
[13:23:13.595]         }
[13:23:13.595]         else {
[13:23:13.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.595]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.595]         }
[13:23:13.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.595]             base::sink(type = "output", split = FALSE)
[13:23:13.595]             base::close(...future.stdout)
[13:23:13.595]         }, add = TRUE)
[13:23:13.595]     }
[13:23:13.595]     ...future.frame <- base::sys.nframe()
[13:23:13.595]     ...future.conditions <- base::list()
[13:23:13.595]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.595]     if (FALSE) {
[13:23:13.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.595]     }
[13:23:13.595]     ...future.result <- base::tryCatch({
[13:23:13.595]         base::withCallingHandlers({
[13:23:13.595]             ...future.value <- base::withVisible(base::local({
[13:23:13.595]                 withCallingHandlers({
[13:23:13.595]                   {
[13:23:13.595]                     xtabs(~x)
[13:23:13.595]                   }
[13:23:13.595]                 }, immediateCondition = function(cond) {
[13:23:13.595]                   save_rds <- function (object, pathname, ...) 
[13:23:13.595]                   {
[13:23:13.595]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.595]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.595]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.595]                         fi_tmp[["mtime"]])
[13:23:13.595]                     }
[13:23:13.595]                     tryCatch({
[13:23:13.595]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.595]                     }, error = function(ex) {
[13:23:13.595]                       msg <- conditionMessage(ex)
[13:23:13.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.595]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.595]                         fi_tmp[["mtime"]], msg)
[13:23:13.595]                       ex$message <- msg
[13:23:13.595]                       stop(ex)
[13:23:13.595]                     })
[13:23:13.595]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.595]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.595]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.595]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.595]                       fi <- file.info(pathname)
[13:23:13.595]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.595]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.595]                         fi[["size"]], fi[["mtime"]])
[13:23:13.595]                       stop(msg)
[13:23:13.595]                     }
[13:23:13.595]                     invisible(pathname)
[13:23:13.595]                   }
[13:23:13.595]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.595]                     rootPath = tempdir()) 
[13:23:13.595]                   {
[13:23:13.595]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.595]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.595]                       tmpdir = path, fileext = ".rds")
[13:23:13.595]                     save_rds(obj, file)
[13:23:13.595]                   }
[13:23:13.595]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.595]                   {
[13:23:13.595]                     inherits <- base::inherits
[13:23:13.595]                     invokeRestart <- base::invokeRestart
[13:23:13.595]                     is.null <- base::is.null
[13:23:13.595]                     muffled <- FALSE
[13:23:13.595]                     if (inherits(cond, "message")) {
[13:23:13.595]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.595]                       if (muffled) 
[13:23:13.595]                         invokeRestart("muffleMessage")
[13:23:13.595]                     }
[13:23:13.595]                     else if (inherits(cond, "warning")) {
[13:23:13.595]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.595]                       if (muffled) 
[13:23:13.595]                         invokeRestart("muffleWarning")
[13:23:13.595]                     }
[13:23:13.595]                     else if (inherits(cond, "condition")) {
[13:23:13.595]                       if (!is.null(pattern)) {
[13:23:13.595]                         computeRestarts <- base::computeRestarts
[13:23:13.595]                         grepl <- base::grepl
[13:23:13.595]                         restarts <- computeRestarts(cond)
[13:23:13.595]                         for (restart in restarts) {
[13:23:13.595]                           name <- restart$name
[13:23:13.595]                           if (is.null(name)) 
[13:23:13.595]                             next
[13:23:13.595]                           if (!grepl(pattern, name)) 
[13:23:13.595]                             next
[13:23:13.595]                           invokeRestart(restart)
[13:23:13.595]                           muffled <- TRUE
[13:23:13.595]                           break
[13:23:13.595]                         }
[13:23:13.595]                       }
[13:23:13.595]                     }
[13:23:13.595]                     invisible(muffled)
[13:23:13.595]                   }
[13:23:13.595]                   muffleCondition(cond)
[13:23:13.595]                 })
[13:23:13.595]             }))
[13:23:13.595]             future::FutureResult(value = ...future.value$value, 
[13:23:13.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.595]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.595]                     ...future.globalenv.names))
[13:23:13.595]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.595]         }, condition = base::local({
[13:23:13.595]             c <- base::c
[13:23:13.595]             inherits <- base::inherits
[13:23:13.595]             invokeRestart <- base::invokeRestart
[13:23:13.595]             length <- base::length
[13:23:13.595]             list <- base::list
[13:23:13.595]             seq.int <- base::seq.int
[13:23:13.595]             signalCondition <- base::signalCondition
[13:23:13.595]             sys.calls <- base::sys.calls
[13:23:13.595]             `[[` <- base::`[[`
[13:23:13.595]             `+` <- base::`+`
[13:23:13.595]             `<<-` <- base::`<<-`
[13:23:13.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.595]                   3L)]
[13:23:13.595]             }
[13:23:13.595]             function(cond) {
[13:23:13.595]                 is_error <- inherits(cond, "error")
[13:23:13.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.595]                   NULL)
[13:23:13.595]                 if (is_error) {
[13:23:13.595]                   sessionInformation <- function() {
[13:23:13.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.595]                       search = base::search(), system = base::Sys.info())
[13:23:13.595]                   }
[13:23:13.595]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.595]                     cond$call), session = sessionInformation(), 
[13:23:13.595]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.595]                   signalCondition(cond)
[13:23:13.595]                 }
[13:23:13.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.595]                 "immediateCondition"))) {
[13:23:13.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.595]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.595]                   if (TRUE && !signal) {
[13:23:13.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.595]                     {
[13:23:13.595]                       inherits <- base::inherits
[13:23:13.595]                       invokeRestart <- base::invokeRestart
[13:23:13.595]                       is.null <- base::is.null
[13:23:13.595]                       muffled <- FALSE
[13:23:13.595]                       if (inherits(cond, "message")) {
[13:23:13.595]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.595]                         if (muffled) 
[13:23:13.595]                           invokeRestart("muffleMessage")
[13:23:13.595]                       }
[13:23:13.595]                       else if (inherits(cond, "warning")) {
[13:23:13.595]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.595]                         if (muffled) 
[13:23:13.595]                           invokeRestart("muffleWarning")
[13:23:13.595]                       }
[13:23:13.595]                       else if (inherits(cond, "condition")) {
[13:23:13.595]                         if (!is.null(pattern)) {
[13:23:13.595]                           computeRestarts <- base::computeRestarts
[13:23:13.595]                           grepl <- base::grepl
[13:23:13.595]                           restarts <- computeRestarts(cond)
[13:23:13.595]                           for (restart in restarts) {
[13:23:13.595]                             name <- restart$name
[13:23:13.595]                             if (is.null(name)) 
[13:23:13.595]                               next
[13:23:13.595]                             if (!grepl(pattern, name)) 
[13:23:13.595]                               next
[13:23:13.595]                             invokeRestart(restart)
[13:23:13.595]                             muffled <- TRUE
[13:23:13.595]                             break
[13:23:13.595]                           }
[13:23:13.595]                         }
[13:23:13.595]                       }
[13:23:13.595]                       invisible(muffled)
[13:23:13.595]                     }
[13:23:13.595]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.595]                   }
[13:23:13.595]                 }
[13:23:13.595]                 else {
[13:23:13.595]                   if (TRUE) {
[13:23:13.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.595]                     {
[13:23:13.595]                       inherits <- base::inherits
[13:23:13.595]                       invokeRestart <- base::invokeRestart
[13:23:13.595]                       is.null <- base::is.null
[13:23:13.595]                       muffled <- FALSE
[13:23:13.595]                       if (inherits(cond, "message")) {
[13:23:13.595]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.595]                         if (muffled) 
[13:23:13.595]                           invokeRestart("muffleMessage")
[13:23:13.595]                       }
[13:23:13.595]                       else if (inherits(cond, "warning")) {
[13:23:13.595]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.595]                         if (muffled) 
[13:23:13.595]                           invokeRestart("muffleWarning")
[13:23:13.595]                       }
[13:23:13.595]                       else if (inherits(cond, "condition")) {
[13:23:13.595]                         if (!is.null(pattern)) {
[13:23:13.595]                           computeRestarts <- base::computeRestarts
[13:23:13.595]                           grepl <- base::grepl
[13:23:13.595]                           restarts <- computeRestarts(cond)
[13:23:13.595]                           for (restart in restarts) {
[13:23:13.595]                             name <- restart$name
[13:23:13.595]                             if (is.null(name)) 
[13:23:13.595]                               next
[13:23:13.595]                             if (!grepl(pattern, name)) 
[13:23:13.595]                               next
[13:23:13.595]                             invokeRestart(restart)
[13:23:13.595]                             muffled <- TRUE
[13:23:13.595]                             break
[13:23:13.595]                           }
[13:23:13.595]                         }
[13:23:13.595]                       }
[13:23:13.595]                       invisible(muffled)
[13:23:13.595]                     }
[13:23:13.595]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.595]                   }
[13:23:13.595]                 }
[13:23:13.595]             }
[13:23:13.595]         }))
[13:23:13.595]     }, error = function(ex) {
[13:23:13.595]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.595]                 ...future.rng), started = ...future.startTime, 
[13:23:13.595]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.595]             version = "1.8"), class = "FutureResult")
[13:23:13.595]     }, finally = {
[13:23:13.595]         if (!identical(...future.workdir, getwd())) 
[13:23:13.595]             setwd(...future.workdir)
[13:23:13.595]         {
[13:23:13.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.595]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.595]             }
[13:23:13.595]             base::options(...future.oldOptions)
[13:23:13.595]             if (.Platform$OS.type == "windows") {
[13:23:13.595]                 old_names <- names(...future.oldEnvVars)
[13:23:13.595]                 envs <- base::Sys.getenv()
[13:23:13.595]                 names <- names(envs)
[13:23:13.595]                 common <- intersect(names, old_names)
[13:23:13.595]                 added <- setdiff(names, old_names)
[13:23:13.595]                 removed <- setdiff(old_names, names)
[13:23:13.595]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.595]                   envs[common]]
[13:23:13.595]                 NAMES <- toupper(changed)
[13:23:13.595]                 args <- list()
[13:23:13.595]                 for (kk in seq_along(NAMES)) {
[13:23:13.595]                   name <- changed[[kk]]
[13:23:13.595]                   NAME <- NAMES[[kk]]
[13:23:13.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.595]                     next
[13:23:13.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.595]                 }
[13:23:13.595]                 NAMES <- toupper(added)
[13:23:13.595]                 for (kk in seq_along(NAMES)) {
[13:23:13.595]                   name <- added[[kk]]
[13:23:13.595]                   NAME <- NAMES[[kk]]
[13:23:13.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.595]                     next
[13:23:13.595]                   args[[name]] <- ""
[13:23:13.595]                 }
[13:23:13.595]                 NAMES <- toupper(removed)
[13:23:13.595]                 for (kk in seq_along(NAMES)) {
[13:23:13.595]                   name <- removed[[kk]]
[13:23:13.595]                   NAME <- NAMES[[kk]]
[13:23:13.595]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.595]                     next
[13:23:13.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.595]                 }
[13:23:13.595]                 if (length(args) > 0) 
[13:23:13.595]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.595]             }
[13:23:13.595]             else {
[13:23:13.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.595]             }
[13:23:13.595]             {
[13:23:13.595]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.595]                   0L) {
[13:23:13.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.595]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.595]                   base::options(opts)
[13:23:13.595]                 }
[13:23:13.595]                 {
[13:23:13.595]                   {
[13:23:13.595]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.595]                     NULL
[13:23:13.595]                   }
[13:23:13.595]                   options(future.plan = NULL)
[13:23:13.595]                   if (is.na(NA_character_)) 
[13:23:13.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.595]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.595]                     envir = parent.frame()) 
[13:23:13.595]                   {
[13:23:13.595]                     default_workers <- missing(workers)
[13:23:13.595]                     if (is.function(workers)) 
[13:23:13.595]                       workers <- workers()
[13:23:13.595]                     workers <- structure(as.integer(workers), 
[13:23:13.595]                       class = class(workers))
[13:23:13.595]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.595]                       1L)
[13:23:13.595]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.595]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.595]                       if (default_workers) 
[13:23:13.595]                         supportsMulticore(warn = TRUE)
[13:23:13.595]                       return(sequential(..., envir = envir))
[13:23:13.595]                     }
[13:23:13.595]                     oopts <- options(mc.cores = workers)
[13:23:13.595]                     on.exit(options(oopts))
[13:23:13.595]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.595]                       envir = envir)
[13:23:13.595]                     if (!future$lazy) 
[13:23:13.595]                       future <- run(future)
[13:23:13.595]                     invisible(future)
[13:23:13.595]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.595]                 }
[13:23:13.595]             }
[13:23:13.595]         }
[13:23:13.595]     })
[13:23:13.595]     if (TRUE) {
[13:23:13.595]         base::sink(type = "output", split = FALSE)
[13:23:13.595]         if (TRUE) {
[13:23:13.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.595]         }
[13:23:13.595]         else {
[13:23:13.595]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.595]         }
[13:23:13.595]         base::close(...future.stdout)
[13:23:13.595]         ...future.stdout <- NULL
[13:23:13.595]     }
[13:23:13.595]     ...future.result$conditions <- ...future.conditions
[13:23:13.595]     ...future.result$finished <- base::Sys.time()
[13:23:13.595]     ...future.result
[13:23:13.595] }
[13:23:13.598] assign_globals() ...
[13:23:13.598] List of 1
[13:23:13.598]  $ x: num [1:5] 1 1 2 2 2
[13:23:13.598]  - attr(*, "where")=List of 1
[13:23:13.598]   ..$ x:<environment: R_EmptyEnv> 
[13:23:13.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.598]  - attr(*, "resolved")= logi FALSE
[13:23:13.598]  - attr(*, "total_size")= num 96
[13:23:13.598]  - attr(*, "already-done")= logi TRUE
[13:23:13.602] - copied ‘x’ to environment
[13:23:13.602] assign_globals() ... done
[13:23:13.602] requestCore(): workers = 2
[13:23:13.604] MulticoreFuture started
[13:23:13.605] - Launch lazy future ... done
[13:23:13.605] run() for ‘MulticoreFuture’ ... done
[13:23:13.605] result() for MulticoreFuture ...
[13:23:13.606] plan(): Setting new future strategy stack:
[13:23:13.606] List of future strategies:
[13:23:13.606] 1. sequential:
[13:23:13.606]    - args: function (..., envir = parent.frame())
[13:23:13.606]    - tweaked: FALSE
[13:23:13.606]    - call: NULL
[13:23:13.607] plan(): nbrOfWorkers() = 1
[13:23:13.610] plan(): Setting new future strategy stack:
[13:23:13.610] List of future strategies:
[13:23:13.610] 1. multicore:
[13:23:13.610]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.610]    - tweaked: FALSE
[13:23:13.610]    - call: plan(strategy)
[13:23:13.616] plan(): nbrOfWorkers() = 2
[13:23:13.617] result() for MulticoreFuture ...
[13:23:13.617] result() for MulticoreFuture ... done
[13:23:13.618] result() for MulticoreFuture ... done
[13:23:13.618] result() for MulticoreFuture ...
[13:23:13.618] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:23:13.620] getGlobalsAndPackages() ...
[13:23:13.620] Searching for globals...
[13:23:13.626] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:23:13.626] Searching for globals ... DONE
[13:23:13.626] Resolving globals: FALSE
[13:23:13.627] 
[13:23:13.627] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.627] getGlobalsAndPackages() ... DONE
[13:23:13.628] run() for ‘Future’ ...
[13:23:13.628] - state: ‘created’
[13:23:13.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.633]   - Field: ‘label’
[13:23:13.633]   - Field: ‘local’
[13:23:13.634]   - Field: ‘owner’
[13:23:13.634]   - Field: ‘envir’
[13:23:13.634]   - Field: ‘workers’
[13:23:13.634]   - Field: ‘packages’
[13:23:13.634]   - Field: ‘gc’
[13:23:13.634]   - Field: ‘job’
[13:23:13.634]   - Field: ‘conditions’
[13:23:13.634]   - Field: ‘expr’
[13:23:13.635]   - Field: ‘uuid’
[13:23:13.635]   - Field: ‘seed’
[13:23:13.635]   - Field: ‘version’
[13:23:13.635]   - Field: ‘result’
[13:23:13.635]   - Field: ‘asynchronous’
[13:23:13.635]   - Field: ‘calls’
[13:23:13.635]   - Field: ‘globals’
[13:23:13.635]   - Field: ‘stdout’
[13:23:13.635]   - Field: ‘earlySignal’
[13:23:13.636]   - Field: ‘lazy’
[13:23:13.636]   - Field: ‘state’
[13:23:13.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.636] - Launch lazy future ...
[13:23:13.636] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.637] Packages needed by future strategies (n = 0): <none>
[13:23:13.637] {
[13:23:13.637]     {
[13:23:13.637]         {
[13:23:13.637]             ...future.startTime <- base::Sys.time()
[13:23:13.637]             {
[13:23:13.637]                 {
[13:23:13.637]                   {
[13:23:13.637]                     {
[13:23:13.637]                       {
[13:23:13.637]                         base::local({
[13:23:13.637]                           has_future <- base::requireNamespace("future", 
[13:23:13.637]                             quietly = TRUE)
[13:23:13.637]                           if (has_future) {
[13:23:13.637]                             ns <- base::getNamespace("future")
[13:23:13.637]                             version <- ns[[".package"]][["version"]]
[13:23:13.637]                             if (is.null(version)) 
[13:23:13.637]                               version <- utils::packageVersion("future")
[13:23:13.637]                           }
[13:23:13.637]                           else {
[13:23:13.637]                             version <- NULL
[13:23:13.637]                           }
[13:23:13.637]                           if (!has_future || version < "1.8.0") {
[13:23:13.637]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.637]                               "", base::R.version$version.string), 
[13:23:13.637]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.637]                                 base::R.version$platform, 8 * 
[13:23:13.637]                                   base::.Machine$sizeof.pointer), 
[13:23:13.637]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.637]                                 "release", "version")], collapse = " "), 
[13:23:13.637]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.637]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.637]                               info)
[13:23:13.637]                             info <- base::paste(info, collapse = "; ")
[13:23:13.637]                             if (!has_future) {
[13:23:13.637]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.637]                                 info)
[13:23:13.637]                             }
[13:23:13.637]                             else {
[13:23:13.637]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.637]                                 info, version)
[13:23:13.637]                             }
[13:23:13.637]                             base::stop(msg)
[13:23:13.637]                           }
[13:23:13.637]                         })
[13:23:13.637]                       }
[13:23:13.637]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.637]                       base::options(mc.cores = 1L)
[13:23:13.637]                     }
[13:23:13.637]                     base::local({
[13:23:13.637]                       for (pkg in c("stats", "datasets")) {
[13:23:13.637]                         base::loadNamespace(pkg)
[13:23:13.637]                         base::library(pkg, character.only = TRUE)
[13:23:13.637]                       }
[13:23:13.637]                     })
[13:23:13.637]                   }
[13:23:13.637]                   options(future.plan = NULL)
[13:23:13.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.637]                 }
[13:23:13.637]                 ...future.workdir <- getwd()
[13:23:13.637]             }
[13:23:13.637]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.637]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.637]         }
[13:23:13.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.637]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.637]             base::names(...future.oldOptions))
[13:23:13.637]     }
[13:23:13.637]     if (FALSE) {
[13:23:13.637]     }
[13:23:13.637]     else {
[13:23:13.637]         if (TRUE) {
[13:23:13.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.637]                 open = "w")
[13:23:13.637]         }
[13:23:13.637]         else {
[13:23:13.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.637]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.637]         }
[13:23:13.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.637]             base::sink(type = "output", split = FALSE)
[13:23:13.637]             base::close(...future.stdout)
[13:23:13.637]         }, add = TRUE)
[13:23:13.637]     }
[13:23:13.637]     ...future.frame <- base::sys.nframe()
[13:23:13.637]     ...future.conditions <- base::list()
[13:23:13.637]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.637]     if (FALSE) {
[13:23:13.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.637]     }
[13:23:13.637]     ...future.result <- base::tryCatch({
[13:23:13.637]         base::withCallingHandlers({
[13:23:13.637]             ...future.value <- base::withVisible(base::local({
[13:23:13.637]                 withCallingHandlers({
[13:23:13.637]                   {
[13:23:13.637]                     lm(dist ~ . - 1, data = cars)
[13:23:13.637]                   }
[13:23:13.637]                 }, immediateCondition = function(cond) {
[13:23:13.637]                   save_rds <- function (object, pathname, ...) 
[13:23:13.637]                   {
[13:23:13.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.637]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.637]                         fi_tmp[["mtime"]])
[13:23:13.637]                     }
[13:23:13.637]                     tryCatch({
[13:23:13.637]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.637]                     }, error = function(ex) {
[13:23:13.637]                       msg <- conditionMessage(ex)
[13:23:13.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.637]                         fi_tmp[["mtime"]], msg)
[13:23:13.637]                       ex$message <- msg
[13:23:13.637]                       stop(ex)
[13:23:13.637]                     })
[13:23:13.637]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.637]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.637]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.637]                       fi <- file.info(pathname)
[13:23:13.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.637]                         fi[["size"]], fi[["mtime"]])
[13:23:13.637]                       stop(msg)
[13:23:13.637]                     }
[13:23:13.637]                     invisible(pathname)
[13:23:13.637]                   }
[13:23:13.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.637]                     rootPath = tempdir()) 
[13:23:13.637]                   {
[13:23:13.637]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.637]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.637]                       tmpdir = path, fileext = ".rds")
[13:23:13.637]                     save_rds(obj, file)
[13:23:13.637]                   }
[13:23:13.637]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.637]                   {
[13:23:13.637]                     inherits <- base::inherits
[13:23:13.637]                     invokeRestart <- base::invokeRestart
[13:23:13.637]                     is.null <- base::is.null
[13:23:13.637]                     muffled <- FALSE
[13:23:13.637]                     if (inherits(cond, "message")) {
[13:23:13.637]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.637]                       if (muffled) 
[13:23:13.637]                         invokeRestart("muffleMessage")
[13:23:13.637]                     }
[13:23:13.637]                     else if (inherits(cond, "warning")) {
[13:23:13.637]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.637]                       if (muffled) 
[13:23:13.637]                         invokeRestart("muffleWarning")
[13:23:13.637]                     }
[13:23:13.637]                     else if (inherits(cond, "condition")) {
[13:23:13.637]                       if (!is.null(pattern)) {
[13:23:13.637]                         computeRestarts <- base::computeRestarts
[13:23:13.637]                         grepl <- base::grepl
[13:23:13.637]                         restarts <- computeRestarts(cond)
[13:23:13.637]                         for (restart in restarts) {
[13:23:13.637]                           name <- restart$name
[13:23:13.637]                           if (is.null(name)) 
[13:23:13.637]                             next
[13:23:13.637]                           if (!grepl(pattern, name)) 
[13:23:13.637]                             next
[13:23:13.637]                           invokeRestart(restart)
[13:23:13.637]                           muffled <- TRUE
[13:23:13.637]                           break
[13:23:13.637]                         }
[13:23:13.637]                       }
[13:23:13.637]                     }
[13:23:13.637]                     invisible(muffled)
[13:23:13.637]                   }
[13:23:13.637]                   muffleCondition(cond)
[13:23:13.637]                 })
[13:23:13.637]             }))
[13:23:13.637]             future::FutureResult(value = ...future.value$value, 
[13:23:13.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.637]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.637]                     ...future.globalenv.names))
[13:23:13.637]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.637]         }, condition = base::local({
[13:23:13.637]             c <- base::c
[13:23:13.637]             inherits <- base::inherits
[13:23:13.637]             invokeRestart <- base::invokeRestart
[13:23:13.637]             length <- base::length
[13:23:13.637]             list <- base::list
[13:23:13.637]             seq.int <- base::seq.int
[13:23:13.637]             signalCondition <- base::signalCondition
[13:23:13.637]             sys.calls <- base::sys.calls
[13:23:13.637]             `[[` <- base::`[[`
[13:23:13.637]             `+` <- base::`+`
[13:23:13.637]             `<<-` <- base::`<<-`
[13:23:13.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.637]                   3L)]
[13:23:13.637]             }
[13:23:13.637]             function(cond) {
[13:23:13.637]                 is_error <- inherits(cond, "error")
[13:23:13.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.637]                   NULL)
[13:23:13.637]                 if (is_error) {
[13:23:13.637]                   sessionInformation <- function() {
[13:23:13.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.637]                       search = base::search(), system = base::Sys.info())
[13:23:13.637]                   }
[13:23:13.637]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.637]                     cond$call), session = sessionInformation(), 
[13:23:13.637]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.637]                   signalCondition(cond)
[13:23:13.637]                 }
[13:23:13.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.637]                 "immediateCondition"))) {
[13:23:13.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.637]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.637]                   if (TRUE && !signal) {
[13:23:13.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.637]                     {
[13:23:13.637]                       inherits <- base::inherits
[13:23:13.637]                       invokeRestart <- base::invokeRestart
[13:23:13.637]                       is.null <- base::is.null
[13:23:13.637]                       muffled <- FALSE
[13:23:13.637]                       if (inherits(cond, "message")) {
[13:23:13.637]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.637]                         if (muffled) 
[13:23:13.637]                           invokeRestart("muffleMessage")
[13:23:13.637]                       }
[13:23:13.637]                       else if (inherits(cond, "warning")) {
[13:23:13.637]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.637]                         if (muffled) 
[13:23:13.637]                           invokeRestart("muffleWarning")
[13:23:13.637]                       }
[13:23:13.637]                       else if (inherits(cond, "condition")) {
[13:23:13.637]                         if (!is.null(pattern)) {
[13:23:13.637]                           computeRestarts <- base::computeRestarts
[13:23:13.637]                           grepl <- base::grepl
[13:23:13.637]                           restarts <- computeRestarts(cond)
[13:23:13.637]                           for (restart in restarts) {
[13:23:13.637]                             name <- restart$name
[13:23:13.637]                             if (is.null(name)) 
[13:23:13.637]                               next
[13:23:13.637]                             if (!grepl(pattern, name)) 
[13:23:13.637]                               next
[13:23:13.637]                             invokeRestart(restart)
[13:23:13.637]                             muffled <- TRUE
[13:23:13.637]                             break
[13:23:13.637]                           }
[13:23:13.637]                         }
[13:23:13.637]                       }
[13:23:13.637]                       invisible(muffled)
[13:23:13.637]                     }
[13:23:13.637]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.637]                   }
[13:23:13.637]                 }
[13:23:13.637]                 else {
[13:23:13.637]                   if (TRUE) {
[13:23:13.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.637]                     {
[13:23:13.637]                       inherits <- base::inherits
[13:23:13.637]                       invokeRestart <- base::invokeRestart
[13:23:13.637]                       is.null <- base::is.null
[13:23:13.637]                       muffled <- FALSE
[13:23:13.637]                       if (inherits(cond, "message")) {
[13:23:13.637]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.637]                         if (muffled) 
[13:23:13.637]                           invokeRestart("muffleMessage")
[13:23:13.637]                       }
[13:23:13.637]                       else if (inherits(cond, "warning")) {
[13:23:13.637]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.637]                         if (muffled) 
[13:23:13.637]                           invokeRestart("muffleWarning")
[13:23:13.637]                       }
[13:23:13.637]                       else if (inherits(cond, "condition")) {
[13:23:13.637]                         if (!is.null(pattern)) {
[13:23:13.637]                           computeRestarts <- base::computeRestarts
[13:23:13.637]                           grepl <- base::grepl
[13:23:13.637]                           restarts <- computeRestarts(cond)
[13:23:13.637]                           for (restart in restarts) {
[13:23:13.637]                             name <- restart$name
[13:23:13.637]                             if (is.null(name)) 
[13:23:13.637]                               next
[13:23:13.637]                             if (!grepl(pattern, name)) 
[13:23:13.637]                               next
[13:23:13.637]                             invokeRestart(restart)
[13:23:13.637]                             muffled <- TRUE
[13:23:13.637]                             break
[13:23:13.637]                           }
[13:23:13.637]                         }
[13:23:13.637]                       }
[13:23:13.637]                       invisible(muffled)
[13:23:13.637]                     }
[13:23:13.637]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.637]                   }
[13:23:13.637]                 }
[13:23:13.637]             }
[13:23:13.637]         }))
[13:23:13.637]     }, error = function(ex) {
[13:23:13.637]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.637]                 ...future.rng), started = ...future.startTime, 
[13:23:13.637]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.637]             version = "1.8"), class = "FutureResult")
[13:23:13.637]     }, finally = {
[13:23:13.637]         if (!identical(...future.workdir, getwd())) 
[13:23:13.637]             setwd(...future.workdir)
[13:23:13.637]         {
[13:23:13.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.637]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.637]             }
[13:23:13.637]             base::options(...future.oldOptions)
[13:23:13.637]             if (.Platform$OS.type == "windows") {
[13:23:13.637]                 old_names <- names(...future.oldEnvVars)
[13:23:13.637]                 envs <- base::Sys.getenv()
[13:23:13.637]                 names <- names(envs)
[13:23:13.637]                 common <- intersect(names, old_names)
[13:23:13.637]                 added <- setdiff(names, old_names)
[13:23:13.637]                 removed <- setdiff(old_names, names)
[13:23:13.637]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.637]                   envs[common]]
[13:23:13.637]                 NAMES <- toupper(changed)
[13:23:13.637]                 args <- list()
[13:23:13.637]                 for (kk in seq_along(NAMES)) {
[13:23:13.637]                   name <- changed[[kk]]
[13:23:13.637]                   NAME <- NAMES[[kk]]
[13:23:13.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.637]                     next
[13:23:13.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.637]                 }
[13:23:13.637]                 NAMES <- toupper(added)
[13:23:13.637]                 for (kk in seq_along(NAMES)) {
[13:23:13.637]                   name <- added[[kk]]
[13:23:13.637]                   NAME <- NAMES[[kk]]
[13:23:13.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.637]                     next
[13:23:13.637]                   args[[name]] <- ""
[13:23:13.637]                 }
[13:23:13.637]                 NAMES <- toupper(removed)
[13:23:13.637]                 for (kk in seq_along(NAMES)) {
[13:23:13.637]                   name <- removed[[kk]]
[13:23:13.637]                   NAME <- NAMES[[kk]]
[13:23:13.637]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.637]                     next
[13:23:13.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.637]                 }
[13:23:13.637]                 if (length(args) > 0) 
[13:23:13.637]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.637]             }
[13:23:13.637]             else {
[13:23:13.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.637]             }
[13:23:13.637]             {
[13:23:13.637]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.637]                   0L) {
[13:23:13.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.637]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.637]                   base::options(opts)
[13:23:13.637]                 }
[13:23:13.637]                 {
[13:23:13.637]                   {
[13:23:13.637]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.637]                     NULL
[13:23:13.637]                   }
[13:23:13.637]                   options(future.plan = NULL)
[13:23:13.637]                   if (is.na(NA_character_)) 
[13:23:13.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.637]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.637]                     envir = parent.frame()) 
[13:23:13.637]                   {
[13:23:13.637]                     default_workers <- missing(workers)
[13:23:13.637]                     if (is.function(workers)) 
[13:23:13.637]                       workers <- workers()
[13:23:13.637]                     workers <- structure(as.integer(workers), 
[13:23:13.637]                       class = class(workers))
[13:23:13.637]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.637]                       1L)
[13:23:13.637]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.637]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.637]                       if (default_workers) 
[13:23:13.637]                         supportsMulticore(warn = TRUE)
[13:23:13.637]                       return(sequential(..., envir = envir))
[13:23:13.637]                     }
[13:23:13.637]                     oopts <- options(mc.cores = workers)
[13:23:13.637]                     on.exit(options(oopts))
[13:23:13.637]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.637]                       envir = envir)
[13:23:13.637]                     if (!future$lazy) 
[13:23:13.637]                       future <- run(future)
[13:23:13.637]                     invisible(future)
[13:23:13.637]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.637]                 }
[13:23:13.637]             }
[13:23:13.637]         }
[13:23:13.637]     })
[13:23:13.637]     if (TRUE) {
[13:23:13.637]         base::sink(type = "output", split = FALSE)
[13:23:13.637]         if (TRUE) {
[13:23:13.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.637]         }
[13:23:13.637]         else {
[13:23:13.637]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.637]         }
[13:23:13.637]         base::close(...future.stdout)
[13:23:13.637]         ...future.stdout <- NULL
[13:23:13.637]     }
[13:23:13.637]     ...future.result$conditions <- ...future.conditions
[13:23:13.637]     ...future.result$finished <- base::Sys.time()
[13:23:13.637]     ...future.result
[13:23:13.637] }
[13:23:13.640] requestCore(): workers = 2
[13:23:13.642] MulticoreFuture started
[13:23:13.643] - Launch lazy future ... done
[13:23:13.643] run() for ‘MulticoreFuture’ ... done
[13:23:13.643] result() for MulticoreFuture ...
[13:23:13.644] plan(): Setting new future strategy stack:
[13:23:13.645] List of future strategies:
[13:23:13.645] 1. sequential:
[13:23:13.645]    - args: function (..., envir = parent.frame())
[13:23:13.645]    - tweaked: FALSE
[13:23:13.645]    - call: NULL
[13:23:13.645] plan(): nbrOfWorkers() = 1
[13:23:13.649] plan(): Setting new future strategy stack:
[13:23:13.649] List of future strategies:
[13:23:13.649] 1. multicore:
[13:23:13.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.649]    - tweaked: FALSE
[13:23:13.649]    - call: plan(strategy)
[13:23:13.655] plan(): nbrOfWorkers() = 2
[13:23:13.657] result() for MulticoreFuture ...
[13:23:13.657] result() for MulticoreFuture ... done
[13:23:13.657] result() for MulticoreFuture ... done
[13:23:13.658] result() for MulticoreFuture ...
[13:23:13.658] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:23:13.661] getGlobalsAndPackages() ...
[13:23:13.662] Searching for globals...
[13:23:13.664] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:23:13.664] Searching for globals ... DONE
[13:23:13.664] Resolving globals: FALSE
[13:23:13.665] 
[13:23:13.665] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.665] getGlobalsAndPackages() ... DONE
[13:23:13.666] run() for ‘Future’ ...
[13:23:13.666] - state: ‘created’
[13:23:13.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.670] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.671]   - Field: ‘label’
[13:23:13.671]   - Field: ‘local’
[13:23:13.671]   - Field: ‘owner’
[13:23:13.671]   - Field: ‘envir’
[13:23:13.671]   - Field: ‘workers’
[13:23:13.671]   - Field: ‘packages’
[13:23:13.672]   - Field: ‘gc’
[13:23:13.672]   - Field: ‘job’
[13:23:13.672]   - Field: ‘conditions’
[13:23:13.672]   - Field: ‘expr’
[13:23:13.672]   - Field: ‘uuid’
[13:23:13.672]   - Field: ‘seed’
[13:23:13.672]   - Field: ‘version’
[13:23:13.672]   - Field: ‘result’
[13:23:13.673]   - Field: ‘asynchronous’
[13:23:13.673]   - Field: ‘calls’
[13:23:13.673]   - Field: ‘globals’
[13:23:13.673]   - Field: ‘stdout’
[13:23:13.673]   - Field: ‘earlySignal’
[13:23:13.673]   - Field: ‘lazy’
[13:23:13.673]   - Field: ‘state’
[13:23:13.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.674] - Launch lazy future ...
[13:23:13.674] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.715] Packages needed by future strategies (n = 0): <none>
[13:23:13.716] {
[13:23:13.716]     {
[13:23:13.716]         {
[13:23:13.716]             ...future.startTime <- base::Sys.time()
[13:23:13.716]             {
[13:23:13.716]                 {
[13:23:13.716]                   {
[13:23:13.716]                     {
[13:23:13.716]                       {
[13:23:13.716]                         base::local({
[13:23:13.716]                           has_future <- base::requireNamespace("future", 
[13:23:13.716]                             quietly = TRUE)
[13:23:13.716]                           if (has_future) {
[13:23:13.716]                             ns <- base::getNamespace("future")
[13:23:13.716]                             version <- ns[[".package"]][["version"]]
[13:23:13.716]                             if (is.null(version)) 
[13:23:13.716]                               version <- utils::packageVersion("future")
[13:23:13.716]                           }
[13:23:13.716]                           else {
[13:23:13.716]                             version <- NULL
[13:23:13.716]                           }
[13:23:13.716]                           if (!has_future || version < "1.8.0") {
[13:23:13.716]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.716]                               "", base::R.version$version.string), 
[13:23:13.716]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.716]                                 base::R.version$platform, 8 * 
[13:23:13.716]                                   base::.Machine$sizeof.pointer), 
[13:23:13.716]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.716]                                 "release", "version")], collapse = " "), 
[13:23:13.716]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.716]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.716]                               info)
[13:23:13.716]                             info <- base::paste(info, collapse = "; ")
[13:23:13.716]                             if (!has_future) {
[13:23:13.716]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.716]                                 info)
[13:23:13.716]                             }
[13:23:13.716]                             else {
[13:23:13.716]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.716]                                 info, version)
[13:23:13.716]                             }
[13:23:13.716]                             base::stop(msg)
[13:23:13.716]                           }
[13:23:13.716]                         })
[13:23:13.716]                       }
[13:23:13.716]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.716]                       base::options(mc.cores = 1L)
[13:23:13.716]                     }
[13:23:13.716]                     base::local({
[13:23:13.716]                       for (pkg in c("stats", "datasets")) {
[13:23:13.716]                         base::loadNamespace(pkg)
[13:23:13.716]                         base::library(pkg, character.only = TRUE)
[13:23:13.716]                       }
[13:23:13.716]                     })
[13:23:13.716]                   }
[13:23:13.716]                   options(future.plan = NULL)
[13:23:13.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.716]                 }
[13:23:13.716]                 ...future.workdir <- getwd()
[13:23:13.716]             }
[13:23:13.716]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.716]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.716]         }
[13:23:13.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.716]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.716]             base::names(...future.oldOptions))
[13:23:13.716]     }
[13:23:13.716]     if (FALSE) {
[13:23:13.716]     }
[13:23:13.716]     else {
[13:23:13.716]         if (TRUE) {
[13:23:13.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.716]                 open = "w")
[13:23:13.716]         }
[13:23:13.716]         else {
[13:23:13.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.716]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.716]         }
[13:23:13.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.716]             base::sink(type = "output", split = FALSE)
[13:23:13.716]             base::close(...future.stdout)
[13:23:13.716]         }, add = TRUE)
[13:23:13.716]     }
[13:23:13.716]     ...future.frame <- base::sys.nframe()
[13:23:13.716]     ...future.conditions <- base::list()
[13:23:13.716]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.716]     if (FALSE) {
[13:23:13.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.716]     }
[13:23:13.716]     ...future.result <- base::tryCatch({
[13:23:13.716]         base::withCallingHandlers({
[13:23:13.716]             ...future.value <- base::withVisible(base::local({
[13:23:13.716]                 withCallingHandlers({
[13:23:13.716]                   {
[13:23:13.716]                     lm(dist ~ . + 0, data = cars)
[13:23:13.716]                   }
[13:23:13.716]                 }, immediateCondition = function(cond) {
[13:23:13.716]                   save_rds <- function (object, pathname, ...) 
[13:23:13.716]                   {
[13:23:13.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.716]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.716]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.716]                         fi_tmp[["mtime"]])
[13:23:13.716]                     }
[13:23:13.716]                     tryCatch({
[13:23:13.716]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.716]                     }, error = function(ex) {
[13:23:13.716]                       msg <- conditionMessage(ex)
[13:23:13.716]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.716]                         fi_tmp[["mtime"]], msg)
[13:23:13.716]                       ex$message <- msg
[13:23:13.716]                       stop(ex)
[13:23:13.716]                     })
[13:23:13.716]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.716]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.716]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.716]                       fi <- file.info(pathname)
[13:23:13.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.716]                         fi[["size"]], fi[["mtime"]])
[13:23:13.716]                       stop(msg)
[13:23:13.716]                     }
[13:23:13.716]                     invisible(pathname)
[13:23:13.716]                   }
[13:23:13.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.716]                     rootPath = tempdir()) 
[13:23:13.716]                   {
[13:23:13.716]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.716]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.716]                       tmpdir = path, fileext = ".rds")
[13:23:13.716]                     save_rds(obj, file)
[13:23:13.716]                   }
[13:23:13.716]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.716]                   {
[13:23:13.716]                     inherits <- base::inherits
[13:23:13.716]                     invokeRestart <- base::invokeRestart
[13:23:13.716]                     is.null <- base::is.null
[13:23:13.716]                     muffled <- FALSE
[13:23:13.716]                     if (inherits(cond, "message")) {
[13:23:13.716]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.716]                       if (muffled) 
[13:23:13.716]                         invokeRestart("muffleMessage")
[13:23:13.716]                     }
[13:23:13.716]                     else if (inherits(cond, "warning")) {
[13:23:13.716]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.716]                       if (muffled) 
[13:23:13.716]                         invokeRestart("muffleWarning")
[13:23:13.716]                     }
[13:23:13.716]                     else if (inherits(cond, "condition")) {
[13:23:13.716]                       if (!is.null(pattern)) {
[13:23:13.716]                         computeRestarts <- base::computeRestarts
[13:23:13.716]                         grepl <- base::grepl
[13:23:13.716]                         restarts <- computeRestarts(cond)
[13:23:13.716]                         for (restart in restarts) {
[13:23:13.716]                           name <- restart$name
[13:23:13.716]                           if (is.null(name)) 
[13:23:13.716]                             next
[13:23:13.716]                           if (!grepl(pattern, name)) 
[13:23:13.716]                             next
[13:23:13.716]                           invokeRestart(restart)
[13:23:13.716]                           muffled <- TRUE
[13:23:13.716]                           break
[13:23:13.716]                         }
[13:23:13.716]                       }
[13:23:13.716]                     }
[13:23:13.716]                     invisible(muffled)
[13:23:13.716]                   }
[13:23:13.716]                   muffleCondition(cond)
[13:23:13.716]                 })
[13:23:13.716]             }))
[13:23:13.716]             future::FutureResult(value = ...future.value$value, 
[13:23:13.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.716]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.716]                     ...future.globalenv.names))
[13:23:13.716]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.716]         }, condition = base::local({
[13:23:13.716]             c <- base::c
[13:23:13.716]             inherits <- base::inherits
[13:23:13.716]             invokeRestart <- base::invokeRestart
[13:23:13.716]             length <- base::length
[13:23:13.716]             list <- base::list
[13:23:13.716]             seq.int <- base::seq.int
[13:23:13.716]             signalCondition <- base::signalCondition
[13:23:13.716]             sys.calls <- base::sys.calls
[13:23:13.716]             `[[` <- base::`[[`
[13:23:13.716]             `+` <- base::`+`
[13:23:13.716]             `<<-` <- base::`<<-`
[13:23:13.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.716]                   3L)]
[13:23:13.716]             }
[13:23:13.716]             function(cond) {
[13:23:13.716]                 is_error <- inherits(cond, "error")
[13:23:13.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.716]                   NULL)
[13:23:13.716]                 if (is_error) {
[13:23:13.716]                   sessionInformation <- function() {
[13:23:13.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.716]                       search = base::search(), system = base::Sys.info())
[13:23:13.716]                   }
[13:23:13.716]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.716]                     cond$call), session = sessionInformation(), 
[13:23:13.716]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.716]                   signalCondition(cond)
[13:23:13.716]                 }
[13:23:13.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.716]                 "immediateCondition"))) {
[13:23:13.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.716]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.716]                   if (TRUE && !signal) {
[13:23:13.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.716]                     {
[13:23:13.716]                       inherits <- base::inherits
[13:23:13.716]                       invokeRestart <- base::invokeRestart
[13:23:13.716]                       is.null <- base::is.null
[13:23:13.716]                       muffled <- FALSE
[13:23:13.716]                       if (inherits(cond, "message")) {
[13:23:13.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.716]                         if (muffled) 
[13:23:13.716]                           invokeRestart("muffleMessage")
[13:23:13.716]                       }
[13:23:13.716]                       else if (inherits(cond, "warning")) {
[13:23:13.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.716]                         if (muffled) 
[13:23:13.716]                           invokeRestart("muffleWarning")
[13:23:13.716]                       }
[13:23:13.716]                       else if (inherits(cond, "condition")) {
[13:23:13.716]                         if (!is.null(pattern)) {
[13:23:13.716]                           computeRestarts <- base::computeRestarts
[13:23:13.716]                           grepl <- base::grepl
[13:23:13.716]                           restarts <- computeRestarts(cond)
[13:23:13.716]                           for (restart in restarts) {
[13:23:13.716]                             name <- restart$name
[13:23:13.716]                             if (is.null(name)) 
[13:23:13.716]                               next
[13:23:13.716]                             if (!grepl(pattern, name)) 
[13:23:13.716]                               next
[13:23:13.716]                             invokeRestart(restart)
[13:23:13.716]                             muffled <- TRUE
[13:23:13.716]                             break
[13:23:13.716]                           }
[13:23:13.716]                         }
[13:23:13.716]                       }
[13:23:13.716]                       invisible(muffled)
[13:23:13.716]                     }
[13:23:13.716]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.716]                   }
[13:23:13.716]                 }
[13:23:13.716]                 else {
[13:23:13.716]                   if (TRUE) {
[13:23:13.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.716]                     {
[13:23:13.716]                       inherits <- base::inherits
[13:23:13.716]                       invokeRestart <- base::invokeRestart
[13:23:13.716]                       is.null <- base::is.null
[13:23:13.716]                       muffled <- FALSE
[13:23:13.716]                       if (inherits(cond, "message")) {
[13:23:13.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.716]                         if (muffled) 
[13:23:13.716]                           invokeRestart("muffleMessage")
[13:23:13.716]                       }
[13:23:13.716]                       else if (inherits(cond, "warning")) {
[13:23:13.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.716]                         if (muffled) 
[13:23:13.716]                           invokeRestart("muffleWarning")
[13:23:13.716]                       }
[13:23:13.716]                       else if (inherits(cond, "condition")) {
[13:23:13.716]                         if (!is.null(pattern)) {
[13:23:13.716]                           computeRestarts <- base::computeRestarts
[13:23:13.716]                           grepl <- base::grepl
[13:23:13.716]                           restarts <- computeRestarts(cond)
[13:23:13.716]                           for (restart in restarts) {
[13:23:13.716]                             name <- restart$name
[13:23:13.716]                             if (is.null(name)) 
[13:23:13.716]                               next
[13:23:13.716]                             if (!grepl(pattern, name)) 
[13:23:13.716]                               next
[13:23:13.716]                             invokeRestart(restart)
[13:23:13.716]                             muffled <- TRUE
[13:23:13.716]                             break
[13:23:13.716]                           }
[13:23:13.716]                         }
[13:23:13.716]                       }
[13:23:13.716]                       invisible(muffled)
[13:23:13.716]                     }
[13:23:13.716]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.716]                   }
[13:23:13.716]                 }
[13:23:13.716]             }
[13:23:13.716]         }))
[13:23:13.716]     }, error = function(ex) {
[13:23:13.716]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.716]                 ...future.rng), started = ...future.startTime, 
[13:23:13.716]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.716]             version = "1.8"), class = "FutureResult")
[13:23:13.716]     }, finally = {
[13:23:13.716]         if (!identical(...future.workdir, getwd())) 
[13:23:13.716]             setwd(...future.workdir)
[13:23:13.716]         {
[13:23:13.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.716]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.716]             }
[13:23:13.716]             base::options(...future.oldOptions)
[13:23:13.716]             if (.Platform$OS.type == "windows") {
[13:23:13.716]                 old_names <- names(...future.oldEnvVars)
[13:23:13.716]                 envs <- base::Sys.getenv()
[13:23:13.716]                 names <- names(envs)
[13:23:13.716]                 common <- intersect(names, old_names)
[13:23:13.716]                 added <- setdiff(names, old_names)
[13:23:13.716]                 removed <- setdiff(old_names, names)
[13:23:13.716]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.716]                   envs[common]]
[13:23:13.716]                 NAMES <- toupper(changed)
[13:23:13.716]                 args <- list()
[13:23:13.716]                 for (kk in seq_along(NAMES)) {
[13:23:13.716]                   name <- changed[[kk]]
[13:23:13.716]                   NAME <- NAMES[[kk]]
[13:23:13.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.716]                     next
[13:23:13.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.716]                 }
[13:23:13.716]                 NAMES <- toupper(added)
[13:23:13.716]                 for (kk in seq_along(NAMES)) {
[13:23:13.716]                   name <- added[[kk]]
[13:23:13.716]                   NAME <- NAMES[[kk]]
[13:23:13.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.716]                     next
[13:23:13.716]                   args[[name]] <- ""
[13:23:13.716]                 }
[13:23:13.716]                 NAMES <- toupper(removed)
[13:23:13.716]                 for (kk in seq_along(NAMES)) {
[13:23:13.716]                   name <- removed[[kk]]
[13:23:13.716]                   NAME <- NAMES[[kk]]
[13:23:13.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.716]                     next
[13:23:13.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.716]                 }
[13:23:13.716]                 if (length(args) > 0) 
[13:23:13.716]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.716]             }
[13:23:13.716]             else {
[13:23:13.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.716]             }
[13:23:13.716]             {
[13:23:13.716]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.716]                   0L) {
[13:23:13.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.716]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.716]                   base::options(opts)
[13:23:13.716]                 }
[13:23:13.716]                 {
[13:23:13.716]                   {
[13:23:13.716]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.716]                     NULL
[13:23:13.716]                   }
[13:23:13.716]                   options(future.plan = NULL)
[13:23:13.716]                   if (is.na(NA_character_)) 
[13:23:13.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.716]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.716]                     envir = parent.frame()) 
[13:23:13.716]                   {
[13:23:13.716]                     default_workers <- missing(workers)
[13:23:13.716]                     if (is.function(workers)) 
[13:23:13.716]                       workers <- workers()
[13:23:13.716]                     workers <- structure(as.integer(workers), 
[13:23:13.716]                       class = class(workers))
[13:23:13.716]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.716]                       1L)
[13:23:13.716]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.716]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.716]                       if (default_workers) 
[13:23:13.716]                         supportsMulticore(warn = TRUE)
[13:23:13.716]                       return(sequential(..., envir = envir))
[13:23:13.716]                     }
[13:23:13.716]                     oopts <- options(mc.cores = workers)
[13:23:13.716]                     on.exit(options(oopts))
[13:23:13.716]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.716]                       envir = envir)
[13:23:13.716]                     if (!future$lazy) 
[13:23:13.716]                       future <- run(future)
[13:23:13.716]                     invisible(future)
[13:23:13.716]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.716]                 }
[13:23:13.716]             }
[13:23:13.716]         }
[13:23:13.716]     })
[13:23:13.716]     if (TRUE) {
[13:23:13.716]         base::sink(type = "output", split = FALSE)
[13:23:13.716]         if (TRUE) {
[13:23:13.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.716]         }
[13:23:13.716]         else {
[13:23:13.716]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.716]         }
[13:23:13.716]         base::close(...future.stdout)
[13:23:13.716]         ...future.stdout <- NULL
[13:23:13.716]     }
[13:23:13.716]     ...future.result$conditions <- ...future.conditions
[13:23:13.716]     ...future.result$finished <- base::Sys.time()
[13:23:13.716]     ...future.result
[13:23:13.716] }
[13:23:13.718] requestCore(): workers = 2
[13:23:13.721] MulticoreFuture started
[13:23:13.722] - Launch lazy future ... done
[13:23:13.722] run() for ‘MulticoreFuture’ ... done
[13:23:13.723] result() for MulticoreFuture ...
[13:23:13.723] plan(): Setting new future strategy stack:
[13:23:13.724] List of future strategies:
[13:23:13.724] 1. sequential:
[13:23:13.724]    - args: function (..., envir = parent.frame())
[13:23:13.724]    - tweaked: FALSE
[13:23:13.724]    - call: NULL
[13:23:13.725] plan(): nbrOfWorkers() = 1
[13:23:13.730] plan(): Setting new future strategy stack:
[13:23:13.730] List of future strategies:
[13:23:13.730] 1. multicore:
[13:23:13.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.730]    - tweaked: FALSE
[13:23:13.730]    - call: plan(strategy)
[13:23:13.735] plan(): nbrOfWorkers() = 2
[13:23:13.738] result() for MulticoreFuture ...
[13:23:13.738] result() for MulticoreFuture ... done
[13:23:13.738] result() for MulticoreFuture ... done
[13:23:13.738] result() for MulticoreFuture ...
[13:23:13.739] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:23:13.743] getGlobalsAndPackages() ...
[13:23:13.743] Searching for globals...
[13:23:13.746] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:23:13.746] Searching for globals ... DONE
[13:23:13.746] Resolving globals: FALSE
[13:23:13.747] 
[13:23:13.747] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.747] getGlobalsAndPackages() ... DONE
[13:23:13.747] run() for ‘Future’ ...
[13:23:13.747] - state: ‘created’
[13:23:13.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.752] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.752]   - Field: ‘label’
[13:23:13.752]   - Field: ‘local’
[13:23:13.753]   - Field: ‘owner’
[13:23:13.753]   - Field: ‘envir’
[13:23:13.753]   - Field: ‘workers’
[13:23:13.753]   - Field: ‘packages’
[13:23:13.753]   - Field: ‘gc’
[13:23:13.753]   - Field: ‘job’
[13:23:13.753]   - Field: ‘conditions’
[13:23:13.753]   - Field: ‘expr’
[13:23:13.754]   - Field: ‘uuid’
[13:23:13.754]   - Field: ‘seed’
[13:23:13.754]   - Field: ‘version’
[13:23:13.754]   - Field: ‘result’
[13:23:13.754]   - Field: ‘asynchronous’
[13:23:13.754]   - Field: ‘calls’
[13:23:13.754]   - Field: ‘globals’
[13:23:13.754]   - Field: ‘stdout’
[13:23:13.754]   - Field: ‘earlySignal’
[13:23:13.755]   - Field: ‘lazy’
[13:23:13.755]   - Field: ‘state’
[13:23:13.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.755] - Launch lazy future ...
[13:23:13.755] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.755] Packages needed by future strategies (n = 0): <none>
[13:23:13.756] {
[13:23:13.756]     {
[13:23:13.756]         {
[13:23:13.756]             ...future.startTime <- base::Sys.time()
[13:23:13.756]             {
[13:23:13.756]                 {
[13:23:13.756]                   {
[13:23:13.756]                     {
[13:23:13.756]                       {
[13:23:13.756]                         base::local({
[13:23:13.756]                           has_future <- base::requireNamespace("future", 
[13:23:13.756]                             quietly = TRUE)
[13:23:13.756]                           if (has_future) {
[13:23:13.756]                             ns <- base::getNamespace("future")
[13:23:13.756]                             version <- ns[[".package"]][["version"]]
[13:23:13.756]                             if (is.null(version)) 
[13:23:13.756]                               version <- utils::packageVersion("future")
[13:23:13.756]                           }
[13:23:13.756]                           else {
[13:23:13.756]                             version <- NULL
[13:23:13.756]                           }
[13:23:13.756]                           if (!has_future || version < "1.8.0") {
[13:23:13.756]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.756]                               "", base::R.version$version.string), 
[13:23:13.756]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.756]                                 base::R.version$platform, 8 * 
[13:23:13.756]                                   base::.Machine$sizeof.pointer), 
[13:23:13.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.756]                                 "release", "version")], collapse = " "), 
[13:23:13.756]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.756]                               info)
[13:23:13.756]                             info <- base::paste(info, collapse = "; ")
[13:23:13.756]                             if (!has_future) {
[13:23:13.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.756]                                 info)
[13:23:13.756]                             }
[13:23:13.756]                             else {
[13:23:13.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.756]                                 info, version)
[13:23:13.756]                             }
[13:23:13.756]                             base::stop(msg)
[13:23:13.756]                           }
[13:23:13.756]                         })
[13:23:13.756]                       }
[13:23:13.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.756]                       base::options(mc.cores = 1L)
[13:23:13.756]                     }
[13:23:13.756]                     base::local({
[13:23:13.756]                       for (pkg in c("stats", "datasets")) {
[13:23:13.756]                         base::loadNamespace(pkg)
[13:23:13.756]                         base::library(pkg, character.only = TRUE)
[13:23:13.756]                       }
[13:23:13.756]                     })
[13:23:13.756]                   }
[13:23:13.756]                   options(future.plan = NULL)
[13:23:13.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.756]                 }
[13:23:13.756]                 ...future.workdir <- getwd()
[13:23:13.756]             }
[13:23:13.756]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.756]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.756]         }
[13:23:13.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.756]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.756]             base::names(...future.oldOptions))
[13:23:13.756]     }
[13:23:13.756]     if (FALSE) {
[13:23:13.756]     }
[13:23:13.756]     else {
[13:23:13.756]         if (TRUE) {
[13:23:13.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.756]                 open = "w")
[13:23:13.756]         }
[13:23:13.756]         else {
[13:23:13.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.756]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.756]         }
[13:23:13.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.756]             base::sink(type = "output", split = FALSE)
[13:23:13.756]             base::close(...future.stdout)
[13:23:13.756]         }, add = TRUE)
[13:23:13.756]     }
[13:23:13.756]     ...future.frame <- base::sys.nframe()
[13:23:13.756]     ...future.conditions <- base::list()
[13:23:13.756]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.756]     if (FALSE) {
[13:23:13.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.756]     }
[13:23:13.756]     ...future.result <- base::tryCatch({
[13:23:13.756]         base::withCallingHandlers({
[13:23:13.756]             ...future.value <- base::withVisible(base::local({
[13:23:13.756]                 withCallingHandlers({
[13:23:13.756]                   {
[13:23:13.756]                     lm(dist ~ speed + speed^2, data = cars)
[13:23:13.756]                   }
[13:23:13.756]                 }, immediateCondition = function(cond) {
[13:23:13.756]                   save_rds <- function (object, pathname, ...) 
[13:23:13.756]                   {
[13:23:13.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.756]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.756]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.756]                         fi_tmp[["mtime"]])
[13:23:13.756]                     }
[13:23:13.756]                     tryCatch({
[13:23:13.756]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.756]                     }, error = function(ex) {
[13:23:13.756]                       msg <- conditionMessage(ex)
[13:23:13.756]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.756]                         fi_tmp[["mtime"]], msg)
[13:23:13.756]                       ex$message <- msg
[13:23:13.756]                       stop(ex)
[13:23:13.756]                     })
[13:23:13.756]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.756]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.756]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.756]                       fi <- file.info(pathname)
[13:23:13.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.756]                         fi[["size"]], fi[["mtime"]])
[13:23:13.756]                       stop(msg)
[13:23:13.756]                     }
[13:23:13.756]                     invisible(pathname)
[13:23:13.756]                   }
[13:23:13.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.756]                     rootPath = tempdir()) 
[13:23:13.756]                   {
[13:23:13.756]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.756]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.756]                       tmpdir = path, fileext = ".rds")
[13:23:13.756]                     save_rds(obj, file)
[13:23:13.756]                   }
[13:23:13.756]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.756]                   {
[13:23:13.756]                     inherits <- base::inherits
[13:23:13.756]                     invokeRestart <- base::invokeRestart
[13:23:13.756]                     is.null <- base::is.null
[13:23:13.756]                     muffled <- FALSE
[13:23:13.756]                     if (inherits(cond, "message")) {
[13:23:13.756]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.756]                       if (muffled) 
[13:23:13.756]                         invokeRestart("muffleMessage")
[13:23:13.756]                     }
[13:23:13.756]                     else if (inherits(cond, "warning")) {
[13:23:13.756]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.756]                       if (muffled) 
[13:23:13.756]                         invokeRestart("muffleWarning")
[13:23:13.756]                     }
[13:23:13.756]                     else if (inherits(cond, "condition")) {
[13:23:13.756]                       if (!is.null(pattern)) {
[13:23:13.756]                         computeRestarts <- base::computeRestarts
[13:23:13.756]                         grepl <- base::grepl
[13:23:13.756]                         restarts <- computeRestarts(cond)
[13:23:13.756]                         for (restart in restarts) {
[13:23:13.756]                           name <- restart$name
[13:23:13.756]                           if (is.null(name)) 
[13:23:13.756]                             next
[13:23:13.756]                           if (!grepl(pattern, name)) 
[13:23:13.756]                             next
[13:23:13.756]                           invokeRestart(restart)
[13:23:13.756]                           muffled <- TRUE
[13:23:13.756]                           break
[13:23:13.756]                         }
[13:23:13.756]                       }
[13:23:13.756]                     }
[13:23:13.756]                     invisible(muffled)
[13:23:13.756]                   }
[13:23:13.756]                   muffleCondition(cond)
[13:23:13.756]                 })
[13:23:13.756]             }))
[13:23:13.756]             future::FutureResult(value = ...future.value$value, 
[13:23:13.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.756]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.756]                     ...future.globalenv.names))
[13:23:13.756]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.756]         }, condition = base::local({
[13:23:13.756]             c <- base::c
[13:23:13.756]             inherits <- base::inherits
[13:23:13.756]             invokeRestart <- base::invokeRestart
[13:23:13.756]             length <- base::length
[13:23:13.756]             list <- base::list
[13:23:13.756]             seq.int <- base::seq.int
[13:23:13.756]             signalCondition <- base::signalCondition
[13:23:13.756]             sys.calls <- base::sys.calls
[13:23:13.756]             `[[` <- base::`[[`
[13:23:13.756]             `+` <- base::`+`
[13:23:13.756]             `<<-` <- base::`<<-`
[13:23:13.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.756]                   3L)]
[13:23:13.756]             }
[13:23:13.756]             function(cond) {
[13:23:13.756]                 is_error <- inherits(cond, "error")
[13:23:13.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.756]                   NULL)
[13:23:13.756]                 if (is_error) {
[13:23:13.756]                   sessionInformation <- function() {
[13:23:13.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.756]                       search = base::search(), system = base::Sys.info())
[13:23:13.756]                   }
[13:23:13.756]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.756]                     cond$call), session = sessionInformation(), 
[13:23:13.756]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.756]                   signalCondition(cond)
[13:23:13.756]                 }
[13:23:13.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.756]                 "immediateCondition"))) {
[13:23:13.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.756]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.756]                   if (TRUE && !signal) {
[13:23:13.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.756]                     {
[13:23:13.756]                       inherits <- base::inherits
[13:23:13.756]                       invokeRestart <- base::invokeRestart
[13:23:13.756]                       is.null <- base::is.null
[13:23:13.756]                       muffled <- FALSE
[13:23:13.756]                       if (inherits(cond, "message")) {
[13:23:13.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.756]                         if (muffled) 
[13:23:13.756]                           invokeRestart("muffleMessage")
[13:23:13.756]                       }
[13:23:13.756]                       else if (inherits(cond, "warning")) {
[13:23:13.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.756]                         if (muffled) 
[13:23:13.756]                           invokeRestart("muffleWarning")
[13:23:13.756]                       }
[13:23:13.756]                       else if (inherits(cond, "condition")) {
[13:23:13.756]                         if (!is.null(pattern)) {
[13:23:13.756]                           computeRestarts <- base::computeRestarts
[13:23:13.756]                           grepl <- base::grepl
[13:23:13.756]                           restarts <- computeRestarts(cond)
[13:23:13.756]                           for (restart in restarts) {
[13:23:13.756]                             name <- restart$name
[13:23:13.756]                             if (is.null(name)) 
[13:23:13.756]                               next
[13:23:13.756]                             if (!grepl(pattern, name)) 
[13:23:13.756]                               next
[13:23:13.756]                             invokeRestart(restart)
[13:23:13.756]                             muffled <- TRUE
[13:23:13.756]                             break
[13:23:13.756]                           }
[13:23:13.756]                         }
[13:23:13.756]                       }
[13:23:13.756]                       invisible(muffled)
[13:23:13.756]                     }
[13:23:13.756]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.756]                   }
[13:23:13.756]                 }
[13:23:13.756]                 else {
[13:23:13.756]                   if (TRUE) {
[13:23:13.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.756]                     {
[13:23:13.756]                       inherits <- base::inherits
[13:23:13.756]                       invokeRestart <- base::invokeRestart
[13:23:13.756]                       is.null <- base::is.null
[13:23:13.756]                       muffled <- FALSE
[13:23:13.756]                       if (inherits(cond, "message")) {
[13:23:13.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.756]                         if (muffled) 
[13:23:13.756]                           invokeRestart("muffleMessage")
[13:23:13.756]                       }
[13:23:13.756]                       else if (inherits(cond, "warning")) {
[13:23:13.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.756]                         if (muffled) 
[13:23:13.756]                           invokeRestart("muffleWarning")
[13:23:13.756]                       }
[13:23:13.756]                       else if (inherits(cond, "condition")) {
[13:23:13.756]                         if (!is.null(pattern)) {
[13:23:13.756]                           computeRestarts <- base::computeRestarts
[13:23:13.756]                           grepl <- base::grepl
[13:23:13.756]                           restarts <- computeRestarts(cond)
[13:23:13.756]                           for (restart in restarts) {
[13:23:13.756]                             name <- restart$name
[13:23:13.756]                             if (is.null(name)) 
[13:23:13.756]                               next
[13:23:13.756]                             if (!grepl(pattern, name)) 
[13:23:13.756]                               next
[13:23:13.756]                             invokeRestart(restart)
[13:23:13.756]                             muffled <- TRUE
[13:23:13.756]                             break
[13:23:13.756]                           }
[13:23:13.756]                         }
[13:23:13.756]                       }
[13:23:13.756]                       invisible(muffled)
[13:23:13.756]                     }
[13:23:13.756]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.756]                   }
[13:23:13.756]                 }
[13:23:13.756]             }
[13:23:13.756]         }))
[13:23:13.756]     }, error = function(ex) {
[13:23:13.756]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.756]                 ...future.rng), started = ...future.startTime, 
[13:23:13.756]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.756]             version = "1.8"), class = "FutureResult")
[13:23:13.756]     }, finally = {
[13:23:13.756]         if (!identical(...future.workdir, getwd())) 
[13:23:13.756]             setwd(...future.workdir)
[13:23:13.756]         {
[13:23:13.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.756]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.756]             }
[13:23:13.756]             base::options(...future.oldOptions)
[13:23:13.756]             if (.Platform$OS.type == "windows") {
[13:23:13.756]                 old_names <- names(...future.oldEnvVars)
[13:23:13.756]                 envs <- base::Sys.getenv()
[13:23:13.756]                 names <- names(envs)
[13:23:13.756]                 common <- intersect(names, old_names)
[13:23:13.756]                 added <- setdiff(names, old_names)
[13:23:13.756]                 removed <- setdiff(old_names, names)
[13:23:13.756]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.756]                   envs[common]]
[13:23:13.756]                 NAMES <- toupper(changed)
[13:23:13.756]                 args <- list()
[13:23:13.756]                 for (kk in seq_along(NAMES)) {
[13:23:13.756]                   name <- changed[[kk]]
[13:23:13.756]                   NAME <- NAMES[[kk]]
[13:23:13.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.756]                     next
[13:23:13.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.756]                 }
[13:23:13.756]                 NAMES <- toupper(added)
[13:23:13.756]                 for (kk in seq_along(NAMES)) {
[13:23:13.756]                   name <- added[[kk]]
[13:23:13.756]                   NAME <- NAMES[[kk]]
[13:23:13.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.756]                     next
[13:23:13.756]                   args[[name]] <- ""
[13:23:13.756]                 }
[13:23:13.756]                 NAMES <- toupper(removed)
[13:23:13.756]                 for (kk in seq_along(NAMES)) {
[13:23:13.756]                   name <- removed[[kk]]
[13:23:13.756]                   NAME <- NAMES[[kk]]
[13:23:13.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.756]                     next
[13:23:13.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.756]                 }
[13:23:13.756]                 if (length(args) > 0) 
[13:23:13.756]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.756]             }
[13:23:13.756]             else {
[13:23:13.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.756]             }
[13:23:13.756]             {
[13:23:13.756]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.756]                   0L) {
[13:23:13.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.756]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.756]                   base::options(opts)
[13:23:13.756]                 }
[13:23:13.756]                 {
[13:23:13.756]                   {
[13:23:13.756]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.756]                     NULL
[13:23:13.756]                   }
[13:23:13.756]                   options(future.plan = NULL)
[13:23:13.756]                   if (is.na(NA_character_)) 
[13:23:13.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.756]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.756]                     envir = parent.frame()) 
[13:23:13.756]                   {
[13:23:13.756]                     default_workers <- missing(workers)
[13:23:13.756]                     if (is.function(workers)) 
[13:23:13.756]                       workers <- workers()
[13:23:13.756]                     workers <- structure(as.integer(workers), 
[13:23:13.756]                       class = class(workers))
[13:23:13.756]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.756]                       1L)
[13:23:13.756]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.756]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.756]                       if (default_workers) 
[13:23:13.756]                         supportsMulticore(warn = TRUE)
[13:23:13.756]                       return(sequential(..., envir = envir))
[13:23:13.756]                     }
[13:23:13.756]                     oopts <- options(mc.cores = workers)
[13:23:13.756]                     on.exit(options(oopts))
[13:23:13.756]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.756]                       envir = envir)
[13:23:13.756]                     if (!future$lazy) 
[13:23:13.756]                       future <- run(future)
[13:23:13.756]                     invisible(future)
[13:23:13.756]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.756]                 }
[13:23:13.756]             }
[13:23:13.756]         }
[13:23:13.756]     })
[13:23:13.756]     if (TRUE) {
[13:23:13.756]         base::sink(type = "output", split = FALSE)
[13:23:13.756]         if (TRUE) {
[13:23:13.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.756]         }
[13:23:13.756]         else {
[13:23:13.756]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.756]         }
[13:23:13.756]         base::close(...future.stdout)
[13:23:13.756]         ...future.stdout <- NULL
[13:23:13.756]     }
[13:23:13.756]     ...future.result$conditions <- ...future.conditions
[13:23:13.756]     ...future.result$finished <- base::Sys.time()
[13:23:13.756]     ...future.result
[13:23:13.756] }
[13:23:13.759] requestCore(): workers = 2
[13:23:13.762] MulticoreFuture started
[13:23:13.762] - Launch lazy future ... done
[13:23:13.762] run() for ‘MulticoreFuture’ ... done
[13:23:13.763] result() for MulticoreFuture ...
[13:23:13.763] plan(): Setting new future strategy stack:
[13:23:13.764] List of future strategies:
[13:23:13.764] 1. sequential:
[13:23:13.764]    - args: function (..., envir = parent.frame())
[13:23:13.764]    - tweaked: FALSE
[13:23:13.764]    - call: NULL
[13:23:13.765] plan(): nbrOfWorkers() = 1
[13:23:13.768] plan(): Setting new future strategy stack:
[13:23:13.769] List of future strategies:
[13:23:13.769] 1. multicore:
[13:23:13.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.769]    - tweaked: FALSE
[13:23:13.769]    - call: plan(strategy)
[13:23:13.774] plan(): nbrOfWorkers() = 2
[13:23:13.777] result() for MulticoreFuture ...
[13:23:13.777] result() for MulticoreFuture ... done
[13:23:13.777] result() for MulticoreFuture ... done
[13:23:13.777] result() for MulticoreFuture ...
[13:23:13.777] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:23:13.781] getGlobalsAndPackages() ...
[13:23:13.781] Searching for globals...
[13:23:13.784] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:23:13.785] Searching for globals ... DONE
[13:23:13.785] Resolving globals: FALSE
[13:23:13.786] 
[13:23:13.786] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.786] getGlobalsAndPackages() ... DONE
[13:23:13.786] run() for ‘Future’ ...
[13:23:13.786] - state: ‘created’
[13:23:13.787] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.795] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.795]   - Field: ‘label’
[13:23:13.795]   - Field: ‘local’
[13:23:13.795]   - Field: ‘owner’
[13:23:13.795]   - Field: ‘envir’
[13:23:13.796]   - Field: ‘workers’
[13:23:13.796]   - Field: ‘packages’
[13:23:13.796]   - Field: ‘gc’
[13:23:13.796]   - Field: ‘job’
[13:23:13.796]   - Field: ‘conditions’
[13:23:13.796]   - Field: ‘expr’
[13:23:13.796]   - Field: ‘uuid’
[13:23:13.797]   - Field: ‘seed’
[13:23:13.797]   - Field: ‘version’
[13:23:13.797]   - Field: ‘result’
[13:23:13.797]   - Field: ‘asynchronous’
[13:23:13.797]   - Field: ‘calls’
[13:23:13.797]   - Field: ‘globals’
[13:23:13.797]   - Field: ‘stdout’
[13:23:13.797]   - Field: ‘earlySignal’
[13:23:13.797]   - Field: ‘lazy’
[13:23:13.798]   - Field: ‘state’
[13:23:13.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.798] - Launch lazy future ...
[13:23:13.798] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.798] Packages needed by future strategies (n = 0): <none>
[13:23:13.799] {
[13:23:13.799]     {
[13:23:13.799]         {
[13:23:13.799]             ...future.startTime <- base::Sys.time()
[13:23:13.799]             {
[13:23:13.799]                 {
[13:23:13.799]                   {
[13:23:13.799]                     {
[13:23:13.799]                       {
[13:23:13.799]                         base::local({
[13:23:13.799]                           has_future <- base::requireNamespace("future", 
[13:23:13.799]                             quietly = TRUE)
[13:23:13.799]                           if (has_future) {
[13:23:13.799]                             ns <- base::getNamespace("future")
[13:23:13.799]                             version <- ns[[".package"]][["version"]]
[13:23:13.799]                             if (is.null(version)) 
[13:23:13.799]                               version <- utils::packageVersion("future")
[13:23:13.799]                           }
[13:23:13.799]                           else {
[13:23:13.799]                             version <- NULL
[13:23:13.799]                           }
[13:23:13.799]                           if (!has_future || version < "1.8.0") {
[13:23:13.799]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.799]                               "", base::R.version$version.string), 
[13:23:13.799]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.799]                                 base::R.version$platform, 8 * 
[13:23:13.799]                                   base::.Machine$sizeof.pointer), 
[13:23:13.799]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.799]                                 "release", "version")], collapse = " "), 
[13:23:13.799]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.799]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.799]                               info)
[13:23:13.799]                             info <- base::paste(info, collapse = "; ")
[13:23:13.799]                             if (!has_future) {
[13:23:13.799]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.799]                                 info)
[13:23:13.799]                             }
[13:23:13.799]                             else {
[13:23:13.799]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.799]                                 info, version)
[13:23:13.799]                             }
[13:23:13.799]                             base::stop(msg)
[13:23:13.799]                           }
[13:23:13.799]                         })
[13:23:13.799]                       }
[13:23:13.799]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.799]                       base::options(mc.cores = 1L)
[13:23:13.799]                     }
[13:23:13.799]                     base::local({
[13:23:13.799]                       for (pkg in c("stats", "datasets")) {
[13:23:13.799]                         base::loadNamespace(pkg)
[13:23:13.799]                         base::library(pkg, character.only = TRUE)
[13:23:13.799]                       }
[13:23:13.799]                     })
[13:23:13.799]                   }
[13:23:13.799]                   options(future.plan = NULL)
[13:23:13.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.799]                 }
[13:23:13.799]                 ...future.workdir <- getwd()
[13:23:13.799]             }
[13:23:13.799]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.799]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.799]         }
[13:23:13.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.799]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.799]             base::names(...future.oldOptions))
[13:23:13.799]     }
[13:23:13.799]     if (FALSE) {
[13:23:13.799]     }
[13:23:13.799]     else {
[13:23:13.799]         if (TRUE) {
[13:23:13.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.799]                 open = "w")
[13:23:13.799]         }
[13:23:13.799]         else {
[13:23:13.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.799]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.799]         }
[13:23:13.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.799]             base::sink(type = "output", split = FALSE)
[13:23:13.799]             base::close(...future.stdout)
[13:23:13.799]         }, add = TRUE)
[13:23:13.799]     }
[13:23:13.799]     ...future.frame <- base::sys.nframe()
[13:23:13.799]     ...future.conditions <- base::list()
[13:23:13.799]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.799]     if (FALSE) {
[13:23:13.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.799]     }
[13:23:13.799]     ...future.result <- base::tryCatch({
[13:23:13.799]         base::withCallingHandlers({
[13:23:13.799]             ...future.value <- base::withVisible(base::local({
[13:23:13.799]                 withCallingHandlers({
[13:23:13.799]                   {
[13:23:13.799]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:23:13.799]                   }
[13:23:13.799]                 }, immediateCondition = function(cond) {
[13:23:13.799]                   save_rds <- function (object, pathname, ...) 
[13:23:13.799]                   {
[13:23:13.799]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.799]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.799]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.799]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.799]                         fi_tmp[["mtime"]])
[13:23:13.799]                     }
[13:23:13.799]                     tryCatch({
[13:23:13.799]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.799]                     }, error = function(ex) {
[13:23:13.799]                       msg <- conditionMessage(ex)
[13:23:13.799]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.799]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.799]                         fi_tmp[["mtime"]], msg)
[13:23:13.799]                       ex$message <- msg
[13:23:13.799]                       stop(ex)
[13:23:13.799]                     })
[13:23:13.799]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.799]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.799]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.799]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.799]                       fi <- file.info(pathname)
[13:23:13.799]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.799]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.799]                         fi[["size"]], fi[["mtime"]])
[13:23:13.799]                       stop(msg)
[13:23:13.799]                     }
[13:23:13.799]                     invisible(pathname)
[13:23:13.799]                   }
[13:23:13.799]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.799]                     rootPath = tempdir()) 
[13:23:13.799]                   {
[13:23:13.799]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.799]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.799]                       tmpdir = path, fileext = ".rds")
[13:23:13.799]                     save_rds(obj, file)
[13:23:13.799]                   }
[13:23:13.799]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.799]                   {
[13:23:13.799]                     inherits <- base::inherits
[13:23:13.799]                     invokeRestart <- base::invokeRestart
[13:23:13.799]                     is.null <- base::is.null
[13:23:13.799]                     muffled <- FALSE
[13:23:13.799]                     if (inherits(cond, "message")) {
[13:23:13.799]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.799]                       if (muffled) 
[13:23:13.799]                         invokeRestart("muffleMessage")
[13:23:13.799]                     }
[13:23:13.799]                     else if (inherits(cond, "warning")) {
[13:23:13.799]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.799]                       if (muffled) 
[13:23:13.799]                         invokeRestart("muffleWarning")
[13:23:13.799]                     }
[13:23:13.799]                     else if (inherits(cond, "condition")) {
[13:23:13.799]                       if (!is.null(pattern)) {
[13:23:13.799]                         computeRestarts <- base::computeRestarts
[13:23:13.799]                         grepl <- base::grepl
[13:23:13.799]                         restarts <- computeRestarts(cond)
[13:23:13.799]                         for (restart in restarts) {
[13:23:13.799]                           name <- restart$name
[13:23:13.799]                           if (is.null(name)) 
[13:23:13.799]                             next
[13:23:13.799]                           if (!grepl(pattern, name)) 
[13:23:13.799]                             next
[13:23:13.799]                           invokeRestart(restart)
[13:23:13.799]                           muffled <- TRUE
[13:23:13.799]                           break
[13:23:13.799]                         }
[13:23:13.799]                       }
[13:23:13.799]                     }
[13:23:13.799]                     invisible(muffled)
[13:23:13.799]                   }
[13:23:13.799]                   muffleCondition(cond)
[13:23:13.799]                 })
[13:23:13.799]             }))
[13:23:13.799]             future::FutureResult(value = ...future.value$value, 
[13:23:13.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.799]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.799]                     ...future.globalenv.names))
[13:23:13.799]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.799]         }, condition = base::local({
[13:23:13.799]             c <- base::c
[13:23:13.799]             inherits <- base::inherits
[13:23:13.799]             invokeRestart <- base::invokeRestart
[13:23:13.799]             length <- base::length
[13:23:13.799]             list <- base::list
[13:23:13.799]             seq.int <- base::seq.int
[13:23:13.799]             signalCondition <- base::signalCondition
[13:23:13.799]             sys.calls <- base::sys.calls
[13:23:13.799]             `[[` <- base::`[[`
[13:23:13.799]             `+` <- base::`+`
[13:23:13.799]             `<<-` <- base::`<<-`
[13:23:13.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.799]                   3L)]
[13:23:13.799]             }
[13:23:13.799]             function(cond) {
[13:23:13.799]                 is_error <- inherits(cond, "error")
[13:23:13.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.799]                   NULL)
[13:23:13.799]                 if (is_error) {
[13:23:13.799]                   sessionInformation <- function() {
[13:23:13.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.799]                       search = base::search(), system = base::Sys.info())
[13:23:13.799]                   }
[13:23:13.799]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.799]                     cond$call), session = sessionInformation(), 
[13:23:13.799]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.799]                   signalCondition(cond)
[13:23:13.799]                 }
[13:23:13.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.799]                 "immediateCondition"))) {
[13:23:13.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.799]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.799]                   if (TRUE && !signal) {
[13:23:13.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.799]                     {
[13:23:13.799]                       inherits <- base::inherits
[13:23:13.799]                       invokeRestart <- base::invokeRestart
[13:23:13.799]                       is.null <- base::is.null
[13:23:13.799]                       muffled <- FALSE
[13:23:13.799]                       if (inherits(cond, "message")) {
[13:23:13.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.799]                         if (muffled) 
[13:23:13.799]                           invokeRestart("muffleMessage")
[13:23:13.799]                       }
[13:23:13.799]                       else if (inherits(cond, "warning")) {
[13:23:13.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.799]                         if (muffled) 
[13:23:13.799]                           invokeRestart("muffleWarning")
[13:23:13.799]                       }
[13:23:13.799]                       else if (inherits(cond, "condition")) {
[13:23:13.799]                         if (!is.null(pattern)) {
[13:23:13.799]                           computeRestarts <- base::computeRestarts
[13:23:13.799]                           grepl <- base::grepl
[13:23:13.799]                           restarts <- computeRestarts(cond)
[13:23:13.799]                           for (restart in restarts) {
[13:23:13.799]                             name <- restart$name
[13:23:13.799]                             if (is.null(name)) 
[13:23:13.799]                               next
[13:23:13.799]                             if (!grepl(pattern, name)) 
[13:23:13.799]                               next
[13:23:13.799]                             invokeRestart(restart)
[13:23:13.799]                             muffled <- TRUE
[13:23:13.799]                             break
[13:23:13.799]                           }
[13:23:13.799]                         }
[13:23:13.799]                       }
[13:23:13.799]                       invisible(muffled)
[13:23:13.799]                     }
[13:23:13.799]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.799]                   }
[13:23:13.799]                 }
[13:23:13.799]                 else {
[13:23:13.799]                   if (TRUE) {
[13:23:13.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.799]                     {
[13:23:13.799]                       inherits <- base::inherits
[13:23:13.799]                       invokeRestart <- base::invokeRestart
[13:23:13.799]                       is.null <- base::is.null
[13:23:13.799]                       muffled <- FALSE
[13:23:13.799]                       if (inherits(cond, "message")) {
[13:23:13.799]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.799]                         if (muffled) 
[13:23:13.799]                           invokeRestart("muffleMessage")
[13:23:13.799]                       }
[13:23:13.799]                       else if (inherits(cond, "warning")) {
[13:23:13.799]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.799]                         if (muffled) 
[13:23:13.799]                           invokeRestart("muffleWarning")
[13:23:13.799]                       }
[13:23:13.799]                       else if (inherits(cond, "condition")) {
[13:23:13.799]                         if (!is.null(pattern)) {
[13:23:13.799]                           computeRestarts <- base::computeRestarts
[13:23:13.799]                           grepl <- base::grepl
[13:23:13.799]                           restarts <- computeRestarts(cond)
[13:23:13.799]                           for (restart in restarts) {
[13:23:13.799]                             name <- restart$name
[13:23:13.799]                             if (is.null(name)) 
[13:23:13.799]                               next
[13:23:13.799]                             if (!grepl(pattern, name)) 
[13:23:13.799]                               next
[13:23:13.799]                             invokeRestart(restart)
[13:23:13.799]                             muffled <- TRUE
[13:23:13.799]                             break
[13:23:13.799]                           }
[13:23:13.799]                         }
[13:23:13.799]                       }
[13:23:13.799]                       invisible(muffled)
[13:23:13.799]                     }
[13:23:13.799]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.799]                   }
[13:23:13.799]                 }
[13:23:13.799]             }
[13:23:13.799]         }))
[13:23:13.799]     }, error = function(ex) {
[13:23:13.799]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.799]                 ...future.rng), started = ...future.startTime, 
[13:23:13.799]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.799]             version = "1.8"), class = "FutureResult")
[13:23:13.799]     }, finally = {
[13:23:13.799]         if (!identical(...future.workdir, getwd())) 
[13:23:13.799]             setwd(...future.workdir)
[13:23:13.799]         {
[13:23:13.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.799]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.799]             }
[13:23:13.799]             base::options(...future.oldOptions)
[13:23:13.799]             if (.Platform$OS.type == "windows") {
[13:23:13.799]                 old_names <- names(...future.oldEnvVars)
[13:23:13.799]                 envs <- base::Sys.getenv()
[13:23:13.799]                 names <- names(envs)
[13:23:13.799]                 common <- intersect(names, old_names)
[13:23:13.799]                 added <- setdiff(names, old_names)
[13:23:13.799]                 removed <- setdiff(old_names, names)
[13:23:13.799]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.799]                   envs[common]]
[13:23:13.799]                 NAMES <- toupper(changed)
[13:23:13.799]                 args <- list()
[13:23:13.799]                 for (kk in seq_along(NAMES)) {
[13:23:13.799]                   name <- changed[[kk]]
[13:23:13.799]                   NAME <- NAMES[[kk]]
[13:23:13.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.799]                     next
[13:23:13.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.799]                 }
[13:23:13.799]                 NAMES <- toupper(added)
[13:23:13.799]                 for (kk in seq_along(NAMES)) {
[13:23:13.799]                   name <- added[[kk]]
[13:23:13.799]                   NAME <- NAMES[[kk]]
[13:23:13.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.799]                     next
[13:23:13.799]                   args[[name]] <- ""
[13:23:13.799]                 }
[13:23:13.799]                 NAMES <- toupper(removed)
[13:23:13.799]                 for (kk in seq_along(NAMES)) {
[13:23:13.799]                   name <- removed[[kk]]
[13:23:13.799]                   NAME <- NAMES[[kk]]
[13:23:13.799]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.799]                     next
[13:23:13.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.799]                 }
[13:23:13.799]                 if (length(args) > 0) 
[13:23:13.799]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.799]             }
[13:23:13.799]             else {
[13:23:13.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.799]             }
[13:23:13.799]             {
[13:23:13.799]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.799]                   0L) {
[13:23:13.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.799]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.799]                   base::options(opts)
[13:23:13.799]                 }
[13:23:13.799]                 {
[13:23:13.799]                   {
[13:23:13.799]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.799]                     NULL
[13:23:13.799]                   }
[13:23:13.799]                   options(future.plan = NULL)
[13:23:13.799]                   if (is.na(NA_character_)) 
[13:23:13.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.799]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.799]                     envir = parent.frame()) 
[13:23:13.799]                   {
[13:23:13.799]                     default_workers <- missing(workers)
[13:23:13.799]                     if (is.function(workers)) 
[13:23:13.799]                       workers <- workers()
[13:23:13.799]                     workers <- structure(as.integer(workers), 
[13:23:13.799]                       class = class(workers))
[13:23:13.799]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.799]                       1L)
[13:23:13.799]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.799]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.799]                       if (default_workers) 
[13:23:13.799]                         supportsMulticore(warn = TRUE)
[13:23:13.799]                       return(sequential(..., envir = envir))
[13:23:13.799]                     }
[13:23:13.799]                     oopts <- options(mc.cores = workers)
[13:23:13.799]                     on.exit(options(oopts))
[13:23:13.799]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.799]                       envir = envir)
[13:23:13.799]                     if (!future$lazy) 
[13:23:13.799]                       future <- run(future)
[13:23:13.799]                     invisible(future)
[13:23:13.799]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.799]                 }
[13:23:13.799]             }
[13:23:13.799]         }
[13:23:13.799]     })
[13:23:13.799]     if (TRUE) {
[13:23:13.799]         base::sink(type = "output", split = FALSE)
[13:23:13.799]         if (TRUE) {
[13:23:13.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.799]         }
[13:23:13.799]         else {
[13:23:13.799]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.799]         }
[13:23:13.799]         base::close(...future.stdout)
[13:23:13.799]         ...future.stdout <- NULL
[13:23:13.799]     }
[13:23:13.799]     ...future.result$conditions <- ...future.conditions
[13:23:13.799]     ...future.result$finished <- base::Sys.time()
[13:23:13.799]     ...future.result
[13:23:13.799] }
[13:23:13.802] requestCore(): workers = 2
[13:23:13.805] MulticoreFuture started
[13:23:13.805] - Launch lazy future ... done
[13:23:13.806] run() for ‘MulticoreFuture’ ... done
[13:23:13.806] plan(): Setting new future strategy stack:
[13:23:13.806] result() for MulticoreFuture ...
[13:23:13.807] List of future strategies:
[13:23:13.807] 1. sequential:
[13:23:13.807]    - args: function (..., envir = parent.frame())
[13:23:13.807]    - tweaked: FALSE
[13:23:13.807]    - call: NULL
[13:23:13.808] plan(): nbrOfWorkers() = 1
[13:23:13.812] plan(): Setting new future strategy stack:
[13:23:13.813] List of future strategies:
[13:23:13.813] 1. multicore:
[13:23:13.813]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.813]    - tweaked: FALSE
[13:23:13.813]    - call: plan(strategy)
[13:23:13.818] plan(): nbrOfWorkers() = 2
[13:23:13.821] result() for MulticoreFuture ...
[13:23:13.821] result() for MulticoreFuture ... done
[13:23:13.821] result() for MulticoreFuture ... done
[13:23:13.822] result() for MulticoreFuture ...
[13:23:13.822] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:23:13.826] getGlobalsAndPackages() ...
[13:23:13.826] Searching for globals...
[13:23:13.829] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:23:13.829] Searching for globals ... DONE
[13:23:13.829] Resolving globals: FALSE
[13:23:13.830] 
[13:23:13.830] - packages: [2] ‘stats’, ‘datasets’
[13:23:13.830] getGlobalsAndPackages() ... DONE
[13:23:13.831] run() for ‘Future’ ...
[13:23:13.831] - state: ‘created’
[13:23:13.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.836] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.836]   - Field: ‘label’
[13:23:13.836]   - Field: ‘local’
[13:23:13.836]   - Field: ‘owner’
[13:23:13.836]   - Field: ‘envir’
[13:23:13.837]   - Field: ‘workers’
[13:23:13.837]   - Field: ‘packages’
[13:23:13.837]   - Field: ‘gc’
[13:23:13.837]   - Field: ‘job’
[13:23:13.837]   - Field: ‘conditions’
[13:23:13.837]   - Field: ‘expr’
[13:23:13.837]   - Field: ‘uuid’
[13:23:13.837]   - Field: ‘seed’
[13:23:13.837]   - Field: ‘version’
[13:23:13.838]   - Field: ‘result’
[13:23:13.838]   - Field: ‘asynchronous’
[13:23:13.838]   - Field: ‘calls’
[13:23:13.838]   - Field: ‘globals’
[13:23:13.838]   - Field: ‘stdout’
[13:23:13.838]   - Field: ‘earlySignal’
[13:23:13.838]   - Field: ‘lazy’
[13:23:13.838]   - Field: ‘state’
[13:23:13.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.839] - Launch lazy future ...
[13:23:13.839] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:13.839] Packages needed by future strategies (n = 0): <none>
[13:23:13.840] {
[13:23:13.840]     {
[13:23:13.840]         {
[13:23:13.840]             ...future.startTime <- base::Sys.time()
[13:23:13.840]             {
[13:23:13.840]                 {
[13:23:13.840]                   {
[13:23:13.840]                     {
[13:23:13.840]                       {
[13:23:13.840]                         base::local({
[13:23:13.840]                           has_future <- base::requireNamespace("future", 
[13:23:13.840]                             quietly = TRUE)
[13:23:13.840]                           if (has_future) {
[13:23:13.840]                             ns <- base::getNamespace("future")
[13:23:13.840]                             version <- ns[[".package"]][["version"]]
[13:23:13.840]                             if (is.null(version)) 
[13:23:13.840]                               version <- utils::packageVersion("future")
[13:23:13.840]                           }
[13:23:13.840]                           else {
[13:23:13.840]                             version <- NULL
[13:23:13.840]                           }
[13:23:13.840]                           if (!has_future || version < "1.8.0") {
[13:23:13.840]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.840]                               "", base::R.version$version.string), 
[13:23:13.840]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:13.840]                                 base::R.version$platform, 8 * 
[13:23:13.840]                                   base::.Machine$sizeof.pointer), 
[13:23:13.840]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.840]                                 "release", "version")], collapse = " "), 
[13:23:13.840]                               hostname = base::Sys.info()[["nodename"]])
[13:23:13.840]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.840]                               info)
[13:23:13.840]                             info <- base::paste(info, collapse = "; ")
[13:23:13.840]                             if (!has_future) {
[13:23:13.840]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.840]                                 info)
[13:23:13.840]                             }
[13:23:13.840]                             else {
[13:23:13.840]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.840]                                 info, version)
[13:23:13.840]                             }
[13:23:13.840]                             base::stop(msg)
[13:23:13.840]                           }
[13:23:13.840]                         })
[13:23:13.840]                       }
[13:23:13.840]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.840]                       base::options(mc.cores = 1L)
[13:23:13.840]                     }
[13:23:13.840]                     base::local({
[13:23:13.840]                       for (pkg in c("stats", "datasets")) {
[13:23:13.840]                         base::loadNamespace(pkg)
[13:23:13.840]                         base::library(pkg, character.only = TRUE)
[13:23:13.840]                       }
[13:23:13.840]                     })
[13:23:13.840]                   }
[13:23:13.840]                   options(future.plan = NULL)
[13:23:13.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.840]                 }
[13:23:13.840]                 ...future.workdir <- getwd()
[13:23:13.840]             }
[13:23:13.840]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.840]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.840]         }
[13:23:13.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.840]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.840]             base::names(...future.oldOptions))
[13:23:13.840]     }
[13:23:13.840]     if (FALSE) {
[13:23:13.840]     }
[13:23:13.840]     else {
[13:23:13.840]         if (TRUE) {
[13:23:13.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.840]                 open = "w")
[13:23:13.840]         }
[13:23:13.840]         else {
[13:23:13.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.840]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.840]         }
[13:23:13.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.840]             base::sink(type = "output", split = FALSE)
[13:23:13.840]             base::close(...future.stdout)
[13:23:13.840]         }, add = TRUE)
[13:23:13.840]     }
[13:23:13.840]     ...future.frame <- base::sys.nframe()
[13:23:13.840]     ...future.conditions <- base::list()
[13:23:13.840]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.840]     if (FALSE) {
[13:23:13.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.840]     }
[13:23:13.840]     ...future.result <- base::tryCatch({
[13:23:13.840]         base::withCallingHandlers({
[13:23:13.840]             ...future.value <- base::withVisible(base::local({
[13:23:13.840]                 withCallingHandlers({
[13:23:13.840]                   {
[13:23:13.840]                     lm(dist ~ poly(speed, 2), data = cars)
[13:23:13.840]                   }
[13:23:13.840]                 }, immediateCondition = function(cond) {
[13:23:13.840]                   save_rds <- function (object, pathname, ...) 
[13:23:13.840]                   {
[13:23:13.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.840]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.840]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.840]                         fi_tmp[["mtime"]])
[13:23:13.840]                     }
[13:23:13.840]                     tryCatch({
[13:23:13.840]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.840]                     }, error = function(ex) {
[13:23:13.840]                       msg <- conditionMessage(ex)
[13:23:13.840]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.840]                         fi_tmp[["mtime"]], msg)
[13:23:13.840]                       ex$message <- msg
[13:23:13.840]                       stop(ex)
[13:23:13.840]                     })
[13:23:13.840]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.840]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.840]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.840]                       fi <- file.info(pathname)
[13:23:13.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.840]                         fi[["size"]], fi[["mtime"]])
[13:23:13.840]                       stop(msg)
[13:23:13.840]                     }
[13:23:13.840]                     invisible(pathname)
[13:23:13.840]                   }
[13:23:13.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.840]                     rootPath = tempdir()) 
[13:23:13.840]                   {
[13:23:13.840]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.840]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.840]                       tmpdir = path, fileext = ".rds")
[13:23:13.840]                     save_rds(obj, file)
[13:23:13.840]                   }
[13:23:13.840]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.840]                   {
[13:23:13.840]                     inherits <- base::inherits
[13:23:13.840]                     invokeRestart <- base::invokeRestart
[13:23:13.840]                     is.null <- base::is.null
[13:23:13.840]                     muffled <- FALSE
[13:23:13.840]                     if (inherits(cond, "message")) {
[13:23:13.840]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.840]                       if (muffled) 
[13:23:13.840]                         invokeRestart("muffleMessage")
[13:23:13.840]                     }
[13:23:13.840]                     else if (inherits(cond, "warning")) {
[13:23:13.840]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.840]                       if (muffled) 
[13:23:13.840]                         invokeRestart("muffleWarning")
[13:23:13.840]                     }
[13:23:13.840]                     else if (inherits(cond, "condition")) {
[13:23:13.840]                       if (!is.null(pattern)) {
[13:23:13.840]                         computeRestarts <- base::computeRestarts
[13:23:13.840]                         grepl <- base::grepl
[13:23:13.840]                         restarts <- computeRestarts(cond)
[13:23:13.840]                         for (restart in restarts) {
[13:23:13.840]                           name <- restart$name
[13:23:13.840]                           if (is.null(name)) 
[13:23:13.840]                             next
[13:23:13.840]                           if (!grepl(pattern, name)) 
[13:23:13.840]                             next
[13:23:13.840]                           invokeRestart(restart)
[13:23:13.840]                           muffled <- TRUE
[13:23:13.840]                           break
[13:23:13.840]                         }
[13:23:13.840]                       }
[13:23:13.840]                     }
[13:23:13.840]                     invisible(muffled)
[13:23:13.840]                   }
[13:23:13.840]                   muffleCondition(cond)
[13:23:13.840]                 })
[13:23:13.840]             }))
[13:23:13.840]             future::FutureResult(value = ...future.value$value, 
[13:23:13.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.840]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.840]                     ...future.globalenv.names))
[13:23:13.840]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.840]         }, condition = base::local({
[13:23:13.840]             c <- base::c
[13:23:13.840]             inherits <- base::inherits
[13:23:13.840]             invokeRestart <- base::invokeRestart
[13:23:13.840]             length <- base::length
[13:23:13.840]             list <- base::list
[13:23:13.840]             seq.int <- base::seq.int
[13:23:13.840]             signalCondition <- base::signalCondition
[13:23:13.840]             sys.calls <- base::sys.calls
[13:23:13.840]             `[[` <- base::`[[`
[13:23:13.840]             `+` <- base::`+`
[13:23:13.840]             `<<-` <- base::`<<-`
[13:23:13.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.840]                   3L)]
[13:23:13.840]             }
[13:23:13.840]             function(cond) {
[13:23:13.840]                 is_error <- inherits(cond, "error")
[13:23:13.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.840]                   NULL)
[13:23:13.840]                 if (is_error) {
[13:23:13.840]                   sessionInformation <- function() {
[13:23:13.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.840]                       search = base::search(), system = base::Sys.info())
[13:23:13.840]                   }
[13:23:13.840]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.840]                     cond$call), session = sessionInformation(), 
[13:23:13.840]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.840]                   signalCondition(cond)
[13:23:13.840]                 }
[13:23:13.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.840]                 "immediateCondition"))) {
[13:23:13.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.840]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.840]                   if (TRUE && !signal) {
[13:23:13.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.840]                     {
[13:23:13.840]                       inherits <- base::inherits
[13:23:13.840]                       invokeRestart <- base::invokeRestart
[13:23:13.840]                       is.null <- base::is.null
[13:23:13.840]                       muffled <- FALSE
[13:23:13.840]                       if (inherits(cond, "message")) {
[13:23:13.840]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.840]                         if (muffled) 
[13:23:13.840]                           invokeRestart("muffleMessage")
[13:23:13.840]                       }
[13:23:13.840]                       else if (inherits(cond, "warning")) {
[13:23:13.840]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.840]                         if (muffled) 
[13:23:13.840]                           invokeRestart("muffleWarning")
[13:23:13.840]                       }
[13:23:13.840]                       else if (inherits(cond, "condition")) {
[13:23:13.840]                         if (!is.null(pattern)) {
[13:23:13.840]                           computeRestarts <- base::computeRestarts
[13:23:13.840]                           grepl <- base::grepl
[13:23:13.840]                           restarts <- computeRestarts(cond)
[13:23:13.840]                           for (restart in restarts) {
[13:23:13.840]                             name <- restart$name
[13:23:13.840]                             if (is.null(name)) 
[13:23:13.840]                               next
[13:23:13.840]                             if (!grepl(pattern, name)) 
[13:23:13.840]                               next
[13:23:13.840]                             invokeRestart(restart)
[13:23:13.840]                             muffled <- TRUE
[13:23:13.840]                             break
[13:23:13.840]                           }
[13:23:13.840]                         }
[13:23:13.840]                       }
[13:23:13.840]                       invisible(muffled)
[13:23:13.840]                     }
[13:23:13.840]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.840]                   }
[13:23:13.840]                 }
[13:23:13.840]                 else {
[13:23:13.840]                   if (TRUE) {
[13:23:13.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.840]                     {
[13:23:13.840]                       inherits <- base::inherits
[13:23:13.840]                       invokeRestart <- base::invokeRestart
[13:23:13.840]                       is.null <- base::is.null
[13:23:13.840]                       muffled <- FALSE
[13:23:13.840]                       if (inherits(cond, "message")) {
[13:23:13.840]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.840]                         if (muffled) 
[13:23:13.840]                           invokeRestart("muffleMessage")
[13:23:13.840]                       }
[13:23:13.840]                       else if (inherits(cond, "warning")) {
[13:23:13.840]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.840]                         if (muffled) 
[13:23:13.840]                           invokeRestart("muffleWarning")
[13:23:13.840]                       }
[13:23:13.840]                       else if (inherits(cond, "condition")) {
[13:23:13.840]                         if (!is.null(pattern)) {
[13:23:13.840]                           computeRestarts <- base::computeRestarts
[13:23:13.840]                           grepl <- base::grepl
[13:23:13.840]                           restarts <- computeRestarts(cond)
[13:23:13.840]                           for (restart in restarts) {
[13:23:13.840]                             name <- restart$name
[13:23:13.840]                             if (is.null(name)) 
[13:23:13.840]                               next
[13:23:13.840]                             if (!grepl(pattern, name)) 
[13:23:13.840]                               next
[13:23:13.840]                             invokeRestart(restart)
[13:23:13.840]                             muffled <- TRUE
[13:23:13.840]                             break
[13:23:13.840]                           }
[13:23:13.840]                         }
[13:23:13.840]                       }
[13:23:13.840]                       invisible(muffled)
[13:23:13.840]                     }
[13:23:13.840]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.840]                   }
[13:23:13.840]                 }
[13:23:13.840]             }
[13:23:13.840]         }))
[13:23:13.840]     }, error = function(ex) {
[13:23:13.840]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.840]                 ...future.rng), started = ...future.startTime, 
[13:23:13.840]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.840]             version = "1.8"), class = "FutureResult")
[13:23:13.840]     }, finally = {
[13:23:13.840]         if (!identical(...future.workdir, getwd())) 
[13:23:13.840]             setwd(...future.workdir)
[13:23:13.840]         {
[13:23:13.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.840]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.840]             }
[13:23:13.840]             base::options(...future.oldOptions)
[13:23:13.840]             if (.Platform$OS.type == "windows") {
[13:23:13.840]                 old_names <- names(...future.oldEnvVars)
[13:23:13.840]                 envs <- base::Sys.getenv()
[13:23:13.840]                 names <- names(envs)
[13:23:13.840]                 common <- intersect(names, old_names)
[13:23:13.840]                 added <- setdiff(names, old_names)
[13:23:13.840]                 removed <- setdiff(old_names, names)
[13:23:13.840]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.840]                   envs[common]]
[13:23:13.840]                 NAMES <- toupper(changed)
[13:23:13.840]                 args <- list()
[13:23:13.840]                 for (kk in seq_along(NAMES)) {
[13:23:13.840]                   name <- changed[[kk]]
[13:23:13.840]                   NAME <- NAMES[[kk]]
[13:23:13.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.840]                     next
[13:23:13.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.840]                 }
[13:23:13.840]                 NAMES <- toupper(added)
[13:23:13.840]                 for (kk in seq_along(NAMES)) {
[13:23:13.840]                   name <- added[[kk]]
[13:23:13.840]                   NAME <- NAMES[[kk]]
[13:23:13.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.840]                     next
[13:23:13.840]                   args[[name]] <- ""
[13:23:13.840]                 }
[13:23:13.840]                 NAMES <- toupper(removed)
[13:23:13.840]                 for (kk in seq_along(NAMES)) {
[13:23:13.840]                   name <- removed[[kk]]
[13:23:13.840]                   NAME <- NAMES[[kk]]
[13:23:13.840]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.840]                     next
[13:23:13.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.840]                 }
[13:23:13.840]                 if (length(args) > 0) 
[13:23:13.840]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.840]             }
[13:23:13.840]             else {
[13:23:13.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.840]             }
[13:23:13.840]             {
[13:23:13.840]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.840]                   0L) {
[13:23:13.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.840]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.840]                   base::options(opts)
[13:23:13.840]                 }
[13:23:13.840]                 {
[13:23:13.840]                   {
[13:23:13.840]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.840]                     NULL
[13:23:13.840]                   }
[13:23:13.840]                   options(future.plan = NULL)
[13:23:13.840]                   if (is.na(NA_character_)) 
[13:23:13.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.840]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.840]                     envir = parent.frame()) 
[13:23:13.840]                   {
[13:23:13.840]                     default_workers <- missing(workers)
[13:23:13.840]                     if (is.function(workers)) 
[13:23:13.840]                       workers <- workers()
[13:23:13.840]                     workers <- structure(as.integer(workers), 
[13:23:13.840]                       class = class(workers))
[13:23:13.840]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.840]                       1L)
[13:23:13.840]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.840]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.840]                       if (default_workers) 
[13:23:13.840]                         supportsMulticore(warn = TRUE)
[13:23:13.840]                       return(sequential(..., envir = envir))
[13:23:13.840]                     }
[13:23:13.840]                     oopts <- options(mc.cores = workers)
[13:23:13.840]                     on.exit(options(oopts))
[13:23:13.840]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.840]                       envir = envir)
[13:23:13.840]                     if (!future$lazy) 
[13:23:13.840]                       future <- run(future)
[13:23:13.840]                     invisible(future)
[13:23:13.840]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.840]                 }
[13:23:13.840]             }
[13:23:13.840]         }
[13:23:13.840]     })
[13:23:13.840]     if (TRUE) {
[13:23:13.840]         base::sink(type = "output", split = FALSE)
[13:23:13.840]         if (TRUE) {
[13:23:13.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.840]         }
[13:23:13.840]         else {
[13:23:13.840]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.840]         }
[13:23:13.840]         base::close(...future.stdout)
[13:23:13.840]         ...future.stdout <- NULL
[13:23:13.840]     }
[13:23:13.840]     ...future.result$conditions <- ...future.conditions
[13:23:13.840]     ...future.result$finished <- base::Sys.time()
[13:23:13.840]     ...future.result
[13:23:13.840] }
[13:23:13.843] requestCore(): workers = 2
[13:23:13.846] MulticoreFuture started
[13:23:13.846] - Launch lazy future ... done
[13:23:13.846] run() for ‘MulticoreFuture’ ... done
[13:23:13.847] result() for MulticoreFuture ...
[13:23:13.847] plan(): Setting new future strategy stack:
[13:23:13.848] List of future strategies:
[13:23:13.848] 1. sequential:
[13:23:13.848]    - args: function (..., envir = parent.frame())
[13:23:13.848]    - tweaked: FALSE
[13:23:13.848]    - call: NULL
[13:23:13.849] plan(): nbrOfWorkers() = 1
[13:23:13.853] plan(): Setting new future strategy stack:
[13:23:13.853] List of future strategies:
[13:23:13.853] 1. multicore:
[13:23:13.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.853]    - tweaked: FALSE
[13:23:13.853]    - call: plan(strategy)
[13:23:13.859] plan(): nbrOfWorkers() = 2
[13:23:13.862] result() for MulticoreFuture ...
[13:23:13.862] result() for MulticoreFuture ... done
[13:23:13.862] result() for MulticoreFuture ... done
[13:23:13.862] result() for MulticoreFuture ...
[13:23:13.862] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:23:13.865] getGlobalsAndPackages() ...
[13:23:13.865] Searching for globals...
[13:23:13.876] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:13.876] Searching for globals ... DONE
[13:23:13.876] Resolving globals: FALSE
[13:23:13.877] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:13.878] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:13.878] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:13.878] 
[13:23:13.878] getGlobalsAndPackages() ... DONE
[13:23:13.878] run() for ‘Future’ ...
[13:23:13.879] - state: ‘created’
[13:23:13.879] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.883] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.883]   - Field: ‘label’
[13:23:13.884]   - Field: ‘local’
[13:23:13.884]   - Field: ‘owner’
[13:23:13.884]   - Field: ‘envir’
[13:23:13.884]   - Field: ‘workers’
[13:23:13.884]   - Field: ‘packages’
[13:23:13.884]   - Field: ‘gc’
[13:23:13.884]   - Field: ‘job’
[13:23:13.884]   - Field: ‘conditions’
[13:23:13.885]   - Field: ‘expr’
[13:23:13.885]   - Field: ‘uuid’
[13:23:13.885]   - Field: ‘seed’
[13:23:13.885]   - Field: ‘version’
[13:23:13.885]   - Field: ‘result’
[13:23:13.885]   - Field: ‘asynchronous’
[13:23:13.885]   - Field: ‘calls’
[13:23:13.885]   - Field: ‘globals’
[13:23:13.885]   - Field: ‘stdout’
[13:23:13.886]   - Field: ‘earlySignal’
[13:23:13.886]   - Field: ‘lazy’
[13:23:13.886]   - Field: ‘state’
[13:23:13.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.886] - Launch lazy future ...
[13:23:13.886] Packages needed by the future expression (n = 0): <none>
[13:23:13.887] Packages needed by future strategies (n = 0): <none>
[13:23:13.887] {
[13:23:13.887]     {
[13:23:13.887]         {
[13:23:13.887]             ...future.startTime <- base::Sys.time()
[13:23:13.887]             {
[13:23:13.887]                 {
[13:23:13.887]                   {
[13:23:13.887]                     {
[13:23:13.887]                       base::local({
[13:23:13.887]                         has_future <- base::requireNamespace("future", 
[13:23:13.887]                           quietly = TRUE)
[13:23:13.887]                         if (has_future) {
[13:23:13.887]                           ns <- base::getNamespace("future")
[13:23:13.887]                           version <- ns[[".package"]][["version"]]
[13:23:13.887]                           if (is.null(version)) 
[13:23:13.887]                             version <- utils::packageVersion("future")
[13:23:13.887]                         }
[13:23:13.887]                         else {
[13:23:13.887]                           version <- NULL
[13:23:13.887]                         }
[13:23:13.887]                         if (!has_future || version < "1.8.0") {
[13:23:13.887]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.887]                             "", base::R.version$version.string), 
[13:23:13.887]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.887]                               "release", "version")], collapse = " "), 
[13:23:13.887]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.887]                             info)
[13:23:13.887]                           info <- base::paste(info, collapse = "; ")
[13:23:13.887]                           if (!has_future) {
[13:23:13.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.887]                               info)
[13:23:13.887]                           }
[13:23:13.887]                           else {
[13:23:13.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.887]                               info, version)
[13:23:13.887]                           }
[13:23:13.887]                           base::stop(msg)
[13:23:13.887]                         }
[13:23:13.887]                       })
[13:23:13.887]                     }
[13:23:13.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.887]                     base::options(mc.cores = 1L)
[13:23:13.887]                   }
[13:23:13.887]                   options(future.plan = NULL)
[13:23:13.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.887]                 }
[13:23:13.887]                 ...future.workdir <- getwd()
[13:23:13.887]             }
[13:23:13.887]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.887]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.887]         }
[13:23:13.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.887]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.887]             base::names(...future.oldOptions))
[13:23:13.887]     }
[13:23:13.887]     if (FALSE) {
[13:23:13.887]     }
[13:23:13.887]     else {
[13:23:13.887]         if (TRUE) {
[13:23:13.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.887]                 open = "w")
[13:23:13.887]         }
[13:23:13.887]         else {
[13:23:13.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.887]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.887]         }
[13:23:13.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.887]             base::sink(type = "output", split = FALSE)
[13:23:13.887]             base::close(...future.stdout)
[13:23:13.887]         }, add = TRUE)
[13:23:13.887]     }
[13:23:13.887]     ...future.frame <- base::sys.nframe()
[13:23:13.887]     ...future.conditions <- base::list()
[13:23:13.887]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.887]     if (FALSE) {
[13:23:13.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.887]     }
[13:23:13.887]     ...future.result <- base::tryCatch({
[13:23:13.887]         base::withCallingHandlers({
[13:23:13.887]             ...future.value <- base::withVisible(base::local({
[13:23:13.887]                 withCallingHandlers({
[13:23:13.887]                   {
[13:23:13.887]                     outer_function(1L)
[13:23:13.887]                   }
[13:23:13.887]                 }, immediateCondition = function(cond) {
[13:23:13.887]                   save_rds <- function (object, pathname, ...) 
[13:23:13.887]                   {
[13:23:13.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.887]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.887]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.887]                         fi_tmp[["mtime"]])
[13:23:13.887]                     }
[13:23:13.887]                     tryCatch({
[13:23:13.887]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.887]                     }, error = function(ex) {
[13:23:13.887]                       msg <- conditionMessage(ex)
[13:23:13.887]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.887]                         fi_tmp[["mtime"]], msg)
[13:23:13.887]                       ex$message <- msg
[13:23:13.887]                       stop(ex)
[13:23:13.887]                     })
[13:23:13.887]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.887]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.887]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.887]                       fi <- file.info(pathname)
[13:23:13.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.887]                         fi[["size"]], fi[["mtime"]])
[13:23:13.887]                       stop(msg)
[13:23:13.887]                     }
[13:23:13.887]                     invisible(pathname)
[13:23:13.887]                   }
[13:23:13.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.887]                     rootPath = tempdir()) 
[13:23:13.887]                   {
[13:23:13.887]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.887]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.887]                       tmpdir = path, fileext = ".rds")
[13:23:13.887]                     save_rds(obj, file)
[13:23:13.887]                   }
[13:23:13.887]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.887]                   {
[13:23:13.887]                     inherits <- base::inherits
[13:23:13.887]                     invokeRestart <- base::invokeRestart
[13:23:13.887]                     is.null <- base::is.null
[13:23:13.887]                     muffled <- FALSE
[13:23:13.887]                     if (inherits(cond, "message")) {
[13:23:13.887]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.887]                       if (muffled) 
[13:23:13.887]                         invokeRestart("muffleMessage")
[13:23:13.887]                     }
[13:23:13.887]                     else if (inherits(cond, "warning")) {
[13:23:13.887]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.887]                       if (muffled) 
[13:23:13.887]                         invokeRestart("muffleWarning")
[13:23:13.887]                     }
[13:23:13.887]                     else if (inherits(cond, "condition")) {
[13:23:13.887]                       if (!is.null(pattern)) {
[13:23:13.887]                         computeRestarts <- base::computeRestarts
[13:23:13.887]                         grepl <- base::grepl
[13:23:13.887]                         restarts <- computeRestarts(cond)
[13:23:13.887]                         for (restart in restarts) {
[13:23:13.887]                           name <- restart$name
[13:23:13.887]                           if (is.null(name)) 
[13:23:13.887]                             next
[13:23:13.887]                           if (!grepl(pattern, name)) 
[13:23:13.887]                             next
[13:23:13.887]                           invokeRestart(restart)
[13:23:13.887]                           muffled <- TRUE
[13:23:13.887]                           break
[13:23:13.887]                         }
[13:23:13.887]                       }
[13:23:13.887]                     }
[13:23:13.887]                     invisible(muffled)
[13:23:13.887]                   }
[13:23:13.887]                   muffleCondition(cond)
[13:23:13.887]                 })
[13:23:13.887]             }))
[13:23:13.887]             future::FutureResult(value = ...future.value$value, 
[13:23:13.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.887]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.887]                     ...future.globalenv.names))
[13:23:13.887]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.887]         }, condition = base::local({
[13:23:13.887]             c <- base::c
[13:23:13.887]             inherits <- base::inherits
[13:23:13.887]             invokeRestart <- base::invokeRestart
[13:23:13.887]             length <- base::length
[13:23:13.887]             list <- base::list
[13:23:13.887]             seq.int <- base::seq.int
[13:23:13.887]             signalCondition <- base::signalCondition
[13:23:13.887]             sys.calls <- base::sys.calls
[13:23:13.887]             `[[` <- base::`[[`
[13:23:13.887]             `+` <- base::`+`
[13:23:13.887]             `<<-` <- base::`<<-`
[13:23:13.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.887]                   3L)]
[13:23:13.887]             }
[13:23:13.887]             function(cond) {
[13:23:13.887]                 is_error <- inherits(cond, "error")
[13:23:13.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.887]                   NULL)
[13:23:13.887]                 if (is_error) {
[13:23:13.887]                   sessionInformation <- function() {
[13:23:13.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.887]                       search = base::search(), system = base::Sys.info())
[13:23:13.887]                   }
[13:23:13.887]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.887]                     cond$call), session = sessionInformation(), 
[13:23:13.887]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.887]                   signalCondition(cond)
[13:23:13.887]                 }
[13:23:13.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.887]                 "immediateCondition"))) {
[13:23:13.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.887]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.887]                   if (TRUE && !signal) {
[13:23:13.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.887]                     {
[13:23:13.887]                       inherits <- base::inherits
[13:23:13.887]                       invokeRestart <- base::invokeRestart
[13:23:13.887]                       is.null <- base::is.null
[13:23:13.887]                       muffled <- FALSE
[13:23:13.887]                       if (inherits(cond, "message")) {
[13:23:13.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.887]                         if (muffled) 
[13:23:13.887]                           invokeRestart("muffleMessage")
[13:23:13.887]                       }
[13:23:13.887]                       else if (inherits(cond, "warning")) {
[13:23:13.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.887]                         if (muffled) 
[13:23:13.887]                           invokeRestart("muffleWarning")
[13:23:13.887]                       }
[13:23:13.887]                       else if (inherits(cond, "condition")) {
[13:23:13.887]                         if (!is.null(pattern)) {
[13:23:13.887]                           computeRestarts <- base::computeRestarts
[13:23:13.887]                           grepl <- base::grepl
[13:23:13.887]                           restarts <- computeRestarts(cond)
[13:23:13.887]                           for (restart in restarts) {
[13:23:13.887]                             name <- restart$name
[13:23:13.887]                             if (is.null(name)) 
[13:23:13.887]                               next
[13:23:13.887]                             if (!grepl(pattern, name)) 
[13:23:13.887]                               next
[13:23:13.887]                             invokeRestart(restart)
[13:23:13.887]                             muffled <- TRUE
[13:23:13.887]                             break
[13:23:13.887]                           }
[13:23:13.887]                         }
[13:23:13.887]                       }
[13:23:13.887]                       invisible(muffled)
[13:23:13.887]                     }
[13:23:13.887]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.887]                   }
[13:23:13.887]                 }
[13:23:13.887]                 else {
[13:23:13.887]                   if (TRUE) {
[13:23:13.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.887]                     {
[13:23:13.887]                       inherits <- base::inherits
[13:23:13.887]                       invokeRestart <- base::invokeRestart
[13:23:13.887]                       is.null <- base::is.null
[13:23:13.887]                       muffled <- FALSE
[13:23:13.887]                       if (inherits(cond, "message")) {
[13:23:13.887]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.887]                         if (muffled) 
[13:23:13.887]                           invokeRestart("muffleMessage")
[13:23:13.887]                       }
[13:23:13.887]                       else if (inherits(cond, "warning")) {
[13:23:13.887]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.887]                         if (muffled) 
[13:23:13.887]                           invokeRestart("muffleWarning")
[13:23:13.887]                       }
[13:23:13.887]                       else if (inherits(cond, "condition")) {
[13:23:13.887]                         if (!is.null(pattern)) {
[13:23:13.887]                           computeRestarts <- base::computeRestarts
[13:23:13.887]                           grepl <- base::grepl
[13:23:13.887]                           restarts <- computeRestarts(cond)
[13:23:13.887]                           for (restart in restarts) {
[13:23:13.887]                             name <- restart$name
[13:23:13.887]                             if (is.null(name)) 
[13:23:13.887]                               next
[13:23:13.887]                             if (!grepl(pattern, name)) 
[13:23:13.887]                               next
[13:23:13.887]                             invokeRestart(restart)
[13:23:13.887]                             muffled <- TRUE
[13:23:13.887]                             break
[13:23:13.887]                           }
[13:23:13.887]                         }
[13:23:13.887]                       }
[13:23:13.887]                       invisible(muffled)
[13:23:13.887]                     }
[13:23:13.887]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.887]                   }
[13:23:13.887]                 }
[13:23:13.887]             }
[13:23:13.887]         }))
[13:23:13.887]     }, error = function(ex) {
[13:23:13.887]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.887]                 ...future.rng), started = ...future.startTime, 
[13:23:13.887]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.887]             version = "1.8"), class = "FutureResult")
[13:23:13.887]     }, finally = {
[13:23:13.887]         if (!identical(...future.workdir, getwd())) 
[13:23:13.887]             setwd(...future.workdir)
[13:23:13.887]         {
[13:23:13.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.887]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.887]             }
[13:23:13.887]             base::options(...future.oldOptions)
[13:23:13.887]             if (.Platform$OS.type == "windows") {
[13:23:13.887]                 old_names <- names(...future.oldEnvVars)
[13:23:13.887]                 envs <- base::Sys.getenv()
[13:23:13.887]                 names <- names(envs)
[13:23:13.887]                 common <- intersect(names, old_names)
[13:23:13.887]                 added <- setdiff(names, old_names)
[13:23:13.887]                 removed <- setdiff(old_names, names)
[13:23:13.887]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.887]                   envs[common]]
[13:23:13.887]                 NAMES <- toupper(changed)
[13:23:13.887]                 args <- list()
[13:23:13.887]                 for (kk in seq_along(NAMES)) {
[13:23:13.887]                   name <- changed[[kk]]
[13:23:13.887]                   NAME <- NAMES[[kk]]
[13:23:13.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.887]                     next
[13:23:13.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.887]                 }
[13:23:13.887]                 NAMES <- toupper(added)
[13:23:13.887]                 for (kk in seq_along(NAMES)) {
[13:23:13.887]                   name <- added[[kk]]
[13:23:13.887]                   NAME <- NAMES[[kk]]
[13:23:13.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.887]                     next
[13:23:13.887]                   args[[name]] <- ""
[13:23:13.887]                 }
[13:23:13.887]                 NAMES <- toupper(removed)
[13:23:13.887]                 for (kk in seq_along(NAMES)) {
[13:23:13.887]                   name <- removed[[kk]]
[13:23:13.887]                   NAME <- NAMES[[kk]]
[13:23:13.887]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.887]                     next
[13:23:13.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.887]                 }
[13:23:13.887]                 if (length(args) > 0) 
[13:23:13.887]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.887]             }
[13:23:13.887]             else {
[13:23:13.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.887]             }
[13:23:13.887]             {
[13:23:13.887]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.887]                   0L) {
[13:23:13.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.887]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.887]                   base::options(opts)
[13:23:13.887]                 }
[13:23:13.887]                 {
[13:23:13.887]                   {
[13:23:13.887]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.887]                     NULL
[13:23:13.887]                   }
[13:23:13.887]                   options(future.plan = NULL)
[13:23:13.887]                   if (is.na(NA_character_)) 
[13:23:13.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.887]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.887]                     envir = parent.frame()) 
[13:23:13.887]                   {
[13:23:13.887]                     default_workers <- missing(workers)
[13:23:13.887]                     if (is.function(workers)) 
[13:23:13.887]                       workers <- workers()
[13:23:13.887]                     workers <- structure(as.integer(workers), 
[13:23:13.887]                       class = class(workers))
[13:23:13.887]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.887]                       1L)
[13:23:13.887]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.887]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.887]                       if (default_workers) 
[13:23:13.887]                         supportsMulticore(warn = TRUE)
[13:23:13.887]                       return(sequential(..., envir = envir))
[13:23:13.887]                     }
[13:23:13.887]                     oopts <- options(mc.cores = workers)
[13:23:13.887]                     on.exit(options(oopts))
[13:23:13.887]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.887]                       envir = envir)
[13:23:13.887]                     if (!future$lazy) 
[13:23:13.887]                       future <- run(future)
[13:23:13.887]                     invisible(future)
[13:23:13.887]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.887]                 }
[13:23:13.887]             }
[13:23:13.887]         }
[13:23:13.887]     })
[13:23:13.887]     if (TRUE) {
[13:23:13.887]         base::sink(type = "output", split = FALSE)
[13:23:13.887]         if (TRUE) {
[13:23:13.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.887]         }
[13:23:13.887]         else {
[13:23:13.887]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.887]         }
[13:23:13.887]         base::close(...future.stdout)
[13:23:13.887]         ...future.stdout <- NULL
[13:23:13.887]     }
[13:23:13.887]     ...future.result$conditions <- ...future.conditions
[13:23:13.887]     ...future.result$finished <- base::Sys.time()
[13:23:13.887]     ...future.result
[13:23:13.887] }
[13:23:13.890] assign_globals() ...
[13:23:13.890] List of 3
[13:23:13.890]  $ outer_function:function (x)  
[13:23:13.890]  $ map           :function (.x, .f, ...)  
[13:23:13.890]  $ inner_function:function (x)  
[13:23:13.890]  - attr(*, "where")=List of 3
[13:23:13.890]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:23:13.890]   ..$ map           :<environment: R_EmptyEnv> 
[13:23:13.890]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:23:13.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.890]  - attr(*, "resolved")= logi FALSE
[13:23:13.890]  - attr(*, "total_size")= num 7704
[13:23:13.890]  - attr(*, "already-done")= logi TRUE
[13:23:13.894] - reassign environment for ‘outer_function’
[13:23:13.894] - copied ‘outer_function’ to environment
[13:23:13.894] - reassign environment for ‘map’
[13:23:13.894] - copied ‘map’ to environment
[13:23:13.894] - reassign environment for ‘inner_function’
[13:23:13.894] - copied ‘inner_function’ to environment
[13:23:13.895] assign_globals() ... done
[13:23:13.895] requestCore(): workers = 2
[13:23:13.897] MulticoreFuture started
[13:23:13.898] - Launch lazy future ... done
[13:23:13.898] run() for ‘MulticoreFuture’ ... done
[13:23:13.898] result() for MulticoreFuture ...
[13:23:13.899] plan(): Setting new future strategy stack:
[13:23:13.899] List of future strategies:
[13:23:13.899] 1. sequential:
[13:23:13.899]    - args: function (..., envir = parent.frame())
[13:23:13.899]    - tweaked: FALSE
[13:23:13.899]    - call: NULL
[13:23:13.900] plan(): nbrOfWorkers() = 1
[13:23:13.902] plan(): Setting new future strategy stack:
[13:23:13.903] List of future strategies:
[13:23:13.903] 1. multicore:
[13:23:13.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.903]    - tweaked: FALSE
[13:23:13.903]    - call: plan(strategy)
[13:23:13.908] plan(): nbrOfWorkers() = 2
[13:23:13.909] result() for MulticoreFuture ...
[13:23:13.909] result() for MulticoreFuture ... done
[13:23:13.910] result() for MulticoreFuture ... done
[13:23:13.910] result() for MulticoreFuture ...
[13:23:13.910] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:23:13.912] getGlobalsAndPackages() ...
[13:23:13.912] Searching for globals...
[13:23:13.922] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:13.923] Searching for globals ... DONE
[13:23:13.923] Resolving globals: FALSE
[13:23:13.924] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:13.924] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:13.924] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:13.925] 
[13:23:13.925] getGlobalsAndPackages() ... DONE
[13:23:13.925] run() for ‘Future’ ...
[13:23:13.925] - state: ‘created’
[13:23:13.925] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:23:13.930] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:13.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:23:13.931]   - Field: ‘label’
[13:23:13.931]   - Field: ‘local’
[13:23:13.931]   - Field: ‘owner’
[13:23:13.931]   - Field: ‘envir’
[13:23:13.931]   - Field: ‘workers’
[13:23:13.931]   - Field: ‘packages’
[13:23:13.932]   - Field: ‘gc’
[13:23:13.932]   - Field: ‘job’
[13:23:13.932]   - Field: ‘conditions’
[13:23:13.932]   - Field: ‘expr’
[13:23:13.932]   - Field: ‘uuid’
[13:23:13.932]   - Field: ‘seed’
[13:23:13.932]   - Field: ‘version’
[13:23:13.933]   - Field: ‘result’
[13:23:13.933]   - Field: ‘asynchronous’
[13:23:13.933]   - Field: ‘calls’
[13:23:13.933]   - Field: ‘globals’
[13:23:13.933]   - Field: ‘stdout’
[13:23:13.933]   - Field: ‘earlySignal’
[13:23:13.933]   - Field: ‘lazy’
[13:23:13.933]   - Field: ‘state’
[13:23:13.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:23:13.934] - Launch lazy future ...
[13:23:13.934] Packages needed by the future expression (n = 0): <none>
[13:23:13.934] Packages needed by future strategies (n = 0): <none>
[13:23:13.935] {
[13:23:13.935]     {
[13:23:13.935]         {
[13:23:13.935]             ...future.startTime <- base::Sys.time()
[13:23:13.935]             {
[13:23:13.935]                 {
[13:23:13.935]                   {
[13:23:13.935]                     {
[13:23:13.935]                       base::local({
[13:23:13.935]                         has_future <- base::requireNamespace("future", 
[13:23:13.935]                           quietly = TRUE)
[13:23:13.935]                         if (has_future) {
[13:23:13.935]                           ns <- base::getNamespace("future")
[13:23:13.935]                           version <- ns[[".package"]][["version"]]
[13:23:13.935]                           if (is.null(version)) 
[13:23:13.935]                             version <- utils::packageVersion("future")
[13:23:13.935]                         }
[13:23:13.935]                         else {
[13:23:13.935]                           version <- NULL
[13:23:13.935]                         }
[13:23:13.935]                         if (!has_future || version < "1.8.0") {
[13:23:13.935]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:13.935]                             "", base::R.version$version.string), 
[13:23:13.935]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:13.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:13.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:13.935]                               "release", "version")], collapse = " "), 
[13:23:13.935]                             hostname = base::Sys.info()[["nodename"]])
[13:23:13.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:13.935]                             info)
[13:23:13.935]                           info <- base::paste(info, collapse = "; ")
[13:23:13.935]                           if (!has_future) {
[13:23:13.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:13.935]                               info)
[13:23:13.935]                           }
[13:23:13.935]                           else {
[13:23:13.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:13.935]                               info, version)
[13:23:13.935]                           }
[13:23:13.935]                           base::stop(msg)
[13:23:13.935]                         }
[13:23:13.935]                       })
[13:23:13.935]                     }
[13:23:13.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:13.935]                     base::options(mc.cores = 1L)
[13:23:13.935]                   }
[13:23:13.935]                   options(future.plan = NULL)
[13:23:13.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:13.935]                 }
[13:23:13.935]                 ...future.workdir <- getwd()
[13:23:13.935]             }
[13:23:13.935]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:13.935]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:13.935]         }
[13:23:13.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:13.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:13.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:13.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:13.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:13.935]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:13.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:13.935]             base::names(...future.oldOptions))
[13:23:13.935]     }
[13:23:13.935]     if (FALSE) {
[13:23:13.935]     }
[13:23:13.935]     else {
[13:23:13.935]         if (TRUE) {
[13:23:13.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:13.935]                 open = "w")
[13:23:13.935]         }
[13:23:13.935]         else {
[13:23:13.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:13.935]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:13.935]         }
[13:23:13.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:13.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:13.935]             base::sink(type = "output", split = FALSE)
[13:23:13.935]             base::close(...future.stdout)
[13:23:13.935]         }, add = TRUE)
[13:23:13.935]     }
[13:23:13.935]     ...future.frame <- base::sys.nframe()
[13:23:13.935]     ...future.conditions <- base::list()
[13:23:13.935]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:13.935]     if (FALSE) {
[13:23:13.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:13.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:13.935]     }
[13:23:13.935]     ...future.result <- base::tryCatch({
[13:23:13.935]         base::withCallingHandlers({
[13:23:13.935]             ...future.value <- base::withVisible(base::local({
[13:23:13.935]                 withCallingHandlers({
[13:23:13.935]                   {
[13:23:13.935]                     outer_function(1L)
[13:23:13.935]                   }
[13:23:13.935]                 }, immediateCondition = function(cond) {
[13:23:13.935]                   save_rds <- function (object, pathname, ...) 
[13:23:13.935]                   {
[13:23:13.935]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:13.935]                     if (file_test("-f", pathname_tmp)) {
[13:23:13.935]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.935]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:13.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.935]                         fi_tmp[["mtime"]])
[13:23:13.935]                     }
[13:23:13.935]                     tryCatch({
[13:23:13.935]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:13.935]                     }, error = function(ex) {
[13:23:13.935]                       msg <- conditionMessage(ex)
[13:23:13.935]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.935]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:13.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.935]                         fi_tmp[["mtime"]], msg)
[13:23:13.935]                       ex$message <- msg
[13:23:13.935]                       stop(ex)
[13:23:13.935]                     })
[13:23:13.935]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:13.935]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:13.935]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:13.935]                       fi_tmp <- file.info(pathname_tmp)
[13:23:13.935]                       fi <- file.info(pathname)
[13:23:13.935]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:13.935]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:13.935]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:13.935]                         fi[["size"]], fi[["mtime"]])
[13:23:13.935]                       stop(msg)
[13:23:13.935]                     }
[13:23:13.935]                     invisible(pathname)
[13:23:13.935]                   }
[13:23:13.935]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:13.935]                     rootPath = tempdir()) 
[13:23:13.935]                   {
[13:23:13.935]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:13.935]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:13.935]                       tmpdir = path, fileext = ".rds")
[13:23:13.935]                     save_rds(obj, file)
[13:23:13.935]                   }
[13:23:13.935]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3UGFnn/.future/immediateConditions")
[13:23:13.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.935]                   {
[13:23:13.935]                     inherits <- base::inherits
[13:23:13.935]                     invokeRestart <- base::invokeRestart
[13:23:13.935]                     is.null <- base::is.null
[13:23:13.935]                     muffled <- FALSE
[13:23:13.935]                     if (inherits(cond, "message")) {
[13:23:13.935]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:13.935]                       if (muffled) 
[13:23:13.935]                         invokeRestart("muffleMessage")
[13:23:13.935]                     }
[13:23:13.935]                     else if (inherits(cond, "warning")) {
[13:23:13.935]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:13.935]                       if (muffled) 
[13:23:13.935]                         invokeRestart("muffleWarning")
[13:23:13.935]                     }
[13:23:13.935]                     else if (inherits(cond, "condition")) {
[13:23:13.935]                       if (!is.null(pattern)) {
[13:23:13.935]                         computeRestarts <- base::computeRestarts
[13:23:13.935]                         grepl <- base::grepl
[13:23:13.935]                         restarts <- computeRestarts(cond)
[13:23:13.935]                         for (restart in restarts) {
[13:23:13.935]                           name <- restart$name
[13:23:13.935]                           if (is.null(name)) 
[13:23:13.935]                             next
[13:23:13.935]                           if (!grepl(pattern, name)) 
[13:23:13.935]                             next
[13:23:13.935]                           invokeRestart(restart)
[13:23:13.935]                           muffled <- TRUE
[13:23:13.935]                           break
[13:23:13.935]                         }
[13:23:13.935]                       }
[13:23:13.935]                     }
[13:23:13.935]                     invisible(muffled)
[13:23:13.935]                   }
[13:23:13.935]                   muffleCondition(cond)
[13:23:13.935]                 })
[13:23:13.935]             }))
[13:23:13.935]             future::FutureResult(value = ...future.value$value, 
[13:23:13.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.935]                   ...future.rng), globalenv = if (FALSE) 
[13:23:13.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:13.935]                     ...future.globalenv.names))
[13:23:13.935]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:13.935]         }, condition = base::local({
[13:23:13.935]             c <- base::c
[13:23:13.935]             inherits <- base::inherits
[13:23:13.935]             invokeRestart <- base::invokeRestart
[13:23:13.935]             length <- base::length
[13:23:13.935]             list <- base::list
[13:23:13.935]             seq.int <- base::seq.int
[13:23:13.935]             signalCondition <- base::signalCondition
[13:23:13.935]             sys.calls <- base::sys.calls
[13:23:13.935]             `[[` <- base::`[[`
[13:23:13.935]             `+` <- base::`+`
[13:23:13.935]             `<<-` <- base::`<<-`
[13:23:13.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:13.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:13.935]                   3L)]
[13:23:13.935]             }
[13:23:13.935]             function(cond) {
[13:23:13.935]                 is_error <- inherits(cond, "error")
[13:23:13.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:13.935]                   NULL)
[13:23:13.935]                 if (is_error) {
[13:23:13.935]                   sessionInformation <- function() {
[13:23:13.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:13.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:13.935]                       search = base::search(), system = base::Sys.info())
[13:23:13.935]                   }
[13:23:13.935]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:13.935]                     cond$call), session = sessionInformation(), 
[13:23:13.935]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:13.935]                   signalCondition(cond)
[13:23:13.935]                 }
[13:23:13.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:13.935]                 "immediateCondition"))) {
[13:23:13.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:13.935]                   ...future.conditions[[length(...future.conditions) + 
[13:23:13.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:13.935]                   if (TRUE && !signal) {
[13:23:13.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.935]                     {
[13:23:13.935]                       inherits <- base::inherits
[13:23:13.935]                       invokeRestart <- base::invokeRestart
[13:23:13.935]                       is.null <- base::is.null
[13:23:13.935]                       muffled <- FALSE
[13:23:13.935]                       if (inherits(cond, "message")) {
[13:23:13.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.935]                         if (muffled) 
[13:23:13.935]                           invokeRestart("muffleMessage")
[13:23:13.935]                       }
[13:23:13.935]                       else if (inherits(cond, "warning")) {
[13:23:13.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.935]                         if (muffled) 
[13:23:13.935]                           invokeRestart("muffleWarning")
[13:23:13.935]                       }
[13:23:13.935]                       else if (inherits(cond, "condition")) {
[13:23:13.935]                         if (!is.null(pattern)) {
[13:23:13.935]                           computeRestarts <- base::computeRestarts
[13:23:13.935]                           grepl <- base::grepl
[13:23:13.935]                           restarts <- computeRestarts(cond)
[13:23:13.935]                           for (restart in restarts) {
[13:23:13.935]                             name <- restart$name
[13:23:13.935]                             if (is.null(name)) 
[13:23:13.935]                               next
[13:23:13.935]                             if (!grepl(pattern, name)) 
[13:23:13.935]                               next
[13:23:13.935]                             invokeRestart(restart)
[13:23:13.935]                             muffled <- TRUE
[13:23:13.935]                             break
[13:23:13.935]                           }
[13:23:13.935]                         }
[13:23:13.935]                       }
[13:23:13.935]                       invisible(muffled)
[13:23:13.935]                     }
[13:23:13.935]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.935]                   }
[13:23:13.935]                 }
[13:23:13.935]                 else {
[13:23:13.935]                   if (TRUE) {
[13:23:13.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:13.935]                     {
[13:23:13.935]                       inherits <- base::inherits
[13:23:13.935]                       invokeRestart <- base::invokeRestart
[13:23:13.935]                       is.null <- base::is.null
[13:23:13.935]                       muffled <- FALSE
[13:23:13.935]                       if (inherits(cond, "message")) {
[13:23:13.935]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:13.935]                         if (muffled) 
[13:23:13.935]                           invokeRestart("muffleMessage")
[13:23:13.935]                       }
[13:23:13.935]                       else if (inherits(cond, "warning")) {
[13:23:13.935]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:13.935]                         if (muffled) 
[13:23:13.935]                           invokeRestart("muffleWarning")
[13:23:13.935]                       }
[13:23:13.935]                       else if (inherits(cond, "condition")) {
[13:23:13.935]                         if (!is.null(pattern)) {
[13:23:13.935]                           computeRestarts <- base::computeRestarts
[13:23:13.935]                           grepl <- base::grepl
[13:23:13.935]                           restarts <- computeRestarts(cond)
[13:23:13.935]                           for (restart in restarts) {
[13:23:13.935]                             name <- restart$name
[13:23:13.935]                             if (is.null(name)) 
[13:23:13.935]                               next
[13:23:13.935]                             if (!grepl(pattern, name)) 
[13:23:13.935]                               next
[13:23:13.935]                             invokeRestart(restart)
[13:23:13.935]                             muffled <- TRUE
[13:23:13.935]                             break
[13:23:13.935]                           }
[13:23:13.935]                         }
[13:23:13.935]                       }
[13:23:13.935]                       invisible(muffled)
[13:23:13.935]                     }
[13:23:13.935]                     muffleCondition(cond, pattern = "^muffle")
[13:23:13.935]                   }
[13:23:13.935]                 }
[13:23:13.935]             }
[13:23:13.935]         }))
[13:23:13.935]     }, error = function(ex) {
[13:23:13.935]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:13.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:13.935]                 ...future.rng), started = ...future.startTime, 
[13:23:13.935]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:13.935]             version = "1.8"), class = "FutureResult")
[13:23:13.935]     }, finally = {
[13:23:13.935]         if (!identical(...future.workdir, getwd())) 
[13:23:13.935]             setwd(...future.workdir)
[13:23:13.935]         {
[13:23:13.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:13.935]                 ...future.oldOptions$nwarnings <- NULL
[13:23:13.935]             }
[13:23:13.935]             base::options(...future.oldOptions)
[13:23:13.935]             if (.Platform$OS.type == "windows") {
[13:23:13.935]                 old_names <- names(...future.oldEnvVars)
[13:23:13.935]                 envs <- base::Sys.getenv()
[13:23:13.935]                 names <- names(envs)
[13:23:13.935]                 common <- intersect(names, old_names)
[13:23:13.935]                 added <- setdiff(names, old_names)
[13:23:13.935]                 removed <- setdiff(old_names, names)
[13:23:13.935]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:13.935]                   envs[common]]
[13:23:13.935]                 NAMES <- toupper(changed)
[13:23:13.935]                 args <- list()
[13:23:13.935]                 for (kk in seq_along(NAMES)) {
[13:23:13.935]                   name <- changed[[kk]]
[13:23:13.935]                   NAME <- NAMES[[kk]]
[13:23:13.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.935]                     next
[13:23:13.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.935]                 }
[13:23:13.935]                 NAMES <- toupper(added)
[13:23:13.935]                 for (kk in seq_along(NAMES)) {
[13:23:13.935]                   name <- added[[kk]]
[13:23:13.935]                   NAME <- NAMES[[kk]]
[13:23:13.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.935]                     next
[13:23:13.935]                   args[[name]] <- ""
[13:23:13.935]                 }
[13:23:13.935]                 NAMES <- toupper(removed)
[13:23:13.935]                 for (kk in seq_along(NAMES)) {
[13:23:13.935]                   name <- removed[[kk]]
[13:23:13.935]                   NAME <- NAMES[[kk]]
[13:23:13.935]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:13.935]                     next
[13:23:13.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:13.935]                 }
[13:23:13.935]                 if (length(args) > 0) 
[13:23:13.935]                   base::do.call(base::Sys.setenv, args = args)
[13:23:13.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:13.935]             }
[13:23:13.935]             else {
[13:23:13.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:13.935]             }
[13:23:13.935]             {
[13:23:13.935]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:13.935]                   0L) {
[13:23:13.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:13.935]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:13.935]                   base::options(opts)
[13:23:13.935]                 }
[13:23:13.935]                 {
[13:23:13.935]                   {
[13:23:13.935]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:13.935]                     NULL
[13:23:13.935]                   }
[13:23:13.935]                   options(future.plan = NULL)
[13:23:13.935]                   if (is.na(NA_character_)) 
[13:23:13.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:13.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:13.935]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:13.935]                     envir = parent.frame()) 
[13:23:13.935]                   {
[13:23:13.935]                     default_workers <- missing(workers)
[13:23:13.935]                     if (is.function(workers)) 
[13:23:13.935]                       workers <- workers()
[13:23:13.935]                     workers <- structure(as.integer(workers), 
[13:23:13.935]                       class = class(workers))
[13:23:13.935]                     stop_if_not(is.finite(workers), workers >= 
[13:23:13.935]                       1L)
[13:23:13.935]                     if ((workers == 1L && !inherits(workers, 
[13:23:13.935]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:13.935]                       if (default_workers) 
[13:23:13.935]                         supportsMulticore(warn = TRUE)
[13:23:13.935]                       return(sequential(..., envir = envir))
[13:23:13.935]                     }
[13:23:13.935]                     oopts <- options(mc.cores = workers)
[13:23:13.935]                     on.exit(options(oopts))
[13:23:13.935]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:13.935]                       envir = envir)
[13:23:13.935]                     if (!future$lazy) 
[13:23:13.935]                       future <- run(future)
[13:23:13.935]                     invisible(future)
[13:23:13.935]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:13.935]                 }
[13:23:13.935]             }
[13:23:13.935]         }
[13:23:13.935]     })
[13:23:13.935]     if (TRUE) {
[13:23:13.935]         base::sink(type = "output", split = FALSE)
[13:23:13.935]         if (TRUE) {
[13:23:13.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:13.935]         }
[13:23:13.935]         else {
[13:23:13.935]             ...future.result["stdout"] <- base::list(NULL)
[13:23:13.935]         }
[13:23:13.935]         base::close(...future.stdout)
[13:23:13.935]         ...future.stdout <- NULL
[13:23:13.935]     }
[13:23:13.935]     ...future.result$conditions <- ...future.conditions
[13:23:13.935]     ...future.result$finished <- base::Sys.time()
[13:23:13.935]     ...future.result
[13:23:13.935] }
[13:23:13.937] assign_globals() ...
[13:23:13.937] List of 3
[13:23:13.937]  $ outer_function:function (x)  
[13:23:13.937]  $ map           :function (.x, .f, ...)  
[13:23:13.937]  $ inner_function:function (x)  
[13:23:13.937]  - attr(*, "where")=List of 3
[13:23:13.937]   ..$ outer_function:<environment: R_EmptyEnv> 
[13:23:13.937]   ..$ map           :<environment: R_EmptyEnv> 
[13:23:13.937]   ..$ inner_function:<environment: R_EmptyEnv> 
[13:23:13.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:13.937]  - attr(*, "resolved")= logi FALSE
[13:23:13.937]  - attr(*, "total_size")= num 7704
[13:23:13.937]  - attr(*, "already-done")= logi TRUE
[13:23:13.941] - reassign environment for ‘outer_function’
[13:23:13.942] - copied ‘outer_function’ to environment
[13:23:13.942] - reassign environment for ‘map’
[13:23:13.942] - copied ‘map’ to environment
[13:23:13.942] - reassign environment for ‘inner_function’
[13:23:13.942] - copied ‘inner_function’ to environment
[13:23:13.942] assign_globals() ... done
[13:23:13.942] requestCore(): workers = 2
[13:23:13.945] MulticoreFuture started
[13:23:13.945] - Launch lazy future ... done
[13:23:13.946] run() for ‘MulticoreFuture’ ... done
[13:23:13.946] result() for MulticoreFuture ...
[13:23:13.946] plan(): Setting new future strategy stack:
[13:23:13.946] List of future strategies:
[13:23:13.946] 1. sequential:
[13:23:13.946]    - args: function (..., envir = parent.frame())
[13:23:13.946]    - tweaked: FALSE
[13:23:13.946]    - call: NULL
[13:23:13.947] plan(): nbrOfWorkers() = 1
[13:23:13.950] plan(): Setting new future strategy stack:
[13:23:13.950] List of future strategies:
[13:23:13.950] 1. multicore:
[13:23:13.950]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:13.950]    - tweaked: FALSE
[13:23:13.950]    - call: plan(strategy)
[13:23:13.956] plan(): nbrOfWorkers() = 2
[13:23:13.957] result() for MulticoreFuture ...
[13:23:13.957] result() for MulticoreFuture ... done
[13:23:13.957] result() for MulticoreFuture ... done
[13:23:13.957] result() for MulticoreFuture ...
[13:23:13.958] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[13:23:13.960] plan(): Setting new future strategy stack:
[13:23:13.961] List of future strategies:
[13:23:13.961] 1. multisession:
[13:23:13.961]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:13.961]    - tweaked: FALSE
[13:23:13.961]    - call: plan(strategy)
[13:23:13.961] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:23:13.961] multisession:
[13:23:13.961] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:23:13.961] - tweaked: FALSE
[13:23:13.961] - call: plan(strategy)
[13:23:13.969] getGlobalsAndPackages() ...
[13:23:13.970] Not searching for globals
[13:23:13.970] - globals: [0] <none>
[13:23:13.970] getGlobalsAndPackages() ... DONE
[13:23:13.971] [local output] makeClusterPSOCK() ...
[13:23:14.027] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:23:14.028] [local output] Base port: 11726
[13:23:14.029] [local output] Getting setup options for 2 cluster nodes ...
[13:23:14.029] [local output]  - Node 1 of 2 ...
[13:23:14.029] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:14.030] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp3UGFnn/worker.rank=1.parallelly.parent=85130.14c8a2e42bc4.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp3UGFnn/worker.rank=1.parallelly.parent=85130.14c8a2e42bc4.pid")'’
[13:23:14.230] - Possible to infer worker's PID: TRUE
[13:23:14.230] [local output] Rscript port: 11726

[13:23:14.231] [local output]  - Node 2 of 2 ...
[13:23:14.231] [local output] localMachine=TRUE => revtunnel=FALSE

[13:23:14.232] [local output] Rscript port: 11726

[13:23:14.232] [local output] Getting setup options for 2 cluster nodes ... done
[13:23:14.232] [local output]  - Parallel setup requested for some PSOCK nodes
[13:23:14.233] [local output] Setting up PSOCK nodes in parallel
[13:23:14.233] List of 36
[13:23:14.233]  $ worker          : chr "localhost"
[13:23:14.233]   ..- attr(*, "localhost")= logi TRUE
[13:23:14.233]  $ master          : chr "localhost"
[13:23:14.233]  $ port            : int 11726
[13:23:14.233]  $ connectTimeout  : num 120
[13:23:14.233]  $ timeout         : num 2592000
[13:23:14.233]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:23:14.233]  $ homogeneous     : logi TRUE
[13:23:14.233]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:23:14.233]  $ rscript_envs    : NULL
[13:23:14.233]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:14.233]  $ rscript_startup : NULL
[13:23:14.233]  $ rscript_sh      : chr "sh"
[13:23:14.233]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:14.233]  $ methods         : logi TRUE
[13:23:14.233]  $ socketOptions   : chr "no-delay"
[13:23:14.233]  $ useXDR          : logi FALSE
[13:23:14.233]  $ outfile         : chr "/dev/null"
[13:23:14.233]  $ renice          : int NA
[13:23:14.233]  $ rshcmd          : NULL
[13:23:14.233]  $ user            : chr(0) 
[13:23:14.233]  $ revtunnel       : logi FALSE
[13:23:14.233]  $ rshlogfile      : NULL
[13:23:14.233]  $ rshopts         : chr(0) 
[13:23:14.233]  $ rank            : int 1
[13:23:14.233]  $ manual          : logi FALSE
[13:23:14.233]  $ dryrun          : logi FALSE
[13:23:14.233]  $ quiet           : logi FALSE
[13:23:14.233]  $ setup_strategy  : chr "parallel"
[13:23:14.233]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:14.233]  $ pidfile         : chr "/tmp/Rtmp3UGFnn/worker.rank=1.parallelly.parent=85130.14c8a2e42bc4.pid"
[13:23:14.233]  $ rshcmd_label    : NULL
[13:23:14.233]  $ rsh_call        : NULL
[13:23:14.233]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:23:14.233]  $ localMachine    : logi TRUE
[13:23:14.233]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:23:14.233]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:23:14.233]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:23:14.233]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:23:14.233]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:23:14.233]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:23:14.233]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:23:14.233]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:23:14.233]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:23:14.233]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:23:14.233]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:23:14.233]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:23:14.233]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:23:14.233]  $ arguments       :List of 28
[13:23:14.233]   ..$ worker          : chr "localhost"
[13:23:14.233]   ..$ master          : NULL
[13:23:14.233]   ..$ port            : int 11726
[13:23:14.233]   ..$ connectTimeout  : num 120
[13:23:14.233]   ..$ timeout         : num 2592000
[13:23:14.233]   ..$ rscript         : NULL
[13:23:14.233]   ..$ homogeneous     : NULL
[13:23:14.233]   ..$ rscript_args    : NULL
[13:23:14.233]   ..$ rscript_envs    : NULL
[13:23:14.233]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:23:14.233]   ..$ rscript_startup : NULL
[13:23:14.233]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:23:14.233]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:23:14.233]   ..$ methods         : logi TRUE
[13:23:14.233]   ..$ socketOptions   : chr "no-delay"
[13:23:14.233]   ..$ useXDR          : logi FALSE
[13:23:14.233]   ..$ outfile         : chr "/dev/null"
[13:23:14.233]   ..$ renice          : int NA
[13:23:14.233]   ..$ rshcmd          : NULL
[13:23:14.233]   ..$ user            : NULL
[13:23:14.233]   ..$ revtunnel       : logi NA
[13:23:14.233]   ..$ rshlogfile      : NULL
[13:23:14.233]   ..$ rshopts         : NULL
[13:23:14.233]   ..$ rank            : int 1
[13:23:14.233]   ..$ manual          : logi FALSE
[13:23:14.233]   ..$ dryrun          : logi FALSE
[13:23:14.233]   ..$ quiet           : logi FALSE
[13:23:14.233]   ..$ setup_strategy  : chr "parallel"
[13:23:14.233]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:23:14.251] [local output] System call to launch all workers:
[13:23:14.251] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp3UGFnn/worker.rank=1.parallelly.parent=85130.14c8a2e42bc4.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11726 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:23:14.251] [local output] Starting PSOCK main server
[13:23:14.257] [local output] Workers launched
[13:23:14.257] [local output] Waiting for workers to connect back
[13:23:14.258]  - [local output] 0 workers out of 2 ready
[13:23:14.514]  - [local output] 0 workers out of 2 ready
[13:23:14.515]  - [local output] 1 workers out of 2 ready
[13:23:14.515]  - [local output] 2 workers out of 2 ready
[13:23:14.515] [local output] Launching of workers completed
[13:23:14.515] [local output] Collecting session information from workers
[13:23:14.516] [local output]  - Worker #1 of 2
[13:23:14.517] [local output]  - Worker #2 of 2
[13:23:14.517] [local output] makeClusterPSOCK() ... done
[13:23:14.529] Packages needed by the future expression (n = 0): <none>
[13:23:14.529] Packages needed by future strategies (n = 0): <none>
[13:23:14.530] {
[13:23:14.530]     {
[13:23:14.530]         {
[13:23:14.530]             ...future.startTime <- base::Sys.time()
[13:23:14.530]             {
[13:23:14.530]                 {
[13:23:14.530]                   {
[13:23:14.530]                     {
[13:23:14.530]                       base::local({
[13:23:14.530]                         has_future <- base::requireNamespace("future", 
[13:23:14.530]                           quietly = TRUE)
[13:23:14.530]                         if (has_future) {
[13:23:14.530]                           ns <- base::getNamespace("future")
[13:23:14.530]                           version <- ns[[".package"]][["version"]]
[13:23:14.530]                           if (is.null(version)) 
[13:23:14.530]                             version <- utils::packageVersion("future")
[13:23:14.530]                         }
[13:23:14.530]                         else {
[13:23:14.530]                           version <- NULL
[13:23:14.530]                         }
[13:23:14.530]                         if (!has_future || version < "1.8.0") {
[13:23:14.530]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.530]                             "", base::R.version$version.string), 
[13:23:14.530]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:14.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:14.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.530]                               "release", "version")], collapse = " "), 
[13:23:14.530]                             hostname = base::Sys.info()[["nodename"]])
[13:23:14.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.530]                             info)
[13:23:14.530]                           info <- base::paste(info, collapse = "; ")
[13:23:14.530]                           if (!has_future) {
[13:23:14.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.530]                               info)
[13:23:14.530]                           }
[13:23:14.530]                           else {
[13:23:14.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.530]                               info, version)
[13:23:14.530]                           }
[13:23:14.530]                           base::stop(msg)
[13:23:14.530]                         }
[13:23:14.530]                       })
[13:23:14.530]                     }
[13:23:14.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.530]                     base::options(mc.cores = 1L)
[13:23:14.530]                   }
[13:23:14.530]                   options(future.plan = NULL)
[13:23:14.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.530]                 }
[13:23:14.530]                 ...future.workdir <- getwd()
[13:23:14.530]             }
[13:23:14.530]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.530]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.530]         }
[13:23:14.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.530]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.530]             base::names(...future.oldOptions))
[13:23:14.530]     }
[13:23:14.530]     if (FALSE) {
[13:23:14.530]     }
[13:23:14.530]     else {
[13:23:14.530]         if (TRUE) {
[13:23:14.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.530]                 open = "w")
[13:23:14.530]         }
[13:23:14.530]         else {
[13:23:14.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.530]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.530]         }
[13:23:14.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.530]             base::sink(type = "output", split = FALSE)
[13:23:14.530]             base::close(...future.stdout)
[13:23:14.530]         }, add = TRUE)
[13:23:14.530]     }
[13:23:14.530]     ...future.frame <- base::sys.nframe()
[13:23:14.530]     ...future.conditions <- base::list()
[13:23:14.530]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.530]     if (FALSE) {
[13:23:14.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.530]     }
[13:23:14.530]     ...future.result <- base::tryCatch({
[13:23:14.530]         base::withCallingHandlers({
[13:23:14.530]             ...future.value <- base::withVisible(base::local({
[13:23:14.530]                 ...future.makeSendCondition <- base::local({
[13:23:14.530]                   sendCondition <- NULL
[13:23:14.530]                   function(frame = 1L) {
[13:23:14.530]                     if (is.function(sendCondition)) 
[13:23:14.530]                       return(sendCondition)
[13:23:14.530]                     ns <- getNamespace("parallel")
[13:23:14.530]                     if (exists("sendData", mode = "function", 
[13:23:14.530]                       envir = ns)) {
[13:23:14.530]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.530]                         envir = ns)
[13:23:14.530]                       envir <- sys.frame(frame)
[13:23:14.530]                       master <- NULL
[13:23:14.530]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.530]                         !identical(envir, emptyenv())) {
[13:23:14.530]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.530]                           inherits = FALSE)) {
[13:23:14.530]                           master <- get("master", mode = "list", 
[13:23:14.530]                             envir = envir, inherits = FALSE)
[13:23:14.530]                           if (inherits(master, c("SOCKnode", 
[13:23:14.530]                             "SOCK0node"))) {
[13:23:14.530]                             sendCondition <<- function(cond) {
[13:23:14.530]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.530]                                 success = TRUE)
[13:23:14.530]                               parallel_sendData(master, data)
[13:23:14.530]                             }
[13:23:14.530]                             return(sendCondition)
[13:23:14.530]                           }
[13:23:14.530]                         }
[13:23:14.530]                         frame <- frame + 1L
[13:23:14.530]                         envir <- sys.frame(frame)
[13:23:14.530]                       }
[13:23:14.530]                     }
[13:23:14.530]                     sendCondition <<- function(cond) NULL
[13:23:14.530]                   }
[13:23:14.530]                 })
[13:23:14.530]                 withCallingHandlers({
[13:23:14.530]                   NA
[13:23:14.530]                 }, immediateCondition = function(cond) {
[13:23:14.530]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.530]                   sendCondition(cond)
[13:23:14.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.530]                   {
[13:23:14.530]                     inherits <- base::inherits
[13:23:14.530]                     invokeRestart <- base::invokeRestart
[13:23:14.530]                     is.null <- base::is.null
[13:23:14.530]                     muffled <- FALSE
[13:23:14.530]                     if (inherits(cond, "message")) {
[13:23:14.530]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.530]                       if (muffled) 
[13:23:14.530]                         invokeRestart("muffleMessage")
[13:23:14.530]                     }
[13:23:14.530]                     else if (inherits(cond, "warning")) {
[13:23:14.530]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.530]                       if (muffled) 
[13:23:14.530]                         invokeRestart("muffleWarning")
[13:23:14.530]                     }
[13:23:14.530]                     else if (inherits(cond, "condition")) {
[13:23:14.530]                       if (!is.null(pattern)) {
[13:23:14.530]                         computeRestarts <- base::computeRestarts
[13:23:14.530]                         grepl <- base::grepl
[13:23:14.530]                         restarts <- computeRestarts(cond)
[13:23:14.530]                         for (restart in restarts) {
[13:23:14.530]                           name <- restart$name
[13:23:14.530]                           if (is.null(name)) 
[13:23:14.530]                             next
[13:23:14.530]                           if (!grepl(pattern, name)) 
[13:23:14.530]                             next
[13:23:14.530]                           invokeRestart(restart)
[13:23:14.530]                           muffled <- TRUE
[13:23:14.530]                           break
[13:23:14.530]                         }
[13:23:14.530]                       }
[13:23:14.530]                     }
[13:23:14.530]                     invisible(muffled)
[13:23:14.530]                   }
[13:23:14.530]                   muffleCondition(cond)
[13:23:14.530]                 })
[13:23:14.530]             }))
[13:23:14.530]             future::FutureResult(value = ...future.value$value, 
[13:23:14.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.530]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.530]                     ...future.globalenv.names))
[13:23:14.530]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.530]         }, condition = base::local({
[13:23:14.530]             c <- base::c
[13:23:14.530]             inherits <- base::inherits
[13:23:14.530]             invokeRestart <- base::invokeRestart
[13:23:14.530]             length <- base::length
[13:23:14.530]             list <- base::list
[13:23:14.530]             seq.int <- base::seq.int
[13:23:14.530]             signalCondition <- base::signalCondition
[13:23:14.530]             sys.calls <- base::sys.calls
[13:23:14.530]             `[[` <- base::`[[`
[13:23:14.530]             `+` <- base::`+`
[13:23:14.530]             `<<-` <- base::`<<-`
[13:23:14.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.530]                   3L)]
[13:23:14.530]             }
[13:23:14.530]             function(cond) {
[13:23:14.530]                 is_error <- inherits(cond, "error")
[13:23:14.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.530]                   NULL)
[13:23:14.530]                 if (is_error) {
[13:23:14.530]                   sessionInformation <- function() {
[13:23:14.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.530]                       search = base::search(), system = base::Sys.info())
[13:23:14.530]                   }
[13:23:14.530]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.530]                     cond$call), session = sessionInformation(), 
[13:23:14.530]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.530]                   signalCondition(cond)
[13:23:14.530]                 }
[13:23:14.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.530]                 "immediateCondition"))) {
[13:23:14.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.530]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.530]                   if (TRUE && !signal) {
[13:23:14.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.530]                     {
[13:23:14.530]                       inherits <- base::inherits
[13:23:14.530]                       invokeRestart <- base::invokeRestart
[13:23:14.530]                       is.null <- base::is.null
[13:23:14.530]                       muffled <- FALSE
[13:23:14.530]                       if (inherits(cond, "message")) {
[13:23:14.530]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.530]                         if (muffled) 
[13:23:14.530]                           invokeRestart("muffleMessage")
[13:23:14.530]                       }
[13:23:14.530]                       else if (inherits(cond, "warning")) {
[13:23:14.530]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.530]                         if (muffled) 
[13:23:14.530]                           invokeRestart("muffleWarning")
[13:23:14.530]                       }
[13:23:14.530]                       else if (inherits(cond, "condition")) {
[13:23:14.530]                         if (!is.null(pattern)) {
[13:23:14.530]                           computeRestarts <- base::computeRestarts
[13:23:14.530]                           grepl <- base::grepl
[13:23:14.530]                           restarts <- computeRestarts(cond)
[13:23:14.530]                           for (restart in restarts) {
[13:23:14.530]                             name <- restart$name
[13:23:14.530]                             if (is.null(name)) 
[13:23:14.530]                               next
[13:23:14.530]                             if (!grepl(pattern, name)) 
[13:23:14.530]                               next
[13:23:14.530]                             invokeRestart(restart)
[13:23:14.530]                             muffled <- TRUE
[13:23:14.530]                             break
[13:23:14.530]                           }
[13:23:14.530]                         }
[13:23:14.530]                       }
[13:23:14.530]                       invisible(muffled)
[13:23:14.530]                     }
[13:23:14.530]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.530]                   }
[13:23:14.530]                 }
[13:23:14.530]                 else {
[13:23:14.530]                   if (TRUE) {
[13:23:14.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.530]                     {
[13:23:14.530]                       inherits <- base::inherits
[13:23:14.530]                       invokeRestart <- base::invokeRestart
[13:23:14.530]                       is.null <- base::is.null
[13:23:14.530]                       muffled <- FALSE
[13:23:14.530]                       if (inherits(cond, "message")) {
[13:23:14.530]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.530]                         if (muffled) 
[13:23:14.530]                           invokeRestart("muffleMessage")
[13:23:14.530]                       }
[13:23:14.530]                       else if (inherits(cond, "warning")) {
[13:23:14.530]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.530]                         if (muffled) 
[13:23:14.530]                           invokeRestart("muffleWarning")
[13:23:14.530]                       }
[13:23:14.530]                       else if (inherits(cond, "condition")) {
[13:23:14.530]                         if (!is.null(pattern)) {
[13:23:14.530]                           computeRestarts <- base::computeRestarts
[13:23:14.530]                           grepl <- base::grepl
[13:23:14.530]                           restarts <- computeRestarts(cond)
[13:23:14.530]                           for (restart in restarts) {
[13:23:14.530]                             name <- restart$name
[13:23:14.530]                             if (is.null(name)) 
[13:23:14.530]                               next
[13:23:14.530]                             if (!grepl(pattern, name)) 
[13:23:14.530]                               next
[13:23:14.530]                             invokeRestart(restart)
[13:23:14.530]                             muffled <- TRUE
[13:23:14.530]                             break
[13:23:14.530]                           }
[13:23:14.530]                         }
[13:23:14.530]                       }
[13:23:14.530]                       invisible(muffled)
[13:23:14.530]                     }
[13:23:14.530]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.530]                   }
[13:23:14.530]                 }
[13:23:14.530]             }
[13:23:14.530]         }))
[13:23:14.530]     }, error = function(ex) {
[13:23:14.530]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.530]                 ...future.rng), started = ...future.startTime, 
[13:23:14.530]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.530]             version = "1.8"), class = "FutureResult")
[13:23:14.530]     }, finally = {
[13:23:14.530]         if (!identical(...future.workdir, getwd())) 
[13:23:14.530]             setwd(...future.workdir)
[13:23:14.530]         {
[13:23:14.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.530]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.530]             }
[13:23:14.530]             base::options(...future.oldOptions)
[13:23:14.530]             if (.Platform$OS.type == "windows") {
[13:23:14.530]                 old_names <- names(...future.oldEnvVars)
[13:23:14.530]                 envs <- base::Sys.getenv()
[13:23:14.530]                 names <- names(envs)
[13:23:14.530]                 common <- intersect(names, old_names)
[13:23:14.530]                 added <- setdiff(names, old_names)
[13:23:14.530]                 removed <- setdiff(old_names, names)
[13:23:14.530]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.530]                   envs[common]]
[13:23:14.530]                 NAMES <- toupper(changed)
[13:23:14.530]                 args <- list()
[13:23:14.530]                 for (kk in seq_along(NAMES)) {
[13:23:14.530]                   name <- changed[[kk]]
[13:23:14.530]                   NAME <- NAMES[[kk]]
[13:23:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.530]                     next
[13:23:14.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.530]                 }
[13:23:14.530]                 NAMES <- toupper(added)
[13:23:14.530]                 for (kk in seq_along(NAMES)) {
[13:23:14.530]                   name <- added[[kk]]
[13:23:14.530]                   NAME <- NAMES[[kk]]
[13:23:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.530]                     next
[13:23:14.530]                   args[[name]] <- ""
[13:23:14.530]                 }
[13:23:14.530]                 NAMES <- toupper(removed)
[13:23:14.530]                 for (kk in seq_along(NAMES)) {
[13:23:14.530]                   name <- removed[[kk]]
[13:23:14.530]                   NAME <- NAMES[[kk]]
[13:23:14.530]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.530]                     next
[13:23:14.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.530]                 }
[13:23:14.530]                 if (length(args) > 0) 
[13:23:14.530]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.530]             }
[13:23:14.530]             else {
[13:23:14.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.530]             }
[13:23:14.530]             {
[13:23:14.530]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.530]                   0L) {
[13:23:14.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.530]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.530]                   base::options(opts)
[13:23:14.530]                 }
[13:23:14.530]                 {
[13:23:14.530]                   {
[13:23:14.530]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.530]                     NULL
[13:23:14.530]                   }
[13:23:14.530]                   options(future.plan = NULL)
[13:23:14.530]                   if (is.na(NA_character_)) 
[13:23:14.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.530]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.530]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.530]                     envir = parent.frame()) 
[13:23:14.530]                   {
[13:23:14.530]                     if (is.function(workers)) 
[13:23:14.530]                       workers <- workers()
[13:23:14.530]                     workers <- structure(as.integer(workers), 
[13:23:14.530]                       class = class(workers))
[13:23:14.530]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.530]                       workers >= 1)
[13:23:14.530]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.530]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.530]                     }
[13:23:14.530]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.530]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.530]                       envir = envir)
[13:23:14.530]                     if (!future$lazy) 
[13:23:14.530]                       future <- run(future)
[13:23:14.530]                     invisible(future)
[13:23:14.530]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.530]                 }
[13:23:14.530]             }
[13:23:14.530]         }
[13:23:14.530]     })
[13:23:14.530]     if (TRUE) {
[13:23:14.530]         base::sink(type = "output", split = FALSE)
[13:23:14.530]         if (TRUE) {
[13:23:14.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.530]         }
[13:23:14.530]         else {
[13:23:14.530]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.530]         }
[13:23:14.530]         base::close(...future.stdout)
[13:23:14.530]         ...future.stdout <- NULL
[13:23:14.530]     }
[13:23:14.530]     ...future.result$conditions <- ...future.conditions
[13:23:14.530]     ...future.result$finished <- base::Sys.time()
[13:23:14.530]     ...future.result
[13:23:14.530] }
[13:23:14.587] MultisessionFuture started
[13:23:14.588] result() for ClusterFuture ...
[13:23:14.589] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.589] - Validating connection of MultisessionFuture
[13:23:14.636] - received message: FutureResult
[13:23:14.637] - Received FutureResult
[13:23:14.637] - Erased future from FutureRegistry
[13:23:14.637] result() for ClusterFuture ...
[13:23:14.637] - result already collected: FutureResult
[13:23:14.637] result() for ClusterFuture ... done
[13:23:14.637] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:14.637] result() for ClusterFuture ... done
[13:23:14.638] result() for ClusterFuture ...
[13:23:14.638] - result already collected: FutureResult
[13:23:14.638] result() for ClusterFuture ... done
[13:23:14.638] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:23:14.642] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[13:23:14.642] getGlobalsAndPackages() ...
[13:23:14.642] Searching for globals...
[13:23:14.644] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:14.645] Searching for globals ... DONE
[13:23:14.645] Resolving globals: FALSE
[13:23:14.645] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:14.646] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:14.646] - globals: [2] ‘weight’, ‘group’
[13:23:14.646] - packages: [1] ‘stats’
[13:23:14.646] getGlobalsAndPackages() ... DONE
[13:23:14.647] run() for ‘Future’ ...
[13:23:14.647] - state: ‘created’
[13:23:14.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:14.662] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:14.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:14.662]   - Field: ‘node’
[13:23:14.663]   - Field: ‘label’
[13:23:14.663]   - Field: ‘local’
[13:23:14.663]   - Field: ‘owner’
[13:23:14.663]   - Field: ‘envir’
[13:23:14.663]   - Field: ‘workers’
[13:23:14.663]   - Field: ‘packages’
[13:23:14.663]   - Field: ‘gc’
[13:23:14.663]   - Field: ‘conditions’
[13:23:14.663]   - Field: ‘persistent’
[13:23:14.663]   - Field: ‘expr’
[13:23:14.664]   - Field: ‘uuid’
[13:23:14.664]   - Field: ‘seed’
[13:23:14.664]   - Field: ‘version’
[13:23:14.664]   - Field: ‘result’
[13:23:14.664]   - Field: ‘asynchronous’
[13:23:14.664]   - Field: ‘calls’
[13:23:14.664]   - Field: ‘globals’
[13:23:14.664]   - Field: ‘stdout’
[13:23:14.665]   - Field: ‘earlySignal’
[13:23:14.665]   - Field: ‘lazy’
[13:23:14.665]   - Field: ‘state’
[13:23:14.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:14.665] - Launch lazy future ...
[13:23:14.665] Packages needed by the future expression (n = 1): ‘stats’
[13:23:14.666] Packages needed by future strategies (n = 0): <none>
[13:23:14.666] {
[13:23:14.666]     {
[13:23:14.666]         {
[13:23:14.666]             ...future.startTime <- base::Sys.time()
[13:23:14.666]             {
[13:23:14.666]                 {
[13:23:14.666]                   {
[13:23:14.666]                     {
[13:23:14.666]                       {
[13:23:14.666]                         base::local({
[13:23:14.666]                           has_future <- base::requireNamespace("future", 
[13:23:14.666]                             quietly = TRUE)
[13:23:14.666]                           if (has_future) {
[13:23:14.666]                             ns <- base::getNamespace("future")
[13:23:14.666]                             version <- ns[[".package"]][["version"]]
[13:23:14.666]                             if (is.null(version)) 
[13:23:14.666]                               version <- utils::packageVersion("future")
[13:23:14.666]                           }
[13:23:14.666]                           else {
[13:23:14.666]                             version <- NULL
[13:23:14.666]                           }
[13:23:14.666]                           if (!has_future || version < "1.8.0") {
[13:23:14.666]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.666]                               "", base::R.version$version.string), 
[13:23:14.666]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:14.666]                                 base::R.version$platform, 8 * 
[13:23:14.666]                                   base::.Machine$sizeof.pointer), 
[13:23:14.666]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.666]                                 "release", "version")], collapse = " "), 
[13:23:14.666]                               hostname = base::Sys.info()[["nodename"]])
[13:23:14.666]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.666]                               info)
[13:23:14.666]                             info <- base::paste(info, collapse = "; ")
[13:23:14.666]                             if (!has_future) {
[13:23:14.666]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.666]                                 info)
[13:23:14.666]                             }
[13:23:14.666]                             else {
[13:23:14.666]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.666]                                 info, version)
[13:23:14.666]                             }
[13:23:14.666]                             base::stop(msg)
[13:23:14.666]                           }
[13:23:14.666]                         })
[13:23:14.666]                       }
[13:23:14.666]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.666]                       base::options(mc.cores = 1L)
[13:23:14.666]                     }
[13:23:14.666]                     base::local({
[13:23:14.666]                       for (pkg in "stats") {
[13:23:14.666]                         base::loadNamespace(pkg)
[13:23:14.666]                         base::library(pkg, character.only = TRUE)
[13:23:14.666]                       }
[13:23:14.666]                     })
[13:23:14.666]                   }
[13:23:14.666]                   options(future.plan = NULL)
[13:23:14.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.666]                 }
[13:23:14.666]                 ...future.workdir <- getwd()
[13:23:14.666]             }
[13:23:14.666]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.666]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.666]         }
[13:23:14.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.666]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.666]             base::names(...future.oldOptions))
[13:23:14.666]     }
[13:23:14.666]     if (FALSE) {
[13:23:14.666]     }
[13:23:14.666]     else {
[13:23:14.666]         if (TRUE) {
[13:23:14.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.666]                 open = "w")
[13:23:14.666]         }
[13:23:14.666]         else {
[13:23:14.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.666]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.666]         }
[13:23:14.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.666]             base::sink(type = "output", split = FALSE)
[13:23:14.666]             base::close(...future.stdout)
[13:23:14.666]         }, add = TRUE)
[13:23:14.666]     }
[13:23:14.666]     ...future.frame <- base::sys.nframe()
[13:23:14.666]     ...future.conditions <- base::list()
[13:23:14.666]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.666]     if (FALSE) {
[13:23:14.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.666]     }
[13:23:14.666]     ...future.result <- base::tryCatch({
[13:23:14.666]         base::withCallingHandlers({
[13:23:14.666]             ...future.value <- base::withVisible(base::local({
[13:23:14.666]                 ...future.makeSendCondition <- base::local({
[13:23:14.666]                   sendCondition <- NULL
[13:23:14.666]                   function(frame = 1L) {
[13:23:14.666]                     if (is.function(sendCondition)) 
[13:23:14.666]                       return(sendCondition)
[13:23:14.666]                     ns <- getNamespace("parallel")
[13:23:14.666]                     if (exists("sendData", mode = "function", 
[13:23:14.666]                       envir = ns)) {
[13:23:14.666]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.666]                         envir = ns)
[13:23:14.666]                       envir <- sys.frame(frame)
[13:23:14.666]                       master <- NULL
[13:23:14.666]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.666]                         !identical(envir, emptyenv())) {
[13:23:14.666]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.666]                           inherits = FALSE)) {
[13:23:14.666]                           master <- get("master", mode = "list", 
[13:23:14.666]                             envir = envir, inherits = FALSE)
[13:23:14.666]                           if (inherits(master, c("SOCKnode", 
[13:23:14.666]                             "SOCK0node"))) {
[13:23:14.666]                             sendCondition <<- function(cond) {
[13:23:14.666]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.666]                                 success = TRUE)
[13:23:14.666]                               parallel_sendData(master, data)
[13:23:14.666]                             }
[13:23:14.666]                             return(sendCondition)
[13:23:14.666]                           }
[13:23:14.666]                         }
[13:23:14.666]                         frame <- frame + 1L
[13:23:14.666]                         envir <- sys.frame(frame)
[13:23:14.666]                       }
[13:23:14.666]                     }
[13:23:14.666]                     sendCondition <<- function(cond) NULL
[13:23:14.666]                   }
[13:23:14.666]                 })
[13:23:14.666]                 withCallingHandlers({
[13:23:14.666]                   {
[13:23:14.666]                     lm(weight ~ group - 1)
[13:23:14.666]                   }
[13:23:14.666]                 }, immediateCondition = function(cond) {
[13:23:14.666]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.666]                   sendCondition(cond)
[13:23:14.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.666]                   {
[13:23:14.666]                     inherits <- base::inherits
[13:23:14.666]                     invokeRestart <- base::invokeRestart
[13:23:14.666]                     is.null <- base::is.null
[13:23:14.666]                     muffled <- FALSE
[13:23:14.666]                     if (inherits(cond, "message")) {
[13:23:14.666]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.666]                       if (muffled) 
[13:23:14.666]                         invokeRestart("muffleMessage")
[13:23:14.666]                     }
[13:23:14.666]                     else if (inherits(cond, "warning")) {
[13:23:14.666]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.666]                       if (muffled) 
[13:23:14.666]                         invokeRestart("muffleWarning")
[13:23:14.666]                     }
[13:23:14.666]                     else if (inherits(cond, "condition")) {
[13:23:14.666]                       if (!is.null(pattern)) {
[13:23:14.666]                         computeRestarts <- base::computeRestarts
[13:23:14.666]                         grepl <- base::grepl
[13:23:14.666]                         restarts <- computeRestarts(cond)
[13:23:14.666]                         for (restart in restarts) {
[13:23:14.666]                           name <- restart$name
[13:23:14.666]                           if (is.null(name)) 
[13:23:14.666]                             next
[13:23:14.666]                           if (!grepl(pattern, name)) 
[13:23:14.666]                             next
[13:23:14.666]                           invokeRestart(restart)
[13:23:14.666]                           muffled <- TRUE
[13:23:14.666]                           break
[13:23:14.666]                         }
[13:23:14.666]                       }
[13:23:14.666]                     }
[13:23:14.666]                     invisible(muffled)
[13:23:14.666]                   }
[13:23:14.666]                   muffleCondition(cond)
[13:23:14.666]                 })
[13:23:14.666]             }))
[13:23:14.666]             future::FutureResult(value = ...future.value$value, 
[13:23:14.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.666]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.666]                     ...future.globalenv.names))
[13:23:14.666]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.666]         }, condition = base::local({
[13:23:14.666]             c <- base::c
[13:23:14.666]             inherits <- base::inherits
[13:23:14.666]             invokeRestart <- base::invokeRestart
[13:23:14.666]             length <- base::length
[13:23:14.666]             list <- base::list
[13:23:14.666]             seq.int <- base::seq.int
[13:23:14.666]             signalCondition <- base::signalCondition
[13:23:14.666]             sys.calls <- base::sys.calls
[13:23:14.666]             `[[` <- base::`[[`
[13:23:14.666]             `+` <- base::`+`
[13:23:14.666]             `<<-` <- base::`<<-`
[13:23:14.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.666]                   3L)]
[13:23:14.666]             }
[13:23:14.666]             function(cond) {
[13:23:14.666]                 is_error <- inherits(cond, "error")
[13:23:14.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.666]                   NULL)
[13:23:14.666]                 if (is_error) {
[13:23:14.666]                   sessionInformation <- function() {
[13:23:14.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.666]                       search = base::search(), system = base::Sys.info())
[13:23:14.666]                   }
[13:23:14.666]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.666]                     cond$call), session = sessionInformation(), 
[13:23:14.666]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.666]                   signalCondition(cond)
[13:23:14.666]                 }
[13:23:14.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.666]                 "immediateCondition"))) {
[13:23:14.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.666]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.666]                   if (TRUE && !signal) {
[13:23:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.666]                     {
[13:23:14.666]                       inherits <- base::inherits
[13:23:14.666]                       invokeRestart <- base::invokeRestart
[13:23:14.666]                       is.null <- base::is.null
[13:23:14.666]                       muffled <- FALSE
[13:23:14.666]                       if (inherits(cond, "message")) {
[13:23:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.666]                         if (muffled) 
[13:23:14.666]                           invokeRestart("muffleMessage")
[13:23:14.666]                       }
[13:23:14.666]                       else if (inherits(cond, "warning")) {
[13:23:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.666]                         if (muffled) 
[13:23:14.666]                           invokeRestart("muffleWarning")
[13:23:14.666]                       }
[13:23:14.666]                       else if (inherits(cond, "condition")) {
[13:23:14.666]                         if (!is.null(pattern)) {
[13:23:14.666]                           computeRestarts <- base::computeRestarts
[13:23:14.666]                           grepl <- base::grepl
[13:23:14.666]                           restarts <- computeRestarts(cond)
[13:23:14.666]                           for (restart in restarts) {
[13:23:14.666]                             name <- restart$name
[13:23:14.666]                             if (is.null(name)) 
[13:23:14.666]                               next
[13:23:14.666]                             if (!grepl(pattern, name)) 
[13:23:14.666]                               next
[13:23:14.666]                             invokeRestart(restart)
[13:23:14.666]                             muffled <- TRUE
[13:23:14.666]                             break
[13:23:14.666]                           }
[13:23:14.666]                         }
[13:23:14.666]                       }
[13:23:14.666]                       invisible(muffled)
[13:23:14.666]                     }
[13:23:14.666]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.666]                   }
[13:23:14.666]                 }
[13:23:14.666]                 else {
[13:23:14.666]                   if (TRUE) {
[13:23:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.666]                     {
[13:23:14.666]                       inherits <- base::inherits
[13:23:14.666]                       invokeRestart <- base::invokeRestart
[13:23:14.666]                       is.null <- base::is.null
[13:23:14.666]                       muffled <- FALSE
[13:23:14.666]                       if (inherits(cond, "message")) {
[13:23:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.666]                         if (muffled) 
[13:23:14.666]                           invokeRestart("muffleMessage")
[13:23:14.666]                       }
[13:23:14.666]                       else if (inherits(cond, "warning")) {
[13:23:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.666]                         if (muffled) 
[13:23:14.666]                           invokeRestart("muffleWarning")
[13:23:14.666]                       }
[13:23:14.666]                       else if (inherits(cond, "condition")) {
[13:23:14.666]                         if (!is.null(pattern)) {
[13:23:14.666]                           computeRestarts <- base::computeRestarts
[13:23:14.666]                           grepl <- base::grepl
[13:23:14.666]                           restarts <- computeRestarts(cond)
[13:23:14.666]                           for (restart in restarts) {
[13:23:14.666]                             name <- restart$name
[13:23:14.666]                             if (is.null(name)) 
[13:23:14.666]                               next
[13:23:14.666]                             if (!grepl(pattern, name)) 
[13:23:14.666]                               next
[13:23:14.666]                             invokeRestart(restart)
[13:23:14.666]                             muffled <- TRUE
[13:23:14.666]                             break
[13:23:14.666]                           }
[13:23:14.666]                         }
[13:23:14.666]                       }
[13:23:14.666]                       invisible(muffled)
[13:23:14.666]                     }
[13:23:14.666]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.666]                   }
[13:23:14.666]                 }
[13:23:14.666]             }
[13:23:14.666]         }))
[13:23:14.666]     }, error = function(ex) {
[13:23:14.666]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.666]                 ...future.rng), started = ...future.startTime, 
[13:23:14.666]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.666]             version = "1.8"), class = "FutureResult")
[13:23:14.666]     }, finally = {
[13:23:14.666]         if (!identical(...future.workdir, getwd())) 
[13:23:14.666]             setwd(...future.workdir)
[13:23:14.666]         {
[13:23:14.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.666]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.666]             }
[13:23:14.666]             base::options(...future.oldOptions)
[13:23:14.666]             if (.Platform$OS.type == "windows") {
[13:23:14.666]                 old_names <- names(...future.oldEnvVars)
[13:23:14.666]                 envs <- base::Sys.getenv()
[13:23:14.666]                 names <- names(envs)
[13:23:14.666]                 common <- intersect(names, old_names)
[13:23:14.666]                 added <- setdiff(names, old_names)
[13:23:14.666]                 removed <- setdiff(old_names, names)
[13:23:14.666]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.666]                   envs[common]]
[13:23:14.666]                 NAMES <- toupper(changed)
[13:23:14.666]                 args <- list()
[13:23:14.666]                 for (kk in seq_along(NAMES)) {
[13:23:14.666]                   name <- changed[[kk]]
[13:23:14.666]                   NAME <- NAMES[[kk]]
[13:23:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.666]                     next
[13:23:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.666]                 }
[13:23:14.666]                 NAMES <- toupper(added)
[13:23:14.666]                 for (kk in seq_along(NAMES)) {
[13:23:14.666]                   name <- added[[kk]]
[13:23:14.666]                   NAME <- NAMES[[kk]]
[13:23:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.666]                     next
[13:23:14.666]                   args[[name]] <- ""
[13:23:14.666]                 }
[13:23:14.666]                 NAMES <- toupper(removed)
[13:23:14.666]                 for (kk in seq_along(NAMES)) {
[13:23:14.666]                   name <- removed[[kk]]
[13:23:14.666]                   NAME <- NAMES[[kk]]
[13:23:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.666]                     next
[13:23:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.666]                 }
[13:23:14.666]                 if (length(args) > 0) 
[13:23:14.666]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.666]             }
[13:23:14.666]             else {
[13:23:14.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.666]             }
[13:23:14.666]             {
[13:23:14.666]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.666]                   0L) {
[13:23:14.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.666]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.666]                   base::options(opts)
[13:23:14.666]                 }
[13:23:14.666]                 {
[13:23:14.666]                   {
[13:23:14.666]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.666]                     NULL
[13:23:14.666]                   }
[13:23:14.666]                   options(future.plan = NULL)
[13:23:14.666]                   if (is.na(NA_character_)) 
[13:23:14.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.666]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.666]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.666]                     envir = parent.frame()) 
[13:23:14.666]                   {
[13:23:14.666]                     if (is.function(workers)) 
[13:23:14.666]                       workers <- workers()
[13:23:14.666]                     workers <- structure(as.integer(workers), 
[13:23:14.666]                       class = class(workers))
[13:23:14.666]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.666]                       workers >= 1)
[13:23:14.666]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.666]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.666]                     }
[13:23:14.666]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.666]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.666]                       envir = envir)
[13:23:14.666]                     if (!future$lazy) 
[13:23:14.666]                       future <- run(future)
[13:23:14.666]                     invisible(future)
[13:23:14.666]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.666]                 }
[13:23:14.666]             }
[13:23:14.666]         }
[13:23:14.666]     })
[13:23:14.666]     if (TRUE) {
[13:23:14.666]         base::sink(type = "output", split = FALSE)
[13:23:14.666]         if (TRUE) {
[13:23:14.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.666]         }
[13:23:14.666]         else {
[13:23:14.666]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.666]         }
[13:23:14.666]         base::close(...future.stdout)
[13:23:14.666]         ...future.stdout <- NULL
[13:23:14.666]     }
[13:23:14.666]     ...future.result$conditions <- ...future.conditions
[13:23:14.666]     ...future.result$finished <- base::Sys.time()
[13:23:14.666]     ...future.result
[13:23:14.666] }
[13:23:14.670] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:23:14.670] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:23:14.670] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:23:14.671] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:23:14.671] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:23:14.671] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:23:14.672] MultisessionFuture started
[13:23:14.672] - Launch lazy future ... done
[13:23:14.672] run() for ‘MultisessionFuture’ ... done
[13:23:14.672] result() for ClusterFuture ...
[13:23:14.673] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.673] - Validating connection of MultisessionFuture
[13:23:14.721] - received message: FutureResult
[13:23:14.721] - Received FutureResult
[13:23:14.722] - Erased future from FutureRegistry
[13:23:14.722] result() for ClusterFuture ...
[13:23:14.722] - result already collected: FutureResult
[13:23:14.722] result() for ClusterFuture ... done
[13:23:14.722] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:14.722] result() for ClusterFuture ... done
[13:23:14.722] result() for ClusterFuture ...
[13:23:14.722] - result already collected: FutureResult
[13:23:14.723] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:14.725] getGlobalsAndPackages() ...
[13:23:14.725] Searching for globals...
[13:23:14.727] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:14.727] Searching for globals ... DONE
[13:23:14.727] Resolving globals: FALSE
[13:23:14.728] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:14.729] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:14.729] - globals: [2] ‘weight’, ‘group’
[13:23:14.729] - packages: [1] ‘stats’
[13:23:14.729] getGlobalsAndPackages() ... DONE
[13:23:14.729] run() for ‘Future’ ...
[13:23:14.729] - state: ‘created’
[13:23:14.730] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:14.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:14.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:14.745]   - Field: ‘node’
[13:23:14.746]   - Field: ‘label’
[13:23:14.746]   - Field: ‘local’
[13:23:14.746]   - Field: ‘owner’
[13:23:14.746]   - Field: ‘envir’
[13:23:14.746]   - Field: ‘workers’
[13:23:14.746]   - Field: ‘packages’
[13:23:14.746]   - Field: ‘gc’
[13:23:14.746]   - Field: ‘conditions’
[13:23:14.746]   - Field: ‘persistent’
[13:23:14.746]   - Field: ‘expr’
[13:23:14.747]   - Field: ‘uuid’
[13:23:14.747]   - Field: ‘seed’
[13:23:14.747]   - Field: ‘version’
[13:23:14.747]   - Field: ‘result’
[13:23:14.747]   - Field: ‘asynchronous’
[13:23:14.747]   - Field: ‘calls’
[13:23:14.747]   - Field: ‘globals’
[13:23:14.747]   - Field: ‘stdout’
[13:23:14.748]   - Field: ‘earlySignal’
[13:23:14.748]   - Field: ‘lazy’
[13:23:14.748]   - Field: ‘state’
[13:23:14.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:14.748] - Launch lazy future ...
[13:23:14.748] Packages needed by the future expression (n = 1): ‘stats’
[13:23:14.749] Packages needed by future strategies (n = 0): <none>
[13:23:14.749] {
[13:23:14.749]     {
[13:23:14.749]         {
[13:23:14.749]             ...future.startTime <- base::Sys.time()
[13:23:14.749]             {
[13:23:14.749]                 {
[13:23:14.749]                   {
[13:23:14.749]                     {
[13:23:14.749]                       {
[13:23:14.749]                         base::local({
[13:23:14.749]                           has_future <- base::requireNamespace("future", 
[13:23:14.749]                             quietly = TRUE)
[13:23:14.749]                           if (has_future) {
[13:23:14.749]                             ns <- base::getNamespace("future")
[13:23:14.749]                             version <- ns[[".package"]][["version"]]
[13:23:14.749]                             if (is.null(version)) 
[13:23:14.749]                               version <- utils::packageVersion("future")
[13:23:14.749]                           }
[13:23:14.749]                           else {
[13:23:14.749]                             version <- NULL
[13:23:14.749]                           }
[13:23:14.749]                           if (!has_future || version < "1.8.0") {
[13:23:14.749]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.749]                               "", base::R.version$version.string), 
[13:23:14.749]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:14.749]                                 base::R.version$platform, 8 * 
[13:23:14.749]                                   base::.Machine$sizeof.pointer), 
[13:23:14.749]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.749]                                 "release", "version")], collapse = " "), 
[13:23:14.749]                               hostname = base::Sys.info()[["nodename"]])
[13:23:14.749]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.749]                               info)
[13:23:14.749]                             info <- base::paste(info, collapse = "; ")
[13:23:14.749]                             if (!has_future) {
[13:23:14.749]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.749]                                 info)
[13:23:14.749]                             }
[13:23:14.749]                             else {
[13:23:14.749]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.749]                                 info, version)
[13:23:14.749]                             }
[13:23:14.749]                             base::stop(msg)
[13:23:14.749]                           }
[13:23:14.749]                         })
[13:23:14.749]                       }
[13:23:14.749]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.749]                       base::options(mc.cores = 1L)
[13:23:14.749]                     }
[13:23:14.749]                     base::local({
[13:23:14.749]                       for (pkg in "stats") {
[13:23:14.749]                         base::loadNamespace(pkg)
[13:23:14.749]                         base::library(pkg, character.only = TRUE)
[13:23:14.749]                       }
[13:23:14.749]                     })
[13:23:14.749]                   }
[13:23:14.749]                   options(future.plan = NULL)
[13:23:14.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.749]                 }
[13:23:14.749]                 ...future.workdir <- getwd()
[13:23:14.749]             }
[13:23:14.749]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.749]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.749]         }
[13:23:14.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.749]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.749]             base::names(...future.oldOptions))
[13:23:14.749]     }
[13:23:14.749]     if (FALSE) {
[13:23:14.749]     }
[13:23:14.749]     else {
[13:23:14.749]         if (TRUE) {
[13:23:14.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.749]                 open = "w")
[13:23:14.749]         }
[13:23:14.749]         else {
[13:23:14.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.749]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.749]         }
[13:23:14.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.749]             base::sink(type = "output", split = FALSE)
[13:23:14.749]             base::close(...future.stdout)
[13:23:14.749]         }, add = TRUE)
[13:23:14.749]     }
[13:23:14.749]     ...future.frame <- base::sys.nframe()
[13:23:14.749]     ...future.conditions <- base::list()
[13:23:14.749]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.749]     if (FALSE) {
[13:23:14.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.749]     }
[13:23:14.749]     ...future.result <- base::tryCatch({
[13:23:14.749]         base::withCallingHandlers({
[13:23:14.749]             ...future.value <- base::withVisible(base::local({
[13:23:14.749]                 ...future.makeSendCondition <- base::local({
[13:23:14.749]                   sendCondition <- NULL
[13:23:14.749]                   function(frame = 1L) {
[13:23:14.749]                     if (is.function(sendCondition)) 
[13:23:14.749]                       return(sendCondition)
[13:23:14.749]                     ns <- getNamespace("parallel")
[13:23:14.749]                     if (exists("sendData", mode = "function", 
[13:23:14.749]                       envir = ns)) {
[13:23:14.749]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.749]                         envir = ns)
[13:23:14.749]                       envir <- sys.frame(frame)
[13:23:14.749]                       master <- NULL
[13:23:14.749]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.749]                         !identical(envir, emptyenv())) {
[13:23:14.749]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.749]                           inherits = FALSE)) {
[13:23:14.749]                           master <- get("master", mode = "list", 
[13:23:14.749]                             envir = envir, inherits = FALSE)
[13:23:14.749]                           if (inherits(master, c("SOCKnode", 
[13:23:14.749]                             "SOCK0node"))) {
[13:23:14.749]                             sendCondition <<- function(cond) {
[13:23:14.749]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.749]                                 success = TRUE)
[13:23:14.749]                               parallel_sendData(master, data)
[13:23:14.749]                             }
[13:23:14.749]                             return(sendCondition)
[13:23:14.749]                           }
[13:23:14.749]                         }
[13:23:14.749]                         frame <- frame + 1L
[13:23:14.749]                         envir <- sys.frame(frame)
[13:23:14.749]                       }
[13:23:14.749]                     }
[13:23:14.749]                     sendCondition <<- function(cond) NULL
[13:23:14.749]                   }
[13:23:14.749]                 })
[13:23:14.749]                 withCallingHandlers({
[13:23:14.749]                   {
[13:23:14.749]                     lm(weight ~ group - 1)
[13:23:14.749]                   }
[13:23:14.749]                 }, immediateCondition = function(cond) {
[13:23:14.749]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.749]                   sendCondition(cond)
[13:23:14.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.749]                   {
[13:23:14.749]                     inherits <- base::inherits
[13:23:14.749]                     invokeRestart <- base::invokeRestart
[13:23:14.749]                     is.null <- base::is.null
[13:23:14.749]                     muffled <- FALSE
[13:23:14.749]                     if (inherits(cond, "message")) {
[13:23:14.749]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.749]                       if (muffled) 
[13:23:14.749]                         invokeRestart("muffleMessage")
[13:23:14.749]                     }
[13:23:14.749]                     else if (inherits(cond, "warning")) {
[13:23:14.749]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.749]                       if (muffled) 
[13:23:14.749]                         invokeRestart("muffleWarning")
[13:23:14.749]                     }
[13:23:14.749]                     else if (inherits(cond, "condition")) {
[13:23:14.749]                       if (!is.null(pattern)) {
[13:23:14.749]                         computeRestarts <- base::computeRestarts
[13:23:14.749]                         grepl <- base::grepl
[13:23:14.749]                         restarts <- computeRestarts(cond)
[13:23:14.749]                         for (restart in restarts) {
[13:23:14.749]                           name <- restart$name
[13:23:14.749]                           if (is.null(name)) 
[13:23:14.749]                             next
[13:23:14.749]                           if (!grepl(pattern, name)) 
[13:23:14.749]                             next
[13:23:14.749]                           invokeRestart(restart)
[13:23:14.749]                           muffled <- TRUE
[13:23:14.749]                           break
[13:23:14.749]                         }
[13:23:14.749]                       }
[13:23:14.749]                     }
[13:23:14.749]                     invisible(muffled)
[13:23:14.749]                   }
[13:23:14.749]                   muffleCondition(cond)
[13:23:14.749]                 })
[13:23:14.749]             }))
[13:23:14.749]             future::FutureResult(value = ...future.value$value, 
[13:23:14.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.749]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.749]                     ...future.globalenv.names))
[13:23:14.749]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.749]         }, condition = base::local({
[13:23:14.749]             c <- base::c
[13:23:14.749]             inherits <- base::inherits
[13:23:14.749]             invokeRestart <- base::invokeRestart
[13:23:14.749]             length <- base::length
[13:23:14.749]             list <- base::list
[13:23:14.749]             seq.int <- base::seq.int
[13:23:14.749]             signalCondition <- base::signalCondition
[13:23:14.749]             sys.calls <- base::sys.calls
[13:23:14.749]             `[[` <- base::`[[`
[13:23:14.749]             `+` <- base::`+`
[13:23:14.749]             `<<-` <- base::`<<-`
[13:23:14.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.749]                   3L)]
[13:23:14.749]             }
[13:23:14.749]             function(cond) {
[13:23:14.749]                 is_error <- inherits(cond, "error")
[13:23:14.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.749]                   NULL)
[13:23:14.749]                 if (is_error) {
[13:23:14.749]                   sessionInformation <- function() {
[13:23:14.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.749]                       search = base::search(), system = base::Sys.info())
[13:23:14.749]                   }
[13:23:14.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.749]                     cond$call), session = sessionInformation(), 
[13:23:14.749]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.749]                   signalCondition(cond)
[13:23:14.749]                 }
[13:23:14.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.749]                 "immediateCondition"))) {
[13:23:14.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.749]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.749]                   if (TRUE && !signal) {
[13:23:14.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.749]                     {
[13:23:14.749]                       inherits <- base::inherits
[13:23:14.749]                       invokeRestart <- base::invokeRestart
[13:23:14.749]                       is.null <- base::is.null
[13:23:14.749]                       muffled <- FALSE
[13:23:14.749]                       if (inherits(cond, "message")) {
[13:23:14.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.749]                         if (muffled) 
[13:23:14.749]                           invokeRestart("muffleMessage")
[13:23:14.749]                       }
[13:23:14.749]                       else if (inherits(cond, "warning")) {
[13:23:14.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.749]                         if (muffled) 
[13:23:14.749]                           invokeRestart("muffleWarning")
[13:23:14.749]                       }
[13:23:14.749]                       else if (inherits(cond, "condition")) {
[13:23:14.749]                         if (!is.null(pattern)) {
[13:23:14.749]                           computeRestarts <- base::computeRestarts
[13:23:14.749]                           grepl <- base::grepl
[13:23:14.749]                           restarts <- computeRestarts(cond)
[13:23:14.749]                           for (restart in restarts) {
[13:23:14.749]                             name <- restart$name
[13:23:14.749]                             if (is.null(name)) 
[13:23:14.749]                               next
[13:23:14.749]                             if (!grepl(pattern, name)) 
[13:23:14.749]                               next
[13:23:14.749]                             invokeRestart(restart)
[13:23:14.749]                             muffled <- TRUE
[13:23:14.749]                             break
[13:23:14.749]                           }
[13:23:14.749]                         }
[13:23:14.749]                       }
[13:23:14.749]                       invisible(muffled)
[13:23:14.749]                     }
[13:23:14.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.749]                   }
[13:23:14.749]                 }
[13:23:14.749]                 else {
[13:23:14.749]                   if (TRUE) {
[13:23:14.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.749]                     {
[13:23:14.749]                       inherits <- base::inherits
[13:23:14.749]                       invokeRestart <- base::invokeRestart
[13:23:14.749]                       is.null <- base::is.null
[13:23:14.749]                       muffled <- FALSE
[13:23:14.749]                       if (inherits(cond, "message")) {
[13:23:14.749]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.749]                         if (muffled) 
[13:23:14.749]                           invokeRestart("muffleMessage")
[13:23:14.749]                       }
[13:23:14.749]                       else if (inherits(cond, "warning")) {
[13:23:14.749]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.749]                         if (muffled) 
[13:23:14.749]                           invokeRestart("muffleWarning")
[13:23:14.749]                       }
[13:23:14.749]                       else if (inherits(cond, "condition")) {
[13:23:14.749]                         if (!is.null(pattern)) {
[13:23:14.749]                           computeRestarts <- base::computeRestarts
[13:23:14.749]                           grepl <- base::grepl
[13:23:14.749]                           restarts <- computeRestarts(cond)
[13:23:14.749]                           for (restart in restarts) {
[13:23:14.749]                             name <- restart$name
[13:23:14.749]                             if (is.null(name)) 
[13:23:14.749]                               next
[13:23:14.749]                             if (!grepl(pattern, name)) 
[13:23:14.749]                               next
[13:23:14.749]                             invokeRestart(restart)
[13:23:14.749]                             muffled <- TRUE
[13:23:14.749]                             break
[13:23:14.749]                           }
[13:23:14.749]                         }
[13:23:14.749]                       }
[13:23:14.749]                       invisible(muffled)
[13:23:14.749]                     }
[13:23:14.749]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.749]                   }
[13:23:14.749]                 }
[13:23:14.749]             }
[13:23:14.749]         }))
[13:23:14.749]     }, error = function(ex) {
[13:23:14.749]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.749]                 ...future.rng), started = ...future.startTime, 
[13:23:14.749]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.749]             version = "1.8"), class = "FutureResult")
[13:23:14.749]     }, finally = {
[13:23:14.749]         if (!identical(...future.workdir, getwd())) 
[13:23:14.749]             setwd(...future.workdir)
[13:23:14.749]         {
[13:23:14.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.749]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.749]             }
[13:23:14.749]             base::options(...future.oldOptions)
[13:23:14.749]             if (.Platform$OS.type == "windows") {
[13:23:14.749]                 old_names <- names(...future.oldEnvVars)
[13:23:14.749]                 envs <- base::Sys.getenv()
[13:23:14.749]                 names <- names(envs)
[13:23:14.749]                 common <- intersect(names, old_names)
[13:23:14.749]                 added <- setdiff(names, old_names)
[13:23:14.749]                 removed <- setdiff(old_names, names)
[13:23:14.749]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.749]                   envs[common]]
[13:23:14.749]                 NAMES <- toupper(changed)
[13:23:14.749]                 args <- list()
[13:23:14.749]                 for (kk in seq_along(NAMES)) {
[13:23:14.749]                   name <- changed[[kk]]
[13:23:14.749]                   NAME <- NAMES[[kk]]
[13:23:14.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.749]                     next
[13:23:14.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.749]                 }
[13:23:14.749]                 NAMES <- toupper(added)
[13:23:14.749]                 for (kk in seq_along(NAMES)) {
[13:23:14.749]                   name <- added[[kk]]
[13:23:14.749]                   NAME <- NAMES[[kk]]
[13:23:14.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.749]                     next
[13:23:14.749]                   args[[name]] <- ""
[13:23:14.749]                 }
[13:23:14.749]                 NAMES <- toupper(removed)
[13:23:14.749]                 for (kk in seq_along(NAMES)) {
[13:23:14.749]                   name <- removed[[kk]]
[13:23:14.749]                   NAME <- NAMES[[kk]]
[13:23:14.749]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.749]                     next
[13:23:14.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.749]                 }
[13:23:14.749]                 if (length(args) > 0) 
[13:23:14.749]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.749]             }
[13:23:14.749]             else {
[13:23:14.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.749]             }
[13:23:14.749]             {
[13:23:14.749]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.749]                   0L) {
[13:23:14.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.749]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.749]                   base::options(opts)
[13:23:14.749]                 }
[13:23:14.749]                 {
[13:23:14.749]                   {
[13:23:14.749]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.749]                     NULL
[13:23:14.749]                   }
[13:23:14.749]                   options(future.plan = NULL)
[13:23:14.749]                   if (is.na(NA_character_)) 
[13:23:14.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.749]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.749]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.749]                     envir = parent.frame()) 
[13:23:14.749]                   {
[13:23:14.749]                     if (is.function(workers)) 
[13:23:14.749]                       workers <- workers()
[13:23:14.749]                     workers <- structure(as.integer(workers), 
[13:23:14.749]                       class = class(workers))
[13:23:14.749]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.749]                       workers >= 1)
[13:23:14.749]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.749]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.749]                     }
[13:23:14.749]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.749]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.749]                       envir = envir)
[13:23:14.749]                     if (!future$lazy) 
[13:23:14.749]                       future <- run(future)
[13:23:14.749]                     invisible(future)
[13:23:14.749]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.749]                 }
[13:23:14.749]             }
[13:23:14.749]         }
[13:23:14.749]     })
[13:23:14.749]     if (TRUE) {
[13:23:14.749]         base::sink(type = "output", split = FALSE)
[13:23:14.749]         if (TRUE) {
[13:23:14.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.749]         }
[13:23:14.749]         else {
[13:23:14.749]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.749]         }
[13:23:14.749]         base::close(...future.stdout)
[13:23:14.749]         ...future.stdout <- NULL
[13:23:14.749]     }
[13:23:14.749]     ...future.result$conditions <- ...future.conditions
[13:23:14.749]     ...future.result$finished <- base::Sys.time()
[13:23:14.749]     ...future.result
[13:23:14.749] }
[13:23:14.753] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:23:14.753] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:23:14.753] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:23:14.754] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:23:14.754] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:23:14.754] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:23:14.755] MultisessionFuture started
[13:23:14.755] - Launch lazy future ... done
[13:23:14.755] run() for ‘MultisessionFuture’ ... done
[13:23:14.755] result() for ClusterFuture ...
[13:23:14.755] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.756] - Validating connection of MultisessionFuture
[13:23:14.803] - received message: FutureResult
[13:23:14.803] - Received FutureResult
[13:23:14.803] - Erased future from FutureRegistry
[13:23:14.803] result() for ClusterFuture ...
[13:23:14.803] - result already collected: FutureResult
[13:23:14.804] result() for ClusterFuture ... done
[13:23:14.804] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:14.804] result() for ClusterFuture ... done
[13:23:14.804] result() for ClusterFuture ...
[13:23:14.804] - result already collected: FutureResult
[13:23:14.804] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:14.807] getGlobalsAndPackages() ...
[13:23:14.807] Searching for globals...
[13:23:14.809] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:14.809] Searching for globals ... DONE
[13:23:14.809] Resolving globals: FALSE
[13:23:14.810] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:14.810] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:14.810] - globals: [2] ‘weight’, ‘group’
[13:23:14.811] - packages: [1] ‘stats’
[13:23:14.811] getGlobalsAndPackages() ... DONE
[13:23:14.811] run() for ‘Future’ ...
[13:23:14.811] - state: ‘created’
[13:23:14.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:14.827] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:14.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:14.827]   - Field: ‘node’
[13:23:14.827]   - Field: ‘label’
[13:23:14.827]   - Field: ‘local’
[13:23:14.827]   - Field: ‘owner’
[13:23:14.827]   - Field: ‘envir’
[13:23:14.827]   - Field: ‘workers’
[13:23:14.828]   - Field: ‘packages’
[13:23:14.828]   - Field: ‘gc’
[13:23:14.828]   - Field: ‘conditions’
[13:23:14.828]   - Field: ‘persistent’
[13:23:14.828]   - Field: ‘expr’
[13:23:14.828]   - Field: ‘uuid’
[13:23:14.828]   - Field: ‘seed’
[13:23:14.828]   - Field: ‘version’
[13:23:14.829]   - Field: ‘result’
[13:23:14.829]   - Field: ‘asynchronous’
[13:23:14.829]   - Field: ‘calls’
[13:23:14.829]   - Field: ‘globals’
[13:23:14.829]   - Field: ‘stdout’
[13:23:14.829]   - Field: ‘earlySignal’
[13:23:14.829]   - Field: ‘lazy’
[13:23:14.829]   - Field: ‘state’
[13:23:14.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:14.830] - Launch lazy future ...
[13:23:14.830] Packages needed by the future expression (n = 1): ‘stats’
[13:23:14.830] Packages needed by future strategies (n = 0): <none>
[13:23:14.831] {
[13:23:14.831]     {
[13:23:14.831]         {
[13:23:14.831]             ...future.startTime <- base::Sys.time()
[13:23:14.831]             {
[13:23:14.831]                 {
[13:23:14.831]                   {
[13:23:14.831]                     {
[13:23:14.831]                       {
[13:23:14.831]                         base::local({
[13:23:14.831]                           has_future <- base::requireNamespace("future", 
[13:23:14.831]                             quietly = TRUE)
[13:23:14.831]                           if (has_future) {
[13:23:14.831]                             ns <- base::getNamespace("future")
[13:23:14.831]                             version <- ns[[".package"]][["version"]]
[13:23:14.831]                             if (is.null(version)) 
[13:23:14.831]                               version <- utils::packageVersion("future")
[13:23:14.831]                           }
[13:23:14.831]                           else {
[13:23:14.831]                             version <- NULL
[13:23:14.831]                           }
[13:23:14.831]                           if (!has_future || version < "1.8.0") {
[13:23:14.831]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.831]                               "", base::R.version$version.string), 
[13:23:14.831]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:14.831]                                 base::R.version$platform, 8 * 
[13:23:14.831]                                   base::.Machine$sizeof.pointer), 
[13:23:14.831]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.831]                                 "release", "version")], collapse = " "), 
[13:23:14.831]                               hostname = base::Sys.info()[["nodename"]])
[13:23:14.831]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.831]                               info)
[13:23:14.831]                             info <- base::paste(info, collapse = "; ")
[13:23:14.831]                             if (!has_future) {
[13:23:14.831]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.831]                                 info)
[13:23:14.831]                             }
[13:23:14.831]                             else {
[13:23:14.831]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.831]                                 info, version)
[13:23:14.831]                             }
[13:23:14.831]                             base::stop(msg)
[13:23:14.831]                           }
[13:23:14.831]                         })
[13:23:14.831]                       }
[13:23:14.831]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.831]                       base::options(mc.cores = 1L)
[13:23:14.831]                     }
[13:23:14.831]                     base::local({
[13:23:14.831]                       for (pkg in "stats") {
[13:23:14.831]                         base::loadNamespace(pkg)
[13:23:14.831]                         base::library(pkg, character.only = TRUE)
[13:23:14.831]                       }
[13:23:14.831]                     })
[13:23:14.831]                   }
[13:23:14.831]                   options(future.plan = NULL)
[13:23:14.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.831]                 }
[13:23:14.831]                 ...future.workdir <- getwd()
[13:23:14.831]             }
[13:23:14.831]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.831]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.831]         }
[13:23:14.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.831]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.831]             base::names(...future.oldOptions))
[13:23:14.831]     }
[13:23:14.831]     if (FALSE) {
[13:23:14.831]     }
[13:23:14.831]     else {
[13:23:14.831]         if (TRUE) {
[13:23:14.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.831]                 open = "w")
[13:23:14.831]         }
[13:23:14.831]         else {
[13:23:14.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.831]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.831]         }
[13:23:14.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.831]             base::sink(type = "output", split = FALSE)
[13:23:14.831]             base::close(...future.stdout)
[13:23:14.831]         }, add = TRUE)
[13:23:14.831]     }
[13:23:14.831]     ...future.frame <- base::sys.nframe()
[13:23:14.831]     ...future.conditions <- base::list()
[13:23:14.831]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.831]     if (FALSE) {
[13:23:14.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.831]     }
[13:23:14.831]     ...future.result <- base::tryCatch({
[13:23:14.831]         base::withCallingHandlers({
[13:23:14.831]             ...future.value <- base::withVisible(base::local({
[13:23:14.831]                 ...future.makeSendCondition <- base::local({
[13:23:14.831]                   sendCondition <- NULL
[13:23:14.831]                   function(frame = 1L) {
[13:23:14.831]                     if (is.function(sendCondition)) 
[13:23:14.831]                       return(sendCondition)
[13:23:14.831]                     ns <- getNamespace("parallel")
[13:23:14.831]                     if (exists("sendData", mode = "function", 
[13:23:14.831]                       envir = ns)) {
[13:23:14.831]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.831]                         envir = ns)
[13:23:14.831]                       envir <- sys.frame(frame)
[13:23:14.831]                       master <- NULL
[13:23:14.831]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.831]                         !identical(envir, emptyenv())) {
[13:23:14.831]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.831]                           inherits = FALSE)) {
[13:23:14.831]                           master <- get("master", mode = "list", 
[13:23:14.831]                             envir = envir, inherits = FALSE)
[13:23:14.831]                           if (inherits(master, c("SOCKnode", 
[13:23:14.831]                             "SOCK0node"))) {
[13:23:14.831]                             sendCondition <<- function(cond) {
[13:23:14.831]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.831]                                 success = TRUE)
[13:23:14.831]                               parallel_sendData(master, data)
[13:23:14.831]                             }
[13:23:14.831]                             return(sendCondition)
[13:23:14.831]                           }
[13:23:14.831]                         }
[13:23:14.831]                         frame <- frame + 1L
[13:23:14.831]                         envir <- sys.frame(frame)
[13:23:14.831]                       }
[13:23:14.831]                     }
[13:23:14.831]                     sendCondition <<- function(cond) NULL
[13:23:14.831]                   }
[13:23:14.831]                 })
[13:23:14.831]                 withCallingHandlers({
[13:23:14.831]                   {
[13:23:14.831]                     lm(weight ~ group - 1)
[13:23:14.831]                   }
[13:23:14.831]                 }, immediateCondition = function(cond) {
[13:23:14.831]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.831]                   sendCondition(cond)
[13:23:14.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.831]                   {
[13:23:14.831]                     inherits <- base::inherits
[13:23:14.831]                     invokeRestart <- base::invokeRestart
[13:23:14.831]                     is.null <- base::is.null
[13:23:14.831]                     muffled <- FALSE
[13:23:14.831]                     if (inherits(cond, "message")) {
[13:23:14.831]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.831]                       if (muffled) 
[13:23:14.831]                         invokeRestart("muffleMessage")
[13:23:14.831]                     }
[13:23:14.831]                     else if (inherits(cond, "warning")) {
[13:23:14.831]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.831]                       if (muffled) 
[13:23:14.831]                         invokeRestart("muffleWarning")
[13:23:14.831]                     }
[13:23:14.831]                     else if (inherits(cond, "condition")) {
[13:23:14.831]                       if (!is.null(pattern)) {
[13:23:14.831]                         computeRestarts <- base::computeRestarts
[13:23:14.831]                         grepl <- base::grepl
[13:23:14.831]                         restarts <- computeRestarts(cond)
[13:23:14.831]                         for (restart in restarts) {
[13:23:14.831]                           name <- restart$name
[13:23:14.831]                           if (is.null(name)) 
[13:23:14.831]                             next
[13:23:14.831]                           if (!grepl(pattern, name)) 
[13:23:14.831]                             next
[13:23:14.831]                           invokeRestart(restart)
[13:23:14.831]                           muffled <- TRUE
[13:23:14.831]                           break
[13:23:14.831]                         }
[13:23:14.831]                       }
[13:23:14.831]                     }
[13:23:14.831]                     invisible(muffled)
[13:23:14.831]                   }
[13:23:14.831]                   muffleCondition(cond)
[13:23:14.831]                 })
[13:23:14.831]             }))
[13:23:14.831]             future::FutureResult(value = ...future.value$value, 
[13:23:14.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.831]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.831]                     ...future.globalenv.names))
[13:23:14.831]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.831]         }, condition = base::local({
[13:23:14.831]             c <- base::c
[13:23:14.831]             inherits <- base::inherits
[13:23:14.831]             invokeRestart <- base::invokeRestart
[13:23:14.831]             length <- base::length
[13:23:14.831]             list <- base::list
[13:23:14.831]             seq.int <- base::seq.int
[13:23:14.831]             signalCondition <- base::signalCondition
[13:23:14.831]             sys.calls <- base::sys.calls
[13:23:14.831]             `[[` <- base::`[[`
[13:23:14.831]             `+` <- base::`+`
[13:23:14.831]             `<<-` <- base::`<<-`
[13:23:14.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.831]                   3L)]
[13:23:14.831]             }
[13:23:14.831]             function(cond) {
[13:23:14.831]                 is_error <- inherits(cond, "error")
[13:23:14.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.831]                   NULL)
[13:23:14.831]                 if (is_error) {
[13:23:14.831]                   sessionInformation <- function() {
[13:23:14.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.831]                       search = base::search(), system = base::Sys.info())
[13:23:14.831]                   }
[13:23:14.831]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.831]                     cond$call), session = sessionInformation(), 
[13:23:14.831]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.831]                   signalCondition(cond)
[13:23:14.831]                 }
[13:23:14.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.831]                 "immediateCondition"))) {
[13:23:14.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.831]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.831]                   if (TRUE && !signal) {
[13:23:14.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.831]                     {
[13:23:14.831]                       inherits <- base::inherits
[13:23:14.831]                       invokeRestart <- base::invokeRestart
[13:23:14.831]                       is.null <- base::is.null
[13:23:14.831]                       muffled <- FALSE
[13:23:14.831]                       if (inherits(cond, "message")) {
[13:23:14.831]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.831]                         if (muffled) 
[13:23:14.831]                           invokeRestart("muffleMessage")
[13:23:14.831]                       }
[13:23:14.831]                       else if (inherits(cond, "warning")) {
[13:23:14.831]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.831]                         if (muffled) 
[13:23:14.831]                           invokeRestart("muffleWarning")
[13:23:14.831]                       }
[13:23:14.831]                       else if (inherits(cond, "condition")) {
[13:23:14.831]                         if (!is.null(pattern)) {
[13:23:14.831]                           computeRestarts <- base::computeRestarts
[13:23:14.831]                           grepl <- base::grepl
[13:23:14.831]                           restarts <- computeRestarts(cond)
[13:23:14.831]                           for (restart in restarts) {
[13:23:14.831]                             name <- restart$name
[13:23:14.831]                             if (is.null(name)) 
[13:23:14.831]                               next
[13:23:14.831]                             if (!grepl(pattern, name)) 
[13:23:14.831]                               next
[13:23:14.831]                             invokeRestart(restart)
[13:23:14.831]                             muffled <- TRUE
[13:23:14.831]                             break
[13:23:14.831]                           }
[13:23:14.831]                         }
[13:23:14.831]                       }
[13:23:14.831]                       invisible(muffled)
[13:23:14.831]                     }
[13:23:14.831]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.831]                   }
[13:23:14.831]                 }
[13:23:14.831]                 else {
[13:23:14.831]                   if (TRUE) {
[13:23:14.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.831]                     {
[13:23:14.831]                       inherits <- base::inherits
[13:23:14.831]                       invokeRestart <- base::invokeRestart
[13:23:14.831]                       is.null <- base::is.null
[13:23:14.831]                       muffled <- FALSE
[13:23:14.831]                       if (inherits(cond, "message")) {
[13:23:14.831]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.831]                         if (muffled) 
[13:23:14.831]                           invokeRestart("muffleMessage")
[13:23:14.831]                       }
[13:23:14.831]                       else if (inherits(cond, "warning")) {
[13:23:14.831]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.831]                         if (muffled) 
[13:23:14.831]                           invokeRestart("muffleWarning")
[13:23:14.831]                       }
[13:23:14.831]                       else if (inherits(cond, "condition")) {
[13:23:14.831]                         if (!is.null(pattern)) {
[13:23:14.831]                           computeRestarts <- base::computeRestarts
[13:23:14.831]                           grepl <- base::grepl
[13:23:14.831]                           restarts <- computeRestarts(cond)
[13:23:14.831]                           for (restart in restarts) {
[13:23:14.831]                             name <- restart$name
[13:23:14.831]                             if (is.null(name)) 
[13:23:14.831]                               next
[13:23:14.831]                             if (!grepl(pattern, name)) 
[13:23:14.831]                               next
[13:23:14.831]                             invokeRestart(restart)
[13:23:14.831]                             muffled <- TRUE
[13:23:14.831]                             break
[13:23:14.831]                           }
[13:23:14.831]                         }
[13:23:14.831]                       }
[13:23:14.831]                       invisible(muffled)
[13:23:14.831]                     }
[13:23:14.831]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.831]                   }
[13:23:14.831]                 }
[13:23:14.831]             }
[13:23:14.831]         }))
[13:23:14.831]     }, error = function(ex) {
[13:23:14.831]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.831]                 ...future.rng), started = ...future.startTime, 
[13:23:14.831]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.831]             version = "1.8"), class = "FutureResult")
[13:23:14.831]     }, finally = {
[13:23:14.831]         if (!identical(...future.workdir, getwd())) 
[13:23:14.831]             setwd(...future.workdir)
[13:23:14.831]         {
[13:23:14.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.831]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.831]             }
[13:23:14.831]             base::options(...future.oldOptions)
[13:23:14.831]             if (.Platform$OS.type == "windows") {
[13:23:14.831]                 old_names <- names(...future.oldEnvVars)
[13:23:14.831]                 envs <- base::Sys.getenv()
[13:23:14.831]                 names <- names(envs)
[13:23:14.831]                 common <- intersect(names, old_names)
[13:23:14.831]                 added <- setdiff(names, old_names)
[13:23:14.831]                 removed <- setdiff(old_names, names)
[13:23:14.831]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.831]                   envs[common]]
[13:23:14.831]                 NAMES <- toupper(changed)
[13:23:14.831]                 args <- list()
[13:23:14.831]                 for (kk in seq_along(NAMES)) {
[13:23:14.831]                   name <- changed[[kk]]
[13:23:14.831]                   NAME <- NAMES[[kk]]
[13:23:14.831]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.831]                     next
[13:23:14.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.831]                 }
[13:23:14.831]                 NAMES <- toupper(added)
[13:23:14.831]                 for (kk in seq_along(NAMES)) {
[13:23:14.831]                   name <- added[[kk]]
[13:23:14.831]                   NAME <- NAMES[[kk]]
[13:23:14.831]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.831]                     next
[13:23:14.831]                   args[[name]] <- ""
[13:23:14.831]                 }
[13:23:14.831]                 NAMES <- toupper(removed)
[13:23:14.831]                 for (kk in seq_along(NAMES)) {
[13:23:14.831]                   name <- removed[[kk]]
[13:23:14.831]                   NAME <- NAMES[[kk]]
[13:23:14.831]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.831]                     next
[13:23:14.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.831]                 }
[13:23:14.831]                 if (length(args) > 0) 
[13:23:14.831]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.831]             }
[13:23:14.831]             else {
[13:23:14.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.831]             }
[13:23:14.831]             {
[13:23:14.831]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.831]                   0L) {
[13:23:14.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.831]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.831]                   base::options(opts)
[13:23:14.831]                 }
[13:23:14.831]                 {
[13:23:14.831]                   {
[13:23:14.831]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.831]                     NULL
[13:23:14.831]                   }
[13:23:14.831]                   options(future.plan = NULL)
[13:23:14.831]                   if (is.na(NA_character_)) 
[13:23:14.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.831]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.831]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.831]                     envir = parent.frame()) 
[13:23:14.831]                   {
[13:23:14.831]                     if (is.function(workers)) 
[13:23:14.831]                       workers <- workers()
[13:23:14.831]                     workers <- structure(as.integer(workers), 
[13:23:14.831]                       class = class(workers))
[13:23:14.831]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.831]                       workers >= 1)
[13:23:14.831]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.831]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.831]                     }
[13:23:14.831]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.831]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.831]                       envir = envir)
[13:23:14.831]                     if (!future$lazy) 
[13:23:14.831]                       future <- run(future)
[13:23:14.831]                     invisible(future)
[13:23:14.831]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.831]                 }
[13:23:14.831]             }
[13:23:14.831]         }
[13:23:14.831]     })
[13:23:14.831]     if (TRUE) {
[13:23:14.831]         base::sink(type = "output", split = FALSE)
[13:23:14.831]         if (TRUE) {
[13:23:14.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.831]         }
[13:23:14.831]         else {
[13:23:14.831]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.831]         }
[13:23:14.831]         base::close(...future.stdout)
[13:23:14.831]         ...future.stdout <- NULL
[13:23:14.831]     }
[13:23:14.831]     ...future.result$conditions <- ...future.conditions
[13:23:14.831]     ...future.result$finished <- base::Sys.time()
[13:23:14.831]     ...future.result
[13:23:14.831] }
[13:23:14.834] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:23:14.834] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:23:14.835] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:23:14.835] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:23:14.838] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:23:14.838] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:23:14.839] MultisessionFuture started
[13:23:14.839] - Launch lazy future ... done
[13:23:14.839] run() for ‘MultisessionFuture’ ... done
[13:23:14.839] result() for ClusterFuture ...
[13:23:14.839] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.840] - Validating connection of MultisessionFuture
[13:23:14.887] - received message: FutureResult
[13:23:14.887] - Received FutureResult
[13:23:14.887] - Erased future from FutureRegistry
[13:23:14.887] result() for ClusterFuture ...
[13:23:14.887] - result already collected: FutureResult
[13:23:14.887] result() for ClusterFuture ... done
[13:23:14.887] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:14.887] result() for ClusterFuture ... done
[13:23:14.888] result() for ClusterFuture ...
[13:23:14.888] - result already collected: FutureResult
[13:23:14.888] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:14.890] getGlobalsAndPackages() ...
[13:23:14.890] Searching for globals...
[13:23:14.891] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:14.891] Searching for globals ... DONE
[13:23:14.892] Resolving globals: FALSE
[13:23:14.892] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:14.893] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:14.893] - globals: [2] ‘weight’, ‘group’
[13:23:14.893] - packages: [1] ‘stats’
[13:23:14.893] getGlobalsAndPackages() ... DONE
[13:23:14.893] run() for ‘Future’ ...
[13:23:14.893] - state: ‘created’
[13:23:14.894] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:14.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:14.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:14.908]   - Field: ‘node’
[13:23:14.908]   - Field: ‘label’
[13:23:14.908]   - Field: ‘local’
[13:23:14.908]   - Field: ‘owner’
[13:23:14.909]   - Field: ‘envir’
[13:23:14.909]   - Field: ‘workers’
[13:23:14.909]   - Field: ‘packages’
[13:23:14.909]   - Field: ‘gc’
[13:23:14.909]   - Field: ‘conditions’
[13:23:14.909]   - Field: ‘persistent’
[13:23:14.909]   - Field: ‘expr’
[13:23:14.909]   - Field: ‘uuid’
[13:23:14.909]   - Field: ‘seed’
[13:23:14.909]   - Field: ‘version’
[13:23:14.909]   - Field: ‘result’
[13:23:14.910]   - Field: ‘asynchronous’
[13:23:14.910]   - Field: ‘calls’
[13:23:14.910]   - Field: ‘globals’
[13:23:14.910]   - Field: ‘stdout’
[13:23:14.910]   - Field: ‘earlySignal’
[13:23:14.910]   - Field: ‘lazy’
[13:23:14.910]   - Field: ‘state’
[13:23:14.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:14.910] - Launch lazy future ...
[13:23:14.911] Packages needed by the future expression (n = 1): ‘stats’
[13:23:14.911] Packages needed by future strategies (n = 0): <none>
[13:23:14.911] {
[13:23:14.911]     {
[13:23:14.911]         {
[13:23:14.911]             ...future.startTime <- base::Sys.time()
[13:23:14.911]             {
[13:23:14.911]                 {
[13:23:14.911]                   {
[13:23:14.911]                     {
[13:23:14.911]                       {
[13:23:14.911]                         base::local({
[13:23:14.911]                           has_future <- base::requireNamespace("future", 
[13:23:14.911]                             quietly = TRUE)
[13:23:14.911]                           if (has_future) {
[13:23:14.911]                             ns <- base::getNamespace("future")
[13:23:14.911]                             version <- ns[[".package"]][["version"]]
[13:23:14.911]                             if (is.null(version)) 
[13:23:14.911]                               version <- utils::packageVersion("future")
[13:23:14.911]                           }
[13:23:14.911]                           else {
[13:23:14.911]                             version <- NULL
[13:23:14.911]                           }
[13:23:14.911]                           if (!has_future || version < "1.8.0") {
[13:23:14.911]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.911]                               "", base::R.version$version.string), 
[13:23:14.911]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:14.911]                                 base::R.version$platform, 8 * 
[13:23:14.911]                                   base::.Machine$sizeof.pointer), 
[13:23:14.911]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.911]                                 "release", "version")], collapse = " "), 
[13:23:14.911]                               hostname = base::Sys.info()[["nodename"]])
[13:23:14.911]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.911]                               info)
[13:23:14.911]                             info <- base::paste(info, collapse = "; ")
[13:23:14.911]                             if (!has_future) {
[13:23:14.911]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.911]                                 info)
[13:23:14.911]                             }
[13:23:14.911]                             else {
[13:23:14.911]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.911]                                 info, version)
[13:23:14.911]                             }
[13:23:14.911]                             base::stop(msg)
[13:23:14.911]                           }
[13:23:14.911]                         })
[13:23:14.911]                       }
[13:23:14.911]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.911]                       base::options(mc.cores = 1L)
[13:23:14.911]                     }
[13:23:14.911]                     base::local({
[13:23:14.911]                       for (pkg in "stats") {
[13:23:14.911]                         base::loadNamespace(pkg)
[13:23:14.911]                         base::library(pkg, character.only = TRUE)
[13:23:14.911]                       }
[13:23:14.911]                     })
[13:23:14.911]                   }
[13:23:14.911]                   options(future.plan = NULL)
[13:23:14.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.911]                 }
[13:23:14.911]                 ...future.workdir <- getwd()
[13:23:14.911]             }
[13:23:14.911]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.911]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.911]         }
[13:23:14.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.911]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.911]             base::names(...future.oldOptions))
[13:23:14.911]     }
[13:23:14.911]     if (FALSE) {
[13:23:14.911]     }
[13:23:14.911]     else {
[13:23:14.911]         if (TRUE) {
[13:23:14.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.911]                 open = "w")
[13:23:14.911]         }
[13:23:14.911]         else {
[13:23:14.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.911]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.911]         }
[13:23:14.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.911]             base::sink(type = "output", split = FALSE)
[13:23:14.911]             base::close(...future.stdout)
[13:23:14.911]         }, add = TRUE)
[13:23:14.911]     }
[13:23:14.911]     ...future.frame <- base::sys.nframe()
[13:23:14.911]     ...future.conditions <- base::list()
[13:23:14.911]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.911]     if (FALSE) {
[13:23:14.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.911]     }
[13:23:14.911]     ...future.result <- base::tryCatch({
[13:23:14.911]         base::withCallingHandlers({
[13:23:14.911]             ...future.value <- base::withVisible(base::local({
[13:23:14.911]                 ...future.makeSendCondition <- base::local({
[13:23:14.911]                   sendCondition <- NULL
[13:23:14.911]                   function(frame = 1L) {
[13:23:14.911]                     if (is.function(sendCondition)) 
[13:23:14.911]                       return(sendCondition)
[13:23:14.911]                     ns <- getNamespace("parallel")
[13:23:14.911]                     if (exists("sendData", mode = "function", 
[13:23:14.911]                       envir = ns)) {
[13:23:14.911]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.911]                         envir = ns)
[13:23:14.911]                       envir <- sys.frame(frame)
[13:23:14.911]                       master <- NULL
[13:23:14.911]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.911]                         !identical(envir, emptyenv())) {
[13:23:14.911]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.911]                           inherits = FALSE)) {
[13:23:14.911]                           master <- get("master", mode = "list", 
[13:23:14.911]                             envir = envir, inherits = FALSE)
[13:23:14.911]                           if (inherits(master, c("SOCKnode", 
[13:23:14.911]                             "SOCK0node"))) {
[13:23:14.911]                             sendCondition <<- function(cond) {
[13:23:14.911]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.911]                                 success = TRUE)
[13:23:14.911]                               parallel_sendData(master, data)
[13:23:14.911]                             }
[13:23:14.911]                             return(sendCondition)
[13:23:14.911]                           }
[13:23:14.911]                         }
[13:23:14.911]                         frame <- frame + 1L
[13:23:14.911]                         envir <- sys.frame(frame)
[13:23:14.911]                       }
[13:23:14.911]                     }
[13:23:14.911]                     sendCondition <<- function(cond) NULL
[13:23:14.911]                   }
[13:23:14.911]                 })
[13:23:14.911]                 withCallingHandlers({
[13:23:14.911]                   {
[13:23:14.911]                     lm(weight ~ group - 1)
[13:23:14.911]                   }
[13:23:14.911]                 }, immediateCondition = function(cond) {
[13:23:14.911]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.911]                   sendCondition(cond)
[13:23:14.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.911]                   {
[13:23:14.911]                     inherits <- base::inherits
[13:23:14.911]                     invokeRestart <- base::invokeRestart
[13:23:14.911]                     is.null <- base::is.null
[13:23:14.911]                     muffled <- FALSE
[13:23:14.911]                     if (inherits(cond, "message")) {
[13:23:14.911]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.911]                       if (muffled) 
[13:23:14.911]                         invokeRestart("muffleMessage")
[13:23:14.911]                     }
[13:23:14.911]                     else if (inherits(cond, "warning")) {
[13:23:14.911]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.911]                       if (muffled) 
[13:23:14.911]                         invokeRestart("muffleWarning")
[13:23:14.911]                     }
[13:23:14.911]                     else if (inherits(cond, "condition")) {
[13:23:14.911]                       if (!is.null(pattern)) {
[13:23:14.911]                         computeRestarts <- base::computeRestarts
[13:23:14.911]                         grepl <- base::grepl
[13:23:14.911]                         restarts <- computeRestarts(cond)
[13:23:14.911]                         for (restart in restarts) {
[13:23:14.911]                           name <- restart$name
[13:23:14.911]                           if (is.null(name)) 
[13:23:14.911]                             next
[13:23:14.911]                           if (!grepl(pattern, name)) 
[13:23:14.911]                             next
[13:23:14.911]                           invokeRestart(restart)
[13:23:14.911]                           muffled <- TRUE
[13:23:14.911]                           break
[13:23:14.911]                         }
[13:23:14.911]                       }
[13:23:14.911]                     }
[13:23:14.911]                     invisible(muffled)
[13:23:14.911]                   }
[13:23:14.911]                   muffleCondition(cond)
[13:23:14.911]                 })
[13:23:14.911]             }))
[13:23:14.911]             future::FutureResult(value = ...future.value$value, 
[13:23:14.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.911]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.911]                     ...future.globalenv.names))
[13:23:14.911]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.911]         }, condition = base::local({
[13:23:14.911]             c <- base::c
[13:23:14.911]             inherits <- base::inherits
[13:23:14.911]             invokeRestart <- base::invokeRestart
[13:23:14.911]             length <- base::length
[13:23:14.911]             list <- base::list
[13:23:14.911]             seq.int <- base::seq.int
[13:23:14.911]             signalCondition <- base::signalCondition
[13:23:14.911]             sys.calls <- base::sys.calls
[13:23:14.911]             `[[` <- base::`[[`
[13:23:14.911]             `+` <- base::`+`
[13:23:14.911]             `<<-` <- base::`<<-`
[13:23:14.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.911]                   3L)]
[13:23:14.911]             }
[13:23:14.911]             function(cond) {
[13:23:14.911]                 is_error <- inherits(cond, "error")
[13:23:14.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.911]                   NULL)
[13:23:14.911]                 if (is_error) {
[13:23:14.911]                   sessionInformation <- function() {
[13:23:14.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.911]                       search = base::search(), system = base::Sys.info())
[13:23:14.911]                   }
[13:23:14.911]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.911]                     cond$call), session = sessionInformation(), 
[13:23:14.911]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.911]                   signalCondition(cond)
[13:23:14.911]                 }
[13:23:14.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.911]                 "immediateCondition"))) {
[13:23:14.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.911]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.911]                   if (TRUE && !signal) {
[13:23:14.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.911]                     {
[13:23:14.911]                       inherits <- base::inherits
[13:23:14.911]                       invokeRestart <- base::invokeRestart
[13:23:14.911]                       is.null <- base::is.null
[13:23:14.911]                       muffled <- FALSE
[13:23:14.911]                       if (inherits(cond, "message")) {
[13:23:14.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.911]                         if (muffled) 
[13:23:14.911]                           invokeRestart("muffleMessage")
[13:23:14.911]                       }
[13:23:14.911]                       else if (inherits(cond, "warning")) {
[13:23:14.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.911]                         if (muffled) 
[13:23:14.911]                           invokeRestart("muffleWarning")
[13:23:14.911]                       }
[13:23:14.911]                       else if (inherits(cond, "condition")) {
[13:23:14.911]                         if (!is.null(pattern)) {
[13:23:14.911]                           computeRestarts <- base::computeRestarts
[13:23:14.911]                           grepl <- base::grepl
[13:23:14.911]                           restarts <- computeRestarts(cond)
[13:23:14.911]                           for (restart in restarts) {
[13:23:14.911]                             name <- restart$name
[13:23:14.911]                             if (is.null(name)) 
[13:23:14.911]                               next
[13:23:14.911]                             if (!grepl(pattern, name)) 
[13:23:14.911]                               next
[13:23:14.911]                             invokeRestart(restart)
[13:23:14.911]                             muffled <- TRUE
[13:23:14.911]                             break
[13:23:14.911]                           }
[13:23:14.911]                         }
[13:23:14.911]                       }
[13:23:14.911]                       invisible(muffled)
[13:23:14.911]                     }
[13:23:14.911]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.911]                   }
[13:23:14.911]                 }
[13:23:14.911]                 else {
[13:23:14.911]                   if (TRUE) {
[13:23:14.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.911]                     {
[13:23:14.911]                       inherits <- base::inherits
[13:23:14.911]                       invokeRestart <- base::invokeRestart
[13:23:14.911]                       is.null <- base::is.null
[13:23:14.911]                       muffled <- FALSE
[13:23:14.911]                       if (inherits(cond, "message")) {
[13:23:14.911]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.911]                         if (muffled) 
[13:23:14.911]                           invokeRestart("muffleMessage")
[13:23:14.911]                       }
[13:23:14.911]                       else if (inherits(cond, "warning")) {
[13:23:14.911]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.911]                         if (muffled) 
[13:23:14.911]                           invokeRestart("muffleWarning")
[13:23:14.911]                       }
[13:23:14.911]                       else if (inherits(cond, "condition")) {
[13:23:14.911]                         if (!is.null(pattern)) {
[13:23:14.911]                           computeRestarts <- base::computeRestarts
[13:23:14.911]                           grepl <- base::grepl
[13:23:14.911]                           restarts <- computeRestarts(cond)
[13:23:14.911]                           for (restart in restarts) {
[13:23:14.911]                             name <- restart$name
[13:23:14.911]                             if (is.null(name)) 
[13:23:14.911]                               next
[13:23:14.911]                             if (!grepl(pattern, name)) 
[13:23:14.911]                               next
[13:23:14.911]                             invokeRestart(restart)
[13:23:14.911]                             muffled <- TRUE
[13:23:14.911]                             break
[13:23:14.911]                           }
[13:23:14.911]                         }
[13:23:14.911]                       }
[13:23:14.911]                       invisible(muffled)
[13:23:14.911]                     }
[13:23:14.911]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.911]                   }
[13:23:14.911]                 }
[13:23:14.911]             }
[13:23:14.911]         }))
[13:23:14.911]     }, error = function(ex) {
[13:23:14.911]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.911]                 ...future.rng), started = ...future.startTime, 
[13:23:14.911]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.911]             version = "1.8"), class = "FutureResult")
[13:23:14.911]     }, finally = {
[13:23:14.911]         if (!identical(...future.workdir, getwd())) 
[13:23:14.911]             setwd(...future.workdir)
[13:23:14.911]         {
[13:23:14.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.911]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.911]             }
[13:23:14.911]             base::options(...future.oldOptions)
[13:23:14.911]             if (.Platform$OS.type == "windows") {
[13:23:14.911]                 old_names <- names(...future.oldEnvVars)
[13:23:14.911]                 envs <- base::Sys.getenv()
[13:23:14.911]                 names <- names(envs)
[13:23:14.911]                 common <- intersect(names, old_names)
[13:23:14.911]                 added <- setdiff(names, old_names)
[13:23:14.911]                 removed <- setdiff(old_names, names)
[13:23:14.911]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.911]                   envs[common]]
[13:23:14.911]                 NAMES <- toupper(changed)
[13:23:14.911]                 args <- list()
[13:23:14.911]                 for (kk in seq_along(NAMES)) {
[13:23:14.911]                   name <- changed[[kk]]
[13:23:14.911]                   NAME <- NAMES[[kk]]
[13:23:14.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.911]                     next
[13:23:14.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.911]                 }
[13:23:14.911]                 NAMES <- toupper(added)
[13:23:14.911]                 for (kk in seq_along(NAMES)) {
[13:23:14.911]                   name <- added[[kk]]
[13:23:14.911]                   NAME <- NAMES[[kk]]
[13:23:14.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.911]                     next
[13:23:14.911]                   args[[name]] <- ""
[13:23:14.911]                 }
[13:23:14.911]                 NAMES <- toupper(removed)
[13:23:14.911]                 for (kk in seq_along(NAMES)) {
[13:23:14.911]                   name <- removed[[kk]]
[13:23:14.911]                   NAME <- NAMES[[kk]]
[13:23:14.911]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.911]                     next
[13:23:14.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.911]                 }
[13:23:14.911]                 if (length(args) > 0) 
[13:23:14.911]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.911]             }
[13:23:14.911]             else {
[13:23:14.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.911]             }
[13:23:14.911]             {
[13:23:14.911]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.911]                   0L) {
[13:23:14.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.911]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.911]                   base::options(opts)
[13:23:14.911]                 }
[13:23:14.911]                 {
[13:23:14.911]                   {
[13:23:14.911]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.911]                     NULL
[13:23:14.911]                   }
[13:23:14.911]                   options(future.plan = NULL)
[13:23:14.911]                   if (is.na(NA_character_)) 
[13:23:14.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.911]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.911]                     envir = parent.frame()) 
[13:23:14.911]                   {
[13:23:14.911]                     if (is.function(workers)) 
[13:23:14.911]                       workers <- workers()
[13:23:14.911]                     workers <- structure(as.integer(workers), 
[13:23:14.911]                       class = class(workers))
[13:23:14.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.911]                       workers >= 1)
[13:23:14.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.911]                     }
[13:23:14.911]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.911]                       envir = envir)
[13:23:14.911]                     if (!future$lazy) 
[13:23:14.911]                       future <- run(future)
[13:23:14.911]                     invisible(future)
[13:23:14.911]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.911]                 }
[13:23:14.911]             }
[13:23:14.911]         }
[13:23:14.911]     })
[13:23:14.911]     if (TRUE) {
[13:23:14.911]         base::sink(type = "output", split = FALSE)
[13:23:14.911]         if (TRUE) {
[13:23:14.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.911]         }
[13:23:14.911]         else {
[13:23:14.911]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.911]         }
[13:23:14.911]         base::close(...future.stdout)
[13:23:14.911]         ...future.stdout <- NULL
[13:23:14.911]     }
[13:23:14.911]     ...future.result$conditions <- ...future.conditions
[13:23:14.911]     ...future.result$finished <- base::Sys.time()
[13:23:14.911]     ...future.result
[13:23:14.911] }
[13:23:14.914] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:23:14.915] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:23:14.915] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:23:14.915] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:23:14.915] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:23:14.916] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:23:14.916] MultisessionFuture started
[13:23:14.916] - Launch lazy future ... done
[13:23:14.917] run() for ‘MultisessionFuture’ ... done
[13:23:14.917] result() for ClusterFuture ...
[13:23:14.917] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.917] - Validating connection of MultisessionFuture
[13:23:14.966] - received message: FutureResult
[13:23:14.967] - Received FutureResult
[13:23:14.967] - Erased future from FutureRegistry
[13:23:14.967] result() for ClusterFuture ...
[13:23:14.967] - result already collected: FutureResult
[13:23:14.967] result() for ClusterFuture ... done
[13:23:14.967] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:14.967] result() for ClusterFuture ... done
[13:23:14.967] result() for ClusterFuture ...
[13:23:14.968] - result already collected: FutureResult
[13:23:14.968] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[13:23:14.970] getGlobalsAndPackages() ...
[13:23:14.970] Searching for globals...
[13:23:14.971] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[13:23:14.971] Searching for globals ... DONE
[13:23:14.972] Resolving globals: FALSE
[13:23:14.972] The total size of the 2 globals is 896 bytes (896 bytes)
[13:23:14.972] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[13:23:14.973] - globals: [2] ‘weight’, ‘group’
[13:23:14.973] - packages: [1] ‘stats’
[13:23:14.973] getGlobalsAndPackages() ... DONE
[13:23:14.973] run() for ‘Future’ ...
[13:23:14.973] - state: ‘created’
[13:23:14.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:14.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:14.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:14.990]   - Field: ‘node’
[13:23:14.990]   - Field: ‘label’
[13:23:14.990]   - Field: ‘local’
[13:23:14.990]   - Field: ‘owner’
[13:23:14.991]   - Field: ‘envir’
[13:23:14.991]   - Field: ‘workers’
[13:23:14.991]   - Field: ‘packages’
[13:23:14.991]   - Field: ‘gc’
[13:23:14.991]   - Field: ‘conditions’
[13:23:14.991]   - Field: ‘persistent’
[13:23:14.991]   - Field: ‘expr’
[13:23:14.991]   - Field: ‘uuid’
[13:23:14.991]   - Field: ‘seed’
[13:23:14.991]   - Field: ‘version’
[13:23:14.992]   - Field: ‘result’
[13:23:14.992]   - Field: ‘asynchronous’
[13:23:14.992]   - Field: ‘calls’
[13:23:14.992]   - Field: ‘globals’
[13:23:14.992]   - Field: ‘stdout’
[13:23:14.992]   - Field: ‘earlySignal’
[13:23:14.992]   - Field: ‘lazy’
[13:23:14.992]   - Field: ‘state’
[13:23:14.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:14.992] - Launch lazy future ...
[13:23:14.993] Packages needed by the future expression (n = 1): ‘stats’
[13:23:14.993] Packages needed by future strategies (n = 0): <none>
[13:23:14.994] {
[13:23:14.994]     {
[13:23:14.994]         {
[13:23:14.994]             ...future.startTime <- base::Sys.time()
[13:23:14.994]             {
[13:23:14.994]                 {
[13:23:14.994]                   {
[13:23:14.994]                     {
[13:23:14.994]                       {
[13:23:14.994]                         base::local({
[13:23:14.994]                           has_future <- base::requireNamespace("future", 
[13:23:14.994]                             quietly = TRUE)
[13:23:14.994]                           if (has_future) {
[13:23:14.994]                             ns <- base::getNamespace("future")
[13:23:14.994]                             version <- ns[[".package"]][["version"]]
[13:23:14.994]                             if (is.null(version)) 
[13:23:14.994]                               version <- utils::packageVersion("future")
[13:23:14.994]                           }
[13:23:14.994]                           else {
[13:23:14.994]                             version <- NULL
[13:23:14.994]                           }
[13:23:14.994]                           if (!has_future || version < "1.8.0") {
[13:23:14.994]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:14.994]                               "", base::R.version$version.string), 
[13:23:14.994]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:14.994]                                 base::R.version$platform, 8 * 
[13:23:14.994]                                   base::.Machine$sizeof.pointer), 
[13:23:14.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:14.994]                                 "release", "version")], collapse = " "), 
[13:23:14.994]                               hostname = base::Sys.info()[["nodename"]])
[13:23:14.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:14.994]                               info)
[13:23:14.994]                             info <- base::paste(info, collapse = "; ")
[13:23:14.994]                             if (!has_future) {
[13:23:14.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:14.994]                                 info)
[13:23:14.994]                             }
[13:23:14.994]                             else {
[13:23:14.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:14.994]                                 info, version)
[13:23:14.994]                             }
[13:23:14.994]                             base::stop(msg)
[13:23:14.994]                           }
[13:23:14.994]                         })
[13:23:14.994]                       }
[13:23:14.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:14.994]                       base::options(mc.cores = 1L)
[13:23:14.994]                     }
[13:23:14.994]                     base::local({
[13:23:14.994]                       for (pkg in "stats") {
[13:23:14.994]                         base::loadNamespace(pkg)
[13:23:14.994]                         base::library(pkg, character.only = TRUE)
[13:23:14.994]                       }
[13:23:14.994]                     })
[13:23:14.994]                   }
[13:23:14.994]                   options(future.plan = NULL)
[13:23:14.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:14.994]                 }
[13:23:14.994]                 ...future.workdir <- getwd()
[13:23:14.994]             }
[13:23:14.994]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:14.994]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:14.994]         }
[13:23:14.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:14.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:14.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:14.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:14.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:14.994]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:14.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:14.994]             base::names(...future.oldOptions))
[13:23:14.994]     }
[13:23:14.994]     if (FALSE) {
[13:23:14.994]     }
[13:23:14.994]     else {
[13:23:14.994]         if (TRUE) {
[13:23:14.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:14.994]                 open = "w")
[13:23:14.994]         }
[13:23:14.994]         else {
[13:23:14.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:14.994]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:14.994]         }
[13:23:14.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:14.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:14.994]             base::sink(type = "output", split = FALSE)
[13:23:14.994]             base::close(...future.stdout)
[13:23:14.994]         }, add = TRUE)
[13:23:14.994]     }
[13:23:14.994]     ...future.frame <- base::sys.nframe()
[13:23:14.994]     ...future.conditions <- base::list()
[13:23:14.994]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:14.994]     if (FALSE) {
[13:23:14.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:14.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:14.994]     }
[13:23:14.994]     ...future.result <- base::tryCatch({
[13:23:14.994]         base::withCallingHandlers({
[13:23:14.994]             ...future.value <- base::withVisible(base::local({
[13:23:14.994]                 ...future.makeSendCondition <- base::local({
[13:23:14.994]                   sendCondition <- NULL
[13:23:14.994]                   function(frame = 1L) {
[13:23:14.994]                     if (is.function(sendCondition)) 
[13:23:14.994]                       return(sendCondition)
[13:23:14.994]                     ns <- getNamespace("parallel")
[13:23:14.994]                     if (exists("sendData", mode = "function", 
[13:23:14.994]                       envir = ns)) {
[13:23:14.994]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:14.994]                         envir = ns)
[13:23:14.994]                       envir <- sys.frame(frame)
[13:23:14.994]                       master <- NULL
[13:23:14.994]                       while (!identical(envir, .GlobalEnv) && 
[13:23:14.994]                         !identical(envir, emptyenv())) {
[13:23:14.994]                         if (exists("master", mode = "list", envir = envir, 
[13:23:14.994]                           inherits = FALSE)) {
[13:23:14.994]                           master <- get("master", mode = "list", 
[13:23:14.994]                             envir = envir, inherits = FALSE)
[13:23:14.994]                           if (inherits(master, c("SOCKnode", 
[13:23:14.994]                             "SOCK0node"))) {
[13:23:14.994]                             sendCondition <<- function(cond) {
[13:23:14.994]                               data <- list(type = "VALUE", value = cond, 
[13:23:14.994]                                 success = TRUE)
[13:23:14.994]                               parallel_sendData(master, data)
[13:23:14.994]                             }
[13:23:14.994]                             return(sendCondition)
[13:23:14.994]                           }
[13:23:14.994]                         }
[13:23:14.994]                         frame <- frame + 1L
[13:23:14.994]                         envir <- sys.frame(frame)
[13:23:14.994]                       }
[13:23:14.994]                     }
[13:23:14.994]                     sendCondition <<- function(cond) NULL
[13:23:14.994]                   }
[13:23:14.994]                 })
[13:23:14.994]                 withCallingHandlers({
[13:23:14.994]                   {
[13:23:14.994]                     lm(weight ~ group - 1)
[13:23:14.994]                   }
[13:23:14.994]                 }, immediateCondition = function(cond) {
[13:23:14.994]                   sendCondition <- ...future.makeSendCondition()
[13:23:14.994]                   sendCondition(cond)
[13:23:14.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.994]                   {
[13:23:14.994]                     inherits <- base::inherits
[13:23:14.994]                     invokeRestart <- base::invokeRestart
[13:23:14.994]                     is.null <- base::is.null
[13:23:14.994]                     muffled <- FALSE
[13:23:14.994]                     if (inherits(cond, "message")) {
[13:23:14.994]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:14.994]                       if (muffled) 
[13:23:14.994]                         invokeRestart("muffleMessage")
[13:23:14.994]                     }
[13:23:14.994]                     else if (inherits(cond, "warning")) {
[13:23:14.994]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:14.994]                       if (muffled) 
[13:23:14.994]                         invokeRestart("muffleWarning")
[13:23:14.994]                     }
[13:23:14.994]                     else if (inherits(cond, "condition")) {
[13:23:14.994]                       if (!is.null(pattern)) {
[13:23:14.994]                         computeRestarts <- base::computeRestarts
[13:23:14.994]                         grepl <- base::grepl
[13:23:14.994]                         restarts <- computeRestarts(cond)
[13:23:14.994]                         for (restart in restarts) {
[13:23:14.994]                           name <- restart$name
[13:23:14.994]                           if (is.null(name)) 
[13:23:14.994]                             next
[13:23:14.994]                           if (!grepl(pattern, name)) 
[13:23:14.994]                             next
[13:23:14.994]                           invokeRestart(restart)
[13:23:14.994]                           muffled <- TRUE
[13:23:14.994]                           break
[13:23:14.994]                         }
[13:23:14.994]                       }
[13:23:14.994]                     }
[13:23:14.994]                     invisible(muffled)
[13:23:14.994]                   }
[13:23:14.994]                   muffleCondition(cond)
[13:23:14.994]                 })
[13:23:14.994]             }))
[13:23:14.994]             future::FutureResult(value = ...future.value$value, 
[13:23:14.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.994]                   ...future.rng), globalenv = if (FALSE) 
[13:23:14.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:14.994]                     ...future.globalenv.names))
[13:23:14.994]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:14.994]         }, condition = base::local({
[13:23:14.994]             c <- base::c
[13:23:14.994]             inherits <- base::inherits
[13:23:14.994]             invokeRestart <- base::invokeRestart
[13:23:14.994]             length <- base::length
[13:23:14.994]             list <- base::list
[13:23:14.994]             seq.int <- base::seq.int
[13:23:14.994]             signalCondition <- base::signalCondition
[13:23:14.994]             sys.calls <- base::sys.calls
[13:23:14.994]             `[[` <- base::`[[`
[13:23:14.994]             `+` <- base::`+`
[13:23:14.994]             `<<-` <- base::`<<-`
[13:23:14.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:14.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:14.994]                   3L)]
[13:23:14.994]             }
[13:23:14.994]             function(cond) {
[13:23:14.994]                 is_error <- inherits(cond, "error")
[13:23:14.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:14.994]                   NULL)
[13:23:14.994]                 if (is_error) {
[13:23:14.994]                   sessionInformation <- function() {
[13:23:14.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:14.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:14.994]                       search = base::search(), system = base::Sys.info())
[13:23:14.994]                   }
[13:23:14.994]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:14.994]                     cond$call), session = sessionInformation(), 
[13:23:14.994]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:14.994]                   signalCondition(cond)
[13:23:14.994]                 }
[13:23:14.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:14.994]                 "immediateCondition"))) {
[13:23:14.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:14.994]                   ...future.conditions[[length(...future.conditions) + 
[13:23:14.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:14.994]                   if (TRUE && !signal) {
[13:23:14.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.994]                     {
[13:23:14.994]                       inherits <- base::inherits
[13:23:14.994]                       invokeRestart <- base::invokeRestart
[13:23:14.994]                       is.null <- base::is.null
[13:23:14.994]                       muffled <- FALSE
[13:23:14.994]                       if (inherits(cond, "message")) {
[13:23:14.994]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.994]                         if (muffled) 
[13:23:14.994]                           invokeRestart("muffleMessage")
[13:23:14.994]                       }
[13:23:14.994]                       else if (inherits(cond, "warning")) {
[13:23:14.994]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.994]                         if (muffled) 
[13:23:14.994]                           invokeRestart("muffleWarning")
[13:23:14.994]                       }
[13:23:14.994]                       else if (inherits(cond, "condition")) {
[13:23:14.994]                         if (!is.null(pattern)) {
[13:23:14.994]                           computeRestarts <- base::computeRestarts
[13:23:14.994]                           grepl <- base::grepl
[13:23:14.994]                           restarts <- computeRestarts(cond)
[13:23:14.994]                           for (restart in restarts) {
[13:23:14.994]                             name <- restart$name
[13:23:14.994]                             if (is.null(name)) 
[13:23:14.994]                               next
[13:23:14.994]                             if (!grepl(pattern, name)) 
[13:23:14.994]                               next
[13:23:14.994]                             invokeRestart(restart)
[13:23:14.994]                             muffled <- TRUE
[13:23:14.994]                             break
[13:23:14.994]                           }
[13:23:14.994]                         }
[13:23:14.994]                       }
[13:23:14.994]                       invisible(muffled)
[13:23:14.994]                     }
[13:23:14.994]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.994]                   }
[13:23:14.994]                 }
[13:23:14.994]                 else {
[13:23:14.994]                   if (TRUE) {
[13:23:14.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:14.994]                     {
[13:23:14.994]                       inherits <- base::inherits
[13:23:14.994]                       invokeRestart <- base::invokeRestart
[13:23:14.994]                       is.null <- base::is.null
[13:23:14.994]                       muffled <- FALSE
[13:23:14.994]                       if (inherits(cond, "message")) {
[13:23:14.994]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:14.994]                         if (muffled) 
[13:23:14.994]                           invokeRestart("muffleMessage")
[13:23:14.994]                       }
[13:23:14.994]                       else if (inherits(cond, "warning")) {
[13:23:14.994]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:14.994]                         if (muffled) 
[13:23:14.994]                           invokeRestart("muffleWarning")
[13:23:14.994]                       }
[13:23:14.994]                       else if (inherits(cond, "condition")) {
[13:23:14.994]                         if (!is.null(pattern)) {
[13:23:14.994]                           computeRestarts <- base::computeRestarts
[13:23:14.994]                           grepl <- base::grepl
[13:23:14.994]                           restarts <- computeRestarts(cond)
[13:23:14.994]                           for (restart in restarts) {
[13:23:14.994]                             name <- restart$name
[13:23:14.994]                             if (is.null(name)) 
[13:23:14.994]                               next
[13:23:14.994]                             if (!grepl(pattern, name)) 
[13:23:14.994]                               next
[13:23:14.994]                             invokeRestart(restart)
[13:23:14.994]                             muffled <- TRUE
[13:23:14.994]                             break
[13:23:14.994]                           }
[13:23:14.994]                         }
[13:23:14.994]                       }
[13:23:14.994]                       invisible(muffled)
[13:23:14.994]                     }
[13:23:14.994]                     muffleCondition(cond, pattern = "^muffle")
[13:23:14.994]                   }
[13:23:14.994]                 }
[13:23:14.994]             }
[13:23:14.994]         }))
[13:23:14.994]     }, error = function(ex) {
[13:23:14.994]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:14.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:14.994]                 ...future.rng), started = ...future.startTime, 
[13:23:14.994]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:14.994]             version = "1.8"), class = "FutureResult")
[13:23:14.994]     }, finally = {
[13:23:14.994]         if (!identical(...future.workdir, getwd())) 
[13:23:14.994]             setwd(...future.workdir)
[13:23:14.994]         {
[13:23:14.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:14.994]                 ...future.oldOptions$nwarnings <- NULL
[13:23:14.994]             }
[13:23:14.994]             base::options(...future.oldOptions)
[13:23:14.994]             if (.Platform$OS.type == "windows") {
[13:23:14.994]                 old_names <- names(...future.oldEnvVars)
[13:23:14.994]                 envs <- base::Sys.getenv()
[13:23:14.994]                 names <- names(envs)
[13:23:14.994]                 common <- intersect(names, old_names)
[13:23:14.994]                 added <- setdiff(names, old_names)
[13:23:14.994]                 removed <- setdiff(old_names, names)
[13:23:14.994]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:14.994]                   envs[common]]
[13:23:14.994]                 NAMES <- toupper(changed)
[13:23:14.994]                 args <- list()
[13:23:14.994]                 for (kk in seq_along(NAMES)) {
[13:23:14.994]                   name <- changed[[kk]]
[13:23:14.994]                   NAME <- NAMES[[kk]]
[13:23:14.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.994]                     next
[13:23:14.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.994]                 }
[13:23:14.994]                 NAMES <- toupper(added)
[13:23:14.994]                 for (kk in seq_along(NAMES)) {
[13:23:14.994]                   name <- added[[kk]]
[13:23:14.994]                   NAME <- NAMES[[kk]]
[13:23:14.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.994]                     next
[13:23:14.994]                   args[[name]] <- ""
[13:23:14.994]                 }
[13:23:14.994]                 NAMES <- toupper(removed)
[13:23:14.994]                 for (kk in seq_along(NAMES)) {
[13:23:14.994]                   name <- removed[[kk]]
[13:23:14.994]                   NAME <- NAMES[[kk]]
[13:23:14.994]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:14.994]                     next
[13:23:14.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:14.994]                 }
[13:23:14.994]                 if (length(args) > 0) 
[13:23:14.994]                   base::do.call(base::Sys.setenv, args = args)
[13:23:14.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:14.994]             }
[13:23:14.994]             else {
[13:23:14.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:14.994]             }
[13:23:14.994]             {
[13:23:14.994]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:14.994]                   0L) {
[13:23:14.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:14.994]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:14.994]                   base::options(opts)
[13:23:14.994]                 }
[13:23:14.994]                 {
[13:23:14.994]                   {
[13:23:14.994]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:14.994]                     NULL
[13:23:14.994]                   }
[13:23:14.994]                   options(future.plan = NULL)
[13:23:14.994]                   if (is.na(NA_character_)) 
[13:23:14.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:14.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:14.994]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:14.994]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:14.994]                     envir = parent.frame()) 
[13:23:14.994]                   {
[13:23:14.994]                     if (is.function(workers)) 
[13:23:14.994]                       workers <- workers()
[13:23:14.994]                     workers <- structure(as.integer(workers), 
[13:23:14.994]                       class = class(workers))
[13:23:14.994]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:14.994]                       workers >= 1)
[13:23:14.994]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:14.994]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:14.994]                     }
[13:23:14.994]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:14.994]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:14.994]                       envir = envir)
[13:23:14.994]                     if (!future$lazy) 
[13:23:14.994]                       future <- run(future)
[13:23:14.994]                     invisible(future)
[13:23:14.994]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:14.994]                 }
[13:23:14.994]             }
[13:23:14.994]         }
[13:23:14.994]     })
[13:23:14.994]     if (TRUE) {
[13:23:14.994]         base::sink(type = "output", split = FALSE)
[13:23:14.994]         if (TRUE) {
[13:23:14.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:14.994]         }
[13:23:14.994]         else {
[13:23:14.994]             ...future.result["stdout"] <- base::list(NULL)
[13:23:14.994]         }
[13:23:14.994]         base::close(...future.stdout)
[13:23:14.994]         ...future.stdout <- NULL
[13:23:14.994]     }
[13:23:14.994]     ...future.result$conditions <- ...future.conditions
[13:23:14.994]     ...future.result$finished <- base::Sys.time()
[13:23:14.994]     ...future.result
[13:23:14.994] }
[13:23:14.997] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[13:23:14.997] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[13:23:14.997] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[13:23:14.997] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[13:23:14.998] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[13:23:14.998] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[13:23:14.998] MultisessionFuture started
[13:23:14.999] - Launch lazy future ... done
[13:23:14.999] run() for ‘MultisessionFuture’ ... done
[13:23:14.999] result() for ClusterFuture ...
[13:23:14.999] receiveMessageFromWorker() for ClusterFuture ...
[13:23:14.999] - Validating connection of MultisessionFuture
[13:23:15.047] - received message: FutureResult
[13:23:15.047] - Received FutureResult
[13:23:15.047] - Erased future from FutureRegistry
[13:23:15.047] result() for ClusterFuture ...
[13:23:15.047] - result already collected: FutureResult
[13:23:15.047] result() for ClusterFuture ... done
[13:23:15.048] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.048] result() for ClusterFuture ... done
[13:23:15.048] result() for ClusterFuture ...
[13:23:15.048] - result already collected: FutureResult
[13:23:15.048] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[13:23:15.050] getGlobalsAndPackages() ...
[13:23:15.050] Searching for globals...
[13:23:15.051] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:15.051] Searching for globals ... DONE
[13:23:15.052] Resolving globals: FALSE
[13:23:15.052] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:15.052] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:15.053] - globals: [1] ‘x’
[13:23:15.053] - packages: [1] ‘stats’
[13:23:15.053] getGlobalsAndPackages() ... DONE
[13:23:15.053] run() for ‘Future’ ...
[13:23:15.053] - state: ‘created’
[13:23:15.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.068]   - Field: ‘node’
[13:23:15.068]   - Field: ‘label’
[13:23:15.068]   - Field: ‘local’
[13:23:15.068]   - Field: ‘owner’
[13:23:15.068]   - Field: ‘envir’
[13:23:15.069]   - Field: ‘workers’
[13:23:15.069]   - Field: ‘packages’
[13:23:15.069]   - Field: ‘gc’
[13:23:15.069]   - Field: ‘conditions’
[13:23:15.069]   - Field: ‘persistent’
[13:23:15.069]   - Field: ‘expr’
[13:23:15.069]   - Field: ‘uuid’
[13:23:15.069]   - Field: ‘seed’
[13:23:15.069]   - Field: ‘version’
[13:23:15.069]   - Field: ‘result’
[13:23:15.070]   - Field: ‘asynchronous’
[13:23:15.070]   - Field: ‘calls’
[13:23:15.070]   - Field: ‘globals’
[13:23:15.070]   - Field: ‘stdout’
[13:23:15.070]   - Field: ‘earlySignal’
[13:23:15.070]   - Field: ‘lazy’
[13:23:15.070]   - Field: ‘state’
[13:23:15.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.070] - Launch lazy future ...
[13:23:15.071] Packages needed by the future expression (n = 1): ‘stats’
[13:23:15.071] Packages needed by future strategies (n = 0): <none>
[13:23:15.071] {
[13:23:15.071]     {
[13:23:15.071]         {
[13:23:15.071]             ...future.startTime <- base::Sys.time()
[13:23:15.071]             {
[13:23:15.071]                 {
[13:23:15.071]                   {
[13:23:15.071]                     {
[13:23:15.071]                       {
[13:23:15.071]                         base::local({
[13:23:15.071]                           has_future <- base::requireNamespace("future", 
[13:23:15.071]                             quietly = TRUE)
[13:23:15.071]                           if (has_future) {
[13:23:15.071]                             ns <- base::getNamespace("future")
[13:23:15.071]                             version <- ns[[".package"]][["version"]]
[13:23:15.071]                             if (is.null(version)) 
[13:23:15.071]                               version <- utils::packageVersion("future")
[13:23:15.071]                           }
[13:23:15.071]                           else {
[13:23:15.071]                             version <- NULL
[13:23:15.071]                           }
[13:23:15.071]                           if (!has_future || version < "1.8.0") {
[13:23:15.071]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.071]                               "", base::R.version$version.string), 
[13:23:15.071]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.071]                                 base::R.version$platform, 8 * 
[13:23:15.071]                                   base::.Machine$sizeof.pointer), 
[13:23:15.071]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.071]                                 "release", "version")], collapse = " "), 
[13:23:15.071]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.071]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.071]                               info)
[13:23:15.071]                             info <- base::paste(info, collapse = "; ")
[13:23:15.071]                             if (!has_future) {
[13:23:15.071]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.071]                                 info)
[13:23:15.071]                             }
[13:23:15.071]                             else {
[13:23:15.071]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.071]                                 info, version)
[13:23:15.071]                             }
[13:23:15.071]                             base::stop(msg)
[13:23:15.071]                           }
[13:23:15.071]                         })
[13:23:15.071]                       }
[13:23:15.071]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.071]                       base::options(mc.cores = 1L)
[13:23:15.071]                     }
[13:23:15.071]                     base::local({
[13:23:15.071]                       for (pkg in "stats") {
[13:23:15.071]                         base::loadNamespace(pkg)
[13:23:15.071]                         base::library(pkg, character.only = TRUE)
[13:23:15.071]                       }
[13:23:15.071]                     })
[13:23:15.071]                   }
[13:23:15.071]                   options(future.plan = NULL)
[13:23:15.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.071]                 }
[13:23:15.071]                 ...future.workdir <- getwd()
[13:23:15.071]             }
[13:23:15.071]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.071]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.071]         }
[13:23:15.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.071]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.071]             base::names(...future.oldOptions))
[13:23:15.071]     }
[13:23:15.071]     if (FALSE) {
[13:23:15.071]     }
[13:23:15.071]     else {
[13:23:15.071]         if (TRUE) {
[13:23:15.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.071]                 open = "w")
[13:23:15.071]         }
[13:23:15.071]         else {
[13:23:15.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.071]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.071]         }
[13:23:15.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.071]             base::sink(type = "output", split = FALSE)
[13:23:15.071]             base::close(...future.stdout)
[13:23:15.071]         }, add = TRUE)
[13:23:15.071]     }
[13:23:15.071]     ...future.frame <- base::sys.nframe()
[13:23:15.071]     ...future.conditions <- base::list()
[13:23:15.071]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.071]     if (FALSE) {
[13:23:15.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.071]     }
[13:23:15.071]     ...future.result <- base::tryCatch({
[13:23:15.071]         base::withCallingHandlers({
[13:23:15.071]             ...future.value <- base::withVisible(base::local({
[13:23:15.071]                 ...future.makeSendCondition <- base::local({
[13:23:15.071]                   sendCondition <- NULL
[13:23:15.071]                   function(frame = 1L) {
[13:23:15.071]                     if (is.function(sendCondition)) 
[13:23:15.071]                       return(sendCondition)
[13:23:15.071]                     ns <- getNamespace("parallel")
[13:23:15.071]                     if (exists("sendData", mode = "function", 
[13:23:15.071]                       envir = ns)) {
[13:23:15.071]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.071]                         envir = ns)
[13:23:15.071]                       envir <- sys.frame(frame)
[13:23:15.071]                       master <- NULL
[13:23:15.071]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.071]                         !identical(envir, emptyenv())) {
[13:23:15.071]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.071]                           inherits = FALSE)) {
[13:23:15.071]                           master <- get("master", mode = "list", 
[13:23:15.071]                             envir = envir, inherits = FALSE)
[13:23:15.071]                           if (inherits(master, c("SOCKnode", 
[13:23:15.071]                             "SOCK0node"))) {
[13:23:15.071]                             sendCondition <<- function(cond) {
[13:23:15.071]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.071]                                 success = TRUE)
[13:23:15.071]                               parallel_sendData(master, data)
[13:23:15.071]                             }
[13:23:15.071]                             return(sendCondition)
[13:23:15.071]                           }
[13:23:15.071]                         }
[13:23:15.071]                         frame <- frame + 1L
[13:23:15.071]                         envir <- sys.frame(frame)
[13:23:15.071]                       }
[13:23:15.071]                     }
[13:23:15.071]                     sendCondition <<- function(cond) NULL
[13:23:15.071]                   }
[13:23:15.071]                 })
[13:23:15.071]                 withCallingHandlers({
[13:23:15.071]                   {
[13:23:15.071]                     xtabs(~x)
[13:23:15.071]                   }
[13:23:15.071]                 }, immediateCondition = function(cond) {
[13:23:15.071]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.071]                   sendCondition(cond)
[13:23:15.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.071]                   {
[13:23:15.071]                     inherits <- base::inherits
[13:23:15.071]                     invokeRestart <- base::invokeRestart
[13:23:15.071]                     is.null <- base::is.null
[13:23:15.071]                     muffled <- FALSE
[13:23:15.071]                     if (inherits(cond, "message")) {
[13:23:15.071]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.071]                       if (muffled) 
[13:23:15.071]                         invokeRestart("muffleMessage")
[13:23:15.071]                     }
[13:23:15.071]                     else if (inherits(cond, "warning")) {
[13:23:15.071]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.071]                       if (muffled) 
[13:23:15.071]                         invokeRestart("muffleWarning")
[13:23:15.071]                     }
[13:23:15.071]                     else if (inherits(cond, "condition")) {
[13:23:15.071]                       if (!is.null(pattern)) {
[13:23:15.071]                         computeRestarts <- base::computeRestarts
[13:23:15.071]                         grepl <- base::grepl
[13:23:15.071]                         restarts <- computeRestarts(cond)
[13:23:15.071]                         for (restart in restarts) {
[13:23:15.071]                           name <- restart$name
[13:23:15.071]                           if (is.null(name)) 
[13:23:15.071]                             next
[13:23:15.071]                           if (!grepl(pattern, name)) 
[13:23:15.071]                             next
[13:23:15.071]                           invokeRestart(restart)
[13:23:15.071]                           muffled <- TRUE
[13:23:15.071]                           break
[13:23:15.071]                         }
[13:23:15.071]                       }
[13:23:15.071]                     }
[13:23:15.071]                     invisible(muffled)
[13:23:15.071]                   }
[13:23:15.071]                   muffleCondition(cond)
[13:23:15.071]                 })
[13:23:15.071]             }))
[13:23:15.071]             future::FutureResult(value = ...future.value$value, 
[13:23:15.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.071]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.071]                     ...future.globalenv.names))
[13:23:15.071]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.071]         }, condition = base::local({
[13:23:15.071]             c <- base::c
[13:23:15.071]             inherits <- base::inherits
[13:23:15.071]             invokeRestart <- base::invokeRestart
[13:23:15.071]             length <- base::length
[13:23:15.071]             list <- base::list
[13:23:15.071]             seq.int <- base::seq.int
[13:23:15.071]             signalCondition <- base::signalCondition
[13:23:15.071]             sys.calls <- base::sys.calls
[13:23:15.071]             `[[` <- base::`[[`
[13:23:15.071]             `+` <- base::`+`
[13:23:15.071]             `<<-` <- base::`<<-`
[13:23:15.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.071]                   3L)]
[13:23:15.071]             }
[13:23:15.071]             function(cond) {
[13:23:15.071]                 is_error <- inherits(cond, "error")
[13:23:15.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.071]                   NULL)
[13:23:15.071]                 if (is_error) {
[13:23:15.071]                   sessionInformation <- function() {
[13:23:15.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.071]                       search = base::search(), system = base::Sys.info())
[13:23:15.071]                   }
[13:23:15.071]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.071]                     cond$call), session = sessionInformation(), 
[13:23:15.071]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.071]                   signalCondition(cond)
[13:23:15.071]                 }
[13:23:15.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.071]                 "immediateCondition"))) {
[13:23:15.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.071]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.071]                   if (TRUE && !signal) {
[13:23:15.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.071]                     {
[13:23:15.071]                       inherits <- base::inherits
[13:23:15.071]                       invokeRestart <- base::invokeRestart
[13:23:15.071]                       is.null <- base::is.null
[13:23:15.071]                       muffled <- FALSE
[13:23:15.071]                       if (inherits(cond, "message")) {
[13:23:15.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.071]                         if (muffled) 
[13:23:15.071]                           invokeRestart("muffleMessage")
[13:23:15.071]                       }
[13:23:15.071]                       else if (inherits(cond, "warning")) {
[13:23:15.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.071]                         if (muffled) 
[13:23:15.071]                           invokeRestart("muffleWarning")
[13:23:15.071]                       }
[13:23:15.071]                       else if (inherits(cond, "condition")) {
[13:23:15.071]                         if (!is.null(pattern)) {
[13:23:15.071]                           computeRestarts <- base::computeRestarts
[13:23:15.071]                           grepl <- base::grepl
[13:23:15.071]                           restarts <- computeRestarts(cond)
[13:23:15.071]                           for (restart in restarts) {
[13:23:15.071]                             name <- restart$name
[13:23:15.071]                             if (is.null(name)) 
[13:23:15.071]                               next
[13:23:15.071]                             if (!grepl(pattern, name)) 
[13:23:15.071]                               next
[13:23:15.071]                             invokeRestart(restart)
[13:23:15.071]                             muffled <- TRUE
[13:23:15.071]                             break
[13:23:15.071]                           }
[13:23:15.071]                         }
[13:23:15.071]                       }
[13:23:15.071]                       invisible(muffled)
[13:23:15.071]                     }
[13:23:15.071]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.071]                   }
[13:23:15.071]                 }
[13:23:15.071]                 else {
[13:23:15.071]                   if (TRUE) {
[13:23:15.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.071]                     {
[13:23:15.071]                       inherits <- base::inherits
[13:23:15.071]                       invokeRestart <- base::invokeRestart
[13:23:15.071]                       is.null <- base::is.null
[13:23:15.071]                       muffled <- FALSE
[13:23:15.071]                       if (inherits(cond, "message")) {
[13:23:15.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.071]                         if (muffled) 
[13:23:15.071]                           invokeRestart("muffleMessage")
[13:23:15.071]                       }
[13:23:15.071]                       else if (inherits(cond, "warning")) {
[13:23:15.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.071]                         if (muffled) 
[13:23:15.071]                           invokeRestart("muffleWarning")
[13:23:15.071]                       }
[13:23:15.071]                       else if (inherits(cond, "condition")) {
[13:23:15.071]                         if (!is.null(pattern)) {
[13:23:15.071]                           computeRestarts <- base::computeRestarts
[13:23:15.071]                           grepl <- base::grepl
[13:23:15.071]                           restarts <- computeRestarts(cond)
[13:23:15.071]                           for (restart in restarts) {
[13:23:15.071]                             name <- restart$name
[13:23:15.071]                             if (is.null(name)) 
[13:23:15.071]                               next
[13:23:15.071]                             if (!grepl(pattern, name)) 
[13:23:15.071]                               next
[13:23:15.071]                             invokeRestart(restart)
[13:23:15.071]                             muffled <- TRUE
[13:23:15.071]                             break
[13:23:15.071]                           }
[13:23:15.071]                         }
[13:23:15.071]                       }
[13:23:15.071]                       invisible(muffled)
[13:23:15.071]                     }
[13:23:15.071]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.071]                   }
[13:23:15.071]                 }
[13:23:15.071]             }
[13:23:15.071]         }))
[13:23:15.071]     }, error = function(ex) {
[13:23:15.071]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.071]                 ...future.rng), started = ...future.startTime, 
[13:23:15.071]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.071]             version = "1.8"), class = "FutureResult")
[13:23:15.071]     }, finally = {
[13:23:15.071]         if (!identical(...future.workdir, getwd())) 
[13:23:15.071]             setwd(...future.workdir)
[13:23:15.071]         {
[13:23:15.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.071]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.071]             }
[13:23:15.071]             base::options(...future.oldOptions)
[13:23:15.071]             if (.Platform$OS.type == "windows") {
[13:23:15.071]                 old_names <- names(...future.oldEnvVars)
[13:23:15.071]                 envs <- base::Sys.getenv()
[13:23:15.071]                 names <- names(envs)
[13:23:15.071]                 common <- intersect(names, old_names)
[13:23:15.071]                 added <- setdiff(names, old_names)
[13:23:15.071]                 removed <- setdiff(old_names, names)
[13:23:15.071]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.071]                   envs[common]]
[13:23:15.071]                 NAMES <- toupper(changed)
[13:23:15.071]                 args <- list()
[13:23:15.071]                 for (kk in seq_along(NAMES)) {
[13:23:15.071]                   name <- changed[[kk]]
[13:23:15.071]                   NAME <- NAMES[[kk]]
[13:23:15.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.071]                     next
[13:23:15.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.071]                 }
[13:23:15.071]                 NAMES <- toupper(added)
[13:23:15.071]                 for (kk in seq_along(NAMES)) {
[13:23:15.071]                   name <- added[[kk]]
[13:23:15.071]                   NAME <- NAMES[[kk]]
[13:23:15.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.071]                     next
[13:23:15.071]                   args[[name]] <- ""
[13:23:15.071]                 }
[13:23:15.071]                 NAMES <- toupper(removed)
[13:23:15.071]                 for (kk in seq_along(NAMES)) {
[13:23:15.071]                   name <- removed[[kk]]
[13:23:15.071]                   NAME <- NAMES[[kk]]
[13:23:15.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.071]                     next
[13:23:15.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.071]                 }
[13:23:15.071]                 if (length(args) > 0) 
[13:23:15.071]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.071]             }
[13:23:15.071]             else {
[13:23:15.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.071]             }
[13:23:15.071]             {
[13:23:15.071]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.071]                   0L) {
[13:23:15.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.071]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.071]                   base::options(opts)
[13:23:15.071]                 }
[13:23:15.071]                 {
[13:23:15.071]                   {
[13:23:15.071]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.071]                     NULL
[13:23:15.071]                   }
[13:23:15.071]                   options(future.plan = NULL)
[13:23:15.071]                   if (is.na(NA_character_)) 
[13:23:15.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.071]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.071]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.071]                     envir = parent.frame()) 
[13:23:15.071]                   {
[13:23:15.071]                     if (is.function(workers)) 
[13:23:15.071]                       workers <- workers()
[13:23:15.071]                     workers <- structure(as.integer(workers), 
[13:23:15.071]                       class = class(workers))
[13:23:15.071]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.071]                       workers >= 1)
[13:23:15.071]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.071]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.071]                     }
[13:23:15.071]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.071]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.071]                       envir = envir)
[13:23:15.071]                     if (!future$lazy) 
[13:23:15.071]                       future <- run(future)
[13:23:15.071]                     invisible(future)
[13:23:15.071]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.071]                 }
[13:23:15.071]             }
[13:23:15.071]         }
[13:23:15.071]     })
[13:23:15.071]     if (TRUE) {
[13:23:15.071]         base::sink(type = "output", split = FALSE)
[13:23:15.071]         if (TRUE) {
[13:23:15.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.071]         }
[13:23:15.071]         else {
[13:23:15.071]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.071]         }
[13:23:15.071]         base::close(...future.stdout)
[13:23:15.071]         ...future.stdout <- NULL
[13:23:15.071]     }
[13:23:15.071]     ...future.result$conditions <- ...future.conditions
[13:23:15.071]     ...future.result$finished <- base::Sys.time()
[13:23:15.071]     ...future.result
[13:23:15.071] }
[13:23:15.074] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:23:15.074] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:23:15.075] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:23:15.075] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:23:15.076] MultisessionFuture started
[13:23:15.076] - Launch lazy future ... done
[13:23:15.076] run() for ‘MultisessionFuture’ ... done
[13:23:15.076] result() for ClusterFuture ...
[13:23:15.076] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.076] - Validating connection of MultisessionFuture
[13:23:15.123] - received message: FutureResult
[13:23:15.123] - Received FutureResult
[13:23:15.123] - Erased future from FutureRegistry
[13:23:15.123] result() for ClusterFuture ...
[13:23:15.123] - result already collected: FutureResult
[13:23:15.123] result() for ClusterFuture ... done
[13:23:15.123] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.123] result() for ClusterFuture ... done
[13:23:15.124] result() for ClusterFuture ...
[13:23:15.124] - result already collected: FutureResult
[13:23:15.124] result() for ClusterFuture ... done
x
1 2 
2 3 
[13:23:15.125] getGlobalsAndPackages() ...
[13:23:15.125] Searching for globals...
[13:23:15.126] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[13:23:15.126] Searching for globals ... DONE
[13:23:15.126] Resolving globals: FALSE
[13:23:15.127] The total size of the 1 globals is 96 bytes (96 bytes)
[13:23:15.127] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[13:23:15.127] - globals: [1] ‘x’
[13:23:15.127] - packages: [1] ‘stats’
[13:23:15.127] getGlobalsAndPackages() ... DONE
[13:23:15.128] run() for ‘Future’ ...
[13:23:15.128] - state: ‘created’
[13:23:15.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.143]   - Field: ‘node’
[13:23:15.143]   - Field: ‘label’
[13:23:15.143]   - Field: ‘local’
[13:23:15.143]   - Field: ‘owner’
[13:23:15.143]   - Field: ‘envir’
[13:23:15.143]   - Field: ‘workers’
[13:23:15.143]   - Field: ‘packages’
[13:23:15.143]   - Field: ‘gc’
[13:23:15.143]   - Field: ‘conditions’
[13:23:15.143]   - Field: ‘persistent’
[13:23:15.144]   - Field: ‘expr’
[13:23:15.144]   - Field: ‘uuid’
[13:23:15.144]   - Field: ‘seed’
[13:23:15.144]   - Field: ‘version’
[13:23:15.144]   - Field: ‘result’
[13:23:15.144]   - Field: ‘asynchronous’
[13:23:15.144]   - Field: ‘calls’
[13:23:15.144]   - Field: ‘globals’
[13:23:15.144]   - Field: ‘stdout’
[13:23:15.144]   - Field: ‘earlySignal’
[13:23:15.145]   - Field: ‘lazy’
[13:23:15.145]   - Field: ‘state’
[13:23:15.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.145] - Launch lazy future ...
[13:23:15.145] Packages needed by the future expression (n = 1): ‘stats’
[13:23:15.145] Packages needed by future strategies (n = 0): <none>
[13:23:15.146] {
[13:23:15.146]     {
[13:23:15.146]         {
[13:23:15.146]             ...future.startTime <- base::Sys.time()
[13:23:15.146]             {
[13:23:15.146]                 {
[13:23:15.146]                   {
[13:23:15.146]                     {
[13:23:15.146]                       {
[13:23:15.146]                         base::local({
[13:23:15.146]                           has_future <- base::requireNamespace("future", 
[13:23:15.146]                             quietly = TRUE)
[13:23:15.146]                           if (has_future) {
[13:23:15.146]                             ns <- base::getNamespace("future")
[13:23:15.146]                             version <- ns[[".package"]][["version"]]
[13:23:15.146]                             if (is.null(version)) 
[13:23:15.146]                               version <- utils::packageVersion("future")
[13:23:15.146]                           }
[13:23:15.146]                           else {
[13:23:15.146]                             version <- NULL
[13:23:15.146]                           }
[13:23:15.146]                           if (!has_future || version < "1.8.0") {
[13:23:15.146]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.146]                               "", base::R.version$version.string), 
[13:23:15.146]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.146]                                 base::R.version$platform, 8 * 
[13:23:15.146]                                   base::.Machine$sizeof.pointer), 
[13:23:15.146]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.146]                                 "release", "version")], collapse = " "), 
[13:23:15.146]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.146]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.146]                               info)
[13:23:15.146]                             info <- base::paste(info, collapse = "; ")
[13:23:15.146]                             if (!has_future) {
[13:23:15.146]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.146]                                 info)
[13:23:15.146]                             }
[13:23:15.146]                             else {
[13:23:15.146]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.146]                                 info, version)
[13:23:15.146]                             }
[13:23:15.146]                             base::stop(msg)
[13:23:15.146]                           }
[13:23:15.146]                         })
[13:23:15.146]                       }
[13:23:15.146]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.146]                       base::options(mc.cores = 1L)
[13:23:15.146]                     }
[13:23:15.146]                     base::local({
[13:23:15.146]                       for (pkg in "stats") {
[13:23:15.146]                         base::loadNamespace(pkg)
[13:23:15.146]                         base::library(pkg, character.only = TRUE)
[13:23:15.146]                       }
[13:23:15.146]                     })
[13:23:15.146]                   }
[13:23:15.146]                   options(future.plan = NULL)
[13:23:15.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.146]                 }
[13:23:15.146]                 ...future.workdir <- getwd()
[13:23:15.146]             }
[13:23:15.146]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.146]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.146]         }
[13:23:15.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.146]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.146]             base::names(...future.oldOptions))
[13:23:15.146]     }
[13:23:15.146]     if (FALSE) {
[13:23:15.146]     }
[13:23:15.146]     else {
[13:23:15.146]         if (TRUE) {
[13:23:15.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.146]                 open = "w")
[13:23:15.146]         }
[13:23:15.146]         else {
[13:23:15.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.146]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.146]         }
[13:23:15.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.146]             base::sink(type = "output", split = FALSE)
[13:23:15.146]             base::close(...future.stdout)
[13:23:15.146]         }, add = TRUE)
[13:23:15.146]     }
[13:23:15.146]     ...future.frame <- base::sys.nframe()
[13:23:15.146]     ...future.conditions <- base::list()
[13:23:15.146]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.146]     if (FALSE) {
[13:23:15.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.146]     }
[13:23:15.146]     ...future.result <- base::tryCatch({
[13:23:15.146]         base::withCallingHandlers({
[13:23:15.146]             ...future.value <- base::withVisible(base::local({
[13:23:15.146]                 ...future.makeSendCondition <- base::local({
[13:23:15.146]                   sendCondition <- NULL
[13:23:15.146]                   function(frame = 1L) {
[13:23:15.146]                     if (is.function(sendCondition)) 
[13:23:15.146]                       return(sendCondition)
[13:23:15.146]                     ns <- getNamespace("parallel")
[13:23:15.146]                     if (exists("sendData", mode = "function", 
[13:23:15.146]                       envir = ns)) {
[13:23:15.146]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.146]                         envir = ns)
[13:23:15.146]                       envir <- sys.frame(frame)
[13:23:15.146]                       master <- NULL
[13:23:15.146]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.146]                         !identical(envir, emptyenv())) {
[13:23:15.146]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.146]                           inherits = FALSE)) {
[13:23:15.146]                           master <- get("master", mode = "list", 
[13:23:15.146]                             envir = envir, inherits = FALSE)
[13:23:15.146]                           if (inherits(master, c("SOCKnode", 
[13:23:15.146]                             "SOCK0node"))) {
[13:23:15.146]                             sendCondition <<- function(cond) {
[13:23:15.146]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.146]                                 success = TRUE)
[13:23:15.146]                               parallel_sendData(master, data)
[13:23:15.146]                             }
[13:23:15.146]                             return(sendCondition)
[13:23:15.146]                           }
[13:23:15.146]                         }
[13:23:15.146]                         frame <- frame + 1L
[13:23:15.146]                         envir <- sys.frame(frame)
[13:23:15.146]                       }
[13:23:15.146]                     }
[13:23:15.146]                     sendCondition <<- function(cond) NULL
[13:23:15.146]                   }
[13:23:15.146]                 })
[13:23:15.146]                 withCallingHandlers({
[13:23:15.146]                   {
[13:23:15.146]                     xtabs(~x)
[13:23:15.146]                   }
[13:23:15.146]                 }, immediateCondition = function(cond) {
[13:23:15.146]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.146]                   sendCondition(cond)
[13:23:15.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.146]                   {
[13:23:15.146]                     inherits <- base::inherits
[13:23:15.146]                     invokeRestart <- base::invokeRestart
[13:23:15.146]                     is.null <- base::is.null
[13:23:15.146]                     muffled <- FALSE
[13:23:15.146]                     if (inherits(cond, "message")) {
[13:23:15.146]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.146]                       if (muffled) 
[13:23:15.146]                         invokeRestart("muffleMessage")
[13:23:15.146]                     }
[13:23:15.146]                     else if (inherits(cond, "warning")) {
[13:23:15.146]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.146]                       if (muffled) 
[13:23:15.146]                         invokeRestart("muffleWarning")
[13:23:15.146]                     }
[13:23:15.146]                     else if (inherits(cond, "condition")) {
[13:23:15.146]                       if (!is.null(pattern)) {
[13:23:15.146]                         computeRestarts <- base::computeRestarts
[13:23:15.146]                         grepl <- base::grepl
[13:23:15.146]                         restarts <- computeRestarts(cond)
[13:23:15.146]                         for (restart in restarts) {
[13:23:15.146]                           name <- restart$name
[13:23:15.146]                           if (is.null(name)) 
[13:23:15.146]                             next
[13:23:15.146]                           if (!grepl(pattern, name)) 
[13:23:15.146]                             next
[13:23:15.146]                           invokeRestart(restart)
[13:23:15.146]                           muffled <- TRUE
[13:23:15.146]                           break
[13:23:15.146]                         }
[13:23:15.146]                       }
[13:23:15.146]                     }
[13:23:15.146]                     invisible(muffled)
[13:23:15.146]                   }
[13:23:15.146]                   muffleCondition(cond)
[13:23:15.146]                 })
[13:23:15.146]             }))
[13:23:15.146]             future::FutureResult(value = ...future.value$value, 
[13:23:15.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.146]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.146]                     ...future.globalenv.names))
[13:23:15.146]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.146]         }, condition = base::local({
[13:23:15.146]             c <- base::c
[13:23:15.146]             inherits <- base::inherits
[13:23:15.146]             invokeRestart <- base::invokeRestart
[13:23:15.146]             length <- base::length
[13:23:15.146]             list <- base::list
[13:23:15.146]             seq.int <- base::seq.int
[13:23:15.146]             signalCondition <- base::signalCondition
[13:23:15.146]             sys.calls <- base::sys.calls
[13:23:15.146]             `[[` <- base::`[[`
[13:23:15.146]             `+` <- base::`+`
[13:23:15.146]             `<<-` <- base::`<<-`
[13:23:15.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.146]                   3L)]
[13:23:15.146]             }
[13:23:15.146]             function(cond) {
[13:23:15.146]                 is_error <- inherits(cond, "error")
[13:23:15.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.146]                   NULL)
[13:23:15.146]                 if (is_error) {
[13:23:15.146]                   sessionInformation <- function() {
[13:23:15.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.146]                       search = base::search(), system = base::Sys.info())
[13:23:15.146]                   }
[13:23:15.146]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.146]                     cond$call), session = sessionInformation(), 
[13:23:15.146]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.146]                   signalCondition(cond)
[13:23:15.146]                 }
[13:23:15.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.146]                 "immediateCondition"))) {
[13:23:15.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.146]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.146]                   if (TRUE && !signal) {
[13:23:15.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.146]                     {
[13:23:15.146]                       inherits <- base::inherits
[13:23:15.146]                       invokeRestart <- base::invokeRestart
[13:23:15.146]                       is.null <- base::is.null
[13:23:15.146]                       muffled <- FALSE
[13:23:15.146]                       if (inherits(cond, "message")) {
[13:23:15.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.146]                         if (muffled) 
[13:23:15.146]                           invokeRestart("muffleMessage")
[13:23:15.146]                       }
[13:23:15.146]                       else if (inherits(cond, "warning")) {
[13:23:15.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.146]                         if (muffled) 
[13:23:15.146]                           invokeRestart("muffleWarning")
[13:23:15.146]                       }
[13:23:15.146]                       else if (inherits(cond, "condition")) {
[13:23:15.146]                         if (!is.null(pattern)) {
[13:23:15.146]                           computeRestarts <- base::computeRestarts
[13:23:15.146]                           grepl <- base::grepl
[13:23:15.146]                           restarts <- computeRestarts(cond)
[13:23:15.146]                           for (restart in restarts) {
[13:23:15.146]                             name <- restart$name
[13:23:15.146]                             if (is.null(name)) 
[13:23:15.146]                               next
[13:23:15.146]                             if (!grepl(pattern, name)) 
[13:23:15.146]                               next
[13:23:15.146]                             invokeRestart(restart)
[13:23:15.146]                             muffled <- TRUE
[13:23:15.146]                             break
[13:23:15.146]                           }
[13:23:15.146]                         }
[13:23:15.146]                       }
[13:23:15.146]                       invisible(muffled)
[13:23:15.146]                     }
[13:23:15.146]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.146]                   }
[13:23:15.146]                 }
[13:23:15.146]                 else {
[13:23:15.146]                   if (TRUE) {
[13:23:15.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.146]                     {
[13:23:15.146]                       inherits <- base::inherits
[13:23:15.146]                       invokeRestart <- base::invokeRestart
[13:23:15.146]                       is.null <- base::is.null
[13:23:15.146]                       muffled <- FALSE
[13:23:15.146]                       if (inherits(cond, "message")) {
[13:23:15.146]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.146]                         if (muffled) 
[13:23:15.146]                           invokeRestart("muffleMessage")
[13:23:15.146]                       }
[13:23:15.146]                       else if (inherits(cond, "warning")) {
[13:23:15.146]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.146]                         if (muffled) 
[13:23:15.146]                           invokeRestart("muffleWarning")
[13:23:15.146]                       }
[13:23:15.146]                       else if (inherits(cond, "condition")) {
[13:23:15.146]                         if (!is.null(pattern)) {
[13:23:15.146]                           computeRestarts <- base::computeRestarts
[13:23:15.146]                           grepl <- base::grepl
[13:23:15.146]                           restarts <- computeRestarts(cond)
[13:23:15.146]                           for (restart in restarts) {
[13:23:15.146]                             name <- restart$name
[13:23:15.146]                             if (is.null(name)) 
[13:23:15.146]                               next
[13:23:15.146]                             if (!grepl(pattern, name)) 
[13:23:15.146]                               next
[13:23:15.146]                             invokeRestart(restart)
[13:23:15.146]                             muffled <- TRUE
[13:23:15.146]                             break
[13:23:15.146]                           }
[13:23:15.146]                         }
[13:23:15.146]                       }
[13:23:15.146]                       invisible(muffled)
[13:23:15.146]                     }
[13:23:15.146]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.146]                   }
[13:23:15.146]                 }
[13:23:15.146]             }
[13:23:15.146]         }))
[13:23:15.146]     }, error = function(ex) {
[13:23:15.146]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.146]                 ...future.rng), started = ...future.startTime, 
[13:23:15.146]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.146]             version = "1.8"), class = "FutureResult")
[13:23:15.146]     }, finally = {
[13:23:15.146]         if (!identical(...future.workdir, getwd())) 
[13:23:15.146]             setwd(...future.workdir)
[13:23:15.146]         {
[13:23:15.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.146]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.146]             }
[13:23:15.146]             base::options(...future.oldOptions)
[13:23:15.146]             if (.Platform$OS.type == "windows") {
[13:23:15.146]                 old_names <- names(...future.oldEnvVars)
[13:23:15.146]                 envs <- base::Sys.getenv()
[13:23:15.146]                 names <- names(envs)
[13:23:15.146]                 common <- intersect(names, old_names)
[13:23:15.146]                 added <- setdiff(names, old_names)
[13:23:15.146]                 removed <- setdiff(old_names, names)
[13:23:15.146]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.146]                   envs[common]]
[13:23:15.146]                 NAMES <- toupper(changed)
[13:23:15.146]                 args <- list()
[13:23:15.146]                 for (kk in seq_along(NAMES)) {
[13:23:15.146]                   name <- changed[[kk]]
[13:23:15.146]                   NAME <- NAMES[[kk]]
[13:23:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.146]                     next
[13:23:15.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.146]                 }
[13:23:15.146]                 NAMES <- toupper(added)
[13:23:15.146]                 for (kk in seq_along(NAMES)) {
[13:23:15.146]                   name <- added[[kk]]
[13:23:15.146]                   NAME <- NAMES[[kk]]
[13:23:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.146]                     next
[13:23:15.146]                   args[[name]] <- ""
[13:23:15.146]                 }
[13:23:15.146]                 NAMES <- toupper(removed)
[13:23:15.146]                 for (kk in seq_along(NAMES)) {
[13:23:15.146]                   name <- removed[[kk]]
[13:23:15.146]                   NAME <- NAMES[[kk]]
[13:23:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.146]                     next
[13:23:15.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.146]                 }
[13:23:15.146]                 if (length(args) > 0) 
[13:23:15.146]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.146]             }
[13:23:15.146]             else {
[13:23:15.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.146]             }
[13:23:15.146]             {
[13:23:15.146]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.146]                   0L) {
[13:23:15.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.146]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.146]                   base::options(opts)
[13:23:15.146]                 }
[13:23:15.146]                 {
[13:23:15.146]                   {
[13:23:15.146]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.146]                     NULL
[13:23:15.146]                   }
[13:23:15.146]                   options(future.plan = NULL)
[13:23:15.146]                   if (is.na(NA_character_)) 
[13:23:15.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.146]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.146]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.146]                     envir = parent.frame()) 
[13:23:15.146]                   {
[13:23:15.146]                     if (is.function(workers)) 
[13:23:15.146]                       workers <- workers()
[13:23:15.146]                     workers <- structure(as.integer(workers), 
[13:23:15.146]                       class = class(workers))
[13:23:15.146]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.146]                       workers >= 1)
[13:23:15.146]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.146]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.146]                     }
[13:23:15.146]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.146]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.146]                       envir = envir)
[13:23:15.146]                     if (!future$lazy) 
[13:23:15.146]                       future <- run(future)
[13:23:15.146]                     invisible(future)
[13:23:15.146]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.146]                 }
[13:23:15.146]             }
[13:23:15.146]         }
[13:23:15.146]     })
[13:23:15.146]     if (TRUE) {
[13:23:15.146]         base::sink(type = "output", split = FALSE)
[13:23:15.146]         if (TRUE) {
[13:23:15.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.146]         }
[13:23:15.146]         else {
[13:23:15.146]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.146]         }
[13:23:15.146]         base::close(...future.stdout)
[13:23:15.146]         ...future.stdout <- NULL
[13:23:15.146]     }
[13:23:15.146]     ...future.result$conditions <- ...future.conditions
[13:23:15.146]     ...future.result$finished <- base::Sys.time()
[13:23:15.146]     ...future.result
[13:23:15.146] }
[13:23:15.149] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[13:23:15.149] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[13:23:15.149] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[13:23:15.149] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[13:23:15.150] MultisessionFuture started
[13:23:15.150] - Launch lazy future ... done
[13:23:15.150] run() for ‘MultisessionFuture’ ... done
[13:23:15.150] result() for ClusterFuture ...
[13:23:15.150] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.151] - Validating connection of MultisessionFuture
[13:23:15.198] - received message: FutureResult
[13:23:15.198] - Received FutureResult
[13:23:15.198] - Erased future from FutureRegistry
[13:23:15.198] result() for ClusterFuture ...
[13:23:15.198] - result already collected: FutureResult
[13:23:15.199] result() for ClusterFuture ... done
[13:23:15.199] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.199] result() for ClusterFuture ... done
[13:23:15.199] result() for ClusterFuture ...
[13:23:15.199] - result already collected: FutureResult
[13:23:15.199] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[13:23:15.201] getGlobalsAndPackages() ...
[13:23:15.201] Searching for globals...
[13:23:15.202] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[13:23:15.203] Searching for globals ... DONE
[13:23:15.203] Resolving globals: FALSE
[13:23:15.203] 
[13:23:15.203] - packages: [2] ‘stats’, ‘datasets’
[13:23:15.204] getGlobalsAndPackages() ... DONE
[13:23:15.204] run() for ‘Future’ ...
[13:23:15.204] - state: ‘created’
[13:23:15.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.219]   - Field: ‘node’
[13:23:15.219]   - Field: ‘label’
[13:23:15.219]   - Field: ‘local’
[13:23:15.219]   - Field: ‘owner’
[13:23:15.220]   - Field: ‘envir’
[13:23:15.220]   - Field: ‘workers’
[13:23:15.220]   - Field: ‘packages’
[13:23:15.220]   - Field: ‘gc’
[13:23:15.220]   - Field: ‘conditions’
[13:23:15.220]   - Field: ‘persistent’
[13:23:15.220]   - Field: ‘expr’
[13:23:15.220]   - Field: ‘uuid’
[13:23:15.220]   - Field: ‘seed’
[13:23:15.220]   - Field: ‘version’
[13:23:15.221]   - Field: ‘result’
[13:23:15.221]   - Field: ‘asynchronous’
[13:23:15.221]   - Field: ‘calls’
[13:23:15.221]   - Field: ‘globals’
[13:23:15.221]   - Field: ‘stdout’
[13:23:15.221]   - Field: ‘earlySignal’
[13:23:15.221]   - Field: ‘lazy’
[13:23:15.221]   - Field: ‘state’
[13:23:15.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.221] - Launch lazy future ...
[13:23:15.222] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:15.222] Packages needed by future strategies (n = 0): <none>
[13:23:15.222] {
[13:23:15.222]     {
[13:23:15.222]         {
[13:23:15.222]             ...future.startTime <- base::Sys.time()
[13:23:15.222]             {
[13:23:15.222]                 {
[13:23:15.222]                   {
[13:23:15.222]                     {
[13:23:15.222]                       {
[13:23:15.222]                         base::local({
[13:23:15.222]                           has_future <- base::requireNamespace("future", 
[13:23:15.222]                             quietly = TRUE)
[13:23:15.222]                           if (has_future) {
[13:23:15.222]                             ns <- base::getNamespace("future")
[13:23:15.222]                             version <- ns[[".package"]][["version"]]
[13:23:15.222]                             if (is.null(version)) 
[13:23:15.222]                               version <- utils::packageVersion("future")
[13:23:15.222]                           }
[13:23:15.222]                           else {
[13:23:15.222]                             version <- NULL
[13:23:15.222]                           }
[13:23:15.222]                           if (!has_future || version < "1.8.0") {
[13:23:15.222]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.222]                               "", base::R.version$version.string), 
[13:23:15.222]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.222]                                 base::R.version$platform, 8 * 
[13:23:15.222]                                   base::.Machine$sizeof.pointer), 
[13:23:15.222]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.222]                                 "release", "version")], collapse = " "), 
[13:23:15.222]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.222]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.222]                               info)
[13:23:15.222]                             info <- base::paste(info, collapse = "; ")
[13:23:15.222]                             if (!has_future) {
[13:23:15.222]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.222]                                 info)
[13:23:15.222]                             }
[13:23:15.222]                             else {
[13:23:15.222]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.222]                                 info, version)
[13:23:15.222]                             }
[13:23:15.222]                             base::stop(msg)
[13:23:15.222]                           }
[13:23:15.222]                         })
[13:23:15.222]                       }
[13:23:15.222]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.222]                       base::options(mc.cores = 1L)
[13:23:15.222]                     }
[13:23:15.222]                     base::local({
[13:23:15.222]                       for (pkg in c("stats", "datasets")) {
[13:23:15.222]                         base::loadNamespace(pkg)
[13:23:15.222]                         base::library(pkg, character.only = TRUE)
[13:23:15.222]                       }
[13:23:15.222]                     })
[13:23:15.222]                   }
[13:23:15.222]                   options(future.plan = NULL)
[13:23:15.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.222]                 }
[13:23:15.222]                 ...future.workdir <- getwd()
[13:23:15.222]             }
[13:23:15.222]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.222]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.222]         }
[13:23:15.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.222]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.222]             base::names(...future.oldOptions))
[13:23:15.222]     }
[13:23:15.222]     if (FALSE) {
[13:23:15.222]     }
[13:23:15.222]     else {
[13:23:15.222]         if (TRUE) {
[13:23:15.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.222]                 open = "w")
[13:23:15.222]         }
[13:23:15.222]         else {
[13:23:15.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.222]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.222]         }
[13:23:15.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.222]             base::sink(type = "output", split = FALSE)
[13:23:15.222]             base::close(...future.stdout)
[13:23:15.222]         }, add = TRUE)
[13:23:15.222]     }
[13:23:15.222]     ...future.frame <- base::sys.nframe()
[13:23:15.222]     ...future.conditions <- base::list()
[13:23:15.222]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.222]     if (FALSE) {
[13:23:15.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.222]     }
[13:23:15.222]     ...future.result <- base::tryCatch({
[13:23:15.222]         base::withCallingHandlers({
[13:23:15.222]             ...future.value <- base::withVisible(base::local({
[13:23:15.222]                 ...future.makeSendCondition <- base::local({
[13:23:15.222]                   sendCondition <- NULL
[13:23:15.222]                   function(frame = 1L) {
[13:23:15.222]                     if (is.function(sendCondition)) 
[13:23:15.222]                       return(sendCondition)
[13:23:15.222]                     ns <- getNamespace("parallel")
[13:23:15.222]                     if (exists("sendData", mode = "function", 
[13:23:15.222]                       envir = ns)) {
[13:23:15.222]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.222]                         envir = ns)
[13:23:15.222]                       envir <- sys.frame(frame)
[13:23:15.222]                       master <- NULL
[13:23:15.222]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.222]                         !identical(envir, emptyenv())) {
[13:23:15.222]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.222]                           inherits = FALSE)) {
[13:23:15.222]                           master <- get("master", mode = "list", 
[13:23:15.222]                             envir = envir, inherits = FALSE)
[13:23:15.222]                           if (inherits(master, c("SOCKnode", 
[13:23:15.222]                             "SOCK0node"))) {
[13:23:15.222]                             sendCondition <<- function(cond) {
[13:23:15.222]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.222]                                 success = TRUE)
[13:23:15.222]                               parallel_sendData(master, data)
[13:23:15.222]                             }
[13:23:15.222]                             return(sendCondition)
[13:23:15.222]                           }
[13:23:15.222]                         }
[13:23:15.222]                         frame <- frame + 1L
[13:23:15.222]                         envir <- sys.frame(frame)
[13:23:15.222]                       }
[13:23:15.222]                     }
[13:23:15.222]                     sendCondition <<- function(cond) NULL
[13:23:15.222]                   }
[13:23:15.222]                 })
[13:23:15.222]                 withCallingHandlers({
[13:23:15.222]                   {
[13:23:15.222]                     lm(dist ~ . - 1, data = cars)
[13:23:15.222]                   }
[13:23:15.222]                 }, immediateCondition = function(cond) {
[13:23:15.222]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.222]                   sendCondition(cond)
[13:23:15.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.222]                   {
[13:23:15.222]                     inherits <- base::inherits
[13:23:15.222]                     invokeRestart <- base::invokeRestart
[13:23:15.222]                     is.null <- base::is.null
[13:23:15.222]                     muffled <- FALSE
[13:23:15.222]                     if (inherits(cond, "message")) {
[13:23:15.222]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.222]                       if (muffled) 
[13:23:15.222]                         invokeRestart("muffleMessage")
[13:23:15.222]                     }
[13:23:15.222]                     else if (inherits(cond, "warning")) {
[13:23:15.222]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.222]                       if (muffled) 
[13:23:15.222]                         invokeRestart("muffleWarning")
[13:23:15.222]                     }
[13:23:15.222]                     else if (inherits(cond, "condition")) {
[13:23:15.222]                       if (!is.null(pattern)) {
[13:23:15.222]                         computeRestarts <- base::computeRestarts
[13:23:15.222]                         grepl <- base::grepl
[13:23:15.222]                         restarts <- computeRestarts(cond)
[13:23:15.222]                         for (restart in restarts) {
[13:23:15.222]                           name <- restart$name
[13:23:15.222]                           if (is.null(name)) 
[13:23:15.222]                             next
[13:23:15.222]                           if (!grepl(pattern, name)) 
[13:23:15.222]                             next
[13:23:15.222]                           invokeRestart(restart)
[13:23:15.222]                           muffled <- TRUE
[13:23:15.222]                           break
[13:23:15.222]                         }
[13:23:15.222]                       }
[13:23:15.222]                     }
[13:23:15.222]                     invisible(muffled)
[13:23:15.222]                   }
[13:23:15.222]                   muffleCondition(cond)
[13:23:15.222]                 })
[13:23:15.222]             }))
[13:23:15.222]             future::FutureResult(value = ...future.value$value, 
[13:23:15.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.222]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.222]                     ...future.globalenv.names))
[13:23:15.222]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.222]         }, condition = base::local({
[13:23:15.222]             c <- base::c
[13:23:15.222]             inherits <- base::inherits
[13:23:15.222]             invokeRestart <- base::invokeRestart
[13:23:15.222]             length <- base::length
[13:23:15.222]             list <- base::list
[13:23:15.222]             seq.int <- base::seq.int
[13:23:15.222]             signalCondition <- base::signalCondition
[13:23:15.222]             sys.calls <- base::sys.calls
[13:23:15.222]             `[[` <- base::`[[`
[13:23:15.222]             `+` <- base::`+`
[13:23:15.222]             `<<-` <- base::`<<-`
[13:23:15.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.222]                   3L)]
[13:23:15.222]             }
[13:23:15.222]             function(cond) {
[13:23:15.222]                 is_error <- inherits(cond, "error")
[13:23:15.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.222]                   NULL)
[13:23:15.222]                 if (is_error) {
[13:23:15.222]                   sessionInformation <- function() {
[13:23:15.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.222]                       search = base::search(), system = base::Sys.info())
[13:23:15.222]                   }
[13:23:15.222]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.222]                     cond$call), session = sessionInformation(), 
[13:23:15.222]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.222]                   signalCondition(cond)
[13:23:15.222]                 }
[13:23:15.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.222]                 "immediateCondition"))) {
[13:23:15.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.222]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.222]                   if (TRUE && !signal) {
[13:23:15.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.222]                     {
[13:23:15.222]                       inherits <- base::inherits
[13:23:15.222]                       invokeRestart <- base::invokeRestart
[13:23:15.222]                       is.null <- base::is.null
[13:23:15.222]                       muffled <- FALSE
[13:23:15.222]                       if (inherits(cond, "message")) {
[13:23:15.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.222]                         if (muffled) 
[13:23:15.222]                           invokeRestart("muffleMessage")
[13:23:15.222]                       }
[13:23:15.222]                       else if (inherits(cond, "warning")) {
[13:23:15.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.222]                         if (muffled) 
[13:23:15.222]                           invokeRestart("muffleWarning")
[13:23:15.222]                       }
[13:23:15.222]                       else if (inherits(cond, "condition")) {
[13:23:15.222]                         if (!is.null(pattern)) {
[13:23:15.222]                           computeRestarts <- base::computeRestarts
[13:23:15.222]                           grepl <- base::grepl
[13:23:15.222]                           restarts <- computeRestarts(cond)
[13:23:15.222]                           for (restart in restarts) {
[13:23:15.222]                             name <- restart$name
[13:23:15.222]                             if (is.null(name)) 
[13:23:15.222]                               next
[13:23:15.222]                             if (!grepl(pattern, name)) 
[13:23:15.222]                               next
[13:23:15.222]                             invokeRestart(restart)
[13:23:15.222]                             muffled <- TRUE
[13:23:15.222]                             break
[13:23:15.222]                           }
[13:23:15.222]                         }
[13:23:15.222]                       }
[13:23:15.222]                       invisible(muffled)
[13:23:15.222]                     }
[13:23:15.222]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.222]                   }
[13:23:15.222]                 }
[13:23:15.222]                 else {
[13:23:15.222]                   if (TRUE) {
[13:23:15.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.222]                     {
[13:23:15.222]                       inherits <- base::inherits
[13:23:15.222]                       invokeRestart <- base::invokeRestart
[13:23:15.222]                       is.null <- base::is.null
[13:23:15.222]                       muffled <- FALSE
[13:23:15.222]                       if (inherits(cond, "message")) {
[13:23:15.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.222]                         if (muffled) 
[13:23:15.222]                           invokeRestart("muffleMessage")
[13:23:15.222]                       }
[13:23:15.222]                       else if (inherits(cond, "warning")) {
[13:23:15.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.222]                         if (muffled) 
[13:23:15.222]                           invokeRestart("muffleWarning")
[13:23:15.222]                       }
[13:23:15.222]                       else if (inherits(cond, "condition")) {
[13:23:15.222]                         if (!is.null(pattern)) {
[13:23:15.222]                           computeRestarts <- base::computeRestarts
[13:23:15.222]                           grepl <- base::grepl
[13:23:15.222]                           restarts <- computeRestarts(cond)
[13:23:15.222]                           for (restart in restarts) {
[13:23:15.222]                             name <- restart$name
[13:23:15.222]                             if (is.null(name)) 
[13:23:15.222]                               next
[13:23:15.222]                             if (!grepl(pattern, name)) 
[13:23:15.222]                               next
[13:23:15.222]                             invokeRestart(restart)
[13:23:15.222]                             muffled <- TRUE
[13:23:15.222]                             break
[13:23:15.222]                           }
[13:23:15.222]                         }
[13:23:15.222]                       }
[13:23:15.222]                       invisible(muffled)
[13:23:15.222]                     }
[13:23:15.222]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.222]                   }
[13:23:15.222]                 }
[13:23:15.222]             }
[13:23:15.222]         }))
[13:23:15.222]     }, error = function(ex) {
[13:23:15.222]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.222]                 ...future.rng), started = ...future.startTime, 
[13:23:15.222]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.222]             version = "1.8"), class = "FutureResult")
[13:23:15.222]     }, finally = {
[13:23:15.222]         if (!identical(...future.workdir, getwd())) 
[13:23:15.222]             setwd(...future.workdir)
[13:23:15.222]         {
[13:23:15.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.222]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.222]             }
[13:23:15.222]             base::options(...future.oldOptions)
[13:23:15.222]             if (.Platform$OS.type == "windows") {
[13:23:15.222]                 old_names <- names(...future.oldEnvVars)
[13:23:15.222]                 envs <- base::Sys.getenv()
[13:23:15.222]                 names <- names(envs)
[13:23:15.222]                 common <- intersect(names, old_names)
[13:23:15.222]                 added <- setdiff(names, old_names)
[13:23:15.222]                 removed <- setdiff(old_names, names)
[13:23:15.222]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.222]                   envs[common]]
[13:23:15.222]                 NAMES <- toupper(changed)
[13:23:15.222]                 args <- list()
[13:23:15.222]                 for (kk in seq_along(NAMES)) {
[13:23:15.222]                   name <- changed[[kk]]
[13:23:15.222]                   NAME <- NAMES[[kk]]
[13:23:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.222]                     next
[13:23:15.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.222]                 }
[13:23:15.222]                 NAMES <- toupper(added)
[13:23:15.222]                 for (kk in seq_along(NAMES)) {
[13:23:15.222]                   name <- added[[kk]]
[13:23:15.222]                   NAME <- NAMES[[kk]]
[13:23:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.222]                     next
[13:23:15.222]                   args[[name]] <- ""
[13:23:15.222]                 }
[13:23:15.222]                 NAMES <- toupper(removed)
[13:23:15.222]                 for (kk in seq_along(NAMES)) {
[13:23:15.222]                   name <- removed[[kk]]
[13:23:15.222]                   NAME <- NAMES[[kk]]
[13:23:15.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.222]                     next
[13:23:15.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.222]                 }
[13:23:15.222]                 if (length(args) > 0) 
[13:23:15.222]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.222]             }
[13:23:15.222]             else {
[13:23:15.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.222]             }
[13:23:15.222]             {
[13:23:15.222]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.222]                   0L) {
[13:23:15.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.222]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.222]                   base::options(opts)
[13:23:15.222]                 }
[13:23:15.222]                 {
[13:23:15.222]                   {
[13:23:15.222]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.222]                     NULL
[13:23:15.222]                   }
[13:23:15.222]                   options(future.plan = NULL)
[13:23:15.222]                   if (is.na(NA_character_)) 
[13:23:15.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.222]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.222]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.222]                     envir = parent.frame()) 
[13:23:15.222]                   {
[13:23:15.222]                     if (is.function(workers)) 
[13:23:15.222]                       workers <- workers()
[13:23:15.222]                     workers <- structure(as.integer(workers), 
[13:23:15.222]                       class = class(workers))
[13:23:15.222]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.222]                       workers >= 1)
[13:23:15.222]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.222]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.222]                     }
[13:23:15.222]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.222]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.222]                       envir = envir)
[13:23:15.222]                     if (!future$lazy) 
[13:23:15.222]                       future <- run(future)
[13:23:15.222]                     invisible(future)
[13:23:15.222]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.222]                 }
[13:23:15.222]             }
[13:23:15.222]         }
[13:23:15.222]     })
[13:23:15.222]     if (TRUE) {
[13:23:15.222]         base::sink(type = "output", split = FALSE)
[13:23:15.222]         if (TRUE) {
[13:23:15.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.222]         }
[13:23:15.222]         else {
[13:23:15.222]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.222]         }
[13:23:15.222]         base::close(...future.stdout)
[13:23:15.222]         ...future.stdout <- NULL
[13:23:15.222]     }
[13:23:15.222]     ...future.result$conditions <- ...future.conditions
[13:23:15.222]     ...future.result$finished <- base::Sys.time()
[13:23:15.222]     ...future.result
[13:23:15.222] }
[13:23:15.226] MultisessionFuture started
[13:23:15.226] - Launch lazy future ... done
[13:23:15.226] run() for ‘MultisessionFuture’ ... done
[13:23:15.226] result() for ClusterFuture ...
[13:23:15.226] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.227] - Validating connection of MultisessionFuture
[13:23:15.275] - received message: FutureResult
[13:23:15.275] - Received FutureResult
[13:23:15.275] - Erased future from FutureRegistry
[13:23:15.275] result() for ClusterFuture ...
[13:23:15.275] - result already collected: FutureResult
[13:23:15.276] result() for ClusterFuture ... done
[13:23:15.276] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.276] result() for ClusterFuture ... done
[13:23:15.276] result() for ClusterFuture ...
[13:23:15.276] - result already collected: FutureResult
[13:23:15.276] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[13:23:15.281] getGlobalsAndPackages() ...
[13:23:15.281] Searching for globals...
[13:23:15.283] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[13:23:15.283] Searching for globals ... DONE
[13:23:15.283] Resolving globals: FALSE
[13:23:15.284] 
[13:23:15.284] - packages: [2] ‘stats’, ‘datasets’
[13:23:15.284] getGlobalsAndPackages() ... DONE
[13:23:15.284] run() for ‘Future’ ...
[13:23:15.284] - state: ‘created’
[13:23:15.284] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.299] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.299]   - Field: ‘node’
[13:23:15.300]   - Field: ‘label’
[13:23:15.300]   - Field: ‘local’
[13:23:15.300]   - Field: ‘owner’
[13:23:15.300]   - Field: ‘envir’
[13:23:15.300]   - Field: ‘workers’
[13:23:15.300]   - Field: ‘packages’
[13:23:15.300]   - Field: ‘gc’
[13:23:15.300]   - Field: ‘conditions’
[13:23:15.300]   - Field: ‘persistent’
[13:23:15.300]   - Field: ‘expr’
[13:23:15.301]   - Field: ‘uuid’
[13:23:15.301]   - Field: ‘seed’
[13:23:15.301]   - Field: ‘version’
[13:23:15.301]   - Field: ‘result’
[13:23:15.301]   - Field: ‘asynchronous’
[13:23:15.301]   - Field: ‘calls’
[13:23:15.301]   - Field: ‘globals’
[13:23:15.301]   - Field: ‘stdout’
[13:23:15.301]   - Field: ‘earlySignal’
[13:23:15.301]   - Field: ‘lazy’
[13:23:15.301]   - Field: ‘state’
[13:23:15.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.302] - Launch lazy future ...
[13:23:15.302] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:15.302] Packages needed by future strategies (n = 0): <none>
[13:23:15.303] {
[13:23:15.303]     {
[13:23:15.303]         {
[13:23:15.303]             ...future.startTime <- base::Sys.time()
[13:23:15.303]             {
[13:23:15.303]                 {
[13:23:15.303]                   {
[13:23:15.303]                     {
[13:23:15.303]                       {
[13:23:15.303]                         base::local({
[13:23:15.303]                           has_future <- base::requireNamespace("future", 
[13:23:15.303]                             quietly = TRUE)
[13:23:15.303]                           if (has_future) {
[13:23:15.303]                             ns <- base::getNamespace("future")
[13:23:15.303]                             version <- ns[[".package"]][["version"]]
[13:23:15.303]                             if (is.null(version)) 
[13:23:15.303]                               version <- utils::packageVersion("future")
[13:23:15.303]                           }
[13:23:15.303]                           else {
[13:23:15.303]                             version <- NULL
[13:23:15.303]                           }
[13:23:15.303]                           if (!has_future || version < "1.8.0") {
[13:23:15.303]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.303]                               "", base::R.version$version.string), 
[13:23:15.303]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.303]                                 base::R.version$platform, 8 * 
[13:23:15.303]                                   base::.Machine$sizeof.pointer), 
[13:23:15.303]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.303]                                 "release", "version")], collapse = " "), 
[13:23:15.303]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.303]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.303]                               info)
[13:23:15.303]                             info <- base::paste(info, collapse = "; ")
[13:23:15.303]                             if (!has_future) {
[13:23:15.303]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.303]                                 info)
[13:23:15.303]                             }
[13:23:15.303]                             else {
[13:23:15.303]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.303]                                 info, version)
[13:23:15.303]                             }
[13:23:15.303]                             base::stop(msg)
[13:23:15.303]                           }
[13:23:15.303]                         })
[13:23:15.303]                       }
[13:23:15.303]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.303]                       base::options(mc.cores = 1L)
[13:23:15.303]                     }
[13:23:15.303]                     base::local({
[13:23:15.303]                       for (pkg in c("stats", "datasets")) {
[13:23:15.303]                         base::loadNamespace(pkg)
[13:23:15.303]                         base::library(pkg, character.only = TRUE)
[13:23:15.303]                       }
[13:23:15.303]                     })
[13:23:15.303]                   }
[13:23:15.303]                   options(future.plan = NULL)
[13:23:15.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.303]                 }
[13:23:15.303]                 ...future.workdir <- getwd()
[13:23:15.303]             }
[13:23:15.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.303]         }
[13:23:15.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.303]             base::names(...future.oldOptions))
[13:23:15.303]     }
[13:23:15.303]     if (FALSE) {
[13:23:15.303]     }
[13:23:15.303]     else {
[13:23:15.303]         if (TRUE) {
[13:23:15.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.303]                 open = "w")
[13:23:15.303]         }
[13:23:15.303]         else {
[13:23:15.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.303]         }
[13:23:15.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.303]             base::sink(type = "output", split = FALSE)
[13:23:15.303]             base::close(...future.stdout)
[13:23:15.303]         }, add = TRUE)
[13:23:15.303]     }
[13:23:15.303]     ...future.frame <- base::sys.nframe()
[13:23:15.303]     ...future.conditions <- base::list()
[13:23:15.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.303]     if (FALSE) {
[13:23:15.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.303]     }
[13:23:15.303]     ...future.result <- base::tryCatch({
[13:23:15.303]         base::withCallingHandlers({
[13:23:15.303]             ...future.value <- base::withVisible(base::local({
[13:23:15.303]                 ...future.makeSendCondition <- base::local({
[13:23:15.303]                   sendCondition <- NULL
[13:23:15.303]                   function(frame = 1L) {
[13:23:15.303]                     if (is.function(sendCondition)) 
[13:23:15.303]                       return(sendCondition)
[13:23:15.303]                     ns <- getNamespace("parallel")
[13:23:15.303]                     if (exists("sendData", mode = "function", 
[13:23:15.303]                       envir = ns)) {
[13:23:15.303]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.303]                         envir = ns)
[13:23:15.303]                       envir <- sys.frame(frame)
[13:23:15.303]                       master <- NULL
[13:23:15.303]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.303]                         !identical(envir, emptyenv())) {
[13:23:15.303]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.303]                           inherits = FALSE)) {
[13:23:15.303]                           master <- get("master", mode = "list", 
[13:23:15.303]                             envir = envir, inherits = FALSE)
[13:23:15.303]                           if (inherits(master, c("SOCKnode", 
[13:23:15.303]                             "SOCK0node"))) {
[13:23:15.303]                             sendCondition <<- function(cond) {
[13:23:15.303]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.303]                                 success = TRUE)
[13:23:15.303]                               parallel_sendData(master, data)
[13:23:15.303]                             }
[13:23:15.303]                             return(sendCondition)
[13:23:15.303]                           }
[13:23:15.303]                         }
[13:23:15.303]                         frame <- frame + 1L
[13:23:15.303]                         envir <- sys.frame(frame)
[13:23:15.303]                       }
[13:23:15.303]                     }
[13:23:15.303]                     sendCondition <<- function(cond) NULL
[13:23:15.303]                   }
[13:23:15.303]                 })
[13:23:15.303]                 withCallingHandlers({
[13:23:15.303]                   {
[13:23:15.303]                     lm(dist ~ . + 0, data = cars)
[13:23:15.303]                   }
[13:23:15.303]                 }, immediateCondition = function(cond) {
[13:23:15.303]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.303]                   sendCondition(cond)
[13:23:15.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.303]                   {
[13:23:15.303]                     inherits <- base::inherits
[13:23:15.303]                     invokeRestart <- base::invokeRestart
[13:23:15.303]                     is.null <- base::is.null
[13:23:15.303]                     muffled <- FALSE
[13:23:15.303]                     if (inherits(cond, "message")) {
[13:23:15.303]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.303]                       if (muffled) 
[13:23:15.303]                         invokeRestart("muffleMessage")
[13:23:15.303]                     }
[13:23:15.303]                     else if (inherits(cond, "warning")) {
[13:23:15.303]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.303]                       if (muffled) 
[13:23:15.303]                         invokeRestart("muffleWarning")
[13:23:15.303]                     }
[13:23:15.303]                     else if (inherits(cond, "condition")) {
[13:23:15.303]                       if (!is.null(pattern)) {
[13:23:15.303]                         computeRestarts <- base::computeRestarts
[13:23:15.303]                         grepl <- base::grepl
[13:23:15.303]                         restarts <- computeRestarts(cond)
[13:23:15.303]                         for (restart in restarts) {
[13:23:15.303]                           name <- restart$name
[13:23:15.303]                           if (is.null(name)) 
[13:23:15.303]                             next
[13:23:15.303]                           if (!grepl(pattern, name)) 
[13:23:15.303]                             next
[13:23:15.303]                           invokeRestart(restart)
[13:23:15.303]                           muffled <- TRUE
[13:23:15.303]                           break
[13:23:15.303]                         }
[13:23:15.303]                       }
[13:23:15.303]                     }
[13:23:15.303]                     invisible(muffled)
[13:23:15.303]                   }
[13:23:15.303]                   muffleCondition(cond)
[13:23:15.303]                 })
[13:23:15.303]             }))
[13:23:15.303]             future::FutureResult(value = ...future.value$value, 
[13:23:15.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.303]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.303]                     ...future.globalenv.names))
[13:23:15.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.303]         }, condition = base::local({
[13:23:15.303]             c <- base::c
[13:23:15.303]             inherits <- base::inherits
[13:23:15.303]             invokeRestart <- base::invokeRestart
[13:23:15.303]             length <- base::length
[13:23:15.303]             list <- base::list
[13:23:15.303]             seq.int <- base::seq.int
[13:23:15.303]             signalCondition <- base::signalCondition
[13:23:15.303]             sys.calls <- base::sys.calls
[13:23:15.303]             `[[` <- base::`[[`
[13:23:15.303]             `+` <- base::`+`
[13:23:15.303]             `<<-` <- base::`<<-`
[13:23:15.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.303]                   3L)]
[13:23:15.303]             }
[13:23:15.303]             function(cond) {
[13:23:15.303]                 is_error <- inherits(cond, "error")
[13:23:15.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.303]                   NULL)
[13:23:15.303]                 if (is_error) {
[13:23:15.303]                   sessionInformation <- function() {
[13:23:15.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.303]                       search = base::search(), system = base::Sys.info())
[13:23:15.303]                   }
[13:23:15.303]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.303]                     cond$call), session = sessionInformation(), 
[13:23:15.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.303]                   signalCondition(cond)
[13:23:15.303]                 }
[13:23:15.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.303]                 "immediateCondition"))) {
[13:23:15.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.303]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.303]                   if (TRUE && !signal) {
[13:23:15.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.303]                     {
[13:23:15.303]                       inherits <- base::inherits
[13:23:15.303]                       invokeRestart <- base::invokeRestart
[13:23:15.303]                       is.null <- base::is.null
[13:23:15.303]                       muffled <- FALSE
[13:23:15.303]                       if (inherits(cond, "message")) {
[13:23:15.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.303]                         if (muffled) 
[13:23:15.303]                           invokeRestart("muffleMessage")
[13:23:15.303]                       }
[13:23:15.303]                       else if (inherits(cond, "warning")) {
[13:23:15.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.303]                         if (muffled) 
[13:23:15.303]                           invokeRestart("muffleWarning")
[13:23:15.303]                       }
[13:23:15.303]                       else if (inherits(cond, "condition")) {
[13:23:15.303]                         if (!is.null(pattern)) {
[13:23:15.303]                           computeRestarts <- base::computeRestarts
[13:23:15.303]                           grepl <- base::grepl
[13:23:15.303]                           restarts <- computeRestarts(cond)
[13:23:15.303]                           for (restart in restarts) {
[13:23:15.303]                             name <- restart$name
[13:23:15.303]                             if (is.null(name)) 
[13:23:15.303]                               next
[13:23:15.303]                             if (!grepl(pattern, name)) 
[13:23:15.303]                               next
[13:23:15.303]                             invokeRestart(restart)
[13:23:15.303]                             muffled <- TRUE
[13:23:15.303]                             break
[13:23:15.303]                           }
[13:23:15.303]                         }
[13:23:15.303]                       }
[13:23:15.303]                       invisible(muffled)
[13:23:15.303]                     }
[13:23:15.303]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.303]                   }
[13:23:15.303]                 }
[13:23:15.303]                 else {
[13:23:15.303]                   if (TRUE) {
[13:23:15.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.303]                     {
[13:23:15.303]                       inherits <- base::inherits
[13:23:15.303]                       invokeRestart <- base::invokeRestart
[13:23:15.303]                       is.null <- base::is.null
[13:23:15.303]                       muffled <- FALSE
[13:23:15.303]                       if (inherits(cond, "message")) {
[13:23:15.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.303]                         if (muffled) 
[13:23:15.303]                           invokeRestart("muffleMessage")
[13:23:15.303]                       }
[13:23:15.303]                       else if (inherits(cond, "warning")) {
[13:23:15.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.303]                         if (muffled) 
[13:23:15.303]                           invokeRestart("muffleWarning")
[13:23:15.303]                       }
[13:23:15.303]                       else if (inherits(cond, "condition")) {
[13:23:15.303]                         if (!is.null(pattern)) {
[13:23:15.303]                           computeRestarts <- base::computeRestarts
[13:23:15.303]                           grepl <- base::grepl
[13:23:15.303]                           restarts <- computeRestarts(cond)
[13:23:15.303]                           for (restart in restarts) {
[13:23:15.303]                             name <- restart$name
[13:23:15.303]                             if (is.null(name)) 
[13:23:15.303]                               next
[13:23:15.303]                             if (!grepl(pattern, name)) 
[13:23:15.303]                               next
[13:23:15.303]                             invokeRestart(restart)
[13:23:15.303]                             muffled <- TRUE
[13:23:15.303]                             break
[13:23:15.303]                           }
[13:23:15.303]                         }
[13:23:15.303]                       }
[13:23:15.303]                       invisible(muffled)
[13:23:15.303]                     }
[13:23:15.303]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.303]                   }
[13:23:15.303]                 }
[13:23:15.303]             }
[13:23:15.303]         }))
[13:23:15.303]     }, error = function(ex) {
[13:23:15.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.303]                 ...future.rng), started = ...future.startTime, 
[13:23:15.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.303]             version = "1.8"), class = "FutureResult")
[13:23:15.303]     }, finally = {
[13:23:15.303]         if (!identical(...future.workdir, getwd())) 
[13:23:15.303]             setwd(...future.workdir)
[13:23:15.303]         {
[13:23:15.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.303]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.303]             }
[13:23:15.303]             base::options(...future.oldOptions)
[13:23:15.303]             if (.Platform$OS.type == "windows") {
[13:23:15.303]                 old_names <- names(...future.oldEnvVars)
[13:23:15.303]                 envs <- base::Sys.getenv()
[13:23:15.303]                 names <- names(envs)
[13:23:15.303]                 common <- intersect(names, old_names)
[13:23:15.303]                 added <- setdiff(names, old_names)
[13:23:15.303]                 removed <- setdiff(old_names, names)
[13:23:15.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.303]                   envs[common]]
[13:23:15.303]                 NAMES <- toupper(changed)
[13:23:15.303]                 args <- list()
[13:23:15.303]                 for (kk in seq_along(NAMES)) {
[13:23:15.303]                   name <- changed[[kk]]
[13:23:15.303]                   NAME <- NAMES[[kk]]
[13:23:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.303]                     next
[13:23:15.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.303]                 }
[13:23:15.303]                 NAMES <- toupper(added)
[13:23:15.303]                 for (kk in seq_along(NAMES)) {
[13:23:15.303]                   name <- added[[kk]]
[13:23:15.303]                   NAME <- NAMES[[kk]]
[13:23:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.303]                     next
[13:23:15.303]                   args[[name]] <- ""
[13:23:15.303]                 }
[13:23:15.303]                 NAMES <- toupper(removed)
[13:23:15.303]                 for (kk in seq_along(NAMES)) {
[13:23:15.303]                   name <- removed[[kk]]
[13:23:15.303]                   NAME <- NAMES[[kk]]
[13:23:15.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.303]                     next
[13:23:15.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.303]                 }
[13:23:15.303]                 if (length(args) > 0) 
[13:23:15.303]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.303]             }
[13:23:15.303]             else {
[13:23:15.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.303]             }
[13:23:15.303]             {
[13:23:15.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.303]                   0L) {
[13:23:15.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.303]                   base::options(opts)
[13:23:15.303]                 }
[13:23:15.303]                 {
[13:23:15.303]                   {
[13:23:15.303]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.303]                     NULL
[13:23:15.303]                   }
[13:23:15.303]                   options(future.plan = NULL)
[13:23:15.303]                   if (is.na(NA_character_)) 
[13:23:15.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.303]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.303]                     envir = parent.frame()) 
[13:23:15.303]                   {
[13:23:15.303]                     if (is.function(workers)) 
[13:23:15.303]                       workers <- workers()
[13:23:15.303]                     workers <- structure(as.integer(workers), 
[13:23:15.303]                       class = class(workers))
[13:23:15.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.303]                       workers >= 1)
[13:23:15.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.303]                     }
[13:23:15.303]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.303]                       envir = envir)
[13:23:15.303]                     if (!future$lazy) 
[13:23:15.303]                       future <- run(future)
[13:23:15.303]                     invisible(future)
[13:23:15.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.303]                 }
[13:23:15.303]             }
[13:23:15.303]         }
[13:23:15.303]     })
[13:23:15.303]     if (TRUE) {
[13:23:15.303]         base::sink(type = "output", split = FALSE)
[13:23:15.303]         if (TRUE) {
[13:23:15.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.303]         }
[13:23:15.303]         else {
[13:23:15.303]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.303]         }
[13:23:15.303]         base::close(...future.stdout)
[13:23:15.303]         ...future.stdout <- NULL
[13:23:15.303]     }
[13:23:15.303]     ...future.result$conditions <- ...future.conditions
[13:23:15.303]     ...future.result$finished <- base::Sys.time()
[13:23:15.303]     ...future.result
[13:23:15.303] }
[13:23:15.306] MultisessionFuture started
[13:23:15.306] - Launch lazy future ... done
[13:23:15.306] run() for ‘MultisessionFuture’ ... done
[13:23:15.306] result() for ClusterFuture ...
[13:23:15.307] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.307] - Validating connection of MultisessionFuture
[13:23:15.355] - received message: FutureResult
[13:23:15.355] - Received FutureResult
[13:23:15.355] - Erased future from FutureRegistry
[13:23:15.355] result() for ClusterFuture ...
[13:23:15.355] - result already collected: FutureResult
[13:23:15.355] result() for ClusterFuture ... done
[13:23:15.356] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.356] result() for ClusterFuture ... done
[13:23:15.356] result() for ClusterFuture ...
[13:23:15.356] - result already collected: FutureResult
[13:23:15.356] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[13:23:15.359] getGlobalsAndPackages() ...
[13:23:15.359] Searching for globals...
[13:23:15.361] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[13:23:15.361] Searching for globals ... DONE
[13:23:15.361] Resolving globals: FALSE
[13:23:15.361] 
[13:23:15.362] - packages: [2] ‘stats’, ‘datasets’
[13:23:15.362] getGlobalsAndPackages() ... DONE
[13:23:15.362] run() for ‘Future’ ...
[13:23:15.362] - state: ‘created’
[13:23:15.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.377]   - Field: ‘node’
[13:23:15.378]   - Field: ‘label’
[13:23:15.378]   - Field: ‘local’
[13:23:15.378]   - Field: ‘owner’
[13:23:15.378]   - Field: ‘envir’
[13:23:15.378]   - Field: ‘workers’
[13:23:15.378]   - Field: ‘packages’
[13:23:15.378]   - Field: ‘gc’
[13:23:15.378]   - Field: ‘conditions’
[13:23:15.378]   - Field: ‘persistent’
[13:23:15.378]   - Field: ‘expr’
[13:23:15.379]   - Field: ‘uuid’
[13:23:15.379]   - Field: ‘seed’
[13:23:15.379]   - Field: ‘version’
[13:23:15.379]   - Field: ‘result’
[13:23:15.379]   - Field: ‘asynchronous’
[13:23:15.379]   - Field: ‘calls’
[13:23:15.379]   - Field: ‘globals’
[13:23:15.379]   - Field: ‘stdout’
[13:23:15.379]   - Field: ‘earlySignal’
[13:23:15.379]   - Field: ‘lazy’
[13:23:15.380]   - Field: ‘state’
[13:23:15.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.380] - Launch lazy future ...
[13:23:15.380] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:15.380] Packages needed by future strategies (n = 0): <none>
[13:23:15.381] {
[13:23:15.381]     {
[13:23:15.381]         {
[13:23:15.381]             ...future.startTime <- base::Sys.time()
[13:23:15.381]             {
[13:23:15.381]                 {
[13:23:15.381]                   {
[13:23:15.381]                     {
[13:23:15.381]                       {
[13:23:15.381]                         base::local({
[13:23:15.381]                           has_future <- base::requireNamespace("future", 
[13:23:15.381]                             quietly = TRUE)
[13:23:15.381]                           if (has_future) {
[13:23:15.381]                             ns <- base::getNamespace("future")
[13:23:15.381]                             version <- ns[[".package"]][["version"]]
[13:23:15.381]                             if (is.null(version)) 
[13:23:15.381]                               version <- utils::packageVersion("future")
[13:23:15.381]                           }
[13:23:15.381]                           else {
[13:23:15.381]                             version <- NULL
[13:23:15.381]                           }
[13:23:15.381]                           if (!has_future || version < "1.8.0") {
[13:23:15.381]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.381]                               "", base::R.version$version.string), 
[13:23:15.381]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.381]                                 base::R.version$platform, 8 * 
[13:23:15.381]                                   base::.Machine$sizeof.pointer), 
[13:23:15.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.381]                                 "release", "version")], collapse = " "), 
[13:23:15.381]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.381]                               info)
[13:23:15.381]                             info <- base::paste(info, collapse = "; ")
[13:23:15.381]                             if (!has_future) {
[13:23:15.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.381]                                 info)
[13:23:15.381]                             }
[13:23:15.381]                             else {
[13:23:15.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.381]                                 info, version)
[13:23:15.381]                             }
[13:23:15.381]                             base::stop(msg)
[13:23:15.381]                           }
[13:23:15.381]                         })
[13:23:15.381]                       }
[13:23:15.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.381]                       base::options(mc.cores = 1L)
[13:23:15.381]                     }
[13:23:15.381]                     base::local({
[13:23:15.381]                       for (pkg in c("stats", "datasets")) {
[13:23:15.381]                         base::loadNamespace(pkg)
[13:23:15.381]                         base::library(pkg, character.only = TRUE)
[13:23:15.381]                       }
[13:23:15.381]                     })
[13:23:15.381]                   }
[13:23:15.381]                   options(future.plan = NULL)
[13:23:15.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.381]                 }
[13:23:15.381]                 ...future.workdir <- getwd()
[13:23:15.381]             }
[13:23:15.381]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.381]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.381]         }
[13:23:15.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.381]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.381]             base::names(...future.oldOptions))
[13:23:15.381]     }
[13:23:15.381]     if (FALSE) {
[13:23:15.381]     }
[13:23:15.381]     else {
[13:23:15.381]         if (TRUE) {
[13:23:15.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.381]                 open = "w")
[13:23:15.381]         }
[13:23:15.381]         else {
[13:23:15.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.381]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.381]         }
[13:23:15.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.381]             base::sink(type = "output", split = FALSE)
[13:23:15.381]             base::close(...future.stdout)
[13:23:15.381]         }, add = TRUE)
[13:23:15.381]     }
[13:23:15.381]     ...future.frame <- base::sys.nframe()
[13:23:15.381]     ...future.conditions <- base::list()
[13:23:15.381]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.381]     if (FALSE) {
[13:23:15.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.381]     }
[13:23:15.381]     ...future.result <- base::tryCatch({
[13:23:15.381]         base::withCallingHandlers({
[13:23:15.381]             ...future.value <- base::withVisible(base::local({
[13:23:15.381]                 ...future.makeSendCondition <- base::local({
[13:23:15.381]                   sendCondition <- NULL
[13:23:15.381]                   function(frame = 1L) {
[13:23:15.381]                     if (is.function(sendCondition)) 
[13:23:15.381]                       return(sendCondition)
[13:23:15.381]                     ns <- getNamespace("parallel")
[13:23:15.381]                     if (exists("sendData", mode = "function", 
[13:23:15.381]                       envir = ns)) {
[13:23:15.381]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.381]                         envir = ns)
[13:23:15.381]                       envir <- sys.frame(frame)
[13:23:15.381]                       master <- NULL
[13:23:15.381]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.381]                         !identical(envir, emptyenv())) {
[13:23:15.381]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.381]                           inherits = FALSE)) {
[13:23:15.381]                           master <- get("master", mode = "list", 
[13:23:15.381]                             envir = envir, inherits = FALSE)
[13:23:15.381]                           if (inherits(master, c("SOCKnode", 
[13:23:15.381]                             "SOCK0node"))) {
[13:23:15.381]                             sendCondition <<- function(cond) {
[13:23:15.381]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.381]                                 success = TRUE)
[13:23:15.381]                               parallel_sendData(master, data)
[13:23:15.381]                             }
[13:23:15.381]                             return(sendCondition)
[13:23:15.381]                           }
[13:23:15.381]                         }
[13:23:15.381]                         frame <- frame + 1L
[13:23:15.381]                         envir <- sys.frame(frame)
[13:23:15.381]                       }
[13:23:15.381]                     }
[13:23:15.381]                     sendCondition <<- function(cond) NULL
[13:23:15.381]                   }
[13:23:15.381]                 })
[13:23:15.381]                 withCallingHandlers({
[13:23:15.381]                   {
[13:23:15.381]                     lm(dist ~ speed + speed^2, data = cars)
[13:23:15.381]                   }
[13:23:15.381]                 }, immediateCondition = function(cond) {
[13:23:15.381]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.381]                   sendCondition(cond)
[13:23:15.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.381]                   {
[13:23:15.381]                     inherits <- base::inherits
[13:23:15.381]                     invokeRestart <- base::invokeRestart
[13:23:15.381]                     is.null <- base::is.null
[13:23:15.381]                     muffled <- FALSE
[13:23:15.381]                     if (inherits(cond, "message")) {
[13:23:15.381]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.381]                       if (muffled) 
[13:23:15.381]                         invokeRestart("muffleMessage")
[13:23:15.381]                     }
[13:23:15.381]                     else if (inherits(cond, "warning")) {
[13:23:15.381]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.381]                       if (muffled) 
[13:23:15.381]                         invokeRestart("muffleWarning")
[13:23:15.381]                     }
[13:23:15.381]                     else if (inherits(cond, "condition")) {
[13:23:15.381]                       if (!is.null(pattern)) {
[13:23:15.381]                         computeRestarts <- base::computeRestarts
[13:23:15.381]                         grepl <- base::grepl
[13:23:15.381]                         restarts <- computeRestarts(cond)
[13:23:15.381]                         for (restart in restarts) {
[13:23:15.381]                           name <- restart$name
[13:23:15.381]                           if (is.null(name)) 
[13:23:15.381]                             next
[13:23:15.381]                           if (!grepl(pattern, name)) 
[13:23:15.381]                             next
[13:23:15.381]                           invokeRestart(restart)
[13:23:15.381]                           muffled <- TRUE
[13:23:15.381]                           break
[13:23:15.381]                         }
[13:23:15.381]                       }
[13:23:15.381]                     }
[13:23:15.381]                     invisible(muffled)
[13:23:15.381]                   }
[13:23:15.381]                   muffleCondition(cond)
[13:23:15.381]                 })
[13:23:15.381]             }))
[13:23:15.381]             future::FutureResult(value = ...future.value$value, 
[13:23:15.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.381]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.381]                     ...future.globalenv.names))
[13:23:15.381]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.381]         }, condition = base::local({
[13:23:15.381]             c <- base::c
[13:23:15.381]             inherits <- base::inherits
[13:23:15.381]             invokeRestart <- base::invokeRestart
[13:23:15.381]             length <- base::length
[13:23:15.381]             list <- base::list
[13:23:15.381]             seq.int <- base::seq.int
[13:23:15.381]             signalCondition <- base::signalCondition
[13:23:15.381]             sys.calls <- base::sys.calls
[13:23:15.381]             `[[` <- base::`[[`
[13:23:15.381]             `+` <- base::`+`
[13:23:15.381]             `<<-` <- base::`<<-`
[13:23:15.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.381]                   3L)]
[13:23:15.381]             }
[13:23:15.381]             function(cond) {
[13:23:15.381]                 is_error <- inherits(cond, "error")
[13:23:15.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.381]                   NULL)
[13:23:15.381]                 if (is_error) {
[13:23:15.381]                   sessionInformation <- function() {
[13:23:15.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.381]                       search = base::search(), system = base::Sys.info())
[13:23:15.381]                   }
[13:23:15.381]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.381]                     cond$call), session = sessionInformation(), 
[13:23:15.381]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.381]                   signalCondition(cond)
[13:23:15.381]                 }
[13:23:15.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.381]                 "immediateCondition"))) {
[13:23:15.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.381]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.381]                   if (TRUE && !signal) {
[13:23:15.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.381]                     {
[13:23:15.381]                       inherits <- base::inherits
[13:23:15.381]                       invokeRestart <- base::invokeRestart
[13:23:15.381]                       is.null <- base::is.null
[13:23:15.381]                       muffled <- FALSE
[13:23:15.381]                       if (inherits(cond, "message")) {
[13:23:15.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.381]                         if (muffled) 
[13:23:15.381]                           invokeRestart("muffleMessage")
[13:23:15.381]                       }
[13:23:15.381]                       else if (inherits(cond, "warning")) {
[13:23:15.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.381]                         if (muffled) 
[13:23:15.381]                           invokeRestart("muffleWarning")
[13:23:15.381]                       }
[13:23:15.381]                       else if (inherits(cond, "condition")) {
[13:23:15.381]                         if (!is.null(pattern)) {
[13:23:15.381]                           computeRestarts <- base::computeRestarts
[13:23:15.381]                           grepl <- base::grepl
[13:23:15.381]                           restarts <- computeRestarts(cond)
[13:23:15.381]                           for (restart in restarts) {
[13:23:15.381]                             name <- restart$name
[13:23:15.381]                             if (is.null(name)) 
[13:23:15.381]                               next
[13:23:15.381]                             if (!grepl(pattern, name)) 
[13:23:15.381]                               next
[13:23:15.381]                             invokeRestart(restart)
[13:23:15.381]                             muffled <- TRUE
[13:23:15.381]                             break
[13:23:15.381]                           }
[13:23:15.381]                         }
[13:23:15.381]                       }
[13:23:15.381]                       invisible(muffled)
[13:23:15.381]                     }
[13:23:15.381]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.381]                   }
[13:23:15.381]                 }
[13:23:15.381]                 else {
[13:23:15.381]                   if (TRUE) {
[13:23:15.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.381]                     {
[13:23:15.381]                       inherits <- base::inherits
[13:23:15.381]                       invokeRestart <- base::invokeRestart
[13:23:15.381]                       is.null <- base::is.null
[13:23:15.381]                       muffled <- FALSE
[13:23:15.381]                       if (inherits(cond, "message")) {
[13:23:15.381]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.381]                         if (muffled) 
[13:23:15.381]                           invokeRestart("muffleMessage")
[13:23:15.381]                       }
[13:23:15.381]                       else if (inherits(cond, "warning")) {
[13:23:15.381]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.381]                         if (muffled) 
[13:23:15.381]                           invokeRestart("muffleWarning")
[13:23:15.381]                       }
[13:23:15.381]                       else if (inherits(cond, "condition")) {
[13:23:15.381]                         if (!is.null(pattern)) {
[13:23:15.381]                           computeRestarts <- base::computeRestarts
[13:23:15.381]                           grepl <- base::grepl
[13:23:15.381]                           restarts <- computeRestarts(cond)
[13:23:15.381]                           for (restart in restarts) {
[13:23:15.381]                             name <- restart$name
[13:23:15.381]                             if (is.null(name)) 
[13:23:15.381]                               next
[13:23:15.381]                             if (!grepl(pattern, name)) 
[13:23:15.381]                               next
[13:23:15.381]                             invokeRestart(restart)
[13:23:15.381]                             muffled <- TRUE
[13:23:15.381]                             break
[13:23:15.381]                           }
[13:23:15.381]                         }
[13:23:15.381]                       }
[13:23:15.381]                       invisible(muffled)
[13:23:15.381]                     }
[13:23:15.381]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.381]                   }
[13:23:15.381]                 }
[13:23:15.381]             }
[13:23:15.381]         }))
[13:23:15.381]     }, error = function(ex) {
[13:23:15.381]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.381]                 ...future.rng), started = ...future.startTime, 
[13:23:15.381]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.381]             version = "1.8"), class = "FutureResult")
[13:23:15.381]     }, finally = {
[13:23:15.381]         if (!identical(...future.workdir, getwd())) 
[13:23:15.381]             setwd(...future.workdir)
[13:23:15.381]         {
[13:23:15.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.381]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.381]             }
[13:23:15.381]             base::options(...future.oldOptions)
[13:23:15.381]             if (.Platform$OS.type == "windows") {
[13:23:15.381]                 old_names <- names(...future.oldEnvVars)
[13:23:15.381]                 envs <- base::Sys.getenv()
[13:23:15.381]                 names <- names(envs)
[13:23:15.381]                 common <- intersect(names, old_names)
[13:23:15.381]                 added <- setdiff(names, old_names)
[13:23:15.381]                 removed <- setdiff(old_names, names)
[13:23:15.381]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.381]                   envs[common]]
[13:23:15.381]                 NAMES <- toupper(changed)
[13:23:15.381]                 args <- list()
[13:23:15.381]                 for (kk in seq_along(NAMES)) {
[13:23:15.381]                   name <- changed[[kk]]
[13:23:15.381]                   NAME <- NAMES[[kk]]
[13:23:15.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.381]                     next
[13:23:15.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.381]                 }
[13:23:15.381]                 NAMES <- toupper(added)
[13:23:15.381]                 for (kk in seq_along(NAMES)) {
[13:23:15.381]                   name <- added[[kk]]
[13:23:15.381]                   NAME <- NAMES[[kk]]
[13:23:15.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.381]                     next
[13:23:15.381]                   args[[name]] <- ""
[13:23:15.381]                 }
[13:23:15.381]                 NAMES <- toupper(removed)
[13:23:15.381]                 for (kk in seq_along(NAMES)) {
[13:23:15.381]                   name <- removed[[kk]]
[13:23:15.381]                   NAME <- NAMES[[kk]]
[13:23:15.381]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.381]                     next
[13:23:15.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.381]                 }
[13:23:15.381]                 if (length(args) > 0) 
[13:23:15.381]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.381]             }
[13:23:15.381]             else {
[13:23:15.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.381]             }
[13:23:15.381]             {
[13:23:15.381]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.381]                   0L) {
[13:23:15.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.381]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.381]                   base::options(opts)
[13:23:15.381]                 }
[13:23:15.381]                 {
[13:23:15.381]                   {
[13:23:15.381]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.381]                     NULL
[13:23:15.381]                   }
[13:23:15.381]                   options(future.plan = NULL)
[13:23:15.381]                   if (is.na(NA_character_)) 
[13:23:15.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.381]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.381]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.381]                     envir = parent.frame()) 
[13:23:15.381]                   {
[13:23:15.381]                     if (is.function(workers)) 
[13:23:15.381]                       workers <- workers()
[13:23:15.381]                     workers <- structure(as.integer(workers), 
[13:23:15.381]                       class = class(workers))
[13:23:15.381]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.381]                       workers >= 1)
[13:23:15.381]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.381]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.381]                     }
[13:23:15.381]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.381]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.381]                       envir = envir)
[13:23:15.381]                     if (!future$lazy) 
[13:23:15.381]                       future <- run(future)
[13:23:15.381]                     invisible(future)
[13:23:15.381]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.381]                 }
[13:23:15.381]             }
[13:23:15.381]         }
[13:23:15.381]     })
[13:23:15.381]     if (TRUE) {
[13:23:15.381]         base::sink(type = "output", split = FALSE)
[13:23:15.381]         if (TRUE) {
[13:23:15.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.381]         }
[13:23:15.381]         else {
[13:23:15.381]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.381]         }
[13:23:15.381]         base::close(...future.stdout)
[13:23:15.381]         ...future.stdout <- NULL
[13:23:15.381]     }
[13:23:15.381]     ...future.result$conditions <- ...future.conditions
[13:23:15.381]     ...future.result$finished <- base::Sys.time()
[13:23:15.381]     ...future.result
[13:23:15.381] }
[13:23:15.384] MultisessionFuture started
[13:23:15.384] - Launch lazy future ... done
[13:23:15.385] run() for ‘MultisessionFuture’ ... done
[13:23:15.385] result() for ClusterFuture ...
[13:23:15.385] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.385] - Validating connection of MultisessionFuture
[13:23:15.434] - received message: FutureResult
[13:23:15.435] - Received FutureResult
[13:23:15.435] - Erased future from FutureRegistry
[13:23:15.435] result() for ClusterFuture ...
[13:23:15.435] - result already collected: FutureResult
[13:23:15.435] result() for ClusterFuture ... done
[13:23:15.435] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.435] result() for ClusterFuture ... done
[13:23:15.435] result() for ClusterFuture ...
[13:23:15.436] - result already collected: FutureResult
[13:23:15.436] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[13:23:15.438] getGlobalsAndPackages() ...
[13:23:15.439] Searching for globals...
[13:23:15.441] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[13:23:15.441] Searching for globals ... DONE
[13:23:15.441] Resolving globals: FALSE
[13:23:15.442] 
[13:23:15.442] - packages: [2] ‘stats’, ‘datasets’
[13:23:15.442] getGlobalsAndPackages() ... DONE
[13:23:15.442] run() for ‘Future’ ...
[13:23:15.442] - state: ‘created’
[13:23:15.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.457]   - Field: ‘node’
[13:23:15.458]   - Field: ‘label’
[13:23:15.458]   - Field: ‘local’
[13:23:15.458]   - Field: ‘owner’
[13:23:15.458]   - Field: ‘envir’
[13:23:15.458]   - Field: ‘workers’
[13:23:15.458]   - Field: ‘packages’
[13:23:15.458]   - Field: ‘gc’
[13:23:15.458]   - Field: ‘conditions’
[13:23:15.458]   - Field: ‘persistent’
[13:23:15.458]   - Field: ‘expr’
[13:23:15.458]   - Field: ‘uuid’
[13:23:15.459]   - Field: ‘seed’
[13:23:15.459]   - Field: ‘version’
[13:23:15.459]   - Field: ‘result’
[13:23:15.459]   - Field: ‘asynchronous’
[13:23:15.459]   - Field: ‘calls’
[13:23:15.459]   - Field: ‘globals’
[13:23:15.459]   - Field: ‘stdout’
[13:23:15.459]   - Field: ‘earlySignal’
[13:23:15.459]   - Field: ‘lazy’
[13:23:15.459]   - Field: ‘state’
[13:23:15.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.460] - Launch lazy future ...
[13:23:15.460] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:15.460] Packages needed by future strategies (n = 0): <none>
[13:23:15.461] {
[13:23:15.461]     {
[13:23:15.461]         {
[13:23:15.461]             ...future.startTime <- base::Sys.time()
[13:23:15.461]             {
[13:23:15.461]                 {
[13:23:15.461]                   {
[13:23:15.461]                     {
[13:23:15.461]                       {
[13:23:15.461]                         base::local({
[13:23:15.461]                           has_future <- base::requireNamespace("future", 
[13:23:15.461]                             quietly = TRUE)
[13:23:15.461]                           if (has_future) {
[13:23:15.461]                             ns <- base::getNamespace("future")
[13:23:15.461]                             version <- ns[[".package"]][["version"]]
[13:23:15.461]                             if (is.null(version)) 
[13:23:15.461]                               version <- utils::packageVersion("future")
[13:23:15.461]                           }
[13:23:15.461]                           else {
[13:23:15.461]                             version <- NULL
[13:23:15.461]                           }
[13:23:15.461]                           if (!has_future || version < "1.8.0") {
[13:23:15.461]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.461]                               "", base::R.version$version.string), 
[13:23:15.461]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.461]                                 base::R.version$platform, 8 * 
[13:23:15.461]                                   base::.Machine$sizeof.pointer), 
[13:23:15.461]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.461]                                 "release", "version")], collapse = " "), 
[13:23:15.461]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.461]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.461]                               info)
[13:23:15.461]                             info <- base::paste(info, collapse = "; ")
[13:23:15.461]                             if (!has_future) {
[13:23:15.461]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.461]                                 info)
[13:23:15.461]                             }
[13:23:15.461]                             else {
[13:23:15.461]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.461]                                 info, version)
[13:23:15.461]                             }
[13:23:15.461]                             base::stop(msg)
[13:23:15.461]                           }
[13:23:15.461]                         })
[13:23:15.461]                       }
[13:23:15.461]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.461]                       base::options(mc.cores = 1L)
[13:23:15.461]                     }
[13:23:15.461]                     base::local({
[13:23:15.461]                       for (pkg in c("stats", "datasets")) {
[13:23:15.461]                         base::loadNamespace(pkg)
[13:23:15.461]                         base::library(pkg, character.only = TRUE)
[13:23:15.461]                       }
[13:23:15.461]                     })
[13:23:15.461]                   }
[13:23:15.461]                   options(future.plan = NULL)
[13:23:15.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.461]                 }
[13:23:15.461]                 ...future.workdir <- getwd()
[13:23:15.461]             }
[13:23:15.461]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.461]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.461]         }
[13:23:15.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.461]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.461]             base::names(...future.oldOptions))
[13:23:15.461]     }
[13:23:15.461]     if (FALSE) {
[13:23:15.461]     }
[13:23:15.461]     else {
[13:23:15.461]         if (TRUE) {
[13:23:15.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.461]                 open = "w")
[13:23:15.461]         }
[13:23:15.461]         else {
[13:23:15.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.461]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.461]         }
[13:23:15.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.461]             base::sink(type = "output", split = FALSE)
[13:23:15.461]             base::close(...future.stdout)
[13:23:15.461]         }, add = TRUE)
[13:23:15.461]     }
[13:23:15.461]     ...future.frame <- base::sys.nframe()
[13:23:15.461]     ...future.conditions <- base::list()
[13:23:15.461]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.461]     if (FALSE) {
[13:23:15.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.461]     }
[13:23:15.461]     ...future.result <- base::tryCatch({
[13:23:15.461]         base::withCallingHandlers({
[13:23:15.461]             ...future.value <- base::withVisible(base::local({
[13:23:15.461]                 ...future.makeSendCondition <- base::local({
[13:23:15.461]                   sendCondition <- NULL
[13:23:15.461]                   function(frame = 1L) {
[13:23:15.461]                     if (is.function(sendCondition)) 
[13:23:15.461]                       return(sendCondition)
[13:23:15.461]                     ns <- getNamespace("parallel")
[13:23:15.461]                     if (exists("sendData", mode = "function", 
[13:23:15.461]                       envir = ns)) {
[13:23:15.461]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.461]                         envir = ns)
[13:23:15.461]                       envir <- sys.frame(frame)
[13:23:15.461]                       master <- NULL
[13:23:15.461]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.461]                         !identical(envir, emptyenv())) {
[13:23:15.461]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.461]                           inherits = FALSE)) {
[13:23:15.461]                           master <- get("master", mode = "list", 
[13:23:15.461]                             envir = envir, inherits = FALSE)
[13:23:15.461]                           if (inherits(master, c("SOCKnode", 
[13:23:15.461]                             "SOCK0node"))) {
[13:23:15.461]                             sendCondition <<- function(cond) {
[13:23:15.461]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.461]                                 success = TRUE)
[13:23:15.461]                               parallel_sendData(master, data)
[13:23:15.461]                             }
[13:23:15.461]                             return(sendCondition)
[13:23:15.461]                           }
[13:23:15.461]                         }
[13:23:15.461]                         frame <- frame + 1L
[13:23:15.461]                         envir <- sys.frame(frame)
[13:23:15.461]                       }
[13:23:15.461]                     }
[13:23:15.461]                     sendCondition <<- function(cond) NULL
[13:23:15.461]                   }
[13:23:15.461]                 })
[13:23:15.461]                 withCallingHandlers({
[13:23:15.461]                   {
[13:23:15.461]                     lm(dist ~ speed + I(speed^2), data = cars)
[13:23:15.461]                   }
[13:23:15.461]                 }, immediateCondition = function(cond) {
[13:23:15.461]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.461]                   sendCondition(cond)
[13:23:15.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.461]                   {
[13:23:15.461]                     inherits <- base::inherits
[13:23:15.461]                     invokeRestart <- base::invokeRestart
[13:23:15.461]                     is.null <- base::is.null
[13:23:15.461]                     muffled <- FALSE
[13:23:15.461]                     if (inherits(cond, "message")) {
[13:23:15.461]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.461]                       if (muffled) 
[13:23:15.461]                         invokeRestart("muffleMessage")
[13:23:15.461]                     }
[13:23:15.461]                     else if (inherits(cond, "warning")) {
[13:23:15.461]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.461]                       if (muffled) 
[13:23:15.461]                         invokeRestart("muffleWarning")
[13:23:15.461]                     }
[13:23:15.461]                     else if (inherits(cond, "condition")) {
[13:23:15.461]                       if (!is.null(pattern)) {
[13:23:15.461]                         computeRestarts <- base::computeRestarts
[13:23:15.461]                         grepl <- base::grepl
[13:23:15.461]                         restarts <- computeRestarts(cond)
[13:23:15.461]                         for (restart in restarts) {
[13:23:15.461]                           name <- restart$name
[13:23:15.461]                           if (is.null(name)) 
[13:23:15.461]                             next
[13:23:15.461]                           if (!grepl(pattern, name)) 
[13:23:15.461]                             next
[13:23:15.461]                           invokeRestart(restart)
[13:23:15.461]                           muffled <- TRUE
[13:23:15.461]                           break
[13:23:15.461]                         }
[13:23:15.461]                       }
[13:23:15.461]                     }
[13:23:15.461]                     invisible(muffled)
[13:23:15.461]                   }
[13:23:15.461]                   muffleCondition(cond)
[13:23:15.461]                 })
[13:23:15.461]             }))
[13:23:15.461]             future::FutureResult(value = ...future.value$value, 
[13:23:15.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.461]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.461]                     ...future.globalenv.names))
[13:23:15.461]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.461]         }, condition = base::local({
[13:23:15.461]             c <- base::c
[13:23:15.461]             inherits <- base::inherits
[13:23:15.461]             invokeRestart <- base::invokeRestart
[13:23:15.461]             length <- base::length
[13:23:15.461]             list <- base::list
[13:23:15.461]             seq.int <- base::seq.int
[13:23:15.461]             signalCondition <- base::signalCondition
[13:23:15.461]             sys.calls <- base::sys.calls
[13:23:15.461]             `[[` <- base::`[[`
[13:23:15.461]             `+` <- base::`+`
[13:23:15.461]             `<<-` <- base::`<<-`
[13:23:15.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.461]                   3L)]
[13:23:15.461]             }
[13:23:15.461]             function(cond) {
[13:23:15.461]                 is_error <- inherits(cond, "error")
[13:23:15.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.461]                   NULL)
[13:23:15.461]                 if (is_error) {
[13:23:15.461]                   sessionInformation <- function() {
[13:23:15.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.461]                       search = base::search(), system = base::Sys.info())
[13:23:15.461]                   }
[13:23:15.461]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.461]                     cond$call), session = sessionInformation(), 
[13:23:15.461]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.461]                   signalCondition(cond)
[13:23:15.461]                 }
[13:23:15.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.461]                 "immediateCondition"))) {
[13:23:15.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.461]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.461]                   if (TRUE && !signal) {
[13:23:15.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.461]                     {
[13:23:15.461]                       inherits <- base::inherits
[13:23:15.461]                       invokeRestart <- base::invokeRestart
[13:23:15.461]                       is.null <- base::is.null
[13:23:15.461]                       muffled <- FALSE
[13:23:15.461]                       if (inherits(cond, "message")) {
[13:23:15.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.461]                         if (muffled) 
[13:23:15.461]                           invokeRestart("muffleMessage")
[13:23:15.461]                       }
[13:23:15.461]                       else if (inherits(cond, "warning")) {
[13:23:15.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.461]                         if (muffled) 
[13:23:15.461]                           invokeRestart("muffleWarning")
[13:23:15.461]                       }
[13:23:15.461]                       else if (inherits(cond, "condition")) {
[13:23:15.461]                         if (!is.null(pattern)) {
[13:23:15.461]                           computeRestarts <- base::computeRestarts
[13:23:15.461]                           grepl <- base::grepl
[13:23:15.461]                           restarts <- computeRestarts(cond)
[13:23:15.461]                           for (restart in restarts) {
[13:23:15.461]                             name <- restart$name
[13:23:15.461]                             if (is.null(name)) 
[13:23:15.461]                               next
[13:23:15.461]                             if (!grepl(pattern, name)) 
[13:23:15.461]                               next
[13:23:15.461]                             invokeRestart(restart)
[13:23:15.461]                             muffled <- TRUE
[13:23:15.461]                             break
[13:23:15.461]                           }
[13:23:15.461]                         }
[13:23:15.461]                       }
[13:23:15.461]                       invisible(muffled)
[13:23:15.461]                     }
[13:23:15.461]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.461]                   }
[13:23:15.461]                 }
[13:23:15.461]                 else {
[13:23:15.461]                   if (TRUE) {
[13:23:15.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.461]                     {
[13:23:15.461]                       inherits <- base::inherits
[13:23:15.461]                       invokeRestart <- base::invokeRestart
[13:23:15.461]                       is.null <- base::is.null
[13:23:15.461]                       muffled <- FALSE
[13:23:15.461]                       if (inherits(cond, "message")) {
[13:23:15.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.461]                         if (muffled) 
[13:23:15.461]                           invokeRestart("muffleMessage")
[13:23:15.461]                       }
[13:23:15.461]                       else if (inherits(cond, "warning")) {
[13:23:15.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.461]                         if (muffled) 
[13:23:15.461]                           invokeRestart("muffleWarning")
[13:23:15.461]                       }
[13:23:15.461]                       else if (inherits(cond, "condition")) {
[13:23:15.461]                         if (!is.null(pattern)) {
[13:23:15.461]                           computeRestarts <- base::computeRestarts
[13:23:15.461]                           grepl <- base::grepl
[13:23:15.461]                           restarts <- computeRestarts(cond)
[13:23:15.461]                           for (restart in restarts) {
[13:23:15.461]                             name <- restart$name
[13:23:15.461]                             if (is.null(name)) 
[13:23:15.461]                               next
[13:23:15.461]                             if (!grepl(pattern, name)) 
[13:23:15.461]                               next
[13:23:15.461]                             invokeRestart(restart)
[13:23:15.461]                             muffled <- TRUE
[13:23:15.461]                             break
[13:23:15.461]                           }
[13:23:15.461]                         }
[13:23:15.461]                       }
[13:23:15.461]                       invisible(muffled)
[13:23:15.461]                     }
[13:23:15.461]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.461]                   }
[13:23:15.461]                 }
[13:23:15.461]             }
[13:23:15.461]         }))
[13:23:15.461]     }, error = function(ex) {
[13:23:15.461]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.461]                 ...future.rng), started = ...future.startTime, 
[13:23:15.461]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.461]             version = "1.8"), class = "FutureResult")
[13:23:15.461]     }, finally = {
[13:23:15.461]         if (!identical(...future.workdir, getwd())) 
[13:23:15.461]             setwd(...future.workdir)
[13:23:15.461]         {
[13:23:15.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.461]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.461]             }
[13:23:15.461]             base::options(...future.oldOptions)
[13:23:15.461]             if (.Platform$OS.type == "windows") {
[13:23:15.461]                 old_names <- names(...future.oldEnvVars)
[13:23:15.461]                 envs <- base::Sys.getenv()
[13:23:15.461]                 names <- names(envs)
[13:23:15.461]                 common <- intersect(names, old_names)
[13:23:15.461]                 added <- setdiff(names, old_names)
[13:23:15.461]                 removed <- setdiff(old_names, names)
[13:23:15.461]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.461]                   envs[common]]
[13:23:15.461]                 NAMES <- toupper(changed)
[13:23:15.461]                 args <- list()
[13:23:15.461]                 for (kk in seq_along(NAMES)) {
[13:23:15.461]                   name <- changed[[kk]]
[13:23:15.461]                   NAME <- NAMES[[kk]]
[13:23:15.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.461]                     next
[13:23:15.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.461]                 }
[13:23:15.461]                 NAMES <- toupper(added)
[13:23:15.461]                 for (kk in seq_along(NAMES)) {
[13:23:15.461]                   name <- added[[kk]]
[13:23:15.461]                   NAME <- NAMES[[kk]]
[13:23:15.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.461]                     next
[13:23:15.461]                   args[[name]] <- ""
[13:23:15.461]                 }
[13:23:15.461]                 NAMES <- toupper(removed)
[13:23:15.461]                 for (kk in seq_along(NAMES)) {
[13:23:15.461]                   name <- removed[[kk]]
[13:23:15.461]                   NAME <- NAMES[[kk]]
[13:23:15.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.461]                     next
[13:23:15.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.461]                 }
[13:23:15.461]                 if (length(args) > 0) 
[13:23:15.461]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.461]             }
[13:23:15.461]             else {
[13:23:15.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.461]             }
[13:23:15.461]             {
[13:23:15.461]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.461]                   0L) {
[13:23:15.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.461]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.461]                   base::options(opts)
[13:23:15.461]                 }
[13:23:15.461]                 {
[13:23:15.461]                   {
[13:23:15.461]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.461]                     NULL
[13:23:15.461]                   }
[13:23:15.461]                   options(future.plan = NULL)
[13:23:15.461]                   if (is.na(NA_character_)) 
[13:23:15.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.461]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.461]                     envir = parent.frame()) 
[13:23:15.461]                   {
[13:23:15.461]                     if (is.function(workers)) 
[13:23:15.461]                       workers <- workers()
[13:23:15.461]                     workers <- structure(as.integer(workers), 
[13:23:15.461]                       class = class(workers))
[13:23:15.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.461]                       workers >= 1)
[13:23:15.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.461]                     }
[13:23:15.461]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.461]                       envir = envir)
[13:23:15.461]                     if (!future$lazy) 
[13:23:15.461]                       future <- run(future)
[13:23:15.461]                     invisible(future)
[13:23:15.461]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.461]                 }
[13:23:15.461]             }
[13:23:15.461]         }
[13:23:15.461]     })
[13:23:15.461]     if (TRUE) {
[13:23:15.461]         base::sink(type = "output", split = FALSE)
[13:23:15.461]         if (TRUE) {
[13:23:15.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.461]         }
[13:23:15.461]         else {
[13:23:15.461]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.461]         }
[13:23:15.461]         base::close(...future.stdout)
[13:23:15.461]         ...future.stdout <- NULL
[13:23:15.461]     }
[13:23:15.461]     ...future.result$conditions <- ...future.conditions
[13:23:15.461]     ...future.result$finished <- base::Sys.time()
[13:23:15.461]     ...future.result
[13:23:15.461] }
[13:23:15.464] MultisessionFuture started
[13:23:15.464] - Launch lazy future ... done
[13:23:15.465] run() for ‘MultisessionFuture’ ... done
[13:23:15.465] result() for ClusterFuture ...
[13:23:15.465] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.465] - Validating connection of MultisessionFuture
[13:23:15.517] - received message: FutureResult
[13:23:15.517] - Received FutureResult
[13:23:15.517] - Erased future from FutureRegistry
[13:23:15.517] result() for ClusterFuture ...
[13:23:15.517] - result already collected: FutureResult
[13:23:15.518] result() for ClusterFuture ... done
[13:23:15.518] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.518] result() for ClusterFuture ... done
[13:23:15.518] result() for ClusterFuture ...
[13:23:15.518] - result already collected: FutureResult
[13:23:15.518] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[13:23:15.521] getGlobalsAndPackages() ...
[13:23:15.521] Searching for globals...
[13:23:15.523] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[13:23:15.523] Searching for globals ... DONE
[13:23:15.523] Resolving globals: FALSE
[13:23:15.523] 
[13:23:15.524] - packages: [2] ‘stats’, ‘datasets’
[13:23:15.524] getGlobalsAndPackages() ... DONE
[13:23:15.524] run() for ‘Future’ ...
[13:23:15.524] - state: ‘created’
[13:23:15.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.538] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.539]   - Field: ‘node’
[13:23:15.539]   - Field: ‘label’
[13:23:15.539]   - Field: ‘local’
[13:23:15.539]   - Field: ‘owner’
[13:23:15.539]   - Field: ‘envir’
[13:23:15.539]   - Field: ‘workers’
[13:23:15.539]   - Field: ‘packages’
[13:23:15.540]   - Field: ‘gc’
[13:23:15.540]   - Field: ‘conditions’
[13:23:15.540]   - Field: ‘persistent’
[13:23:15.540]   - Field: ‘expr’
[13:23:15.540]   - Field: ‘uuid’
[13:23:15.540]   - Field: ‘seed’
[13:23:15.540]   - Field: ‘version’
[13:23:15.540]   - Field: ‘result’
[13:23:15.540]   - Field: ‘asynchronous’
[13:23:15.540]   - Field: ‘calls’
[13:23:15.541]   - Field: ‘globals’
[13:23:15.541]   - Field: ‘stdout’
[13:23:15.541]   - Field: ‘earlySignal’
[13:23:15.541]   - Field: ‘lazy’
[13:23:15.541]   - Field: ‘state’
[13:23:15.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.541] - Launch lazy future ...
[13:23:15.541] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[13:23:15.542] Packages needed by future strategies (n = 0): <none>
[13:23:15.542] {
[13:23:15.542]     {
[13:23:15.542]         {
[13:23:15.542]             ...future.startTime <- base::Sys.time()
[13:23:15.542]             {
[13:23:15.542]                 {
[13:23:15.542]                   {
[13:23:15.542]                     {
[13:23:15.542]                       {
[13:23:15.542]                         base::local({
[13:23:15.542]                           has_future <- base::requireNamespace("future", 
[13:23:15.542]                             quietly = TRUE)
[13:23:15.542]                           if (has_future) {
[13:23:15.542]                             ns <- base::getNamespace("future")
[13:23:15.542]                             version <- ns[[".package"]][["version"]]
[13:23:15.542]                             if (is.null(version)) 
[13:23:15.542]                               version <- utils::packageVersion("future")
[13:23:15.542]                           }
[13:23:15.542]                           else {
[13:23:15.542]                             version <- NULL
[13:23:15.542]                           }
[13:23:15.542]                           if (!has_future || version < "1.8.0") {
[13:23:15.542]                             info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.542]                               "", base::R.version$version.string), 
[13:23:15.542]                               platform = base::sprintf("%s (%s-bit)", 
[13:23:15.542]                                 base::R.version$platform, 8 * 
[13:23:15.542]                                   base::.Machine$sizeof.pointer), 
[13:23:15.542]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.542]                                 "release", "version")], collapse = " "), 
[13:23:15.542]                               hostname = base::Sys.info()[["nodename"]])
[13:23:15.542]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.542]                               info)
[13:23:15.542]                             info <- base::paste(info, collapse = "; ")
[13:23:15.542]                             if (!has_future) {
[13:23:15.542]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.542]                                 info)
[13:23:15.542]                             }
[13:23:15.542]                             else {
[13:23:15.542]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.542]                                 info, version)
[13:23:15.542]                             }
[13:23:15.542]                             base::stop(msg)
[13:23:15.542]                           }
[13:23:15.542]                         })
[13:23:15.542]                       }
[13:23:15.542]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.542]                       base::options(mc.cores = 1L)
[13:23:15.542]                     }
[13:23:15.542]                     base::local({
[13:23:15.542]                       for (pkg in c("stats", "datasets")) {
[13:23:15.542]                         base::loadNamespace(pkg)
[13:23:15.542]                         base::library(pkg, character.only = TRUE)
[13:23:15.542]                       }
[13:23:15.542]                     })
[13:23:15.542]                   }
[13:23:15.542]                   options(future.plan = NULL)
[13:23:15.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.542]                 }
[13:23:15.542]                 ...future.workdir <- getwd()
[13:23:15.542]             }
[13:23:15.542]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.542]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.542]         }
[13:23:15.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.542]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.542]             base::names(...future.oldOptions))
[13:23:15.542]     }
[13:23:15.542]     if (FALSE) {
[13:23:15.542]     }
[13:23:15.542]     else {
[13:23:15.542]         if (TRUE) {
[13:23:15.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.542]                 open = "w")
[13:23:15.542]         }
[13:23:15.542]         else {
[13:23:15.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.542]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.542]         }
[13:23:15.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.542]             base::sink(type = "output", split = FALSE)
[13:23:15.542]             base::close(...future.stdout)
[13:23:15.542]         }, add = TRUE)
[13:23:15.542]     }
[13:23:15.542]     ...future.frame <- base::sys.nframe()
[13:23:15.542]     ...future.conditions <- base::list()
[13:23:15.542]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.542]     if (FALSE) {
[13:23:15.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.542]     }
[13:23:15.542]     ...future.result <- base::tryCatch({
[13:23:15.542]         base::withCallingHandlers({
[13:23:15.542]             ...future.value <- base::withVisible(base::local({
[13:23:15.542]                 ...future.makeSendCondition <- base::local({
[13:23:15.542]                   sendCondition <- NULL
[13:23:15.542]                   function(frame = 1L) {
[13:23:15.542]                     if (is.function(sendCondition)) 
[13:23:15.542]                       return(sendCondition)
[13:23:15.542]                     ns <- getNamespace("parallel")
[13:23:15.542]                     if (exists("sendData", mode = "function", 
[13:23:15.542]                       envir = ns)) {
[13:23:15.542]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.542]                         envir = ns)
[13:23:15.542]                       envir <- sys.frame(frame)
[13:23:15.542]                       master <- NULL
[13:23:15.542]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.542]                         !identical(envir, emptyenv())) {
[13:23:15.542]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.542]                           inherits = FALSE)) {
[13:23:15.542]                           master <- get("master", mode = "list", 
[13:23:15.542]                             envir = envir, inherits = FALSE)
[13:23:15.542]                           if (inherits(master, c("SOCKnode", 
[13:23:15.542]                             "SOCK0node"))) {
[13:23:15.542]                             sendCondition <<- function(cond) {
[13:23:15.542]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.542]                                 success = TRUE)
[13:23:15.542]                               parallel_sendData(master, data)
[13:23:15.542]                             }
[13:23:15.542]                             return(sendCondition)
[13:23:15.542]                           }
[13:23:15.542]                         }
[13:23:15.542]                         frame <- frame + 1L
[13:23:15.542]                         envir <- sys.frame(frame)
[13:23:15.542]                       }
[13:23:15.542]                     }
[13:23:15.542]                     sendCondition <<- function(cond) NULL
[13:23:15.542]                   }
[13:23:15.542]                 })
[13:23:15.542]                 withCallingHandlers({
[13:23:15.542]                   {
[13:23:15.542]                     lm(dist ~ poly(speed, 2), data = cars)
[13:23:15.542]                   }
[13:23:15.542]                 }, immediateCondition = function(cond) {
[13:23:15.542]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.542]                   sendCondition(cond)
[13:23:15.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.542]                   {
[13:23:15.542]                     inherits <- base::inherits
[13:23:15.542]                     invokeRestart <- base::invokeRestart
[13:23:15.542]                     is.null <- base::is.null
[13:23:15.542]                     muffled <- FALSE
[13:23:15.542]                     if (inherits(cond, "message")) {
[13:23:15.542]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.542]                       if (muffled) 
[13:23:15.542]                         invokeRestart("muffleMessage")
[13:23:15.542]                     }
[13:23:15.542]                     else if (inherits(cond, "warning")) {
[13:23:15.542]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.542]                       if (muffled) 
[13:23:15.542]                         invokeRestart("muffleWarning")
[13:23:15.542]                     }
[13:23:15.542]                     else if (inherits(cond, "condition")) {
[13:23:15.542]                       if (!is.null(pattern)) {
[13:23:15.542]                         computeRestarts <- base::computeRestarts
[13:23:15.542]                         grepl <- base::grepl
[13:23:15.542]                         restarts <- computeRestarts(cond)
[13:23:15.542]                         for (restart in restarts) {
[13:23:15.542]                           name <- restart$name
[13:23:15.542]                           if (is.null(name)) 
[13:23:15.542]                             next
[13:23:15.542]                           if (!grepl(pattern, name)) 
[13:23:15.542]                             next
[13:23:15.542]                           invokeRestart(restart)
[13:23:15.542]                           muffled <- TRUE
[13:23:15.542]                           break
[13:23:15.542]                         }
[13:23:15.542]                       }
[13:23:15.542]                     }
[13:23:15.542]                     invisible(muffled)
[13:23:15.542]                   }
[13:23:15.542]                   muffleCondition(cond)
[13:23:15.542]                 })
[13:23:15.542]             }))
[13:23:15.542]             future::FutureResult(value = ...future.value$value, 
[13:23:15.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.542]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.542]                     ...future.globalenv.names))
[13:23:15.542]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.542]         }, condition = base::local({
[13:23:15.542]             c <- base::c
[13:23:15.542]             inherits <- base::inherits
[13:23:15.542]             invokeRestart <- base::invokeRestart
[13:23:15.542]             length <- base::length
[13:23:15.542]             list <- base::list
[13:23:15.542]             seq.int <- base::seq.int
[13:23:15.542]             signalCondition <- base::signalCondition
[13:23:15.542]             sys.calls <- base::sys.calls
[13:23:15.542]             `[[` <- base::`[[`
[13:23:15.542]             `+` <- base::`+`
[13:23:15.542]             `<<-` <- base::`<<-`
[13:23:15.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.542]                   3L)]
[13:23:15.542]             }
[13:23:15.542]             function(cond) {
[13:23:15.542]                 is_error <- inherits(cond, "error")
[13:23:15.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.542]                   NULL)
[13:23:15.542]                 if (is_error) {
[13:23:15.542]                   sessionInformation <- function() {
[13:23:15.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.542]                       search = base::search(), system = base::Sys.info())
[13:23:15.542]                   }
[13:23:15.542]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.542]                     cond$call), session = sessionInformation(), 
[13:23:15.542]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.542]                   signalCondition(cond)
[13:23:15.542]                 }
[13:23:15.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.542]                 "immediateCondition"))) {
[13:23:15.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.542]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.542]                   if (TRUE && !signal) {
[13:23:15.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.542]                     {
[13:23:15.542]                       inherits <- base::inherits
[13:23:15.542]                       invokeRestart <- base::invokeRestart
[13:23:15.542]                       is.null <- base::is.null
[13:23:15.542]                       muffled <- FALSE
[13:23:15.542]                       if (inherits(cond, "message")) {
[13:23:15.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.542]                         if (muffled) 
[13:23:15.542]                           invokeRestart("muffleMessage")
[13:23:15.542]                       }
[13:23:15.542]                       else if (inherits(cond, "warning")) {
[13:23:15.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.542]                         if (muffled) 
[13:23:15.542]                           invokeRestart("muffleWarning")
[13:23:15.542]                       }
[13:23:15.542]                       else if (inherits(cond, "condition")) {
[13:23:15.542]                         if (!is.null(pattern)) {
[13:23:15.542]                           computeRestarts <- base::computeRestarts
[13:23:15.542]                           grepl <- base::grepl
[13:23:15.542]                           restarts <- computeRestarts(cond)
[13:23:15.542]                           for (restart in restarts) {
[13:23:15.542]                             name <- restart$name
[13:23:15.542]                             if (is.null(name)) 
[13:23:15.542]                               next
[13:23:15.542]                             if (!grepl(pattern, name)) 
[13:23:15.542]                               next
[13:23:15.542]                             invokeRestart(restart)
[13:23:15.542]                             muffled <- TRUE
[13:23:15.542]                             break
[13:23:15.542]                           }
[13:23:15.542]                         }
[13:23:15.542]                       }
[13:23:15.542]                       invisible(muffled)
[13:23:15.542]                     }
[13:23:15.542]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.542]                   }
[13:23:15.542]                 }
[13:23:15.542]                 else {
[13:23:15.542]                   if (TRUE) {
[13:23:15.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.542]                     {
[13:23:15.542]                       inherits <- base::inherits
[13:23:15.542]                       invokeRestart <- base::invokeRestart
[13:23:15.542]                       is.null <- base::is.null
[13:23:15.542]                       muffled <- FALSE
[13:23:15.542]                       if (inherits(cond, "message")) {
[13:23:15.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.542]                         if (muffled) 
[13:23:15.542]                           invokeRestart("muffleMessage")
[13:23:15.542]                       }
[13:23:15.542]                       else if (inherits(cond, "warning")) {
[13:23:15.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.542]                         if (muffled) 
[13:23:15.542]                           invokeRestart("muffleWarning")
[13:23:15.542]                       }
[13:23:15.542]                       else if (inherits(cond, "condition")) {
[13:23:15.542]                         if (!is.null(pattern)) {
[13:23:15.542]                           computeRestarts <- base::computeRestarts
[13:23:15.542]                           grepl <- base::grepl
[13:23:15.542]                           restarts <- computeRestarts(cond)
[13:23:15.542]                           for (restart in restarts) {
[13:23:15.542]                             name <- restart$name
[13:23:15.542]                             if (is.null(name)) 
[13:23:15.542]                               next
[13:23:15.542]                             if (!grepl(pattern, name)) 
[13:23:15.542]                               next
[13:23:15.542]                             invokeRestart(restart)
[13:23:15.542]                             muffled <- TRUE
[13:23:15.542]                             break
[13:23:15.542]                           }
[13:23:15.542]                         }
[13:23:15.542]                       }
[13:23:15.542]                       invisible(muffled)
[13:23:15.542]                     }
[13:23:15.542]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.542]                   }
[13:23:15.542]                 }
[13:23:15.542]             }
[13:23:15.542]         }))
[13:23:15.542]     }, error = function(ex) {
[13:23:15.542]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.542]                 ...future.rng), started = ...future.startTime, 
[13:23:15.542]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.542]             version = "1.8"), class = "FutureResult")
[13:23:15.542]     }, finally = {
[13:23:15.542]         if (!identical(...future.workdir, getwd())) 
[13:23:15.542]             setwd(...future.workdir)
[13:23:15.542]         {
[13:23:15.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.542]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.542]             }
[13:23:15.542]             base::options(...future.oldOptions)
[13:23:15.542]             if (.Platform$OS.type == "windows") {
[13:23:15.542]                 old_names <- names(...future.oldEnvVars)
[13:23:15.542]                 envs <- base::Sys.getenv()
[13:23:15.542]                 names <- names(envs)
[13:23:15.542]                 common <- intersect(names, old_names)
[13:23:15.542]                 added <- setdiff(names, old_names)
[13:23:15.542]                 removed <- setdiff(old_names, names)
[13:23:15.542]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.542]                   envs[common]]
[13:23:15.542]                 NAMES <- toupper(changed)
[13:23:15.542]                 args <- list()
[13:23:15.542]                 for (kk in seq_along(NAMES)) {
[13:23:15.542]                   name <- changed[[kk]]
[13:23:15.542]                   NAME <- NAMES[[kk]]
[13:23:15.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.542]                     next
[13:23:15.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.542]                 }
[13:23:15.542]                 NAMES <- toupper(added)
[13:23:15.542]                 for (kk in seq_along(NAMES)) {
[13:23:15.542]                   name <- added[[kk]]
[13:23:15.542]                   NAME <- NAMES[[kk]]
[13:23:15.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.542]                     next
[13:23:15.542]                   args[[name]] <- ""
[13:23:15.542]                 }
[13:23:15.542]                 NAMES <- toupper(removed)
[13:23:15.542]                 for (kk in seq_along(NAMES)) {
[13:23:15.542]                   name <- removed[[kk]]
[13:23:15.542]                   NAME <- NAMES[[kk]]
[13:23:15.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.542]                     next
[13:23:15.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.542]                 }
[13:23:15.542]                 if (length(args) > 0) 
[13:23:15.542]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.542]             }
[13:23:15.542]             else {
[13:23:15.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.542]             }
[13:23:15.542]             {
[13:23:15.542]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.542]                   0L) {
[13:23:15.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.542]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.542]                   base::options(opts)
[13:23:15.542]                 }
[13:23:15.542]                 {
[13:23:15.542]                   {
[13:23:15.542]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.542]                     NULL
[13:23:15.542]                   }
[13:23:15.542]                   options(future.plan = NULL)
[13:23:15.542]                   if (is.na(NA_character_)) 
[13:23:15.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.542]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.542]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.542]                     envir = parent.frame()) 
[13:23:15.542]                   {
[13:23:15.542]                     if (is.function(workers)) 
[13:23:15.542]                       workers <- workers()
[13:23:15.542]                     workers <- structure(as.integer(workers), 
[13:23:15.542]                       class = class(workers))
[13:23:15.542]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.542]                       workers >= 1)
[13:23:15.542]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.542]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.542]                     }
[13:23:15.542]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.542]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.542]                       envir = envir)
[13:23:15.542]                     if (!future$lazy) 
[13:23:15.542]                       future <- run(future)
[13:23:15.542]                     invisible(future)
[13:23:15.542]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.542]                 }
[13:23:15.542]             }
[13:23:15.542]         }
[13:23:15.542]     })
[13:23:15.542]     if (TRUE) {
[13:23:15.542]         base::sink(type = "output", split = FALSE)
[13:23:15.542]         if (TRUE) {
[13:23:15.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.542]         }
[13:23:15.542]         else {
[13:23:15.542]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.542]         }
[13:23:15.542]         base::close(...future.stdout)
[13:23:15.542]         ...future.stdout <- NULL
[13:23:15.542]     }
[13:23:15.542]     ...future.result$conditions <- ...future.conditions
[13:23:15.542]     ...future.result$finished <- base::Sys.time()
[13:23:15.542]     ...future.result
[13:23:15.542] }
[13:23:15.545] MultisessionFuture started
[13:23:15.546] - Launch lazy future ... done
[13:23:15.546] run() for ‘MultisessionFuture’ ... done
[13:23:15.546] result() for ClusterFuture ...
[13:23:15.546] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.546] - Validating connection of MultisessionFuture
[13:23:15.596] - received message: FutureResult
[13:23:15.596] - Received FutureResult
[13:23:15.596] - Erased future from FutureRegistry
[13:23:15.597] result() for ClusterFuture ...
[13:23:15.597] - result already collected: FutureResult
[13:23:15.597] result() for ClusterFuture ... done
[13:23:15.597] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.597] result() for ClusterFuture ... done
[13:23:15.597] result() for ClusterFuture ...
[13:23:15.597] - result already collected: FutureResult
[13:23:15.597] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[13:23:15.599] getGlobalsAndPackages() ...
[13:23:15.599] Searching for globals...
[13:23:15.604] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:15.604] Searching for globals ... DONE
[13:23:15.604] Resolving globals: FALSE
[13:23:15.605] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:15.605] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:15.605] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:15.605] 
[13:23:15.606] getGlobalsAndPackages() ... DONE
[13:23:15.606] run() for ‘Future’ ...
[13:23:15.606] - state: ‘created’
[13:23:15.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.621] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.621]   - Field: ‘node’
[13:23:15.621]   - Field: ‘label’
[13:23:15.621]   - Field: ‘local’
[13:23:15.621]   - Field: ‘owner’
[13:23:15.621]   - Field: ‘envir’
[13:23:15.621]   - Field: ‘workers’
[13:23:15.622]   - Field: ‘packages’
[13:23:15.622]   - Field: ‘gc’
[13:23:15.622]   - Field: ‘conditions’
[13:23:15.624]   - Field: ‘persistent’
[13:23:15.624]   - Field: ‘expr’
[13:23:15.624]   - Field: ‘uuid’
[13:23:15.625]   - Field: ‘seed’
[13:23:15.625]   - Field: ‘version’
[13:23:15.625]   - Field: ‘result’
[13:23:15.625]   - Field: ‘asynchronous’
[13:23:15.625]   - Field: ‘calls’
[13:23:15.625]   - Field: ‘globals’
[13:23:15.625]   - Field: ‘stdout’
[13:23:15.625]   - Field: ‘earlySignal’
[13:23:15.625]   - Field: ‘lazy’
[13:23:15.625]   - Field: ‘state’
[13:23:15.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.626] - Launch lazy future ...
[13:23:15.626] Packages needed by the future expression (n = 0): <none>
[13:23:15.626] Packages needed by future strategies (n = 0): <none>
[13:23:15.626] {
[13:23:15.626]     {
[13:23:15.626]         {
[13:23:15.626]             ...future.startTime <- base::Sys.time()
[13:23:15.626]             {
[13:23:15.626]                 {
[13:23:15.626]                   {
[13:23:15.626]                     {
[13:23:15.626]                       base::local({
[13:23:15.626]                         has_future <- base::requireNamespace("future", 
[13:23:15.626]                           quietly = TRUE)
[13:23:15.626]                         if (has_future) {
[13:23:15.626]                           ns <- base::getNamespace("future")
[13:23:15.626]                           version <- ns[[".package"]][["version"]]
[13:23:15.626]                           if (is.null(version)) 
[13:23:15.626]                             version <- utils::packageVersion("future")
[13:23:15.626]                         }
[13:23:15.626]                         else {
[13:23:15.626]                           version <- NULL
[13:23:15.626]                         }
[13:23:15.626]                         if (!has_future || version < "1.8.0") {
[13:23:15.626]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.626]                             "", base::R.version$version.string), 
[13:23:15.626]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:15.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:15.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.626]                               "release", "version")], collapse = " "), 
[13:23:15.626]                             hostname = base::Sys.info()[["nodename"]])
[13:23:15.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.626]                             info)
[13:23:15.626]                           info <- base::paste(info, collapse = "; ")
[13:23:15.626]                           if (!has_future) {
[13:23:15.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.626]                               info)
[13:23:15.626]                           }
[13:23:15.626]                           else {
[13:23:15.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.626]                               info, version)
[13:23:15.626]                           }
[13:23:15.626]                           base::stop(msg)
[13:23:15.626]                         }
[13:23:15.626]                       })
[13:23:15.626]                     }
[13:23:15.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.626]                     base::options(mc.cores = 1L)
[13:23:15.626]                   }
[13:23:15.626]                   options(future.plan = NULL)
[13:23:15.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.626]                 }
[13:23:15.626]                 ...future.workdir <- getwd()
[13:23:15.626]             }
[13:23:15.626]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.626]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.626]         }
[13:23:15.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.626]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.626]             base::names(...future.oldOptions))
[13:23:15.626]     }
[13:23:15.626]     if (FALSE) {
[13:23:15.626]     }
[13:23:15.626]     else {
[13:23:15.626]         if (TRUE) {
[13:23:15.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.626]                 open = "w")
[13:23:15.626]         }
[13:23:15.626]         else {
[13:23:15.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.626]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.626]         }
[13:23:15.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.626]             base::sink(type = "output", split = FALSE)
[13:23:15.626]             base::close(...future.stdout)
[13:23:15.626]         }, add = TRUE)
[13:23:15.626]     }
[13:23:15.626]     ...future.frame <- base::sys.nframe()
[13:23:15.626]     ...future.conditions <- base::list()
[13:23:15.626]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.626]     if (FALSE) {
[13:23:15.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.626]     }
[13:23:15.626]     ...future.result <- base::tryCatch({
[13:23:15.626]         base::withCallingHandlers({
[13:23:15.626]             ...future.value <- base::withVisible(base::local({
[13:23:15.626]                 ...future.makeSendCondition <- base::local({
[13:23:15.626]                   sendCondition <- NULL
[13:23:15.626]                   function(frame = 1L) {
[13:23:15.626]                     if (is.function(sendCondition)) 
[13:23:15.626]                       return(sendCondition)
[13:23:15.626]                     ns <- getNamespace("parallel")
[13:23:15.626]                     if (exists("sendData", mode = "function", 
[13:23:15.626]                       envir = ns)) {
[13:23:15.626]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.626]                         envir = ns)
[13:23:15.626]                       envir <- sys.frame(frame)
[13:23:15.626]                       master <- NULL
[13:23:15.626]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.626]                         !identical(envir, emptyenv())) {
[13:23:15.626]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.626]                           inherits = FALSE)) {
[13:23:15.626]                           master <- get("master", mode = "list", 
[13:23:15.626]                             envir = envir, inherits = FALSE)
[13:23:15.626]                           if (inherits(master, c("SOCKnode", 
[13:23:15.626]                             "SOCK0node"))) {
[13:23:15.626]                             sendCondition <<- function(cond) {
[13:23:15.626]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.626]                                 success = TRUE)
[13:23:15.626]                               parallel_sendData(master, data)
[13:23:15.626]                             }
[13:23:15.626]                             return(sendCondition)
[13:23:15.626]                           }
[13:23:15.626]                         }
[13:23:15.626]                         frame <- frame + 1L
[13:23:15.626]                         envir <- sys.frame(frame)
[13:23:15.626]                       }
[13:23:15.626]                     }
[13:23:15.626]                     sendCondition <<- function(cond) NULL
[13:23:15.626]                   }
[13:23:15.626]                 })
[13:23:15.626]                 withCallingHandlers({
[13:23:15.626]                   {
[13:23:15.626]                     outer_function(1L)
[13:23:15.626]                   }
[13:23:15.626]                 }, immediateCondition = function(cond) {
[13:23:15.626]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.626]                   sendCondition(cond)
[13:23:15.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.626]                   {
[13:23:15.626]                     inherits <- base::inherits
[13:23:15.626]                     invokeRestart <- base::invokeRestart
[13:23:15.626]                     is.null <- base::is.null
[13:23:15.626]                     muffled <- FALSE
[13:23:15.626]                     if (inherits(cond, "message")) {
[13:23:15.626]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.626]                       if (muffled) 
[13:23:15.626]                         invokeRestart("muffleMessage")
[13:23:15.626]                     }
[13:23:15.626]                     else if (inherits(cond, "warning")) {
[13:23:15.626]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.626]                       if (muffled) 
[13:23:15.626]                         invokeRestart("muffleWarning")
[13:23:15.626]                     }
[13:23:15.626]                     else if (inherits(cond, "condition")) {
[13:23:15.626]                       if (!is.null(pattern)) {
[13:23:15.626]                         computeRestarts <- base::computeRestarts
[13:23:15.626]                         grepl <- base::grepl
[13:23:15.626]                         restarts <- computeRestarts(cond)
[13:23:15.626]                         for (restart in restarts) {
[13:23:15.626]                           name <- restart$name
[13:23:15.626]                           if (is.null(name)) 
[13:23:15.626]                             next
[13:23:15.626]                           if (!grepl(pattern, name)) 
[13:23:15.626]                             next
[13:23:15.626]                           invokeRestart(restart)
[13:23:15.626]                           muffled <- TRUE
[13:23:15.626]                           break
[13:23:15.626]                         }
[13:23:15.626]                       }
[13:23:15.626]                     }
[13:23:15.626]                     invisible(muffled)
[13:23:15.626]                   }
[13:23:15.626]                   muffleCondition(cond)
[13:23:15.626]                 })
[13:23:15.626]             }))
[13:23:15.626]             future::FutureResult(value = ...future.value$value, 
[13:23:15.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.626]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.626]                     ...future.globalenv.names))
[13:23:15.626]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.626]         }, condition = base::local({
[13:23:15.626]             c <- base::c
[13:23:15.626]             inherits <- base::inherits
[13:23:15.626]             invokeRestart <- base::invokeRestart
[13:23:15.626]             length <- base::length
[13:23:15.626]             list <- base::list
[13:23:15.626]             seq.int <- base::seq.int
[13:23:15.626]             signalCondition <- base::signalCondition
[13:23:15.626]             sys.calls <- base::sys.calls
[13:23:15.626]             `[[` <- base::`[[`
[13:23:15.626]             `+` <- base::`+`
[13:23:15.626]             `<<-` <- base::`<<-`
[13:23:15.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.626]                   3L)]
[13:23:15.626]             }
[13:23:15.626]             function(cond) {
[13:23:15.626]                 is_error <- inherits(cond, "error")
[13:23:15.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.626]                   NULL)
[13:23:15.626]                 if (is_error) {
[13:23:15.626]                   sessionInformation <- function() {
[13:23:15.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.626]                       search = base::search(), system = base::Sys.info())
[13:23:15.626]                   }
[13:23:15.626]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.626]                     cond$call), session = sessionInformation(), 
[13:23:15.626]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.626]                   signalCondition(cond)
[13:23:15.626]                 }
[13:23:15.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.626]                 "immediateCondition"))) {
[13:23:15.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.626]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.626]                   if (TRUE && !signal) {
[13:23:15.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.626]                     {
[13:23:15.626]                       inherits <- base::inherits
[13:23:15.626]                       invokeRestart <- base::invokeRestart
[13:23:15.626]                       is.null <- base::is.null
[13:23:15.626]                       muffled <- FALSE
[13:23:15.626]                       if (inherits(cond, "message")) {
[13:23:15.626]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.626]                         if (muffled) 
[13:23:15.626]                           invokeRestart("muffleMessage")
[13:23:15.626]                       }
[13:23:15.626]                       else if (inherits(cond, "warning")) {
[13:23:15.626]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.626]                         if (muffled) 
[13:23:15.626]                           invokeRestart("muffleWarning")
[13:23:15.626]                       }
[13:23:15.626]                       else if (inherits(cond, "condition")) {
[13:23:15.626]                         if (!is.null(pattern)) {
[13:23:15.626]                           computeRestarts <- base::computeRestarts
[13:23:15.626]                           grepl <- base::grepl
[13:23:15.626]                           restarts <- computeRestarts(cond)
[13:23:15.626]                           for (restart in restarts) {
[13:23:15.626]                             name <- restart$name
[13:23:15.626]                             if (is.null(name)) 
[13:23:15.626]                               next
[13:23:15.626]                             if (!grepl(pattern, name)) 
[13:23:15.626]                               next
[13:23:15.626]                             invokeRestart(restart)
[13:23:15.626]                             muffled <- TRUE
[13:23:15.626]                             break
[13:23:15.626]                           }
[13:23:15.626]                         }
[13:23:15.626]                       }
[13:23:15.626]                       invisible(muffled)
[13:23:15.626]                     }
[13:23:15.626]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.626]                   }
[13:23:15.626]                 }
[13:23:15.626]                 else {
[13:23:15.626]                   if (TRUE) {
[13:23:15.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.626]                     {
[13:23:15.626]                       inherits <- base::inherits
[13:23:15.626]                       invokeRestart <- base::invokeRestart
[13:23:15.626]                       is.null <- base::is.null
[13:23:15.626]                       muffled <- FALSE
[13:23:15.626]                       if (inherits(cond, "message")) {
[13:23:15.626]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.626]                         if (muffled) 
[13:23:15.626]                           invokeRestart("muffleMessage")
[13:23:15.626]                       }
[13:23:15.626]                       else if (inherits(cond, "warning")) {
[13:23:15.626]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.626]                         if (muffled) 
[13:23:15.626]                           invokeRestart("muffleWarning")
[13:23:15.626]                       }
[13:23:15.626]                       else if (inherits(cond, "condition")) {
[13:23:15.626]                         if (!is.null(pattern)) {
[13:23:15.626]                           computeRestarts <- base::computeRestarts
[13:23:15.626]                           grepl <- base::grepl
[13:23:15.626]                           restarts <- computeRestarts(cond)
[13:23:15.626]                           for (restart in restarts) {
[13:23:15.626]                             name <- restart$name
[13:23:15.626]                             if (is.null(name)) 
[13:23:15.626]                               next
[13:23:15.626]                             if (!grepl(pattern, name)) 
[13:23:15.626]                               next
[13:23:15.626]                             invokeRestart(restart)
[13:23:15.626]                             muffled <- TRUE
[13:23:15.626]                             break
[13:23:15.626]                           }
[13:23:15.626]                         }
[13:23:15.626]                       }
[13:23:15.626]                       invisible(muffled)
[13:23:15.626]                     }
[13:23:15.626]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.626]                   }
[13:23:15.626]                 }
[13:23:15.626]             }
[13:23:15.626]         }))
[13:23:15.626]     }, error = function(ex) {
[13:23:15.626]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.626]                 ...future.rng), started = ...future.startTime, 
[13:23:15.626]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.626]             version = "1.8"), class = "FutureResult")
[13:23:15.626]     }, finally = {
[13:23:15.626]         if (!identical(...future.workdir, getwd())) 
[13:23:15.626]             setwd(...future.workdir)
[13:23:15.626]         {
[13:23:15.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.626]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.626]             }
[13:23:15.626]             base::options(...future.oldOptions)
[13:23:15.626]             if (.Platform$OS.type == "windows") {
[13:23:15.626]                 old_names <- names(...future.oldEnvVars)
[13:23:15.626]                 envs <- base::Sys.getenv()
[13:23:15.626]                 names <- names(envs)
[13:23:15.626]                 common <- intersect(names, old_names)
[13:23:15.626]                 added <- setdiff(names, old_names)
[13:23:15.626]                 removed <- setdiff(old_names, names)
[13:23:15.626]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.626]                   envs[common]]
[13:23:15.626]                 NAMES <- toupper(changed)
[13:23:15.626]                 args <- list()
[13:23:15.626]                 for (kk in seq_along(NAMES)) {
[13:23:15.626]                   name <- changed[[kk]]
[13:23:15.626]                   NAME <- NAMES[[kk]]
[13:23:15.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.626]                     next
[13:23:15.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.626]                 }
[13:23:15.626]                 NAMES <- toupper(added)
[13:23:15.626]                 for (kk in seq_along(NAMES)) {
[13:23:15.626]                   name <- added[[kk]]
[13:23:15.626]                   NAME <- NAMES[[kk]]
[13:23:15.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.626]                     next
[13:23:15.626]                   args[[name]] <- ""
[13:23:15.626]                 }
[13:23:15.626]                 NAMES <- toupper(removed)
[13:23:15.626]                 for (kk in seq_along(NAMES)) {
[13:23:15.626]                   name <- removed[[kk]]
[13:23:15.626]                   NAME <- NAMES[[kk]]
[13:23:15.626]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.626]                     next
[13:23:15.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.626]                 }
[13:23:15.626]                 if (length(args) > 0) 
[13:23:15.626]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.626]             }
[13:23:15.626]             else {
[13:23:15.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.626]             }
[13:23:15.626]             {
[13:23:15.626]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.626]                   0L) {
[13:23:15.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.626]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.626]                   base::options(opts)
[13:23:15.626]                 }
[13:23:15.626]                 {
[13:23:15.626]                   {
[13:23:15.626]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.626]                     NULL
[13:23:15.626]                   }
[13:23:15.626]                   options(future.plan = NULL)
[13:23:15.626]                   if (is.na(NA_character_)) 
[13:23:15.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.626]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.626]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.626]                     envir = parent.frame()) 
[13:23:15.626]                   {
[13:23:15.626]                     if (is.function(workers)) 
[13:23:15.626]                       workers <- workers()
[13:23:15.626]                     workers <- structure(as.integer(workers), 
[13:23:15.626]                       class = class(workers))
[13:23:15.626]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.626]                       workers >= 1)
[13:23:15.626]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.626]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.626]                     }
[13:23:15.626]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.626]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.626]                       envir = envir)
[13:23:15.626]                     if (!future$lazy) 
[13:23:15.626]                       future <- run(future)
[13:23:15.626]                     invisible(future)
[13:23:15.626]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.626]                 }
[13:23:15.626]             }
[13:23:15.626]         }
[13:23:15.626]     })
[13:23:15.626]     if (TRUE) {
[13:23:15.626]         base::sink(type = "output", split = FALSE)
[13:23:15.626]         if (TRUE) {
[13:23:15.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.626]         }
[13:23:15.626]         else {
[13:23:15.626]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.626]         }
[13:23:15.626]         base::close(...future.stdout)
[13:23:15.626]         ...future.stdout <- NULL
[13:23:15.626]     }
[13:23:15.626]     ...future.result$conditions <- ...future.conditions
[13:23:15.626]     ...future.result$finished <- base::Sys.time()
[13:23:15.626]     ...future.result
[13:23:15.626] }
[13:23:15.629] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:23:15.630] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:23:15.630] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:23:15.630] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:23:15.630] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:23:15.631] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:23:15.631] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:23:15.631] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:23:15.631] MultisessionFuture started
[13:23:15.632] - Launch lazy future ... done
[13:23:15.632] run() for ‘MultisessionFuture’ ... done
[13:23:15.632] result() for ClusterFuture ...
[13:23:15.632] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.632] - Validating connection of MultisessionFuture
[13:23:15.682] - received message: FutureResult
[13:23:15.682] - Received FutureResult
[13:23:15.683] - Erased future from FutureRegistry
[13:23:15.683] result() for ClusterFuture ...
[13:23:15.683] - result already collected: FutureResult
[13:23:15.683] result() for ClusterFuture ... done
[13:23:15.683] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.683] result() for ClusterFuture ... done
[13:23:15.683] result() for ClusterFuture ...
[13:23:15.683] - result already collected: FutureResult
[13:23:15.683] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[13:23:15.685] getGlobalsAndPackages() ...
[13:23:15.685] Searching for globals...
[13:23:15.689] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[13:23:15.690] Searching for globals ... DONE
[13:23:15.690] Resolving globals: FALSE
[13:23:15.690] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[13:23:15.691] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[13:23:15.691] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[13:23:15.691] 
[13:23:15.691] getGlobalsAndPackages() ... DONE
[13:23:15.691] run() for ‘Future’ ...
[13:23:15.692] - state: ‘created’
[13:23:15.692] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:23:15.706] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:15.706] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:23:15.707]   - Field: ‘node’
[13:23:15.707]   - Field: ‘label’
[13:23:15.707]   - Field: ‘local’
[13:23:15.707]   - Field: ‘owner’
[13:23:15.707]   - Field: ‘envir’
[13:23:15.707]   - Field: ‘workers’
[13:23:15.707]   - Field: ‘packages’
[13:23:15.707]   - Field: ‘gc’
[13:23:15.707]   - Field: ‘conditions’
[13:23:15.707]   - Field: ‘persistent’
[13:23:15.708]   - Field: ‘expr’
[13:23:15.708]   - Field: ‘uuid’
[13:23:15.708]   - Field: ‘seed’
[13:23:15.708]   - Field: ‘version’
[13:23:15.708]   - Field: ‘result’
[13:23:15.708]   - Field: ‘asynchronous’
[13:23:15.708]   - Field: ‘calls’
[13:23:15.708]   - Field: ‘globals’
[13:23:15.708]   - Field: ‘stdout’
[13:23:15.708]   - Field: ‘earlySignal’
[13:23:15.709]   - Field: ‘lazy’
[13:23:15.709]   - Field: ‘state’
[13:23:15.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:23:15.709] - Launch lazy future ...
[13:23:15.709] Packages needed by the future expression (n = 0): <none>
[13:23:15.709] Packages needed by future strategies (n = 0): <none>
[13:23:15.710] {
[13:23:15.710]     {
[13:23:15.710]         {
[13:23:15.710]             ...future.startTime <- base::Sys.time()
[13:23:15.710]             {
[13:23:15.710]                 {
[13:23:15.710]                   {
[13:23:15.710]                     {
[13:23:15.710]                       base::local({
[13:23:15.710]                         has_future <- base::requireNamespace("future", 
[13:23:15.710]                           quietly = TRUE)
[13:23:15.710]                         if (has_future) {
[13:23:15.710]                           ns <- base::getNamespace("future")
[13:23:15.710]                           version <- ns[[".package"]][["version"]]
[13:23:15.710]                           if (is.null(version)) 
[13:23:15.710]                             version <- utils::packageVersion("future")
[13:23:15.710]                         }
[13:23:15.710]                         else {
[13:23:15.710]                           version <- NULL
[13:23:15.710]                         }
[13:23:15.710]                         if (!has_future || version < "1.8.0") {
[13:23:15.710]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:15.710]                             "", base::R.version$version.string), 
[13:23:15.710]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:15.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:15.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:15.710]                               "release", "version")], collapse = " "), 
[13:23:15.710]                             hostname = base::Sys.info()[["nodename"]])
[13:23:15.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:15.710]                             info)
[13:23:15.710]                           info <- base::paste(info, collapse = "; ")
[13:23:15.710]                           if (!has_future) {
[13:23:15.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:15.710]                               info)
[13:23:15.710]                           }
[13:23:15.710]                           else {
[13:23:15.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:15.710]                               info, version)
[13:23:15.710]                           }
[13:23:15.710]                           base::stop(msg)
[13:23:15.710]                         }
[13:23:15.710]                       })
[13:23:15.710]                     }
[13:23:15.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:15.710]                     base::options(mc.cores = 1L)
[13:23:15.710]                   }
[13:23:15.710]                   options(future.plan = NULL)
[13:23:15.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:15.710]                 }
[13:23:15.710]                 ...future.workdir <- getwd()
[13:23:15.710]             }
[13:23:15.710]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:15.710]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:15.710]         }
[13:23:15.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:15.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:15.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:15.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:15.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:15.710]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:15.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:15.710]             base::names(...future.oldOptions))
[13:23:15.710]     }
[13:23:15.710]     if (FALSE) {
[13:23:15.710]     }
[13:23:15.710]     else {
[13:23:15.710]         if (TRUE) {
[13:23:15.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:15.710]                 open = "w")
[13:23:15.710]         }
[13:23:15.710]         else {
[13:23:15.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:15.710]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:15.710]         }
[13:23:15.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:15.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:15.710]             base::sink(type = "output", split = FALSE)
[13:23:15.710]             base::close(...future.stdout)
[13:23:15.710]         }, add = TRUE)
[13:23:15.710]     }
[13:23:15.710]     ...future.frame <- base::sys.nframe()
[13:23:15.710]     ...future.conditions <- base::list()
[13:23:15.710]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:15.710]     if (FALSE) {
[13:23:15.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:15.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:15.710]     }
[13:23:15.710]     ...future.result <- base::tryCatch({
[13:23:15.710]         base::withCallingHandlers({
[13:23:15.710]             ...future.value <- base::withVisible(base::local({
[13:23:15.710]                 ...future.makeSendCondition <- base::local({
[13:23:15.710]                   sendCondition <- NULL
[13:23:15.710]                   function(frame = 1L) {
[13:23:15.710]                     if (is.function(sendCondition)) 
[13:23:15.710]                       return(sendCondition)
[13:23:15.710]                     ns <- getNamespace("parallel")
[13:23:15.710]                     if (exists("sendData", mode = "function", 
[13:23:15.710]                       envir = ns)) {
[13:23:15.710]                       parallel_sendData <- get("sendData", mode = "function", 
[13:23:15.710]                         envir = ns)
[13:23:15.710]                       envir <- sys.frame(frame)
[13:23:15.710]                       master <- NULL
[13:23:15.710]                       while (!identical(envir, .GlobalEnv) && 
[13:23:15.710]                         !identical(envir, emptyenv())) {
[13:23:15.710]                         if (exists("master", mode = "list", envir = envir, 
[13:23:15.710]                           inherits = FALSE)) {
[13:23:15.710]                           master <- get("master", mode = "list", 
[13:23:15.710]                             envir = envir, inherits = FALSE)
[13:23:15.710]                           if (inherits(master, c("SOCKnode", 
[13:23:15.710]                             "SOCK0node"))) {
[13:23:15.710]                             sendCondition <<- function(cond) {
[13:23:15.710]                               data <- list(type = "VALUE", value = cond, 
[13:23:15.710]                                 success = TRUE)
[13:23:15.710]                               parallel_sendData(master, data)
[13:23:15.710]                             }
[13:23:15.710]                             return(sendCondition)
[13:23:15.710]                           }
[13:23:15.710]                         }
[13:23:15.710]                         frame <- frame + 1L
[13:23:15.710]                         envir <- sys.frame(frame)
[13:23:15.710]                       }
[13:23:15.710]                     }
[13:23:15.710]                     sendCondition <<- function(cond) NULL
[13:23:15.710]                   }
[13:23:15.710]                 })
[13:23:15.710]                 withCallingHandlers({
[13:23:15.710]                   {
[13:23:15.710]                     outer_function(1L)
[13:23:15.710]                   }
[13:23:15.710]                 }, immediateCondition = function(cond) {
[13:23:15.710]                   sendCondition <- ...future.makeSendCondition()
[13:23:15.710]                   sendCondition(cond)
[13:23:15.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.710]                   {
[13:23:15.710]                     inherits <- base::inherits
[13:23:15.710]                     invokeRestart <- base::invokeRestart
[13:23:15.710]                     is.null <- base::is.null
[13:23:15.710]                     muffled <- FALSE
[13:23:15.710]                     if (inherits(cond, "message")) {
[13:23:15.710]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:15.710]                       if (muffled) 
[13:23:15.710]                         invokeRestart("muffleMessage")
[13:23:15.710]                     }
[13:23:15.710]                     else if (inherits(cond, "warning")) {
[13:23:15.710]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:15.710]                       if (muffled) 
[13:23:15.710]                         invokeRestart("muffleWarning")
[13:23:15.710]                     }
[13:23:15.710]                     else if (inherits(cond, "condition")) {
[13:23:15.710]                       if (!is.null(pattern)) {
[13:23:15.710]                         computeRestarts <- base::computeRestarts
[13:23:15.710]                         grepl <- base::grepl
[13:23:15.710]                         restarts <- computeRestarts(cond)
[13:23:15.710]                         for (restart in restarts) {
[13:23:15.710]                           name <- restart$name
[13:23:15.710]                           if (is.null(name)) 
[13:23:15.710]                             next
[13:23:15.710]                           if (!grepl(pattern, name)) 
[13:23:15.710]                             next
[13:23:15.710]                           invokeRestart(restart)
[13:23:15.710]                           muffled <- TRUE
[13:23:15.710]                           break
[13:23:15.710]                         }
[13:23:15.710]                       }
[13:23:15.710]                     }
[13:23:15.710]                     invisible(muffled)
[13:23:15.710]                   }
[13:23:15.710]                   muffleCondition(cond)
[13:23:15.710]                 })
[13:23:15.710]             }))
[13:23:15.710]             future::FutureResult(value = ...future.value$value, 
[13:23:15.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.710]                   ...future.rng), globalenv = if (FALSE) 
[13:23:15.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:15.710]                     ...future.globalenv.names))
[13:23:15.710]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:15.710]         }, condition = base::local({
[13:23:15.710]             c <- base::c
[13:23:15.710]             inherits <- base::inherits
[13:23:15.710]             invokeRestart <- base::invokeRestart
[13:23:15.710]             length <- base::length
[13:23:15.710]             list <- base::list
[13:23:15.710]             seq.int <- base::seq.int
[13:23:15.710]             signalCondition <- base::signalCondition
[13:23:15.710]             sys.calls <- base::sys.calls
[13:23:15.710]             `[[` <- base::`[[`
[13:23:15.710]             `+` <- base::`+`
[13:23:15.710]             `<<-` <- base::`<<-`
[13:23:15.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:15.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:15.710]                   3L)]
[13:23:15.710]             }
[13:23:15.710]             function(cond) {
[13:23:15.710]                 is_error <- inherits(cond, "error")
[13:23:15.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:15.710]                   NULL)
[13:23:15.710]                 if (is_error) {
[13:23:15.710]                   sessionInformation <- function() {
[13:23:15.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:15.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:15.710]                       search = base::search(), system = base::Sys.info())
[13:23:15.710]                   }
[13:23:15.710]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:15.710]                     cond$call), session = sessionInformation(), 
[13:23:15.710]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:15.710]                   signalCondition(cond)
[13:23:15.710]                 }
[13:23:15.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:15.710]                 "immediateCondition"))) {
[13:23:15.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:15.710]                   ...future.conditions[[length(...future.conditions) + 
[13:23:15.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:15.710]                   if (TRUE && !signal) {
[13:23:15.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.710]                     {
[13:23:15.710]                       inherits <- base::inherits
[13:23:15.710]                       invokeRestart <- base::invokeRestart
[13:23:15.710]                       is.null <- base::is.null
[13:23:15.710]                       muffled <- FALSE
[13:23:15.710]                       if (inherits(cond, "message")) {
[13:23:15.710]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.710]                         if (muffled) 
[13:23:15.710]                           invokeRestart("muffleMessage")
[13:23:15.710]                       }
[13:23:15.710]                       else if (inherits(cond, "warning")) {
[13:23:15.710]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.710]                         if (muffled) 
[13:23:15.710]                           invokeRestart("muffleWarning")
[13:23:15.710]                       }
[13:23:15.710]                       else if (inherits(cond, "condition")) {
[13:23:15.710]                         if (!is.null(pattern)) {
[13:23:15.710]                           computeRestarts <- base::computeRestarts
[13:23:15.710]                           grepl <- base::grepl
[13:23:15.710]                           restarts <- computeRestarts(cond)
[13:23:15.710]                           for (restart in restarts) {
[13:23:15.710]                             name <- restart$name
[13:23:15.710]                             if (is.null(name)) 
[13:23:15.710]                               next
[13:23:15.710]                             if (!grepl(pattern, name)) 
[13:23:15.710]                               next
[13:23:15.710]                             invokeRestart(restart)
[13:23:15.710]                             muffled <- TRUE
[13:23:15.710]                             break
[13:23:15.710]                           }
[13:23:15.710]                         }
[13:23:15.710]                       }
[13:23:15.710]                       invisible(muffled)
[13:23:15.710]                     }
[13:23:15.710]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.710]                   }
[13:23:15.710]                 }
[13:23:15.710]                 else {
[13:23:15.710]                   if (TRUE) {
[13:23:15.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:15.710]                     {
[13:23:15.710]                       inherits <- base::inherits
[13:23:15.710]                       invokeRestart <- base::invokeRestart
[13:23:15.710]                       is.null <- base::is.null
[13:23:15.710]                       muffled <- FALSE
[13:23:15.710]                       if (inherits(cond, "message")) {
[13:23:15.710]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:15.710]                         if (muffled) 
[13:23:15.710]                           invokeRestart("muffleMessage")
[13:23:15.710]                       }
[13:23:15.710]                       else if (inherits(cond, "warning")) {
[13:23:15.710]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:15.710]                         if (muffled) 
[13:23:15.710]                           invokeRestart("muffleWarning")
[13:23:15.710]                       }
[13:23:15.710]                       else if (inherits(cond, "condition")) {
[13:23:15.710]                         if (!is.null(pattern)) {
[13:23:15.710]                           computeRestarts <- base::computeRestarts
[13:23:15.710]                           grepl <- base::grepl
[13:23:15.710]                           restarts <- computeRestarts(cond)
[13:23:15.710]                           for (restart in restarts) {
[13:23:15.710]                             name <- restart$name
[13:23:15.710]                             if (is.null(name)) 
[13:23:15.710]                               next
[13:23:15.710]                             if (!grepl(pattern, name)) 
[13:23:15.710]                               next
[13:23:15.710]                             invokeRestart(restart)
[13:23:15.710]                             muffled <- TRUE
[13:23:15.710]                             break
[13:23:15.710]                           }
[13:23:15.710]                         }
[13:23:15.710]                       }
[13:23:15.710]                       invisible(muffled)
[13:23:15.710]                     }
[13:23:15.710]                     muffleCondition(cond, pattern = "^muffle")
[13:23:15.710]                   }
[13:23:15.710]                 }
[13:23:15.710]             }
[13:23:15.710]         }))
[13:23:15.710]     }, error = function(ex) {
[13:23:15.710]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:15.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:15.710]                 ...future.rng), started = ...future.startTime, 
[13:23:15.710]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:15.710]             version = "1.8"), class = "FutureResult")
[13:23:15.710]     }, finally = {
[13:23:15.710]         if (!identical(...future.workdir, getwd())) 
[13:23:15.710]             setwd(...future.workdir)
[13:23:15.710]         {
[13:23:15.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:15.710]                 ...future.oldOptions$nwarnings <- NULL
[13:23:15.710]             }
[13:23:15.710]             base::options(...future.oldOptions)
[13:23:15.710]             if (.Platform$OS.type == "windows") {
[13:23:15.710]                 old_names <- names(...future.oldEnvVars)
[13:23:15.710]                 envs <- base::Sys.getenv()
[13:23:15.710]                 names <- names(envs)
[13:23:15.710]                 common <- intersect(names, old_names)
[13:23:15.710]                 added <- setdiff(names, old_names)
[13:23:15.710]                 removed <- setdiff(old_names, names)
[13:23:15.710]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:15.710]                   envs[common]]
[13:23:15.710]                 NAMES <- toupper(changed)
[13:23:15.710]                 args <- list()
[13:23:15.710]                 for (kk in seq_along(NAMES)) {
[13:23:15.710]                   name <- changed[[kk]]
[13:23:15.710]                   NAME <- NAMES[[kk]]
[13:23:15.710]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.710]                     next
[13:23:15.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.710]                 }
[13:23:15.710]                 NAMES <- toupper(added)
[13:23:15.710]                 for (kk in seq_along(NAMES)) {
[13:23:15.710]                   name <- added[[kk]]
[13:23:15.710]                   NAME <- NAMES[[kk]]
[13:23:15.710]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.710]                     next
[13:23:15.710]                   args[[name]] <- ""
[13:23:15.710]                 }
[13:23:15.710]                 NAMES <- toupper(removed)
[13:23:15.710]                 for (kk in seq_along(NAMES)) {
[13:23:15.710]                   name <- removed[[kk]]
[13:23:15.710]                   NAME <- NAMES[[kk]]
[13:23:15.710]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:15.710]                     next
[13:23:15.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:15.710]                 }
[13:23:15.710]                 if (length(args) > 0) 
[13:23:15.710]                   base::do.call(base::Sys.setenv, args = args)
[13:23:15.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:15.710]             }
[13:23:15.710]             else {
[13:23:15.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:15.710]             }
[13:23:15.710]             {
[13:23:15.710]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:15.710]                   0L) {
[13:23:15.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:15.710]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:15.710]                   base::options(opts)
[13:23:15.710]                 }
[13:23:15.710]                 {
[13:23:15.710]                   {
[13:23:15.710]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:15.710]                     NULL
[13:23:15.710]                   }
[13:23:15.710]                   options(future.plan = NULL)
[13:23:15.710]                   if (is.na(NA_character_)) 
[13:23:15.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:15.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:15.710]                   future::plan(list(function (..., workers = availableCores(), 
[13:23:15.710]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:23:15.710]                     envir = parent.frame()) 
[13:23:15.710]                   {
[13:23:15.710]                     if (is.function(workers)) 
[13:23:15.710]                       workers <- workers()
[13:23:15.710]                     workers <- structure(as.integer(workers), 
[13:23:15.710]                       class = class(workers))
[13:23:15.710]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:23:15.710]                       workers >= 1)
[13:23:15.710]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:23:15.710]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:23:15.710]                     }
[13:23:15.710]                     future <- MultisessionFuture(..., workers = workers, 
[13:23:15.710]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:23:15.710]                       envir = envir)
[13:23:15.710]                     if (!future$lazy) 
[13:23:15.710]                       future <- run(future)
[13:23:15.710]                     invisible(future)
[13:23:15.710]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:15.710]                 }
[13:23:15.710]             }
[13:23:15.710]         }
[13:23:15.710]     })
[13:23:15.710]     if (TRUE) {
[13:23:15.710]         base::sink(type = "output", split = FALSE)
[13:23:15.710]         if (TRUE) {
[13:23:15.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:15.710]         }
[13:23:15.710]         else {
[13:23:15.710]             ...future.result["stdout"] <- base::list(NULL)
[13:23:15.710]         }
[13:23:15.710]         base::close(...future.stdout)
[13:23:15.710]         ...future.stdout <- NULL
[13:23:15.710]     }
[13:23:15.710]     ...future.result$conditions <- ...future.conditions
[13:23:15.710]     ...future.result$finished <- base::Sys.time()
[13:23:15.710]     ...future.result
[13:23:15.710] }
[13:23:15.713] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[13:23:15.713] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[13:23:15.713] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[13:23:15.713] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[13:23:15.714] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[13:23:15.714] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[13:23:15.714] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[13:23:15.714] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[13:23:15.715] MultisessionFuture started
[13:23:15.715] - Launch lazy future ... done
[13:23:15.715] run() for ‘MultisessionFuture’ ... done
[13:23:15.715] result() for ClusterFuture ...
[13:23:15.715] receiveMessageFromWorker() for ClusterFuture ...
[13:23:15.716] - Validating connection of MultisessionFuture
[13:23:15.761] - received message: FutureResult
[13:23:15.762] - Received FutureResult
[13:23:15.762] - Erased future from FutureRegistry
[13:23:15.762] result() for ClusterFuture ...
[13:23:15.762] - result already collected: FutureResult
[13:23:15.762] result() for ClusterFuture ... done
[13:23:15.762] receiveMessageFromWorker() for ClusterFuture ... done
[13:23:15.762] result() for ClusterFuture ... done
[13:23:15.762] result() for ClusterFuture ...
[13:23:15.762] - result already collected: FutureResult
[13:23:15.762] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[13:23:15.764] plan(): Setting new future strategy stack:
[13:23:15.765] List of future strategies:
[13:23:15.765] 1. FutureStrategy:
[13:23:15.765]    - args: function (..., envir = parent.frame())
[13:23:15.765]    - tweaked: FALSE
[13:23:15.765]    - call: future::plan(oplan)
[13:23:15.765] plan(): nbrOfWorkers() = 1
> 
