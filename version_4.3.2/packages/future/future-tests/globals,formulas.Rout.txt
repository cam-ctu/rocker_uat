
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:48.224] plan(): Setting new future strategy stack:
[16:04:48.225] List of future strategies:
[16:04:48.225] 1. sequential:
[16:04:48.225]    - args: function (..., envir = parent.frame())
[16:04:48.225]    - tweaked: FALSE
[16:04:48.225]    - call: future::plan("sequential")
[16:04:48.238] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[16:04:48.293] plan(): Setting new future strategy stack:
[16:04:48.293] List of future strategies:
[16:04:48.293] 1. sequential:
[16:04:48.293]    - args: function (..., envir = parent.frame())
[16:04:48.293]    - tweaked: FALSE
[16:04:48.293]    - call: plan(strategy)
[16:04:48.305] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[16:04:48.306] getGlobalsAndPackages() ...
[16:04:48.306] Searching for globals...
[16:04:48.312] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.313] Searching for globals ... DONE
[16:04:48.313] Resolving globals: FALSE
[16:04:48.314] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.314] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.314] - globals: [2] ‘weight’, ‘group’
[16:04:48.314] - packages: [1] ‘stats’
[16:04:48.315] getGlobalsAndPackages() ... DONE
[16:04:48.315] run() for ‘Future’ ...
[16:04:48.315] - state: ‘created’
[16:04:48.316] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.316] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.316]   - Field: ‘label’
[16:04:48.316]   - Field: ‘local’
[16:04:48.316]   - Field: ‘owner’
[16:04:48.316]   - Field: ‘envir’
[16:04:48.317]   - Field: ‘packages’
[16:04:48.317]   - Field: ‘gc’
[16:04:48.317]   - Field: ‘conditions’
[16:04:48.317]   - Field: ‘expr’
[16:04:48.317]   - Field: ‘uuid’
[16:04:48.317]   - Field: ‘seed’
[16:04:48.317]   - Field: ‘version’
[16:04:48.317]   - Field: ‘result’
[16:04:48.317]   - Field: ‘asynchronous’
[16:04:48.317]   - Field: ‘calls’
[16:04:48.317]   - Field: ‘globals’
[16:04:48.318]   - Field: ‘stdout’
[16:04:48.318]   - Field: ‘earlySignal’
[16:04:48.318]   - Field: ‘lazy’
[16:04:48.318]   - Field: ‘state’
[16:04:48.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.318] - Launch lazy future ...
[16:04:48.319] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.319] Packages needed by future strategies (n = 0): <none>
[16:04:48.320] {
[16:04:48.320]     {
[16:04:48.320]         {
[16:04:48.320]             ...future.startTime <- base::Sys.time()
[16:04:48.320]             {
[16:04:48.320]                 {
[16:04:48.320]                   {
[16:04:48.320]                     {
[16:04:48.320]                       base::local({
[16:04:48.320]                         has_future <- base::requireNamespace("future", 
[16:04:48.320]                           quietly = TRUE)
[16:04:48.320]                         if (has_future) {
[16:04:48.320]                           ns <- base::getNamespace("future")
[16:04:48.320]                           version <- ns[[".package"]][["version"]]
[16:04:48.320]                           if (is.null(version)) 
[16:04:48.320]                             version <- utils::packageVersion("future")
[16:04:48.320]                         }
[16:04:48.320]                         else {
[16:04:48.320]                           version <- NULL
[16:04:48.320]                         }
[16:04:48.320]                         if (!has_future || version < "1.8.0") {
[16:04:48.320]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.320]                             "", base::R.version$version.string), 
[16:04:48.320]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.320]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.320]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.320]                               "release", "version")], collapse = " "), 
[16:04:48.320]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.320]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.320]                             info)
[16:04:48.320]                           info <- base::paste(info, collapse = "; ")
[16:04:48.320]                           if (!has_future) {
[16:04:48.320]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.320]                               info)
[16:04:48.320]                           }
[16:04:48.320]                           else {
[16:04:48.320]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.320]                               info, version)
[16:04:48.320]                           }
[16:04:48.320]                           base::stop(msg)
[16:04:48.320]                         }
[16:04:48.320]                       })
[16:04:48.320]                     }
[16:04:48.320]                     base::local({
[16:04:48.320]                       for (pkg in "stats") {
[16:04:48.320]                         base::loadNamespace(pkg)
[16:04:48.320]                         base::library(pkg, character.only = TRUE)
[16:04:48.320]                       }
[16:04:48.320]                     })
[16:04:48.320]                   }
[16:04:48.320]                   options(future.plan = NULL)
[16:04:48.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.320]                 }
[16:04:48.320]                 ...future.workdir <- getwd()
[16:04:48.320]             }
[16:04:48.320]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.320]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.320]         }
[16:04:48.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.320]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.320]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.320]             base::names(...future.oldOptions))
[16:04:48.320]     }
[16:04:48.320]     if (FALSE) {
[16:04:48.320]     }
[16:04:48.320]     else {
[16:04:48.320]         if (TRUE) {
[16:04:48.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.320]                 open = "w")
[16:04:48.320]         }
[16:04:48.320]         else {
[16:04:48.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.320]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.320]         }
[16:04:48.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.320]             base::sink(type = "output", split = FALSE)
[16:04:48.320]             base::close(...future.stdout)
[16:04:48.320]         }, add = TRUE)
[16:04:48.320]     }
[16:04:48.320]     ...future.frame <- base::sys.nframe()
[16:04:48.320]     ...future.conditions <- base::list()
[16:04:48.320]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.320]     if (FALSE) {
[16:04:48.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.320]     }
[16:04:48.320]     ...future.result <- base::tryCatch({
[16:04:48.320]         base::withCallingHandlers({
[16:04:48.320]             ...future.value <- base::withVisible(base::local({
[16:04:48.320]                 lm(weight ~ group - 1)
[16:04:48.320]             }))
[16:04:48.320]             future::FutureResult(value = ...future.value$value, 
[16:04:48.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.320]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.320]                     ...future.globalenv.names))
[16:04:48.320]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.320]         }, condition = base::local({
[16:04:48.320]             c <- base::c
[16:04:48.320]             inherits <- base::inherits
[16:04:48.320]             invokeRestart <- base::invokeRestart
[16:04:48.320]             length <- base::length
[16:04:48.320]             list <- base::list
[16:04:48.320]             seq.int <- base::seq.int
[16:04:48.320]             signalCondition <- base::signalCondition
[16:04:48.320]             sys.calls <- base::sys.calls
[16:04:48.320]             `[[` <- base::`[[`
[16:04:48.320]             `+` <- base::`+`
[16:04:48.320]             `<<-` <- base::`<<-`
[16:04:48.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.320]                   3L)]
[16:04:48.320]             }
[16:04:48.320]             function(cond) {
[16:04:48.320]                 is_error <- inherits(cond, "error")
[16:04:48.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.320]                   NULL)
[16:04:48.320]                 if (is_error) {
[16:04:48.320]                   sessionInformation <- function() {
[16:04:48.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.320]                       search = base::search(), system = base::Sys.info())
[16:04:48.320]                   }
[16:04:48.320]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.320]                     cond$call), session = sessionInformation(), 
[16:04:48.320]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.320]                   signalCondition(cond)
[16:04:48.320]                 }
[16:04:48.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.320]                 "immediateCondition"))) {
[16:04:48.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.320]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.320]                   if (TRUE && !signal) {
[16:04:48.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.320]                     {
[16:04:48.320]                       inherits <- base::inherits
[16:04:48.320]                       invokeRestart <- base::invokeRestart
[16:04:48.320]                       is.null <- base::is.null
[16:04:48.320]                       muffled <- FALSE
[16:04:48.320]                       if (inherits(cond, "message")) {
[16:04:48.320]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.320]                         if (muffled) 
[16:04:48.320]                           invokeRestart("muffleMessage")
[16:04:48.320]                       }
[16:04:48.320]                       else if (inherits(cond, "warning")) {
[16:04:48.320]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.320]                         if (muffled) 
[16:04:48.320]                           invokeRestart("muffleWarning")
[16:04:48.320]                       }
[16:04:48.320]                       else if (inherits(cond, "condition")) {
[16:04:48.320]                         if (!is.null(pattern)) {
[16:04:48.320]                           computeRestarts <- base::computeRestarts
[16:04:48.320]                           grepl <- base::grepl
[16:04:48.320]                           restarts <- computeRestarts(cond)
[16:04:48.320]                           for (restart in restarts) {
[16:04:48.320]                             name <- restart$name
[16:04:48.320]                             if (is.null(name)) 
[16:04:48.320]                               next
[16:04:48.320]                             if (!grepl(pattern, name)) 
[16:04:48.320]                               next
[16:04:48.320]                             invokeRestart(restart)
[16:04:48.320]                             muffled <- TRUE
[16:04:48.320]                             break
[16:04:48.320]                           }
[16:04:48.320]                         }
[16:04:48.320]                       }
[16:04:48.320]                       invisible(muffled)
[16:04:48.320]                     }
[16:04:48.320]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.320]                   }
[16:04:48.320]                 }
[16:04:48.320]                 else {
[16:04:48.320]                   if (TRUE) {
[16:04:48.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.320]                     {
[16:04:48.320]                       inherits <- base::inherits
[16:04:48.320]                       invokeRestart <- base::invokeRestart
[16:04:48.320]                       is.null <- base::is.null
[16:04:48.320]                       muffled <- FALSE
[16:04:48.320]                       if (inherits(cond, "message")) {
[16:04:48.320]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.320]                         if (muffled) 
[16:04:48.320]                           invokeRestart("muffleMessage")
[16:04:48.320]                       }
[16:04:48.320]                       else if (inherits(cond, "warning")) {
[16:04:48.320]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.320]                         if (muffled) 
[16:04:48.320]                           invokeRestart("muffleWarning")
[16:04:48.320]                       }
[16:04:48.320]                       else if (inherits(cond, "condition")) {
[16:04:48.320]                         if (!is.null(pattern)) {
[16:04:48.320]                           computeRestarts <- base::computeRestarts
[16:04:48.320]                           grepl <- base::grepl
[16:04:48.320]                           restarts <- computeRestarts(cond)
[16:04:48.320]                           for (restart in restarts) {
[16:04:48.320]                             name <- restart$name
[16:04:48.320]                             if (is.null(name)) 
[16:04:48.320]                               next
[16:04:48.320]                             if (!grepl(pattern, name)) 
[16:04:48.320]                               next
[16:04:48.320]                             invokeRestart(restart)
[16:04:48.320]                             muffled <- TRUE
[16:04:48.320]                             break
[16:04:48.320]                           }
[16:04:48.320]                         }
[16:04:48.320]                       }
[16:04:48.320]                       invisible(muffled)
[16:04:48.320]                     }
[16:04:48.320]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.320]                   }
[16:04:48.320]                 }
[16:04:48.320]             }
[16:04:48.320]         }))
[16:04:48.320]     }, error = function(ex) {
[16:04:48.320]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.320]                 ...future.rng), started = ...future.startTime, 
[16:04:48.320]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.320]             version = "1.8"), class = "FutureResult")
[16:04:48.320]     }, finally = {
[16:04:48.320]         if (!identical(...future.workdir, getwd())) 
[16:04:48.320]             setwd(...future.workdir)
[16:04:48.320]         {
[16:04:48.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.320]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.320]             }
[16:04:48.320]             base::options(...future.oldOptions)
[16:04:48.320]             if (.Platform$OS.type == "windows") {
[16:04:48.320]                 old_names <- names(...future.oldEnvVars)
[16:04:48.320]                 envs <- base::Sys.getenv()
[16:04:48.320]                 names <- names(envs)
[16:04:48.320]                 common <- intersect(names, old_names)
[16:04:48.320]                 added <- setdiff(names, old_names)
[16:04:48.320]                 removed <- setdiff(old_names, names)
[16:04:48.320]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.320]                   envs[common]]
[16:04:48.320]                 NAMES <- toupper(changed)
[16:04:48.320]                 args <- list()
[16:04:48.320]                 for (kk in seq_along(NAMES)) {
[16:04:48.320]                   name <- changed[[kk]]
[16:04:48.320]                   NAME <- NAMES[[kk]]
[16:04:48.320]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.320]                     next
[16:04:48.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.320]                 }
[16:04:48.320]                 NAMES <- toupper(added)
[16:04:48.320]                 for (kk in seq_along(NAMES)) {
[16:04:48.320]                   name <- added[[kk]]
[16:04:48.320]                   NAME <- NAMES[[kk]]
[16:04:48.320]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.320]                     next
[16:04:48.320]                   args[[name]] <- ""
[16:04:48.320]                 }
[16:04:48.320]                 NAMES <- toupper(removed)
[16:04:48.320]                 for (kk in seq_along(NAMES)) {
[16:04:48.320]                   name <- removed[[kk]]
[16:04:48.320]                   NAME <- NAMES[[kk]]
[16:04:48.320]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.320]                     next
[16:04:48.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.320]                 }
[16:04:48.320]                 if (length(args) > 0) 
[16:04:48.320]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.320]             }
[16:04:48.320]             else {
[16:04:48.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.320]             }
[16:04:48.320]             {
[16:04:48.320]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.320]                   0L) {
[16:04:48.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.320]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.320]                   base::options(opts)
[16:04:48.320]                 }
[16:04:48.320]                 {
[16:04:48.320]                   {
[16:04:48.320]                     NULL
[16:04:48.320]                     RNGkind("Mersenne-Twister")
[16:04:48.320]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.320]                       inherits = FALSE)
[16:04:48.320]                   }
[16:04:48.320]                   options(future.plan = NULL)
[16:04:48.320]                   if (is.na(NA_character_)) 
[16:04:48.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.320]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.320]                   {
[16:04:48.320]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.320]                     if (!future$lazy) 
[16:04:48.320]                       future <- run(future)
[16:04:48.320]                     invisible(future)
[16:04:48.320]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.320]                 }
[16:04:48.320]             }
[16:04:48.320]         }
[16:04:48.320]     })
[16:04:48.320]     if (TRUE) {
[16:04:48.320]         base::sink(type = "output", split = FALSE)
[16:04:48.320]         if (TRUE) {
[16:04:48.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.320]         }
[16:04:48.320]         else {
[16:04:48.320]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.320]         }
[16:04:48.320]         base::close(...future.stdout)
[16:04:48.320]         ...future.stdout <- NULL
[16:04:48.320]     }
[16:04:48.320]     ...future.result$conditions <- ...future.conditions
[16:04:48.320]     ...future.result$finished <- base::Sys.time()
[16:04:48.320]     ...future.result
[16:04:48.320] }
[16:04:48.322] assign_globals() ...
[16:04:48.322] List of 2
[16:04:48.322]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.322]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.322]  - attr(*, "where")=List of 2
[16:04:48.322]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.322]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.322]  - attr(*, "resolved")= logi FALSE
[16:04:48.322]  - attr(*, "total_size")= num 896
[16:04:48.322]  - attr(*, "already-done")= logi TRUE
[16:04:48.325] - copied ‘weight’ to environment
[16:04:48.325] - copied ‘group’ to environment
[16:04:48.325] assign_globals() ... done
[16:04:48.325] plan(): Setting new future strategy stack:
[16:04:48.325] List of future strategies:
[16:04:48.325] 1. sequential:
[16:04:48.325]    - args: function (..., envir = parent.frame())
[16:04:48.325]    - tweaked: FALSE
[16:04:48.325]    - call: NULL
[16:04:48.326] plan(): nbrOfWorkers() = 1
[16:04:48.328] plan(): Setting new future strategy stack:
[16:04:48.328] List of future strategies:
[16:04:48.328] 1. sequential:
[16:04:48.328]    - args: function (..., envir = parent.frame())
[16:04:48.328]    - tweaked: FALSE
[16:04:48.328]    - call: plan(strategy)
[16:04:48.328] plan(): nbrOfWorkers() = 1
[16:04:48.328] SequentialFuture started (and completed)
[16:04:48.329] - Launch lazy future ... done
[16:04:48.329] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.333] getGlobalsAndPackages() ...
[16:04:48.333] Searching for globals...
[16:04:48.334] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.334] Searching for globals ... DONE
[16:04:48.335] Resolving globals: FALSE
[16:04:48.335] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.335] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.336] - globals: [2] ‘weight’, ‘group’
[16:04:48.336] - packages: [1] ‘stats’
[16:04:48.336] getGlobalsAndPackages() ... DONE
[16:04:48.336] run() for ‘Future’ ...
[16:04:48.336] - state: ‘created’
[16:04:48.336] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.336] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.337] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.337]   - Field: ‘label’
[16:04:48.337]   - Field: ‘local’
[16:04:48.337]   - Field: ‘owner’
[16:04:48.337]   - Field: ‘envir’
[16:04:48.337]   - Field: ‘packages’
[16:04:48.337]   - Field: ‘gc’
[16:04:48.337]   - Field: ‘conditions’
[16:04:48.337]   - Field: ‘expr’
[16:04:48.337]   - Field: ‘uuid’
[16:04:48.337]   - Field: ‘seed’
[16:04:48.338]   - Field: ‘version’
[16:04:48.338]   - Field: ‘result’
[16:04:48.338]   - Field: ‘asynchronous’
[16:04:48.338]   - Field: ‘calls’
[16:04:48.338]   - Field: ‘globals’
[16:04:48.338]   - Field: ‘stdout’
[16:04:48.338]   - Field: ‘earlySignal’
[16:04:48.338]   - Field: ‘lazy’
[16:04:48.338]   - Field: ‘state’
[16:04:48.338] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.338] - Launch lazy future ...
[16:04:48.339] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.339] Packages needed by future strategies (n = 0): <none>
[16:04:48.339] {
[16:04:48.339]     {
[16:04:48.339]         {
[16:04:48.339]             ...future.startTime <- base::Sys.time()
[16:04:48.339]             {
[16:04:48.339]                 {
[16:04:48.339]                   {
[16:04:48.339]                     {
[16:04:48.339]                       base::local({
[16:04:48.339]                         has_future <- base::requireNamespace("future", 
[16:04:48.339]                           quietly = TRUE)
[16:04:48.339]                         if (has_future) {
[16:04:48.339]                           ns <- base::getNamespace("future")
[16:04:48.339]                           version <- ns[[".package"]][["version"]]
[16:04:48.339]                           if (is.null(version)) 
[16:04:48.339]                             version <- utils::packageVersion("future")
[16:04:48.339]                         }
[16:04:48.339]                         else {
[16:04:48.339]                           version <- NULL
[16:04:48.339]                         }
[16:04:48.339]                         if (!has_future || version < "1.8.0") {
[16:04:48.339]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.339]                             "", base::R.version$version.string), 
[16:04:48.339]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.339]                               "release", "version")], collapse = " "), 
[16:04:48.339]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.339]                             info)
[16:04:48.339]                           info <- base::paste(info, collapse = "; ")
[16:04:48.339]                           if (!has_future) {
[16:04:48.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.339]                               info)
[16:04:48.339]                           }
[16:04:48.339]                           else {
[16:04:48.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.339]                               info, version)
[16:04:48.339]                           }
[16:04:48.339]                           base::stop(msg)
[16:04:48.339]                         }
[16:04:48.339]                       })
[16:04:48.339]                     }
[16:04:48.339]                     base::local({
[16:04:48.339]                       for (pkg in "stats") {
[16:04:48.339]                         base::loadNamespace(pkg)
[16:04:48.339]                         base::library(pkg, character.only = TRUE)
[16:04:48.339]                       }
[16:04:48.339]                     })
[16:04:48.339]                   }
[16:04:48.339]                   options(future.plan = NULL)
[16:04:48.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.339]                 }
[16:04:48.339]                 ...future.workdir <- getwd()
[16:04:48.339]             }
[16:04:48.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.339]         }
[16:04:48.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.339]             base::names(...future.oldOptions))
[16:04:48.339]     }
[16:04:48.339]     if (FALSE) {
[16:04:48.339]     }
[16:04:48.339]     else {
[16:04:48.339]         if (TRUE) {
[16:04:48.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.339]                 open = "w")
[16:04:48.339]         }
[16:04:48.339]         else {
[16:04:48.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.339]         }
[16:04:48.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.339]             base::sink(type = "output", split = FALSE)
[16:04:48.339]             base::close(...future.stdout)
[16:04:48.339]         }, add = TRUE)
[16:04:48.339]     }
[16:04:48.339]     ...future.frame <- base::sys.nframe()
[16:04:48.339]     ...future.conditions <- base::list()
[16:04:48.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.339]     if (FALSE) {
[16:04:48.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.339]     }
[16:04:48.339]     ...future.result <- base::tryCatch({
[16:04:48.339]         base::withCallingHandlers({
[16:04:48.339]             ...future.value <- base::withVisible(base::local({
[16:04:48.339]                 lm(weight ~ group - 1)
[16:04:48.339]             }))
[16:04:48.339]             future::FutureResult(value = ...future.value$value, 
[16:04:48.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.339]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.339]                     ...future.globalenv.names))
[16:04:48.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.339]         }, condition = base::local({
[16:04:48.339]             c <- base::c
[16:04:48.339]             inherits <- base::inherits
[16:04:48.339]             invokeRestart <- base::invokeRestart
[16:04:48.339]             length <- base::length
[16:04:48.339]             list <- base::list
[16:04:48.339]             seq.int <- base::seq.int
[16:04:48.339]             signalCondition <- base::signalCondition
[16:04:48.339]             sys.calls <- base::sys.calls
[16:04:48.339]             `[[` <- base::`[[`
[16:04:48.339]             `+` <- base::`+`
[16:04:48.339]             `<<-` <- base::`<<-`
[16:04:48.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.339]                   3L)]
[16:04:48.339]             }
[16:04:48.339]             function(cond) {
[16:04:48.339]                 is_error <- inherits(cond, "error")
[16:04:48.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.339]                   NULL)
[16:04:48.339]                 if (is_error) {
[16:04:48.339]                   sessionInformation <- function() {
[16:04:48.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.339]                       search = base::search(), system = base::Sys.info())
[16:04:48.339]                   }
[16:04:48.339]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.339]                     cond$call), session = sessionInformation(), 
[16:04:48.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.339]                   signalCondition(cond)
[16:04:48.339]                 }
[16:04:48.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.339]                 "immediateCondition"))) {
[16:04:48.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.339]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.339]                   if (TRUE && !signal) {
[16:04:48.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.339]                     {
[16:04:48.339]                       inherits <- base::inherits
[16:04:48.339]                       invokeRestart <- base::invokeRestart
[16:04:48.339]                       is.null <- base::is.null
[16:04:48.339]                       muffled <- FALSE
[16:04:48.339]                       if (inherits(cond, "message")) {
[16:04:48.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.339]                         if (muffled) 
[16:04:48.339]                           invokeRestart("muffleMessage")
[16:04:48.339]                       }
[16:04:48.339]                       else if (inherits(cond, "warning")) {
[16:04:48.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.339]                         if (muffled) 
[16:04:48.339]                           invokeRestart("muffleWarning")
[16:04:48.339]                       }
[16:04:48.339]                       else if (inherits(cond, "condition")) {
[16:04:48.339]                         if (!is.null(pattern)) {
[16:04:48.339]                           computeRestarts <- base::computeRestarts
[16:04:48.339]                           grepl <- base::grepl
[16:04:48.339]                           restarts <- computeRestarts(cond)
[16:04:48.339]                           for (restart in restarts) {
[16:04:48.339]                             name <- restart$name
[16:04:48.339]                             if (is.null(name)) 
[16:04:48.339]                               next
[16:04:48.339]                             if (!grepl(pattern, name)) 
[16:04:48.339]                               next
[16:04:48.339]                             invokeRestart(restart)
[16:04:48.339]                             muffled <- TRUE
[16:04:48.339]                             break
[16:04:48.339]                           }
[16:04:48.339]                         }
[16:04:48.339]                       }
[16:04:48.339]                       invisible(muffled)
[16:04:48.339]                     }
[16:04:48.339]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.339]                   }
[16:04:48.339]                 }
[16:04:48.339]                 else {
[16:04:48.339]                   if (TRUE) {
[16:04:48.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.339]                     {
[16:04:48.339]                       inherits <- base::inherits
[16:04:48.339]                       invokeRestart <- base::invokeRestart
[16:04:48.339]                       is.null <- base::is.null
[16:04:48.339]                       muffled <- FALSE
[16:04:48.339]                       if (inherits(cond, "message")) {
[16:04:48.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.339]                         if (muffled) 
[16:04:48.339]                           invokeRestart("muffleMessage")
[16:04:48.339]                       }
[16:04:48.339]                       else if (inherits(cond, "warning")) {
[16:04:48.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.339]                         if (muffled) 
[16:04:48.339]                           invokeRestart("muffleWarning")
[16:04:48.339]                       }
[16:04:48.339]                       else if (inherits(cond, "condition")) {
[16:04:48.339]                         if (!is.null(pattern)) {
[16:04:48.339]                           computeRestarts <- base::computeRestarts
[16:04:48.339]                           grepl <- base::grepl
[16:04:48.339]                           restarts <- computeRestarts(cond)
[16:04:48.339]                           for (restart in restarts) {
[16:04:48.339]                             name <- restart$name
[16:04:48.339]                             if (is.null(name)) 
[16:04:48.339]                               next
[16:04:48.339]                             if (!grepl(pattern, name)) 
[16:04:48.339]                               next
[16:04:48.339]                             invokeRestart(restart)
[16:04:48.339]                             muffled <- TRUE
[16:04:48.339]                             break
[16:04:48.339]                           }
[16:04:48.339]                         }
[16:04:48.339]                       }
[16:04:48.339]                       invisible(muffled)
[16:04:48.339]                     }
[16:04:48.339]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.339]                   }
[16:04:48.339]                 }
[16:04:48.339]             }
[16:04:48.339]         }))
[16:04:48.339]     }, error = function(ex) {
[16:04:48.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.339]                 ...future.rng), started = ...future.startTime, 
[16:04:48.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.339]             version = "1.8"), class = "FutureResult")
[16:04:48.339]     }, finally = {
[16:04:48.339]         if (!identical(...future.workdir, getwd())) 
[16:04:48.339]             setwd(...future.workdir)
[16:04:48.339]         {
[16:04:48.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.339]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.339]             }
[16:04:48.339]             base::options(...future.oldOptions)
[16:04:48.339]             if (.Platform$OS.type == "windows") {
[16:04:48.339]                 old_names <- names(...future.oldEnvVars)
[16:04:48.339]                 envs <- base::Sys.getenv()
[16:04:48.339]                 names <- names(envs)
[16:04:48.339]                 common <- intersect(names, old_names)
[16:04:48.339]                 added <- setdiff(names, old_names)
[16:04:48.339]                 removed <- setdiff(old_names, names)
[16:04:48.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.339]                   envs[common]]
[16:04:48.339]                 NAMES <- toupper(changed)
[16:04:48.339]                 args <- list()
[16:04:48.339]                 for (kk in seq_along(NAMES)) {
[16:04:48.339]                   name <- changed[[kk]]
[16:04:48.339]                   NAME <- NAMES[[kk]]
[16:04:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.339]                     next
[16:04:48.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.339]                 }
[16:04:48.339]                 NAMES <- toupper(added)
[16:04:48.339]                 for (kk in seq_along(NAMES)) {
[16:04:48.339]                   name <- added[[kk]]
[16:04:48.339]                   NAME <- NAMES[[kk]]
[16:04:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.339]                     next
[16:04:48.339]                   args[[name]] <- ""
[16:04:48.339]                 }
[16:04:48.339]                 NAMES <- toupper(removed)
[16:04:48.339]                 for (kk in seq_along(NAMES)) {
[16:04:48.339]                   name <- removed[[kk]]
[16:04:48.339]                   NAME <- NAMES[[kk]]
[16:04:48.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.339]                     next
[16:04:48.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.339]                 }
[16:04:48.339]                 if (length(args) > 0) 
[16:04:48.339]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.339]             }
[16:04:48.339]             else {
[16:04:48.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.339]             }
[16:04:48.339]             {
[16:04:48.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.339]                   0L) {
[16:04:48.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.339]                   base::options(opts)
[16:04:48.339]                 }
[16:04:48.339]                 {
[16:04:48.339]                   {
[16:04:48.339]                     NULL
[16:04:48.339]                     RNGkind("Mersenne-Twister")
[16:04:48.339]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.339]                       inherits = FALSE)
[16:04:48.339]                   }
[16:04:48.339]                   options(future.plan = NULL)
[16:04:48.339]                   if (is.na(NA_character_)) 
[16:04:48.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.339]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.339]                   {
[16:04:48.339]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.339]                     if (!future$lazy) 
[16:04:48.339]                       future <- run(future)
[16:04:48.339]                     invisible(future)
[16:04:48.339]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.339]                 }
[16:04:48.339]             }
[16:04:48.339]         }
[16:04:48.339]     })
[16:04:48.339]     if (TRUE) {
[16:04:48.339]         base::sink(type = "output", split = FALSE)
[16:04:48.339]         if (TRUE) {
[16:04:48.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.339]         }
[16:04:48.339]         else {
[16:04:48.339]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.339]         }
[16:04:48.339]         base::close(...future.stdout)
[16:04:48.339]         ...future.stdout <- NULL
[16:04:48.339]     }
[16:04:48.339]     ...future.result$conditions <- ...future.conditions
[16:04:48.339]     ...future.result$finished <- base::Sys.time()
[16:04:48.339]     ...future.result
[16:04:48.339] }
[16:04:48.341] assign_globals() ...
[16:04:48.341] List of 2
[16:04:48.341]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.341]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.341]  - attr(*, "where")=List of 2
[16:04:48.341]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.341]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.341]  - attr(*, "resolved")= logi FALSE
[16:04:48.341]  - attr(*, "total_size")= num 896
[16:04:48.341]  - attr(*, "already-done")= logi TRUE
[16:04:48.344] - copied ‘weight’ to environment
[16:04:48.344] - copied ‘group’ to environment
[16:04:48.344] assign_globals() ... done
[16:04:48.344] plan(): Setting new future strategy stack:
[16:04:48.344] List of future strategies:
[16:04:48.344] 1. sequential:
[16:04:48.344]    - args: function (..., envir = parent.frame())
[16:04:48.344]    - tweaked: FALSE
[16:04:48.344]    - call: NULL
[16:04:48.345] plan(): nbrOfWorkers() = 1
[16:04:48.346] plan(): Setting new future strategy stack:
[16:04:48.346] List of future strategies:
[16:04:48.346] 1. sequential:
[16:04:48.346]    - args: function (..., envir = parent.frame())
[16:04:48.346]    - tweaked: FALSE
[16:04:48.346]    - call: plan(strategy)
[16:04:48.346] plan(): nbrOfWorkers() = 1
[16:04:48.346] SequentialFuture started (and completed)
[16:04:48.347] - Launch lazy future ... done
[16:04:48.347] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.349] getGlobalsAndPackages() ...
[16:04:48.349] Searching for globals...
[16:04:48.350] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.351] Searching for globals ... DONE
[16:04:48.351] Resolving globals: FALSE
[16:04:48.351] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.351] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.352] - globals: [2] ‘weight’, ‘group’
[16:04:48.352] - packages: [1] ‘stats’
[16:04:48.352] getGlobalsAndPackages() ... DONE
[16:04:48.352] run() for ‘Future’ ...
[16:04:48.352] - state: ‘created’
[16:04:48.352] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.353] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.353]   - Field: ‘label’
[16:04:48.353]   - Field: ‘local’
[16:04:48.353]   - Field: ‘owner’
[16:04:48.353]   - Field: ‘envir’
[16:04:48.353]   - Field: ‘packages’
[16:04:48.353]   - Field: ‘gc’
[16:04:48.353]   - Field: ‘conditions’
[16:04:48.353]   - Field: ‘expr’
[16:04:48.354]   - Field: ‘uuid’
[16:04:48.354]   - Field: ‘seed’
[16:04:48.354]   - Field: ‘version’
[16:04:48.354]   - Field: ‘result’
[16:04:48.354]   - Field: ‘asynchronous’
[16:04:48.354]   - Field: ‘calls’
[16:04:48.354]   - Field: ‘globals’
[16:04:48.354]   - Field: ‘stdout’
[16:04:48.354]   - Field: ‘earlySignal’
[16:04:48.354]   - Field: ‘lazy’
[16:04:48.354]   - Field: ‘state’
[16:04:48.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.355] - Launch lazy future ...
[16:04:48.355] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.355] Packages needed by future strategies (n = 0): <none>
[16:04:48.356] {
[16:04:48.356]     {
[16:04:48.356]         {
[16:04:48.356]             ...future.startTime <- base::Sys.time()
[16:04:48.356]             {
[16:04:48.356]                 {
[16:04:48.356]                   {
[16:04:48.356]                     {
[16:04:48.356]                       base::local({
[16:04:48.356]                         has_future <- base::requireNamespace("future", 
[16:04:48.356]                           quietly = TRUE)
[16:04:48.356]                         if (has_future) {
[16:04:48.356]                           ns <- base::getNamespace("future")
[16:04:48.356]                           version <- ns[[".package"]][["version"]]
[16:04:48.356]                           if (is.null(version)) 
[16:04:48.356]                             version <- utils::packageVersion("future")
[16:04:48.356]                         }
[16:04:48.356]                         else {
[16:04:48.356]                           version <- NULL
[16:04:48.356]                         }
[16:04:48.356]                         if (!has_future || version < "1.8.0") {
[16:04:48.356]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.356]                             "", base::R.version$version.string), 
[16:04:48.356]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.356]                               "release", "version")], collapse = " "), 
[16:04:48.356]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.356]                             info)
[16:04:48.356]                           info <- base::paste(info, collapse = "; ")
[16:04:48.356]                           if (!has_future) {
[16:04:48.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.356]                               info)
[16:04:48.356]                           }
[16:04:48.356]                           else {
[16:04:48.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.356]                               info, version)
[16:04:48.356]                           }
[16:04:48.356]                           base::stop(msg)
[16:04:48.356]                         }
[16:04:48.356]                       })
[16:04:48.356]                     }
[16:04:48.356]                     base::local({
[16:04:48.356]                       for (pkg in "stats") {
[16:04:48.356]                         base::loadNamespace(pkg)
[16:04:48.356]                         base::library(pkg, character.only = TRUE)
[16:04:48.356]                       }
[16:04:48.356]                     })
[16:04:48.356]                   }
[16:04:48.356]                   options(future.plan = NULL)
[16:04:48.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.356]                 }
[16:04:48.356]                 ...future.workdir <- getwd()
[16:04:48.356]             }
[16:04:48.356]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.356]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.356]         }
[16:04:48.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.356]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.356]             base::names(...future.oldOptions))
[16:04:48.356]     }
[16:04:48.356]     if (FALSE) {
[16:04:48.356]     }
[16:04:48.356]     else {
[16:04:48.356]         if (TRUE) {
[16:04:48.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.356]                 open = "w")
[16:04:48.356]         }
[16:04:48.356]         else {
[16:04:48.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.356]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.356]         }
[16:04:48.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.356]             base::sink(type = "output", split = FALSE)
[16:04:48.356]             base::close(...future.stdout)
[16:04:48.356]         }, add = TRUE)
[16:04:48.356]     }
[16:04:48.356]     ...future.frame <- base::sys.nframe()
[16:04:48.356]     ...future.conditions <- base::list()
[16:04:48.356]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.356]     if (FALSE) {
[16:04:48.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.356]     }
[16:04:48.356]     ...future.result <- base::tryCatch({
[16:04:48.356]         base::withCallingHandlers({
[16:04:48.356]             ...future.value <- base::withVisible(base::local({
[16:04:48.356]                 lm(weight ~ group - 1)
[16:04:48.356]             }))
[16:04:48.356]             future::FutureResult(value = ...future.value$value, 
[16:04:48.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.356]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.356]                     ...future.globalenv.names))
[16:04:48.356]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.356]         }, condition = base::local({
[16:04:48.356]             c <- base::c
[16:04:48.356]             inherits <- base::inherits
[16:04:48.356]             invokeRestart <- base::invokeRestart
[16:04:48.356]             length <- base::length
[16:04:48.356]             list <- base::list
[16:04:48.356]             seq.int <- base::seq.int
[16:04:48.356]             signalCondition <- base::signalCondition
[16:04:48.356]             sys.calls <- base::sys.calls
[16:04:48.356]             `[[` <- base::`[[`
[16:04:48.356]             `+` <- base::`+`
[16:04:48.356]             `<<-` <- base::`<<-`
[16:04:48.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.356]                   3L)]
[16:04:48.356]             }
[16:04:48.356]             function(cond) {
[16:04:48.356]                 is_error <- inherits(cond, "error")
[16:04:48.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.356]                   NULL)
[16:04:48.356]                 if (is_error) {
[16:04:48.356]                   sessionInformation <- function() {
[16:04:48.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.356]                       search = base::search(), system = base::Sys.info())
[16:04:48.356]                   }
[16:04:48.356]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.356]                     cond$call), session = sessionInformation(), 
[16:04:48.356]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.356]                   signalCondition(cond)
[16:04:48.356]                 }
[16:04:48.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.356]                 "immediateCondition"))) {
[16:04:48.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.356]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.356]                   if (TRUE && !signal) {
[16:04:48.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.356]                     {
[16:04:48.356]                       inherits <- base::inherits
[16:04:48.356]                       invokeRestart <- base::invokeRestart
[16:04:48.356]                       is.null <- base::is.null
[16:04:48.356]                       muffled <- FALSE
[16:04:48.356]                       if (inherits(cond, "message")) {
[16:04:48.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.356]                         if (muffled) 
[16:04:48.356]                           invokeRestart("muffleMessage")
[16:04:48.356]                       }
[16:04:48.356]                       else if (inherits(cond, "warning")) {
[16:04:48.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.356]                         if (muffled) 
[16:04:48.356]                           invokeRestart("muffleWarning")
[16:04:48.356]                       }
[16:04:48.356]                       else if (inherits(cond, "condition")) {
[16:04:48.356]                         if (!is.null(pattern)) {
[16:04:48.356]                           computeRestarts <- base::computeRestarts
[16:04:48.356]                           grepl <- base::grepl
[16:04:48.356]                           restarts <- computeRestarts(cond)
[16:04:48.356]                           for (restart in restarts) {
[16:04:48.356]                             name <- restart$name
[16:04:48.356]                             if (is.null(name)) 
[16:04:48.356]                               next
[16:04:48.356]                             if (!grepl(pattern, name)) 
[16:04:48.356]                               next
[16:04:48.356]                             invokeRestart(restart)
[16:04:48.356]                             muffled <- TRUE
[16:04:48.356]                             break
[16:04:48.356]                           }
[16:04:48.356]                         }
[16:04:48.356]                       }
[16:04:48.356]                       invisible(muffled)
[16:04:48.356]                     }
[16:04:48.356]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.356]                   }
[16:04:48.356]                 }
[16:04:48.356]                 else {
[16:04:48.356]                   if (TRUE) {
[16:04:48.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.356]                     {
[16:04:48.356]                       inherits <- base::inherits
[16:04:48.356]                       invokeRestart <- base::invokeRestart
[16:04:48.356]                       is.null <- base::is.null
[16:04:48.356]                       muffled <- FALSE
[16:04:48.356]                       if (inherits(cond, "message")) {
[16:04:48.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.356]                         if (muffled) 
[16:04:48.356]                           invokeRestart("muffleMessage")
[16:04:48.356]                       }
[16:04:48.356]                       else if (inherits(cond, "warning")) {
[16:04:48.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.356]                         if (muffled) 
[16:04:48.356]                           invokeRestart("muffleWarning")
[16:04:48.356]                       }
[16:04:48.356]                       else if (inherits(cond, "condition")) {
[16:04:48.356]                         if (!is.null(pattern)) {
[16:04:48.356]                           computeRestarts <- base::computeRestarts
[16:04:48.356]                           grepl <- base::grepl
[16:04:48.356]                           restarts <- computeRestarts(cond)
[16:04:48.356]                           for (restart in restarts) {
[16:04:48.356]                             name <- restart$name
[16:04:48.356]                             if (is.null(name)) 
[16:04:48.356]                               next
[16:04:48.356]                             if (!grepl(pattern, name)) 
[16:04:48.356]                               next
[16:04:48.356]                             invokeRestart(restart)
[16:04:48.356]                             muffled <- TRUE
[16:04:48.356]                             break
[16:04:48.356]                           }
[16:04:48.356]                         }
[16:04:48.356]                       }
[16:04:48.356]                       invisible(muffled)
[16:04:48.356]                     }
[16:04:48.356]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.356]                   }
[16:04:48.356]                 }
[16:04:48.356]             }
[16:04:48.356]         }))
[16:04:48.356]     }, error = function(ex) {
[16:04:48.356]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.356]                 ...future.rng), started = ...future.startTime, 
[16:04:48.356]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.356]             version = "1.8"), class = "FutureResult")
[16:04:48.356]     }, finally = {
[16:04:48.356]         if (!identical(...future.workdir, getwd())) 
[16:04:48.356]             setwd(...future.workdir)
[16:04:48.356]         {
[16:04:48.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.356]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.356]             }
[16:04:48.356]             base::options(...future.oldOptions)
[16:04:48.356]             if (.Platform$OS.type == "windows") {
[16:04:48.356]                 old_names <- names(...future.oldEnvVars)
[16:04:48.356]                 envs <- base::Sys.getenv()
[16:04:48.356]                 names <- names(envs)
[16:04:48.356]                 common <- intersect(names, old_names)
[16:04:48.356]                 added <- setdiff(names, old_names)
[16:04:48.356]                 removed <- setdiff(old_names, names)
[16:04:48.356]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.356]                   envs[common]]
[16:04:48.356]                 NAMES <- toupper(changed)
[16:04:48.356]                 args <- list()
[16:04:48.356]                 for (kk in seq_along(NAMES)) {
[16:04:48.356]                   name <- changed[[kk]]
[16:04:48.356]                   NAME <- NAMES[[kk]]
[16:04:48.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.356]                     next
[16:04:48.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.356]                 }
[16:04:48.356]                 NAMES <- toupper(added)
[16:04:48.356]                 for (kk in seq_along(NAMES)) {
[16:04:48.356]                   name <- added[[kk]]
[16:04:48.356]                   NAME <- NAMES[[kk]]
[16:04:48.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.356]                     next
[16:04:48.356]                   args[[name]] <- ""
[16:04:48.356]                 }
[16:04:48.356]                 NAMES <- toupper(removed)
[16:04:48.356]                 for (kk in seq_along(NAMES)) {
[16:04:48.356]                   name <- removed[[kk]]
[16:04:48.356]                   NAME <- NAMES[[kk]]
[16:04:48.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.356]                     next
[16:04:48.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.356]                 }
[16:04:48.356]                 if (length(args) > 0) 
[16:04:48.356]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.356]             }
[16:04:48.356]             else {
[16:04:48.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.356]             }
[16:04:48.356]             {
[16:04:48.356]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.356]                   0L) {
[16:04:48.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.356]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.356]                   base::options(opts)
[16:04:48.356]                 }
[16:04:48.356]                 {
[16:04:48.356]                   {
[16:04:48.356]                     NULL
[16:04:48.356]                     RNGkind("Mersenne-Twister")
[16:04:48.356]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.356]                       inherits = FALSE)
[16:04:48.356]                   }
[16:04:48.356]                   options(future.plan = NULL)
[16:04:48.356]                   if (is.na(NA_character_)) 
[16:04:48.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.356]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.356]                   {
[16:04:48.356]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.356]                     if (!future$lazy) 
[16:04:48.356]                       future <- run(future)
[16:04:48.356]                     invisible(future)
[16:04:48.356]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.356]                 }
[16:04:48.356]             }
[16:04:48.356]         }
[16:04:48.356]     })
[16:04:48.356]     if (TRUE) {
[16:04:48.356]         base::sink(type = "output", split = FALSE)
[16:04:48.356]         if (TRUE) {
[16:04:48.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.356]         }
[16:04:48.356]         else {
[16:04:48.356]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.356]         }
[16:04:48.356]         base::close(...future.stdout)
[16:04:48.356]         ...future.stdout <- NULL
[16:04:48.356]     }
[16:04:48.356]     ...future.result$conditions <- ...future.conditions
[16:04:48.356]     ...future.result$finished <- base::Sys.time()
[16:04:48.356]     ...future.result
[16:04:48.356] }
[16:04:48.358] assign_globals() ...
[16:04:48.358] List of 2
[16:04:48.358]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.358]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.358]  - attr(*, "where")=List of 2
[16:04:48.358]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.358]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.358]  - attr(*, "resolved")= logi FALSE
[16:04:48.358]  - attr(*, "total_size")= num 896
[16:04:48.358]  - attr(*, "already-done")= logi TRUE
[16:04:48.361] - copied ‘weight’ to environment
[16:04:48.361] - copied ‘group’ to environment
[16:04:48.361] assign_globals() ... done
[16:04:48.361] plan(): Setting new future strategy stack:
[16:04:48.361] List of future strategies:
[16:04:48.361] 1. sequential:
[16:04:48.361]    - args: function (..., envir = parent.frame())
[16:04:48.361]    - tweaked: FALSE
[16:04:48.361]    - call: NULL
[16:04:48.362] plan(): nbrOfWorkers() = 1
[16:04:48.363] plan(): Setting new future strategy stack:
[16:04:48.363] List of future strategies:
[16:04:48.363] 1. sequential:
[16:04:48.363]    - args: function (..., envir = parent.frame())
[16:04:48.363]    - tweaked: FALSE
[16:04:48.363]    - call: plan(strategy)
[16:04:48.363] plan(): nbrOfWorkers() = 1
[16:04:48.364] SequentialFuture started (and completed)
[16:04:48.364] - Launch lazy future ... done
[16:04:48.364] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.365] getGlobalsAndPackages() ...
[16:04:48.366] Searching for globals...
[16:04:48.367] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.367] Searching for globals ... DONE
[16:04:48.367] Resolving globals: FALSE
[16:04:48.367] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.368] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.368] - globals: [2] ‘weight’, ‘group’
[16:04:48.368] - packages: [1] ‘stats’
[16:04:48.368] getGlobalsAndPackages() ... DONE
[16:04:48.368] run() for ‘Future’ ...
[16:04:48.368] - state: ‘created’
[16:04:48.369] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.369] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.369] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.369]   - Field: ‘label’
[16:04:48.369]   - Field: ‘local’
[16:04:48.369]   - Field: ‘owner’
[16:04:48.369]   - Field: ‘envir’
[16:04:48.369]   - Field: ‘packages’
[16:04:48.369]   - Field: ‘gc’
[16:04:48.370]   - Field: ‘conditions’
[16:04:48.370]   - Field: ‘expr’
[16:04:48.370]   - Field: ‘uuid’
[16:04:48.370]   - Field: ‘seed’
[16:04:48.370]   - Field: ‘version’
[16:04:48.370]   - Field: ‘result’
[16:04:48.370]   - Field: ‘asynchronous’
[16:04:48.370]   - Field: ‘calls’
[16:04:48.370]   - Field: ‘globals’
[16:04:48.370]   - Field: ‘stdout’
[16:04:48.370]   - Field: ‘earlySignal’
[16:04:48.370]   - Field: ‘lazy’
[16:04:48.371]   - Field: ‘state’
[16:04:48.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.371] - Launch lazy future ...
[16:04:48.371] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.371] Packages needed by future strategies (n = 0): <none>
[16:04:48.371] {
[16:04:48.371]     {
[16:04:48.371]         {
[16:04:48.371]             ...future.startTime <- base::Sys.time()
[16:04:48.371]             {
[16:04:48.371]                 {
[16:04:48.371]                   {
[16:04:48.371]                     {
[16:04:48.371]                       base::local({
[16:04:48.371]                         has_future <- base::requireNamespace("future", 
[16:04:48.371]                           quietly = TRUE)
[16:04:48.371]                         if (has_future) {
[16:04:48.371]                           ns <- base::getNamespace("future")
[16:04:48.371]                           version <- ns[[".package"]][["version"]]
[16:04:48.371]                           if (is.null(version)) 
[16:04:48.371]                             version <- utils::packageVersion("future")
[16:04:48.371]                         }
[16:04:48.371]                         else {
[16:04:48.371]                           version <- NULL
[16:04:48.371]                         }
[16:04:48.371]                         if (!has_future || version < "1.8.0") {
[16:04:48.371]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.371]                             "", base::R.version$version.string), 
[16:04:48.371]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.371]                               "release", "version")], collapse = " "), 
[16:04:48.371]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.371]                             info)
[16:04:48.371]                           info <- base::paste(info, collapse = "; ")
[16:04:48.371]                           if (!has_future) {
[16:04:48.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.371]                               info)
[16:04:48.371]                           }
[16:04:48.371]                           else {
[16:04:48.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.371]                               info, version)
[16:04:48.371]                           }
[16:04:48.371]                           base::stop(msg)
[16:04:48.371]                         }
[16:04:48.371]                       })
[16:04:48.371]                     }
[16:04:48.371]                     base::local({
[16:04:48.371]                       for (pkg in "stats") {
[16:04:48.371]                         base::loadNamespace(pkg)
[16:04:48.371]                         base::library(pkg, character.only = TRUE)
[16:04:48.371]                       }
[16:04:48.371]                     })
[16:04:48.371]                   }
[16:04:48.371]                   options(future.plan = NULL)
[16:04:48.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.371]                 }
[16:04:48.371]                 ...future.workdir <- getwd()
[16:04:48.371]             }
[16:04:48.371]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.371]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.371]         }
[16:04:48.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.371]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.371]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.371]             base::names(...future.oldOptions))
[16:04:48.371]     }
[16:04:48.371]     if (FALSE) {
[16:04:48.371]     }
[16:04:48.371]     else {
[16:04:48.371]         if (TRUE) {
[16:04:48.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.371]                 open = "w")
[16:04:48.371]         }
[16:04:48.371]         else {
[16:04:48.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.371]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.371]         }
[16:04:48.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.371]             base::sink(type = "output", split = FALSE)
[16:04:48.371]             base::close(...future.stdout)
[16:04:48.371]         }, add = TRUE)
[16:04:48.371]     }
[16:04:48.371]     ...future.frame <- base::sys.nframe()
[16:04:48.371]     ...future.conditions <- base::list()
[16:04:48.371]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.371]     if (FALSE) {
[16:04:48.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.371]     }
[16:04:48.371]     ...future.result <- base::tryCatch({
[16:04:48.371]         base::withCallingHandlers({
[16:04:48.371]             ...future.value <- base::withVisible(base::local({
[16:04:48.371]                 lm(weight ~ group - 1)
[16:04:48.371]             }))
[16:04:48.371]             future::FutureResult(value = ...future.value$value, 
[16:04:48.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.371]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.371]                     ...future.globalenv.names))
[16:04:48.371]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.371]         }, condition = base::local({
[16:04:48.371]             c <- base::c
[16:04:48.371]             inherits <- base::inherits
[16:04:48.371]             invokeRestart <- base::invokeRestart
[16:04:48.371]             length <- base::length
[16:04:48.371]             list <- base::list
[16:04:48.371]             seq.int <- base::seq.int
[16:04:48.371]             signalCondition <- base::signalCondition
[16:04:48.371]             sys.calls <- base::sys.calls
[16:04:48.371]             `[[` <- base::`[[`
[16:04:48.371]             `+` <- base::`+`
[16:04:48.371]             `<<-` <- base::`<<-`
[16:04:48.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.371]                   3L)]
[16:04:48.371]             }
[16:04:48.371]             function(cond) {
[16:04:48.371]                 is_error <- inherits(cond, "error")
[16:04:48.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.371]                   NULL)
[16:04:48.371]                 if (is_error) {
[16:04:48.371]                   sessionInformation <- function() {
[16:04:48.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.371]                       search = base::search(), system = base::Sys.info())
[16:04:48.371]                   }
[16:04:48.371]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.371]                     cond$call), session = sessionInformation(), 
[16:04:48.371]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.371]                   signalCondition(cond)
[16:04:48.371]                 }
[16:04:48.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.371]                 "immediateCondition"))) {
[16:04:48.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.371]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.371]                   if (TRUE && !signal) {
[16:04:48.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.371]                     {
[16:04:48.371]                       inherits <- base::inherits
[16:04:48.371]                       invokeRestart <- base::invokeRestart
[16:04:48.371]                       is.null <- base::is.null
[16:04:48.371]                       muffled <- FALSE
[16:04:48.371]                       if (inherits(cond, "message")) {
[16:04:48.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.371]                         if (muffled) 
[16:04:48.371]                           invokeRestart("muffleMessage")
[16:04:48.371]                       }
[16:04:48.371]                       else if (inherits(cond, "warning")) {
[16:04:48.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.371]                         if (muffled) 
[16:04:48.371]                           invokeRestart("muffleWarning")
[16:04:48.371]                       }
[16:04:48.371]                       else if (inherits(cond, "condition")) {
[16:04:48.371]                         if (!is.null(pattern)) {
[16:04:48.371]                           computeRestarts <- base::computeRestarts
[16:04:48.371]                           grepl <- base::grepl
[16:04:48.371]                           restarts <- computeRestarts(cond)
[16:04:48.371]                           for (restart in restarts) {
[16:04:48.371]                             name <- restart$name
[16:04:48.371]                             if (is.null(name)) 
[16:04:48.371]                               next
[16:04:48.371]                             if (!grepl(pattern, name)) 
[16:04:48.371]                               next
[16:04:48.371]                             invokeRestart(restart)
[16:04:48.371]                             muffled <- TRUE
[16:04:48.371]                             break
[16:04:48.371]                           }
[16:04:48.371]                         }
[16:04:48.371]                       }
[16:04:48.371]                       invisible(muffled)
[16:04:48.371]                     }
[16:04:48.371]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.371]                   }
[16:04:48.371]                 }
[16:04:48.371]                 else {
[16:04:48.371]                   if (TRUE) {
[16:04:48.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.371]                     {
[16:04:48.371]                       inherits <- base::inherits
[16:04:48.371]                       invokeRestart <- base::invokeRestart
[16:04:48.371]                       is.null <- base::is.null
[16:04:48.371]                       muffled <- FALSE
[16:04:48.371]                       if (inherits(cond, "message")) {
[16:04:48.371]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.371]                         if (muffled) 
[16:04:48.371]                           invokeRestart("muffleMessage")
[16:04:48.371]                       }
[16:04:48.371]                       else if (inherits(cond, "warning")) {
[16:04:48.371]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.371]                         if (muffled) 
[16:04:48.371]                           invokeRestart("muffleWarning")
[16:04:48.371]                       }
[16:04:48.371]                       else if (inherits(cond, "condition")) {
[16:04:48.371]                         if (!is.null(pattern)) {
[16:04:48.371]                           computeRestarts <- base::computeRestarts
[16:04:48.371]                           grepl <- base::grepl
[16:04:48.371]                           restarts <- computeRestarts(cond)
[16:04:48.371]                           for (restart in restarts) {
[16:04:48.371]                             name <- restart$name
[16:04:48.371]                             if (is.null(name)) 
[16:04:48.371]                               next
[16:04:48.371]                             if (!grepl(pattern, name)) 
[16:04:48.371]                               next
[16:04:48.371]                             invokeRestart(restart)
[16:04:48.371]                             muffled <- TRUE
[16:04:48.371]                             break
[16:04:48.371]                           }
[16:04:48.371]                         }
[16:04:48.371]                       }
[16:04:48.371]                       invisible(muffled)
[16:04:48.371]                     }
[16:04:48.371]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.371]                   }
[16:04:48.371]                 }
[16:04:48.371]             }
[16:04:48.371]         }))
[16:04:48.371]     }, error = function(ex) {
[16:04:48.371]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.371]                 ...future.rng), started = ...future.startTime, 
[16:04:48.371]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.371]             version = "1.8"), class = "FutureResult")
[16:04:48.371]     }, finally = {
[16:04:48.371]         if (!identical(...future.workdir, getwd())) 
[16:04:48.371]             setwd(...future.workdir)
[16:04:48.371]         {
[16:04:48.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.371]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.371]             }
[16:04:48.371]             base::options(...future.oldOptions)
[16:04:48.371]             if (.Platform$OS.type == "windows") {
[16:04:48.371]                 old_names <- names(...future.oldEnvVars)
[16:04:48.371]                 envs <- base::Sys.getenv()
[16:04:48.371]                 names <- names(envs)
[16:04:48.371]                 common <- intersect(names, old_names)
[16:04:48.371]                 added <- setdiff(names, old_names)
[16:04:48.371]                 removed <- setdiff(old_names, names)
[16:04:48.371]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.371]                   envs[common]]
[16:04:48.371]                 NAMES <- toupper(changed)
[16:04:48.371]                 args <- list()
[16:04:48.371]                 for (kk in seq_along(NAMES)) {
[16:04:48.371]                   name <- changed[[kk]]
[16:04:48.371]                   NAME <- NAMES[[kk]]
[16:04:48.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.371]                     next
[16:04:48.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.371]                 }
[16:04:48.371]                 NAMES <- toupper(added)
[16:04:48.371]                 for (kk in seq_along(NAMES)) {
[16:04:48.371]                   name <- added[[kk]]
[16:04:48.371]                   NAME <- NAMES[[kk]]
[16:04:48.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.371]                     next
[16:04:48.371]                   args[[name]] <- ""
[16:04:48.371]                 }
[16:04:48.371]                 NAMES <- toupper(removed)
[16:04:48.371]                 for (kk in seq_along(NAMES)) {
[16:04:48.371]                   name <- removed[[kk]]
[16:04:48.371]                   NAME <- NAMES[[kk]]
[16:04:48.371]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.371]                     next
[16:04:48.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.371]                 }
[16:04:48.371]                 if (length(args) > 0) 
[16:04:48.371]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.371]             }
[16:04:48.371]             else {
[16:04:48.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.371]             }
[16:04:48.371]             {
[16:04:48.371]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.371]                   0L) {
[16:04:48.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.371]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.371]                   base::options(opts)
[16:04:48.371]                 }
[16:04:48.371]                 {
[16:04:48.371]                   {
[16:04:48.371]                     NULL
[16:04:48.371]                     RNGkind("Mersenne-Twister")
[16:04:48.371]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.371]                       inherits = FALSE)
[16:04:48.371]                   }
[16:04:48.371]                   options(future.plan = NULL)
[16:04:48.371]                   if (is.na(NA_character_)) 
[16:04:48.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.371]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.371]                   {
[16:04:48.371]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.371]                     if (!future$lazy) 
[16:04:48.371]                       future <- run(future)
[16:04:48.371]                     invisible(future)
[16:04:48.371]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.371]                 }
[16:04:48.371]             }
[16:04:48.371]         }
[16:04:48.371]     })
[16:04:48.371]     if (TRUE) {
[16:04:48.371]         base::sink(type = "output", split = FALSE)
[16:04:48.371]         if (TRUE) {
[16:04:48.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.371]         }
[16:04:48.371]         else {
[16:04:48.371]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.371]         }
[16:04:48.371]         base::close(...future.stdout)
[16:04:48.371]         ...future.stdout <- NULL
[16:04:48.371]     }
[16:04:48.371]     ...future.result$conditions <- ...future.conditions
[16:04:48.371]     ...future.result$finished <- base::Sys.time()
[16:04:48.371]     ...future.result
[16:04:48.371] }
[16:04:48.373] assign_globals() ...
[16:04:48.373] List of 2
[16:04:48.373]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.373]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.373]  - attr(*, "where")=List of 2
[16:04:48.373]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.373]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.373]  - attr(*, "resolved")= logi FALSE
[16:04:48.373]  - attr(*, "total_size")= num 896
[16:04:48.373]  - attr(*, "already-done")= logi TRUE
[16:04:48.376] - copied ‘weight’ to environment
[16:04:48.376] - copied ‘group’ to environment
[16:04:48.376] assign_globals() ... done
[16:04:48.377] plan(): Setting new future strategy stack:
[16:04:48.377] List of future strategies:
[16:04:48.377] 1. sequential:
[16:04:48.377]    - args: function (..., envir = parent.frame())
[16:04:48.377]    - tweaked: FALSE
[16:04:48.377]    - call: NULL
[16:04:48.377] plan(): nbrOfWorkers() = 1
[16:04:48.378] plan(): Setting new future strategy stack:
[16:04:48.378] List of future strategies:
[16:04:48.378] 1. sequential:
[16:04:48.378]    - args: function (..., envir = parent.frame())
[16:04:48.378]    - tweaked: FALSE
[16:04:48.378]    - call: plan(strategy)
[16:04:48.379] plan(): nbrOfWorkers() = 1
[16:04:48.379] SequentialFuture started (and completed)
[16:04:48.379] - Launch lazy future ... done
[16:04:48.379] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.381] getGlobalsAndPackages() ...
[16:04:48.382] Searching for globals...
[16:04:48.383] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.383] Searching for globals ... DONE
[16:04:48.383] Resolving globals: FALSE
[16:04:48.384] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.384] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.384] - globals: [2] ‘weight’, ‘group’
[16:04:48.384] - packages: [1] ‘stats’
[16:04:48.384] getGlobalsAndPackages() ... DONE
[16:04:48.384] run() for ‘Future’ ...
[16:04:48.385] - state: ‘created’
[16:04:48.385] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.385] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.385] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.385]   - Field: ‘label’
[16:04:48.385]   - Field: ‘local’
[16:04:48.385]   - Field: ‘owner’
[16:04:48.385]   - Field: ‘envir’
[16:04:48.386]   - Field: ‘packages’
[16:04:48.386]   - Field: ‘gc’
[16:04:48.386]   - Field: ‘conditions’
[16:04:48.386]   - Field: ‘expr’
[16:04:48.386]   - Field: ‘uuid’
[16:04:48.386]   - Field: ‘seed’
[16:04:48.386]   - Field: ‘version’
[16:04:48.386]   - Field: ‘result’
[16:04:48.386]   - Field: ‘asynchronous’
[16:04:48.386]   - Field: ‘calls’
[16:04:48.386]   - Field: ‘globals’
[16:04:48.386]   - Field: ‘stdout’
[16:04:48.387]   - Field: ‘earlySignal’
[16:04:48.387]   - Field: ‘lazy’
[16:04:48.387]   - Field: ‘state’
[16:04:48.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.387] - Launch lazy future ...
[16:04:48.387] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.387] Packages needed by future strategies (n = 0): <none>
[16:04:48.388] {
[16:04:48.388]     {
[16:04:48.388]         {
[16:04:48.388]             ...future.startTime <- base::Sys.time()
[16:04:48.388]             {
[16:04:48.388]                 {
[16:04:48.388]                   {
[16:04:48.388]                     {
[16:04:48.388]                       base::local({
[16:04:48.388]                         has_future <- base::requireNamespace("future", 
[16:04:48.388]                           quietly = TRUE)
[16:04:48.388]                         if (has_future) {
[16:04:48.388]                           ns <- base::getNamespace("future")
[16:04:48.388]                           version <- ns[[".package"]][["version"]]
[16:04:48.388]                           if (is.null(version)) 
[16:04:48.388]                             version <- utils::packageVersion("future")
[16:04:48.388]                         }
[16:04:48.388]                         else {
[16:04:48.388]                           version <- NULL
[16:04:48.388]                         }
[16:04:48.388]                         if (!has_future || version < "1.8.0") {
[16:04:48.388]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.388]                             "", base::R.version$version.string), 
[16:04:48.388]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.388]                               "release", "version")], collapse = " "), 
[16:04:48.388]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.388]                             info)
[16:04:48.388]                           info <- base::paste(info, collapse = "; ")
[16:04:48.388]                           if (!has_future) {
[16:04:48.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.388]                               info)
[16:04:48.388]                           }
[16:04:48.388]                           else {
[16:04:48.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.388]                               info, version)
[16:04:48.388]                           }
[16:04:48.388]                           base::stop(msg)
[16:04:48.388]                         }
[16:04:48.388]                       })
[16:04:48.388]                     }
[16:04:48.388]                     base::local({
[16:04:48.388]                       for (pkg in "stats") {
[16:04:48.388]                         base::loadNamespace(pkg)
[16:04:48.388]                         base::library(pkg, character.only = TRUE)
[16:04:48.388]                       }
[16:04:48.388]                     })
[16:04:48.388]                   }
[16:04:48.388]                   options(future.plan = NULL)
[16:04:48.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.388]                 }
[16:04:48.388]                 ...future.workdir <- getwd()
[16:04:48.388]             }
[16:04:48.388]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.388]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.388]         }
[16:04:48.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.388]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.388]             base::names(...future.oldOptions))
[16:04:48.388]     }
[16:04:48.388]     if (FALSE) {
[16:04:48.388]     }
[16:04:48.388]     else {
[16:04:48.388]         if (TRUE) {
[16:04:48.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.388]                 open = "w")
[16:04:48.388]         }
[16:04:48.388]         else {
[16:04:48.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.388]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.388]         }
[16:04:48.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.388]             base::sink(type = "output", split = FALSE)
[16:04:48.388]             base::close(...future.stdout)
[16:04:48.388]         }, add = TRUE)
[16:04:48.388]     }
[16:04:48.388]     ...future.frame <- base::sys.nframe()
[16:04:48.388]     ...future.conditions <- base::list()
[16:04:48.388]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.388]     if (FALSE) {
[16:04:48.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.388]     }
[16:04:48.388]     ...future.result <- base::tryCatch({
[16:04:48.388]         base::withCallingHandlers({
[16:04:48.388]             ...future.value <- base::withVisible(base::local({
[16:04:48.388]                 lm(weight ~ group - 1)
[16:04:48.388]             }))
[16:04:48.388]             future::FutureResult(value = ...future.value$value, 
[16:04:48.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.388]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.388]                     ...future.globalenv.names))
[16:04:48.388]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.388]         }, condition = base::local({
[16:04:48.388]             c <- base::c
[16:04:48.388]             inherits <- base::inherits
[16:04:48.388]             invokeRestart <- base::invokeRestart
[16:04:48.388]             length <- base::length
[16:04:48.388]             list <- base::list
[16:04:48.388]             seq.int <- base::seq.int
[16:04:48.388]             signalCondition <- base::signalCondition
[16:04:48.388]             sys.calls <- base::sys.calls
[16:04:48.388]             `[[` <- base::`[[`
[16:04:48.388]             `+` <- base::`+`
[16:04:48.388]             `<<-` <- base::`<<-`
[16:04:48.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.388]                   3L)]
[16:04:48.388]             }
[16:04:48.388]             function(cond) {
[16:04:48.388]                 is_error <- inherits(cond, "error")
[16:04:48.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.388]                   NULL)
[16:04:48.388]                 if (is_error) {
[16:04:48.388]                   sessionInformation <- function() {
[16:04:48.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.388]                       search = base::search(), system = base::Sys.info())
[16:04:48.388]                   }
[16:04:48.388]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.388]                     cond$call), session = sessionInformation(), 
[16:04:48.388]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.388]                   signalCondition(cond)
[16:04:48.388]                 }
[16:04:48.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.388]                 "immediateCondition"))) {
[16:04:48.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.388]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.388]                   if (TRUE && !signal) {
[16:04:48.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.388]                     {
[16:04:48.388]                       inherits <- base::inherits
[16:04:48.388]                       invokeRestart <- base::invokeRestart
[16:04:48.388]                       is.null <- base::is.null
[16:04:48.388]                       muffled <- FALSE
[16:04:48.388]                       if (inherits(cond, "message")) {
[16:04:48.388]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.388]                         if (muffled) 
[16:04:48.388]                           invokeRestart("muffleMessage")
[16:04:48.388]                       }
[16:04:48.388]                       else if (inherits(cond, "warning")) {
[16:04:48.388]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.388]                         if (muffled) 
[16:04:48.388]                           invokeRestart("muffleWarning")
[16:04:48.388]                       }
[16:04:48.388]                       else if (inherits(cond, "condition")) {
[16:04:48.388]                         if (!is.null(pattern)) {
[16:04:48.388]                           computeRestarts <- base::computeRestarts
[16:04:48.388]                           grepl <- base::grepl
[16:04:48.388]                           restarts <- computeRestarts(cond)
[16:04:48.388]                           for (restart in restarts) {
[16:04:48.388]                             name <- restart$name
[16:04:48.388]                             if (is.null(name)) 
[16:04:48.388]                               next
[16:04:48.388]                             if (!grepl(pattern, name)) 
[16:04:48.388]                               next
[16:04:48.388]                             invokeRestart(restart)
[16:04:48.388]                             muffled <- TRUE
[16:04:48.388]                             break
[16:04:48.388]                           }
[16:04:48.388]                         }
[16:04:48.388]                       }
[16:04:48.388]                       invisible(muffled)
[16:04:48.388]                     }
[16:04:48.388]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.388]                   }
[16:04:48.388]                 }
[16:04:48.388]                 else {
[16:04:48.388]                   if (TRUE) {
[16:04:48.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.388]                     {
[16:04:48.388]                       inherits <- base::inherits
[16:04:48.388]                       invokeRestart <- base::invokeRestart
[16:04:48.388]                       is.null <- base::is.null
[16:04:48.388]                       muffled <- FALSE
[16:04:48.388]                       if (inherits(cond, "message")) {
[16:04:48.388]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.388]                         if (muffled) 
[16:04:48.388]                           invokeRestart("muffleMessage")
[16:04:48.388]                       }
[16:04:48.388]                       else if (inherits(cond, "warning")) {
[16:04:48.388]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.388]                         if (muffled) 
[16:04:48.388]                           invokeRestart("muffleWarning")
[16:04:48.388]                       }
[16:04:48.388]                       else if (inherits(cond, "condition")) {
[16:04:48.388]                         if (!is.null(pattern)) {
[16:04:48.388]                           computeRestarts <- base::computeRestarts
[16:04:48.388]                           grepl <- base::grepl
[16:04:48.388]                           restarts <- computeRestarts(cond)
[16:04:48.388]                           for (restart in restarts) {
[16:04:48.388]                             name <- restart$name
[16:04:48.388]                             if (is.null(name)) 
[16:04:48.388]                               next
[16:04:48.388]                             if (!grepl(pattern, name)) 
[16:04:48.388]                               next
[16:04:48.388]                             invokeRestart(restart)
[16:04:48.388]                             muffled <- TRUE
[16:04:48.388]                             break
[16:04:48.388]                           }
[16:04:48.388]                         }
[16:04:48.388]                       }
[16:04:48.388]                       invisible(muffled)
[16:04:48.388]                     }
[16:04:48.388]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.388]                   }
[16:04:48.388]                 }
[16:04:48.388]             }
[16:04:48.388]         }))
[16:04:48.388]     }, error = function(ex) {
[16:04:48.388]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.388]                 ...future.rng), started = ...future.startTime, 
[16:04:48.388]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.388]             version = "1.8"), class = "FutureResult")
[16:04:48.388]     }, finally = {
[16:04:48.388]         if (!identical(...future.workdir, getwd())) 
[16:04:48.388]             setwd(...future.workdir)
[16:04:48.388]         {
[16:04:48.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.388]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.388]             }
[16:04:48.388]             base::options(...future.oldOptions)
[16:04:48.388]             if (.Platform$OS.type == "windows") {
[16:04:48.388]                 old_names <- names(...future.oldEnvVars)
[16:04:48.388]                 envs <- base::Sys.getenv()
[16:04:48.388]                 names <- names(envs)
[16:04:48.388]                 common <- intersect(names, old_names)
[16:04:48.388]                 added <- setdiff(names, old_names)
[16:04:48.388]                 removed <- setdiff(old_names, names)
[16:04:48.388]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.388]                   envs[common]]
[16:04:48.388]                 NAMES <- toupper(changed)
[16:04:48.388]                 args <- list()
[16:04:48.388]                 for (kk in seq_along(NAMES)) {
[16:04:48.388]                   name <- changed[[kk]]
[16:04:48.388]                   NAME <- NAMES[[kk]]
[16:04:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.388]                     next
[16:04:48.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.388]                 }
[16:04:48.388]                 NAMES <- toupper(added)
[16:04:48.388]                 for (kk in seq_along(NAMES)) {
[16:04:48.388]                   name <- added[[kk]]
[16:04:48.388]                   NAME <- NAMES[[kk]]
[16:04:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.388]                     next
[16:04:48.388]                   args[[name]] <- ""
[16:04:48.388]                 }
[16:04:48.388]                 NAMES <- toupper(removed)
[16:04:48.388]                 for (kk in seq_along(NAMES)) {
[16:04:48.388]                   name <- removed[[kk]]
[16:04:48.388]                   NAME <- NAMES[[kk]]
[16:04:48.388]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.388]                     next
[16:04:48.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.388]                 }
[16:04:48.388]                 if (length(args) > 0) 
[16:04:48.388]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.388]             }
[16:04:48.388]             else {
[16:04:48.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.388]             }
[16:04:48.388]             {
[16:04:48.388]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.388]                   0L) {
[16:04:48.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.388]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.388]                   base::options(opts)
[16:04:48.388]                 }
[16:04:48.388]                 {
[16:04:48.388]                   {
[16:04:48.388]                     NULL
[16:04:48.388]                     RNGkind("Mersenne-Twister")
[16:04:48.388]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.388]                       inherits = FALSE)
[16:04:48.388]                   }
[16:04:48.388]                   options(future.plan = NULL)
[16:04:48.388]                   if (is.na(NA_character_)) 
[16:04:48.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.388]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.388]                   {
[16:04:48.388]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.388]                     if (!future$lazy) 
[16:04:48.388]                       future <- run(future)
[16:04:48.388]                     invisible(future)
[16:04:48.388]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.388]                 }
[16:04:48.388]             }
[16:04:48.388]         }
[16:04:48.388]     })
[16:04:48.388]     if (TRUE) {
[16:04:48.388]         base::sink(type = "output", split = FALSE)
[16:04:48.388]         if (TRUE) {
[16:04:48.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.388]         }
[16:04:48.388]         else {
[16:04:48.388]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.388]         }
[16:04:48.388]         base::close(...future.stdout)
[16:04:48.388]         ...future.stdout <- NULL
[16:04:48.388]     }
[16:04:48.388]     ...future.result$conditions <- ...future.conditions
[16:04:48.388]     ...future.result$finished <- base::Sys.time()
[16:04:48.388]     ...future.result
[16:04:48.388] }
[16:04:48.389] assign_globals() ...
[16:04:48.389] List of 2
[16:04:48.389]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.389]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.389]  - attr(*, "where")=List of 2
[16:04:48.389]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.389]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.389]  - attr(*, "resolved")= logi FALSE
[16:04:48.389]  - attr(*, "total_size")= num 896
[16:04:48.389]  - attr(*, "already-done")= logi TRUE
[16:04:48.392] - copied ‘weight’ to environment
[16:04:48.392] - copied ‘group’ to environment
[16:04:48.392] assign_globals() ... done
[16:04:48.393] plan(): Setting new future strategy stack:
[16:04:48.393] List of future strategies:
[16:04:48.393] 1. sequential:
[16:04:48.393]    - args: function (..., envir = parent.frame())
[16:04:48.393]    - tweaked: FALSE
[16:04:48.393]    - call: NULL
[16:04:48.393] plan(): nbrOfWorkers() = 1
[16:04:48.394] plan(): Setting new future strategy stack:
[16:04:48.394] List of future strategies:
[16:04:48.394] 1. sequential:
[16:04:48.394]    - args: function (..., envir = parent.frame())
[16:04:48.394]    - tweaked: FALSE
[16:04:48.394]    - call: plan(strategy)
[16:04:48.395] plan(): nbrOfWorkers() = 1
[16:04:48.395] SequentialFuture started (and completed)
[16:04:48.395] - Launch lazy future ... done
[16:04:48.395] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:04:48.397] getGlobalsAndPackages() ...
[16:04:48.397] Searching for globals...
[16:04:48.398] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:48.398] Searching for globals ... DONE
[16:04:48.398] Resolving globals: FALSE
[16:04:48.398] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:48.399] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:48.399] - globals: [1] ‘x’
[16:04:48.399] - packages: [1] ‘stats’
[16:04:48.399] getGlobalsAndPackages() ... DONE
[16:04:48.399] run() for ‘Future’ ...
[16:04:48.399] - state: ‘created’
[16:04:48.399] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.400]   - Field: ‘label’
[16:04:48.400]   - Field: ‘local’
[16:04:48.400]   - Field: ‘owner’
[16:04:48.400]   - Field: ‘envir’
[16:04:48.400]   - Field: ‘packages’
[16:04:48.400]   - Field: ‘gc’
[16:04:48.400]   - Field: ‘conditions’
[16:04:48.401]   - Field: ‘expr’
[16:04:48.401]   - Field: ‘uuid’
[16:04:48.401]   - Field: ‘seed’
[16:04:48.401]   - Field: ‘version’
[16:04:48.401]   - Field: ‘result’
[16:04:48.401]   - Field: ‘asynchronous’
[16:04:48.401]   - Field: ‘calls’
[16:04:48.402]   - Field: ‘globals’
[16:04:48.402]   - Field: ‘stdout’
[16:04:48.402]   - Field: ‘earlySignal’
[16:04:48.402]   - Field: ‘lazy’
[16:04:48.402]   - Field: ‘state’
[16:04:48.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.402] - Launch lazy future ...
[16:04:48.403] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.403] Packages needed by future strategies (n = 0): <none>
[16:04:48.403] {
[16:04:48.403]     {
[16:04:48.403]         {
[16:04:48.403]             ...future.startTime <- base::Sys.time()
[16:04:48.403]             {
[16:04:48.403]                 {
[16:04:48.403]                   {
[16:04:48.403]                     {
[16:04:48.403]                       base::local({
[16:04:48.403]                         has_future <- base::requireNamespace("future", 
[16:04:48.403]                           quietly = TRUE)
[16:04:48.403]                         if (has_future) {
[16:04:48.403]                           ns <- base::getNamespace("future")
[16:04:48.403]                           version <- ns[[".package"]][["version"]]
[16:04:48.403]                           if (is.null(version)) 
[16:04:48.403]                             version <- utils::packageVersion("future")
[16:04:48.403]                         }
[16:04:48.403]                         else {
[16:04:48.403]                           version <- NULL
[16:04:48.403]                         }
[16:04:48.403]                         if (!has_future || version < "1.8.0") {
[16:04:48.403]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.403]                             "", base::R.version$version.string), 
[16:04:48.403]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.403]                               "release", "version")], collapse = " "), 
[16:04:48.403]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.403]                             info)
[16:04:48.403]                           info <- base::paste(info, collapse = "; ")
[16:04:48.403]                           if (!has_future) {
[16:04:48.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.403]                               info)
[16:04:48.403]                           }
[16:04:48.403]                           else {
[16:04:48.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.403]                               info, version)
[16:04:48.403]                           }
[16:04:48.403]                           base::stop(msg)
[16:04:48.403]                         }
[16:04:48.403]                       })
[16:04:48.403]                     }
[16:04:48.403]                     base::local({
[16:04:48.403]                       for (pkg in "stats") {
[16:04:48.403]                         base::loadNamespace(pkg)
[16:04:48.403]                         base::library(pkg, character.only = TRUE)
[16:04:48.403]                       }
[16:04:48.403]                     })
[16:04:48.403]                   }
[16:04:48.403]                   options(future.plan = NULL)
[16:04:48.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.403]                 }
[16:04:48.403]                 ...future.workdir <- getwd()
[16:04:48.403]             }
[16:04:48.403]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.403]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.403]         }
[16:04:48.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.403]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.403]             base::names(...future.oldOptions))
[16:04:48.403]     }
[16:04:48.403]     if (FALSE) {
[16:04:48.403]     }
[16:04:48.403]     else {
[16:04:48.403]         if (TRUE) {
[16:04:48.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.403]                 open = "w")
[16:04:48.403]         }
[16:04:48.403]         else {
[16:04:48.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.403]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.403]         }
[16:04:48.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.403]             base::sink(type = "output", split = FALSE)
[16:04:48.403]             base::close(...future.stdout)
[16:04:48.403]         }, add = TRUE)
[16:04:48.403]     }
[16:04:48.403]     ...future.frame <- base::sys.nframe()
[16:04:48.403]     ...future.conditions <- base::list()
[16:04:48.403]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.403]     if (FALSE) {
[16:04:48.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.403]     }
[16:04:48.403]     ...future.result <- base::tryCatch({
[16:04:48.403]         base::withCallingHandlers({
[16:04:48.403]             ...future.value <- base::withVisible(base::local({
[16:04:48.403]                 xtabs(~x)
[16:04:48.403]             }))
[16:04:48.403]             future::FutureResult(value = ...future.value$value, 
[16:04:48.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.403]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.403]                     ...future.globalenv.names))
[16:04:48.403]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.403]         }, condition = base::local({
[16:04:48.403]             c <- base::c
[16:04:48.403]             inherits <- base::inherits
[16:04:48.403]             invokeRestart <- base::invokeRestart
[16:04:48.403]             length <- base::length
[16:04:48.403]             list <- base::list
[16:04:48.403]             seq.int <- base::seq.int
[16:04:48.403]             signalCondition <- base::signalCondition
[16:04:48.403]             sys.calls <- base::sys.calls
[16:04:48.403]             `[[` <- base::`[[`
[16:04:48.403]             `+` <- base::`+`
[16:04:48.403]             `<<-` <- base::`<<-`
[16:04:48.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.403]                   3L)]
[16:04:48.403]             }
[16:04:48.403]             function(cond) {
[16:04:48.403]                 is_error <- inherits(cond, "error")
[16:04:48.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.403]                   NULL)
[16:04:48.403]                 if (is_error) {
[16:04:48.403]                   sessionInformation <- function() {
[16:04:48.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.403]                       search = base::search(), system = base::Sys.info())
[16:04:48.403]                   }
[16:04:48.403]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.403]                     cond$call), session = sessionInformation(), 
[16:04:48.403]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.403]                   signalCondition(cond)
[16:04:48.403]                 }
[16:04:48.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.403]                 "immediateCondition"))) {
[16:04:48.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.403]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.403]                   if (TRUE && !signal) {
[16:04:48.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.403]                     {
[16:04:48.403]                       inherits <- base::inherits
[16:04:48.403]                       invokeRestart <- base::invokeRestart
[16:04:48.403]                       is.null <- base::is.null
[16:04:48.403]                       muffled <- FALSE
[16:04:48.403]                       if (inherits(cond, "message")) {
[16:04:48.403]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.403]                         if (muffled) 
[16:04:48.403]                           invokeRestart("muffleMessage")
[16:04:48.403]                       }
[16:04:48.403]                       else if (inherits(cond, "warning")) {
[16:04:48.403]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.403]                         if (muffled) 
[16:04:48.403]                           invokeRestart("muffleWarning")
[16:04:48.403]                       }
[16:04:48.403]                       else if (inherits(cond, "condition")) {
[16:04:48.403]                         if (!is.null(pattern)) {
[16:04:48.403]                           computeRestarts <- base::computeRestarts
[16:04:48.403]                           grepl <- base::grepl
[16:04:48.403]                           restarts <- computeRestarts(cond)
[16:04:48.403]                           for (restart in restarts) {
[16:04:48.403]                             name <- restart$name
[16:04:48.403]                             if (is.null(name)) 
[16:04:48.403]                               next
[16:04:48.403]                             if (!grepl(pattern, name)) 
[16:04:48.403]                               next
[16:04:48.403]                             invokeRestart(restart)
[16:04:48.403]                             muffled <- TRUE
[16:04:48.403]                             break
[16:04:48.403]                           }
[16:04:48.403]                         }
[16:04:48.403]                       }
[16:04:48.403]                       invisible(muffled)
[16:04:48.403]                     }
[16:04:48.403]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.403]                   }
[16:04:48.403]                 }
[16:04:48.403]                 else {
[16:04:48.403]                   if (TRUE) {
[16:04:48.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.403]                     {
[16:04:48.403]                       inherits <- base::inherits
[16:04:48.403]                       invokeRestart <- base::invokeRestart
[16:04:48.403]                       is.null <- base::is.null
[16:04:48.403]                       muffled <- FALSE
[16:04:48.403]                       if (inherits(cond, "message")) {
[16:04:48.403]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.403]                         if (muffled) 
[16:04:48.403]                           invokeRestart("muffleMessage")
[16:04:48.403]                       }
[16:04:48.403]                       else if (inherits(cond, "warning")) {
[16:04:48.403]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.403]                         if (muffled) 
[16:04:48.403]                           invokeRestart("muffleWarning")
[16:04:48.403]                       }
[16:04:48.403]                       else if (inherits(cond, "condition")) {
[16:04:48.403]                         if (!is.null(pattern)) {
[16:04:48.403]                           computeRestarts <- base::computeRestarts
[16:04:48.403]                           grepl <- base::grepl
[16:04:48.403]                           restarts <- computeRestarts(cond)
[16:04:48.403]                           for (restart in restarts) {
[16:04:48.403]                             name <- restart$name
[16:04:48.403]                             if (is.null(name)) 
[16:04:48.403]                               next
[16:04:48.403]                             if (!grepl(pattern, name)) 
[16:04:48.403]                               next
[16:04:48.403]                             invokeRestart(restart)
[16:04:48.403]                             muffled <- TRUE
[16:04:48.403]                             break
[16:04:48.403]                           }
[16:04:48.403]                         }
[16:04:48.403]                       }
[16:04:48.403]                       invisible(muffled)
[16:04:48.403]                     }
[16:04:48.403]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.403]                   }
[16:04:48.403]                 }
[16:04:48.403]             }
[16:04:48.403]         }))
[16:04:48.403]     }, error = function(ex) {
[16:04:48.403]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.403]                 ...future.rng), started = ...future.startTime, 
[16:04:48.403]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.403]             version = "1.8"), class = "FutureResult")
[16:04:48.403]     }, finally = {
[16:04:48.403]         if (!identical(...future.workdir, getwd())) 
[16:04:48.403]             setwd(...future.workdir)
[16:04:48.403]         {
[16:04:48.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.403]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.403]             }
[16:04:48.403]             base::options(...future.oldOptions)
[16:04:48.403]             if (.Platform$OS.type == "windows") {
[16:04:48.403]                 old_names <- names(...future.oldEnvVars)
[16:04:48.403]                 envs <- base::Sys.getenv()
[16:04:48.403]                 names <- names(envs)
[16:04:48.403]                 common <- intersect(names, old_names)
[16:04:48.403]                 added <- setdiff(names, old_names)
[16:04:48.403]                 removed <- setdiff(old_names, names)
[16:04:48.403]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.403]                   envs[common]]
[16:04:48.403]                 NAMES <- toupper(changed)
[16:04:48.403]                 args <- list()
[16:04:48.403]                 for (kk in seq_along(NAMES)) {
[16:04:48.403]                   name <- changed[[kk]]
[16:04:48.403]                   NAME <- NAMES[[kk]]
[16:04:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.403]                     next
[16:04:48.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.403]                 }
[16:04:48.403]                 NAMES <- toupper(added)
[16:04:48.403]                 for (kk in seq_along(NAMES)) {
[16:04:48.403]                   name <- added[[kk]]
[16:04:48.403]                   NAME <- NAMES[[kk]]
[16:04:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.403]                     next
[16:04:48.403]                   args[[name]] <- ""
[16:04:48.403]                 }
[16:04:48.403]                 NAMES <- toupper(removed)
[16:04:48.403]                 for (kk in seq_along(NAMES)) {
[16:04:48.403]                   name <- removed[[kk]]
[16:04:48.403]                   NAME <- NAMES[[kk]]
[16:04:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.403]                     next
[16:04:48.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.403]                 }
[16:04:48.403]                 if (length(args) > 0) 
[16:04:48.403]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.403]             }
[16:04:48.403]             else {
[16:04:48.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.403]             }
[16:04:48.403]             {
[16:04:48.403]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.403]                   0L) {
[16:04:48.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.403]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.403]                   base::options(opts)
[16:04:48.403]                 }
[16:04:48.403]                 {
[16:04:48.403]                   {
[16:04:48.403]                     NULL
[16:04:48.403]                     RNGkind("Mersenne-Twister")
[16:04:48.403]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.403]                       inherits = FALSE)
[16:04:48.403]                   }
[16:04:48.403]                   options(future.plan = NULL)
[16:04:48.403]                   if (is.na(NA_character_)) 
[16:04:48.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.403]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.403]                   {
[16:04:48.403]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.403]                     if (!future$lazy) 
[16:04:48.403]                       future <- run(future)
[16:04:48.403]                     invisible(future)
[16:04:48.403]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.403]                 }
[16:04:48.403]             }
[16:04:48.403]         }
[16:04:48.403]     })
[16:04:48.403]     if (TRUE) {
[16:04:48.403]         base::sink(type = "output", split = FALSE)
[16:04:48.403]         if (TRUE) {
[16:04:48.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.403]         }
[16:04:48.403]         else {
[16:04:48.403]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.403]         }
[16:04:48.403]         base::close(...future.stdout)
[16:04:48.403]         ...future.stdout <- NULL
[16:04:48.403]     }
[16:04:48.403]     ...future.result$conditions <- ...future.conditions
[16:04:48.403]     ...future.result$finished <- base::Sys.time()
[16:04:48.403]     ...future.result
[16:04:48.403] }
[16:04:48.405] assign_globals() ...
[16:04:48.405] List of 1
[16:04:48.405]  $ x: num [1:5] 1 1 2 2 2
[16:04:48.405]  - attr(*, "where")=List of 1
[16:04:48.405]   ..$ x:<environment: R_EmptyEnv> 
[16:04:48.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.405]  - attr(*, "resolved")= logi FALSE
[16:04:48.405]  - attr(*, "total_size")= num 96
[16:04:48.405]  - attr(*, "already-done")= logi TRUE
[16:04:48.407] - copied ‘x’ to environment
[16:04:48.407] assign_globals() ... done
[16:04:48.408] plan(): Setting new future strategy stack:
[16:04:48.408] List of future strategies:
[16:04:48.408] 1. sequential:
[16:04:48.408]    - args: function (..., envir = parent.frame())
[16:04:48.408]    - tweaked: FALSE
[16:04:48.408]    - call: NULL
[16:04:48.408] plan(): nbrOfWorkers() = 1
[16:04:48.409] plan(): Setting new future strategy stack:
[16:04:48.409] List of future strategies:
[16:04:48.409] 1. sequential:
[16:04:48.409]    - args: function (..., envir = parent.frame())
[16:04:48.409]    - tweaked: FALSE
[16:04:48.409]    - call: plan(strategy)
[16:04:48.409] plan(): nbrOfWorkers() = 1
[16:04:48.410] SequentialFuture started (and completed)
[16:04:48.410] - Launch lazy future ... done
[16:04:48.410] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[16:04:48.411] getGlobalsAndPackages() ...
[16:04:48.411] Searching for globals...
[16:04:48.412] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:48.412] Searching for globals ... DONE
[16:04:48.412] Resolving globals: FALSE
[16:04:48.412] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:48.413] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:48.413] - globals: [1] ‘x’
[16:04:48.413] - packages: [1] ‘stats’
[16:04:48.413] getGlobalsAndPackages() ... DONE
[16:04:48.413] run() for ‘Future’ ...
[16:04:48.413] - state: ‘created’
[16:04:48.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.414] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.414]   - Field: ‘label’
[16:04:48.414]   - Field: ‘local’
[16:04:48.414]   - Field: ‘owner’
[16:04:48.414]   - Field: ‘envir’
[16:04:48.414]   - Field: ‘packages’
[16:04:48.414]   - Field: ‘gc’
[16:04:48.414]   - Field: ‘conditions’
[16:04:48.414]   - Field: ‘expr’
[16:04:48.414]   - Field: ‘uuid’
[16:04:48.415]   - Field: ‘seed’
[16:04:48.415]   - Field: ‘version’
[16:04:48.415]   - Field: ‘result’
[16:04:48.415]   - Field: ‘asynchronous’
[16:04:48.415]   - Field: ‘calls’
[16:04:48.415]   - Field: ‘globals’
[16:04:48.415]   - Field: ‘stdout’
[16:04:48.415]   - Field: ‘earlySignal’
[16:04:48.415]   - Field: ‘lazy’
[16:04:48.415]   - Field: ‘state’
[16:04:48.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.416] - Launch lazy future ...
[16:04:48.416] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.416] Packages needed by future strategies (n = 0): <none>
[16:04:48.416] {
[16:04:48.416]     {
[16:04:48.416]         {
[16:04:48.416]             ...future.startTime <- base::Sys.time()
[16:04:48.416]             {
[16:04:48.416]                 {
[16:04:48.416]                   {
[16:04:48.416]                     {
[16:04:48.416]                       base::local({
[16:04:48.416]                         has_future <- base::requireNamespace("future", 
[16:04:48.416]                           quietly = TRUE)
[16:04:48.416]                         if (has_future) {
[16:04:48.416]                           ns <- base::getNamespace("future")
[16:04:48.416]                           version <- ns[[".package"]][["version"]]
[16:04:48.416]                           if (is.null(version)) 
[16:04:48.416]                             version <- utils::packageVersion("future")
[16:04:48.416]                         }
[16:04:48.416]                         else {
[16:04:48.416]                           version <- NULL
[16:04:48.416]                         }
[16:04:48.416]                         if (!has_future || version < "1.8.0") {
[16:04:48.416]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.416]                             "", base::R.version$version.string), 
[16:04:48.416]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.416]                               "release", "version")], collapse = " "), 
[16:04:48.416]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.416]                             info)
[16:04:48.416]                           info <- base::paste(info, collapse = "; ")
[16:04:48.416]                           if (!has_future) {
[16:04:48.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.416]                               info)
[16:04:48.416]                           }
[16:04:48.416]                           else {
[16:04:48.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.416]                               info, version)
[16:04:48.416]                           }
[16:04:48.416]                           base::stop(msg)
[16:04:48.416]                         }
[16:04:48.416]                       })
[16:04:48.416]                     }
[16:04:48.416]                     base::local({
[16:04:48.416]                       for (pkg in "stats") {
[16:04:48.416]                         base::loadNamespace(pkg)
[16:04:48.416]                         base::library(pkg, character.only = TRUE)
[16:04:48.416]                       }
[16:04:48.416]                     })
[16:04:48.416]                   }
[16:04:48.416]                   options(future.plan = NULL)
[16:04:48.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.416]                 }
[16:04:48.416]                 ...future.workdir <- getwd()
[16:04:48.416]             }
[16:04:48.416]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.416]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.416]         }
[16:04:48.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.416]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.416]             base::names(...future.oldOptions))
[16:04:48.416]     }
[16:04:48.416]     if (FALSE) {
[16:04:48.416]     }
[16:04:48.416]     else {
[16:04:48.416]         if (TRUE) {
[16:04:48.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.416]                 open = "w")
[16:04:48.416]         }
[16:04:48.416]         else {
[16:04:48.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.416]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.416]         }
[16:04:48.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.416]             base::sink(type = "output", split = FALSE)
[16:04:48.416]             base::close(...future.stdout)
[16:04:48.416]         }, add = TRUE)
[16:04:48.416]     }
[16:04:48.416]     ...future.frame <- base::sys.nframe()
[16:04:48.416]     ...future.conditions <- base::list()
[16:04:48.416]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.416]     if (FALSE) {
[16:04:48.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.416]     }
[16:04:48.416]     ...future.result <- base::tryCatch({
[16:04:48.416]         base::withCallingHandlers({
[16:04:48.416]             ...future.value <- base::withVisible(base::local({
[16:04:48.416]                 xtabs(~x)
[16:04:48.416]             }))
[16:04:48.416]             future::FutureResult(value = ...future.value$value, 
[16:04:48.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.416]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.416]                     ...future.globalenv.names))
[16:04:48.416]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.416]         }, condition = base::local({
[16:04:48.416]             c <- base::c
[16:04:48.416]             inherits <- base::inherits
[16:04:48.416]             invokeRestart <- base::invokeRestart
[16:04:48.416]             length <- base::length
[16:04:48.416]             list <- base::list
[16:04:48.416]             seq.int <- base::seq.int
[16:04:48.416]             signalCondition <- base::signalCondition
[16:04:48.416]             sys.calls <- base::sys.calls
[16:04:48.416]             `[[` <- base::`[[`
[16:04:48.416]             `+` <- base::`+`
[16:04:48.416]             `<<-` <- base::`<<-`
[16:04:48.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.416]                   3L)]
[16:04:48.416]             }
[16:04:48.416]             function(cond) {
[16:04:48.416]                 is_error <- inherits(cond, "error")
[16:04:48.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.416]                   NULL)
[16:04:48.416]                 if (is_error) {
[16:04:48.416]                   sessionInformation <- function() {
[16:04:48.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.416]                       search = base::search(), system = base::Sys.info())
[16:04:48.416]                   }
[16:04:48.416]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.416]                     cond$call), session = sessionInformation(), 
[16:04:48.416]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.416]                   signalCondition(cond)
[16:04:48.416]                 }
[16:04:48.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.416]                 "immediateCondition"))) {
[16:04:48.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.416]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.416]                   if (TRUE && !signal) {
[16:04:48.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.416]                     {
[16:04:48.416]                       inherits <- base::inherits
[16:04:48.416]                       invokeRestart <- base::invokeRestart
[16:04:48.416]                       is.null <- base::is.null
[16:04:48.416]                       muffled <- FALSE
[16:04:48.416]                       if (inherits(cond, "message")) {
[16:04:48.416]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.416]                         if (muffled) 
[16:04:48.416]                           invokeRestart("muffleMessage")
[16:04:48.416]                       }
[16:04:48.416]                       else if (inherits(cond, "warning")) {
[16:04:48.416]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.416]                         if (muffled) 
[16:04:48.416]                           invokeRestart("muffleWarning")
[16:04:48.416]                       }
[16:04:48.416]                       else if (inherits(cond, "condition")) {
[16:04:48.416]                         if (!is.null(pattern)) {
[16:04:48.416]                           computeRestarts <- base::computeRestarts
[16:04:48.416]                           grepl <- base::grepl
[16:04:48.416]                           restarts <- computeRestarts(cond)
[16:04:48.416]                           for (restart in restarts) {
[16:04:48.416]                             name <- restart$name
[16:04:48.416]                             if (is.null(name)) 
[16:04:48.416]                               next
[16:04:48.416]                             if (!grepl(pattern, name)) 
[16:04:48.416]                               next
[16:04:48.416]                             invokeRestart(restart)
[16:04:48.416]                             muffled <- TRUE
[16:04:48.416]                             break
[16:04:48.416]                           }
[16:04:48.416]                         }
[16:04:48.416]                       }
[16:04:48.416]                       invisible(muffled)
[16:04:48.416]                     }
[16:04:48.416]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.416]                   }
[16:04:48.416]                 }
[16:04:48.416]                 else {
[16:04:48.416]                   if (TRUE) {
[16:04:48.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.416]                     {
[16:04:48.416]                       inherits <- base::inherits
[16:04:48.416]                       invokeRestart <- base::invokeRestart
[16:04:48.416]                       is.null <- base::is.null
[16:04:48.416]                       muffled <- FALSE
[16:04:48.416]                       if (inherits(cond, "message")) {
[16:04:48.416]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.416]                         if (muffled) 
[16:04:48.416]                           invokeRestart("muffleMessage")
[16:04:48.416]                       }
[16:04:48.416]                       else if (inherits(cond, "warning")) {
[16:04:48.416]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.416]                         if (muffled) 
[16:04:48.416]                           invokeRestart("muffleWarning")
[16:04:48.416]                       }
[16:04:48.416]                       else if (inherits(cond, "condition")) {
[16:04:48.416]                         if (!is.null(pattern)) {
[16:04:48.416]                           computeRestarts <- base::computeRestarts
[16:04:48.416]                           grepl <- base::grepl
[16:04:48.416]                           restarts <- computeRestarts(cond)
[16:04:48.416]                           for (restart in restarts) {
[16:04:48.416]                             name <- restart$name
[16:04:48.416]                             if (is.null(name)) 
[16:04:48.416]                               next
[16:04:48.416]                             if (!grepl(pattern, name)) 
[16:04:48.416]                               next
[16:04:48.416]                             invokeRestart(restart)
[16:04:48.416]                             muffled <- TRUE
[16:04:48.416]                             break
[16:04:48.416]                           }
[16:04:48.416]                         }
[16:04:48.416]                       }
[16:04:48.416]                       invisible(muffled)
[16:04:48.416]                     }
[16:04:48.416]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.416]                   }
[16:04:48.416]                 }
[16:04:48.416]             }
[16:04:48.416]         }))
[16:04:48.416]     }, error = function(ex) {
[16:04:48.416]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.416]                 ...future.rng), started = ...future.startTime, 
[16:04:48.416]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.416]             version = "1.8"), class = "FutureResult")
[16:04:48.416]     }, finally = {
[16:04:48.416]         if (!identical(...future.workdir, getwd())) 
[16:04:48.416]             setwd(...future.workdir)
[16:04:48.416]         {
[16:04:48.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.416]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.416]             }
[16:04:48.416]             base::options(...future.oldOptions)
[16:04:48.416]             if (.Platform$OS.type == "windows") {
[16:04:48.416]                 old_names <- names(...future.oldEnvVars)
[16:04:48.416]                 envs <- base::Sys.getenv()
[16:04:48.416]                 names <- names(envs)
[16:04:48.416]                 common <- intersect(names, old_names)
[16:04:48.416]                 added <- setdiff(names, old_names)
[16:04:48.416]                 removed <- setdiff(old_names, names)
[16:04:48.416]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.416]                   envs[common]]
[16:04:48.416]                 NAMES <- toupper(changed)
[16:04:48.416]                 args <- list()
[16:04:48.416]                 for (kk in seq_along(NAMES)) {
[16:04:48.416]                   name <- changed[[kk]]
[16:04:48.416]                   NAME <- NAMES[[kk]]
[16:04:48.416]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.416]                     next
[16:04:48.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.416]                 }
[16:04:48.416]                 NAMES <- toupper(added)
[16:04:48.416]                 for (kk in seq_along(NAMES)) {
[16:04:48.416]                   name <- added[[kk]]
[16:04:48.416]                   NAME <- NAMES[[kk]]
[16:04:48.416]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.416]                     next
[16:04:48.416]                   args[[name]] <- ""
[16:04:48.416]                 }
[16:04:48.416]                 NAMES <- toupper(removed)
[16:04:48.416]                 for (kk in seq_along(NAMES)) {
[16:04:48.416]                   name <- removed[[kk]]
[16:04:48.416]                   NAME <- NAMES[[kk]]
[16:04:48.416]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.416]                     next
[16:04:48.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.416]                 }
[16:04:48.416]                 if (length(args) > 0) 
[16:04:48.416]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.416]             }
[16:04:48.416]             else {
[16:04:48.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.416]             }
[16:04:48.416]             {
[16:04:48.416]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.416]                   0L) {
[16:04:48.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.416]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.416]                   base::options(opts)
[16:04:48.416]                 }
[16:04:48.416]                 {
[16:04:48.416]                   {
[16:04:48.416]                     NULL
[16:04:48.416]                     RNGkind("Mersenne-Twister")
[16:04:48.416]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.416]                       inherits = FALSE)
[16:04:48.416]                   }
[16:04:48.416]                   options(future.plan = NULL)
[16:04:48.416]                   if (is.na(NA_character_)) 
[16:04:48.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.416]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.416]                   {
[16:04:48.416]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.416]                     if (!future$lazy) 
[16:04:48.416]                       future <- run(future)
[16:04:48.416]                     invisible(future)
[16:04:48.416]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.416]                 }
[16:04:48.416]             }
[16:04:48.416]         }
[16:04:48.416]     })
[16:04:48.416]     if (TRUE) {
[16:04:48.416]         base::sink(type = "output", split = FALSE)
[16:04:48.416]         if (TRUE) {
[16:04:48.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.416]         }
[16:04:48.416]         else {
[16:04:48.416]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.416]         }
[16:04:48.416]         base::close(...future.stdout)
[16:04:48.416]         ...future.stdout <- NULL
[16:04:48.416]     }
[16:04:48.416]     ...future.result$conditions <- ...future.conditions
[16:04:48.416]     ...future.result$finished <- base::Sys.time()
[16:04:48.416]     ...future.result
[16:04:48.416] }
[16:04:48.418] assign_globals() ...
[16:04:48.418] List of 1
[16:04:48.418]  $ x: num [1:5] 1 1 2 2 2
[16:04:48.418]  - attr(*, "where")=List of 1
[16:04:48.418]   ..$ x:<environment: R_EmptyEnv> 
[16:04:48.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.418]  - attr(*, "resolved")= logi FALSE
[16:04:48.418]  - attr(*, "total_size")= num 96
[16:04:48.418]  - attr(*, "already-done")= logi TRUE
[16:04:48.420] - copied ‘x’ to environment
[16:04:48.420] assign_globals() ... done
[16:04:48.421] plan(): Setting new future strategy stack:
[16:04:48.421] List of future strategies:
[16:04:48.421] 1. sequential:
[16:04:48.421]    - args: function (..., envir = parent.frame())
[16:04:48.421]    - tweaked: FALSE
[16:04:48.421]    - call: NULL
[16:04:48.421] plan(): nbrOfWorkers() = 1
[16:04:48.422] plan(): Setting new future strategy stack:
[16:04:48.422] List of future strategies:
[16:04:48.422] 1. sequential:
[16:04:48.422]    - args: function (..., envir = parent.frame())
[16:04:48.422]    - tweaked: FALSE
[16:04:48.422]    - call: plan(strategy)
[16:04:48.422] plan(): nbrOfWorkers() = 1
[16:04:48.423] SequentialFuture started (and completed)
[16:04:48.423] - Launch lazy future ... done
[16:04:48.423] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:04:48.425] getGlobalsAndPackages() ...
[16:04:48.425] Searching for globals...
[16:04:48.427] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:04:48.427] Searching for globals ... DONE
[16:04:48.427] Resolving globals: FALSE
[16:04:48.428] 
[16:04:48.428] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.428] getGlobalsAndPackages() ... DONE
[16:04:48.428] run() for ‘Future’ ...
[16:04:48.428] - state: ‘created’
[16:04:48.428] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.429] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.429]   - Field: ‘label’
[16:04:48.429]   - Field: ‘local’
[16:04:48.429]   - Field: ‘owner’
[16:04:48.429]   - Field: ‘envir’
[16:04:48.429]   - Field: ‘packages’
[16:04:48.429]   - Field: ‘gc’
[16:04:48.429]   - Field: ‘conditions’
[16:04:48.429]   - Field: ‘expr’
[16:04:48.430]   - Field: ‘uuid’
[16:04:48.430]   - Field: ‘seed’
[16:04:48.430]   - Field: ‘version’
[16:04:48.430]   - Field: ‘result’
[16:04:48.430]   - Field: ‘asynchronous’
[16:04:48.430]   - Field: ‘calls’
[16:04:48.430]   - Field: ‘globals’
[16:04:48.430]   - Field: ‘stdout’
[16:04:48.430]   - Field: ‘earlySignal’
[16:04:48.430]   - Field: ‘lazy’
[16:04:48.430]   - Field: ‘state’
[16:04:48.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.431] - Launch lazy future ...
[16:04:48.431] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.431] Packages needed by future strategies (n = 0): <none>
[16:04:48.431] {
[16:04:48.431]     {
[16:04:48.431]         {
[16:04:48.431]             ...future.startTime <- base::Sys.time()
[16:04:48.431]             {
[16:04:48.431]                 {
[16:04:48.431]                   {
[16:04:48.431]                     {
[16:04:48.431]                       base::local({
[16:04:48.431]                         has_future <- base::requireNamespace("future", 
[16:04:48.431]                           quietly = TRUE)
[16:04:48.431]                         if (has_future) {
[16:04:48.431]                           ns <- base::getNamespace("future")
[16:04:48.431]                           version <- ns[[".package"]][["version"]]
[16:04:48.431]                           if (is.null(version)) 
[16:04:48.431]                             version <- utils::packageVersion("future")
[16:04:48.431]                         }
[16:04:48.431]                         else {
[16:04:48.431]                           version <- NULL
[16:04:48.431]                         }
[16:04:48.431]                         if (!has_future || version < "1.8.0") {
[16:04:48.431]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.431]                             "", base::R.version$version.string), 
[16:04:48.431]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.431]                               "release", "version")], collapse = " "), 
[16:04:48.431]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.431]                             info)
[16:04:48.431]                           info <- base::paste(info, collapse = "; ")
[16:04:48.431]                           if (!has_future) {
[16:04:48.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.431]                               info)
[16:04:48.431]                           }
[16:04:48.431]                           else {
[16:04:48.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.431]                               info, version)
[16:04:48.431]                           }
[16:04:48.431]                           base::stop(msg)
[16:04:48.431]                         }
[16:04:48.431]                       })
[16:04:48.431]                     }
[16:04:48.431]                     base::local({
[16:04:48.431]                       for (pkg in c("stats", "datasets")) {
[16:04:48.431]                         base::loadNamespace(pkg)
[16:04:48.431]                         base::library(pkg, character.only = TRUE)
[16:04:48.431]                       }
[16:04:48.431]                     })
[16:04:48.431]                   }
[16:04:48.431]                   options(future.plan = NULL)
[16:04:48.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.431]                 }
[16:04:48.431]                 ...future.workdir <- getwd()
[16:04:48.431]             }
[16:04:48.431]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.431]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.431]         }
[16:04:48.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.431]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.431]             base::names(...future.oldOptions))
[16:04:48.431]     }
[16:04:48.431]     if (FALSE) {
[16:04:48.431]     }
[16:04:48.431]     else {
[16:04:48.431]         if (TRUE) {
[16:04:48.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.431]                 open = "w")
[16:04:48.431]         }
[16:04:48.431]         else {
[16:04:48.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.431]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.431]         }
[16:04:48.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.431]             base::sink(type = "output", split = FALSE)
[16:04:48.431]             base::close(...future.stdout)
[16:04:48.431]         }, add = TRUE)
[16:04:48.431]     }
[16:04:48.431]     ...future.frame <- base::sys.nframe()
[16:04:48.431]     ...future.conditions <- base::list()
[16:04:48.431]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.431]     if (FALSE) {
[16:04:48.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.431]     }
[16:04:48.431]     ...future.result <- base::tryCatch({
[16:04:48.431]         base::withCallingHandlers({
[16:04:48.431]             ...future.value <- base::withVisible(base::local({
[16:04:48.431]                 lm(dist ~ . - 1, data = cars)
[16:04:48.431]             }))
[16:04:48.431]             future::FutureResult(value = ...future.value$value, 
[16:04:48.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.431]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.431]                     ...future.globalenv.names))
[16:04:48.431]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.431]         }, condition = base::local({
[16:04:48.431]             c <- base::c
[16:04:48.431]             inherits <- base::inherits
[16:04:48.431]             invokeRestart <- base::invokeRestart
[16:04:48.431]             length <- base::length
[16:04:48.431]             list <- base::list
[16:04:48.431]             seq.int <- base::seq.int
[16:04:48.431]             signalCondition <- base::signalCondition
[16:04:48.431]             sys.calls <- base::sys.calls
[16:04:48.431]             `[[` <- base::`[[`
[16:04:48.431]             `+` <- base::`+`
[16:04:48.431]             `<<-` <- base::`<<-`
[16:04:48.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.431]                   3L)]
[16:04:48.431]             }
[16:04:48.431]             function(cond) {
[16:04:48.431]                 is_error <- inherits(cond, "error")
[16:04:48.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.431]                   NULL)
[16:04:48.431]                 if (is_error) {
[16:04:48.431]                   sessionInformation <- function() {
[16:04:48.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.431]                       search = base::search(), system = base::Sys.info())
[16:04:48.431]                   }
[16:04:48.431]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.431]                     cond$call), session = sessionInformation(), 
[16:04:48.431]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.431]                   signalCondition(cond)
[16:04:48.431]                 }
[16:04:48.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.431]                 "immediateCondition"))) {
[16:04:48.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.431]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.431]                   if (TRUE && !signal) {
[16:04:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.431]                     {
[16:04:48.431]                       inherits <- base::inherits
[16:04:48.431]                       invokeRestart <- base::invokeRestart
[16:04:48.431]                       is.null <- base::is.null
[16:04:48.431]                       muffled <- FALSE
[16:04:48.431]                       if (inherits(cond, "message")) {
[16:04:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.431]                         if (muffled) 
[16:04:48.431]                           invokeRestart("muffleMessage")
[16:04:48.431]                       }
[16:04:48.431]                       else if (inherits(cond, "warning")) {
[16:04:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.431]                         if (muffled) 
[16:04:48.431]                           invokeRestart("muffleWarning")
[16:04:48.431]                       }
[16:04:48.431]                       else if (inherits(cond, "condition")) {
[16:04:48.431]                         if (!is.null(pattern)) {
[16:04:48.431]                           computeRestarts <- base::computeRestarts
[16:04:48.431]                           grepl <- base::grepl
[16:04:48.431]                           restarts <- computeRestarts(cond)
[16:04:48.431]                           for (restart in restarts) {
[16:04:48.431]                             name <- restart$name
[16:04:48.431]                             if (is.null(name)) 
[16:04:48.431]                               next
[16:04:48.431]                             if (!grepl(pattern, name)) 
[16:04:48.431]                               next
[16:04:48.431]                             invokeRestart(restart)
[16:04:48.431]                             muffled <- TRUE
[16:04:48.431]                             break
[16:04:48.431]                           }
[16:04:48.431]                         }
[16:04:48.431]                       }
[16:04:48.431]                       invisible(muffled)
[16:04:48.431]                     }
[16:04:48.431]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.431]                   }
[16:04:48.431]                 }
[16:04:48.431]                 else {
[16:04:48.431]                   if (TRUE) {
[16:04:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.431]                     {
[16:04:48.431]                       inherits <- base::inherits
[16:04:48.431]                       invokeRestart <- base::invokeRestart
[16:04:48.431]                       is.null <- base::is.null
[16:04:48.431]                       muffled <- FALSE
[16:04:48.431]                       if (inherits(cond, "message")) {
[16:04:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.431]                         if (muffled) 
[16:04:48.431]                           invokeRestart("muffleMessage")
[16:04:48.431]                       }
[16:04:48.431]                       else if (inherits(cond, "warning")) {
[16:04:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.431]                         if (muffled) 
[16:04:48.431]                           invokeRestart("muffleWarning")
[16:04:48.431]                       }
[16:04:48.431]                       else if (inherits(cond, "condition")) {
[16:04:48.431]                         if (!is.null(pattern)) {
[16:04:48.431]                           computeRestarts <- base::computeRestarts
[16:04:48.431]                           grepl <- base::grepl
[16:04:48.431]                           restarts <- computeRestarts(cond)
[16:04:48.431]                           for (restart in restarts) {
[16:04:48.431]                             name <- restart$name
[16:04:48.431]                             if (is.null(name)) 
[16:04:48.431]                               next
[16:04:48.431]                             if (!grepl(pattern, name)) 
[16:04:48.431]                               next
[16:04:48.431]                             invokeRestart(restart)
[16:04:48.431]                             muffled <- TRUE
[16:04:48.431]                             break
[16:04:48.431]                           }
[16:04:48.431]                         }
[16:04:48.431]                       }
[16:04:48.431]                       invisible(muffled)
[16:04:48.431]                     }
[16:04:48.431]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.431]                   }
[16:04:48.431]                 }
[16:04:48.431]             }
[16:04:48.431]         }))
[16:04:48.431]     }, error = function(ex) {
[16:04:48.431]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.431]                 ...future.rng), started = ...future.startTime, 
[16:04:48.431]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.431]             version = "1.8"), class = "FutureResult")
[16:04:48.431]     }, finally = {
[16:04:48.431]         if (!identical(...future.workdir, getwd())) 
[16:04:48.431]             setwd(...future.workdir)
[16:04:48.431]         {
[16:04:48.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.431]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.431]             }
[16:04:48.431]             base::options(...future.oldOptions)
[16:04:48.431]             if (.Platform$OS.type == "windows") {
[16:04:48.431]                 old_names <- names(...future.oldEnvVars)
[16:04:48.431]                 envs <- base::Sys.getenv()
[16:04:48.431]                 names <- names(envs)
[16:04:48.431]                 common <- intersect(names, old_names)
[16:04:48.431]                 added <- setdiff(names, old_names)
[16:04:48.431]                 removed <- setdiff(old_names, names)
[16:04:48.431]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.431]                   envs[common]]
[16:04:48.431]                 NAMES <- toupper(changed)
[16:04:48.431]                 args <- list()
[16:04:48.431]                 for (kk in seq_along(NAMES)) {
[16:04:48.431]                   name <- changed[[kk]]
[16:04:48.431]                   NAME <- NAMES[[kk]]
[16:04:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.431]                     next
[16:04:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.431]                 }
[16:04:48.431]                 NAMES <- toupper(added)
[16:04:48.431]                 for (kk in seq_along(NAMES)) {
[16:04:48.431]                   name <- added[[kk]]
[16:04:48.431]                   NAME <- NAMES[[kk]]
[16:04:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.431]                     next
[16:04:48.431]                   args[[name]] <- ""
[16:04:48.431]                 }
[16:04:48.431]                 NAMES <- toupper(removed)
[16:04:48.431]                 for (kk in seq_along(NAMES)) {
[16:04:48.431]                   name <- removed[[kk]]
[16:04:48.431]                   NAME <- NAMES[[kk]]
[16:04:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.431]                     next
[16:04:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.431]                 }
[16:04:48.431]                 if (length(args) > 0) 
[16:04:48.431]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.431]             }
[16:04:48.431]             else {
[16:04:48.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.431]             }
[16:04:48.431]             {
[16:04:48.431]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.431]                   0L) {
[16:04:48.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.431]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.431]                   base::options(opts)
[16:04:48.431]                 }
[16:04:48.431]                 {
[16:04:48.431]                   {
[16:04:48.431]                     NULL
[16:04:48.431]                     RNGkind("Mersenne-Twister")
[16:04:48.431]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.431]                       inherits = FALSE)
[16:04:48.431]                   }
[16:04:48.431]                   options(future.plan = NULL)
[16:04:48.431]                   if (is.na(NA_character_)) 
[16:04:48.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.431]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.431]                   {
[16:04:48.431]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.431]                     if (!future$lazy) 
[16:04:48.431]                       future <- run(future)
[16:04:48.431]                     invisible(future)
[16:04:48.431]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.431]                 }
[16:04:48.431]             }
[16:04:48.431]         }
[16:04:48.431]     })
[16:04:48.431]     if (TRUE) {
[16:04:48.431]         base::sink(type = "output", split = FALSE)
[16:04:48.431]         if (TRUE) {
[16:04:48.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.431]         }
[16:04:48.431]         else {
[16:04:48.431]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.431]         }
[16:04:48.431]         base::close(...future.stdout)
[16:04:48.431]         ...future.stdout <- NULL
[16:04:48.431]     }
[16:04:48.431]     ...future.result$conditions <- ...future.conditions
[16:04:48.431]     ...future.result$finished <- base::Sys.time()
[16:04:48.431]     ...future.result
[16:04:48.431] }
[16:04:48.433] plan(): Setting new future strategy stack:
[16:04:48.433] List of future strategies:
[16:04:48.433] 1. sequential:
[16:04:48.433]    - args: function (..., envir = parent.frame())
[16:04:48.433]    - tweaked: FALSE
[16:04:48.433]    - call: NULL
[16:04:48.434] plan(): nbrOfWorkers() = 1
[16:04:48.435] plan(): Setting new future strategy stack:
[16:04:48.435] List of future strategies:
[16:04:48.435] 1. sequential:
[16:04:48.435]    - args: function (..., envir = parent.frame())
[16:04:48.435]    - tweaked: FALSE
[16:04:48.435]    - call: plan(strategy)
[16:04:48.435] plan(): nbrOfWorkers() = 1
[16:04:48.435] SequentialFuture started (and completed)
[16:04:48.435] - Launch lazy future ... done
[16:04:48.436] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:04:48.438] getGlobalsAndPackages() ...
[16:04:48.438] Searching for globals...
[16:04:48.439] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:04:48.439] Searching for globals ... DONE
[16:04:48.439] Resolving globals: FALSE
[16:04:48.440] 
[16:04:48.440] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.440] getGlobalsAndPackages() ... DONE
[16:04:48.440] run() for ‘Future’ ...
[16:04:48.440] - state: ‘created’
[16:04:48.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.441] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.441]   - Field: ‘label’
[16:04:48.441]   - Field: ‘local’
[16:04:48.441]   - Field: ‘owner’
[16:04:48.441]   - Field: ‘envir’
[16:04:48.441]   - Field: ‘packages’
[16:04:48.441]   - Field: ‘gc’
[16:04:48.441]   - Field: ‘conditions’
[16:04:48.442]   - Field: ‘expr’
[16:04:48.442]   - Field: ‘uuid’
[16:04:48.442]   - Field: ‘seed’
[16:04:48.442]   - Field: ‘version’
[16:04:48.442]   - Field: ‘result’
[16:04:48.442]   - Field: ‘asynchronous’
[16:04:48.442]   - Field: ‘calls’
[16:04:48.442]   - Field: ‘globals’
[16:04:48.442]   - Field: ‘stdout’
[16:04:48.442]   - Field: ‘earlySignal’
[16:04:48.442]   - Field: ‘lazy’
[16:04:48.442]   - Field: ‘state’
[16:04:48.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.443] - Launch lazy future ...
[16:04:48.443] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.443] Packages needed by future strategies (n = 0): <none>
[16:04:48.443] {
[16:04:48.443]     {
[16:04:48.443]         {
[16:04:48.443]             ...future.startTime <- base::Sys.time()
[16:04:48.443]             {
[16:04:48.443]                 {
[16:04:48.443]                   {
[16:04:48.443]                     {
[16:04:48.443]                       base::local({
[16:04:48.443]                         has_future <- base::requireNamespace("future", 
[16:04:48.443]                           quietly = TRUE)
[16:04:48.443]                         if (has_future) {
[16:04:48.443]                           ns <- base::getNamespace("future")
[16:04:48.443]                           version <- ns[[".package"]][["version"]]
[16:04:48.443]                           if (is.null(version)) 
[16:04:48.443]                             version <- utils::packageVersion("future")
[16:04:48.443]                         }
[16:04:48.443]                         else {
[16:04:48.443]                           version <- NULL
[16:04:48.443]                         }
[16:04:48.443]                         if (!has_future || version < "1.8.0") {
[16:04:48.443]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.443]                             "", base::R.version$version.string), 
[16:04:48.443]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.443]                               "release", "version")], collapse = " "), 
[16:04:48.443]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.443]                             info)
[16:04:48.443]                           info <- base::paste(info, collapse = "; ")
[16:04:48.443]                           if (!has_future) {
[16:04:48.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.443]                               info)
[16:04:48.443]                           }
[16:04:48.443]                           else {
[16:04:48.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.443]                               info, version)
[16:04:48.443]                           }
[16:04:48.443]                           base::stop(msg)
[16:04:48.443]                         }
[16:04:48.443]                       })
[16:04:48.443]                     }
[16:04:48.443]                     base::local({
[16:04:48.443]                       for (pkg in c("stats", "datasets")) {
[16:04:48.443]                         base::loadNamespace(pkg)
[16:04:48.443]                         base::library(pkg, character.only = TRUE)
[16:04:48.443]                       }
[16:04:48.443]                     })
[16:04:48.443]                   }
[16:04:48.443]                   options(future.plan = NULL)
[16:04:48.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.443]                 }
[16:04:48.443]                 ...future.workdir <- getwd()
[16:04:48.443]             }
[16:04:48.443]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.443]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.443]         }
[16:04:48.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.443]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.443]             base::names(...future.oldOptions))
[16:04:48.443]     }
[16:04:48.443]     if (FALSE) {
[16:04:48.443]     }
[16:04:48.443]     else {
[16:04:48.443]         if (TRUE) {
[16:04:48.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.443]                 open = "w")
[16:04:48.443]         }
[16:04:48.443]         else {
[16:04:48.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.443]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.443]         }
[16:04:48.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.443]             base::sink(type = "output", split = FALSE)
[16:04:48.443]             base::close(...future.stdout)
[16:04:48.443]         }, add = TRUE)
[16:04:48.443]     }
[16:04:48.443]     ...future.frame <- base::sys.nframe()
[16:04:48.443]     ...future.conditions <- base::list()
[16:04:48.443]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.443]     if (FALSE) {
[16:04:48.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.443]     }
[16:04:48.443]     ...future.result <- base::tryCatch({
[16:04:48.443]         base::withCallingHandlers({
[16:04:48.443]             ...future.value <- base::withVisible(base::local({
[16:04:48.443]                 lm(dist ~ . + 0, data = cars)
[16:04:48.443]             }))
[16:04:48.443]             future::FutureResult(value = ...future.value$value, 
[16:04:48.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.443]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.443]                     ...future.globalenv.names))
[16:04:48.443]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.443]         }, condition = base::local({
[16:04:48.443]             c <- base::c
[16:04:48.443]             inherits <- base::inherits
[16:04:48.443]             invokeRestart <- base::invokeRestart
[16:04:48.443]             length <- base::length
[16:04:48.443]             list <- base::list
[16:04:48.443]             seq.int <- base::seq.int
[16:04:48.443]             signalCondition <- base::signalCondition
[16:04:48.443]             sys.calls <- base::sys.calls
[16:04:48.443]             `[[` <- base::`[[`
[16:04:48.443]             `+` <- base::`+`
[16:04:48.443]             `<<-` <- base::`<<-`
[16:04:48.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.443]                   3L)]
[16:04:48.443]             }
[16:04:48.443]             function(cond) {
[16:04:48.443]                 is_error <- inherits(cond, "error")
[16:04:48.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.443]                   NULL)
[16:04:48.443]                 if (is_error) {
[16:04:48.443]                   sessionInformation <- function() {
[16:04:48.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.443]                       search = base::search(), system = base::Sys.info())
[16:04:48.443]                   }
[16:04:48.443]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.443]                     cond$call), session = sessionInformation(), 
[16:04:48.443]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.443]                   signalCondition(cond)
[16:04:48.443]                 }
[16:04:48.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.443]                 "immediateCondition"))) {
[16:04:48.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.443]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.443]                   if (TRUE && !signal) {
[16:04:48.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.443]                     {
[16:04:48.443]                       inherits <- base::inherits
[16:04:48.443]                       invokeRestart <- base::invokeRestart
[16:04:48.443]                       is.null <- base::is.null
[16:04:48.443]                       muffled <- FALSE
[16:04:48.443]                       if (inherits(cond, "message")) {
[16:04:48.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.443]                         if (muffled) 
[16:04:48.443]                           invokeRestart("muffleMessage")
[16:04:48.443]                       }
[16:04:48.443]                       else if (inherits(cond, "warning")) {
[16:04:48.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.443]                         if (muffled) 
[16:04:48.443]                           invokeRestart("muffleWarning")
[16:04:48.443]                       }
[16:04:48.443]                       else if (inherits(cond, "condition")) {
[16:04:48.443]                         if (!is.null(pattern)) {
[16:04:48.443]                           computeRestarts <- base::computeRestarts
[16:04:48.443]                           grepl <- base::grepl
[16:04:48.443]                           restarts <- computeRestarts(cond)
[16:04:48.443]                           for (restart in restarts) {
[16:04:48.443]                             name <- restart$name
[16:04:48.443]                             if (is.null(name)) 
[16:04:48.443]                               next
[16:04:48.443]                             if (!grepl(pattern, name)) 
[16:04:48.443]                               next
[16:04:48.443]                             invokeRestart(restart)
[16:04:48.443]                             muffled <- TRUE
[16:04:48.443]                             break
[16:04:48.443]                           }
[16:04:48.443]                         }
[16:04:48.443]                       }
[16:04:48.443]                       invisible(muffled)
[16:04:48.443]                     }
[16:04:48.443]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.443]                   }
[16:04:48.443]                 }
[16:04:48.443]                 else {
[16:04:48.443]                   if (TRUE) {
[16:04:48.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.443]                     {
[16:04:48.443]                       inherits <- base::inherits
[16:04:48.443]                       invokeRestart <- base::invokeRestart
[16:04:48.443]                       is.null <- base::is.null
[16:04:48.443]                       muffled <- FALSE
[16:04:48.443]                       if (inherits(cond, "message")) {
[16:04:48.443]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.443]                         if (muffled) 
[16:04:48.443]                           invokeRestart("muffleMessage")
[16:04:48.443]                       }
[16:04:48.443]                       else if (inherits(cond, "warning")) {
[16:04:48.443]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.443]                         if (muffled) 
[16:04:48.443]                           invokeRestart("muffleWarning")
[16:04:48.443]                       }
[16:04:48.443]                       else if (inherits(cond, "condition")) {
[16:04:48.443]                         if (!is.null(pattern)) {
[16:04:48.443]                           computeRestarts <- base::computeRestarts
[16:04:48.443]                           grepl <- base::grepl
[16:04:48.443]                           restarts <- computeRestarts(cond)
[16:04:48.443]                           for (restart in restarts) {
[16:04:48.443]                             name <- restart$name
[16:04:48.443]                             if (is.null(name)) 
[16:04:48.443]                               next
[16:04:48.443]                             if (!grepl(pattern, name)) 
[16:04:48.443]                               next
[16:04:48.443]                             invokeRestart(restart)
[16:04:48.443]                             muffled <- TRUE
[16:04:48.443]                             break
[16:04:48.443]                           }
[16:04:48.443]                         }
[16:04:48.443]                       }
[16:04:48.443]                       invisible(muffled)
[16:04:48.443]                     }
[16:04:48.443]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.443]                   }
[16:04:48.443]                 }
[16:04:48.443]             }
[16:04:48.443]         }))
[16:04:48.443]     }, error = function(ex) {
[16:04:48.443]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.443]                 ...future.rng), started = ...future.startTime, 
[16:04:48.443]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.443]             version = "1.8"), class = "FutureResult")
[16:04:48.443]     }, finally = {
[16:04:48.443]         if (!identical(...future.workdir, getwd())) 
[16:04:48.443]             setwd(...future.workdir)
[16:04:48.443]         {
[16:04:48.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.443]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.443]             }
[16:04:48.443]             base::options(...future.oldOptions)
[16:04:48.443]             if (.Platform$OS.type == "windows") {
[16:04:48.443]                 old_names <- names(...future.oldEnvVars)
[16:04:48.443]                 envs <- base::Sys.getenv()
[16:04:48.443]                 names <- names(envs)
[16:04:48.443]                 common <- intersect(names, old_names)
[16:04:48.443]                 added <- setdiff(names, old_names)
[16:04:48.443]                 removed <- setdiff(old_names, names)
[16:04:48.443]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.443]                   envs[common]]
[16:04:48.443]                 NAMES <- toupper(changed)
[16:04:48.443]                 args <- list()
[16:04:48.443]                 for (kk in seq_along(NAMES)) {
[16:04:48.443]                   name <- changed[[kk]]
[16:04:48.443]                   NAME <- NAMES[[kk]]
[16:04:48.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.443]                     next
[16:04:48.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.443]                 }
[16:04:48.443]                 NAMES <- toupper(added)
[16:04:48.443]                 for (kk in seq_along(NAMES)) {
[16:04:48.443]                   name <- added[[kk]]
[16:04:48.443]                   NAME <- NAMES[[kk]]
[16:04:48.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.443]                     next
[16:04:48.443]                   args[[name]] <- ""
[16:04:48.443]                 }
[16:04:48.443]                 NAMES <- toupper(removed)
[16:04:48.443]                 for (kk in seq_along(NAMES)) {
[16:04:48.443]                   name <- removed[[kk]]
[16:04:48.443]                   NAME <- NAMES[[kk]]
[16:04:48.443]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.443]                     next
[16:04:48.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.443]                 }
[16:04:48.443]                 if (length(args) > 0) 
[16:04:48.443]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.443]             }
[16:04:48.443]             else {
[16:04:48.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.443]             }
[16:04:48.443]             {
[16:04:48.443]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.443]                   0L) {
[16:04:48.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.443]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.443]                   base::options(opts)
[16:04:48.443]                 }
[16:04:48.443]                 {
[16:04:48.443]                   {
[16:04:48.443]                     NULL
[16:04:48.443]                     RNGkind("Mersenne-Twister")
[16:04:48.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.443]                       inherits = FALSE)
[16:04:48.443]                   }
[16:04:48.443]                   options(future.plan = NULL)
[16:04:48.443]                   if (is.na(NA_character_)) 
[16:04:48.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.443]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.443]                   {
[16:04:48.443]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.443]                     if (!future$lazy) 
[16:04:48.443]                       future <- run(future)
[16:04:48.443]                     invisible(future)
[16:04:48.443]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.443]                 }
[16:04:48.443]             }
[16:04:48.443]         }
[16:04:48.443]     })
[16:04:48.443]     if (TRUE) {
[16:04:48.443]         base::sink(type = "output", split = FALSE)
[16:04:48.443]         if (TRUE) {
[16:04:48.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.443]         }
[16:04:48.443]         else {
[16:04:48.443]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.443]         }
[16:04:48.443]         base::close(...future.stdout)
[16:04:48.443]         ...future.stdout <- NULL
[16:04:48.443]     }
[16:04:48.443]     ...future.result$conditions <- ...future.conditions
[16:04:48.443]     ...future.result$finished <- base::Sys.time()
[16:04:48.443]     ...future.result
[16:04:48.443] }
[16:04:48.445] plan(): Setting new future strategy stack:
[16:04:48.445] List of future strategies:
[16:04:48.445] 1. sequential:
[16:04:48.445]    - args: function (..., envir = parent.frame())
[16:04:48.445]    - tweaked: FALSE
[16:04:48.445]    - call: NULL
[16:04:48.446] plan(): nbrOfWorkers() = 1
[16:04:48.447] plan(): Setting new future strategy stack:
[16:04:48.447] List of future strategies:
[16:04:48.447] 1. sequential:
[16:04:48.447]    - args: function (..., envir = parent.frame())
[16:04:48.447]    - tweaked: FALSE
[16:04:48.447]    - call: plan(strategy)
[16:04:48.447] plan(): nbrOfWorkers() = 1
[16:04:48.447] SequentialFuture started (and completed)
[16:04:48.448] - Launch lazy future ... done
[16:04:48.448] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:04:48.451] getGlobalsAndPackages() ...
[16:04:48.451] Searching for globals...
[16:04:48.452] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:04:48.453] Searching for globals ... DONE
[16:04:48.453] Resolving globals: FALSE
[16:04:48.453] 
[16:04:48.453] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.453] getGlobalsAndPackages() ... DONE
[16:04:48.453] run() for ‘Future’ ...
[16:04:48.454] - state: ‘created’
[16:04:48.454] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.454]   - Field: ‘label’
[16:04:48.454]   - Field: ‘local’
[16:04:48.454]   - Field: ‘owner’
[16:04:48.454]   - Field: ‘envir’
[16:04:48.455]   - Field: ‘packages’
[16:04:48.455]   - Field: ‘gc’
[16:04:48.455]   - Field: ‘conditions’
[16:04:48.455]   - Field: ‘expr’
[16:04:48.455]   - Field: ‘uuid’
[16:04:48.455]   - Field: ‘seed’
[16:04:48.455]   - Field: ‘version’
[16:04:48.455]   - Field: ‘result’
[16:04:48.455]   - Field: ‘asynchronous’
[16:04:48.455]   - Field: ‘calls’
[16:04:48.455]   - Field: ‘globals’
[16:04:48.455]   - Field: ‘stdout’
[16:04:48.456]   - Field: ‘earlySignal’
[16:04:48.456]   - Field: ‘lazy’
[16:04:48.456]   - Field: ‘state’
[16:04:48.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.456] - Launch lazy future ...
[16:04:48.456] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.456] Packages needed by future strategies (n = 0): <none>
[16:04:48.457] {
[16:04:48.457]     {
[16:04:48.457]         {
[16:04:48.457]             ...future.startTime <- base::Sys.time()
[16:04:48.457]             {
[16:04:48.457]                 {
[16:04:48.457]                   {
[16:04:48.457]                     {
[16:04:48.457]                       base::local({
[16:04:48.457]                         has_future <- base::requireNamespace("future", 
[16:04:48.457]                           quietly = TRUE)
[16:04:48.457]                         if (has_future) {
[16:04:48.457]                           ns <- base::getNamespace("future")
[16:04:48.457]                           version <- ns[[".package"]][["version"]]
[16:04:48.457]                           if (is.null(version)) 
[16:04:48.457]                             version <- utils::packageVersion("future")
[16:04:48.457]                         }
[16:04:48.457]                         else {
[16:04:48.457]                           version <- NULL
[16:04:48.457]                         }
[16:04:48.457]                         if (!has_future || version < "1.8.0") {
[16:04:48.457]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.457]                             "", base::R.version$version.string), 
[16:04:48.457]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.457]                               "release", "version")], collapse = " "), 
[16:04:48.457]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.457]                             info)
[16:04:48.457]                           info <- base::paste(info, collapse = "; ")
[16:04:48.457]                           if (!has_future) {
[16:04:48.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.457]                               info)
[16:04:48.457]                           }
[16:04:48.457]                           else {
[16:04:48.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.457]                               info, version)
[16:04:48.457]                           }
[16:04:48.457]                           base::stop(msg)
[16:04:48.457]                         }
[16:04:48.457]                       })
[16:04:48.457]                     }
[16:04:48.457]                     base::local({
[16:04:48.457]                       for (pkg in c("stats", "datasets")) {
[16:04:48.457]                         base::loadNamespace(pkg)
[16:04:48.457]                         base::library(pkg, character.only = TRUE)
[16:04:48.457]                       }
[16:04:48.457]                     })
[16:04:48.457]                   }
[16:04:48.457]                   options(future.plan = NULL)
[16:04:48.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.457]                 }
[16:04:48.457]                 ...future.workdir <- getwd()
[16:04:48.457]             }
[16:04:48.457]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.457]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.457]         }
[16:04:48.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.457]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.457]             base::names(...future.oldOptions))
[16:04:48.457]     }
[16:04:48.457]     if (FALSE) {
[16:04:48.457]     }
[16:04:48.457]     else {
[16:04:48.457]         if (TRUE) {
[16:04:48.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.457]                 open = "w")
[16:04:48.457]         }
[16:04:48.457]         else {
[16:04:48.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.457]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.457]         }
[16:04:48.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.457]             base::sink(type = "output", split = FALSE)
[16:04:48.457]             base::close(...future.stdout)
[16:04:48.457]         }, add = TRUE)
[16:04:48.457]     }
[16:04:48.457]     ...future.frame <- base::sys.nframe()
[16:04:48.457]     ...future.conditions <- base::list()
[16:04:48.457]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.457]     if (FALSE) {
[16:04:48.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.457]     }
[16:04:48.457]     ...future.result <- base::tryCatch({
[16:04:48.457]         base::withCallingHandlers({
[16:04:48.457]             ...future.value <- base::withVisible(base::local({
[16:04:48.457]                 lm(dist ~ speed + speed^2, data = cars)
[16:04:48.457]             }))
[16:04:48.457]             future::FutureResult(value = ...future.value$value, 
[16:04:48.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.457]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.457]                     ...future.globalenv.names))
[16:04:48.457]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.457]         }, condition = base::local({
[16:04:48.457]             c <- base::c
[16:04:48.457]             inherits <- base::inherits
[16:04:48.457]             invokeRestart <- base::invokeRestart
[16:04:48.457]             length <- base::length
[16:04:48.457]             list <- base::list
[16:04:48.457]             seq.int <- base::seq.int
[16:04:48.457]             signalCondition <- base::signalCondition
[16:04:48.457]             sys.calls <- base::sys.calls
[16:04:48.457]             `[[` <- base::`[[`
[16:04:48.457]             `+` <- base::`+`
[16:04:48.457]             `<<-` <- base::`<<-`
[16:04:48.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.457]                   3L)]
[16:04:48.457]             }
[16:04:48.457]             function(cond) {
[16:04:48.457]                 is_error <- inherits(cond, "error")
[16:04:48.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.457]                   NULL)
[16:04:48.457]                 if (is_error) {
[16:04:48.457]                   sessionInformation <- function() {
[16:04:48.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.457]                       search = base::search(), system = base::Sys.info())
[16:04:48.457]                   }
[16:04:48.457]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.457]                     cond$call), session = sessionInformation(), 
[16:04:48.457]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.457]                   signalCondition(cond)
[16:04:48.457]                 }
[16:04:48.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.457]                 "immediateCondition"))) {
[16:04:48.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.457]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.457]                   if (TRUE && !signal) {
[16:04:48.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.457]                     {
[16:04:48.457]                       inherits <- base::inherits
[16:04:48.457]                       invokeRestart <- base::invokeRestart
[16:04:48.457]                       is.null <- base::is.null
[16:04:48.457]                       muffled <- FALSE
[16:04:48.457]                       if (inherits(cond, "message")) {
[16:04:48.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.457]                         if (muffled) 
[16:04:48.457]                           invokeRestart("muffleMessage")
[16:04:48.457]                       }
[16:04:48.457]                       else if (inherits(cond, "warning")) {
[16:04:48.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.457]                         if (muffled) 
[16:04:48.457]                           invokeRestart("muffleWarning")
[16:04:48.457]                       }
[16:04:48.457]                       else if (inherits(cond, "condition")) {
[16:04:48.457]                         if (!is.null(pattern)) {
[16:04:48.457]                           computeRestarts <- base::computeRestarts
[16:04:48.457]                           grepl <- base::grepl
[16:04:48.457]                           restarts <- computeRestarts(cond)
[16:04:48.457]                           for (restart in restarts) {
[16:04:48.457]                             name <- restart$name
[16:04:48.457]                             if (is.null(name)) 
[16:04:48.457]                               next
[16:04:48.457]                             if (!grepl(pattern, name)) 
[16:04:48.457]                               next
[16:04:48.457]                             invokeRestart(restart)
[16:04:48.457]                             muffled <- TRUE
[16:04:48.457]                             break
[16:04:48.457]                           }
[16:04:48.457]                         }
[16:04:48.457]                       }
[16:04:48.457]                       invisible(muffled)
[16:04:48.457]                     }
[16:04:48.457]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.457]                   }
[16:04:48.457]                 }
[16:04:48.457]                 else {
[16:04:48.457]                   if (TRUE) {
[16:04:48.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.457]                     {
[16:04:48.457]                       inherits <- base::inherits
[16:04:48.457]                       invokeRestart <- base::invokeRestart
[16:04:48.457]                       is.null <- base::is.null
[16:04:48.457]                       muffled <- FALSE
[16:04:48.457]                       if (inherits(cond, "message")) {
[16:04:48.457]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.457]                         if (muffled) 
[16:04:48.457]                           invokeRestart("muffleMessage")
[16:04:48.457]                       }
[16:04:48.457]                       else if (inherits(cond, "warning")) {
[16:04:48.457]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.457]                         if (muffled) 
[16:04:48.457]                           invokeRestart("muffleWarning")
[16:04:48.457]                       }
[16:04:48.457]                       else if (inherits(cond, "condition")) {
[16:04:48.457]                         if (!is.null(pattern)) {
[16:04:48.457]                           computeRestarts <- base::computeRestarts
[16:04:48.457]                           grepl <- base::grepl
[16:04:48.457]                           restarts <- computeRestarts(cond)
[16:04:48.457]                           for (restart in restarts) {
[16:04:48.457]                             name <- restart$name
[16:04:48.457]                             if (is.null(name)) 
[16:04:48.457]                               next
[16:04:48.457]                             if (!grepl(pattern, name)) 
[16:04:48.457]                               next
[16:04:48.457]                             invokeRestart(restart)
[16:04:48.457]                             muffled <- TRUE
[16:04:48.457]                             break
[16:04:48.457]                           }
[16:04:48.457]                         }
[16:04:48.457]                       }
[16:04:48.457]                       invisible(muffled)
[16:04:48.457]                     }
[16:04:48.457]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.457]                   }
[16:04:48.457]                 }
[16:04:48.457]             }
[16:04:48.457]         }))
[16:04:48.457]     }, error = function(ex) {
[16:04:48.457]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.457]                 ...future.rng), started = ...future.startTime, 
[16:04:48.457]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.457]             version = "1.8"), class = "FutureResult")
[16:04:48.457]     }, finally = {
[16:04:48.457]         if (!identical(...future.workdir, getwd())) 
[16:04:48.457]             setwd(...future.workdir)
[16:04:48.457]         {
[16:04:48.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.457]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.457]             }
[16:04:48.457]             base::options(...future.oldOptions)
[16:04:48.457]             if (.Platform$OS.type == "windows") {
[16:04:48.457]                 old_names <- names(...future.oldEnvVars)
[16:04:48.457]                 envs <- base::Sys.getenv()
[16:04:48.457]                 names <- names(envs)
[16:04:48.457]                 common <- intersect(names, old_names)
[16:04:48.457]                 added <- setdiff(names, old_names)
[16:04:48.457]                 removed <- setdiff(old_names, names)
[16:04:48.457]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.457]                   envs[common]]
[16:04:48.457]                 NAMES <- toupper(changed)
[16:04:48.457]                 args <- list()
[16:04:48.457]                 for (kk in seq_along(NAMES)) {
[16:04:48.457]                   name <- changed[[kk]]
[16:04:48.457]                   NAME <- NAMES[[kk]]
[16:04:48.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.457]                     next
[16:04:48.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.457]                 }
[16:04:48.457]                 NAMES <- toupper(added)
[16:04:48.457]                 for (kk in seq_along(NAMES)) {
[16:04:48.457]                   name <- added[[kk]]
[16:04:48.457]                   NAME <- NAMES[[kk]]
[16:04:48.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.457]                     next
[16:04:48.457]                   args[[name]] <- ""
[16:04:48.457]                 }
[16:04:48.457]                 NAMES <- toupper(removed)
[16:04:48.457]                 for (kk in seq_along(NAMES)) {
[16:04:48.457]                   name <- removed[[kk]]
[16:04:48.457]                   NAME <- NAMES[[kk]]
[16:04:48.457]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.457]                     next
[16:04:48.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.457]                 }
[16:04:48.457]                 if (length(args) > 0) 
[16:04:48.457]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.457]             }
[16:04:48.457]             else {
[16:04:48.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.457]             }
[16:04:48.457]             {
[16:04:48.457]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.457]                   0L) {
[16:04:48.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.457]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.457]                   base::options(opts)
[16:04:48.457]                 }
[16:04:48.457]                 {
[16:04:48.457]                   {
[16:04:48.457]                     NULL
[16:04:48.457]                     RNGkind("Mersenne-Twister")
[16:04:48.457]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.457]                       inherits = FALSE)
[16:04:48.457]                   }
[16:04:48.457]                   options(future.plan = NULL)
[16:04:48.457]                   if (is.na(NA_character_)) 
[16:04:48.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.457]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.457]                   {
[16:04:48.457]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.457]                     if (!future$lazy) 
[16:04:48.457]                       future <- run(future)
[16:04:48.457]                     invisible(future)
[16:04:48.457]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.457]                 }
[16:04:48.457]             }
[16:04:48.457]         }
[16:04:48.457]     })
[16:04:48.457]     if (TRUE) {
[16:04:48.457]         base::sink(type = "output", split = FALSE)
[16:04:48.457]         if (TRUE) {
[16:04:48.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.457]         }
[16:04:48.457]         else {
[16:04:48.457]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.457]         }
[16:04:48.457]         base::close(...future.stdout)
[16:04:48.457]         ...future.stdout <- NULL
[16:04:48.457]     }
[16:04:48.457]     ...future.result$conditions <- ...future.conditions
[16:04:48.457]     ...future.result$finished <- base::Sys.time()
[16:04:48.457]     ...future.result
[16:04:48.457] }
[16:04:48.459] plan(): Setting new future strategy stack:
[16:04:48.459] List of future strategies:
[16:04:48.459] 1. sequential:
[16:04:48.459]    - args: function (..., envir = parent.frame())
[16:04:48.459]    - tweaked: FALSE
[16:04:48.459]    - call: NULL
[16:04:48.459] plan(): nbrOfWorkers() = 1
[16:04:48.460] plan(): Setting new future strategy stack:
[16:04:48.460] List of future strategies:
[16:04:48.460] 1. sequential:
[16:04:48.460]    - args: function (..., envir = parent.frame())
[16:04:48.460]    - tweaked: FALSE
[16:04:48.460]    - call: plan(strategy)
[16:04:48.461] plan(): nbrOfWorkers() = 1
[16:04:48.461] SequentialFuture started (and completed)
[16:04:48.461] - Launch lazy future ... done
[16:04:48.461] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:04:48.463] getGlobalsAndPackages() ...
[16:04:48.463] Searching for globals...
[16:04:48.465] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:04:48.465] Searching for globals ... DONE
[16:04:48.465] Resolving globals: FALSE
[16:04:48.466] 
[16:04:48.466] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.466] getGlobalsAndPackages() ... DONE
[16:04:48.466] run() for ‘Future’ ...
[16:04:48.466] - state: ‘created’
[16:04:48.466] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.467] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.467]   - Field: ‘label’
[16:04:48.467]   - Field: ‘local’
[16:04:48.467]   - Field: ‘owner’
[16:04:48.467]   - Field: ‘envir’
[16:04:48.467]   - Field: ‘packages’
[16:04:48.467]   - Field: ‘gc’
[16:04:48.467]   - Field: ‘conditions’
[16:04:48.467]   - Field: ‘expr’
[16:04:48.468]   - Field: ‘uuid’
[16:04:48.468]   - Field: ‘seed’
[16:04:48.468]   - Field: ‘version’
[16:04:48.468]   - Field: ‘result’
[16:04:48.468]   - Field: ‘asynchronous’
[16:04:48.468]   - Field: ‘calls’
[16:04:48.468]   - Field: ‘globals’
[16:04:48.468]   - Field: ‘stdout’
[16:04:48.468]   - Field: ‘earlySignal’
[16:04:48.468]   - Field: ‘lazy’
[16:04:48.468]   - Field: ‘state’
[16:04:48.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.469] - Launch lazy future ...
[16:04:48.469] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.469] Packages needed by future strategies (n = 0): <none>
[16:04:48.469] {
[16:04:48.469]     {
[16:04:48.469]         {
[16:04:48.469]             ...future.startTime <- base::Sys.time()
[16:04:48.469]             {
[16:04:48.469]                 {
[16:04:48.469]                   {
[16:04:48.469]                     {
[16:04:48.469]                       base::local({
[16:04:48.469]                         has_future <- base::requireNamespace("future", 
[16:04:48.469]                           quietly = TRUE)
[16:04:48.469]                         if (has_future) {
[16:04:48.469]                           ns <- base::getNamespace("future")
[16:04:48.469]                           version <- ns[[".package"]][["version"]]
[16:04:48.469]                           if (is.null(version)) 
[16:04:48.469]                             version <- utils::packageVersion("future")
[16:04:48.469]                         }
[16:04:48.469]                         else {
[16:04:48.469]                           version <- NULL
[16:04:48.469]                         }
[16:04:48.469]                         if (!has_future || version < "1.8.0") {
[16:04:48.469]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.469]                             "", base::R.version$version.string), 
[16:04:48.469]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.469]                               "release", "version")], collapse = " "), 
[16:04:48.469]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.469]                             info)
[16:04:48.469]                           info <- base::paste(info, collapse = "; ")
[16:04:48.469]                           if (!has_future) {
[16:04:48.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.469]                               info)
[16:04:48.469]                           }
[16:04:48.469]                           else {
[16:04:48.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.469]                               info, version)
[16:04:48.469]                           }
[16:04:48.469]                           base::stop(msg)
[16:04:48.469]                         }
[16:04:48.469]                       })
[16:04:48.469]                     }
[16:04:48.469]                     base::local({
[16:04:48.469]                       for (pkg in c("stats", "datasets")) {
[16:04:48.469]                         base::loadNamespace(pkg)
[16:04:48.469]                         base::library(pkg, character.only = TRUE)
[16:04:48.469]                       }
[16:04:48.469]                     })
[16:04:48.469]                   }
[16:04:48.469]                   options(future.plan = NULL)
[16:04:48.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.469]                 }
[16:04:48.469]                 ...future.workdir <- getwd()
[16:04:48.469]             }
[16:04:48.469]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.469]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.469]         }
[16:04:48.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.469]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.469]             base::names(...future.oldOptions))
[16:04:48.469]     }
[16:04:48.469]     if (FALSE) {
[16:04:48.469]     }
[16:04:48.469]     else {
[16:04:48.469]         if (TRUE) {
[16:04:48.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.469]                 open = "w")
[16:04:48.469]         }
[16:04:48.469]         else {
[16:04:48.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.469]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.469]         }
[16:04:48.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.469]             base::sink(type = "output", split = FALSE)
[16:04:48.469]             base::close(...future.stdout)
[16:04:48.469]         }, add = TRUE)
[16:04:48.469]     }
[16:04:48.469]     ...future.frame <- base::sys.nframe()
[16:04:48.469]     ...future.conditions <- base::list()
[16:04:48.469]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.469]     if (FALSE) {
[16:04:48.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.469]     }
[16:04:48.469]     ...future.result <- base::tryCatch({
[16:04:48.469]         base::withCallingHandlers({
[16:04:48.469]             ...future.value <- base::withVisible(base::local({
[16:04:48.469]                 lm(dist ~ speed + I(speed^2), data = cars)
[16:04:48.469]             }))
[16:04:48.469]             future::FutureResult(value = ...future.value$value, 
[16:04:48.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.469]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.469]                     ...future.globalenv.names))
[16:04:48.469]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.469]         }, condition = base::local({
[16:04:48.469]             c <- base::c
[16:04:48.469]             inherits <- base::inherits
[16:04:48.469]             invokeRestart <- base::invokeRestart
[16:04:48.469]             length <- base::length
[16:04:48.469]             list <- base::list
[16:04:48.469]             seq.int <- base::seq.int
[16:04:48.469]             signalCondition <- base::signalCondition
[16:04:48.469]             sys.calls <- base::sys.calls
[16:04:48.469]             `[[` <- base::`[[`
[16:04:48.469]             `+` <- base::`+`
[16:04:48.469]             `<<-` <- base::`<<-`
[16:04:48.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.469]                   3L)]
[16:04:48.469]             }
[16:04:48.469]             function(cond) {
[16:04:48.469]                 is_error <- inherits(cond, "error")
[16:04:48.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.469]                   NULL)
[16:04:48.469]                 if (is_error) {
[16:04:48.469]                   sessionInformation <- function() {
[16:04:48.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.469]                       search = base::search(), system = base::Sys.info())
[16:04:48.469]                   }
[16:04:48.469]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.469]                     cond$call), session = sessionInformation(), 
[16:04:48.469]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.469]                   signalCondition(cond)
[16:04:48.469]                 }
[16:04:48.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.469]                 "immediateCondition"))) {
[16:04:48.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.469]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.469]                   if (TRUE && !signal) {
[16:04:48.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.469]                     {
[16:04:48.469]                       inherits <- base::inherits
[16:04:48.469]                       invokeRestart <- base::invokeRestart
[16:04:48.469]                       is.null <- base::is.null
[16:04:48.469]                       muffled <- FALSE
[16:04:48.469]                       if (inherits(cond, "message")) {
[16:04:48.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.469]                         if (muffled) 
[16:04:48.469]                           invokeRestart("muffleMessage")
[16:04:48.469]                       }
[16:04:48.469]                       else if (inherits(cond, "warning")) {
[16:04:48.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.469]                         if (muffled) 
[16:04:48.469]                           invokeRestart("muffleWarning")
[16:04:48.469]                       }
[16:04:48.469]                       else if (inherits(cond, "condition")) {
[16:04:48.469]                         if (!is.null(pattern)) {
[16:04:48.469]                           computeRestarts <- base::computeRestarts
[16:04:48.469]                           grepl <- base::grepl
[16:04:48.469]                           restarts <- computeRestarts(cond)
[16:04:48.469]                           for (restart in restarts) {
[16:04:48.469]                             name <- restart$name
[16:04:48.469]                             if (is.null(name)) 
[16:04:48.469]                               next
[16:04:48.469]                             if (!grepl(pattern, name)) 
[16:04:48.469]                               next
[16:04:48.469]                             invokeRestart(restart)
[16:04:48.469]                             muffled <- TRUE
[16:04:48.469]                             break
[16:04:48.469]                           }
[16:04:48.469]                         }
[16:04:48.469]                       }
[16:04:48.469]                       invisible(muffled)
[16:04:48.469]                     }
[16:04:48.469]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.469]                   }
[16:04:48.469]                 }
[16:04:48.469]                 else {
[16:04:48.469]                   if (TRUE) {
[16:04:48.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.469]                     {
[16:04:48.469]                       inherits <- base::inherits
[16:04:48.469]                       invokeRestart <- base::invokeRestart
[16:04:48.469]                       is.null <- base::is.null
[16:04:48.469]                       muffled <- FALSE
[16:04:48.469]                       if (inherits(cond, "message")) {
[16:04:48.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.469]                         if (muffled) 
[16:04:48.469]                           invokeRestart("muffleMessage")
[16:04:48.469]                       }
[16:04:48.469]                       else if (inherits(cond, "warning")) {
[16:04:48.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.469]                         if (muffled) 
[16:04:48.469]                           invokeRestart("muffleWarning")
[16:04:48.469]                       }
[16:04:48.469]                       else if (inherits(cond, "condition")) {
[16:04:48.469]                         if (!is.null(pattern)) {
[16:04:48.469]                           computeRestarts <- base::computeRestarts
[16:04:48.469]                           grepl <- base::grepl
[16:04:48.469]                           restarts <- computeRestarts(cond)
[16:04:48.469]                           for (restart in restarts) {
[16:04:48.469]                             name <- restart$name
[16:04:48.469]                             if (is.null(name)) 
[16:04:48.469]                               next
[16:04:48.469]                             if (!grepl(pattern, name)) 
[16:04:48.469]                               next
[16:04:48.469]                             invokeRestart(restart)
[16:04:48.469]                             muffled <- TRUE
[16:04:48.469]                             break
[16:04:48.469]                           }
[16:04:48.469]                         }
[16:04:48.469]                       }
[16:04:48.469]                       invisible(muffled)
[16:04:48.469]                     }
[16:04:48.469]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.469]                   }
[16:04:48.469]                 }
[16:04:48.469]             }
[16:04:48.469]         }))
[16:04:48.469]     }, error = function(ex) {
[16:04:48.469]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.469]                 ...future.rng), started = ...future.startTime, 
[16:04:48.469]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.469]             version = "1.8"), class = "FutureResult")
[16:04:48.469]     }, finally = {
[16:04:48.469]         if (!identical(...future.workdir, getwd())) 
[16:04:48.469]             setwd(...future.workdir)
[16:04:48.469]         {
[16:04:48.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.469]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.469]             }
[16:04:48.469]             base::options(...future.oldOptions)
[16:04:48.469]             if (.Platform$OS.type == "windows") {
[16:04:48.469]                 old_names <- names(...future.oldEnvVars)
[16:04:48.469]                 envs <- base::Sys.getenv()
[16:04:48.469]                 names <- names(envs)
[16:04:48.469]                 common <- intersect(names, old_names)
[16:04:48.469]                 added <- setdiff(names, old_names)
[16:04:48.469]                 removed <- setdiff(old_names, names)
[16:04:48.469]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.469]                   envs[common]]
[16:04:48.469]                 NAMES <- toupper(changed)
[16:04:48.469]                 args <- list()
[16:04:48.469]                 for (kk in seq_along(NAMES)) {
[16:04:48.469]                   name <- changed[[kk]]
[16:04:48.469]                   NAME <- NAMES[[kk]]
[16:04:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.469]                     next
[16:04:48.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.469]                 }
[16:04:48.469]                 NAMES <- toupper(added)
[16:04:48.469]                 for (kk in seq_along(NAMES)) {
[16:04:48.469]                   name <- added[[kk]]
[16:04:48.469]                   NAME <- NAMES[[kk]]
[16:04:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.469]                     next
[16:04:48.469]                   args[[name]] <- ""
[16:04:48.469]                 }
[16:04:48.469]                 NAMES <- toupper(removed)
[16:04:48.469]                 for (kk in seq_along(NAMES)) {
[16:04:48.469]                   name <- removed[[kk]]
[16:04:48.469]                   NAME <- NAMES[[kk]]
[16:04:48.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.469]                     next
[16:04:48.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.469]                 }
[16:04:48.469]                 if (length(args) > 0) 
[16:04:48.469]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.469]             }
[16:04:48.469]             else {
[16:04:48.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.469]             }
[16:04:48.469]             {
[16:04:48.469]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.469]                   0L) {
[16:04:48.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.469]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.469]                   base::options(opts)
[16:04:48.469]                 }
[16:04:48.469]                 {
[16:04:48.469]                   {
[16:04:48.469]                     NULL
[16:04:48.469]                     RNGkind("Mersenne-Twister")
[16:04:48.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.469]                       inherits = FALSE)
[16:04:48.469]                   }
[16:04:48.469]                   options(future.plan = NULL)
[16:04:48.469]                   if (is.na(NA_character_)) 
[16:04:48.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.469]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.469]                   {
[16:04:48.469]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.469]                     if (!future$lazy) 
[16:04:48.469]                       future <- run(future)
[16:04:48.469]                     invisible(future)
[16:04:48.469]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.469]                 }
[16:04:48.469]             }
[16:04:48.469]         }
[16:04:48.469]     })
[16:04:48.469]     if (TRUE) {
[16:04:48.469]         base::sink(type = "output", split = FALSE)
[16:04:48.469]         if (TRUE) {
[16:04:48.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.469]         }
[16:04:48.469]         else {
[16:04:48.469]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.469]         }
[16:04:48.469]         base::close(...future.stdout)
[16:04:48.469]         ...future.stdout <- NULL
[16:04:48.469]     }
[16:04:48.469]     ...future.result$conditions <- ...future.conditions
[16:04:48.469]     ...future.result$finished <- base::Sys.time()
[16:04:48.469]     ...future.result
[16:04:48.469] }
[16:04:48.471] plan(): Setting new future strategy stack:
[16:04:48.471] List of future strategies:
[16:04:48.471] 1. sequential:
[16:04:48.471]    - args: function (..., envir = parent.frame())
[16:04:48.471]    - tweaked: FALSE
[16:04:48.471]    - call: NULL
[16:04:48.472] plan(): nbrOfWorkers() = 1
[16:04:48.474] plan(): Setting new future strategy stack:
[16:04:48.474] List of future strategies:
[16:04:48.474] 1. sequential:
[16:04:48.474]    - args: function (..., envir = parent.frame())
[16:04:48.474]    - tweaked: FALSE
[16:04:48.474]    - call: plan(strategy)
[16:04:48.474] plan(): nbrOfWorkers() = 1
[16:04:48.474] SequentialFuture started (and completed)
[16:04:48.475] - Launch lazy future ... done
[16:04:48.475] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:04:48.478] getGlobalsAndPackages() ...
[16:04:48.478] Searching for globals...
[16:04:48.479] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:04:48.479] Searching for globals ... DONE
[16:04:48.480] Resolving globals: FALSE
[16:04:48.480] 
[16:04:48.480] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.480] getGlobalsAndPackages() ... DONE
[16:04:48.480] run() for ‘Future’ ...
[16:04:48.480] - state: ‘created’
[16:04:48.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.481]   - Field: ‘label’
[16:04:48.481]   - Field: ‘local’
[16:04:48.481]   - Field: ‘owner’
[16:04:48.481]   - Field: ‘envir’
[16:04:48.481]   - Field: ‘packages’
[16:04:48.481]   - Field: ‘gc’
[16:04:48.482]   - Field: ‘conditions’
[16:04:48.482]   - Field: ‘expr’
[16:04:48.482]   - Field: ‘uuid’
[16:04:48.482]   - Field: ‘seed’
[16:04:48.482]   - Field: ‘version’
[16:04:48.482]   - Field: ‘result’
[16:04:48.482]   - Field: ‘asynchronous’
[16:04:48.482]   - Field: ‘calls’
[16:04:48.482]   - Field: ‘globals’
[16:04:48.482]   - Field: ‘stdout’
[16:04:48.482]   - Field: ‘earlySignal’
[16:04:48.482]   - Field: ‘lazy’
[16:04:48.483]   - Field: ‘state’
[16:04:48.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.483] - Launch lazy future ...
[16:04:48.483] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.483] Packages needed by future strategies (n = 0): <none>
[16:04:48.483] {
[16:04:48.483]     {
[16:04:48.483]         {
[16:04:48.483]             ...future.startTime <- base::Sys.time()
[16:04:48.483]             {
[16:04:48.483]                 {
[16:04:48.483]                   {
[16:04:48.483]                     {
[16:04:48.483]                       base::local({
[16:04:48.483]                         has_future <- base::requireNamespace("future", 
[16:04:48.483]                           quietly = TRUE)
[16:04:48.483]                         if (has_future) {
[16:04:48.483]                           ns <- base::getNamespace("future")
[16:04:48.483]                           version <- ns[[".package"]][["version"]]
[16:04:48.483]                           if (is.null(version)) 
[16:04:48.483]                             version <- utils::packageVersion("future")
[16:04:48.483]                         }
[16:04:48.483]                         else {
[16:04:48.483]                           version <- NULL
[16:04:48.483]                         }
[16:04:48.483]                         if (!has_future || version < "1.8.0") {
[16:04:48.483]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.483]                             "", base::R.version$version.string), 
[16:04:48.483]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:48.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.483]                               "release", "version")], collapse = " "), 
[16:04:48.483]                             hostname = base::Sys.info()[["nodename"]])
[16:04:48.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.483]                             info)
[16:04:48.483]                           info <- base::paste(info, collapse = "; ")
[16:04:48.483]                           if (!has_future) {
[16:04:48.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.483]                               info)
[16:04:48.483]                           }
[16:04:48.483]                           else {
[16:04:48.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.483]                               info, version)
[16:04:48.483]                           }
[16:04:48.483]                           base::stop(msg)
[16:04:48.483]                         }
[16:04:48.483]                       })
[16:04:48.483]                     }
[16:04:48.483]                     base::local({
[16:04:48.483]                       for (pkg in c("stats", "datasets")) {
[16:04:48.483]                         base::loadNamespace(pkg)
[16:04:48.483]                         base::library(pkg, character.only = TRUE)
[16:04:48.483]                       }
[16:04:48.483]                     })
[16:04:48.483]                   }
[16:04:48.483]                   options(future.plan = NULL)
[16:04:48.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.483]                 }
[16:04:48.483]                 ...future.workdir <- getwd()
[16:04:48.483]             }
[16:04:48.483]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.483]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.483]         }
[16:04:48.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.483]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.483]             base::names(...future.oldOptions))
[16:04:48.483]     }
[16:04:48.483]     if (FALSE) {
[16:04:48.483]     }
[16:04:48.483]     else {
[16:04:48.483]         if (TRUE) {
[16:04:48.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.483]                 open = "w")
[16:04:48.483]         }
[16:04:48.483]         else {
[16:04:48.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.483]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.483]         }
[16:04:48.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.483]             base::sink(type = "output", split = FALSE)
[16:04:48.483]             base::close(...future.stdout)
[16:04:48.483]         }, add = TRUE)
[16:04:48.483]     }
[16:04:48.483]     ...future.frame <- base::sys.nframe()
[16:04:48.483]     ...future.conditions <- base::list()
[16:04:48.483]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.483]     if (FALSE) {
[16:04:48.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.483]     }
[16:04:48.483]     ...future.result <- base::tryCatch({
[16:04:48.483]         base::withCallingHandlers({
[16:04:48.483]             ...future.value <- base::withVisible(base::local({
[16:04:48.483]                 lm(dist ~ poly(speed, 2), data = cars)
[16:04:48.483]             }))
[16:04:48.483]             future::FutureResult(value = ...future.value$value, 
[16:04:48.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.483]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.483]                     ...future.globalenv.names))
[16:04:48.483]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.483]         }, condition = base::local({
[16:04:48.483]             c <- base::c
[16:04:48.483]             inherits <- base::inherits
[16:04:48.483]             invokeRestart <- base::invokeRestart
[16:04:48.483]             length <- base::length
[16:04:48.483]             list <- base::list
[16:04:48.483]             seq.int <- base::seq.int
[16:04:48.483]             signalCondition <- base::signalCondition
[16:04:48.483]             sys.calls <- base::sys.calls
[16:04:48.483]             `[[` <- base::`[[`
[16:04:48.483]             `+` <- base::`+`
[16:04:48.483]             `<<-` <- base::`<<-`
[16:04:48.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.483]                   3L)]
[16:04:48.483]             }
[16:04:48.483]             function(cond) {
[16:04:48.483]                 is_error <- inherits(cond, "error")
[16:04:48.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.483]                   NULL)
[16:04:48.483]                 if (is_error) {
[16:04:48.483]                   sessionInformation <- function() {
[16:04:48.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.483]                       search = base::search(), system = base::Sys.info())
[16:04:48.483]                   }
[16:04:48.483]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.483]                     cond$call), session = sessionInformation(), 
[16:04:48.483]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.483]                   signalCondition(cond)
[16:04:48.483]                 }
[16:04:48.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.483]                 "immediateCondition"))) {
[16:04:48.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.483]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.483]                   if (TRUE && !signal) {
[16:04:48.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.483]                     {
[16:04:48.483]                       inherits <- base::inherits
[16:04:48.483]                       invokeRestart <- base::invokeRestart
[16:04:48.483]                       is.null <- base::is.null
[16:04:48.483]                       muffled <- FALSE
[16:04:48.483]                       if (inherits(cond, "message")) {
[16:04:48.483]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.483]                         if (muffled) 
[16:04:48.483]                           invokeRestart("muffleMessage")
[16:04:48.483]                       }
[16:04:48.483]                       else if (inherits(cond, "warning")) {
[16:04:48.483]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.483]                         if (muffled) 
[16:04:48.483]                           invokeRestart("muffleWarning")
[16:04:48.483]                       }
[16:04:48.483]                       else if (inherits(cond, "condition")) {
[16:04:48.483]                         if (!is.null(pattern)) {
[16:04:48.483]                           computeRestarts <- base::computeRestarts
[16:04:48.483]                           grepl <- base::grepl
[16:04:48.483]                           restarts <- computeRestarts(cond)
[16:04:48.483]                           for (restart in restarts) {
[16:04:48.483]                             name <- restart$name
[16:04:48.483]                             if (is.null(name)) 
[16:04:48.483]                               next
[16:04:48.483]                             if (!grepl(pattern, name)) 
[16:04:48.483]                               next
[16:04:48.483]                             invokeRestart(restart)
[16:04:48.483]                             muffled <- TRUE
[16:04:48.483]                             break
[16:04:48.483]                           }
[16:04:48.483]                         }
[16:04:48.483]                       }
[16:04:48.483]                       invisible(muffled)
[16:04:48.483]                     }
[16:04:48.483]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.483]                   }
[16:04:48.483]                 }
[16:04:48.483]                 else {
[16:04:48.483]                   if (TRUE) {
[16:04:48.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.483]                     {
[16:04:48.483]                       inherits <- base::inherits
[16:04:48.483]                       invokeRestart <- base::invokeRestart
[16:04:48.483]                       is.null <- base::is.null
[16:04:48.483]                       muffled <- FALSE
[16:04:48.483]                       if (inherits(cond, "message")) {
[16:04:48.483]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.483]                         if (muffled) 
[16:04:48.483]                           invokeRestart("muffleMessage")
[16:04:48.483]                       }
[16:04:48.483]                       else if (inherits(cond, "warning")) {
[16:04:48.483]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.483]                         if (muffled) 
[16:04:48.483]                           invokeRestart("muffleWarning")
[16:04:48.483]                       }
[16:04:48.483]                       else if (inherits(cond, "condition")) {
[16:04:48.483]                         if (!is.null(pattern)) {
[16:04:48.483]                           computeRestarts <- base::computeRestarts
[16:04:48.483]                           grepl <- base::grepl
[16:04:48.483]                           restarts <- computeRestarts(cond)
[16:04:48.483]                           for (restart in restarts) {
[16:04:48.483]                             name <- restart$name
[16:04:48.483]                             if (is.null(name)) 
[16:04:48.483]                               next
[16:04:48.483]                             if (!grepl(pattern, name)) 
[16:04:48.483]                               next
[16:04:48.483]                             invokeRestart(restart)
[16:04:48.483]                             muffled <- TRUE
[16:04:48.483]                             break
[16:04:48.483]                           }
[16:04:48.483]                         }
[16:04:48.483]                       }
[16:04:48.483]                       invisible(muffled)
[16:04:48.483]                     }
[16:04:48.483]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.483]                   }
[16:04:48.483]                 }
[16:04:48.483]             }
[16:04:48.483]         }))
[16:04:48.483]     }, error = function(ex) {
[16:04:48.483]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.483]                 ...future.rng), started = ...future.startTime, 
[16:04:48.483]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.483]             version = "1.8"), class = "FutureResult")
[16:04:48.483]     }, finally = {
[16:04:48.483]         if (!identical(...future.workdir, getwd())) 
[16:04:48.483]             setwd(...future.workdir)
[16:04:48.483]         {
[16:04:48.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.483]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.483]             }
[16:04:48.483]             base::options(...future.oldOptions)
[16:04:48.483]             if (.Platform$OS.type == "windows") {
[16:04:48.483]                 old_names <- names(...future.oldEnvVars)
[16:04:48.483]                 envs <- base::Sys.getenv()
[16:04:48.483]                 names <- names(envs)
[16:04:48.483]                 common <- intersect(names, old_names)
[16:04:48.483]                 added <- setdiff(names, old_names)
[16:04:48.483]                 removed <- setdiff(old_names, names)
[16:04:48.483]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.483]                   envs[common]]
[16:04:48.483]                 NAMES <- toupper(changed)
[16:04:48.483]                 args <- list()
[16:04:48.483]                 for (kk in seq_along(NAMES)) {
[16:04:48.483]                   name <- changed[[kk]]
[16:04:48.483]                   NAME <- NAMES[[kk]]
[16:04:48.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.483]                     next
[16:04:48.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.483]                 }
[16:04:48.483]                 NAMES <- toupper(added)
[16:04:48.483]                 for (kk in seq_along(NAMES)) {
[16:04:48.483]                   name <- added[[kk]]
[16:04:48.483]                   NAME <- NAMES[[kk]]
[16:04:48.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.483]                     next
[16:04:48.483]                   args[[name]] <- ""
[16:04:48.483]                 }
[16:04:48.483]                 NAMES <- toupper(removed)
[16:04:48.483]                 for (kk in seq_along(NAMES)) {
[16:04:48.483]                   name <- removed[[kk]]
[16:04:48.483]                   NAME <- NAMES[[kk]]
[16:04:48.483]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.483]                     next
[16:04:48.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.483]                 }
[16:04:48.483]                 if (length(args) > 0) 
[16:04:48.483]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.483]             }
[16:04:48.483]             else {
[16:04:48.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.483]             }
[16:04:48.483]             {
[16:04:48.483]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.483]                   0L) {
[16:04:48.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.483]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.483]                   base::options(opts)
[16:04:48.483]                 }
[16:04:48.483]                 {
[16:04:48.483]                   {
[16:04:48.483]                     NULL
[16:04:48.483]                     RNGkind("Mersenne-Twister")
[16:04:48.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.483]                       inherits = FALSE)
[16:04:48.483]                   }
[16:04:48.483]                   options(future.plan = NULL)
[16:04:48.483]                   if (is.na(NA_character_)) 
[16:04:48.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.483]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.483]                   {
[16:04:48.483]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.483]                     if (!future$lazy) 
[16:04:48.483]                       future <- run(future)
[16:04:48.483]                     invisible(future)
[16:04:48.483]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.483]                 }
[16:04:48.483]             }
[16:04:48.483]         }
[16:04:48.483]     })
[16:04:48.483]     if (TRUE) {
[16:04:48.483]         base::sink(type = "output", split = FALSE)
[16:04:48.483]         if (TRUE) {
[16:04:48.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.483]         }
[16:04:48.483]         else {
[16:04:48.483]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.483]         }
[16:04:48.483]         base::close(...future.stdout)
[16:04:48.483]         ...future.stdout <- NULL
[16:04:48.483]     }
[16:04:48.483]     ...future.result$conditions <- ...future.conditions
[16:04:48.483]     ...future.result$finished <- base::Sys.time()
[16:04:48.483]     ...future.result
[16:04:48.483] }
[16:04:48.485] plan(): Setting new future strategy stack:
[16:04:48.485] List of future strategies:
[16:04:48.485] 1. sequential:
[16:04:48.485]    - args: function (..., envir = parent.frame())
[16:04:48.485]    - tweaked: FALSE
[16:04:48.485]    - call: NULL
[16:04:48.486] plan(): nbrOfWorkers() = 1
[16:04:48.487] plan(): Setting new future strategy stack:
[16:04:48.487] List of future strategies:
[16:04:48.487] 1. sequential:
[16:04:48.487]    - args: function (..., envir = parent.frame())
[16:04:48.487]    - tweaked: FALSE
[16:04:48.487]    - call: plan(strategy)
[16:04:48.488] plan(): nbrOfWorkers() = 1
[16:04:48.488] SequentialFuture started (and completed)
[16:04:48.488] - Launch lazy future ... done
[16:04:48.488] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:04:48.490] getGlobalsAndPackages() ...
[16:04:48.490] Searching for globals...
[16:04:48.495] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:48.495] Searching for globals ... DONE
[16:04:48.495] Resolving globals: FALSE
[16:04:48.496] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:48.496] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:48.496] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:48.497] 
[16:04:48.497] getGlobalsAndPackages() ... DONE
[16:04:48.497] run() for ‘Future’ ...
[16:04:48.497] - state: ‘created’
[16:04:48.497] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.498]   - Field: ‘label’
[16:04:48.498]   - Field: ‘local’
[16:04:48.498]   - Field: ‘owner’
[16:04:48.498]   - Field: ‘envir’
[16:04:48.498]   - Field: ‘packages’
[16:04:48.498]   - Field: ‘gc’
[16:04:48.498]   - Field: ‘conditions’
[16:04:48.498]   - Field: ‘expr’
[16:04:48.498]   - Field: ‘uuid’
[16:04:48.498]   - Field: ‘seed’
[16:04:48.498]   - Field: ‘version’
[16:04:48.499]   - Field: ‘result’
[16:04:48.499]   - Field: ‘asynchronous’
[16:04:48.499]   - Field: ‘calls’
[16:04:48.499]   - Field: ‘globals’
[16:04:48.499]   - Field: ‘stdout’
[16:04:48.499]   - Field: ‘earlySignal’
[16:04:48.499]   - Field: ‘lazy’
[16:04:48.499]   - Field: ‘state’
[16:04:48.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.499] - Launch lazy future ...
[16:04:48.500] Packages needed by the future expression (n = 0): <none>
[16:04:48.500] Packages needed by future strategies (n = 0): <none>
[16:04:48.500] {
[16:04:48.500]     {
[16:04:48.500]         {
[16:04:48.500]             ...future.startTime <- base::Sys.time()
[16:04:48.500]             {
[16:04:48.500]                 {
[16:04:48.500]                   {
[16:04:48.500]                     base::local({
[16:04:48.500]                       has_future <- base::requireNamespace("future", 
[16:04:48.500]                         quietly = TRUE)
[16:04:48.500]                       if (has_future) {
[16:04:48.500]                         ns <- base::getNamespace("future")
[16:04:48.500]                         version <- ns[[".package"]][["version"]]
[16:04:48.500]                         if (is.null(version)) 
[16:04:48.500]                           version <- utils::packageVersion("future")
[16:04:48.500]                       }
[16:04:48.500]                       else {
[16:04:48.500]                         version <- NULL
[16:04:48.500]                       }
[16:04:48.500]                       if (!has_future || version < "1.8.0") {
[16:04:48.500]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.500]                           "", base::R.version$version.string), 
[16:04:48.500]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:48.500]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.500]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.500]                             "release", "version")], collapse = " "), 
[16:04:48.500]                           hostname = base::Sys.info()[["nodename"]])
[16:04:48.500]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.500]                           info)
[16:04:48.500]                         info <- base::paste(info, collapse = "; ")
[16:04:48.500]                         if (!has_future) {
[16:04:48.500]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.500]                             info)
[16:04:48.500]                         }
[16:04:48.500]                         else {
[16:04:48.500]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.500]                             info, version)
[16:04:48.500]                         }
[16:04:48.500]                         base::stop(msg)
[16:04:48.500]                       }
[16:04:48.500]                     })
[16:04:48.500]                   }
[16:04:48.500]                   options(future.plan = NULL)
[16:04:48.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.500]                 }
[16:04:48.500]                 ...future.workdir <- getwd()
[16:04:48.500]             }
[16:04:48.500]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.500]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.500]         }
[16:04:48.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.500]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.500]             base::names(...future.oldOptions))
[16:04:48.500]     }
[16:04:48.500]     if (FALSE) {
[16:04:48.500]     }
[16:04:48.500]     else {
[16:04:48.500]         if (TRUE) {
[16:04:48.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.500]                 open = "w")
[16:04:48.500]         }
[16:04:48.500]         else {
[16:04:48.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.500]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.500]         }
[16:04:48.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.500]             base::sink(type = "output", split = FALSE)
[16:04:48.500]             base::close(...future.stdout)
[16:04:48.500]         }, add = TRUE)
[16:04:48.500]     }
[16:04:48.500]     ...future.frame <- base::sys.nframe()
[16:04:48.500]     ...future.conditions <- base::list()
[16:04:48.500]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.500]     if (FALSE) {
[16:04:48.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.500]     }
[16:04:48.500]     ...future.result <- base::tryCatch({
[16:04:48.500]         base::withCallingHandlers({
[16:04:48.500]             ...future.value <- base::withVisible(base::local({
[16:04:48.500]                 outer_function(1L)
[16:04:48.500]             }))
[16:04:48.500]             future::FutureResult(value = ...future.value$value, 
[16:04:48.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.500]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.500]                     ...future.globalenv.names))
[16:04:48.500]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.500]         }, condition = base::local({
[16:04:48.500]             c <- base::c
[16:04:48.500]             inherits <- base::inherits
[16:04:48.500]             invokeRestart <- base::invokeRestart
[16:04:48.500]             length <- base::length
[16:04:48.500]             list <- base::list
[16:04:48.500]             seq.int <- base::seq.int
[16:04:48.500]             signalCondition <- base::signalCondition
[16:04:48.500]             sys.calls <- base::sys.calls
[16:04:48.500]             `[[` <- base::`[[`
[16:04:48.500]             `+` <- base::`+`
[16:04:48.500]             `<<-` <- base::`<<-`
[16:04:48.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.500]                   3L)]
[16:04:48.500]             }
[16:04:48.500]             function(cond) {
[16:04:48.500]                 is_error <- inherits(cond, "error")
[16:04:48.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.500]                   NULL)
[16:04:48.500]                 if (is_error) {
[16:04:48.500]                   sessionInformation <- function() {
[16:04:48.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.500]                       search = base::search(), system = base::Sys.info())
[16:04:48.500]                   }
[16:04:48.500]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.500]                     cond$call), session = sessionInformation(), 
[16:04:48.500]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.500]                   signalCondition(cond)
[16:04:48.500]                 }
[16:04:48.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.500]                 "immediateCondition"))) {
[16:04:48.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.500]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.500]                   if (TRUE && !signal) {
[16:04:48.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.500]                     {
[16:04:48.500]                       inherits <- base::inherits
[16:04:48.500]                       invokeRestart <- base::invokeRestart
[16:04:48.500]                       is.null <- base::is.null
[16:04:48.500]                       muffled <- FALSE
[16:04:48.500]                       if (inherits(cond, "message")) {
[16:04:48.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.500]                         if (muffled) 
[16:04:48.500]                           invokeRestart("muffleMessage")
[16:04:48.500]                       }
[16:04:48.500]                       else if (inherits(cond, "warning")) {
[16:04:48.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.500]                         if (muffled) 
[16:04:48.500]                           invokeRestart("muffleWarning")
[16:04:48.500]                       }
[16:04:48.500]                       else if (inherits(cond, "condition")) {
[16:04:48.500]                         if (!is.null(pattern)) {
[16:04:48.500]                           computeRestarts <- base::computeRestarts
[16:04:48.500]                           grepl <- base::grepl
[16:04:48.500]                           restarts <- computeRestarts(cond)
[16:04:48.500]                           for (restart in restarts) {
[16:04:48.500]                             name <- restart$name
[16:04:48.500]                             if (is.null(name)) 
[16:04:48.500]                               next
[16:04:48.500]                             if (!grepl(pattern, name)) 
[16:04:48.500]                               next
[16:04:48.500]                             invokeRestart(restart)
[16:04:48.500]                             muffled <- TRUE
[16:04:48.500]                             break
[16:04:48.500]                           }
[16:04:48.500]                         }
[16:04:48.500]                       }
[16:04:48.500]                       invisible(muffled)
[16:04:48.500]                     }
[16:04:48.500]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.500]                   }
[16:04:48.500]                 }
[16:04:48.500]                 else {
[16:04:48.500]                   if (TRUE) {
[16:04:48.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.500]                     {
[16:04:48.500]                       inherits <- base::inherits
[16:04:48.500]                       invokeRestart <- base::invokeRestart
[16:04:48.500]                       is.null <- base::is.null
[16:04:48.500]                       muffled <- FALSE
[16:04:48.500]                       if (inherits(cond, "message")) {
[16:04:48.500]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.500]                         if (muffled) 
[16:04:48.500]                           invokeRestart("muffleMessage")
[16:04:48.500]                       }
[16:04:48.500]                       else if (inherits(cond, "warning")) {
[16:04:48.500]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.500]                         if (muffled) 
[16:04:48.500]                           invokeRestart("muffleWarning")
[16:04:48.500]                       }
[16:04:48.500]                       else if (inherits(cond, "condition")) {
[16:04:48.500]                         if (!is.null(pattern)) {
[16:04:48.500]                           computeRestarts <- base::computeRestarts
[16:04:48.500]                           grepl <- base::grepl
[16:04:48.500]                           restarts <- computeRestarts(cond)
[16:04:48.500]                           for (restart in restarts) {
[16:04:48.500]                             name <- restart$name
[16:04:48.500]                             if (is.null(name)) 
[16:04:48.500]                               next
[16:04:48.500]                             if (!grepl(pattern, name)) 
[16:04:48.500]                               next
[16:04:48.500]                             invokeRestart(restart)
[16:04:48.500]                             muffled <- TRUE
[16:04:48.500]                             break
[16:04:48.500]                           }
[16:04:48.500]                         }
[16:04:48.500]                       }
[16:04:48.500]                       invisible(muffled)
[16:04:48.500]                     }
[16:04:48.500]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.500]                   }
[16:04:48.500]                 }
[16:04:48.500]             }
[16:04:48.500]         }))
[16:04:48.500]     }, error = function(ex) {
[16:04:48.500]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.500]                 ...future.rng), started = ...future.startTime, 
[16:04:48.500]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.500]             version = "1.8"), class = "FutureResult")
[16:04:48.500]     }, finally = {
[16:04:48.500]         if (!identical(...future.workdir, getwd())) 
[16:04:48.500]             setwd(...future.workdir)
[16:04:48.500]         {
[16:04:48.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.500]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.500]             }
[16:04:48.500]             base::options(...future.oldOptions)
[16:04:48.500]             if (.Platform$OS.type == "windows") {
[16:04:48.500]                 old_names <- names(...future.oldEnvVars)
[16:04:48.500]                 envs <- base::Sys.getenv()
[16:04:48.500]                 names <- names(envs)
[16:04:48.500]                 common <- intersect(names, old_names)
[16:04:48.500]                 added <- setdiff(names, old_names)
[16:04:48.500]                 removed <- setdiff(old_names, names)
[16:04:48.500]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.500]                   envs[common]]
[16:04:48.500]                 NAMES <- toupper(changed)
[16:04:48.500]                 args <- list()
[16:04:48.500]                 for (kk in seq_along(NAMES)) {
[16:04:48.500]                   name <- changed[[kk]]
[16:04:48.500]                   NAME <- NAMES[[kk]]
[16:04:48.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.500]                     next
[16:04:48.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.500]                 }
[16:04:48.500]                 NAMES <- toupper(added)
[16:04:48.500]                 for (kk in seq_along(NAMES)) {
[16:04:48.500]                   name <- added[[kk]]
[16:04:48.500]                   NAME <- NAMES[[kk]]
[16:04:48.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.500]                     next
[16:04:48.500]                   args[[name]] <- ""
[16:04:48.500]                 }
[16:04:48.500]                 NAMES <- toupper(removed)
[16:04:48.500]                 for (kk in seq_along(NAMES)) {
[16:04:48.500]                   name <- removed[[kk]]
[16:04:48.500]                   NAME <- NAMES[[kk]]
[16:04:48.500]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.500]                     next
[16:04:48.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.500]                 }
[16:04:48.500]                 if (length(args) > 0) 
[16:04:48.500]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.500]             }
[16:04:48.500]             else {
[16:04:48.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.500]             }
[16:04:48.500]             {
[16:04:48.500]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.500]                   0L) {
[16:04:48.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.500]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.500]                   base::options(opts)
[16:04:48.500]                 }
[16:04:48.500]                 {
[16:04:48.500]                   {
[16:04:48.500]                     NULL
[16:04:48.500]                     RNGkind("Mersenne-Twister")
[16:04:48.500]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.500]                       inherits = FALSE)
[16:04:48.500]                   }
[16:04:48.500]                   options(future.plan = NULL)
[16:04:48.500]                   if (is.na(NA_character_)) 
[16:04:48.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.500]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.500]                   {
[16:04:48.500]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.500]                     if (!future$lazy) 
[16:04:48.500]                       future <- run(future)
[16:04:48.500]                     invisible(future)
[16:04:48.500]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.500]                 }
[16:04:48.500]             }
[16:04:48.500]         }
[16:04:48.500]     })
[16:04:48.500]     if (TRUE) {
[16:04:48.500]         base::sink(type = "output", split = FALSE)
[16:04:48.500]         if (TRUE) {
[16:04:48.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.500]         }
[16:04:48.500]         else {
[16:04:48.500]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.500]         }
[16:04:48.500]         base::close(...future.stdout)
[16:04:48.500]         ...future.stdout <- NULL
[16:04:48.500]     }
[16:04:48.500]     ...future.result$conditions <- ...future.conditions
[16:04:48.500]     ...future.result$finished <- base::Sys.time()
[16:04:48.500]     ...future.result
[16:04:48.500] }
[16:04:48.502] assign_globals() ...
[16:04:48.502] List of 3
[16:04:48.502]  $ outer_function:function (x)  
[16:04:48.502]  $ map           :function (.x, .f, ...)  
[16:04:48.502]  $ inner_function:function (x)  
[16:04:48.502]  - attr(*, "where")=List of 3
[16:04:48.502]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:04:48.502]   ..$ map           :<environment: R_EmptyEnv> 
[16:04:48.502]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:04:48.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.502]  - attr(*, "resolved")= logi FALSE
[16:04:48.502]  - attr(*, "total_size")= num 7704
[16:04:48.502]  - attr(*, "already-done")= logi TRUE
[16:04:48.505] - reassign environment for ‘outer_function’
[16:04:48.505] - copied ‘outer_function’ to environment
[16:04:48.505] - reassign environment for ‘map’
[16:04:48.505] - copied ‘map’ to environment
[16:04:48.505] - reassign environment for ‘inner_function’
[16:04:48.505] - copied ‘inner_function’ to environment
[16:04:48.505] assign_globals() ... done
[16:04:48.505] plan(): Setting new future strategy stack:
[16:04:48.506] List of future strategies:
[16:04:48.506] 1. sequential:
[16:04:48.506]    - args: function (..., envir = parent.frame())
[16:04:48.506]    - tweaked: FALSE
[16:04:48.506]    - call: NULL
[16:04:48.506] plan(): nbrOfWorkers() = 1
[16:04:48.511] plan(): Setting new future strategy stack:
[16:04:48.511] List of future strategies:
[16:04:48.511] 1. sequential:
[16:04:48.511]    - args: function (..., envir = parent.frame())
[16:04:48.511]    - tweaked: FALSE
[16:04:48.511]    - call: plan(strategy)
[16:04:48.511] plan(): nbrOfWorkers() = 1
[16:04:48.511] SequentialFuture started (and completed)
[16:04:48.511] - Launch lazy future ... done
[16:04:48.511] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:04:48.513] getGlobalsAndPackages() ...
[16:04:48.513] Searching for globals...
[16:04:48.517] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:48.517] Searching for globals ... DONE
[16:04:48.517] Resolving globals: FALSE
[16:04:48.518] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:48.518] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:48.519] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:48.519] 
[16:04:48.519] getGlobalsAndPackages() ... DONE
[16:04:48.519] run() for ‘Future’ ...
[16:04:48.519] - state: ‘created’
[16:04:48.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:48.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:48.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:48.520]   - Field: ‘label’
[16:04:48.520]   - Field: ‘local’
[16:04:48.520]   - Field: ‘owner’
[16:04:48.520]   - Field: ‘envir’
[16:04:48.520]   - Field: ‘packages’
[16:04:48.520]   - Field: ‘gc’
[16:04:48.520]   - Field: ‘conditions’
[16:04:48.520]   - Field: ‘expr’
[16:04:48.520]   - Field: ‘uuid’
[16:04:48.520]   - Field: ‘seed’
[16:04:48.520]   - Field: ‘version’
[16:04:48.521]   - Field: ‘result’
[16:04:48.521]   - Field: ‘asynchronous’
[16:04:48.521]   - Field: ‘calls’
[16:04:48.521]   - Field: ‘globals’
[16:04:48.521]   - Field: ‘stdout’
[16:04:48.521]   - Field: ‘earlySignal’
[16:04:48.521]   - Field: ‘lazy’
[16:04:48.521]   - Field: ‘state’
[16:04:48.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:48.521] - Launch lazy future ...
[16:04:48.521] Packages needed by the future expression (n = 0): <none>
[16:04:48.522] Packages needed by future strategies (n = 0): <none>
[16:04:48.522] {
[16:04:48.522]     {
[16:04:48.522]         {
[16:04:48.522]             ...future.startTime <- base::Sys.time()
[16:04:48.522]             {
[16:04:48.522]                 {
[16:04:48.522]                   {
[16:04:48.522]                     base::local({
[16:04:48.522]                       has_future <- base::requireNamespace("future", 
[16:04:48.522]                         quietly = TRUE)
[16:04:48.522]                       if (has_future) {
[16:04:48.522]                         ns <- base::getNamespace("future")
[16:04:48.522]                         version <- ns[[".package"]][["version"]]
[16:04:48.522]                         if (is.null(version)) 
[16:04:48.522]                           version <- utils::packageVersion("future")
[16:04:48.522]                       }
[16:04:48.522]                       else {
[16:04:48.522]                         version <- NULL
[16:04:48.522]                       }
[16:04:48.522]                       if (!has_future || version < "1.8.0") {
[16:04:48.522]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.522]                           "", base::R.version$version.string), 
[16:04:48.522]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:48.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:48.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.522]                             "release", "version")], collapse = " "), 
[16:04:48.522]                           hostname = base::Sys.info()[["nodename"]])
[16:04:48.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.522]                           info)
[16:04:48.522]                         info <- base::paste(info, collapse = "; ")
[16:04:48.522]                         if (!has_future) {
[16:04:48.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.522]                             info)
[16:04:48.522]                         }
[16:04:48.522]                         else {
[16:04:48.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.522]                             info, version)
[16:04:48.522]                         }
[16:04:48.522]                         base::stop(msg)
[16:04:48.522]                       }
[16:04:48.522]                     })
[16:04:48.522]                   }
[16:04:48.522]                   options(future.plan = NULL)
[16:04:48.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.522]                 }
[16:04:48.522]                 ...future.workdir <- getwd()
[16:04:48.522]             }
[16:04:48.522]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.522]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.522]         }
[16:04:48.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.522]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.522]             base::names(...future.oldOptions))
[16:04:48.522]     }
[16:04:48.522]     if (FALSE) {
[16:04:48.522]     }
[16:04:48.522]     else {
[16:04:48.522]         if (TRUE) {
[16:04:48.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.522]                 open = "w")
[16:04:48.522]         }
[16:04:48.522]         else {
[16:04:48.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.522]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.522]         }
[16:04:48.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.522]             base::sink(type = "output", split = FALSE)
[16:04:48.522]             base::close(...future.stdout)
[16:04:48.522]         }, add = TRUE)
[16:04:48.522]     }
[16:04:48.522]     ...future.frame <- base::sys.nframe()
[16:04:48.522]     ...future.conditions <- base::list()
[16:04:48.522]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.522]     if (FALSE) {
[16:04:48.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.522]     }
[16:04:48.522]     ...future.result <- base::tryCatch({
[16:04:48.522]         base::withCallingHandlers({
[16:04:48.522]             ...future.value <- base::withVisible(base::local({
[16:04:48.522]                 outer_function(1L)
[16:04:48.522]             }))
[16:04:48.522]             future::FutureResult(value = ...future.value$value, 
[16:04:48.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.522]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.522]                     ...future.globalenv.names))
[16:04:48.522]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.522]         }, condition = base::local({
[16:04:48.522]             c <- base::c
[16:04:48.522]             inherits <- base::inherits
[16:04:48.522]             invokeRestart <- base::invokeRestart
[16:04:48.522]             length <- base::length
[16:04:48.522]             list <- base::list
[16:04:48.522]             seq.int <- base::seq.int
[16:04:48.522]             signalCondition <- base::signalCondition
[16:04:48.522]             sys.calls <- base::sys.calls
[16:04:48.522]             `[[` <- base::`[[`
[16:04:48.522]             `+` <- base::`+`
[16:04:48.522]             `<<-` <- base::`<<-`
[16:04:48.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.522]                   3L)]
[16:04:48.522]             }
[16:04:48.522]             function(cond) {
[16:04:48.522]                 is_error <- inherits(cond, "error")
[16:04:48.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.522]                   NULL)
[16:04:48.522]                 if (is_error) {
[16:04:48.522]                   sessionInformation <- function() {
[16:04:48.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.522]                       search = base::search(), system = base::Sys.info())
[16:04:48.522]                   }
[16:04:48.522]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.522]                     cond$call), session = sessionInformation(), 
[16:04:48.522]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.522]                   signalCondition(cond)
[16:04:48.522]                 }
[16:04:48.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.522]                 "immediateCondition"))) {
[16:04:48.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.522]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.522]                   if (TRUE && !signal) {
[16:04:48.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.522]                     {
[16:04:48.522]                       inherits <- base::inherits
[16:04:48.522]                       invokeRestart <- base::invokeRestart
[16:04:48.522]                       is.null <- base::is.null
[16:04:48.522]                       muffled <- FALSE
[16:04:48.522]                       if (inherits(cond, "message")) {
[16:04:48.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.522]                         if (muffled) 
[16:04:48.522]                           invokeRestart("muffleMessage")
[16:04:48.522]                       }
[16:04:48.522]                       else if (inherits(cond, "warning")) {
[16:04:48.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.522]                         if (muffled) 
[16:04:48.522]                           invokeRestart("muffleWarning")
[16:04:48.522]                       }
[16:04:48.522]                       else if (inherits(cond, "condition")) {
[16:04:48.522]                         if (!is.null(pattern)) {
[16:04:48.522]                           computeRestarts <- base::computeRestarts
[16:04:48.522]                           grepl <- base::grepl
[16:04:48.522]                           restarts <- computeRestarts(cond)
[16:04:48.522]                           for (restart in restarts) {
[16:04:48.522]                             name <- restart$name
[16:04:48.522]                             if (is.null(name)) 
[16:04:48.522]                               next
[16:04:48.522]                             if (!grepl(pattern, name)) 
[16:04:48.522]                               next
[16:04:48.522]                             invokeRestart(restart)
[16:04:48.522]                             muffled <- TRUE
[16:04:48.522]                             break
[16:04:48.522]                           }
[16:04:48.522]                         }
[16:04:48.522]                       }
[16:04:48.522]                       invisible(muffled)
[16:04:48.522]                     }
[16:04:48.522]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.522]                   }
[16:04:48.522]                 }
[16:04:48.522]                 else {
[16:04:48.522]                   if (TRUE) {
[16:04:48.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.522]                     {
[16:04:48.522]                       inherits <- base::inherits
[16:04:48.522]                       invokeRestart <- base::invokeRestart
[16:04:48.522]                       is.null <- base::is.null
[16:04:48.522]                       muffled <- FALSE
[16:04:48.522]                       if (inherits(cond, "message")) {
[16:04:48.522]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.522]                         if (muffled) 
[16:04:48.522]                           invokeRestart("muffleMessage")
[16:04:48.522]                       }
[16:04:48.522]                       else if (inherits(cond, "warning")) {
[16:04:48.522]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.522]                         if (muffled) 
[16:04:48.522]                           invokeRestart("muffleWarning")
[16:04:48.522]                       }
[16:04:48.522]                       else if (inherits(cond, "condition")) {
[16:04:48.522]                         if (!is.null(pattern)) {
[16:04:48.522]                           computeRestarts <- base::computeRestarts
[16:04:48.522]                           grepl <- base::grepl
[16:04:48.522]                           restarts <- computeRestarts(cond)
[16:04:48.522]                           for (restart in restarts) {
[16:04:48.522]                             name <- restart$name
[16:04:48.522]                             if (is.null(name)) 
[16:04:48.522]                               next
[16:04:48.522]                             if (!grepl(pattern, name)) 
[16:04:48.522]                               next
[16:04:48.522]                             invokeRestart(restart)
[16:04:48.522]                             muffled <- TRUE
[16:04:48.522]                             break
[16:04:48.522]                           }
[16:04:48.522]                         }
[16:04:48.522]                       }
[16:04:48.522]                       invisible(muffled)
[16:04:48.522]                     }
[16:04:48.522]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.522]                   }
[16:04:48.522]                 }
[16:04:48.522]             }
[16:04:48.522]         }))
[16:04:48.522]     }, error = function(ex) {
[16:04:48.522]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.522]                 ...future.rng), started = ...future.startTime, 
[16:04:48.522]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.522]             version = "1.8"), class = "FutureResult")
[16:04:48.522]     }, finally = {
[16:04:48.522]         if (!identical(...future.workdir, getwd())) 
[16:04:48.522]             setwd(...future.workdir)
[16:04:48.522]         {
[16:04:48.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.522]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.522]             }
[16:04:48.522]             base::options(...future.oldOptions)
[16:04:48.522]             if (.Platform$OS.type == "windows") {
[16:04:48.522]                 old_names <- names(...future.oldEnvVars)
[16:04:48.522]                 envs <- base::Sys.getenv()
[16:04:48.522]                 names <- names(envs)
[16:04:48.522]                 common <- intersect(names, old_names)
[16:04:48.522]                 added <- setdiff(names, old_names)
[16:04:48.522]                 removed <- setdiff(old_names, names)
[16:04:48.522]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.522]                   envs[common]]
[16:04:48.522]                 NAMES <- toupper(changed)
[16:04:48.522]                 args <- list()
[16:04:48.522]                 for (kk in seq_along(NAMES)) {
[16:04:48.522]                   name <- changed[[kk]]
[16:04:48.522]                   NAME <- NAMES[[kk]]
[16:04:48.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.522]                     next
[16:04:48.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.522]                 }
[16:04:48.522]                 NAMES <- toupper(added)
[16:04:48.522]                 for (kk in seq_along(NAMES)) {
[16:04:48.522]                   name <- added[[kk]]
[16:04:48.522]                   NAME <- NAMES[[kk]]
[16:04:48.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.522]                     next
[16:04:48.522]                   args[[name]] <- ""
[16:04:48.522]                 }
[16:04:48.522]                 NAMES <- toupper(removed)
[16:04:48.522]                 for (kk in seq_along(NAMES)) {
[16:04:48.522]                   name <- removed[[kk]]
[16:04:48.522]                   NAME <- NAMES[[kk]]
[16:04:48.522]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.522]                     next
[16:04:48.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.522]                 }
[16:04:48.522]                 if (length(args) > 0) 
[16:04:48.522]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.522]             }
[16:04:48.522]             else {
[16:04:48.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.522]             }
[16:04:48.522]             {
[16:04:48.522]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.522]                   0L) {
[16:04:48.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.522]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.522]                   base::options(opts)
[16:04:48.522]                 }
[16:04:48.522]                 {
[16:04:48.522]                   {
[16:04:48.522]                     NULL
[16:04:48.522]                     RNGkind("Mersenne-Twister")
[16:04:48.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:48.522]                       inherits = FALSE)
[16:04:48.522]                   }
[16:04:48.522]                   options(future.plan = NULL)
[16:04:48.522]                   if (is.na(NA_character_)) 
[16:04:48.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.522]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:48.522]                   {
[16:04:48.522]                     future <- SequentialFuture(..., envir = envir)
[16:04:48.522]                     if (!future$lazy) 
[16:04:48.522]                       future <- run(future)
[16:04:48.522]                     invisible(future)
[16:04:48.522]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.522]                 }
[16:04:48.522]             }
[16:04:48.522]         }
[16:04:48.522]     })
[16:04:48.522]     if (TRUE) {
[16:04:48.522]         base::sink(type = "output", split = FALSE)
[16:04:48.522]         if (TRUE) {
[16:04:48.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.522]         }
[16:04:48.522]         else {
[16:04:48.522]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.522]         }
[16:04:48.522]         base::close(...future.stdout)
[16:04:48.522]         ...future.stdout <- NULL
[16:04:48.522]     }
[16:04:48.522]     ...future.result$conditions <- ...future.conditions
[16:04:48.522]     ...future.result$finished <- base::Sys.time()
[16:04:48.522]     ...future.result
[16:04:48.522] }
[16:04:48.523] assign_globals() ...
[16:04:48.524] List of 3
[16:04:48.524]  $ outer_function:function (x)  
[16:04:48.524]  $ map           :function (.x, .f, ...)  
[16:04:48.524]  $ inner_function:function (x)  
[16:04:48.524]  - attr(*, "where")=List of 3
[16:04:48.524]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:04:48.524]   ..$ map           :<environment: R_EmptyEnv> 
[16:04:48.524]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:04:48.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.524]  - attr(*, "resolved")= logi FALSE
[16:04:48.524]  - attr(*, "total_size")= num 7704
[16:04:48.524]  - attr(*, "already-done")= logi TRUE
[16:04:48.527] - reassign environment for ‘outer_function’
[16:04:48.527] - copied ‘outer_function’ to environment
[16:04:48.527] - reassign environment for ‘map’
[16:04:48.527] - copied ‘map’ to environment
[16:04:48.527] - reassign environment for ‘inner_function’
[16:04:48.527] - copied ‘inner_function’ to environment
[16:04:48.527] assign_globals() ... done
[16:04:48.527] plan(): Setting new future strategy stack:
[16:04:48.527] List of future strategies:
[16:04:48.527] 1. sequential:
[16:04:48.527]    - args: function (..., envir = parent.frame())
[16:04:48.527]    - tweaked: FALSE
[16:04:48.527]    - call: NULL
[16:04:48.528] plan(): nbrOfWorkers() = 1
[16:04:48.528] plan(): Setting new future strategy stack:
[16:04:48.528] List of future strategies:
[16:04:48.528] 1. sequential:
[16:04:48.528]    - args: function (..., envir = parent.frame())
[16:04:48.528]    - tweaked: FALSE
[16:04:48.528]    - call: plan(strategy)
[16:04:48.529] plan(): nbrOfWorkers() = 1
[16:04:48.529] SequentialFuture started (and completed)
[16:04:48.529] - Launch lazy future ... done
[16:04:48.529] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[16:04:48.539] plan(): Setting new future strategy stack:
[16:04:48.539] List of future strategies:
[16:04:48.539] 1. multicore:
[16:04:48.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.539]    - tweaked: FALSE
[16:04:48.539]    - call: plan(strategy)
[16:04:48.543] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:04:48.543] getGlobalsAndPackages() ...
[16:04:48.543] Searching for globals...
[16:04:48.544] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.544] Searching for globals ... DONE
[16:04:48.545] Resolving globals: FALSE
[16:04:48.545] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.545] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.545] - globals: [2] ‘weight’, ‘group’
[16:04:48.546] - packages: [1] ‘stats’
[16:04:48.546] getGlobalsAndPackages() ... DONE
[16:04:48.546] run() for ‘Future’ ...
[16:04:48.546] - state: ‘created’
[16:04:48.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.550]   - Field: ‘label’
[16:04:48.550]   - Field: ‘local’
[16:04:48.550]   - Field: ‘owner’
[16:04:48.550]   - Field: ‘envir’
[16:04:48.550]   - Field: ‘workers’
[16:04:48.550]   - Field: ‘packages’
[16:04:48.550]   - Field: ‘gc’
[16:04:48.550]   - Field: ‘job’
[16:04:48.550]   - Field: ‘conditions’
[16:04:48.551]   - Field: ‘expr’
[16:04:48.551]   - Field: ‘uuid’
[16:04:48.551]   - Field: ‘seed’
[16:04:48.551]   - Field: ‘version’
[16:04:48.551]   - Field: ‘result’
[16:04:48.551]   - Field: ‘asynchronous’
[16:04:48.551]   - Field: ‘calls’
[16:04:48.551]   - Field: ‘globals’
[16:04:48.551]   - Field: ‘stdout’
[16:04:48.551]   - Field: ‘earlySignal’
[16:04:48.551]   - Field: ‘lazy’
[16:04:48.552]   - Field: ‘state’
[16:04:48.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.552] - Launch lazy future ...
[16:04:48.553] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.553] Packages needed by future strategies (n = 0): <none>
[16:04:48.553] {
[16:04:48.553]     {
[16:04:48.553]         {
[16:04:48.553]             ...future.startTime <- base::Sys.time()
[16:04:48.553]             {
[16:04:48.553]                 {
[16:04:48.553]                   {
[16:04:48.553]                     {
[16:04:48.553]                       {
[16:04:48.553]                         base::local({
[16:04:48.553]                           has_future <- base::requireNamespace("future", 
[16:04:48.553]                             quietly = TRUE)
[16:04:48.553]                           if (has_future) {
[16:04:48.553]                             ns <- base::getNamespace("future")
[16:04:48.553]                             version <- ns[[".package"]][["version"]]
[16:04:48.553]                             if (is.null(version)) 
[16:04:48.553]                               version <- utils::packageVersion("future")
[16:04:48.553]                           }
[16:04:48.553]                           else {
[16:04:48.553]                             version <- NULL
[16:04:48.553]                           }
[16:04:48.553]                           if (!has_future || version < "1.8.0") {
[16:04:48.553]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.553]                               "", base::R.version$version.string), 
[16:04:48.553]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.553]                                 base::R.version$platform, 8 * 
[16:04:48.553]                                   base::.Machine$sizeof.pointer), 
[16:04:48.553]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.553]                                 "release", "version")], collapse = " "), 
[16:04:48.553]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.553]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.553]                               info)
[16:04:48.553]                             info <- base::paste(info, collapse = "; ")
[16:04:48.553]                             if (!has_future) {
[16:04:48.553]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.553]                                 info)
[16:04:48.553]                             }
[16:04:48.553]                             else {
[16:04:48.553]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.553]                                 info, version)
[16:04:48.553]                             }
[16:04:48.553]                             base::stop(msg)
[16:04:48.553]                           }
[16:04:48.553]                         })
[16:04:48.553]                       }
[16:04:48.553]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.553]                       base::options(mc.cores = 1L)
[16:04:48.553]                     }
[16:04:48.553]                     base::local({
[16:04:48.553]                       for (pkg in "stats") {
[16:04:48.553]                         base::loadNamespace(pkg)
[16:04:48.553]                         base::library(pkg, character.only = TRUE)
[16:04:48.553]                       }
[16:04:48.553]                     })
[16:04:48.553]                   }
[16:04:48.553]                   options(future.plan = NULL)
[16:04:48.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.553]                 }
[16:04:48.553]                 ...future.workdir <- getwd()
[16:04:48.553]             }
[16:04:48.553]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.553]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.553]         }
[16:04:48.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.553]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.553]             base::names(...future.oldOptions))
[16:04:48.553]     }
[16:04:48.553]     if (FALSE) {
[16:04:48.553]     }
[16:04:48.553]     else {
[16:04:48.553]         if (TRUE) {
[16:04:48.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.553]                 open = "w")
[16:04:48.553]         }
[16:04:48.553]         else {
[16:04:48.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.553]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.553]         }
[16:04:48.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.553]             base::sink(type = "output", split = FALSE)
[16:04:48.553]             base::close(...future.stdout)
[16:04:48.553]         }, add = TRUE)
[16:04:48.553]     }
[16:04:48.553]     ...future.frame <- base::sys.nframe()
[16:04:48.553]     ...future.conditions <- base::list()
[16:04:48.553]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.553]     if (FALSE) {
[16:04:48.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.553]     }
[16:04:48.553]     ...future.result <- base::tryCatch({
[16:04:48.553]         base::withCallingHandlers({
[16:04:48.553]             ...future.value <- base::withVisible(base::local({
[16:04:48.553]                 withCallingHandlers({
[16:04:48.553]                   {
[16:04:48.553]                     lm(weight ~ group - 1)
[16:04:48.553]                   }
[16:04:48.553]                 }, immediateCondition = function(cond) {
[16:04:48.553]                   save_rds <- function (object, pathname, ...) 
[16:04:48.553]                   {
[16:04:48.553]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.553]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.553]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.553]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.553]                         fi_tmp[["mtime"]])
[16:04:48.553]                     }
[16:04:48.553]                     tryCatch({
[16:04:48.553]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.553]                     }, error = function(ex) {
[16:04:48.553]                       msg <- conditionMessage(ex)
[16:04:48.553]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.553]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.553]                         fi_tmp[["mtime"]], msg)
[16:04:48.553]                       ex$message <- msg
[16:04:48.553]                       stop(ex)
[16:04:48.553]                     })
[16:04:48.553]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.553]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.553]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.553]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.553]                       fi <- file.info(pathname)
[16:04:48.553]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.553]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.553]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.553]                         fi[["size"]], fi[["mtime"]])
[16:04:48.553]                       stop(msg)
[16:04:48.553]                     }
[16:04:48.553]                     invisible(pathname)
[16:04:48.553]                   }
[16:04:48.553]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.553]                     rootPath = tempdir()) 
[16:04:48.553]                   {
[16:04:48.553]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.553]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.553]                       tmpdir = path, fileext = ".rds")
[16:04:48.553]                     save_rds(obj, file)
[16:04:48.553]                   }
[16:04:48.553]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.553]                   {
[16:04:48.553]                     inherits <- base::inherits
[16:04:48.553]                     invokeRestart <- base::invokeRestart
[16:04:48.553]                     is.null <- base::is.null
[16:04:48.553]                     muffled <- FALSE
[16:04:48.553]                     if (inherits(cond, "message")) {
[16:04:48.553]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.553]                       if (muffled) 
[16:04:48.553]                         invokeRestart("muffleMessage")
[16:04:48.553]                     }
[16:04:48.553]                     else if (inherits(cond, "warning")) {
[16:04:48.553]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.553]                       if (muffled) 
[16:04:48.553]                         invokeRestart("muffleWarning")
[16:04:48.553]                     }
[16:04:48.553]                     else if (inherits(cond, "condition")) {
[16:04:48.553]                       if (!is.null(pattern)) {
[16:04:48.553]                         computeRestarts <- base::computeRestarts
[16:04:48.553]                         grepl <- base::grepl
[16:04:48.553]                         restarts <- computeRestarts(cond)
[16:04:48.553]                         for (restart in restarts) {
[16:04:48.553]                           name <- restart$name
[16:04:48.553]                           if (is.null(name)) 
[16:04:48.553]                             next
[16:04:48.553]                           if (!grepl(pattern, name)) 
[16:04:48.553]                             next
[16:04:48.553]                           invokeRestart(restart)
[16:04:48.553]                           muffled <- TRUE
[16:04:48.553]                           break
[16:04:48.553]                         }
[16:04:48.553]                       }
[16:04:48.553]                     }
[16:04:48.553]                     invisible(muffled)
[16:04:48.553]                   }
[16:04:48.553]                   muffleCondition(cond)
[16:04:48.553]                 })
[16:04:48.553]             }))
[16:04:48.553]             future::FutureResult(value = ...future.value$value, 
[16:04:48.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.553]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.553]                     ...future.globalenv.names))
[16:04:48.553]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.553]         }, condition = base::local({
[16:04:48.553]             c <- base::c
[16:04:48.553]             inherits <- base::inherits
[16:04:48.553]             invokeRestart <- base::invokeRestart
[16:04:48.553]             length <- base::length
[16:04:48.553]             list <- base::list
[16:04:48.553]             seq.int <- base::seq.int
[16:04:48.553]             signalCondition <- base::signalCondition
[16:04:48.553]             sys.calls <- base::sys.calls
[16:04:48.553]             `[[` <- base::`[[`
[16:04:48.553]             `+` <- base::`+`
[16:04:48.553]             `<<-` <- base::`<<-`
[16:04:48.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.553]                   3L)]
[16:04:48.553]             }
[16:04:48.553]             function(cond) {
[16:04:48.553]                 is_error <- inherits(cond, "error")
[16:04:48.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.553]                   NULL)
[16:04:48.553]                 if (is_error) {
[16:04:48.553]                   sessionInformation <- function() {
[16:04:48.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.553]                       search = base::search(), system = base::Sys.info())
[16:04:48.553]                   }
[16:04:48.553]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.553]                     cond$call), session = sessionInformation(), 
[16:04:48.553]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.553]                   signalCondition(cond)
[16:04:48.553]                 }
[16:04:48.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.553]                 "immediateCondition"))) {
[16:04:48.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.553]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.553]                   if (TRUE && !signal) {
[16:04:48.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.553]                     {
[16:04:48.553]                       inherits <- base::inherits
[16:04:48.553]                       invokeRestart <- base::invokeRestart
[16:04:48.553]                       is.null <- base::is.null
[16:04:48.553]                       muffled <- FALSE
[16:04:48.553]                       if (inherits(cond, "message")) {
[16:04:48.553]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.553]                         if (muffled) 
[16:04:48.553]                           invokeRestart("muffleMessage")
[16:04:48.553]                       }
[16:04:48.553]                       else if (inherits(cond, "warning")) {
[16:04:48.553]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.553]                         if (muffled) 
[16:04:48.553]                           invokeRestart("muffleWarning")
[16:04:48.553]                       }
[16:04:48.553]                       else if (inherits(cond, "condition")) {
[16:04:48.553]                         if (!is.null(pattern)) {
[16:04:48.553]                           computeRestarts <- base::computeRestarts
[16:04:48.553]                           grepl <- base::grepl
[16:04:48.553]                           restarts <- computeRestarts(cond)
[16:04:48.553]                           for (restart in restarts) {
[16:04:48.553]                             name <- restart$name
[16:04:48.553]                             if (is.null(name)) 
[16:04:48.553]                               next
[16:04:48.553]                             if (!grepl(pattern, name)) 
[16:04:48.553]                               next
[16:04:48.553]                             invokeRestart(restart)
[16:04:48.553]                             muffled <- TRUE
[16:04:48.553]                             break
[16:04:48.553]                           }
[16:04:48.553]                         }
[16:04:48.553]                       }
[16:04:48.553]                       invisible(muffled)
[16:04:48.553]                     }
[16:04:48.553]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.553]                   }
[16:04:48.553]                 }
[16:04:48.553]                 else {
[16:04:48.553]                   if (TRUE) {
[16:04:48.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.553]                     {
[16:04:48.553]                       inherits <- base::inherits
[16:04:48.553]                       invokeRestart <- base::invokeRestart
[16:04:48.553]                       is.null <- base::is.null
[16:04:48.553]                       muffled <- FALSE
[16:04:48.553]                       if (inherits(cond, "message")) {
[16:04:48.553]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.553]                         if (muffled) 
[16:04:48.553]                           invokeRestart("muffleMessage")
[16:04:48.553]                       }
[16:04:48.553]                       else if (inherits(cond, "warning")) {
[16:04:48.553]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.553]                         if (muffled) 
[16:04:48.553]                           invokeRestart("muffleWarning")
[16:04:48.553]                       }
[16:04:48.553]                       else if (inherits(cond, "condition")) {
[16:04:48.553]                         if (!is.null(pattern)) {
[16:04:48.553]                           computeRestarts <- base::computeRestarts
[16:04:48.553]                           grepl <- base::grepl
[16:04:48.553]                           restarts <- computeRestarts(cond)
[16:04:48.553]                           for (restart in restarts) {
[16:04:48.553]                             name <- restart$name
[16:04:48.553]                             if (is.null(name)) 
[16:04:48.553]                               next
[16:04:48.553]                             if (!grepl(pattern, name)) 
[16:04:48.553]                               next
[16:04:48.553]                             invokeRestart(restart)
[16:04:48.553]                             muffled <- TRUE
[16:04:48.553]                             break
[16:04:48.553]                           }
[16:04:48.553]                         }
[16:04:48.553]                       }
[16:04:48.553]                       invisible(muffled)
[16:04:48.553]                     }
[16:04:48.553]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.553]                   }
[16:04:48.553]                 }
[16:04:48.553]             }
[16:04:48.553]         }))
[16:04:48.553]     }, error = function(ex) {
[16:04:48.553]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.553]                 ...future.rng), started = ...future.startTime, 
[16:04:48.553]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.553]             version = "1.8"), class = "FutureResult")
[16:04:48.553]     }, finally = {
[16:04:48.553]         if (!identical(...future.workdir, getwd())) 
[16:04:48.553]             setwd(...future.workdir)
[16:04:48.553]         {
[16:04:48.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.553]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.553]             }
[16:04:48.553]             base::options(...future.oldOptions)
[16:04:48.553]             if (.Platform$OS.type == "windows") {
[16:04:48.553]                 old_names <- names(...future.oldEnvVars)
[16:04:48.553]                 envs <- base::Sys.getenv()
[16:04:48.553]                 names <- names(envs)
[16:04:48.553]                 common <- intersect(names, old_names)
[16:04:48.553]                 added <- setdiff(names, old_names)
[16:04:48.553]                 removed <- setdiff(old_names, names)
[16:04:48.553]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.553]                   envs[common]]
[16:04:48.553]                 NAMES <- toupper(changed)
[16:04:48.553]                 args <- list()
[16:04:48.553]                 for (kk in seq_along(NAMES)) {
[16:04:48.553]                   name <- changed[[kk]]
[16:04:48.553]                   NAME <- NAMES[[kk]]
[16:04:48.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.553]                     next
[16:04:48.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.553]                 }
[16:04:48.553]                 NAMES <- toupper(added)
[16:04:48.553]                 for (kk in seq_along(NAMES)) {
[16:04:48.553]                   name <- added[[kk]]
[16:04:48.553]                   NAME <- NAMES[[kk]]
[16:04:48.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.553]                     next
[16:04:48.553]                   args[[name]] <- ""
[16:04:48.553]                 }
[16:04:48.553]                 NAMES <- toupper(removed)
[16:04:48.553]                 for (kk in seq_along(NAMES)) {
[16:04:48.553]                   name <- removed[[kk]]
[16:04:48.553]                   NAME <- NAMES[[kk]]
[16:04:48.553]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.553]                     next
[16:04:48.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.553]                 }
[16:04:48.553]                 if (length(args) > 0) 
[16:04:48.553]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.553]             }
[16:04:48.553]             else {
[16:04:48.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.553]             }
[16:04:48.553]             {
[16:04:48.553]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.553]                   0L) {
[16:04:48.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.553]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.553]                   base::options(opts)
[16:04:48.553]                 }
[16:04:48.553]                 {
[16:04:48.553]                   {
[16:04:48.553]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.553]                     NULL
[16:04:48.553]                   }
[16:04:48.553]                   options(future.plan = NULL)
[16:04:48.553]                   if (is.na(NA_character_)) 
[16:04:48.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.553]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.553]                     envir = parent.frame()) 
[16:04:48.553]                   {
[16:04:48.553]                     default_workers <- missing(workers)
[16:04:48.553]                     if (is.function(workers)) 
[16:04:48.553]                       workers <- workers()
[16:04:48.553]                     workers <- structure(as.integer(workers), 
[16:04:48.553]                       class = class(workers))
[16:04:48.553]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.553]                       1L)
[16:04:48.553]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.553]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.553]                       if (default_workers) 
[16:04:48.553]                         supportsMulticore(warn = TRUE)
[16:04:48.553]                       return(sequential(..., envir = envir))
[16:04:48.553]                     }
[16:04:48.553]                     oopts <- options(mc.cores = workers)
[16:04:48.553]                     on.exit(options(oopts))
[16:04:48.553]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.553]                       envir = envir)
[16:04:48.553]                     if (!future$lazy) 
[16:04:48.553]                       future <- run(future)
[16:04:48.553]                     invisible(future)
[16:04:48.553]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.553]                 }
[16:04:48.553]             }
[16:04:48.553]         }
[16:04:48.553]     })
[16:04:48.553]     if (TRUE) {
[16:04:48.553]         base::sink(type = "output", split = FALSE)
[16:04:48.553]         if (TRUE) {
[16:04:48.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.553]         }
[16:04:48.553]         else {
[16:04:48.553]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.553]         }
[16:04:48.553]         base::close(...future.stdout)
[16:04:48.553]         ...future.stdout <- NULL
[16:04:48.553]     }
[16:04:48.553]     ...future.result$conditions <- ...future.conditions
[16:04:48.553]     ...future.result$finished <- base::Sys.time()
[16:04:48.553]     ...future.result
[16:04:48.553] }
[16:04:48.556] assign_globals() ...
[16:04:48.556] List of 2
[16:04:48.556]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.556]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.556]  - attr(*, "where")=List of 2
[16:04:48.556]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.556]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.556]  - attr(*, "resolved")= logi FALSE
[16:04:48.556]  - attr(*, "total_size")= num 896
[16:04:48.556]  - attr(*, "already-done")= logi TRUE
[16:04:48.559] - copied ‘weight’ to environment
[16:04:48.559] - copied ‘group’ to environment
[16:04:48.559] assign_globals() ... done
[16:04:48.559] requestCore(): workers = 2
[16:04:48.562] MulticoreFuture started
[16:04:48.562] - Launch lazy future ... done
[16:04:48.562] run() for ‘MulticoreFuture’ ... done
[16:04:48.563] plan(): Setting new future strategy stack:
[16:04:48.563] result() for MulticoreFuture ...
[16:04:48.563] List of future strategies:
[16:04:48.563] 1. sequential:
[16:04:48.563]    - args: function (..., envir = parent.frame())
[16:04:48.563]    - tweaked: FALSE
[16:04:48.563]    - call: NULL
[16:04:48.564] plan(): nbrOfWorkers() = 1
[16:04:48.567] plan(): Setting new future strategy stack:
[16:04:48.567] List of future strategies:
[16:04:48.567] 1. multicore:
[16:04:48.567]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.567]    - tweaked: FALSE
[16:04:48.567]    - call: plan(strategy)
[16:04:48.572] plan(): nbrOfWorkers() = 2
[16:04:48.583] result() for MulticoreFuture ...
[16:04:48.583] result() for MulticoreFuture ... done
[16:04:48.583] result() for MulticoreFuture ... done
[16:04:48.583] result() for MulticoreFuture ...
[16:04:48.584] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.586] getGlobalsAndPackages() ...
[16:04:48.586] Searching for globals...
[16:04:48.588] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.588] Searching for globals ... DONE
[16:04:48.588] Resolving globals: FALSE
[16:04:48.589] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.589] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.590] - globals: [2] ‘weight’, ‘group’
[16:04:48.590] - packages: [1] ‘stats’
[16:04:48.590] getGlobalsAndPackages() ... DONE
[16:04:48.590] run() for ‘Future’ ...
[16:04:48.590] - state: ‘created’
[16:04:48.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.594] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.594]   - Field: ‘label’
[16:04:48.594]   - Field: ‘local’
[16:04:48.595]   - Field: ‘owner’
[16:04:48.595]   - Field: ‘envir’
[16:04:48.595]   - Field: ‘workers’
[16:04:48.595]   - Field: ‘packages’
[16:04:48.595]   - Field: ‘gc’
[16:04:48.595]   - Field: ‘job’
[16:04:48.595]   - Field: ‘conditions’
[16:04:48.595]   - Field: ‘expr’
[16:04:48.596]   - Field: ‘uuid’
[16:04:48.596]   - Field: ‘seed’
[16:04:48.596]   - Field: ‘version’
[16:04:48.596]   - Field: ‘result’
[16:04:48.596]   - Field: ‘asynchronous’
[16:04:48.596]   - Field: ‘calls’
[16:04:48.596]   - Field: ‘globals’
[16:04:48.596]   - Field: ‘stdout’
[16:04:48.596]   - Field: ‘earlySignal’
[16:04:48.596]   - Field: ‘lazy’
[16:04:48.597]   - Field: ‘state’
[16:04:48.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.597] - Launch lazy future ...
[16:04:48.597] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.597] Packages needed by future strategies (n = 0): <none>
[16:04:48.598] {
[16:04:48.598]     {
[16:04:48.598]         {
[16:04:48.598]             ...future.startTime <- base::Sys.time()
[16:04:48.598]             {
[16:04:48.598]                 {
[16:04:48.598]                   {
[16:04:48.598]                     {
[16:04:48.598]                       {
[16:04:48.598]                         base::local({
[16:04:48.598]                           has_future <- base::requireNamespace("future", 
[16:04:48.598]                             quietly = TRUE)
[16:04:48.598]                           if (has_future) {
[16:04:48.598]                             ns <- base::getNamespace("future")
[16:04:48.598]                             version <- ns[[".package"]][["version"]]
[16:04:48.598]                             if (is.null(version)) 
[16:04:48.598]                               version <- utils::packageVersion("future")
[16:04:48.598]                           }
[16:04:48.598]                           else {
[16:04:48.598]                             version <- NULL
[16:04:48.598]                           }
[16:04:48.598]                           if (!has_future || version < "1.8.0") {
[16:04:48.598]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.598]                               "", base::R.version$version.string), 
[16:04:48.598]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.598]                                 base::R.version$platform, 8 * 
[16:04:48.598]                                   base::.Machine$sizeof.pointer), 
[16:04:48.598]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.598]                                 "release", "version")], collapse = " "), 
[16:04:48.598]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.598]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.598]                               info)
[16:04:48.598]                             info <- base::paste(info, collapse = "; ")
[16:04:48.598]                             if (!has_future) {
[16:04:48.598]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.598]                                 info)
[16:04:48.598]                             }
[16:04:48.598]                             else {
[16:04:48.598]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.598]                                 info, version)
[16:04:48.598]                             }
[16:04:48.598]                             base::stop(msg)
[16:04:48.598]                           }
[16:04:48.598]                         })
[16:04:48.598]                       }
[16:04:48.598]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.598]                       base::options(mc.cores = 1L)
[16:04:48.598]                     }
[16:04:48.598]                     base::local({
[16:04:48.598]                       for (pkg in "stats") {
[16:04:48.598]                         base::loadNamespace(pkg)
[16:04:48.598]                         base::library(pkg, character.only = TRUE)
[16:04:48.598]                       }
[16:04:48.598]                     })
[16:04:48.598]                   }
[16:04:48.598]                   options(future.plan = NULL)
[16:04:48.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.598]                 }
[16:04:48.598]                 ...future.workdir <- getwd()
[16:04:48.598]             }
[16:04:48.598]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.598]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.598]         }
[16:04:48.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.598]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.598]             base::names(...future.oldOptions))
[16:04:48.598]     }
[16:04:48.598]     if (FALSE) {
[16:04:48.598]     }
[16:04:48.598]     else {
[16:04:48.598]         if (TRUE) {
[16:04:48.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.598]                 open = "w")
[16:04:48.598]         }
[16:04:48.598]         else {
[16:04:48.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.598]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.598]         }
[16:04:48.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.598]             base::sink(type = "output", split = FALSE)
[16:04:48.598]             base::close(...future.stdout)
[16:04:48.598]         }, add = TRUE)
[16:04:48.598]     }
[16:04:48.598]     ...future.frame <- base::sys.nframe()
[16:04:48.598]     ...future.conditions <- base::list()
[16:04:48.598]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.598]     if (FALSE) {
[16:04:48.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.598]     }
[16:04:48.598]     ...future.result <- base::tryCatch({
[16:04:48.598]         base::withCallingHandlers({
[16:04:48.598]             ...future.value <- base::withVisible(base::local({
[16:04:48.598]                 withCallingHandlers({
[16:04:48.598]                   {
[16:04:48.598]                     lm(weight ~ group - 1)
[16:04:48.598]                   }
[16:04:48.598]                 }, immediateCondition = function(cond) {
[16:04:48.598]                   save_rds <- function (object, pathname, ...) 
[16:04:48.598]                   {
[16:04:48.598]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.598]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.598]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.598]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.598]                         fi_tmp[["mtime"]])
[16:04:48.598]                     }
[16:04:48.598]                     tryCatch({
[16:04:48.598]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.598]                     }, error = function(ex) {
[16:04:48.598]                       msg <- conditionMessage(ex)
[16:04:48.598]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.598]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.598]                         fi_tmp[["mtime"]], msg)
[16:04:48.598]                       ex$message <- msg
[16:04:48.598]                       stop(ex)
[16:04:48.598]                     })
[16:04:48.598]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.598]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.598]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.598]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.598]                       fi <- file.info(pathname)
[16:04:48.598]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.598]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.598]                         fi[["size"]], fi[["mtime"]])
[16:04:48.598]                       stop(msg)
[16:04:48.598]                     }
[16:04:48.598]                     invisible(pathname)
[16:04:48.598]                   }
[16:04:48.598]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.598]                     rootPath = tempdir()) 
[16:04:48.598]                   {
[16:04:48.598]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.598]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.598]                       tmpdir = path, fileext = ".rds")
[16:04:48.598]                     save_rds(obj, file)
[16:04:48.598]                   }
[16:04:48.598]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.598]                   {
[16:04:48.598]                     inherits <- base::inherits
[16:04:48.598]                     invokeRestart <- base::invokeRestart
[16:04:48.598]                     is.null <- base::is.null
[16:04:48.598]                     muffled <- FALSE
[16:04:48.598]                     if (inherits(cond, "message")) {
[16:04:48.598]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.598]                       if (muffled) 
[16:04:48.598]                         invokeRestart("muffleMessage")
[16:04:48.598]                     }
[16:04:48.598]                     else if (inherits(cond, "warning")) {
[16:04:48.598]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.598]                       if (muffled) 
[16:04:48.598]                         invokeRestart("muffleWarning")
[16:04:48.598]                     }
[16:04:48.598]                     else if (inherits(cond, "condition")) {
[16:04:48.598]                       if (!is.null(pattern)) {
[16:04:48.598]                         computeRestarts <- base::computeRestarts
[16:04:48.598]                         grepl <- base::grepl
[16:04:48.598]                         restarts <- computeRestarts(cond)
[16:04:48.598]                         for (restart in restarts) {
[16:04:48.598]                           name <- restart$name
[16:04:48.598]                           if (is.null(name)) 
[16:04:48.598]                             next
[16:04:48.598]                           if (!grepl(pattern, name)) 
[16:04:48.598]                             next
[16:04:48.598]                           invokeRestart(restart)
[16:04:48.598]                           muffled <- TRUE
[16:04:48.598]                           break
[16:04:48.598]                         }
[16:04:48.598]                       }
[16:04:48.598]                     }
[16:04:48.598]                     invisible(muffled)
[16:04:48.598]                   }
[16:04:48.598]                   muffleCondition(cond)
[16:04:48.598]                 })
[16:04:48.598]             }))
[16:04:48.598]             future::FutureResult(value = ...future.value$value, 
[16:04:48.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.598]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.598]                     ...future.globalenv.names))
[16:04:48.598]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.598]         }, condition = base::local({
[16:04:48.598]             c <- base::c
[16:04:48.598]             inherits <- base::inherits
[16:04:48.598]             invokeRestart <- base::invokeRestart
[16:04:48.598]             length <- base::length
[16:04:48.598]             list <- base::list
[16:04:48.598]             seq.int <- base::seq.int
[16:04:48.598]             signalCondition <- base::signalCondition
[16:04:48.598]             sys.calls <- base::sys.calls
[16:04:48.598]             `[[` <- base::`[[`
[16:04:48.598]             `+` <- base::`+`
[16:04:48.598]             `<<-` <- base::`<<-`
[16:04:48.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.598]                   3L)]
[16:04:48.598]             }
[16:04:48.598]             function(cond) {
[16:04:48.598]                 is_error <- inherits(cond, "error")
[16:04:48.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.598]                   NULL)
[16:04:48.598]                 if (is_error) {
[16:04:48.598]                   sessionInformation <- function() {
[16:04:48.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.598]                       search = base::search(), system = base::Sys.info())
[16:04:48.598]                   }
[16:04:48.598]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.598]                     cond$call), session = sessionInformation(), 
[16:04:48.598]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.598]                   signalCondition(cond)
[16:04:48.598]                 }
[16:04:48.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.598]                 "immediateCondition"))) {
[16:04:48.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.598]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.598]                   if (TRUE && !signal) {
[16:04:48.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.598]                     {
[16:04:48.598]                       inherits <- base::inherits
[16:04:48.598]                       invokeRestart <- base::invokeRestart
[16:04:48.598]                       is.null <- base::is.null
[16:04:48.598]                       muffled <- FALSE
[16:04:48.598]                       if (inherits(cond, "message")) {
[16:04:48.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.598]                         if (muffled) 
[16:04:48.598]                           invokeRestart("muffleMessage")
[16:04:48.598]                       }
[16:04:48.598]                       else if (inherits(cond, "warning")) {
[16:04:48.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.598]                         if (muffled) 
[16:04:48.598]                           invokeRestart("muffleWarning")
[16:04:48.598]                       }
[16:04:48.598]                       else if (inherits(cond, "condition")) {
[16:04:48.598]                         if (!is.null(pattern)) {
[16:04:48.598]                           computeRestarts <- base::computeRestarts
[16:04:48.598]                           grepl <- base::grepl
[16:04:48.598]                           restarts <- computeRestarts(cond)
[16:04:48.598]                           for (restart in restarts) {
[16:04:48.598]                             name <- restart$name
[16:04:48.598]                             if (is.null(name)) 
[16:04:48.598]                               next
[16:04:48.598]                             if (!grepl(pattern, name)) 
[16:04:48.598]                               next
[16:04:48.598]                             invokeRestart(restart)
[16:04:48.598]                             muffled <- TRUE
[16:04:48.598]                             break
[16:04:48.598]                           }
[16:04:48.598]                         }
[16:04:48.598]                       }
[16:04:48.598]                       invisible(muffled)
[16:04:48.598]                     }
[16:04:48.598]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.598]                   }
[16:04:48.598]                 }
[16:04:48.598]                 else {
[16:04:48.598]                   if (TRUE) {
[16:04:48.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.598]                     {
[16:04:48.598]                       inherits <- base::inherits
[16:04:48.598]                       invokeRestart <- base::invokeRestart
[16:04:48.598]                       is.null <- base::is.null
[16:04:48.598]                       muffled <- FALSE
[16:04:48.598]                       if (inherits(cond, "message")) {
[16:04:48.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.598]                         if (muffled) 
[16:04:48.598]                           invokeRestart("muffleMessage")
[16:04:48.598]                       }
[16:04:48.598]                       else if (inherits(cond, "warning")) {
[16:04:48.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.598]                         if (muffled) 
[16:04:48.598]                           invokeRestart("muffleWarning")
[16:04:48.598]                       }
[16:04:48.598]                       else if (inherits(cond, "condition")) {
[16:04:48.598]                         if (!is.null(pattern)) {
[16:04:48.598]                           computeRestarts <- base::computeRestarts
[16:04:48.598]                           grepl <- base::grepl
[16:04:48.598]                           restarts <- computeRestarts(cond)
[16:04:48.598]                           for (restart in restarts) {
[16:04:48.598]                             name <- restart$name
[16:04:48.598]                             if (is.null(name)) 
[16:04:48.598]                               next
[16:04:48.598]                             if (!grepl(pattern, name)) 
[16:04:48.598]                               next
[16:04:48.598]                             invokeRestart(restart)
[16:04:48.598]                             muffled <- TRUE
[16:04:48.598]                             break
[16:04:48.598]                           }
[16:04:48.598]                         }
[16:04:48.598]                       }
[16:04:48.598]                       invisible(muffled)
[16:04:48.598]                     }
[16:04:48.598]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.598]                   }
[16:04:48.598]                 }
[16:04:48.598]             }
[16:04:48.598]         }))
[16:04:48.598]     }, error = function(ex) {
[16:04:48.598]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.598]                 ...future.rng), started = ...future.startTime, 
[16:04:48.598]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.598]             version = "1.8"), class = "FutureResult")
[16:04:48.598]     }, finally = {
[16:04:48.598]         if (!identical(...future.workdir, getwd())) 
[16:04:48.598]             setwd(...future.workdir)
[16:04:48.598]         {
[16:04:48.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.598]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.598]             }
[16:04:48.598]             base::options(...future.oldOptions)
[16:04:48.598]             if (.Platform$OS.type == "windows") {
[16:04:48.598]                 old_names <- names(...future.oldEnvVars)
[16:04:48.598]                 envs <- base::Sys.getenv()
[16:04:48.598]                 names <- names(envs)
[16:04:48.598]                 common <- intersect(names, old_names)
[16:04:48.598]                 added <- setdiff(names, old_names)
[16:04:48.598]                 removed <- setdiff(old_names, names)
[16:04:48.598]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.598]                   envs[common]]
[16:04:48.598]                 NAMES <- toupper(changed)
[16:04:48.598]                 args <- list()
[16:04:48.598]                 for (kk in seq_along(NAMES)) {
[16:04:48.598]                   name <- changed[[kk]]
[16:04:48.598]                   NAME <- NAMES[[kk]]
[16:04:48.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.598]                     next
[16:04:48.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.598]                 }
[16:04:48.598]                 NAMES <- toupper(added)
[16:04:48.598]                 for (kk in seq_along(NAMES)) {
[16:04:48.598]                   name <- added[[kk]]
[16:04:48.598]                   NAME <- NAMES[[kk]]
[16:04:48.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.598]                     next
[16:04:48.598]                   args[[name]] <- ""
[16:04:48.598]                 }
[16:04:48.598]                 NAMES <- toupper(removed)
[16:04:48.598]                 for (kk in seq_along(NAMES)) {
[16:04:48.598]                   name <- removed[[kk]]
[16:04:48.598]                   NAME <- NAMES[[kk]]
[16:04:48.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.598]                     next
[16:04:48.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.598]                 }
[16:04:48.598]                 if (length(args) > 0) 
[16:04:48.598]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.598]             }
[16:04:48.598]             else {
[16:04:48.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.598]             }
[16:04:48.598]             {
[16:04:48.598]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.598]                   0L) {
[16:04:48.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.598]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.598]                   base::options(opts)
[16:04:48.598]                 }
[16:04:48.598]                 {
[16:04:48.598]                   {
[16:04:48.598]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.598]                     NULL
[16:04:48.598]                   }
[16:04:48.598]                   options(future.plan = NULL)
[16:04:48.598]                   if (is.na(NA_character_)) 
[16:04:48.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.598]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.598]                     envir = parent.frame()) 
[16:04:48.598]                   {
[16:04:48.598]                     default_workers <- missing(workers)
[16:04:48.598]                     if (is.function(workers)) 
[16:04:48.598]                       workers <- workers()
[16:04:48.598]                     workers <- structure(as.integer(workers), 
[16:04:48.598]                       class = class(workers))
[16:04:48.598]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.598]                       1L)
[16:04:48.598]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.598]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.598]                       if (default_workers) 
[16:04:48.598]                         supportsMulticore(warn = TRUE)
[16:04:48.598]                       return(sequential(..., envir = envir))
[16:04:48.598]                     }
[16:04:48.598]                     oopts <- options(mc.cores = workers)
[16:04:48.598]                     on.exit(options(oopts))
[16:04:48.598]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.598]                       envir = envir)
[16:04:48.598]                     if (!future$lazy) 
[16:04:48.598]                       future <- run(future)
[16:04:48.598]                     invisible(future)
[16:04:48.598]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.598]                 }
[16:04:48.598]             }
[16:04:48.598]         }
[16:04:48.598]     })
[16:04:48.598]     if (TRUE) {
[16:04:48.598]         base::sink(type = "output", split = FALSE)
[16:04:48.598]         if (TRUE) {
[16:04:48.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.598]         }
[16:04:48.598]         else {
[16:04:48.598]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.598]         }
[16:04:48.598]         base::close(...future.stdout)
[16:04:48.598]         ...future.stdout <- NULL
[16:04:48.598]     }
[16:04:48.598]     ...future.result$conditions <- ...future.conditions
[16:04:48.598]     ...future.result$finished <- base::Sys.time()
[16:04:48.598]     ...future.result
[16:04:48.598] }
[16:04:48.600] assign_globals() ...
[16:04:48.600] List of 2
[16:04:48.600]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.600]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.600]  - attr(*, "where")=List of 2
[16:04:48.600]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.600]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.600]  - attr(*, "resolved")= logi FALSE
[16:04:48.600]  - attr(*, "total_size")= num 896
[16:04:48.600]  - attr(*, "already-done")= logi TRUE
[16:04:48.604] - copied ‘weight’ to environment
[16:04:48.604] - copied ‘group’ to environment
[16:04:48.604] assign_globals() ... done
[16:04:48.604] requestCore(): workers = 2
[16:04:48.606] MulticoreFuture started
[16:04:48.606] - Launch lazy future ... done
[16:04:48.606] run() for ‘MulticoreFuture’ ... done
[16:04:48.607] result() for MulticoreFuture ...
[16:04:48.607] plan(): Setting new future strategy stack:
[16:04:48.608] List of future strategies:
[16:04:48.608] 1. sequential:
[16:04:48.608]    - args: function (..., envir = parent.frame())
[16:04:48.608]    - tweaked: FALSE
[16:04:48.608]    - call: NULL
[16:04:48.608] plan(): nbrOfWorkers() = 1
[16:04:48.612] plan(): Setting new future strategy stack:
[16:04:48.612] List of future strategies:
[16:04:48.612] 1. multicore:
[16:04:48.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.612]    - tweaked: FALSE
[16:04:48.612]    - call: plan(strategy)
[16:04:48.617] plan(): nbrOfWorkers() = 2
[16:04:48.619] result() for MulticoreFuture ...
[16:04:48.619] result() for MulticoreFuture ... done
[16:04:48.619] result() for MulticoreFuture ... done
[16:04:48.619] result() for MulticoreFuture ...
[16:04:48.619] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.622] getGlobalsAndPackages() ...
[16:04:48.622] Searching for globals...
[16:04:48.626] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.626] Searching for globals ... DONE
[16:04:48.627] Resolving globals: FALSE
[16:04:48.627] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.628] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.628] - globals: [2] ‘weight’, ‘group’
[16:04:48.628] - packages: [1] ‘stats’
[16:04:48.628] getGlobalsAndPackages() ... DONE
[16:04:48.629] run() for ‘Future’ ...
[16:04:48.629] - state: ‘created’
[16:04:48.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.633]   - Field: ‘label’
[16:04:48.633]   - Field: ‘local’
[16:04:48.633]   - Field: ‘owner’
[16:04:48.633]   - Field: ‘envir’
[16:04:48.634]   - Field: ‘workers’
[16:04:48.634]   - Field: ‘packages’
[16:04:48.634]   - Field: ‘gc’
[16:04:48.634]   - Field: ‘job’
[16:04:48.634]   - Field: ‘conditions’
[16:04:48.634]   - Field: ‘expr’
[16:04:48.634]   - Field: ‘uuid’
[16:04:48.634]   - Field: ‘seed’
[16:04:48.634]   - Field: ‘version’
[16:04:48.635]   - Field: ‘result’
[16:04:48.635]   - Field: ‘asynchronous’
[16:04:48.635]   - Field: ‘calls’
[16:04:48.635]   - Field: ‘globals’
[16:04:48.635]   - Field: ‘stdout’
[16:04:48.635]   - Field: ‘earlySignal’
[16:04:48.635]   - Field: ‘lazy’
[16:04:48.635]   - Field: ‘state’
[16:04:48.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.636] - Launch lazy future ...
[16:04:48.636] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.636] Packages needed by future strategies (n = 0): <none>
[16:04:48.637] {
[16:04:48.637]     {
[16:04:48.637]         {
[16:04:48.637]             ...future.startTime <- base::Sys.time()
[16:04:48.637]             {
[16:04:48.637]                 {
[16:04:48.637]                   {
[16:04:48.637]                     {
[16:04:48.637]                       {
[16:04:48.637]                         base::local({
[16:04:48.637]                           has_future <- base::requireNamespace("future", 
[16:04:48.637]                             quietly = TRUE)
[16:04:48.637]                           if (has_future) {
[16:04:48.637]                             ns <- base::getNamespace("future")
[16:04:48.637]                             version <- ns[[".package"]][["version"]]
[16:04:48.637]                             if (is.null(version)) 
[16:04:48.637]                               version <- utils::packageVersion("future")
[16:04:48.637]                           }
[16:04:48.637]                           else {
[16:04:48.637]                             version <- NULL
[16:04:48.637]                           }
[16:04:48.637]                           if (!has_future || version < "1.8.0") {
[16:04:48.637]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.637]                               "", base::R.version$version.string), 
[16:04:48.637]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.637]                                 base::R.version$platform, 8 * 
[16:04:48.637]                                   base::.Machine$sizeof.pointer), 
[16:04:48.637]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.637]                                 "release", "version")], collapse = " "), 
[16:04:48.637]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.637]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.637]                               info)
[16:04:48.637]                             info <- base::paste(info, collapse = "; ")
[16:04:48.637]                             if (!has_future) {
[16:04:48.637]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.637]                                 info)
[16:04:48.637]                             }
[16:04:48.637]                             else {
[16:04:48.637]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.637]                                 info, version)
[16:04:48.637]                             }
[16:04:48.637]                             base::stop(msg)
[16:04:48.637]                           }
[16:04:48.637]                         })
[16:04:48.637]                       }
[16:04:48.637]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.637]                       base::options(mc.cores = 1L)
[16:04:48.637]                     }
[16:04:48.637]                     base::local({
[16:04:48.637]                       for (pkg in "stats") {
[16:04:48.637]                         base::loadNamespace(pkg)
[16:04:48.637]                         base::library(pkg, character.only = TRUE)
[16:04:48.637]                       }
[16:04:48.637]                     })
[16:04:48.637]                   }
[16:04:48.637]                   options(future.plan = NULL)
[16:04:48.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.637]                 }
[16:04:48.637]                 ...future.workdir <- getwd()
[16:04:48.637]             }
[16:04:48.637]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.637]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.637]         }
[16:04:48.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.637]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.637]             base::names(...future.oldOptions))
[16:04:48.637]     }
[16:04:48.637]     if (FALSE) {
[16:04:48.637]     }
[16:04:48.637]     else {
[16:04:48.637]         if (TRUE) {
[16:04:48.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.637]                 open = "w")
[16:04:48.637]         }
[16:04:48.637]         else {
[16:04:48.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.637]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.637]         }
[16:04:48.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.637]             base::sink(type = "output", split = FALSE)
[16:04:48.637]             base::close(...future.stdout)
[16:04:48.637]         }, add = TRUE)
[16:04:48.637]     }
[16:04:48.637]     ...future.frame <- base::sys.nframe()
[16:04:48.637]     ...future.conditions <- base::list()
[16:04:48.637]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.637]     if (FALSE) {
[16:04:48.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.637]     }
[16:04:48.637]     ...future.result <- base::tryCatch({
[16:04:48.637]         base::withCallingHandlers({
[16:04:48.637]             ...future.value <- base::withVisible(base::local({
[16:04:48.637]                 withCallingHandlers({
[16:04:48.637]                   {
[16:04:48.637]                     lm(weight ~ group - 1)
[16:04:48.637]                   }
[16:04:48.637]                 }, immediateCondition = function(cond) {
[16:04:48.637]                   save_rds <- function (object, pathname, ...) 
[16:04:48.637]                   {
[16:04:48.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.637]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.637]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.637]                         fi_tmp[["mtime"]])
[16:04:48.637]                     }
[16:04:48.637]                     tryCatch({
[16:04:48.637]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.637]                     }, error = function(ex) {
[16:04:48.637]                       msg <- conditionMessage(ex)
[16:04:48.637]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.637]                         fi_tmp[["mtime"]], msg)
[16:04:48.637]                       ex$message <- msg
[16:04:48.637]                       stop(ex)
[16:04:48.637]                     })
[16:04:48.637]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.637]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.637]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.637]                       fi <- file.info(pathname)
[16:04:48.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.637]                         fi[["size"]], fi[["mtime"]])
[16:04:48.637]                       stop(msg)
[16:04:48.637]                     }
[16:04:48.637]                     invisible(pathname)
[16:04:48.637]                   }
[16:04:48.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.637]                     rootPath = tempdir()) 
[16:04:48.637]                   {
[16:04:48.637]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.637]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.637]                       tmpdir = path, fileext = ".rds")
[16:04:48.637]                     save_rds(obj, file)
[16:04:48.637]                   }
[16:04:48.637]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.637]                   {
[16:04:48.637]                     inherits <- base::inherits
[16:04:48.637]                     invokeRestart <- base::invokeRestart
[16:04:48.637]                     is.null <- base::is.null
[16:04:48.637]                     muffled <- FALSE
[16:04:48.637]                     if (inherits(cond, "message")) {
[16:04:48.637]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.637]                       if (muffled) 
[16:04:48.637]                         invokeRestart("muffleMessage")
[16:04:48.637]                     }
[16:04:48.637]                     else if (inherits(cond, "warning")) {
[16:04:48.637]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.637]                       if (muffled) 
[16:04:48.637]                         invokeRestart("muffleWarning")
[16:04:48.637]                     }
[16:04:48.637]                     else if (inherits(cond, "condition")) {
[16:04:48.637]                       if (!is.null(pattern)) {
[16:04:48.637]                         computeRestarts <- base::computeRestarts
[16:04:48.637]                         grepl <- base::grepl
[16:04:48.637]                         restarts <- computeRestarts(cond)
[16:04:48.637]                         for (restart in restarts) {
[16:04:48.637]                           name <- restart$name
[16:04:48.637]                           if (is.null(name)) 
[16:04:48.637]                             next
[16:04:48.637]                           if (!grepl(pattern, name)) 
[16:04:48.637]                             next
[16:04:48.637]                           invokeRestart(restart)
[16:04:48.637]                           muffled <- TRUE
[16:04:48.637]                           break
[16:04:48.637]                         }
[16:04:48.637]                       }
[16:04:48.637]                     }
[16:04:48.637]                     invisible(muffled)
[16:04:48.637]                   }
[16:04:48.637]                   muffleCondition(cond)
[16:04:48.637]                 })
[16:04:48.637]             }))
[16:04:48.637]             future::FutureResult(value = ...future.value$value, 
[16:04:48.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.637]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.637]                     ...future.globalenv.names))
[16:04:48.637]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.637]         }, condition = base::local({
[16:04:48.637]             c <- base::c
[16:04:48.637]             inherits <- base::inherits
[16:04:48.637]             invokeRestart <- base::invokeRestart
[16:04:48.637]             length <- base::length
[16:04:48.637]             list <- base::list
[16:04:48.637]             seq.int <- base::seq.int
[16:04:48.637]             signalCondition <- base::signalCondition
[16:04:48.637]             sys.calls <- base::sys.calls
[16:04:48.637]             `[[` <- base::`[[`
[16:04:48.637]             `+` <- base::`+`
[16:04:48.637]             `<<-` <- base::`<<-`
[16:04:48.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.637]                   3L)]
[16:04:48.637]             }
[16:04:48.637]             function(cond) {
[16:04:48.637]                 is_error <- inherits(cond, "error")
[16:04:48.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.637]                   NULL)
[16:04:48.637]                 if (is_error) {
[16:04:48.637]                   sessionInformation <- function() {
[16:04:48.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.637]                       search = base::search(), system = base::Sys.info())
[16:04:48.637]                   }
[16:04:48.637]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.637]                     cond$call), session = sessionInformation(), 
[16:04:48.637]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.637]                   signalCondition(cond)
[16:04:48.637]                 }
[16:04:48.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.637]                 "immediateCondition"))) {
[16:04:48.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.637]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.637]                   if (TRUE && !signal) {
[16:04:48.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.637]                     {
[16:04:48.637]                       inherits <- base::inherits
[16:04:48.637]                       invokeRestart <- base::invokeRestart
[16:04:48.637]                       is.null <- base::is.null
[16:04:48.637]                       muffled <- FALSE
[16:04:48.637]                       if (inherits(cond, "message")) {
[16:04:48.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.637]                         if (muffled) 
[16:04:48.637]                           invokeRestart("muffleMessage")
[16:04:48.637]                       }
[16:04:48.637]                       else if (inherits(cond, "warning")) {
[16:04:48.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.637]                         if (muffled) 
[16:04:48.637]                           invokeRestart("muffleWarning")
[16:04:48.637]                       }
[16:04:48.637]                       else if (inherits(cond, "condition")) {
[16:04:48.637]                         if (!is.null(pattern)) {
[16:04:48.637]                           computeRestarts <- base::computeRestarts
[16:04:48.637]                           grepl <- base::grepl
[16:04:48.637]                           restarts <- computeRestarts(cond)
[16:04:48.637]                           for (restart in restarts) {
[16:04:48.637]                             name <- restart$name
[16:04:48.637]                             if (is.null(name)) 
[16:04:48.637]                               next
[16:04:48.637]                             if (!grepl(pattern, name)) 
[16:04:48.637]                               next
[16:04:48.637]                             invokeRestart(restart)
[16:04:48.637]                             muffled <- TRUE
[16:04:48.637]                             break
[16:04:48.637]                           }
[16:04:48.637]                         }
[16:04:48.637]                       }
[16:04:48.637]                       invisible(muffled)
[16:04:48.637]                     }
[16:04:48.637]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.637]                   }
[16:04:48.637]                 }
[16:04:48.637]                 else {
[16:04:48.637]                   if (TRUE) {
[16:04:48.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.637]                     {
[16:04:48.637]                       inherits <- base::inherits
[16:04:48.637]                       invokeRestart <- base::invokeRestart
[16:04:48.637]                       is.null <- base::is.null
[16:04:48.637]                       muffled <- FALSE
[16:04:48.637]                       if (inherits(cond, "message")) {
[16:04:48.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.637]                         if (muffled) 
[16:04:48.637]                           invokeRestart("muffleMessage")
[16:04:48.637]                       }
[16:04:48.637]                       else if (inherits(cond, "warning")) {
[16:04:48.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.637]                         if (muffled) 
[16:04:48.637]                           invokeRestart("muffleWarning")
[16:04:48.637]                       }
[16:04:48.637]                       else if (inherits(cond, "condition")) {
[16:04:48.637]                         if (!is.null(pattern)) {
[16:04:48.637]                           computeRestarts <- base::computeRestarts
[16:04:48.637]                           grepl <- base::grepl
[16:04:48.637]                           restarts <- computeRestarts(cond)
[16:04:48.637]                           for (restart in restarts) {
[16:04:48.637]                             name <- restart$name
[16:04:48.637]                             if (is.null(name)) 
[16:04:48.637]                               next
[16:04:48.637]                             if (!grepl(pattern, name)) 
[16:04:48.637]                               next
[16:04:48.637]                             invokeRestart(restart)
[16:04:48.637]                             muffled <- TRUE
[16:04:48.637]                             break
[16:04:48.637]                           }
[16:04:48.637]                         }
[16:04:48.637]                       }
[16:04:48.637]                       invisible(muffled)
[16:04:48.637]                     }
[16:04:48.637]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.637]                   }
[16:04:48.637]                 }
[16:04:48.637]             }
[16:04:48.637]         }))
[16:04:48.637]     }, error = function(ex) {
[16:04:48.637]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.637]                 ...future.rng), started = ...future.startTime, 
[16:04:48.637]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.637]             version = "1.8"), class = "FutureResult")
[16:04:48.637]     }, finally = {
[16:04:48.637]         if (!identical(...future.workdir, getwd())) 
[16:04:48.637]             setwd(...future.workdir)
[16:04:48.637]         {
[16:04:48.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.637]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.637]             }
[16:04:48.637]             base::options(...future.oldOptions)
[16:04:48.637]             if (.Platform$OS.type == "windows") {
[16:04:48.637]                 old_names <- names(...future.oldEnvVars)
[16:04:48.637]                 envs <- base::Sys.getenv()
[16:04:48.637]                 names <- names(envs)
[16:04:48.637]                 common <- intersect(names, old_names)
[16:04:48.637]                 added <- setdiff(names, old_names)
[16:04:48.637]                 removed <- setdiff(old_names, names)
[16:04:48.637]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.637]                   envs[common]]
[16:04:48.637]                 NAMES <- toupper(changed)
[16:04:48.637]                 args <- list()
[16:04:48.637]                 for (kk in seq_along(NAMES)) {
[16:04:48.637]                   name <- changed[[kk]]
[16:04:48.637]                   NAME <- NAMES[[kk]]
[16:04:48.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.637]                     next
[16:04:48.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.637]                 }
[16:04:48.637]                 NAMES <- toupper(added)
[16:04:48.637]                 for (kk in seq_along(NAMES)) {
[16:04:48.637]                   name <- added[[kk]]
[16:04:48.637]                   NAME <- NAMES[[kk]]
[16:04:48.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.637]                     next
[16:04:48.637]                   args[[name]] <- ""
[16:04:48.637]                 }
[16:04:48.637]                 NAMES <- toupper(removed)
[16:04:48.637]                 for (kk in seq_along(NAMES)) {
[16:04:48.637]                   name <- removed[[kk]]
[16:04:48.637]                   NAME <- NAMES[[kk]]
[16:04:48.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.637]                     next
[16:04:48.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.637]                 }
[16:04:48.637]                 if (length(args) > 0) 
[16:04:48.637]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.637]             }
[16:04:48.637]             else {
[16:04:48.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.637]             }
[16:04:48.637]             {
[16:04:48.637]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.637]                   0L) {
[16:04:48.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.637]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.637]                   base::options(opts)
[16:04:48.637]                 }
[16:04:48.637]                 {
[16:04:48.637]                   {
[16:04:48.637]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.637]                     NULL
[16:04:48.637]                   }
[16:04:48.637]                   options(future.plan = NULL)
[16:04:48.637]                   if (is.na(NA_character_)) 
[16:04:48.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.637]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.637]                     envir = parent.frame()) 
[16:04:48.637]                   {
[16:04:48.637]                     default_workers <- missing(workers)
[16:04:48.637]                     if (is.function(workers)) 
[16:04:48.637]                       workers <- workers()
[16:04:48.637]                     workers <- structure(as.integer(workers), 
[16:04:48.637]                       class = class(workers))
[16:04:48.637]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.637]                       1L)
[16:04:48.637]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.637]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.637]                       if (default_workers) 
[16:04:48.637]                         supportsMulticore(warn = TRUE)
[16:04:48.637]                       return(sequential(..., envir = envir))
[16:04:48.637]                     }
[16:04:48.637]                     oopts <- options(mc.cores = workers)
[16:04:48.637]                     on.exit(options(oopts))
[16:04:48.637]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.637]                       envir = envir)
[16:04:48.637]                     if (!future$lazy) 
[16:04:48.637]                       future <- run(future)
[16:04:48.637]                     invisible(future)
[16:04:48.637]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.637]                 }
[16:04:48.637]             }
[16:04:48.637]         }
[16:04:48.637]     })
[16:04:48.637]     if (TRUE) {
[16:04:48.637]         base::sink(type = "output", split = FALSE)
[16:04:48.637]         if (TRUE) {
[16:04:48.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.637]         }
[16:04:48.637]         else {
[16:04:48.637]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.637]         }
[16:04:48.637]         base::close(...future.stdout)
[16:04:48.637]         ...future.stdout <- NULL
[16:04:48.637]     }
[16:04:48.637]     ...future.result$conditions <- ...future.conditions
[16:04:48.637]     ...future.result$finished <- base::Sys.time()
[16:04:48.637]     ...future.result
[16:04:48.637] }
[16:04:48.639] assign_globals() ...
[16:04:48.639] List of 2
[16:04:48.639]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.639]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.639]  - attr(*, "where")=List of 2
[16:04:48.639]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.639]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.639]  - attr(*, "resolved")= logi FALSE
[16:04:48.639]  - attr(*, "total_size")= num 896
[16:04:48.639]  - attr(*, "already-done")= logi TRUE
[16:04:48.643] - copied ‘weight’ to environment
[16:04:48.643] - copied ‘group’ to environment
[16:04:48.643] assign_globals() ... done
[16:04:48.643] requestCore(): workers = 2
[16:04:48.645] MulticoreFuture started
[16:04:48.645] - Launch lazy future ... done
[16:04:48.645] run() for ‘MulticoreFuture’ ... done
[16:04:48.646] result() for MulticoreFuture ...
[16:04:48.646] plan(): Setting new future strategy stack:
[16:04:48.647] List of future strategies:
[16:04:48.647] 1. sequential:
[16:04:48.647]    - args: function (..., envir = parent.frame())
[16:04:48.647]    - tweaked: FALSE
[16:04:48.647]    - call: NULL
[16:04:48.647] plan(): nbrOfWorkers() = 1
[16:04:48.651] plan(): Setting new future strategy stack:
[16:04:48.651] List of future strategies:
[16:04:48.651] 1. multicore:
[16:04:48.651]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.651]    - tweaked: FALSE
[16:04:48.651]    - call: plan(strategy)
[16:04:48.656] plan(): nbrOfWorkers() = 2
[16:04:48.658] result() for MulticoreFuture ...
[16:04:48.658] result() for MulticoreFuture ... done
[16:04:48.658] result() for MulticoreFuture ... done
[16:04:48.658] result() for MulticoreFuture ...
[16:04:48.658] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.661] getGlobalsAndPackages() ...
[16:04:48.661] Searching for globals...
[16:04:48.663] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.663] Searching for globals ... DONE
[16:04:48.663] Resolving globals: FALSE
[16:04:48.664] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.664] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.664] - globals: [2] ‘weight’, ‘group’
[16:04:48.664] - packages: [1] ‘stats’
[16:04:48.665] getGlobalsAndPackages() ... DONE
[16:04:48.665] run() for ‘Future’ ...
[16:04:48.665] - state: ‘created’
[16:04:48.665] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.671]   - Field: ‘label’
[16:04:48.672]   - Field: ‘local’
[16:04:48.672]   - Field: ‘owner’
[16:04:48.672]   - Field: ‘envir’
[16:04:48.672]   - Field: ‘workers’
[16:04:48.672]   - Field: ‘packages’
[16:04:48.672]   - Field: ‘gc’
[16:04:48.672]   - Field: ‘job’
[16:04:48.672]   - Field: ‘conditions’
[16:04:48.673]   - Field: ‘expr’
[16:04:48.673]   - Field: ‘uuid’
[16:04:48.673]   - Field: ‘seed’
[16:04:48.673]   - Field: ‘version’
[16:04:48.673]   - Field: ‘result’
[16:04:48.673]   - Field: ‘asynchronous’
[16:04:48.673]   - Field: ‘calls’
[16:04:48.673]   - Field: ‘globals’
[16:04:48.674]   - Field: ‘stdout’
[16:04:48.674]   - Field: ‘earlySignal’
[16:04:48.674]   - Field: ‘lazy’
[16:04:48.674]   - Field: ‘state’
[16:04:48.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.674] - Launch lazy future ...
[16:04:48.674] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.675] Packages needed by future strategies (n = 0): <none>
[16:04:48.675] {
[16:04:48.675]     {
[16:04:48.675]         {
[16:04:48.675]             ...future.startTime <- base::Sys.time()
[16:04:48.675]             {
[16:04:48.675]                 {
[16:04:48.675]                   {
[16:04:48.675]                     {
[16:04:48.675]                       {
[16:04:48.675]                         base::local({
[16:04:48.675]                           has_future <- base::requireNamespace("future", 
[16:04:48.675]                             quietly = TRUE)
[16:04:48.675]                           if (has_future) {
[16:04:48.675]                             ns <- base::getNamespace("future")
[16:04:48.675]                             version <- ns[[".package"]][["version"]]
[16:04:48.675]                             if (is.null(version)) 
[16:04:48.675]                               version <- utils::packageVersion("future")
[16:04:48.675]                           }
[16:04:48.675]                           else {
[16:04:48.675]                             version <- NULL
[16:04:48.675]                           }
[16:04:48.675]                           if (!has_future || version < "1.8.0") {
[16:04:48.675]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.675]                               "", base::R.version$version.string), 
[16:04:48.675]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.675]                                 base::R.version$platform, 8 * 
[16:04:48.675]                                   base::.Machine$sizeof.pointer), 
[16:04:48.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.675]                                 "release", "version")], collapse = " "), 
[16:04:48.675]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.675]                               info)
[16:04:48.675]                             info <- base::paste(info, collapse = "; ")
[16:04:48.675]                             if (!has_future) {
[16:04:48.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.675]                                 info)
[16:04:48.675]                             }
[16:04:48.675]                             else {
[16:04:48.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.675]                                 info, version)
[16:04:48.675]                             }
[16:04:48.675]                             base::stop(msg)
[16:04:48.675]                           }
[16:04:48.675]                         })
[16:04:48.675]                       }
[16:04:48.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.675]                       base::options(mc.cores = 1L)
[16:04:48.675]                     }
[16:04:48.675]                     base::local({
[16:04:48.675]                       for (pkg in "stats") {
[16:04:48.675]                         base::loadNamespace(pkg)
[16:04:48.675]                         base::library(pkg, character.only = TRUE)
[16:04:48.675]                       }
[16:04:48.675]                     })
[16:04:48.675]                   }
[16:04:48.675]                   options(future.plan = NULL)
[16:04:48.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.675]                 }
[16:04:48.675]                 ...future.workdir <- getwd()
[16:04:48.675]             }
[16:04:48.675]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.675]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.675]         }
[16:04:48.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.675]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.675]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.675]             base::names(...future.oldOptions))
[16:04:48.675]     }
[16:04:48.675]     if (FALSE) {
[16:04:48.675]     }
[16:04:48.675]     else {
[16:04:48.675]         if (TRUE) {
[16:04:48.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.675]                 open = "w")
[16:04:48.675]         }
[16:04:48.675]         else {
[16:04:48.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.675]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.675]         }
[16:04:48.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.675]             base::sink(type = "output", split = FALSE)
[16:04:48.675]             base::close(...future.stdout)
[16:04:48.675]         }, add = TRUE)
[16:04:48.675]     }
[16:04:48.675]     ...future.frame <- base::sys.nframe()
[16:04:48.675]     ...future.conditions <- base::list()
[16:04:48.675]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.675]     if (FALSE) {
[16:04:48.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.675]     }
[16:04:48.675]     ...future.result <- base::tryCatch({
[16:04:48.675]         base::withCallingHandlers({
[16:04:48.675]             ...future.value <- base::withVisible(base::local({
[16:04:48.675]                 withCallingHandlers({
[16:04:48.675]                   {
[16:04:48.675]                     lm(weight ~ group - 1)
[16:04:48.675]                   }
[16:04:48.675]                 }, immediateCondition = function(cond) {
[16:04:48.675]                   save_rds <- function (object, pathname, ...) 
[16:04:48.675]                   {
[16:04:48.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.675]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.675]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.675]                         fi_tmp[["mtime"]])
[16:04:48.675]                     }
[16:04:48.675]                     tryCatch({
[16:04:48.675]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.675]                     }, error = function(ex) {
[16:04:48.675]                       msg <- conditionMessage(ex)
[16:04:48.675]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.675]                         fi_tmp[["mtime"]], msg)
[16:04:48.675]                       ex$message <- msg
[16:04:48.675]                       stop(ex)
[16:04:48.675]                     })
[16:04:48.675]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.675]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.675]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.675]                       fi <- file.info(pathname)
[16:04:48.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.675]                         fi[["size"]], fi[["mtime"]])
[16:04:48.675]                       stop(msg)
[16:04:48.675]                     }
[16:04:48.675]                     invisible(pathname)
[16:04:48.675]                   }
[16:04:48.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.675]                     rootPath = tempdir()) 
[16:04:48.675]                   {
[16:04:48.675]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.675]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.675]                       tmpdir = path, fileext = ".rds")
[16:04:48.675]                     save_rds(obj, file)
[16:04:48.675]                   }
[16:04:48.675]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.675]                   {
[16:04:48.675]                     inherits <- base::inherits
[16:04:48.675]                     invokeRestart <- base::invokeRestart
[16:04:48.675]                     is.null <- base::is.null
[16:04:48.675]                     muffled <- FALSE
[16:04:48.675]                     if (inherits(cond, "message")) {
[16:04:48.675]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.675]                       if (muffled) 
[16:04:48.675]                         invokeRestart("muffleMessage")
[16:04:48.675]                     }
[16:04:48.675]                     else if (inherits(cond, "warning")) {
[16:04:48.675]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.675]                       if (muffled) 
[16:04:48.675]                         invokeRestart("muffleWarning")
[16:04:48.675]                     }
[16:04:48.675]                     else if (inherits(cond, "condition")) {
[16:04:48.675]                       if (!is.null(pattern)) {
[16:04:48.675]                         computeRestarts <- base::computeRestarts
[16:04:48.675]                         grepl <- base::grepl
[16:04:48.675]                         restarts <- computeRestarts(cond)
[16:04:48.675]                         for (restart in restarts) {
[16:04:48.675]                           name <- restart$name
[16:04:48.675]                           if (is.null(name)) 
[16:04:48.675]                             next
[16:04:48.675]                           if (!grepl(pattern, name)) 
[16:04:48.675]                             next
[16:04:48.675]                           invokeRestart(restart)
[16:04:48.675]                           muffled <- TRUE
[16:04:48.675]                           break
[16:04:48.675]                         }
[16:04:48.675]                       }
[16:04:48.675]                     }
[16:04:48.675]                     invisible(muffled)
[16:04:48.675]                   }
[16:04:48.675]                   muffleCondition(cond)
[16:04:48.675]                 })
[16:04:48.675]             }))
[16:04:48.675]             future::FutureResult(value = ...future.value$value, 
[16:04:48.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.675]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.675]                     ...future.globalenv.names))
[16:04:48.675]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.675]         }, condition = base::local({
[16:04:48.675]             c <- base::c
[16:04:48.675]             inherits <- base::inherits
[16:04:48.675]             invokeRestart <- base::invokeRestart
[16:04:48.675]             length <- base::length
[16:04:48.675]             list <- base::list
[16:04:48.675]             seq.int <- base::seq.int
[16:04:48.675]             signalCondition <- base::signalCondition
[16:04:48.675]             sys.calls <- base::sys.calls
[16:04:48.675]             `[[` <- base::`[[`
[16:04:48.675]             `+` <- base::`+`
[16:04:48.675]             `<<-` <- base::`<<-`
[16:04:48.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.675]                   3L)]
[16:04:48.675]             }
[16:04:48.675]             function(cond) {
[16:04:48.675]                 is_error <- inherits(cond, "error")
[16:04:48.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.675]                   NULL)
[16:04:48.675]                 if (is_error) {
[16:04:48.675]                   sessionInformation <- function() {
[16:04:48.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.675]                       search = base::search(), system = base::Sys.info())
[16:04:48.675]                   }
[16:04:48.675]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.675]                     cond$call), session = sessionInformation(), 
[16:04:48.675]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.675]                   signalCondition(cond)
[16:04:48.675]                 }
[16:04:48.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.675]                 "immediateCondition"))) {
[16:04:48.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.675]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.675]                   if (TRUE && !signal) {
[16:04:48.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.675]                     {
[16:04:48.675]                       inherits <- base::inherits
[16:04:48.675]                       invokeRestart <- base::invokeRestart
[16:04:48.675]                       is.null <- base::is.null
[16:04:48.675]                       muffled <- FALSE
[16:04:48.675]                       if (inherits(cond, "message")) {
[16:04:48.675]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.675]                         if (muffled) 
[16:04:48.675]                           invokeRestart("muffleMessage")
[16:04:48.675]                       }
[16:04:48.675]                       else if (inherits(cond, "warning")) {
[16:04:48.675]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.675]                         if (muffled) 
[16:04:48.675]                           invokeRestart("muffleWarning")
[16:04:48.675]                       }
[16:04:48.675]                       else if (inherits(cond, "condition")) {
[16:04:48.675]                         if (!is.null(pattern)) {
[16:04:48.675]                           computeRestarts <- base::computeRestarts
[16:04:48.675]                           grepl <- base::grepl
[16:04:48.675]                           restarts <- computeRestarts(cond)
[16:04:48.675]                           for (restart in restarts) {
[16:04:48.675]                             name <- restart$name
[16:04:48.675]                             if (is.null(name)) 
[16:04:48.675]                               next
[16:04:48.675]                             if (!grepl(pattern, name)) 
[16:04:48.675]                               next
[16:04:48.675]                             invokeRestart(restart)
[16:04:48.675]                             muffled <- TRUE
[16:04:48.675]                             break
[16:04:48.675]                           }
[16:04:48.675]                         }
[16:04:48.675]                       }
[16:04:48.675]                       invisible(muffled)
[16:04:48.675]                     }
[16:04:48.675]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.675]                   }
[16:04:48.675]                 }
[16:04:48.675]                 else {
[16:04:48.675]                   if (TRUE) {
[16:04:48.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.675]                     {
[16:04:48.675]                       inherits <- base::inherits
[16:04:48.675]                       invokeRestart <- base::invokeRestart
[16:04:48.675]                       is.null <- base::is.null
[16:04:48.675]                       muffled <- FALSE
[16:04:48.675]                       if (inherits(cond, "message")) {
[16:04:48.675]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.675]                         if (muffled) 
[16:04:48.675]                           invokeRestart("muffleMessage")
[16:04:48.675]                       }
[16:04:48.675]                       else if (inherits(cond, "warning")) {
[16:04:48.675]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.675]                         if (muffled) 
[16:04:48.675]                           invokeRestart("muffleWarning")
[16:04:48.675]                       }
[16:04:48.675]                       else if (inherits(cond, "condition")) {
[16:04:48.675]                         if (!is.null(pattern)) {
[16:04:48.675]                           computeRestarts <- base::computeRestarts
[16:04:48.675]                           grepl <- base::grepl
[16:04:48.675]                           restarts <- computeRestarts(cond)
[16:04:48.675]                           for (restart in restarts) {
[16:04:48.675]                             name <- restart$name
[16:04:48.675]                             if (is.null(name)) 
[16:04:48.675]                               next
[16:04:48.675]                             if (!grepl(pattern, name)) 
[16:04:48.675]                               next
[16:04:48.675]                             invokeRestart(restart)
[16:04:48.675]                             muffled <- TRUE
[16:04:48.675]                             break
[16:04:48.675]                           }
[16:04:48.675]                         }
[16:04:48.675]                       }
[16:04:48.675]                       invisible(muffled)
[16:04:48.675]                     }
[16:04:48.675]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.675]                   }
[16:04:48.675]                 }
[16:04:48.675]             }
[16:04:48.675]         }))
[16:04:48.675]     }, error = function(ex) {
[16:04:48.675]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.675]                 ...future.rng), started = ...future.startTime, 
[16:04:48.675]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.675]             version = "1.8"), class = "FutureResult")
[16:04:48.675]     }, finally = {
[16:04:48.675]         if (!identical(...future.workdir, getwd())) 
[16:04:48.675]             setwd(...future.workdir)
[16:04:48.675]         {
[16:04:48.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.675]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.675]             }
[16:04:48.675]             base::options(...future.oldOptions)
[16:04:48.675]             if (.Platform$OS.type == "windows") {
[16:04:48.675]                 old_names <- names(...future.oldEnvVars)
[16:04:48.675]                 envs <- base::Sys.getenv()
[16:04:48.675]                 names <- names(envs)
[16:04:48.675]                 common <- intersect(names, old_names)
[16:04:48.675]                 added <- setdiff(names, old_names)
[16:04:48.675]                 removed <- setdiff(old_names, names)
[16:04:48.675]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.675]                   envs[common]]
[16:04:48.675]                 NAMES <- toupper(changed)
[16:04:48.675]                 args <- list()
[16:04:48.675]                 for (kk in seq_along(NAMES)) {
[16:04:48.675]                   name <- changed[[kk]]
[16:04:48.675]                   NAME <- NAMES[[kk]]
[16:04:48.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.675]                     next
[16:04:48.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.675]                 }
[16:04:48.675]                 NAMES <- toupper(added)
[16:04:48.675]                 for (kk in seq_along(NAMES)) {
[16:04:48.675]                   name <- added[[kk]]
[16:04:48.675]                   NAME <- NAMES[[kk]]
[16:04:48.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.675]                     next
[16:04:48.675]                   args[[name]] <- ""
[16:04:48.675]                 }
[16:04:48.675]                 NAMES <- toupper(removed)
[16:04:48.675]                 for (kk in seq_along(NAMES)) {
[16:04:48.675]                   name <- removed[[kk]]
[16:04:48.675]                   NAME <- NAMES[[kk]]
[16:04:48.675]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.675]                     next
[16:04:48.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.675]                 }
[16:04:48.675]                 if (length(args) > 0) 
[16:04:48.675]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.675]             }
[16:04:48.675]             else {
[16:04:48.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.675]             }
[16:04:48.675]             {
[16:04:48.675]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.675]                   0L) {
[16:04:48.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.675]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.675]                   base::options(opts)
[16:04:48.675]                 }
[16:04:48.675]                 {
[16:04:48.675]                   {
[16:04:48.675]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.675]                     NULL
[16:04:48.675]                   }
[16:04:48.675]                   options(future.plan = NULL)
[16:04:48.675]                   if (is.na(NA_character_)) 
[16:04:48.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.675]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.675]                     envir = parent.frame()) 
[16:04:48.675]                   {
[16:04:48.675]                     default_workers <- missing(workers)
[16:04:48.675]                     if (is.function(workers)) 
[16:04:48.675]                       workers <- workers()
[16:04:48.675]                     workers <- structure(as.integer(workers), 
[16:04:48.675]                       class = class(workers))
[16:04:48.675]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.675]                       1L)
[16:04:48.675]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.675]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.675]                       if (default_workers) 
[16:04:48.675]                         supportsMulticore(warn = TRUE)
[16:04:48.675]                       return(sequential(..., envir = envir))
[16:04:48.675]                     }
[16:04:48.675]                     oopts <- options(mc.cores = workers)
[16:04:48.675]                     on.exit(options(oopts))
[16:04:48.675]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.675]                       envir = envir)
[16:04:48.675]                     if (!future$lazy) 
[16:04:48.675]                       future <- run(future)
[16:04:48.675]                     invisible(future)
[16:04:48.675]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.675]                 }
[16:04:48.675]             }
[16:04:48.675]         }
[16:04:48.675]     })
[16:04:48.675]     if (TRUE) {
[16:04:48.675]         base::sink(type = "output", split = FALSE)
[16:04:48.675]         if (TRUE) {
[16:04:48.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.675]         }
[16:04:48.675]         else {
[16:04:48.675]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.675]         }
[16:04:48.675]         base::close(...future.stdout)
[16:04:48.675]         ...future.stdout <- NULL
[16:04:48.675]     }
[16:04:48.675]     ...future.result$conditions <- ...future.conditions
[16:04:48.675]     ...future.result$finished <- base::Sys.time()
[16:04:48.675]     ...future.result
[16:04:48.675] }
[16:04:48.678] assign_globals() ...
[16:04:48.678] List of 2
[16:04:48.678]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.678]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.678]  - attr(*, "where")=List of 2
[16:04:48.678]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.678]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.678]  - attr(*, "resolved")= logi FALSE
[16:04:48.678]  - attr(*, "total_size")= num 896
[16:04:48.678]  - attr(*, "already-done")= logi TRUE
[16:04:48.681] - copied ‘weight’ to environment
[16:04:48.682] - copied ‘group’ to environment
[16:04:48.682] assign_globals() ... done
[16:04:48.682] requestCore(): workers = 2
[16:04:48.683] MulticoreFuture started
[16:04:48.684] - Launch lazy future ... done
[16:04:48.684] run() for ‘MulticoreFuture’ ... done
[16:04:48.684] result() for MulticoreFuture ...
[16:04:48.685] plan(): Setting new future strategy stack:
[16:04:48.685] List of future strategies:
[16:04:48.685] 1. sequential:
[16:04:48.685]    - args: function (..., envir = parent.frame())
[16:04:48.685]    - tweaked: FALSE
[16:04:48.685]    - call: NULL
[16:04:48.686] plan(): nbrOfWorkers() = 1
[16:04:48.689] plan(): Setting new future strategy stack:
[16:04:48.689] List of future strategies:
[16:04:48.689] 1. multicore:
[16:04:48.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.689]    - tweaked: FALSE
[16:04:48.689]    - call: plan(strategy)
[16:04:48.695] plan(): nbrOfWorkers() = 2
[16:04:48.696] result() for MulticoreFuture ...
[16:04:48.697] result() for MulticoreFuture ... done
[16:04:48.697] result() for MulticoreFuture ... done
[16:04:48.697] result() for MulticoreFuture ...
[16:04:48.697] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:48.699] getGlobalsAndPackages() ...
[16:04:48.700] Searching for globals...
[16:04:48.702] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:48.702] Searching for globals ... DONE
[16:04:48.702] Resolving globals: FALSE
[16:04:48.702] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:48.703] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:48.703] - globals: [2] ‘weight’, ‘group’
[16:04:48.703] - packages: [1] ‘stats’
[16:04:48.703] getGlobalsAndPackages() ... DONE
[16:04:48.704] run() for ‘Future’ ...
[16:04:48.704] - state: ‘created’
[16:04:48.704] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.708] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.708] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.708]   - Field: ‘label’
[16:04:48.708]   - Field: ‘local’
[16:04:48.708]   - Field: ‘owner’
[16:04:48.709]   - Field: ‘envir’
[16:04:48.709]   - Field: ‘workers’
[16:04:48.709]   - Field: ‘packages’
[16:04:48.709]   - Field: ‘gc’
[16:04:48.709]   - Field: ‘job’
[16:04:48.709]   - Field: ‘conditions’
[16:04:48.709]   - Field: ‘expr’
[16:04:48.709]   - Field: ‘uuid’
[16:04:48.709]   - Field: ‘seed’
[16:04:48.710]   - Field: ‘version’
[16:04:48.710]   - Field: ‘result’
[16:04:48.710]   - Field: ‘asynchronous’
[16:04:48.710]   - Field: ‘calls’
[16:04:48.710]   - Field: ‘globals’
[16:04:48.710]   - Field: ‘stdout’
[16:04:48.710]   - Field: ‘earlySignal’
[16:04:48.712]   - Field: ‘lazy’
[16:04:48.712]   - Field: ‘state’
[16:04:48.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.713] - Launch lazy future ...
[16:04:48.713] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.713] Packages needed by future strategies (n = 0): <none>
[16:04:48.714] {
[16:04:48.714]     {
[16:04:48.714]         {
[16:04:48.714]             ...future.startTime <- base::Sys.time()
[16:04:48.714]             {
[16:04:48.714]                 {
[16:04:48.714]                   {
[16:04:48.714]                     {
[16:04:48.714]                       {
[16:04:48.714]                         base::local({
[16:04:48.714]                           has_future <- base::requireNamespace("future", 
[16:04:48.714]                             quietly = TRUE)
[16:04:48.714]                           if (has_future) {
[16:04:48.714]                             ns <- base::getNamespace("future")
[16:04:48.714]                             version <- ns[[".package"]][["version"]]
[16:04:48.714]                             if (is.null(version)) 
[16:04:48.714]                               version <- utils::packageVersion("future")
[16:04:48.714]                           }
[16:04:48.714]                           else {
[16:04:48.714]                             version <- NULL
[16:04:48.714]                           }
[16:04:48.714]                           if (!has_future || version < "1.8.0") {
[16:04:48.714]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.714]                               "", base::R.version$version.string), 
[16:04:48.714]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.714]                                 base::R.version$platform, 8 * 
[16:04:48.714]                                   base::.Machine$sizeof.pointer), 
[16:04:48.714]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.714]                                 "release", "version")], collapse = " "), 
[16:04:48.714]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.714]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.714]                               info)
[16:04:48.714]                             info <- base::paste(info, collapse = "; ")
[16:04:48.714]                             if (!has_future) {
[16:04:48.714]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.714]                                 info)
[16:04:48.714]                             }
[16:04:48.714]                             else {
[16:04:48.714]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.714]                                 info, version)
[16:04:48.714]                             }
[16:04:48.714]                             base::stop(msg)
[16:04:48.714]                           }
[16:04:48.714]                         })
[16:04:48.714]                       }
[16:04:48.714]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.714]                       base::options(mc.cores = 1L)
[16:04:48.714]                     }
[16:04:48.714]                     base::local({
[16:04:48.714]                       for (pkg in "stats") {
[16:04:48.714]                         base::loadNamespace(pkg)
[16:04:48.714]                         base::library(pkg, character.only = TRUE)
[16:04:48.714]                       }
[16:04:48.714]                     })
[16:04:48.714]                   }
[16:04:48.714]                   options(future.plan = NULL)
[16:04:48.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.714]                 }
[16:04:48.714]                 ...future.workdir <- getwd()
[16:04:48.714]             }
[16:04:48.714]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.714]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.714]         }
[16:04:48.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.714]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.714]             base::names(...future.oldOptions))
[16:04:48.714]     }
[16:04:48.714]     if (FALSE) {
[16:04:48.714]     }
[16:04:48.714]     else {
[16:04:48.714]         if (TRUE) {
[16:04:48.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.714]                 open = "w")
[16:04:48.714]         }
[16:04:48.714]         else {
[16:04:48.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.714]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.714]         }
[16:04:48.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.714]             base::sink(type = "output", split = FALSE)
[16:04:48.714]             base::close(...future.stdout)
[16:04:48.714]         }, add = TRUE)
[16:04:48.714]     }
[16:04:48.714]     ...future.frame <- base::sys.nframe()
[16:04:48.714]     ...future.conditions <- base::list()
[16:04:48.714]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.714]     if (FALSE) {
[16:04:48.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.714]     }
[16:04:48.714]     ...future.result <- base::tryCatch({
[16:04:48.714]         base::withCallingHandlers({
[16:04:48.714]             ...future.value <- base::withVisible(base::local({
[16:04:48.714]                 withCallingHandlers({
[16:04:48.714]                   {
[16:04:48.714]                     lm(weight ~ group - 1)
[16:04:48.714]                   }
[16:04:48.714]                 }, immediateCondition = function(cond) {
[16:04:48.714]                   save_rds <- function (object, pathname, ...) 
[16:04:48.714]                   {
[16:04:48.714]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.714]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.714]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.714]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.714]                         fi_tmp[["mtime"]])
[16:04:48.714]                     }
[16:04:48.714]                     tryCatch({
[16:04:48.714]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.714]                     }, error = function(ex) {
[16:04:48.714]                       msg <- conditionMessage(ex)
[16:04:48.714]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.714]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.714]                         fi_tmp[["mtime"]], msg)
[16:04:48.714]                       ex$message <- msg
[16:04:48.714]                       stop(ex)
[16:04:48.714]                     })
[16:04:48.714]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.714]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.714]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.714]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.714]                       fi <- file.info(pathname)
[16:04:48.714]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.714]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.714]                         fi[["size"]], fi[["mtime"]])
[16:04:48.714]                       stop(msg)
[16:04:48.714]                     }
[16:04:48.714]                     invisible(pathname)
[16:04:48.714]                   }
[16:04:48.714]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.714]                     rootPath = tempdir()) 
[16:04:48.714]                   {
[16:04:48.714]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.714]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.714]                       tmpdir = path, fileext = ".rds")
[16:04:48.714]                     save_rds(obj, file)
[16:04:48.714]                   }
[16:04:48.714]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.714]                   {
[16:04:48.714]                     inherits <- base::inherits
[16:04:48.714]                     invokeRestart <- base::invokeRestart
[16:04:48.714]                     is.null <- base::is.null
[16:04:48.714]                     muffled <- FALSE
[16:04:48.714]                     if (inherits(cond, "message")) {
[16:04:48.714]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.714]                       if (muffled) 
[16:04:48.714]                         invokeRestart("muffleMessage")
[16:04:48.714]                     }
[16:04:48.714]                     else if (inherits(cond, "warning")) {
[16:04:48.714]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.714]                       if (muffled) 
[16:04:48.714]                         invokeRestart("muffleWarning")
[16:04:48.714]                     }
[16:04:48.714]                     else if (inherits(cond, "condition")) {
[16:04:48.714]                       if (!is.null(pattern)) {
[16:04:48.714]                         computeRestarts <- base::computeRestarts
[16:04:48.714]                         grepl <- base::grepl
[16:04:48.714]                         restarts <- computeRestarts(cond)
[16:04:48.714]                         for (restart in restarts) {
[16:04:48.714]                           name <- restart$name
[16:04:48.714]                           if (is.null(name)) 
[16:04:48.714]                             next
[16:04:48.714]                           if (!grepl(pattern, name)) 
[16:04:48.714]                             next
[16:04:48.714]                           invokeRestart(restart)
[16:04:48.714]                           muffled <- TRUE
[16:04:48.714]                           break
[16:04:48.714]                         }
[16:04:48.714]                       }
[16:04:48.714]                     }
[16:04:48.714]                     invisible(muffled)
[16:04:48.714]                   }
[16:04:48.714]                   muffleCondition(cond)
[16:04:48.714]                 })
[16:04:48.714]             }))
[16:04:48.714]             future::FutureResult(value = ...future.value$value, 
[16:04:48.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.714]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.714]                     ...future.globalenv.names))
[16:04:48.714]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.714]         }, condition = base::local({
[16:04:48.714]             c <- base::c
[16:04:48.714]             inherits <- base::inherits
[16:04:48.714]             invokeRestart <- base::invokeRestart
[16:04:48.714]             length <- base::length
[16:04:48.714]             list <- base::list
[16:04:48.714]             seq.int <- base::seq.int
[16:04:48.714]             signalCondition <- base::signalCondition
[16:04:48.714]             sys.calls <- base::sys.calls
[16:04:48.714]             `[[` <- base::`[[`
[16:04:48.714]             `+` <- base::`+`
[16:04:48.714]             `<<-` <- base::`<<-`
[16:04:48.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.714]                   3L)]
[16:04:48.714]             }
[16:04:48.714]             function(cond) {
[16:04:48.714]                 is_error <- inherits(cond, "error")
[16:04:48.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.714]                   NULL)
[16:04:48.714]                 if (is_error) {
[16:04:48.714]                   sessionInformation <- function() {
[16:04:48.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.714]                       search = base::search(), system = base::Sys.info())
[16:04:48.714]                   }
[16:04:48.714]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.714]                     cond$call), session = sessionInformation(), 
[16:04:48.714]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.714]                   signalCondition(cond)
[16:04:48.714]                 }
[16:04:48.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.714]                 "immediateCondition"))) {
[16:04:48.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.714]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.714]                   if (TRUE && !signal) {
[16:04:48.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.714]                     {
[16:04:48.714]                       inherits <- base::inherits
[16:04:48.714]                       invokeRestart <- base::invokeRestart
[16:04:48.714]                       is.null <- base::is.null
[16:04:48.714]                       muffled <- FALSE
[16:04:48.714]                       if (inherits(cond, "message")) {
[16:04:48.714]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.714]                         if (muffled) 
[16:04:48.714]                           invokeRestart("muffleMessage")
[16:04:48.714]                       }
[16:04:48.714]                       else if (inherits(cond, "warning")) {
[16:04:48.714]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.714]                         if (muffled) 
[16:04:48.714]                           invokeRestart("muffleWarning")
[16:04:48.714]                       }
[16:04:48.714]                       else if (inherits(cond, "condition")) {
[16:04:48.714]                         if (!is.null(pattern)) {
[16:04:48.714]                           computeRestarts <- base::computeRestarts
[16:04:48.714]                           grepl <- base::grepl
[16:04:48.714]                           restarts <- computeRestarts(cond)
[16:04:48.714]                           for (restart in restarts) {
[16:04:48.714]                             name <- restart$name
[16:04:48.714]                             if (is.null(name)) 
[16:04:48.714]                               next
[16:04:48.714]                             if (!grepl(pattern, name)) 
[16:04:48.714]                               next
[16:04:48.714]                             invokeRestart(restart)
[16:04:48.714]                             muffled <- TRUE
[16:04:48.714]                             break
[16:04:48.714]                           }
[16:04:48.714]                         }
[16:04:48.714]                       }
[16:04:48.714]                       invisible(muffled)
[16:04:48.714]                     }
[16:04:48.714]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.714]                   }
[16:04:48.714]                 }
[16:04:48.714]                 else {
[16:04:48.714]                   if (TRUE) {
[16:04:48.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.714]                     {
[16:04:48.714]                       inherits <- base::inherits
[16:04:48.714]                       invokeRestart <- base::invokeRestart
[16:04:48.714]                       is.null <- base::is.null
[16:04:48.714]                       muffled <- FALSE
[16:04:48.714]                       if (inherits(cond, "message")) {
[16:04:48.714]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.714]                         if (muffled) 
[16:04:48.714]                           invokeRestart("muffleMessage")
[16:04:48.714]                       }
[16:04:48.714]                       else if (inherits(cond, "warning")) {
[16:04:48.714]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.714]                         if (muffled) 
[16:04:48.714]                           invokeRestart("muffleWarning")
[16:04:48.714]                       }
[16:04:48.714]                       else if (inherits(cond, "condition")) {
[16:04:48.714]                         if (!is.null(pattern)) {
[16:04:48.714]                           computeRestarts <- base::computeRestarts
[16:04:48.714]                           grepl <- base::grepl
[16:04:48.714]                           restarts <- computeRestarts(cond)
[16:04:48.714]                           for (restart in restarts) {
[16:04:48.714]                             name <- restart$name
[16:04:48.714]                             if (is.null(name)) 
[16:04:48.714]                               next
[16:04:48.714]                             if (!grepl(pattern, name)) 
[16:04:48.714]                               next
[16:04:48.714]                             invokeRestart(restart)
[16:04:48.714]                             muffled <- TRUE
[16:04:48.714]                             break
[16:04:48.714]                           }
[16:04:48.714]                         }
[16:04:48.714]                       }
[16:04:48.714]                       invisible(muffled)
[16:04:48.714]                     }
[16:04:48.714]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.714]                   }
[16:04:48.714]                 }
[16:04:48.714]             }
[16:04:48.714]         }))
[16:04:48.714]     }, error = function(ex) {
[16:04:48.714]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.714]                 ...future.rng), started = ...future.startTime, 
[16:04:48.714]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.714]             version = "1.8"), class = "FutureResult")
[16:04:48.714]     }, finally = {
[16:04:48.714]         if (!identical(...future.workdir, getwd())) 
[16:04:48.714]             setwd(...future.workdir)
[16:04:48.714]         {
[16:04:48.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.714]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.714]             }
[16:04:48.714]             base::options(...future.oldOptions)
[16:04:48.714]             if (.Platform$OS.type == "windows") {
[16:04:48.714]                 old_names <- names(...future.oldEnvVars)
[16:04:48.714]                 envs <- base::Sys.getenv()
[16:04:48.714]                 names <- names(envs)
[16:04:48.714]                 common <- intersect(names, old_names)
[16:04:48.714]                 added <- setdiff(names, old_names)
[16:04:48.714]                 removed <- setdiff(old_names, names)
[16:04:48.714]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.714]                   envs[common]]
[16:04:48.714]                 NAMES <- toupper(changed)
[16:04:48.714]                 args <- list()
[16:04:48.714]                 for (kk in seq_along(NAMES)) {
[16:04:48.714]                   name <- changed[[kk]]
[16:04:48.714]                   NAME <- NAMES[[kk]]
[16:04:48.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.714]                     next
[16:04:48.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.714]                 }
[16:04:48.714]                 NAMES <- toupper(added)
[16:04:48.714]                 for (kk in seq_along(NAMES)) {
[16:04:48.714]                   name <- added[[kk]]
[16:04:48.714]                   NAME <- NAMES[[kk]]
[16:04:48.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.714]                     next
[16:04:48.714]                   args[[name]] <- ""
[16:04:48.714]                 }
[16:04:48.714]                 NAMES <- toupper(removed)
[16:04:48.714]                 for (kk in seq_along(NAMES)) {
[16:04:48.714]                   name <- removed[[kk]]
[16:04:48.714]                   NAME <- NAMES[[kk]]
[16:04:48.714]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.714]                     next
[16:04:48.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.714]                 }
[16:04:48.714]                 if (length(args) > 0) 
[16:04:48.714]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.714]             }
[16:04:48.714]             else {
[16:04:48.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.714]             }
[16:04:48.714]             {
[16:04:48.714]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.714]                   0L) {
[16:04:48.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.714]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.714]                   base::options(opts)
[16:04:48.714]                 }
[16:04:48.714]                 {
[16:04:48.714]                   {
[16:04:48.714]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.714]                     NULL
[16:04:48.714]                   }
[16:04:48.714]                   options(future.plan = NULL)
[16:04:48.714]                   if (is.na(NA_character_)) 
[16:04:48.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.714]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.714]                     envir = parent.frame()) 
[16:04:48.714]                   {
[16:04:48.714]                     default_workers <- missing(workers)
[16:04:48.714]                     if (is.function(workers)) 
[16:04:48.714]                       workers <- workers()
[16:04:48.714]                     workers <- structure(as.integer(workers), 
[16:04:48.714]                       class = class(workers))
[16:04:48.714]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.714]                       1L)
[16:04:48.714]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.714]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.714]                       if (default_workers) 
[16:04:48.714]                         supportsMulticore(warn = TRUE)
[16:04:48.714]                       return(sequential(..., envir = envir))
[16:04:48.714]                     }
[16:04:48.714]                     oopts <- options(mc.cores = workers)
[16:04:48.714]                     on.exit(options(oopts))
[16:04:48.714]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.714]                       envir = envir)
[16:04:48.714]                     if (!future$lazy) 
[16:04:48.714]                       future <- run(future)
[16:04:48.714]                     invisible(future)
[16:04:48.714]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.714]                 }
[16:04:48.714]             }
[16:04:48.714]         }
[16:04:48.714]     })
[16:04:48.714]     if (TRUE) {
[16:04:48.714]         base::sink(type = "output", split = FALSE)
[16:04:48.714]         if (TRUE) {
[16:04:48.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.714]         }
[16:04:48.714]         else {
[16:04:48.714]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.714]         }
[16:04:48.714]         base::close(...future.stdout)
[16:04:48.714]         ...future.stdout <- NULL
[16:04:48.714]     }
[16:04:48.714]     ...future.result$conditions <- ...future.conditions
[16:04:48.714]     ...future.result$finished <- base::Sys.time()
[16:04:48.714]     ...future.result
[16:04:48.714] }
[16:04:48.716] assign_globals() ...
[16:04:48.717] List of 2
[16:04:48.717]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[16:04:48.717]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[16:04:48.717]  - attr(*, "where")=List of 2
[16:04:48.717]   ..$ weight:<environment: R_EmptyEnv> 
[16:04:48.717]   ..$ group :<environment: R_EmptyEnv> 
[16:04:48.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.717]  - attr(*, "resolved")= logi FALSE
[16:04:48.717]  - attr(*, "total_size")= num 896
[16:04:48.717]  - attr(*, "already-done")= logi TRUE
[16:04:48.721] - copied ‘weight’ to environment
[16:04:48.721] - copied ‘group’ to environment
[16:04:48.721] assign_globals() ... done
[16:04:48.721] requestCore(): workers = 2
[16:04:48.723] MulticoreFuture started
[16:04:48.723] - Launch lazy future ... done
[16:04:48.723] run() for ‘MulticoreFuture’ ... done
[16:04:48.724] result() for MulticoreFuture ...
[16:04:48.724] plan(): Setting new future strategy stack:
[16:04:48.725] List of future strategies:
[16:04:48.725] 1. sequential:
[16:04:48.725]    - args: function (..., envir = parent.frame())
[16:04:48.725]    - tweaked: FALSE
[16:04:48.725]    - call: NULL
[16:04:48.725] plan(): nbrOfWorkers() = 1
[16:04:48.729] plan(): Setting new future strategy stack:
[16:04:48.729] List of future strategies:
[16:04:48.729] 1. multicore:
[16:04:48.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.729]    - tweaked: FALSE
[16:04:48.729]    - call: plan(strategy)
[16:04:48.734] plan(): nbrOfWorkers() = 2
[16:04:48.736] result() for MulticoreFuture ...
[16:04:48.736] result() for MulticoreFuture ... done
[16:04:48.736] result() for MulticoreFuture ... done
[16:04:48.736] result() for MulticoreFuture ...
[16:04:48.737] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:04:48.739] getGlobalsAndPackages() ...
[16:04:48.739] Searching for globals...
[16:04:48.741] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:48.741] Searching for globals ... DONE
[16:04:48.741] Resolving globals: FALSE
[16:04:48.741] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:48.742] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:48.742] - globals: [1] ‘x’
[16:04:48.742] - packages: [1] ‘stats’
[16:04:48.742] getGlobalsAndPackages() ... DONE
[16:04:48.743] run() for ‘Future’ ...
[16:04:48.743] - state: ‘created’
[16:04:48.743] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.747] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.747]   - Field: ‘label’
[16:04:48.747]   - Field: ‘local’
[16:04:48.747]   - Field: ‘owner’
[16:04:48.748]   - Field: ‘envir’
[16:04:48.748]   - Field: ‘workers’
[16:04:48.748]   - Field: ‘packages’
[16:04:48.748]   - Field: ‘gc’
[16:04:48.748]   - Field: ‘job’
[16:04:48.748]   - Field: ‘conditions’
[16:04:48.748]   - Field: ‘expr’
[16:04:48.748]   - Field: ‘uuid’
[16:04:48.748]   - Field: ‘seed’
[16:04:48.749]   - Field: ‘version’
[16:04:48.749]   - Field: ‘result’
[16:04:48.749]   - Field: ‘asynchronous’
[16:04:48.749]   - Field: ‘calls’
[16:04:48.749]   - Field: ‘globals’
[16:04:48.749]   - Field: ‘stdout’
[16:04:48.749]   - Field: ‘earlySignal’
[16:04:48.749]   - Field: ‘lazy’
[16:04:48.749]   - Field: ‘state’
[16:04:48.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.750] - Launch lazy future ...
[16:04:48.750] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.750] Packages needed by future strategies (n = 0): <none>
[16:04:48.751] {
[16:04:48.751]     {
[16:04:48.751]         {
[16:04:48.751]             ...future.startTime <- base::Sys.time()
[16:04:48.751]             {
[16:04:48.751]                 {
[16:04:48.751]                   {
[16:04:48.751]                     {
[16:04:48.751]                       {
[16:04:48.751]                         base::local({
[16:04:48.751]                           has_future <- base::requireNamespace("future", 
[16:04:48.751]                             quietly = TRUE)
[16:04:48.751]                           if (has_future) {
[16:04:48.751]                             ns <- base::getNamespace("future")
[16:04:48.751]                             version <- ns[[".package"]][["version"]]
[16:04:48.751]                             if (is.null(version)) 
[16:04:48.751]                               version <- utils::packageVersion("future")
[16:04:48.751]                           }
[16:04:48.751]                           else {
[16:04:48.751]                             version <- NULL
[16:04:48.751]                           }
[16:04:48.751]                           if (!has_future || version < "1.8.0") {
[16:04:48.751]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.751]                               "", base::R.version$version.string), 
[16:04:48.751]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.751]                                 base::R.version$platform, 8 * 
[16:04:48.751]                                   base::.Machine$sizeof.pointer), 
[16:04:48.751]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.751]                                 "release", "version")], collapse = " "), 
[16:04:48.751]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.751]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.751]                               info)
[16:04:48.751]                             info <- base::paste(info, collapse = "; ")
[16:04:48.751]                             if (!has_future) {
[16:04:48.751]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.751]                                 info)
[16:04:48.751]                             }
[16:04:48.751]                             else {
[16:04:48.751]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.751]                                 info, version)
[16:04:48.751]                             }
[16:04:48.751]                             base::stop(msg)
[16:04:48.751]                           }
[16:04:48.751]                         })
[16:04:48.751]                       }
[16:04:48.751]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.751]                       base::options(mc.cores = 1L)
[16:04:48.751]                     }
[16:04:48.751]                     base::local({
[16:04:48.751]                       for (pkg in "stats") {
[16:04:48.751]                         base::loadNamespace(pkg)
[16:04:48.751]                         base::library(pkg, character.only = TRUE)
[16:04:48.751]                       }
[16:04:48.751]                     })
[16:04:48.751]                   }
[16:04:48.751]                   options(future.plan = NULL)
[16:04:48.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.751]                 }
[16:04:48.751]                 ...future.workdir <- getwd()
[16:04:48.751]             }
[16:04:48.751]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.751]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.751]         }
[16:04:48.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.751]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.751]             base::names(...future.oldOptions))
[16:04:48.751]     }
[16:04:48.751]     if (FALSE) {
[16:04:48.751]     }
[16:04:48.751]     else {
[16:04:48.751]         if (TRUE) {
[16:04:48.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.751]                 open = "w")
[16:04:48.751]         }
[16:04:48.751]         else {
[16:04:48.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.751]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.751]         }
[16:04:48.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.751]             base::sink(type = "output", split = FALSE)
[16:04:48.751]             base::close(...future.stdout)
[16:04:48.751]         }, add = TRUE)
[16:04:48.751]     }
[16:04:48.751]     ...future.frame <- base::sys.nframe()
[16:04:48.751]     ...future.conditions <- base::list()
[16:04:48.751]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.751]     if (FALSE) {
[16:04:48.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.751]     }
[16:04:48.751]     ...future.result <- base::tryCatch({
[16:04:48.751]         base::withCallingHandlers({
[16:04:48.751]             ...future.value <- base::withVisible(base::local({
[16:04:48.751]                 withCallingHandlers({
[16:04:48.751]                   {
[16:04:48.751]                     xtabs(~x)
[16:04:48.751]                   }
[16:04:48.751]                 }, immediateCondition = function(cond) {
[16:04:48.751]                   save_rds <- function (object, pathname, ...) 
[16:04:48.751]                   {
[16:04:48.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.751]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.751]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.751]                         fi_tmp[["mtime"]])
[16:04:48.751]                     }
[16:04:48.751]                     tryCatch({
[16:04:48.751]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.751]                     }, error = function(ex) {
[16:04:48.751]                       msg <- conditionMessage(ex)
[16:04:48.751]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.751]                         fi_tmp[["mtime"]], msg)
[16:04:48.751]                       ex$message <- msg
[16:04:48.751]                       stop(ex)
[16:04:48.751]                     })
[16:04:48.751]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.751]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.751]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.751]                       fi <- file.info(pathname)
[16:04:48.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.751]                         fi[["size"]], fi[["mtime"]])
[16:04:48.751]                       stop(msg)
[16:04:48.751]                     }
[16:04:48.751]                     invisible(pathname)
[16:04:48.751]                   }
[16:04:48.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.751]                     rootPath = tempdir()) 
[16:04:48.751]                   {
[16:04:48.751]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.751]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.751]                       tmpdir = path, fileext = ".rds")
[16:04:48.751]                     save_rds(obj, file)
[16:04:48.751]                   }
[16:04:48.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.751]                   {
[16:04:48.751]                     inherits <- base::inherits
[16:04:48.751]                     invokeRestart <- base::invokeRestart
[16:04:48.751]                     is.null <- base::is.null
[16:04:48.751]                     muffled <- FALSE
[16:04:48.751]                     if (inherits(cond, "message")) {
[16:04:48.751]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.751]                       if (muffled) 
[16:04:48.751]                         invokeRestart("muffleMessage")
[16:04:48.751]                     }
[16:04:48.751]                     else if (inherits(cond, "warning")) {
[16:04:48.751]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.751]                       if (muffled) 
[16:04:48.751]                         invokeRestart("muffleWarning")
[16:04:48.751]                     }
[16:04:48.751]                     else if (inherits(cond, "condition")) {
[16:04:48.751]                       if (!is.null(pattern)) {
[16:04:48.751]                         computeRestarts <- base::computeRestarts
[16:04:48.751]                         grepl <- base::grepl
[16:04:48.751]                         restarts <- computeRestarts(cond)
[16:04:48.751]                         for (restart in restarts) {
[16:04:48.751]                           name <- restart$name
[16:04:48.751]                           if (is.null(name)) 
[16:04:48.751]                             next
[16:04:48.751]                           if (!grepl(pattern, name)) 
[16:04:48.751]                             next
[16:04:48.751]                           invokeRestart(restart)
[16:04:48.751]                           muffled <- TRUE
[16:04:48.751]                           break
[16:04:48.751]                         }
[16:04:48.751]                       }
[16:04:48.751]                     }
[16:04:48.751]                     invisible(muffled)
[16:04:48.751]                   }
[16:04:48.751]                   muffleCondition(cond)
[16:04:48.751]                 })
[16:04:48.751]             }))
[16:04:48.751]             future::FutureResult(value = ...future.value$value, 
[16:04:48.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.751]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.751]                     ...future.globalenv.names))
[16:04:48.751]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.751]         }, condition = base::local({
[16:04:48.751]             c <- base::c
[16:04:48.751]             inherits <- base::inherits
[16:04:48.751]             invokeRestart <- base::invokeRestart
[16:04:48.751]             length <- base::length
[16:04:48.751]             list <- base::list
[16:04:48.751]             seq.int <- base::seq.int
[16:04:48.751]             signalCondition <- base::signalCondition
[16:04:48.751]             sys.calls <- base::sys.calls
[16:04:48.751]             `[[` <- base::`[[`
[16:04:48.751]             `+` <- base::`+`
[16:04:48.751]             `<<-` <- base::`<<-`
[16:04:48.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.751]                   3L)]
[16:04:48.751]             }
[16:04:48.751]             function(cond) {
[16:04:48.751]                 is_error <- inherits(cond, "error")
[16:04:48.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.751]                   NULL)
[16:04:48.751]                 if (is_error) {
[16:04:48.751]                   sessionInformation <- function() {
[16:04:48.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.751]                       search = base::search(), system = base::Sys.info())
[16:04:48.751]                   }
[16:04:48.751]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.751]                     cond$call), session = sessionInformation(), 
[16:04:48.751]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.751]                   signalCondition(cond)
[16:04:48.751]                 }
[16:04:48.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.751]                 "immediateCondition"))) {
[16:04:48.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.751]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.751]                   if (TRUE && !signal) {
[16:04:48.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.751]                     {
[16:04:48.751]                       inherits <- base::inherits
[16:04:48.751]                       invokeRestart <- base::invokeRestart
[16:04:48.751]                       is.null <- base::is.null
[16:04:48.751]                       muffled <- FALSE
[16:04:48.751]                       if (inherits(cond, "message")) {
[16:04:48.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.751]                         if (muffled) 
[16:04:48.751]                           invokeRestart("muffleMessage")
[16:04:48.751]                       }
[16:04:48.751]                       else if (inherits(cond, "warning")) {
[16:04:48.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.751]                         if (muffled) 
[16:04:48.751]                           invokeRestart("muffleWarning")
[16:04:48.751]                       }
[16:04:48.751]                       else if (inherits(cond, "condition")) {
[16:04:48.751]                         if (!is.null(pattern)) {
[16:04:48.751]                           computeRestarts <- base::computeRestarts
[16:04:48.751]                           grepl <- base::grepl
[16:04:48.751]                           restarts <- computeRestarts(cond)
[16:04:48.751]                           for (restart in restarts) {
[16:04:48.751]                             name <- restart$name
[16:04:48.751]                             if (is.null(name)) 
[16:04:48.751]                               next
[16:04:48.751]                             if (!grepl(pattern, name)) 
[16:04:48.751]                               next
[16:04:48.751]                             invokeRestart(restart)
[16:04:48.751]                             muffled <- TRUE
[16:04:48.751]                             break
[16:04:48.751]                           }
[16:04:48.751]                         }
[16:04:48.751]                       }
[16:04:48.751]                       invisible(muffled)
[16:04:48.751]                     }
[16:04:48.751]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.751]                   }
[16:04:48.751]                 }
[16:04:48.751]                 else {
[16:04:48.751]                   if (TRUE) {
[16:04:48.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.751]                     {
[16:04:48.751]                       inherits <- base::inherits
[16:04:48.751]                       invokeRestart <- base::invokeRestart
[16:04:48.751]                       is.null <- base::is.null
[16:04:48.751]                       muffled <- FALSE
[16:04:48.751]                       if (inherits(cond, "message")) {
[16:04:48.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.751]                         if (muffled) 
[16:04:48.751]                           invokeRestart("muffleMessage")
[16:04:48.751]                       }
[16:04:48.751]                       else if (inherits(cond, "warning")) {
[16:04:48.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.751]                         if (muffled) 
[16:04:48.751]                           invokeRestart("muffleWarning")
[16:04:48.751]                       }
[16:04:48.751]                       else if (inherits(cond, "condition")) {
[16:04:48.751]                         if (!is.null(pattern)) {
[16:04:48.751]                           computeRestarts <- base::computeRestarts
[16:04:48.751]                           grepl <- base::grepl
[16:04:48.751]                           restarts <- computeRestarts(cond)
[16:04:48.751]                           for (restart in restarts) {
[16:04:48.751]                             name <- restart$name
[16:04:48.751]                             if (is.null(name)) 
[16:04:48.751]                               next
[16:04:48.751]                             if (!grepl(pattern, name)) 
[16:04:48.751]                               next
[16:04:48.751]                             invokeRestart(restart)
[16:04:48.751]                             muffled <- TRUE
[16:04:48.751]                             break
[16:04:48.751]                           }
[16:04:48.751]                         }
[16:04:48.751]                       }
[16:04:48.751]                       invisible(muffled)
[16:04:48.751]                     }
[16:04:48.751]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.751]                   }
[16:04:48.751]                 }
[16:04:48.751]             }
[16:04:48.751]         }))
[16:04:48.751]     }, error = function(ex) {
[16:04:48.751]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.751]                 ...future.rng), started = ...future.startTime, 
[16:04:48.751]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.751]             version = "1.8"), class = "FutureResult")
[16:04:48.751]     }, finally = {
[16:04:48.751]         if (!identical(...future.workdir, getwd())) 
[16:04:48.751]             setwd(...future.workdir)
[16:04:48.751]         {
[16:04:48.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.751]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.751]             }
[16:04:48.751]             base::options(...future.oldOptions)
[16:04:48.751]             if (.Platform$OS.type == "windows") {
[16:04:48.751]                 old_names <- names(...future.oldEnvVars)
[16:04:48.751]                 envs <- base::Sys.getenv()
[16:04:48.751]                 names <- names(envs)
[16:04:48.751]                 common <- intersect(names, old_names)
[16:04:48.751]                 added <- setdiff(names, old_names)
[16:04:48.751]                 removed <- setdiff(old_names, names)
[16:04:48.751]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.751]                   envs[common]]
[16:04:48.751]                 NAMES <- toupper(changed)
[16:04:48.751]                 args <- list()
[16:04:48.751]                 for (kk in seq_along(NAMES)) {
[16:04:48.751]                   name <- changed[[kk]]
[16:04:48.751]                   NAME <- NAMES[[kk]]
[16:04:48.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.751]                     next
[16:04:48.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.751]                 }
[16:04:48.751]                 NAMES <- toupper(added)
[16:04:48.751]                 for (kk in seq_along(NAMES)) {
[16:04:48.751]                   name <- added[[kk]]
[16:04:48.751]                   NAME <- NAMES[[kk]]
[16:04:48.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.751]                     next
[16:04:48.751]                   args[[name]] <- ""
[16:04:48.751]                 }
[16:04:48.751]                 NAMES <- toupper(removed)
[16:04:48.751]                 for (kk in seq_along(NAMES)) {
[16:04:48.751]                   name <- removed[[kk]]
[16:04:48.751]                   NAME <- NAMES[[kk]]
[16:04:48.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.751]                     next
[16:04:48.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.751]                 }
[16:04:48.751]                 if (length(args) > 0) 
[16:04:48.751]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.751]             }
[16:04:48.751]             else {
[16:04:48.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.751]             }
[16:04:48.751]             {
[16:04:48.751]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.751]                   0L) {
[16:04:48.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.751]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.751]                   base::options(opts)
[16:04:48.751]                 }
[16:04:48.751]                 {
[16:04:48.751]                   {
[16:04:48.751]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.751]                     NULL
[16:04:48.751]                   }
[16:04:48.751]                   options(future.plan = NULL)
[16:04:48.751]                   if (is.na(NA_character_)) 
[16:04:48.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.751]                     envir = parent.frame()) 
[16:04:48.751]                   {
[16:04:48.751]                     default_workers <- missing(workers)
[16:04:48.751]                     if (is.function(workers)) 
[16:04:48.751]                       workers <- workers()
[16:04:48.751]                     workers <- structure(as.integer(workers), 
[16:04:48.751]                       class = class(workers))
[16:04:48.751]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.751]                       1L)
[16:04:48.751]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.751]                       if (default_workers) 
[16:04:48.751]                         supportsMulticore(warn = TRUE)
[16:04:48.751]                       return(sequential(..., envir = envir))
[16:04:48.751]                     }
[16:04:48.751]                     oopts <- options(mc.cores = workers)
[16:04:48.751]                     on.exit(options(oopts))
[16:04:48.751]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.751]                       envir = envir)
[16:04:48.751]                     if (!future$lazy) 
[16:04:48.751]                       future <- run(future)
[16:04:48.751]                     invisible(future)
[16:04:48.751]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.751]                 }
[16:04:48.751]             }
[16:04:48.751]         }
[16:04:48.751]     })
[16:04:48.751]     if (TRUE) {
[16:04:48.751]         base::sink(type = "output", split = FALSE)
[16:04:48.751]         if (TRUE) {
[16:04:48.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.751]         }
[16:04:48.751]         else {
[16:04:48.751]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.751]         }
[16:04:48.751]         base::close(...future.stdout)
[16:04:48.751]         ...future.stdout <- NULL
[16:04:48.751]     }
[16:04:48.751]     ...future.result$conditions <- ...future.conditions
[16:04:48.751]     ...future.result$finished <- base::Sys.time()
[16:04:48.751]     ...future.result
[16:04:48.751] }
[16:04:48.754] assign_globals() ...
[16:04:48.754] List of 1
[16:04:48.754]  $ x: num [1:5] 1 1 2 2 2
[16:04:48.754]  - attr(*, "where")=List of 1
[16:04:48.754]   ..$ x:<environment: R_EmptyEnv> 
[16:04:48.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.754]  - attr(*, "resolved")= logi FALSE
[16:04:48.754]  - attr(*, "total_size")= num 96
[16:04:48.754]  - attr(*, "already-done")= logi TRUE
[16:04:48.759] - copied ‘x’ to environment
[16:04:48.759] assign_globals() ... done
[16:04:48.759] requestCore(): workers = 2
[16:04:48.761] MulticoreFuture started
[16:04:48.762] - Launch lazy future ... done
[16:04:48.762] run() for ‘MulticoreFuture’ ... done
[16:04:48.762] result() for MulticoreFuture ...
[16:04:48.763] plan(): Setting new future strategy stack:
[16:04:48.763] List of future strategies:
[16:04:48.763] 1. sequential:
[16:04:48.763]    - args: function (..., envir = parent.frame())
[16:04:48.763]    - tweaked: FALSE
[16:04:48.763]    - call: NULL
[16:04:48.764] plan(): nbrOfWorkers() = 1
[16:04:48.767] plan(): Setting new future strategy stack:
[16:04:48.767] List of future strategies:
[16:04:48.767] 1. multicore:
[16:04:48.767]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.767]    - tweaked: FALSE
[16:04:48.767]    - call: plan(strategy)
[16:04:48.772] plan(): nbrOfWorkers() = 2
[16:04:48.773] result() for MulticoreFuture ...
[16:04:48.774] result() for MulticoreFuture ... done
[16:04:48.774] result() for MulticoreFuture ... done
[16:04:48.774] result() for MulticoreFuture ...
[16:04:48.774] result() for MulticoreFuture ... done
x
1 2 
2 3 
[16:04:48.775] getGlobalsAndPackages() ...
[16:04:48.775] Searching for globals...
[16:04:48.777] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:48.777] Searching for globals ... DONE
[16:04:48.777] Resolving globals: FALSE
[16:04:48.778] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:48.778] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:48.779] - globals: [1] ‘x’
[16:04:48.779] - packages: [1] ‘stats’
[16:04:48.779] getGlobalsAndPackages() ... DONE
[16:04:48.779] run() for ‘Future’ ...
[16:04:48.779] - state: ‘created’
[16:04:48.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.784] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.784]   - Field: ‘label’
[16:04:48.784]   - Field: ‘local’
[16:04:48.784]   - Field: ‘owner’
[16:04:48.784]   - Field: ‘envir’
[16:04:48.784]   - Field: ‘workers’
[16:04:48.784]   - Field: ‘packages’
[16:04:48.785]   - Field: ‘gc’
[16:04:48.785]   - Field: ‘job’
[16:04:48.785]   - Field: ‘conditions’
[16:04:48.785]   - Field: ‘expr’
[16:04:48.785]   - Field: ‘uuid’
[16:04:48.785]   - Field: ‘seed’
[16:04:48.785]   - Field: ‘version’
[16:04:48.785]   - Field: ‘result’
[16:04:48.785]   - Field: ‘asynchronous’
[16:04:48.786]   - Field: ‘calls’
[16:04:48.786]   - Field: ‘globals’
[16:04:48.786]   - Field: ‘stdout’
[16:04:48.786]   - Field: ‘earlySignal’
[16:04:48.786]   - Field: ‘lazy’
[16:04:48.786]   - Field: ‘state’
[16:04:48.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.786] - Launch lazy future ...
[16:04:48.787] Packages needed by the future expression (n = 1): ‘stats’
[16:04:48.787] Packages needed by future strategies (n = 0): <none>
[16:04:48.788] {
[16:04:48.788]     {
[16:04:48.788]         {
[16:04:48.788]             ...future.startTime <- base::Sys.time()
[16:04:48.788]             {
[16:04:48.788]                 {
[16:04:48.788]                   {
[16:04:48.788]                     {
[16:04:48.788]                       {
[16:04:48.788]                         base::local({
[16:04:48.788]                           has_future <- base::requireNamespace("future", 
[16:04:48.788]                             quietly = TRUE)
[16:04:48.788]                           if (has_future) {
[16:04:48.788]                             ns <- base::getNamespace("future")
[16:04:48.788]                             version <- ns[[".package"]][["version"]]
[16:04:48.788]                             if (is.null(version)) 
[16:04:48.788]                               version <- utils::packageVersion("future")
[16:04:48.788]                           }
[16:04:48.788]                           else {
[16:04:48.788]                             version <- NULL
[16:04:48.788]                           }
[16:04:48.788]                           if (!has_future || version < "1.8.0") {
[16:04:48.788]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.788]                               "", base::R.version$version.string), 
[16:04:48.788]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.788]                                 base::R.version$platform, 8 * 
[16:04:48.788]                                   base::.Machine$sizeof.pointer), 
[16:04:48.788]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.788]                                 "release", "version")], collapse = " "), 
[16:04:48.788]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.788]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.788]                               info)
[16:04:48.788]                             info <- base::paste(info, collapse = "; ")
[16:04:48.788]                             if (!has_future) {
[16:04:48.788]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.788]                                 info)
[16:04:48.788]                             }
[16:04:48.788]                             else {
[16:04:48.788]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.788]                                 info, version)
[16:04:48.788]                             }
[16:04:48.788]                             base::stop(msg)
[16:04:48.788]                           }
[16:04:48.788]                         })
[16:04:48.788]                       }
[16:04:48.788]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.788]                       base::options(mc.cores = 1L)
[16:04:48.788]                     }
[16:04:48.788]                     base::local({
[16:04:48.788]                       for (pkg in "stats") {
[16:04:48.788]                         base::loadNamespace(pkg)
[16:04:48.788]                         base::library(pkg, character.only = TRUE)
[16:04:48.788]                       }
[16:04:48.788]                     })
[16:04:48.788]                   }
[16:04:48.788]                   options(future.plan = NULL)
[16:04:48.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.788]                 }
[16:04:48.788]                 ...future.workdir <- getwd()
[16:04:48.788]             }
[16:04:48.788]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.788]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.788]         }
[16:04:48.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.788]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.788]             base::names(...future.oldOptions))
[16:04:48.788]     }
[16:04:48.788]     if (FALSE) {
[16:04:48.788]     }
[16:04:48.788]     else {
[16:04:48.788]         if (TRUE) {
[16:04:48.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.788]                 open = "w")
[16:04:48.788]         }
[16:04:48.788]         else {
[16:04:48.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.788]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.788]         }
[16:04:48.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.788]             base::sink(type = "output", split = FALSE)
[16:04:48.788]             base::close(...future.stdout)
[16:04:48.788]         }, add = TRUE)
[16:04:48.788]     }
[16:04:48.788]     ...future.frame <- base::sys.nframe()
[16:04:48.788]     ...future.conditions <- base::list()
[16:04:48.788]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.788]     if (FALSE) {
[16:04:48.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.788]     }
[16:04:48.788]     ...future.result <- base::tryCatch({
[16:04:48.788]         base::withCallingHandlers({
[16:04:48.788]             ...future.value <- base::withVisible(base::local({
[16:04:48.788]                 withCallingHandlers({
[16:04:48.788]                   {
[16:04:48.788]                     xtabs(~x)
[16:04:48.788]                   }
[16:04:48.788]                 }, immediateCondition = function(cond) {
[16:04:48.788]                   save_rds <- function (object, pathname, ...) 
[16:04:48.788]                   {
[16:04:48.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.788]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.788]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.788]                         fi_tmp[["mtime"]])
[16:04:48.788]                     }
[16:04:48.788]                     tryCatch({
[16:04:48.788]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.788]                     }, error = function(ex) {
[16:04:48.788]                       msg <- conditionMessage(ex)
[16:04:48.788]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.788]                         fi_tmp[["mtime"]], msg)
[16:04:48.788]                       ex$message <- msg
[16:04:48.788]                       stop(ex)
[16:04:48.788]                     })
[16:04:48.788]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.788]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.788]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.788]                       fi <- file.info(pathname)
[16:04:48.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.788]                         fi[["size"]], fi[["mtime"]])
[16:04:48.788]                       stop(msg)
[16:04:48.788]                     }
[16:04:48.788]                     invisible(pathname)
[16:04:48.788]                   }
[16:04:48.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.788]                     rootPath = tempdir()) 
[16:04:48.788]                   {
[16:04:48.788]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.788]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.788]                       tmpdir = path, fileext = ".rds")
[16:04:48.788]                     save_rds(obj, file)
[16:04:48.788]                   }
[16:04:48.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.788]                   {
[16:04:48.788]                     inherits <- base::inherits
[16:04:48.788]                     invokeRestart <- base::invokeRestart
[16:04:48.788]                     is.null <- base::is.null
[16:04:48.788]                     muffled <- FALSE
[16:04:48.788]                     if (inherits(cond, "message")) {
[16:04:48.788]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.788]                       if (muffled) 
[16:04:48.788]                         invokeRestart("muffleMessage")
[16:04:48.788]                     }
[16:04:48.788]                     else if (inherits(cond, "warning")) {
[16:04:48.788]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.788]                       if (muffled) 
[16:04:48.788]                         invokeRestart("muffleWarning")
[16:04:48.788]                     }
[16:04:48.788]                     else if (inherits(cond, "condition")) {
[16:04:48.788]                       if (!is.null(pattern)) {
[16:04:48.788]                         computeRestarts <- base::computeRestarts
[16:04:48.788]                         grepl <- base::grepl
[16:04:48.788]                         restarts <- computeRestarts(cond)
[16:04:48.788]                         for (restart in restarts) {
[16:04:48.788]                           name <- restart$name
[16:04:48.788]                           if (is.null(name)) 
[16:04:48.788]                             next
[16:04:48.788]                           if (!grepl(pattern, name)) 
[16:04:48.788]                             next
[16:04:48.788]                           invokeRestart(restart)
[16:04:48.788]                           muffled <- TRUE
[16:04:48.788]                           break
[16:04:48.788]                         }
[16:04:48.788]                       }
[16:04:48.788]                     }
[16:04:48.788]                     invisible(muffled)
[16:04:48.788]                   }
[16:04:48.788]                   muffleCondition(cond)
[16:04:48.788]                 })
[16:04:48.788]             }))
[16:04:48.788]             future::FutureResult(value = ...future.value$value, 
[16:04:48.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.788]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.788]                     ...future.globalenv.names))
[16:04:48.788]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.788]         }, condition = base::local({
[16:04:48.788]             c <- base::c
[16:04:48.788]             inherits <- base::inherits
[16:04:48.788]             invokeRestart <- base::invokeRestart
[16:04:48.788]             length <- base::length
[16:04:48.788]             list <- base::list
[16:04:48.788]             seq.int <- base::seq.int
[16:04:48.788]             signalCondition <- base::signalCondition
[16:04:48.788]             sys.calls <- base::sys.calls
[16:04:48.788]             `[[` <- base::`[[`
[16:04:48.788]             `+` <- base::`+`
[16:04:48.788]             `<<-` <- base::`<<-`
[16:04:48.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.788]                   3L)]
[16:04:48.788]             }
[16:04:48.788]             function(cond) {
[16:04:48.788]                 is_error <- inherits(cond, "error")
[16:04:48.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.788]                   NULL)
[16:04:48.788]                 if (is_error) {
[16:04:48.788]                   sessionInformation <- function() {
[16:04:48.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.788]                       search = base::search(), system = base::Sys.info())
[16:04:48.788]                   }
[16:04:48.788]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.788]                     cond$call), session = sessionInformation(), 
[16:04:48.788]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.788]                   signalCondition(cond)
[16:04:48.788]                 }
[16:04:48.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.788]                 "immediateCondition"))) {
[16:04:48.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.788]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.788]                   if (TRUE && !signal) {
[16:04:48.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.788]                     {
[16:04:48.788]                       inherits <- base::inherits
[16:04:48.788]                       invokeRestart <- base::invokeRestart
[16:04:48.788]                       is.null <- base::is.null
[16:04:48.788]                       muffled <- FALSE
[16:04:48.788]                       if (inherits(cond, "message")) {
[16:04:48.788]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.788]                         if (muffled) 
[16:04:48.788]                           invokeRestart("muffleMessage")
[16:04:48.788]                       }
[16:04:48.788]                       else if (inherits(cond, "warning")) {
[16:04:48.788]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.788]                         if (muffled) 
[16:04:48.788]                           invokeRestart("muffleWarning")
[16:04:48.788]                       }
[16:04:48.788]                       else if (inherits(cond, "condition")) {
[16:04:48.788]                         if (!is.null(pattern)) {
[16:04:48.788]                           computeRestarts <- base::computeRestarts
[16:04:48.788]                           grepl <- base::grepl
[16:04:48.788]                           restarts <- computeRestarts(cond)
[16:04:48.788]                           for (restart in restarts) {
[16:04:48.788]                             name <- restart$name
[16:04:48.788]                             if (is.null(name)) 
[16:04:48.788]                               next
[16:04:48.788]                             if (!grepl(pattern, name)) 
[16:04:48.788]                               next
[16:04:48.788]                             invokeRestart(restart)
[16:04:48.788]                             muffled <- TRUE
[16:04:48.788]                             break
[16:04:48.788]                           }
[16:04:48.788]                         }
[16:04:48.788]                       }
[16:04:48.788]                       invisible(muffled)
[16:04:48.788]                     }
[16:04:48.788]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.788]                   }
[16:04:48.788]                 }
[16:04:48.788]                 else {
[16:04:48.788]                   if (TRUE) {
[16:04:48.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.788]                     {
[16:04:48.788]                       inherits <- base::inherits
[16:04:48.788]                       invokeRestart <- base::invokeRestart
[16:04:48.788]                       is.null <- base::is.null
[16:04:48.788]                       muffled <- FALSE
[16:04:48.788]                       if (inherits(cond, "message")) {
[16:04:48.788]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.788]                         if (muffled) 
[16:04:48.788]                           invokeRestart("muffleMessage")
[16:04:48.788]                       }
[16:04:48.788]                       else if (inherits(cond, "warning")) {
[16:04:48.788]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.788]                         if (muffled) 
[16:04:48.788]                           invokeRestart("muffleWarning")
[16:04:48.788]                       }
[16:04:48.788]                       else if (inherits(cond, "condition")) {
[16:04:48.788]                         if (!is.null(pattern)) {
[16:04:48.788]                           computeRestarts <- base::computeRestarts
[16:04:48.788]                           grepl <- base::grepl
[16:04:48.788]                           restarts <- computeRestarts(cond)
[16:04:48.788]                           for (restart in restarts) {
[16:04:48.788]                             name <- restart$name
[16:04:48.788]                             if (is.null(name)) 
[16:04:48.788]                               next
[16:04:48.788]                             if (!grepl(pattern, name)) 
[16:04:48.788]                               next
[16:04:48.788]                             invokeRestart(restart)
[16:04:48.788]                             muffled <- TRUE
[16:04:48.788]                             break
[16:04:48.788]                           }
[16:04:48.788]                         }
[16:04:48.788]                       }
[16:04:48.788]                       invisible(muffled)
[16:04:48.788]                     }
[16:04:48.788]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.788]                   }
[16:04:48.788]                 }
[16:04:48.788]             }
[16:04:48.788]         }))
[16:04:48.788]     }, error = function(ex) {
[16:04:48.788]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.788]                 ...future.rng), started = ...future.startTime, 
[16:04:48.788]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.788]             version = "1.8"), class = "FutureResult")
[16:04:48.788]     }, finally = {
[16:04:48.788]         if (!identical(...future.workdir, getwd())) 
[16:04:48.788]             setwd(...future.workdir)
[16:04:48.788]         {
[16:04:48.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.788]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.788]             }
[16:04:48.788]             base::options(...future.oldOptions)
[16:04:48.788]             if (.Platform$OS.type == "windows") {
[16:04:48.788]                 old_names <- names(...future.oldEnvVars)
[16:04:48.788]                 envs <- base::Sys.getenv()
[16:04:48.788]                 names <- names(envs)
[16:04:48.788]                 common <- intersect(names, old_names)
[16:04:48.788]                 added <- setdiff(names, old_names)
[16:04:48.788]                 removed <- setdiff(old_names, names)
[16:04:48.788]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.788]                   envs[common]]
[16:04:48.788]                 NAMES <- toupper(changed)
[16:04:48.788]                 args <- list()
[16:04:48.788]                 for (kk in seq_along(NAMES)) {
[16:04:48.788]                   name <- changed[[kk]]
[16:04:48.788]                   NAME <- NAMES[[kk]]
[16:04:48.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.788]                     next
[16:04:48.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.788]                 }
[16:04:48.788]                 NAMES <- toupper(added)
[16:04:48.788]                 for (kk in seq_along(NAMES)) {
[16:04:48.788]                   name <- added[[kk]]
[16:04:48.788]                   NAME <- NAMES[[kk]]
[16:04:48.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.788]                     next
[16:04:48.788]                   args[[name]] <- ""
[16:04:48.788]                 }
[16:04:48.788]                 NAMES <- toupper(removed)
[16:04:48.788]                 for (kk in seq_along(NAMES)) {
[16:04:48.788]                   name <- removed[[kk]]
[16:04:48.788]                   NAME <- NAMES[[kk]]
[16:04:48.788]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.788]                     next
[16:04:48.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.788]                 }
[16:04:48.788]                 if (length(args) > 0) 
[16:04:48.788]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.788]             }
[16:04:48.788]             else {
[16:04:48.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.788]             }
[16:04:48.788]             {
[16:04:48.788]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.788]                   0L) {
[16:04:48.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.788]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.788]                   base::options(opts)
[16:04:48.788]                 }
[16:04:48.788]                 {
[16:04:48.788]                   {
[16:04:48.788]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.788]                     NULL
[16:04:48.788]                   }
[16:04:48.788]                   options(future.plan = NULL)
[16:04:48.788]                   if (is.na(NA_character_)) 
[16:04:48.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.788]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.788]                     envir = parent.frame()) 
[16:04:48.788]                   {
[16:04:48.788]                     default_workers <- missing(workers)
[16:04:48.788]                     if (is.function(workers)) 
[16:04:48.788]                       workers <- workers()
[16:04:48.788]                     workers <- structure(as.integer(workers), 
[16:04:48.788]                       class = class(workers))
[16:04:48.788]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.788]                       1L)
[16:04:48.788]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.788]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.788]                       if (default_workers) 
[16:04:48.788]                         supportsMulticore(warn = TRUE)
[16:04:48.788]                       return(sequential(..., envir = envir))
[16:04:48.788]                     }
[16:04:48.788]                     oopts <- options(mc.cores = workers)
[16:04:48.788]                     on.exit(options(oopts))
[16:04:48.788]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.788]                       envir = envir)
[16:04:48.788]                     if (!future$lazy) 
[16:04:48.788]                       future <- run(future)
[16:04:48.788]                     invisible(future)
[16:04:48.788]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.788]                 }
[16:04:48.788]             }
[16:04:48.788]         }
[16:04:48.788]     })
[16:04:48.788]     if (TRUE) {
[16:04:48.788]         base::sink(type = "output", split = FALSE)
[16:04:48.788]         if (TRUE) {
[16:04:48.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.788]         }
[16:04:48.788]         else {
[16:04:48.788]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.788]         }
[16:04:48.788]         base::close(...future.stdout)
[16:04:48.788]         ...future.stdout <- NULL
[16:04:48.788]     }
[16:04:48.788]     ...future.result$conditions <- ...future.conditions
[16:04:48.788]     ...future.result$finished <- base::Sys.time()
[16:04:48.788]     ...future.result
[16:04:48.788] }
[16:04:48.790] assign_globals() ...
[16:04:48.790] List of 1
[16:04:48.790]  $ x: num [1:5] 1 1 2 2 2
[16:04:48.790]  - attr(*, "where")=List of 1
[16:04:48.790]   ..$ x:<environment: R_EmptyEnv> 
[16:04:48.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:48.790]  - attr(*, "resolved")= logi FALSE
[16:04:48.790]  - attr(*, "total_size")= num 96
[16:04:48.790]  - attr(*, "already-done")= logi TRUE
[16:04:48.793] - copied ‘x’ to environment
[16:04:48.794] assign_globals() ... done
[16:04:48.794] requestCore(): workers = 2
[16:04:48.795] MulticoreFuture started
[16:04:48.796] - Launch lazy future ... done
[16:04:48.796] run() for ‘MulticoreFuture’ ... done
[16:04:48.796] result() for MulticoreFuture ...
[16:04:48.797] plan(): Setting new future strategy stack:
[16:04:48.797] List of future strategies:
[16:04:48.797] 1. sequential:
[16:04:48.797]    - args: function (..., envir = parent.frame())
[16:04:48.797]    - tweaked: FALSE
[16:04:48.797]    - call: NULL
[16:04:48.798] plan(): nbrOfWorkers() = 1
[16:04:48.801] plan(): Setting new future strategy stack:
[16:04:48.801] List of future strategies:
[16:04:48.801] 1. multicore:
[16:04:48.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.801]    - tweaked: FALSE
[16:04:48.801]    - call: plan(strategy)
[16:04:48.806] plan(): nbrOfWorkers() = 2
[16:04:48.806] result() for MulticoreFuture ...
[16:04:48.807] result() for MulticoreFuture ... done
[16:04:48.807] result() for MulticoreFuture ... done
[16:04:48.807] result() for MulticoreFuture ...
[16:04:48.807] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:04:48.809] getGlobalsAndPackages() ...
[16:04:48.809] Searching for globals...
[16:04:48.814] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:04:48.814] Searching for globals ... DONE
[16:04:48.814] Resolving globals: FALSE
[16:04:48.815] 
[16:04:48.815] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.815] getGlobalsAndPackages() ... DONE
[16:04:48.816] run() for ‘Future’ ...
[16:04:48.816] - state: ‘created’
[16:04:48.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.820]   - Field: ‘label’
[16:04:48.820]   - Field: ‘local’
[16:04:48.821]   - Field: ‘owner’
[16:04:48.821]   - Field: ‘envir’
[16:04:48.821]   - Field: ‘workers’
[16:04:48.821]   - Field: ‘packages’
[16:04:48.821]   - Field: ‘gc’
[16:04:48.821]   - Field: ‘job’
[16:04:48.821]   - Field: ‘conditions’
[16:04:48.821]   - Field: ‘expr’
[16:04:48.822]   - Field: ‘uuid’
[16:04:48.822]   - Field: ‘seed’
[16:04:48.822]   - Field: ‘version’
[16:04:48.822]   - Field: ‘result’
[16:04:48.822]   - Field: ‘asynchronous’
[16:04:48.822]   - Field: ‘calls’
[16:04:48.822]   - Field: ‘globals’
[16:04:48.822]   - Field: ‘stdout’
[16:04:48.822]   - Field: ‘earlySignal’
[16:04:48.823]   - Field: ‘lazy’
[16:04:48.823]   - Field: ‘state’
[16:04:48.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.823] - Launch lazy future ...
[16:04:48.823] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.823] Packages needed by future strategies (n = 0): <none>
[16:04:48.824] {
[16:04:48.824]     {
[16:04:48.824]         {
[16:04:48.824]             ...future.startTime <- base::Sys.time()
[16:04:48.824]             {
[16:04:48.824]                 {
[16:04:48.824]                   {
[16:04:48.824]                     {
[16:04:48.824]                       {
[16:04:48.824]                         base::local({
[16:04:48.824]                           has_future <- base::requireNamespace("future", 
[16:04:48.824]                             quietly = TRUE)
[16:04:48.824]                           if (has_future) {
[16:04:48.824]                             ns <- base::getNamespace("future")
[16:04:48.824]                             version <- ns[[".package"]][["version"]]
[16:04:48.824]                             if (is.null(version)) 
[16:04:48.824]                               version <- utils::packageVersion("future")
[16:04:48.824]                           }
[16:04:48.824]                           else {
[16:04:48.824]                             version <- NULL
[16:04:48.824]                           }
[16:04:48.824]                           if (!has_future || version < "1.8.0") {
[16:04:48.824]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.824]                               "", base::R.version$version.string), 
[16:04:48.824]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.824]                                 base::R.version$platform, 8 * 
[16:04:48.824]                                   base::.Machine$sizeof.pointer), 
[16:04:48.824]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.824]                                 "release", "version")], collapse = " "), 
[16:04:48.824]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.824]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.824]                               info)
[16:04:48.824]                             info <- base::paste(info, collapse = "; ")
[16:04:48.824]                             if (!has_future) {
[16:04:48.824]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.824]                                 info)
[16:04:48.824]                             }
[16:04:48.824]                             else {
[16:04:48.824]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.824]                                 info, version)
[16:04:48.824]                             }
[16:04:48.824]                             base::stop(msg)
[16:04:48.824]                           }
[16:04:48.824]                         })
[16:04:48.824]                       }
[16:04:48.824]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.824]                       base::options(mc.cores = 1L)
[16:04:48.824]                     }
[16:04:48.824]                     base::local({
[16:04:48.824]                       for (pkg in c("stats", "datasets")) {
[16:04:48.824]                         base::loadNamespace(pkg)
[16:04:48.824]                         base::library(pkg, character.only = TRUE)
[16:04:48.824]                       }
[16:04:48.824]                     })
[16:04:48.824]                   }
[16:04:48.824]                   options(future.plan = NULL)
[16:04:48.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.824]                 }
[16:04:48.824]                 ...future.workdir <- getwd()
[16:04:48.824]             }
[16:04:48.824]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.824]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.824]         }
[16:04:48.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.824]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.824]             base::names(...future.oldOptions))
[16:04:48.824]     }
[16:04:48.824]     if (FALSE) {
[16:04:48.824]     }
[16:04:48.824]     else {
[16:04:48.824]         if (TRUE) {
[16:04:48.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.824]                 open = "w")
[16:04:48.824]         }
[16:04:48.824]         else {
[16:04:48.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.824]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.824]         }
[16:04:48.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.824]             base::sink(type = "output", split = FALSE)
[16:04:48.824]             base::close(...future.stdout)
[16:04:48.824]         }, add = TRUE)
[16:04:48.824]     }
[16:04:48.824]     ...future.frame <- base::sys.nframe()
[16:04:48.824]     ...future.conditions <- base::list()
[16:04:48.824]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.824]     if (FALSE) {
[16:04:48.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.824]     }
[16:04:48.824]     ...future.result <- base::tryCatch({
[16:04:48.824]         base::withCallingHandlers({
[16:04:48.824]             ...future.value <- base::withVisible(base::local({
[16:04:48.824]                 withCallingHandlers({
[16:04:48.824]                   {
[16:04:48.824]                     lm(dist ~ . - 1, data = cars)
[16:04:48.824]                   }
[16:04:48.824]                 }, immediateCondition = function(cond) {
[16:04:48.824]                   save_rds <- function (object, pathname, ...) 
[16:04:48.824]                   {
[16:04:48.824]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.824]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.824]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.824]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.824]                         fi_tmp[["mtime"]])
[16:04:48.824]                     }
[16:04:48.824]                     tryCatch({
[16:04:48.824]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.824]                     }, error = function(ex) {
[16:04:48.824]                       msg <- conditionMessage(ex)
[16:04:48.824]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.824]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.824]                         fi_tmp[["mtime"]], msg)
[16:04:48.824]                       ex$message <- msg
[16:04:48.824]                       stop(ex)
[16:04:48.824]                     })
[16:04:48.824]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.824]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.824]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.824]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.824]                       fi <- file.info(pathname)
[16:04:48.824]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.824]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.824]                         fi[["size"]], fi[["mtime"]])
[16:04:48.824]                       stop(msg)
[16:04:48.824]                     }
[16:04:48.824]                     invisible(pathname)
[16:04:48.824]                   }
[16:04:48.824]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.824]                     rootPath = tempdir()) 
[16:04:48.824]                   {
[16:04:48.824]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.824]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.824]                       tmpdir = path, fileext = ".rds")
[16:04:48.824]                     save_rds(obj, file)
[16:04:48.824]                   }
[16:04:48.824]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.824]                   {
[16:04:48.824]                     inherits <- base::inherits
[16:04:48.824]                     invokeRestart <- base::invokeRestart
[16:04:48.824]                     is.null <- base::is.null
[16:04:48.824]                     muffled <- FALSE
[16:04:48.824]                     if (inherits(cond, "message")) {
[16:04:48.824]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.824]                       if (muffled) 
[16:04:48.824]                         invokeRestart("muffleMessage")
[16:04:48.824]                     }
[16:04:48.824]                     else if (inherits(cond, "warning")) {
[16:04:48.824]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.824]                       if (muffled) 
[16:04:48.824]                         invokeRestart("muffleWarning")
[16:04:48.824]                     }
[16:04:48.824]                     else if (inherits(cond, "condition")) {
[16:04:48.824]                       if (!is.null(pattern)) {
[16:04:48.824]                         computeRestarts <- base::computeRestarts
[16:04:48.824]                         grepl <- base::grepl
[16:04:48.824]                         restarts <- computeRestarts(cond)
[16:04:48.824]                         for (restart in restarts) {
[16:04:48.824]                           name <- restart$name
[16:04:48.824]                           if (is.null(name)) 
[16:04:48.824]                             next
[16:04:48.824]                           if (!grepl(pattern, name)) 
[16:04:48.824]                             next
[16:04:48.824]                           invokeRestart(restart)
[16:04:48.824]                           muffled <- TRUE
[16:04:48.824]                           break
[16:04:48.824]                         }
[16:04:48.824]                       }
[16:04:48.824]                     }
[16:04:48.824]                     invisible(muffled)
[16:04:48.824]                   }
[16:04:48.824]                   muffleCondition(cond)
[16:04:48.824]                 })
[16:04:48.824]             }))
[16:04:48.824]             future::FutureResult(value = ...future.value$value, 
[16:04:48.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.824]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.824]                     ...future.globalenv.names))
[16:04:48.824]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.824]         }, condition = base::local({
[16:04:48.824]             c <- base::c
[16:04:48.824]             inherits <- base::inherits
[16:04:48.824]             invokeRestart <- base::invokeRestart
[16:04:48.824]             length <- base::length
[16:04:48.824]             list <- base::list
[16:04:48.824]             seq.int <- base::seq.int
[16:04:48.824]             signalCondition <- base::signalCondition
[16:04:48.824]             sys.calls <- base::sys.calls
[16:04:48.824]             `[[` <- base::`[[`
[16:04:48.824]             `+` <- base::`+`
[16:04:48.824]             `<<-` <- base::`<<-`
[16:04:48.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.824]                   3L)]
[16:04:48.824]             }
[16:04:48.824]             function(cond) {
[16:04:48.824]                 is_error <- inherits(cond, "error")
[16:04:48.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.824]                   NULL)
[16:04:48.824]                 if (is_error) {
[16:04:48.824]                   sessionInformation <- function() {
[16:04:48.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.824]                       search = base::search(), system = base::Sys.info())
[16:04:48.824]                   }
[16:04:48.824]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.824]                     cond$call), session = sessionInformation(), 
[16:04:48.824]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.824]                   signalCondition(cond)
[16:04:48.824]                 }
[16:04:48.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.824]                 "immediateCondition"))) {
[16:04:48.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.824]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.824]                   if (TRUE && !signal) {
[16:04:48.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.824]                     {
[16:04:48.824]                       inherits <- base::inherits
[16:04:48.824]                       invokeRestart <- base::invokeRestart
[16:04:48.824]                       is.null <- base::is.null
[16:04:48.824]                       muffled <- FALSE
[16:04:48.824]                       if (inherits(cond, "message")) {
[16:04:48.824]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.824]                         if (muffled) 
[16:04:48.824]                           invokeRestart("muffleMessage")
[16:04:48.824]                       }
[16:04:48.824]                       else if (inherits(cond, "warning")) {
[16:04:48.824]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.824]                         if (muffled) 
[16:04:48.824]                           invokeRestart("muffleWarning")
[16:04:48.824]                       }
[16:04:48.824]                       else if (inherits(cond, "condition")) {
[16:04:48.824]                         if (!is.null(pattern)) {
[16:04:48.824]                           computeRestarts <- base::computeRestarts
[16:04:48.824]                           grepl <- base::grepl
[16:04:48.824]                           restarts <- computeRestarts(cond)
[16:04:48.824]                           for (restart in restarts) {
[16:04:48.824]                             name <- restart$name
[16:04:48.824]                             if (is.null(name)) 
[16:04:48.824]                               next
[16:04:48.824]                             if (!grepl(pattern, name)) 
[16:04:48.824]                               next
[16:04:48.824]                             invokeRestart(restart)
[16:04:48.824]                             muffled <- TRUE
[16:04:48.824]                             break
[16:04:48.824]                           }
[16:04:48.824]                         }
[16:04:48.824]                       }
[16:04:48.824]                       invisible(muffled)
[16:04:48.824]                     }
[16:04:48.824]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.824]                   }
[16:04:48.824]                 }
[16:04:48.824]                 else {
[16:04:48.824]                   if (TRUE) {
[16:04:48.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.824]                     {
[16:04:48.824]                       inherits <- base::inherits
[16:04:48.824]                       invokeRestart <- base::invokeRestart
[16:04:48.824]                       is.null <- base::is.null
[16:04:48.824]                       muffled <- FALSE
[16:04:48.824]                       if (inherits(cond, "message")) {
[16:04:48.824]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.824]                         if (muffled) 
[16:04:48.824]                           invokeRestart("muffleMessage")
[16:04:48.824]                       }
[16:04:48.824]                       else if (inherits(cond, "warning")) {
[16:04:48.824]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.824]                         if (muffled) 
[16:04:48.824]                           invokeRestart("muffleWarning")
[16:04:48.824]                       }
[16:04:48.824]                       else if (inherits(cond, "condition")) {
[16:04:48.824]                         if (!is.null(pattern)) {
[16:04:48.824]                           computeRestarts <- base::computeRestarts
[16:04:48.824]                           grepl <- base::grepl
[16:04:48.824]                           restarts <- computeRestarts(cond)
[16:04:48.824]                           for (restart in restarts) {
[16:04:48.824]                             name <- restart$name
[16:04:48.824]                             if (is.null(name)) 
[16:04:48.824]                               next
[16:04:48.824]                             if (!grepl(pattern, name)) 
[16:04:48.824]                               next
[16:04:48.824]                             invokeRestart(restart)
[16:04:48.824]                             muffled <- TRUE
[16:04:48.824]                             break
[16:04:48.824]                           }
[16:04:48.824]                         }
[16:04:48.824]                       }
[16:04:48.824]                       invisible(muffled)
[16:04:48.824]                     }
[16:04:48.824]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.824]                   }
[16:04:48.824]                 }
[16:04:48.824]             }
[16:04:48.824]         }))
[16:04:48.824]     }, error = function(ex) {
[16:04:48.824]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.824]                 ...future.rng), started = ...future.startTime, 
[16:04:48.824]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.824]             version = "1.8"), class = "FutureResult")
[16:04:48.824]     }, finally = {
[16:04:48.824]         if (!identical(...future.workdir, getwd())) 
[16:04:48.824]             setwd(...future.workdir)
[16:04:48.824]         {
[16:04:48.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.824]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.824]             }
[16:04:48.824]             base::options(...future.oldOptions)
[16:04:48.824]             if (.Platform$OS.type == "windows") {
[16:04:48.824]                 old_names <- names(...future.oldEnvVars)
[16:04:48.824]                 envs <- base::Sys.getenv()
[16:04:48.824]                 names <- names(envs)
[16:04:48.824]                 common <- intersect(names, old_names)
[16:04:48.824]                 added <- setdiff(names, old_names)
[16:04:48.824]                 removed <- setdiff(old_names, names)
[16:04:48.824]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.824]                   envs[common]]
[16:04:48.824]                 NAMES <- toupper(changed)
[16:04:48.824]                 args <- list()
[16:04:48.824]                 for (kk in seq_along(NAMES)) {
[16:04:48.824]                   name <- changed[[kk]]
[16:04:48.824]                   NAME <- NAMES[[kk]]
[16:04:48.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.824]                     next
[16:04:48.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.824]                 }
[16:04:48.824]                 NAMES <- toupper(added)
[16:04:48.824]                 for (kk in seq_along(NAMES)) {
[16:04:48.824]                   name <- added[[kk]]
[16:04:48.824]                   NAME <- NAMES[[kk]]
[16:04:48.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.824]                     next
[16:04:48.824]                   args[[name]] <- ""
[16:04:48.824]                 }
[16:04:48.824]                 NAMES <- toupper(removed)
[16:04:48.824]                 for (kk in seq_along(NAMES)) {
[16:04:48.824]                   name <- removed[[kk]]
[16:04:48.824]                   NAME <- NAMES[[kk]]
[16:04:48.824]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.824]                     next
[16:04:48.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.824]                 }
[16:04:48.824]                 if (length(args) > 0) 
[16:04:48.824]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.824]             }
[16:04:48.824]             else {
[16:04:48.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.824]             }
[16:04:48.824]             {
[16:04:48.824]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.824]                   0L) {
[16:04:48.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.824]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.824]                   base::options(opts)
[16:04:48.824]                 }
[16:04:48.824]                 {
[16:04:48.824]                   {
[16:04:48.824]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.824]                     NULL
[16:04:48.824]                   }
[16:04:48.824]                   options(future.plan = NULL)
[16:04:48.824]                   if (is.na(NA_character_)) 
[16:04:48.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.824]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.824]                     envir = parent.frame()) 
[16:04:48.824]                   {
[16:04:48.824]                     default_workers <- missing(workers)
[16:04:48.824]                     if (is.function(workers)) 
[16:04:48.824]                       workers <- workers()
[16:04:48.824]                     workers <- structure(as.integer(workers), 
[16:04:48.824]                       class = class(workers))
[16:04:48.824]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.824]                       1L)
[16:04:48.824]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.824]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.824]                       if (default_workers) 
[16:04:48.824]                         supportsMulticore(warn = TRUE)
[16:04:48.824]                       return(sequential(..., envir = envir))
[16:04:48.824]                     }
[16:04:48.824]                     oopts <- options(mc.cores = workers)
[16:04:48.824]                     on.exit(options(oopts))
[16:04:48.824]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.824]                       envir = envir)
[16:04:48.824]                     if (!future$lazy) 
[16:04:48.824]                       future <- run(future)
[16:04:48.824]                     invisible(future)
[16:04:48.824]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.824]                 }
[16:04:48.824]             }
[16:04:48.824]         }
[16:04:48.824]     })
[16:04:48.824]     if (TRUE) {
[16:04:48.824]         base::sink(type = "output", split = FALSE)
[16:04:48.824]         if (TRUE) {
[16:04:48.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.824]         }
[16:04:48.824]         else {
[16:04:48.824]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.824]         }
[16:04:48.824]         base::close(...future.stdout)
[16:04:48.824]         ...future.stdout <- NULL
[16:04:48.824]     }
[16:04:48.824]     ...future.result$conditions <- ...future.conditions
[16:04:48.824]     ...future.result$finished <- base::Sys.time()
[16:04:48.824]     ...future.result
[16:04:48.824] }
[16:04:48.826] requestCore(): workers = 2
[16:04:48.828] MulticoreFuture started
[16:04:48.828] - Launch lazy future ... done
[16:04:48.829] run() for ‘MulticoreFuture’ ... done
[16:04:48.829] result() for MulticoreFuture ...
[16:04:48.830] plan(): Setting new future strategy stack:
[16:04:48.830] List of future strategies:
[16:04:48.830] 1. sequential:
[16:04:48.830]    - args: function (..., envir = parent.frame())
[16:04:48.830]    - tweaked: FALSE
[16:04:48.830]    - call: NULL
[16:04:48.831] plan(): nbrOfWorkers() = 1
[16:04:48.834] plan(): Setting new future strategy stack:
[16:04:48.834] List of future strategies:
[16:04:48.834] 1. multicore:
[16:04:48.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.834]    - tweaked: FALSE
[16:04:48.834]    - call: plan(strategy)
[16:04:48.839] plan(): nbrOfWorkers() = 2
[16:04:48.841] result() for MulticoreFuture ...
[16:04:48.841] result() for MulticoreFuture ... done
[16:04:48.841] result() for MulticoreFuture ... done
[16:04:48.841] result() for MulticoreFuture ...
[16:04:48.841] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:04:48.844] getGlobalsAndPackages() ...
[16:04:48.844] Searching for globals...
[16:04:48.846] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:04:48.847] Searching for globals ... DONE
[16:04:48.847] Resolving globals: FALSE
[16:04:48.847] 
[16:04:48.848] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.848] getGlobalsAndPackages() ... DONE
[16:04:48.848] run() for ‘Future’ ...
[16:04:48.848] - state: ‘created’
[16:04:48.848] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.852] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.852]   - Field: ‘label’
[16:04:48.852]   - Field: ‘local’
[16:04:48.853]   - Field: ‘owner’
[16:04:48.853]   - Field: ‘envir’
[16:04:48.853]   - Field: ‘workers’
[16:04:48.853]   - Field: ‘packages’
[16:04:48.853]   - Field: ‘gc’
[16:04:48.853]   - Field: ‘job’
[16:04:48.853]   - Field: ‘conditions’
[16:04:48.853]   - Field: ‘expr’
[16:04:48.854]   - Field: ‘uuid’
[16:04:48.854]   - Field: ‘seed’
[16:04:48.854]   - Field: ‘version’
[16:04:48.854]   - Field: ‘result’
[16:04:48.854]   - Field: ‘asynchronous’
[16:04:48.854]   - Field: ‘calls’
[16:04:48.854]   - Field: ‘globals’
[16:04:48.854]   - Field: ‘stdout’
[16:04:48.854]   - Field: ‘earlySignal’
[16:04:48.855]   - Field: ‘lazy’
[16:04:48.855]   - Field: ‘state’
[16:04:48.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.855] - Launch lazy future ...
[16:04:48.855] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.855] Packages needed by future strategies (n = 0): <none>
[16:04:48.888] {
[16:04:48.888]     {
[16:04:48.888]         {
[16:04:48.888]             ...future.startTime <- base::Sys.time()
[16:04:48.888]             {
[16:04:48.888]                 {
[16:04:48.888]                   {
[16:04:48.888]                     {
[16:04:48.888]                       {
[16:04:48.888]                         base::local({
[16:04:48.888]                           has_future <- base::requireNamespace("future", 
[16:04:48.888]                             quietly = TRUE)
[16:04:48.888]                           if (has_future) {
[16:04:48.888]                             ns <- base::getNamespace("future")
[16:04:48.888]                             version <- ns[[".package"]][["version"]]
[16:04:48.888]                             if (is.null(version)) 
[16:04:48.888]                               version <- utils::packageVersion("future")
[16:04:48.888]                           }
[16:04:48.888]                           else {
[16:04:48.888]                             version <- NULL
[16:04:48.888]                           }
[16:04:48.888]                           if (!has_future || version < "1.8.0") {
[16:04:48.888]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.888]                               "", base::R.version$version.string), 
[16:04:48.888]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.888]                                 base::R.version$platform, 8 * 
[16:04:48.888]                                   base::.Machine$sizeof.pointer), 
[16:04:48.888]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.888]                                 "release", "version")], collapse = " "), 
[16:04:48.888]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.888]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.888]                               info)
[16:04:48.888]                             info <- base::paste(info, collapse = "; ")
[16:04:48.888]                             if (!has_future) {
[16:04:48.888]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.888]                                 info)
[16:04:48.888]                             }
[16:04:48.888]                             else {
[16:04:48.888]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.888]                                 info, version)
[16:04:48.888]                             }
[16:04:48.888]                             base::stop(msg)
[16:04:48.888]                           }
[16:04:48.888]                         })
[16:04:48.888]                       }
[16:04:48.888]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.888]                       base::options(mc.cores = 1L)
[16:04:48.888]                     }
[16:04:48.888]                     base::local({
[16:04:48.888]                       for (pkg in c("stats", "datasets")) {
[16:04:48.888]                         base::loadNamespace(pkg)
[16:04:48.888]                         base::library(pkg, character.only = TRUE)
[16:04:48.888]                       }
[16:04:48.888]                     })
[16:04:48.888]                   }
[16:04:48.888]                   options(future.plan = NULL)
[16:04:48.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.888]                 }
[16:04:48.888]                 ...future.workdir <- getwd()
[16:04:48.888]             }
[16:04:48.888]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.888]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.888]         }
[16:04:48.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.888]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.888]             base::names(...future.oldOptions))
[16:04:48.888]     }
[16:04:48.888]     if (FALSE) {
[16:04:48.888]     }
[16:04:48.888]     else {
[16:04:48.888]         if (TRUE) {
[16:04:48.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.888]                 open = "w")
[16:04:48.888]         }
[16:04:48.888]         else {
[16:04:48.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.888]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.888]         }
[16:04:48.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.888]             base::sink(type = "output", split = FALSE)
[16:04:48.888]             base::close(...future.stdout)
[16:04:48.888]         }, add = TRUE)
[16:04:48.888]     }
[16:04:48.888]     ...future.frame <- base::sys.nframe()
[16:04:48.888]     ...future.conditions <- base::list()
[16:04:48.888]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.888]     if (FALSE) {
[16:04:48.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.888]     }
[16:04:48.888]     ...future.result <- base::tryCatch({
[16:04:48.888]         base::withCallingHandlers({
[16:04:48.888]             ...future.value <- base::withVisible(base::local({
[16:04:48.888]                 withCallingHandlers({
[16:04:48.888]                   {
[16:04:48.888]                     lm(dist ~ . + 0, data = cars)
[16:04:48.888]                   }
[16:04:48.888]                 }, immediateCondition = function(cond) {
[16:04:48.888]                   save_rds <- function (object, pathname, ...) 
[16:04:48.888]                   {
[16:04:48.888]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.888]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.888]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.888]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.888]                         fi_tmp[["mtime"]])
[16:04:48.888]                     }
[16:04:48.888]                     tryCatch({
[16:04:48.888]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.888]                     }, error = function(ex) {
[16:04:48.888]                       msg <- conditionMessage(ex)
[16:04:48.888]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.888]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.888]                         fi_tmp[["mtime"]], msg)
[16:04:48.888]                       ex$message <- msg
[16:04:48.888]                       stop(ex)
[16:04:48.888]                     })
[16:04:48.888]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.888]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.888]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.888]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.888]                       fi <- file.info(pathname)
[16:04:48.888]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.888]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.888]                         fi[["size"]], fi[["mtime"]])
[16:04:48.888]                       stop(msg)
[16:04:48.888]                     }
[16:04:48.888]                     invisible(pathname)
[16:04:48.888]                   }
[16:04:48.888]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.888]                     rootPath = tempdir()) 
[16:04:48.888]                   {
[16:04:48.888]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.888]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.888]                       tmpdir = path, fileext = ".rds")
[16:04:48.888]                     save_rds(obj, file)
[16:04:48.888]                   }
[16:04:48.888]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.888]                   {
[16:04:48.888]                     inherits <- base::inherits
[16:04:48.888]                     invokeRestart <- base::invokeRestart
[16:04:48.888]                     is.null <- base::is.null
[16:04:48.888]                     muffled <- FALSE
[16:04:48.888]                     if (inherits(cond, "message")) {
[16:04:48.888]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.888]                       if (muffled) 
[16:04:48.888]                         invokeRestart("muffleMessage")
[16:04:48.888]                     }
[16:04:48.888]                     else if (inherits(cond, "warning")) {
[16:04:48.888]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.888]                       if (muffled) 
[16:04:48.888]                         invokeRestart("muffleWarning")
[16:04:48.888]                     }
[16:04:48.888]                     else if (inherits(cond, "condition")) {
[16:04:48.888]                       if (!is.null(pattern)) {
[16:04:48.888]                         computeRestarts <- base::computeRestarts
[16:04:48.888]                         grepl <- base::grepl
[16:04:48.888]                         restarts <- computeRestarts(cond)
[16:04:48.888]                         for (restart in restarts) {
[16:04:48.888]                           name <- restart$name
[16:04:48.888]                           if (is.null(name)) 
[16:04:48.888]                             next
[16:04:48.888]                           if (!grepl(pattern, name)) 
[16:04:48.888]                             next
[16:04:48.888]                           invokeRestart(restart)
[16:04:48.888]                           muffled <- TRUE
[16:04:48.888]                           break
[16:04:48.888]                         }
[16:04:48.888]                       }
[16:04:48.888]                     }
[16:04:48.888]                     invisible(muffled)
[16:04:48.888]                   }
[16:04:48.888]                   muffleCondition(cond)
[16:04:48.888]                 })
[16:04:48.888]             }))
[16:04:48.888]             future::FutureResult(value = ...future.value$value, 
[16:04:48.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.888]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.888]                     ...future.globalenv.names))
[16:04:48.888]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.888]         }, condition = base::local({
[16:04:48.888]             c <- base::c
[16:04:48.888]             inherits <- base::inherits
[16:04:48.888]             invokeRestart <- base::invokeRestart
[16:04:48.888]             length <- base::length
[16:04:48.888]             list <- base::list
[16:04:48.888]             seq.int <- base::seq.int
[16:04:48.888]             signalCondition <- base::signalCondition
[16:04:48.888]             sys.calls <- base::sys.calls
[16:04:48.888]             `[[` <- base::`[[`
[16:04:48.888]             `+` <- base::`+`
[16:04:48.888]             `<<-` <- base::`<<-`
[16:04:48.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.888]                   3L)]
[16:04:48.888]             }
[16:04:48.888]             function(cond) {
[16:04:48.888]                 is_error <- inherits(cond, "error")
[16:04:48.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.888]                   NULL)
[16:04:48.888]                 if (is_error) {
[16:04:48.888]                   sessionInformation <- function() {
[16:04:48.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.888]                       search = base::search(), system = base::Sys.info())
[16:04:48.888]                   }
[16:04:48.888]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.888]                     cond$call), session = sessionInformation(), 
[16:04:48.888]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.888]                   signalCondition(cond)
[16:04:48.888]                 }
[16:04:48.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.888]                 "immediateCondition"))) {
[16:04:48.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.888]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.888]                   if (TRUE && !signal) {
[16:04:48.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.888]                     {
[16:04:48.888]                       inherits <- base::inherits
[16:04:48.888]                       invokeRestart <- base::invokeRestart
[16:04:48.888]                       is.null <- base::is.null
[16:04:48.888]                       muffled <- FALSE
[16:04:48.888]                       if (inherits(cond, "message")) {
[16:04:48.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.888]                         if (muffled) 
[16:04:48.888]                           invokeRestart("muffleMessage")
[16:04:48.888]                       }
[16:04:48.888]                       else if (inherits(cond, "warning")) {
[16:04:48.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.888]                         if (muffled) 
[16:04:48.888]                           invokeRestart("muffleWarning")
[16:04:48.888]                       }
[16:04:48.888]                       else if (inherits(cond, "condition")) {
[16:04:48.888]                         if (!is.null(pattern)) {
[16:04:48.888]                           computeRestarts <- base::computeRestarts
[16:04:48.888]                           grepl <- base::grepl
[16:04:48.888]                           restarts <- computeRestarts(cond)
[16:04:48.888]                           for (restart in restarts) {
[16:04:48.888]                             name <- restart$name
[16:04:48.888]                             if (is.null(name)) 
[16:04:48.888]                               next
[16:04:48.888]                             if (!grepl(pattern, name)) 
[16:04:48.888]                               next
[16:04:48.888]                             invokeRestart(restart)
[16:04:48.888]                             muffled <- TRUE
[16:04:48.888]                             break
[16:04:48.888]                           }
[16:04:48.888]                         }
[16:04:48.888]                       }
[16:04:48.888]                       invisible(muffled)
[16:04:48.888]                     }
[16:04:48.888]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.888]                   }
[16:04:48.888]                 }
[16:04:48.888]                 else {
[16:04:48.888]                   if (TRUE) {
[16:04:48.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.888]                     {
[16:04:48.888]                       inherits <- base::inherits
[16:04:48.888]                       invokeRestart <- base::invokeRestart
[16:04:48.888]                       is.null <- base::is.null
[16:04:48.888]                       muffled <- FALSE
[16:04:48.888]                       if (inherits(cond, "message")) {
[16:04:48.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.888]                         if (muffled) 
[16:04:48.888]                           invokeRestart("muffleMessage")
[16:04:48.888]                       }
[16:04:48.888]                       else if (inherits(cond, "warning")) {
[16:04:48.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.888]                         if (muffled) 
[16:04:48.888]                           invokeRestart("muffleWarning")
[16:04:48.888]                       }
[16:04:48.888]                       else if (inherits(cond, "condition")) {
[16:04:48.888]                         if (!is.null(pattern)) {
[16:04:48.888]                           computeRestarts <- base::computeRestarts
[16:04:48.888]                           grepl <- base::grepl
[16:04:48.888]                           restarts <- computeRestarts(cond)
[16:04:48.888]                           for (restart in restarts) {
[16:04:48.888]                             name <- restart$name
[16:04:48.888]                             if (is.null(name)) 
[16:04:48.888]                               next
[16:04:48.888]                             if (!grepl(pattern, name)) 
[16:04:48.888]                               next
[16:04:48.888]                             invokeRestart(restart)
[16:04:48.888]                             muffled <- TRUE
[16:04:48.888]                             break
[16:04:48.888]                           }
[16:04:48.888]                         }
[16:04:48.888]                       }
[16:04:48.888]                       invisible(muffled)
[16:04:48.888]                     }
[16:04:48.888]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.888]                   }
[16:04:48.888]                 }
[16:04:48.888]             }
[16:04:48.888]         }))
[16:04:48.888]     }, error = function(ex) {
[16:04:48.888]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.888]                 ...future.rng), started = ...future.startTime, 
[16:04:48.888]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.888]             version = "1.8"), class = "FutureResult")
[16:04:48.888]     }, finally = {
[16:04:48.888]         if (!identical(...future.workdir, getwd())) 
[16:04:48.888]             setwd(...future.workdir)
[16:04:48.888]         {
[16:04:48.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.888]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.888]             }
[16:04:48.888]             base::options(...future.oldOptions)
[16:04:48.888]             if (.Platform$OS.type == "windows") {
[16:04:48.888]                 old_names <- names(...future.oldEnvVars)
[16:04:48.888]                 envs <- base::Sys.getenv()
[16:04:48.888]                 names <- names(envs)
[16:04:48.888]                 common <- intersect(names, old_names)
[16:04:48.888]                 added <- setdiff(names, old_names)
[16:04:48.888]                 removed <- setdiff(old_names, names)
[16:04:48.888]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.888]                   envs[common]]
[16:04:48.888]                 NAMES <- toupper(changed)
[16:04:48.888]                 args <- list()
[16:04:48.888]                 for (kk in seq_along(NAMES)) {
[16:04:48.888]                   name <- changed[[kk]]
[16:04:48.888]                   NAME <- NAMES[[kk]]
[16:04:48.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.888]                     next
[16:04:48.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.888]                 }
[16:04:48.888]                 NAMES <- toupper(added)
[16:04:48.888]                 for (kk in seq_along(NAMES)) {
[16:04:48.888]                   name <- added[[kk]]
[16:04:48.888]                   NAME <- NAMES[[kk]]
[16:04:48.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.888]                     next
[16:04:48.888]                   args[[name]] <- ""
[16:04:48.888]                 }
[16:04:48.888]                 NAMES <- toupper(removed)
[16:04:48.888]                 for (kk in seq_along(NAMES)) {
[16:04:48.888]                   name <- removed[[kk]]
[16:04:48.888]                   NAME <- NAMES[[kk]]
[16:04:48.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.888]                     next
[16:04:48.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.888]                 }
[16:04:48.888]                 if (length(args) > 0) 
[16:04:48.888]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.888]             }
[16:04:48.888]             else {
[16:04:48.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.888]             }
[16:04:48.888]             {
[16:04:48.888]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.888]                   0L) {
[16:04:48.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.888]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.888]                   base::options(opts)
[16:04:48.888]                 }
[16:04:48.888]                 {
[16:04:48.888]                   {
[16:04:48.888]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.888]                     NULL
[16:04:48.888]                   }
[16:04:48.888]                   options(future.plan = NULL)
[16:04:48.888]                   if (is.na(NA_character_)) 
[16:04:48.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.888]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.888]                     envir = parent.frame()) 
[16:04:48.888]                   {
[16:04:48.888]                     default_workers <- missing(workers)
[16:04:48.888]                     if (is.function(workers)) 
[16:04:48.888]                       workers <- workers()
[16:04:48.888]                     workers <- structure(as.integer(workers), 
[16:04:48.888]                       class = class(workers))
[16:04:48.888]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.888]                       1L)
[16:04:48.888]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.888]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.888]                       if (default_workers) 
[16:04:48.888]                         supportsMulticore(warn = TRUE)
[16:04:48.888]                       return(sequential(..., envir = envir))
[16:04:48.888]                     }
[16:04:48.888]                     oopts <- options(mc.cores = workers)
[16:04:48.888]                     on.exit(options(oopts))
[16:04:48.888]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.888]                       envir = envir)
[16:04:48.888]                     if (!future$lazy) 
[16:04:48.888]                       future <- run(future)
[16:04:48.888]                     invisible(future)
[16:04:48.888]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.888]                 }
[16:04:48.888]             }
[16:04:48.888]         }
[16:04:48.888]     })
[16:04:48.888]     if (TRUE) {
[16:04:48.888]         base::sink(type = "output", split = FALSE)
[16:04:48.888]         if (TRUE) {
[16:04:48.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.888]         }
[16:04:48.888]         else {
[16:04:48.888]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.888]         }
[16:04:48.888]         base::close(...future.stdout)
[16:04:48.888]         ...future.stdout <- NULL
[16:04:48.888]     }
[16:04:48.888]     ...future.result$conditions <- ...future.conditions
[16:04:48.888]     ...future.result$finished <- base::Sys.time()
[16:04:48.888]     ...future.result
[16:04:48.888] }
[16:04:48.890] requestCore(): workers = 2
[16:04:48.892] MulticoreFuture started
[16:04:48.893] - Launch lazy future ... done
[16:04:48.893] run() for ‘MulticoreFuture’ ... done
[16:04:48.894] result() for MulticoreFuture ...
[16:04:48.895] plan(): Setting new future strategy stack:
[16:04:48.895] List of future strategies:
[16:04:48.895] 1. sequential:
[16:04:48.895]    - args: function (..., envir = parent.frame())
[16:04:48.895]    - tweaked: FALSE
[16:04:48.895]    - call: NULL
[16:04:48.896] plan(): nbrOfWorkers() = 1
[16:04:48.900] plan(): Setting new future strategy stack:
[16:04:48.900] List of future strategies:
[16:04:48.900] 1. multicore:
[16:04:48.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.900]    - tweaked: FALSE
[16:04:48.900]    - call: plan(strategy)
[16:04:48.906] plan(): nbrOfWorkers() = 2
[16:04:48.908] result() for MulticoreFuture ...
[16:04:48.908] result() for MulticoreFuture ... done
[16:04:48.909] result() for MulticoreFuture ... done
[16:04:48.909] result() for MulticoreFuture ...
[16:04:48.909] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:04:48.913] getGlobalsAndPackages() ...
[16:04:48.913] Searching for globals...
[16:04:48.915] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:04:48.916] Searching for globals ... DONE
[16:04:48.916] Resolving globals: FALSE
[16:04:48.916] 
[16:04:48.916] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.917] getGlobalsAndPackages() ... DONE
[16:04:48.917] run() for ‘Future’ ...
[16:04:48.917] - state: ‘created’
[16:04:48.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.921] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.921]   - Field: ‘label’
[16:04:48.921]   - Field: ‘local’
[16:04:48.921]   - Field: ‘owner’
[16:04:48.921]   - Field: ‘envir’
[16:04:48.922]   - Field: ‘workers’
[16:04:48.922]   - Field: ‘packages’
[16:04:48.922]   - Field: ‘gc’
[16:04:48.922]   - Field: ‘job’
[16:04:48.922]   - Field: ‘conditions’
[16:04:48.922]   - Field: ‘expr’
[16:04:48.922]   - Field: ‘uuid’
[16:04:48.922]   - Field: ‘seed’
[16:04:48.922]   - Field: ‘version’
[16:04:48.923]   - Field: ‘result’
[16:04:48.923]   - Field: ‘asynchronous’
[16:04:48.923]   - Field: ‘calls’
[16:04:48.923]   - Field: ‘globals’
[16:04:48.923]   - Field: ‘stdout’
[16:04:48.923]   - Field: ‘earlySignal’
[16:04:48.923]   - Field: ‘lazy’
[16:04:48.923]   - Field: ‘state’
[16:04:48.924] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.924] - Launch lazy future ...
[16:04:48.924] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.924] Packages needed by future strategies (n = 0): <none>
[16:04:48.925] {
[16:04:48.925]     {
[16:04:48.925]         {
[16:04:48.925]             ...future.startTime <- base::Sys.time()
[16:04:48.925]             {
[16:04:48.925]                 {
[16:04:48.925]                   {
[16:04:48.925]                     {
[16:04:48.925]                       {
[16:04:48.925]                         base::local({
[16:04:48.925]                           has_future <- base::requireNamespace("future", 
[16:04:48.925]                             quietly = TRUE)
[16:04:48.925]                           if (has_future) {
[16:04:48.925]                             ns <- base::getNamespace("future")
[16:04:48.925]                             version <- ns[[".package"]][["version"]]
[16:04:48.925]                             if (is.null(version)) 
[16:04:48.925]                               version <- utils::packageVersion("future")
[16:04:48.925]                           }
[16:04:48.925]                           else {
[16:04:48.925]                             version <- NULL
[16:04:48.925]                           }
[16:04:48.925]                           if (!has_future || version < "1.8.0") {
[16:04:48.925]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.925]                               "", base::R.version$version.string), 
[16:04:48.925]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.925]                                 base::R.version$platform, 8 * 
[16:04:48.925]                                   base::.Machine$sizeof.pointer), 
[16:04:48.925]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.925]                                 "release", "version")], collapse = " "), 
[16:04:48.925]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.925]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.925]                               info)
[16:04:48.925]                             info <- base::paste(info, collapse = "; ")
[16:04:48.925]                             if (!has_future) {
[16:04:48.925]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.925]                                 info)
[16:04:48.925]                             }
[16:04:48.925]                             else {
[16:04:48.925]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.925]                                 info, version)
[16:04:48.925]                             }
[16:04:48.925]                             base::stop(msg)
[16:04:48.925]                           }
[16:04:48.925]                         })
[16:04:48.925]                       }
[16:04:48.925]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.925]                       base::options(mc.cores = 1L)
[16:04:48.925]                     }
[16:04:48.925]                     base::local({
[16:04:48.925]                       for (pkg in c("stats", "datasets")) {
[16:04:48.925]                         base::loadNamespace(pkg)
[16:04:48.925]                         base::library(pkg, character.only = TRUE)
[16:04:48.925]                       }
[16:04:48.925]                     })
[16:04:48.925]                   }
[16:04:48.925]                   options(future.plan = NULL)
[16:04:48.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.925]                 }
[16:04:48.925]                 ...future.workdir <- getwd()
[16:04:48.925]             }
[16:04:48.925]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.925]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.925]         }
[16:04:48.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.925]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.925]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.925]             base::names(...future.oldOptions))
[16:04:48.925]     }
[16:04:48.925]     if (FALSE) {
[16:04:48.925]     }
[16:04:48.925]     else {
[16:04:48.925]         if (TRUE) {
[16:04:48.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.925]                 open = "w")
[16:04:48.925]         }
[16:04:48.925]         else {
[16:04:48.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.925]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.925]         }
[16:04:48.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.925]             base::sink(type = "output", split = FALSE)
[16:04:48.925]             base::close(...future.stdout)
[16:04:48.925]         }, add = TRUE)
[16:04:48.925]     }
[16:04:48.925]     ...future.frame <- base::sys.nframe()
[16:04:48.925]     ...future.conditions <- base::list()
[16:04:48.925]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.925]     if (FALSE) {
[16:04:48.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.925]     }
[16:04:48.925]     ...future.result <- base::tryCatch({
[16:04:48.925]         base::withCallingHandlers({
[16:04:48.925]             ...future.value <- base::withVisible(base::local({
[16:04:48.925]                 withCallingHandlers({
[16:04:48.925]                   {
[16:04:48.925]                     lm(dist ~ speed + speed^2, data = cars)
[16:04:48.925]                   }
[16:04:48.925]                 }, immediateCondition = function(cond) {
[16:04:48.925]                   save_rds <- function (object, pathname, ...) 
[16:04:48.925]                   {
[16:04:48.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.925]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.925]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.925]                         fi_tmp[["mtime"]])
[16:04:48.925]                     }
[16:04:48.925]                     tryCatch({
[16:04:48.925]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.925]                     }, error = function(ex) {
[16:04:48.925]                       msg <- conditionMessage(ex)
[16:04:48.925]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.925]                         fi_tmp[["mtime"]], msg)
[16:04:48.925]                       ex$message <- msg
[16:04:48.925]                       stop(ex)
[16:04:48.925]                     })
[16:04:48.925]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.925]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.925]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.925]                       fi <- file.info(pathname)
[16:04:48.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.925]                         fi[["size"]], fi[["mtime"]])
[16:04:48.925]                       stop(msg)
[16:04:48.925]                     }
[16:04:48.925]                     invisible(pathname)
[16:04:48.925]                   }
[16:04:48.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.925]                     rootPath = tempdir()) 
[16:04:48.925]                   {
[16:04:48.925]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.925]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.925]                       tmpdir = path, fileext = ".rds")
[16:04:48.925]                     save_rds(obj, file)
[16:04:48.925]                   }
[16:04:48.925]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.925]                   {
[16:04:48.925]                     inherits <- base::inherits
[16:04:48.925]                     invokeRestart <- base::invokeRestart
[16:04:48.925]                     is.null <- base::is.null
[16:04:48.925]                     muffled <- FALSE
[16:04:48.925]                     if (inherits(cond, "message")) {
[16:04:48.925]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.925]                       if (muffled) 
[16:04:48.925]                         invokeRestart("muffleMessage")
[16:04:48.925]                     }
[16:04:48.925]                     else if (inherits(cond, "warning")) {
[16:04:48.925]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.925]                       if (muffled) 
[16:04:48.925]                         invokeRestart("muffleWarning")
[16:04:48.925]                     }
[16:04:48.925]                     else if (inherits(cond, "condition")) {
[16:04:48.925]                       if (!is.null(pattern)) {
[16:04:48.925]                         computeRestarts <- base::computeRestarts
[16:04:48.925]                         grepl <- base::grepl
[16:04:48.925]                         restarts <- computeRestarts(cond)
[16:04:48.925]                         for (restart in restarts) {
[16:04:48.925]                           name <- restart$name
[16:04:48.925]                           if (is.null(name)) 
[16:04:48.925]                             next
[16:04:48.925]                           if (!grepl(pattern, name)) 
[16:04:48.925]                             next
[16:04:48.925]                           invokeRestart(restart)
[16:04:48.925]                           muffled <- TRUE
[16:04:48.925]                           break
[16:04:48.925]                         }
[16:04:48.925]                       }
[16:04:48.925]                     }
[16:04:48.925]                     invisible(muffled)
[16:04:48.925]                   }
[16:04:48.925]                   muffleCondition(cond)
[16:04:48.925]                 })
[16:04:48.925]             }))
[16:04:48.925]             future::FutureResult(value = ...future.value$value, 
[16:04:48.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.925]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.925]                     ...future.globalenv.names))
[16:04:48.925]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.925]         }, condition = base::local({
[16:04:48.925]             c <- base::c
[16:04:48.925]             inherits <- base::inherits
[16:04:48.925]             invokeRestart <- base::invokeRestart
[16:04:48.925]             length <- base::length
[16:04:48.925]             list <- base::list
[16:04:48.925]             seq.int <- base::seq.int
[16:04:48.925]             signalCondition <- base::signalCondition
[16:04:48.925]             sys.calls <- base::sys.calls
[16:04:48.925]             `[[` <- base::`[[`
[16:04:48.925]             `+` <- base::`+`
[16:04:48.925]             `<<-` <- base::`<<-`
[16:04:48.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.925]                   3L)]
[16:04:48.925]             }
[16:04:48.925]             function(cond) {
[16:04:48.925]                 is_error <- inherits(cond, "error")
[16:04:48.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.925]                   NULL)
[16:04:48.925]                 if (is_error) {
[16:04:48.925]                   sessionInformation <- function() {
[16:04:48.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.925]                       search = base::search(), system = base::Sys.info())
[16:04:48.925]                   }
[16:04:48.925]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.925]                     cond$call), session = sessionInformation(), 
[16:04:48.925]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.925]                   signalCondition(cond)
[16:04:48.925]                 }
[16:04:48.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.925]                 "immediateCondition"))) {
[16:04:48.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.925]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.925]                   if (TRUE && !signal) {
[16:04:48.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.925]                     {
[16:04:48.925]                       inherits <- base::inherits
[16:04:48.925]                       invokeRestart <- base::invokeRestart
[16:04:48.925]                       is.null <- base::is.null
[16:04:48.925]                       muffled <- FALSE
[16:04:48.925]                       if (inherits(cond, "message")) {
[16:04:48.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.925]                         if (muffled) 
[16:04:48.925]                           invokeRestart("muffleMessage")
[16:04:48.925]                       }
[16:04:48.925]                       else if (inherits(cond, "warning")) {
[16:04:48.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.925]                         if (muffled) 
[16:04:48.925]                           invokeRestart("muffleWarning")
[16:04:48.925]                       }
[16:04:48.925]                       else if (inherits(cond, "condition")) {
[16:04:48.925]                         if (!is.null(pattern)) {
[16:04:48.925]                           computeRestarts <- base::computeRestarts
[16:04:48.925]                           grepl <- base::grepl
[16:04:48.925]                           restarts <- computeRestarts(cond)
[16:04:48.925]                           for (restart in restarts) {
[16:04:48.925]                             name <- restart$name
[16:04:48.925]                             if (is.null(name)) 
[16:04:48.925]                               next
[16:04:48.925]                             if (!grepl(pattern, name)) 
[16:04:48.925]                               next
[16:04:48.925]                             invokeRestart(restart)
[16:04:48.925]                             muffled <- TRUE
[16:04:48.925]                             break
[16:04:48.925]                           }
[16:04:48.925]                         }
[16:04:48.925]                       }
[16:04:48.925]                       invisible(muffled)
[16:04:48.925]                     }
[16:04:48.925]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.925]                   }
[16:04:48.925]                 }
[16:04:48.925]                 else {
[16:04:48.925]                   if (TRUE) {
[16:04:48.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.925]                     {
[16:04:48.925]                       inherits <- base::inherits
[16:04:48.925]                       invokeRestart <- base::invokeRestart
[16:04:48.925]                       is.null <- base::is.null
[16:04:48.925]                       muffled <- FALSE
[16:04:48.925]                       if (inherits(cond, "message")) {
[16:04:48.925]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.925]                         if (muffled) 
[16:04:48.925]                           invokeRestart("muffleMessage")
[16:04:48.925]                       }
[16:04:48.925]                       else if (inherits(cond, "warning")) {
[16:04:48.925]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.925]                         if (muffled) 
[16:04:48.925]                           invokeRestart("muffleWarning")
[16:04:48.925]                       }
[16:04:48.925]                       else if (inherits(cond, "condition")) {
[16:04:48.925]                         if (!is.null(pattern)) {
[16:04:48.925]                           computeRestarts <- base::computeRestarts
[16:04:48.925]                           grepl <- base::grepl
[16:04:48.925]                           restarts <- computeRestarts(cond)
[16:04:48.925]                           for (restart in restarts) {
[16:04:48.925]                             name <- restart$name
[16:04:48.925]                             if (is.null(name)) 
[16:04:48.925]                               next
[16:04:48.925]                             if (!grepl(pattern, name)) 
[16:04:48.925]                               next
[16:04:48.925]                             invokeRestart(restart)
[16:04:48.925]                             muffled <- TRUE
[16:04:48.925]                             break
[16:04:48.925]                           }
[16:04:48.925]                         }
[16:04:48.925]                       }
[16:04:48.925]                       invisible(muffled)
[16:04:48.925]                     }
[16:04:48.925]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.925]                   }
[16:04:48.925]                 }
[16:04:48.925]             }
[16:04:48.925]         }))
[16:04:48.925]     }, error = function(ex) {
[16:04:48.925]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.925]                 ...future.rng), started = ...future.startTime, 
[16:04:48.925]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.925]             version = "1.8"), class = "FutureResult")
[16:04:48.925]     }, finally = {
[16:04:48.925]         if (!identical(...future.workdir, getwd())) 
[16:04:48.925]             setwd(...future.workdir)
[16:04:48.925]         {
[16:04:48.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.925]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.925]             }
[16:04:48.925]             base::options(...future.oldOptions)
[16:04:48.925]             if (.Platform$OS.type == "windows") {
[16:04:48.925]                 old_names <- names(...future.oldEnvVars)
[16:04:48.925]                 envs <- base::Sys.getenv()
[16:04:48.925]                 names <- names(envs)
[16:04:48.925]                 common <- intersect(names, old_names)
[16:04:48.925]                 added <- setdiff(names, old_names)
[16:04:48.925]                 removed <- setdiff(old_names, names)
[16:04:48.925]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.925]                   envs[common]]
[16:04:48.925]                 NAMES <- toupper(changed)
[16:04:48.925]                 args <- list()
[16:04:48.925]                 for (kk in seq_along(NAMES)) {
[16:04:48.925]                   name <- changed[[kk]]
[16:04:48.925]                   NAME <- NAMES[[kk]]
[16:04:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.925]                     next
[16:04:48.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.925]                 }
[16:04:48.925]                 NAMES <- toupper(added)
[16:04:48.925]                 for (kk in seq_along(NAMES)) {
[16:04:48.925]                   name <- added[[kk]]
[16:04:48.925]                   NAME <- NAMES[[kk]]
[16:04:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.925]                     next
[16:04:48.925]                   args[[name]] <- ""
[16:04:48.925]                 }
[16:04:48.925]                 NAMES <- toupper(removed)
[16:04:48.925]                 for (kk in seq_along(NAMES)) {
[16:04:48.925]                   name <- removed[[kk]]
[16:04:48.925]                   NAME <- NAMES[[kk]]
[16:04:48.925]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.925]                     next
[16:04:48.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.925]                 }
[16:04:48.925]                 if (length(args) > 0) 
[16:04:48.925]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.925]             }
[16:04:48.925]             else {
[16:04:48.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.925]             }
[16:04:48.925]             {
[16:04:48.925]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.925]                   0L) {
[16:04:48.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.925]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.925]                   base::options(opts)
[16:04:48.925]                 }
[16:04:48.925]                 {
[16:04:48.925]                   {
[16:04:48.925]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.925]                     NULL
[16:04:48.925]                   }
[16:04:48.925]                   options(future.plan = NULL)
[16:04:48.925]                   if (is.na(NA_character_)) 
[16:04:48.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.925]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.925]                     envir = parent.frame()) 
[16:04:48.925]                   {
[16:04:48.925]                     default_workers <- missing(workers)
[16:04:48.925]                     if (is.function(workers)) 
[16:04:48.925]                       workers <- workers()
[16:04:48.925]                     workers <- structure(as.integer(workers), 
[16:04:48.925]                       class = class(workers))
[16:04:48.925]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.925]                       1L)
[16:04:48.925]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.925]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.925]                       if (default_workers) 
[16:04:48.925]                         supportsMulticore(warn = TRUE)
[16:04:48.925]                       return(sequential(..., envir = envir))
[16:04:48.925]                     }
[16:04:48.925]                     oopts <- options(mc.cores = workers)
[16:04:48.925]                     on.exit(options(oopts))
[16:04:48.925]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.925]                       envir = envir)
[16:04:48.925]                     if (!future$lazy) 
[16:04:48.925]                       future <- run(future)
[16:04:48.925]                     invisible(future)
[16:04:48.925]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.925]                 }
[16:04:48.925]             }
[16:04:48.925]         }
[16:04:48.925]     })
[16:04:48.925]     if (TRUE) {
[16:04:48.925]         base::sink(type = "output", split = FALSE)
[16:04:48.925]         if (TRUE) {
[16:04:48.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.925]         }
[16:04:48.925]         else {
[16:04:48.925]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.925]         }
[16:04:48.925]         base::close(...future.stdout)
[16:04:48.925]         ...future.stdout <- NULL
[16:04:48.925]     }
[16:04:48.925]     ...future.result$conditions <- ...future.conditions
[16:04:48.925]     ...future.result$finished <- base::Sys.time()
[16:04:48.925]     ...future.result
[16:04:48.925] }
[16:04:48.927] requestCore(): workers = 2
[16:04:48.929] MulticoreFuture started
[16:04:48.930] - Launch lazy future ... done
[16:04:48.930] run() for ‘MulticoreFuture’ ... done
[16:04:48.930] result() for MulticoreFuture ...
[16:04:48.931] plan(): Setting new future strategy stack:
[16:04:48.931] List of future strategies:
[16:04:48.931] 1. sequential:
[16:04:48.931]    - args: function (..., envir = parent.frame())
[16:04:48.931]    - tweaked: FALSE
[16:04:48.931]    - call: NULL
[16:04:48.932] plan(): nbrOfWorkers() = 1
[16:04:48.935] plan(): Setting new future strategy stack:
[16:04:48.935] List of future strategies:
[16:04:48.935] 1. multicore:
[16:04:48.935]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.935]    - tweaked: FALSE
[16:04:48.935]    - call: plan(strategy)
[16:04:48.940] plan(): nbrOfWorkers() = 2
[16:04:48.942] result() for MulticoreFuture ...
[16:04:48.942] result() for MulticoreFuture ... done
[16:04:48.943] result() for MulticoreFuture ... done
[16:04:48.943] result() for MulticoreFuture ...
[16:04:48.943] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:04:48.946] getGlobalsAndPackages() ...
[16:04:48.946] Searching for globals...
[16:04:48.949] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:04:48.949] Searching for globals ... DONE
[16:04:48.949] Resolving globals: FALSE
[16:04:48.950] 
[16:04:48.950] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.950] getGlobalsAndPackages() ... DONE
[16:04:48.951] run() for ‘Future’ ...
[16:04:48.951] - state: ‘created’
[16:04:48.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.958] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.959]   - Field: ‘label’
[16:04:48.959]   - Field: ‘local’
[16:04:48.959]   - Field: ‘owner’
[16:04:48.960]   - Field: ‘envir’
[16:04:48.960]   - Field: ‘workers’
[16:04:48.960]   - Field: ‘packages’
[16:04:48.960]   - Field: ‘gc’
[16:04:48.960]   - Field: ‘job’
[16:04:48.960]   - Field: ‘conditions’
[16:04:48.961]   - Field: ‘expr’
[16:04:48.961]   - Field: ‘uuid’
[16:04:48.961]   - Field: ‘seed’
[16:04:48.961]   - Field: ‘version’
[16:04:48.961]   - Field: ‘result’
[16:04:48.961]   - Field: ‘asynchronous’
[16:04:48.961]   - Field: ‘calls’
[16:04:48.961]   - Field: ‘globals’
[16:04:48.962]   - Field: ‘stdout’
[16:04:48.962]   - Field: ‘earlySignal’
[16:04:48.962]   - Field: ‘lazy’
[16:04:48.962]   - Field: ‘state’
[16:04:48.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.962] - Launch lazy future ...
[16:04:48.962] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.963] Packages needed by future strategies (n = 0): <none>
[16:04:48.963] {
[16:04:48.963]     {
[16:04:48.963]         {
[16:04:48.963]             ...future.startTime <- base::Sys.time()
[16:04:48.963]             {
[16:04:48.963]                 {
[16:04:48.963]                   {
[16:04:48.963]                     {
[16:04:48.963]                       {
[16:04:48.963]                         base::local({
[16:04:48.963]                           has_future <- base::requireNamespace("future", 
[16:04:48.963]                             quietly = TRUE)
[16:04:48.963]                           if (has_future) {
[16:04:48.963]                             ns <- base::getNamespace("future")
[16:04:48.963]                             version <- ns[[".package"]][["version"]]
[16:04:48.963]                             if (is.null(version)) 
[16:04:48.963]                               version <- utils::packageVersion("future")
[16:04:48.963]                           }
[16:04:48.963]                           else {
[16:04:48.963]                             version <- NULL
[16:04:48.963]                           }
[16:04:48.963]                           if (!has_future || version < "1.8.0") {
[16:04:48.963]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.963]                               "", base::R.version$version.string), 
[16:04:48.963]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.963]                                 base::R.version$platform, 8 * 
[16:04:48.963]                                   base::.Machine$sizeof.pointer), 
[16:04:48.963]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.963]                                 "release", "version")], collapse = " "), 
[16:04:48.963]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.963]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.963]                               info)
[16:04:48.963]                             info <- base::paste(info, collapse = "; ")
[16:04:48.963]                             if (!has_future) {
[16:04:48.963]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.963]                                 info)
[16:04:48.963]                             }
[16:04:48.963]                             else {
[16:04:48.963]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.963]                                 info, version)
[16:04:48.963]                             }
[16:04:48.963]                             base::stop(msg)
[16:04:48.963]                           }
[16:04:48.963]                         })
[16:04:48.963]                       }
[16:04:48.963]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.963]                       base::options(mc.cores = 1L)
[16:04:48.963]                     }
[16:04:48.963]                     base::local({
[16:04:48.963]                       for (pkg in c("stats", "datasets")) {
[16:04:48.963]                         base::loadNamespace(pkg)
[16:04:48.963]                         base::library(pkg, character.only = TRUE)
[16:04:48.963]                       }
[16:04:48.963]                     })
[16:04:48.963]                   }
[16:04:48.963]                   options(future.plan = NULL)
[16:04:48.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.963]                 }
[16:04:48.963]                 ...future.workdir <- getwd()
[16:04:48.963]             }
[16:04:48.963]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.963]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.963]         }
[16:04:48.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.963]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.963]             base::names(...future.oldOptions))
[16:04:48.963]     }
[16:04:48.963]     if (FALSE) {
[16:04:48.963]     }
[16:04:48.963]     else {
[16:04:48.963]         if (TRUE) {
[16:04:48.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.963]                 open = "w")
[16:04:48.963]         }
[16:04:48.963]         else {
[16:04:48.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.963]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.963]         }
[16:04:48.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.963]             base::sink(type = "output", split = FALSE)
[16:04:48.963]             base::close(...future.stdout)
[16:04:48.963]         }, add = TRUE)
[16:04:48.963]     }
[16:04:48.963]     ...future.frame <- base::sys.nframe()
[16:04:48.963]     ...future.conditions <- base::list()
[16:04:48.963]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.963]     if (FALSE) {
[16:04:48.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.963]     }
[16:04:48.963]     ...future.result <- base::tryCatch({
[16:04:48.963]         base::withCallingHandlers({
[16:04:48.963]             ...future.value <- base::withVisible(base::local({
[16:04:48.963]                 withCallingHandlers({
[16:04:48.963]                   {
[16:04:48.963]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:04:48.963]                   }
[16:04:48.963]                 }, immediateCondition = function(cond) {
[16:04:48.963]                   save_rds <- function (object, pathname, ...) 
[16:04:48.963]                   {
[16:04:48.963]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.963]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.963]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.963]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.963]                         fi_tmp[["mtime"]])
[16:04:48.963]                     }
[16:04:48.963]                     tryCatch({
[16:04:48.963]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.963]                     }, error = function(ex) {
[16:04:48.963]                       msg <- conditionMessage(ex)
[16:04:48.963]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.963]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.963]                         fi_tmp[["mtime"]], msg)
[16:04:48.963]                       ex$message <- msg
[16:04:48.963]                       stop(ex)
[16:04:48.963]                     })
[16:04:48.963]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.963]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.963]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.963]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.963]                       fi <- file.info(pathname)
[16:04:48.963]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.963]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.963]                         fi[["size"]], fi[["mtime"]])
[16:04:48.963]                       stop(msg)
[16:04:48.963]                     }
[16:04:48.963]                     invisible(pathname)
[16:04:48.963]                   }
[16:04:48.963]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.963]                     rootPath = tempdir()) 
[16:04:48.963]                   {
[16:04:48.963]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.963]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.963]                       tmpdir = path, fileext = ".rds")
[16:04:48.963]                     save_rds(obj, file)
[16:04:48.963]                   }
[16:04:48.963]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.963]                   {
[16:04:48.963]                     inherits <- base::inherits
[16:04:48.963]                     invokeRestart <- base::invokeRestart
[16:04:48.963]                     is.null <- base::is.null
[16:04:48.963]                     muffled <- FALSE
[16:04:48.963]                     if (inherits(cond, "message")) {
[16:04:48.963]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.963]                       if (muffled) 
[16:04:48.963]                         invokeRestart("muffleMessage")
[16:04:48.963]                     }
[16:04:48.963]                     else if (inherits(cond, "warning")) {
[16:04:48.963]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.963]                       if (muffled) 
[16:04:48.963]                         invokeRestart("muffleWarning")
[16:04:48.963]                     }
[16:04:48.963]                     else if (inherits(cond, "condition")) {
[16:04:48.963]                       if (!is.null(pattern)) {
[16:04:48.963]                         computeRestarts <- base::computeRestarts
[16:04:48.963]                         grepl <- base::grepl
[16:04:48.963]                         restarts <- computeRestarts(cond)
[16:04:48.963]                         for (restart in restarts) {
[16:04:48.963]                           name <- restart$name
[16:04:48.963]                           if (is.null(name)) 
[16:04:48.963]                             next
[16:04:48.963]                           if (!grepl(pattern, name)) 
[16:04:48.963]                             next
[16:04:48.963]                           invokeRestart(restart)
[16:04:48.963]                           muffled <- TRUE
[16:04:48.963]                           break
[16:04:48.963]                         }
[16:04:48.963]                       }
[16:04:48.963]                     }
[16:04:48.963]                     invisible(muffled)
[16:04:48.963]                   }
[16:04:48.963]                   muffleCondition(cond)
[16:04:48.963]                 })
[16:04:48.963]             }))
[16:04:48.963]             future::FutureResult(value = ...future.value$value, 
[16:04:48.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.963]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.963]                     ...future.globalenv.names))
[16:04:48.963]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.963]         }, condition = base::local({
[16:04:48.963]             c <- base::c
[16:04:48.963]             inherits <- base::inherits
[16:04:48.963]             invokeRestart <- base::invokeRestart
[16:04:48.963]             length <- base::length
[16:04:48.963]             list <- base::list
[16:04:48.963]             seq.int <- base::seq.int
[16:04:48.963]             signalCondition <- base::signalCondition
[16:04:48.963]             sys.calls <- base::sys.calls
[16:04:48.963]             `[[` <- base::`[[`
[16:04:48.963]             `+` <- base::`+`
[16:04:48.963]             `<<-` <- base::`<<-`
[16:04:48.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.963]                   3L)]
[16:04:48.963]             }
[16:04:48.963]             function(cond) {
[16:04:48.963]                 is_error <- inherits(cond, "error")
[16:04:48.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.963]                   NULL)
[16:04:48.963]                 if (is_error) {
[16:04:48.963]                   sessionInformation <- function() {
[16:04:48.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.963]                       search = base::search(), system = base::Sys.info())
[16:04:48.963]                   }
[16:04:48.963]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.963]                     cond$call), session = sessionInformation(), 
[16:04:48.963]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.963]                   signalCondition(cond)
[16:04:48.963]                 }
[16:04:48.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.963]                 "immediateCondition"))) {
[16:04:48.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.963]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.963]                   if (TRUE && !signal) {
[16:04:48.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.963]                     {
[16:04:48.963]                       inherits <- base::inherits
[16:04:48.963]                       invokeRestart <- base::invokeRestart
[16:04:48.963]                       is.null <- base::is.null
[16:04:48.963]                       muffled <- FALSE
[16:04:48.963]                       if (inherits(cond, "message")) {
[16:04:48.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.963]                         if (muffled) 
[16:04:48.963]                           invokeRestart("muffleMessage")
[16:04:48.963]                       }
[16:04:48.963]                       else if (inherits(cond, "warning")) {
[16:04:48.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.963]                         if (muffled) 
[16:04:48.963]                           invokeRestart("muffleWarning")
[16:04:48.963]                       }
[16:04:48.963]                       else if (inherits(cond, "condition")) {
[16:04:48.963]                         if (!is.null(pattern)) {
[16:04:48.963]                           computeRestarts <- base::computeRestarts
[16:04:48.963]                           grepl <- base::grepl
[16:04:48.963]                           restarts <- computeRestarts(cond)
[16:04:48.963]                           for (restart in restarts) {
[16:04:48.963]                             name <- restart$name
[16:04:48.963]                             if (is.null(name)) 
[16:04:48.963]                               next
[16:04:48.963]                             if (!grepl(pattern, name)) 
[16:04:48.963]                               next
[16:04:48.963]                             invokeRestart(restart)
[16:04:48.963]                             muffled <- TRUE
[16:04:48.963]                             break
[16:04:48.963]                           }
[16:04:48.963]                         }
[16:04:48.963]                       }
[16:04:48.963]                       invisible(muffled)
[16:04:48.963]                     }
[16:04:48.963]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.963]                   }
[16:04:48.963]                 }
[16:04:48.963]                 else {
[16:04:48.963]                   if (TRUE) {
[16:04:48.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.963]                     {
[16:04:48.963]                       inherits <- base::inherits
[16:04:48.963]                       invokeRestart <- base::invokeRestart
[16:04:48.963]                       is.null <- base::is.null
[16:04:48.963]                       muffled <- FALSE
[16:04:48.963]                       if (inherits(cond, "message")) {
[16:04:48.963]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.963]                         if (muffled) 
[16:04:48.963]                           invokeRestart("muffleMessage")
[16:04:48.963]                       }
[16:04:48.963]                       else if (inherits(cond, "warning")) {
[16:04:48.963]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.963]                         if (muffled) 
[16:04:48.963]                           invokeRestart("muffleWarning")
[16:04:48.963]                       }
[16:04:48.963]                       else if (inherits(cond, "condition")) {
[16:04:48.963]                         if (!is.null(pattern)) {
[16:04:48.963]                           computeRestarts <- base::computeRestarts
[16:04:48.963]                           grepl <- base::grepl
[16:04:48.963]                           restarts <- computeRestarts(cond)
[16:04:48.963]                           for (restart in restarts) {
[16:04:48.963]                             name <- restart$name
[16:04:48.963]                             if (is.null(name)) 
[16:04:48.963]                               next
[16:04:48.963]                             if (!grepl(pattern, name)) 
[16:04:48.963]                               next
[16:04:48.963]                             invokeRestart(restart)
[16:04:48.963]                             muffled <- TRUE
[16:04:48.963]                             break
[16:04:48.963]                           }
[16:04:48.963]                         }
[16:04:48.963]                       }
[16:04:48.963]                       invisible(muffled)
[16:04:48.963]                     }
[16:04:48.963]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.963]                   }
[16:04:48.963]                 }
[16:04:48.963]             }
[16:04:48.963]         }))
[16:04:48.963]     }, error = function(ex) {
[16:04:48.963]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.963]                 ...future.rng), started = ...future.startTime, 
[16:04:48.963]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.963]             version = "1.8"), class = "FutureResult")
[16:04:48.963]     }, finally = {
[16:04:48.963]         if (!identical(...future.workdir, getwd())) 
[16:04:48.963]             setwd(...future.workdir)
[16:04:48.963]         {
[16:04:48.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.963]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.963]             }
[16:04:48.963]             base::options(...future.oldOptions)
[16:04:48.963]             if (.Platform$OS.type == "windows") {
[16:04:48.963]                 old_names <- names(...future.oldEnvVars)
[16:04:48.963]                 envs <- base::Sys.getenv()
[16:04:48.963]                 names <- names(envs)
[16:04:48.963]                 common <- intersect(names, old_names)
[16:04:48.963]                 added <- setdiff(names, old_names)
[16:04:48.963]                 removed <- setdiff(old_names, names)
[16:04:48.963]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.963]                   envs[common]]
[16:04:48.963]                 NAMES <- toupper(changed)
[16:04:48.963]                 args <- list()
[16:04:48.963]                 for (kk in seq_along(NAMES)) {
[16:04:48.963]                   name <- changed[[kk]]
[16:04:48.963]                   NAME <- NAMES[[kk]]
[16:04:48.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.963]                     next
[16:04:48.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.963]                 }
[16:04:48.963]                 NAMES <- toupper(added)
[16:04:48.963]                 for (kk in seq_along(NAMES)) {
[16:04:48.963]                   name <- added[[kk]]
[16:04:48.963]                   NAME <- NAMES[[kk]]
[16:04:48.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.963]                     next
[16:04:48.963]                   args[[name]] <- ""
[16:04:48.963]                 }
[16:04:48.963]                 NAMES <- toupper(removed)
[16:04:48.963]                 for (kk in seq_along(NAMES)) {
[16:04:48.963]                   name <- removed[[kk]]
[16:04:48.963]                   NAME <- NAMES[[kk]]
[16:04:48.963]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.963]                     next
[16:04:48.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.963]                 }
[16:04:48.963]                 if (length(args) > 0) 
[16:04:48.963]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.963]             }
[16:04:48.963]             else {
[16:04:48.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.963]             }
[16:04:48.963]             {
[16:04:48.963]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.963]                   0L) {
[16:04:48.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.963]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.963]                   base::options(opts)
[16:04:48.963]                 }
[16:04:48.963]                 {
[16:04:48.963]                   {
[16:04:48.963]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.963]                     NULL
[16:04:48.963]                   }
[16:04:48.963]                   options(future.plan = NULL)
[16:04:48.963]                   if (is.na(NA_character_)) 
[16:04:48.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.963]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.963]                     envir = parent.frame()) 
[16:04:48.963]                   {
[16:04:48.963]                     default_workers <- missing(workers)
[16:04:48.963]                     if (is.function(workers)) 
[16:04:48.963]                       workers <- workers()
[16:04:48.963]                     workers <- structure(as.integer(workers), 
[16:04:48.963]                       class = class(workers))
[16:04:48.963]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.963]                       1L)
[16:04:48.963]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.963]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.963]                       if (default_workers) 
[16:04:48.963]                         supportsMulticore(warn = TRUE)
[16:04:48.963]                       return(sequential(..., envir = envir))
[16:04:48.963]                     }
[16:04:48.963]                     oopts <- options(mc.cores = workers)
[16:04:48.963]                     on.exit(options(oopts))
[16:04:48.963]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.963]                       envir = envir)
[16:04:48.963]                     if (!future$lazy) 
[16:04:48.963]                       future <- run(future)
[16:04:48.963]                     invisible(future)
[16:04:48.963]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.963]                 }
[16:04:48.963]             }
[16:04:48.963]         }
[16:04:48.963]     })
[16:04:48.963]     if (TRUE) {
[16:04:48.963]         base::sink(type = "output", split = FALSE)
[16:04:48.963]         if (TRUE) {
[16:04:48.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.963]         }
[16:04:48.963]         else {
[16:04:48.963]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.963]         }
[16:04:48.963]         base::close(...future.stdout)
[16:04:48.963]         ...future.stdout <- NULL
[16:04:48.963]     }
[16:04:48.963]     ...future.result$conditions <- ...future.conditions
[16:04:48.963]     ...future.result$finished <- base::Sys.time()
[16:04:48.963]     ...future.result
[16:04:48.963] }
[16:04:48.966] requestCore(): workers = 2
[16:04:48.967] MulticoreFuture started
[16:04:48.968] - Launch lazy future ... done
[16:04:48.968] run() for ‘MulticoreFuture’ ... done
[16:04:48.969] result() for MulticoreFuture ...
[16:04:48.969] plan(): Setting new future strategy stack:
[16:04:48.969] List of future strategies:
[16:04:48.969] 1. sequential:
[16:04:48.969]    - args: function (..., envir = parent.frame())
[16:04:48.969]    - tweaked: FALSE
[16:04:48.969]    - call: NULL
[16:04:48.971] plan(): nbrOfWorkers() = 1
[16:04:48.975] plan(): Setting new future strategy stack:
[16:04:48.975] List of future strategies:
[16:04:48.975] 1. multicore:
[16:04:48.975]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:48.975]    - tweaked: FALSE
[16:04:48.975]    - call: plan(strategy)
[16:04:48.980] plan(): nbrOfWorkers() = 2
[16:04:48.983] result() for MulticoreFuture ...
[16:04:48.983] result() for MulticoreFuture ... done
[16:04:48.983] result() for MulticoreFuture ... done
[16:04:48.983] result() for MulticoreFuture ...
[16:04:48.983] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:04:48.987] getGlobalsAndPackages() ...
[16:04:48.987] Searching for globals...
[16:04:48.990] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:04:48.990] Searching for globals ... DONE
[16:04:48.990] Resolving globals: FALSE
[16:04:48.990] 
[16:04:48.991] - packages: [2] ‘stats’, ‘datasets’
[16:04:48.991] getGlobalsAndPackages() ... DONE
[16:04:48.991] run() for ‘Future’ ...
[16:04:48.991] - state: ‘created’
[16:04:48.991] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:48.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:48.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:48.995]   - Field: ‘label’
[16:04:48.996]   - Field: ‘local’
[16:04:48.996]   - Field: ‘owner’
[16:04:48.996]   - Field: ‘envir’
[16:04:48.996]   - Field: ‘workers’
[16:04:48.996]   - Field: ‘packages’
[16:04:48.996]   - Field: ‘gc’
[16:04:48.996]   - Field: ‘job’
[16:04:48.996]   - Field: ‘conditions’
[16:04:48.997]   - Field: ‘expr’
[16:04:48.997]   - Field: ‘uuid’
[16:04:48.997]   - Field: ‘seed’
[16:04:48.997]   - Field: ‘version’
[16:04:48.997]   - Field: ‘result’
[16:04:48.997]   - Field: ‘asynchronous’
[16:04:48.997]   - Field: ‘calls’
[16:04:48.997]   - Field: ‘globals’
[16:04:48.997]   - Field: ‘stdout’
[16:04:48.998]   - Field: ‘earlySignal’
[16:04:48.998]   - Field: ‘lazy’
[16:04:48.998]   - Field: ‘state’
[16:04:48.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:48.998] - Launch lazy future ...
[16:04:48.998] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:48.998] Packages needed by future strategies (n = 0): <none>
[16:04:48.999] {
[16:04:48.999]     {
[16:04:48.999]         {
[16:04:48.999]             ...future.startTime <- base::Sys.time()
[16:04:48.999]             {
[16:04:48.999]                 {
[16:04:48.999]                   {
[16:04:48.999]                     {
[16:04:48.999]                       {
[16:04:48.999]                         base::local({
[16:04:48.999]                           has_future <- base::requireNamespace("future", 
[16:04:48.999]                             quietly = TRUE)
[16:04:48.999]                           if (has_future) {
[16:04:48.999]                             ns <- base::getNamespace("future")
[16:04:48.999]                             version <- ns[[".package"]][["version"]]
[16:04:48.999]                             if (is.null(version)) 
[16:04:48.999]                               version <- utils::packageVersion("future")
[16:04:48.999]                           }
[16:04:48.999]                           else {
[16:04:48.999]                             version <- NULL
[16:04:48.999]                           }
[16:04:48.999]                           if (!has_future || version < "1.8.0") {
[16:04:48.999]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:48.999]                               "", base::R.version$version.string), 
[16:04:48.999]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:48.999]                                 base::R.version$platform, 8 * 
[16:04:48.999]                                   base::.Machine$sizeof.pointer), 
[16:04:48.999]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:48.999]                                 "release", "version")], collapse = " "), 
[16:04:48.999]                               hostname = base::Sys.info()[["nodename"]])
[16:04:48.999]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:48.999]                               info)
[16:04:48.999]                             info <- base::paste(info, collapse = "; ")
[16:04:48.999]                             if (!has_future) {
[16:04:48.999]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:48.999]                                 info)
[16:04:48.999]                             }
[16:04:48.999]                             else {
[16:04:48.999]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:48.999]                                 info, version)
[16:04:48.999]                             }
[16:04:48.999]                             base::stop(msg)
[16:04:48.999]                           }
[16:04:48.999]                         })
[16:04:48.999]                       }
[16:04:48.999]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:48.999]                       base::options(mc.cores = 1L)
[16:04:48.999]                     }
[16:04:48.999]                     base::local({
[16:04:48.999]                       for (pkg in c("stats", "datasets")) {
[16:04:48.999]                         base::loadNamespace(pkg)
[16:04:48.999]                         base::library(pkg, character.only = TRUE)
[16:04:48.999]                       }
[16:04:48.999]                     })
[16:04:48.999]                   }
[16:04:48.999]                   options(future.plan = NULL)
[16:04:48.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:48.999]                 }
[16:04:48.999]                 ...future.workdir <- getwd()
[16:04:48.999]             }
[16:04:48.999]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:48.999]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:48.999]         }
[16:04:48.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:48.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:48.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:48.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:48.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:48.999]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:48.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:48.999]             base::names(...future.oldOptions))
[16:04:48.999]     }
[16:04:48.999]     if (FALSE) {
[16:04:48.999]     }
[16:04:48.999]     else {
[16:04:48.999]         if (TRUE) {
[16:04:48.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:48.999]                 open = "w")
[16:04:48.999]         }
[16:04:48.999]         else {
[16:04:48.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:48.999]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:48.999]         }
[16:04:48.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:48.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:48.999]             base::sink(type = "output", split = FALSE)
[16:04:48.999]             base::close(...future.stdout)
[16:04:48.999]         }, add = TRUE)
[16:04:48.999]     }
[16:04:48.999]     ...future.frame <- base::sys.nframe()
[16:04:48.999]     ...future.conditions <- base::list()
[16:04:48.999]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:48.999]     if (FALSE) {
[16:04:48.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:48.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:48.999]     }
[16:04:48.999]     ...future.result <- base::tryCatch({
[16:04:48.999]         base::withCallingHandlers({
[16:04:48.999]             ...future.value <- base::withVisible(base::local({
[16:04:48.999]                 withCallingHandlers({
[16:04:48.999]                   {
[16:04:48.999]                     lm(dist ~ poly(speed, 2), data = cars)
[16:04:48.999]                   }
[16:04:48.999]                 }, immediateCondition = function(cond) {
[16:04:48.999]                   save_rds <- function (object, pathname, ...) 
[16:04:48.999]                   {
[16:04:48.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:48.999]                     if (file_test("-f", pathname_tmp)) {
[16:04:48.999]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:48.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.999]                         fi_tmp[["mtime"]])
[16:04:48.999]                     }
[16:04:48.999]                     tryCatch({
[16:04:48.999]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:48.999]                     }, error = function(ex) {
[16:04:48.999]                       msg <- conditionMessage(ex)
[16:04:48.999]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:48.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.999]                         fi_tmp[["mtime"]], msg)
[16:04:48.999]                       ex$message <- msg
[16:04:48.999]                       stop(ex)
[16:04:48.999]                     })
[16:04:48.999]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:48.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:48.999]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:48.999]                       fi_tmp <- file.info(pathname_tmp)
[16:04:48.999]                       fi <- file.info(pathname)
[16:04:48.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:48.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:48.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:48.999]                         fi[["size"]], fi[["mtime"]])
[16:04:48.999]                       stop(msg)
[16:04:48.999]                     }
[16:04:48.999]                     invisible(pathname)
[16:04:48.999]                   }
[16:04:48.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:48.999]                     rootPath = tempdir()) 
[16:04:48.999]                   {
[16:04:48.999]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:48.999]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:48.999]                       tmpdir = path, fileext = ".rds")
[16:04:48.999]                     save_rds(obj, file)
[16:04:48.999]                   }
[16:04:48.999]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:48.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.999]                   {
[16:04:48.999]                     inherits <- base::inherits
[16:04:48.999]                     invokeRestart <- base::invokeRestart
[16:04:48.999]                     is.null <- base::is.null
[16:04:48.999]                     muffled <- FALSE
[16:04:48.999]                     if (inherits(cond, "message")) {
[16:04:48.999]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:48.999]                       if (muffled) 
[16:04:48.999]                         invokeRestart("muffleMessage")
[16:04:48.999]                     }
[16:04:48.999]                     else if (inherits(cond, "warning")) {
[16:04:48.999]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:48.999]                       if (muffled) 
[16:04:48.999]                         invokeRestart("muffleWarning")
[16:04:48.999]                     }
[16:04:48.999]                     else if (inherits(cond, "condition")) {
[16:04:48.999]                       if (!is.null(pattern)) {
[16:04:48.999]                         computeRestarts <- base::computeRestarts
[16:04:48.999]                         grepl <- base::grepl
[16:04:48.999]                         restarts <- computeRestarts(cond)
[16:04:48.999]                         for (restart in restarts) {
[16:04:48.999]                           name <- restart$name
[16:04:48.999]                           if (is.null(name)) 
[16:04:48.999]                             next
[16:04:48.999]                           if (!grepl(pattern, name)) 
[16:04:48.999]                             next
[16:04:48.999]                           invokeRestart(restart)
[16:04:48.999]                           muffled <- TRUE
[16:04:48.999]                           break
[16:04:48.999]                         }
[16:04:48.999]                       }
[16:04:48.999]                     }
[16:04:48.999]                     invisible(muffled)
[16:04:48.999]                   }
[16:04:48.999]                   muffleCondition(cond)
[16:04:48.999]                 })
[16:04:48.999]             }))
[16:04:48.999]             future::FutureResult(value = ...future.value$value, 
[16:04:48.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.999]                   ...future.rng), globalenv = if (FALSE) 
[16:04:48.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:48.999]                     ...future.globalenv.names))
[16:04:48.999]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:48.999]         }, condition = base::local({
[16:04:48.999]             c <- base::c
[16:04:48.999]             inherits <- base::inherits
[16:04:48.999]             invokeRestart <- base::invokeRestart
[16:04:48.999]             length <- base::length
[16:04:48.999]             list <- base::list
[16:04:48.999]             seq.int <- base::seq.int
[16:04:48.999]             signalCondition <- base::signalCondition
[16:04:48.999]             sys.calls <- base::sys.calls
[16:04:48.999]             `[[` <- base::`[[`
[16:04:48.999]             `+` <- base::`+`
[16:04:48.999]             `<<-` <- base::`<<-`
[16:04:48.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:48.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:48.999]                   3L)]
[16:04:48.999]             }
[16:04:48.999]             function(cond) {
[16:04:48.999]                 is_error <- inherits(cond, "error")
[16:04:48.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:48.999]                   NULL)
[16:04:48.999]                 if (is_error) {
[16:04:48.999]                   sessionInformation <- function() {
[16:04:48.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:48.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:48.999]                       search = base::search(), system = base::Sys.info())
[16:04:48.999]                   }
[16:04:48.999]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:48.999]                     cond$call), session = sessionInformation(), 
[16:04:48.999]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:48.999]                   signalCondition(cond)
[16:04:48.999]                 }
[16:04:48.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:48.999]                 "immediateCondition"))) {
[16:04:48.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:48.999]                   ...future.conditions[[length(...future.conditions) + 
[16:04:48.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:48.999]                   if (TRUE && !signal) {
[16:04:48.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.999]                     {
[16:04:48.999]                       inherits <- base::inherits
[16:04:48.999]                       invokeRestart <- base::invokeRestart
[16:04:48.999]                       is.null <- base::is.null
[16:04:48.999]                       muffled <- FALSE
[16:04:48.999]                       if (inherits(cond, "message")) {
[16:04:48.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.999]                         if (muffled) 
[16:04:48.999]                           invokeRestart("muffleMessage")
[16:04:48.999]                       }
[16:04:48.999]                       else if (inherits(cond, "warning")) {
[16:04:48.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.999]                         if (muffled) 
[16:04:48.999]                           invokeRestart("muffleWarning")
[16:04:48.999]                       }
[16:04:48.999]                       else if (inherits(cond, "condition")) {
[16:04:48.999]                         if (!is.null(pattern)) {
[16:04:48.999]                           computeRestarts <- base::computeRestarts
[16:04:48.999]                           grepl <- base::grepl
[16:04:48.999]                           restarts <- computeRestarts(cond)
[16:04:48.999]                           for (restart in restarts) {
[16:04:48.999]                             name <- restart$name
[16:04:48.999]                             if (is.null(name)) 
[16:04:48.999]                               next
[16:04:48.999]                             if (!grepl(pattern, name)) 
[16:04:48.999]                               next
[16:04:48.999]                             invokeRestart(restart)
[16:04:48.999]                             muffled <- TRUE
[16:04:48.999]                             break
[16:04:48.999]                           }
[16:04:48.999]                         }
[16:04:48.999]                       }
[16:04:48.999]                       invisible(muffled)
[16:04:48.999]                     }
[16:04:48.999]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.999]                   }
[16:04:48.999]                 }
[16:04:48.999]                 else {
[16:04:48.999]                   if (TRUE) {
[16:04:48.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:48.999]                     {
[16:04:48.999]                       inherits <- base::inherits
[16:04:48.999]                       invokeRestart <- base::invokeRestart
[16:04:48.999]                       is.null <- base::is.null
[16:04:48.999]                       muffled <- FALSE
[16:04:48.999]                       if (inherits(cond, "message")) {
[16:04:48.999]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:48.999]                         if (muffled) 
[16:04:48.999]                           invokeRestart("muffleMessage")
[16:04:48.999]                       }
[16:04:48.999]                       else if (inherits(cond, "warning")) {
[16:04:48.999]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:48.999]                         if (muffled) 
[16:04:48.999]                           invokeRestart("muffleWarning")
[16:04:48.999]                       }
[16:04:48.999]                       else if (inherits(cond, "condition")) {
[16:04:48.999]                         if (!is.null(pattern)) {
[16:04:48.999]                           computeRestarts <- base::computeRestarts
[16:04:48.999]                           grepl <- base::grepl
[16:04:48.999]                           restarts <- computeRestarts(cond)
[16:04:48.999]                           for (restart in restarts) {
[16:04:48.999]                             name <- restart$name
[16:04:48.999]                             if (is.null(name)) 
[16:04:48.999]                               next
[16:04:48.999]                             if (!grepl(pattern, name)) 
[16:04:48.999]                               next
[16:04:48.999]                             invokeRestart(restart)
[16:04:48.999]                             muffled <- TRUE
[16:04:48.999]                             break
[16:04:48.999]                           }
[16:04:48.999]                         }
[16:04:48.999]                       }
[16:04:48.999]                       invisible(muffled)
[16:04:48.999]                     }
[16:04:48.999]                     muffleCondition(cond, pattern = "^muffle")
[16:04:48.999]                   }
[16:04:48.999]                 }
[16:04:48.999]             }
[16:04:48.999]         }))
[16:04:48.999]     }, error = function(ex) {
[16:04:48.999]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:48.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:48.999]                 ...future.rng), started = ...future.startTime, 
[16:04:48.999]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:48.999]             version = "1.8"), class = "FutureResult")
[16:04:48.999]     }, finally = {
[16:04:48.999]         if (!identical(...future.workdir, getwd())) 
[16:04:48.999]             setwd(...future.workdir)
[16:04:48.999]         {
[16:04:48.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:48.999]                 ...future.oldOptions$nwarnings <- NULL
[16:04:48.999]             }
[16:04:48.999]             base::options(...future.oldOptions)
[16:04:48.999]             if (.Platform$OS.type == "windows") {
[16:04:48.999]                 old_names <- names(...future.oldEnvVars)
[16:04:48.999]                 envs <- base::Sys.getenv()
[16:04:48.999]                 names <- names(envs)
[16:04:48.999]                 common <- intersect(names, old_names)
[16:04:48.999]                 added <- setdiff(names, old_names)
[16:04:48.999]                 removed <- setdiff(old_names, names)
[16:04:48.999]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:48.999]                   envs[common]]
[16:04:48.999]                 NAMES <- toupper(changed)
[16:04:48.999]                 args <- list()
[16:04:48.999]                 for (kk in seq_along(NAMES)) {
[16:04:48.999]                   name <- changed[[kk]]
[16:04:48.999]                   NAME <- NAMES[[kk]]
[16:04:48.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.999]                     next
[16:04:48.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.999]                 }
[16:04:48.999]                 NAMES <- toupper(added)
[16:04:48.999]                 for (kk in seq_along(NAMES)) {
[16:04:48.999]                   name <- added[[kk]]
[16:04:48.999]                   NAME <- NAMES[[kk]]
[16:04:48.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.999]                     next
[16:04:48.999]                   args[[name]] <- ""
[16:04:48.999]                 }
[16:04:48.999]                 NAMES <- toupper(removed)
[16:04:48.999]                 for (kk in seq_along(NAMES)) {
[16:04:48.999]                   name <- removed[[kk]]
[16:04:48.999]                   NAME <- NAMES[[kk]]
[16:04:48.999]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:48.999]                     next
[16:04:48.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:48.999]                 }
[16:04:48.999]                 if (length(args) > 0) 
[16:04:48.999]                   base::do.call(base::Sys.setenv, args = args)
[16:04:48.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:48.999]             }
[16:04:48.999]             else {
[16:04:48.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:48.999]             }
[16:04:48.999]             {
[16:04:48.999]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:48.999]                   0L) {
[16:04:48.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:48.999]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:48.999]                   base::options(opts)
[16:04:48.999]                 }
[16:04:48.999]                 {
[16:04:48.999]                   {
[16:04:48.999]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:48.999]                     NULL
[16:04:48.999]                   }
[16:04:48.999]                   options(future.plan = NULL)
[16:04:48.999]                   if (is.na(NA_character_)) 
[16:04:48.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:48.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:48.999]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:48.999]                     envir = parent.frame()) 
[16:04:48.999]                   {
[16:04:48.999]                     default_workers <- missing(workers)
[16:04:48.999]                     if (is.function(workers)) 
[16:04:48.999]                       workers <- workers()
[16:04:48.999]                     workers <- structure(as.integer(workers), 
[16:04:48.999]                       class = class(workers))
[16:04:48.999]                     stop_if_not(is.finite(workers), workers >= 
[16:04:48.999]                       1L)
[16:04:48.999]                     if ((workers == 1L && !inherits(workers, 
[16:04:48.999]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:48.999]                       if (default_workers) 
[16:04:48.999]                         supportsMulticore(warn = TRUE)
[16:04:48.999]                       return(sequential(..., envir = envir))
[16:04:48.999]                     }
[16:04:48.999]                     oopts <- options(mc.cores = workers)
[16:04:48.999]                     on.exit(options(oopts))
[16:04:48.999]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:48.999]                       envir = envir)
[16:04:48.999]                     if (!future$lazy) 
[16:04:48.999]                       future <- run(future)
[16:04:48.999]                     invisible(future)
[16:04:48.999]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:48.999]                 }
[16:04:48.999]             }
[16:04:48.999]         }
[16:04:48.999]     })
[16:04:48.999]     if (TRUE) {
[16:04:48.999]         base::sink(type = "output", split = FALSE)
[16:04:48.999]         if (TRUE) {
[16:04:48.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:48.999]         }
[16:04:48.999]         else {
[16:04:48.999]             ...future.result["stdout"] <- base::list(NULL)
[16:04:48.999]         }
[16:04:48.999]         base::close(...future.stdout)
[16:04:48.999]         ...future.stdout <- NULL
[16:04:48.999]     }
[16:04:48.999]     ...future.result$conditions <- ...future.conditions
[16:04:48.999]     ...future.result$finished <- base::Sys.time()
[16:04:48.999]     ...future.result
[16:04:48.999] }
[16:04:49.002] requestCore(): workers = 2
[16:04:49.004] MulticoreFuture started
[16:04:49.004] - Launch lazy future ... done
[16:04:49.004] run() for ‘MulticoreFuture’ ... done
[16:04:49.004] result() for MulticoreFuture ...
[16:04:49.005] plan(): Setting new future strategy stack:
[16:04:49.005] List of future strategies:
[16:04:49.005] 1. sequential:
[16:04:49.005]    - args: function (..., envir = parent.frame())
[16:04:49.005]    - tweaked: FALSE
[16:04:49.005]    - call: NULL
[16:04:49.006] plan(): nbrOfWorkers() = 1
[16:04:49.010] plan(): Setting new future strategy stack:
[16:04:49.010] List of future strategies:
[16:04:49.010] 1. multicore:
[16:04:49.010]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:49.010]    - tweaked: FALSE
[16:04:49.010]    - call: plan(strategy)
[16:04:49.015] plan(): nbrOfWorkers() = 2
[16:04:49.017] result() for MulticoreFuture ...
[16:04:49.017] result() for MulticoreFuture ... done
[16:04:49.017] result() for MulticoreFuture ... done
[16:04:49.018] result() for MulticoreFuture ...
[16:04:49.018] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:04:49.020] getGlobalsAndPackages() ...
[16:04:49.020] Searching for globals...
[16:04:49.029] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:49.030] Searching for globals ... DONE
[16:04:49.030] Resolving globals: FALSE
[16:04:49.030] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:49.031] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:49.031] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:49.031] 
[16:04:49.031] getGlobalsAndPackages() ... DONE
[16:04:49.032] run() for ‘Future’ ...
[16:04:49.032] - state: ‘created’
[16:04:49.032] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.036] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.036] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:49.036]   - Field: ‘label’
[16:04:49.037]   - Field: ‘local’
[16:04:49.037]   - Field: ‘owner’
[16:04:49.037]   - Field: ‘envir’
[16:04:49.037]   - Field: ‘workers’
[16:04:49.037]   - Field: ‘packages’
[16:04:49.037]   - Field: ‘gc’
[16:04:49.037]   - Field: ‘job’
[16:04:49.037]   - Field: ‘conditions’
[16:04:49.037]   - Field: ‘expr’
[16:04:49.038]   - Field: ‘uuid’
[16:04:49.038]   - Field: ‘seed’
[16:04:49.038]   - Field: ‘version’
[16:04:49.038]   - Field: ‘result’
[16:04:49.038]   - Field: ‘asynchronous’
[16:04:49.038]   - Field: ‘calls’
[16:04:49.038]   - Field: ‘globals’
[16:04:49.038]   - Field: ‘stdout’
[16:04:49.038]   - Field: ‘earlySignal’
[16:04:49.038]   - Field: ‘lazy’
[16:04:49.039]   - Field: ‘state’
[16:04:49.039] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:49.039] - Launch lazy future ...
[16:04:49.039] Packages needed by the future expression (n = 0): <none>
[16:04:49.039] Packages needed by future strategies (n = 0): <none>
[16:04:49.040] {
[16:04:49.040]     {
[16:04:49.040]         {
[16:04:49.040]             ...future.startTime <- base::Sys.time()
[16:04:49.040]             {
[16:04:49.040]                 {
[16:04:49.040]                   {
[16:04:49.040]                     {
[16:04:49.040]                       base::local({
[16:04:49.040]                         has_future <- base::requireNamespace("future", 
[16:04:49.040]                           quietly = TRUE)
[16:04:49.040]                         if (has_future) {
[16:04:49.040]                           ns <- base::getNamespace("future")
[16:04:49.040]                           version <- ns[[".package"]][["version"]]
[16:04:49.040]                           if (is.null(version)) 
[16:04:49.040]                             version <- utils::packageVersion("future")
[16:04:49.040]                         }
[16:04:49.040]                         else {
[16:04:49.040]                           version <- NULL
[16:04:49.040]                         }
[16:04:49.040]                         if (!has_future || version < "1.8.0") {
[16:04:49.040]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.040]                             "", base::R.version$version.string), 
[16:04:49.040]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:49.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:49.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.040]                               "release", "version")], collapse = " "), 
[16:04:49.040]                             hostname = base::Sys.info()[["nodename"]])
[16:04:49.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.040]                             info)
[16:04:49.040]                           info <- base::paste(info, collapse = "; ")
[16:04:49.040]                           if (!has_future) {
[16:04:49.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.040]                               info)
[16:04:49.040]                           }
[16:04:49.040]                           else {
[16:04:49.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.040]                               info, version)
[16:04:49.040]                           }
[16:04:49.040]                           base::stop(msg)
[16:04:49.040]                         }
[16:04:49.040]                       })
[16:04:49.040]                     }
[16:04:49.040]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.040]                     base::options(mc.cores = 1L)
[16:04:49.040]                   }
[16:04:49.040]                   options(future.plan = NULL)
[16:04:49.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.040]                 }
[16:04:49.040]                 ...future.workdir <- getwd()
[16:04:49.040]             }
[16:04:49.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.040]         }
[16:04:49.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.040]             base::names(...future.oldOptions))
[16:04:49.040]     }
[16:04:49.040]     if (FALSE) {
[16:04:49.040]     }
[16:04:49.040]     else {
[16:04:49.040]         if (TRUE) {
[16:04:49.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.040]                 open = "w")
[16:04:49.040]         }
[16:04:49.040]         else {
[16:04:49.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.040]         }
[16:04:49.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.040]             base::sink(type = "output", split = FALSE)
[16:04:49.040]             base::close(...future.stdout)
[16:04:49.040]         }, add = TRUE)
[16:04:49.040]     }
[16:04:49.040]     ...future.frame <- base::sys.nframe()
[16:04:49.040]     ...future.conditions <- base::list()
[16:04:49.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.040]     if (FALSE) {
[16:04:49.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.040]     }
[16:04:49.040]     ...future.result <- base::tryCatch({
[16:04:49.040]         base::withCallingHandlers({
[16:04:49.040]             ...future.value <- base::withVisible(base::local({
[16:04:49.040]                 withCallingHandlers({
[16:04:49.040]                   {
[16:04:49.040]                     outer_function(1L)
[16:04:49.040]                   }
[16:04:49.040]                 }, immediateCondition = function(cond) {
[16:04:49.040]                   save_rds <- function (object, pathname, ...) 
[16:04:49.040]                   {
[16:04:49.040]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:49.040]                     if (file_test("-f", pathname_tmp)) {
[16:04:49.040]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.040]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:49.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.040]                         fi_tmp[["mtime"]])
[16:04:49.040]                     }
[16:04:49.040]                     tryCatch({
[16:04:49.040]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:49.040]                     }, error = function(ex) {
[16:04:49.040]                       msg <- conditionMessage(ex)
[16:04:49.040]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.040]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:49.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.040]                         fi_tmp[["mtime"]], msg)
[16:04:49.040]                       ex$message <- msg
[16:04:49.040]                       stop(ex)
[16:04:49.040]                     })
[16:04:49.040]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:49.040]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:49.040]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:49.040]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.040]                       fi <- file.info(pathname)
[16:04:49.040]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:49.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.040]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:49.040]                         fi[["size"]], fi[["mtime"]])
[16:04:49.040]                       stop(msg)
[16:04:49.040]                     }
[16:04:49.040]                     invisible(pathname)
[16:04:49.040]                   }
[16:04:49.040]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:49.040]                     rootPath = tempdir()) 
[16:04:49.040]                   {
[16:04:49.040]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:49.040]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:49.040]                       tmpdir = path, fileext = ".rds")
[16:04:49.040]                     save_rds(obj, file)
[16:04:49.040]                   }
[16:04:49.040]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:49.040]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.040]                   {
[16:04:49.040]                     inherits <- base::inherits
[16:04:49.040]                     invokeRestart <- base::invokeRestart
[16:04:49.040]                     is.null <- base::is.null
[16:04:49.040]                     muffled <- FALSE
[16:04:49.040]                     if (inherits(cond, "message")) {
[16:04:49.040]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.040]                       if (muffled) 
[16:04:49.040]                         invokeRestart("muffleMessage")
[16:04:49.040]                     }
[16:04:49.040]                     else if (inherits(cond, "warning")) {
[16:04:49.040]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.040]                       if (muffled) 
[16:04:49.040]                         invokeRestart("muffleWarning")
[16:04:49.040]                     }
[16:04:49.040]                     else if (inherits(cond, "condition")) {
[16:04:49.040]                       if (!is.null(pattern)) {
[16:04:49.040]                         computeRestarts <- base::computeRestarts
[16:04:49.040]                         grepl <- base::grepl
[16:04:49.040]                         restarts <- computeRestarts(cond)
[16:04:49.040]                         for (restart in restarts) {
[16:04:49.040]                           name <- restart$name
[16:04:49.040]                           if (is.null(name)) 
[16:04:49.040]                             next
[16:04:49.040]                           if (!grepl(pattern, name)) 
[16:04:49.040]                             next
[16:04:49.040]                           invokeRestart(restart)
[16:04:49.040]                           muffled <- TRUE
[16:04:49.040]                           break
[16:04:49.040]                         }
[16:04:49.040]                       }
[16:04:49.040]                     }
[16:04:49.040]                     invisible(muffled)
[16:04:49.040]                   }
[16:04:49.040]                   muffleCondition(cond)
[16:04:49.040]                 })
[16:04:49.040]             }))
[16:04:49.040]             future::FutureResult(value = ...future.value$value, 
[16:04:49.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.040]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.040]                     ...future.globalenv.names))
[16:04:49.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.040]         }, condition = base::local({
[16:04:49.040]             c <- base::c
[16:04:49.040]             inherits <- base::inherits
[16:04:49.040]             invokeRestart <- base::invokeRestart
[16:04:49.040]             length <- base::length
[16:04:49.040]             list <- base::list
[16:04:49.040]             seq.int <- base::seq.int
[16:04:49.040]             signalCondition <- base::signalCondition
[16:04:49.040]             sys.calls <- base::sys.calls
[16:04:49.040]             `[[` <- base::`[[`
[16:04:49.040]             `+` <- base::`+`
[16:04:49.040]             `<<-` <- base::`<<-`
[16:04:49.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.040]                   3L)]
[16:04:49.040]             }
[16:04:49.040]             function(cond) {
[16:04:49.040]                 is_error <- inherits(cond, "error")
[16:04:49.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.040]                   NULL)
[16:04:49.040]                 if (is_error) {
[16:04:49.040]                   sessionInformation <- function() {
[16:04:49.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.040]                       search = base::search(), system = base::Sys.info())
[16:04:49.040]                   }
[16:04:49.040]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.040]                     cond$call), session = sessionInformation(), 
[16:04:49.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.040]                   signalCondition(cond)
[16:04:49.040]                 }
[16:04:49.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.040]                 "immediateCondition"))) {
[16:04:49.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.040]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.040]                   if (TRUE && !signal) {
[16:04:49.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.040]                     {
[16:04:49.040]                       inherits <- base::inherits
[16:04:49.040]                       invokeRestart <- base::invokeRestart
[16:04:49.040]                       is.null <- base::is.null
[16:04:49.040]                       muffled <- FALSE
[16:04:49.040]                       if (inherits(cond, "message")) {
[16:04:49.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.040]                         if (muffled) 
[16:04:49.040]                           invokeRestart("muffleMessage")
[16:04:49.040]                       }
[16:04:49.040]                       else if (inherits(cond, "warning")) {
[16:04:49.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.040]                         if (muffled) 
[16:04:49.040]                           invokeRestart("muffleWarning")
[16:04:49.040]                       }
[16:04:49.040]                       else if (inherits(cond, "condition")) {
[16:04:49.040]                         if (!is.null(pattern)) {
[16:04:49.040]                           computeRestarts <- base::computeRestarts
[16:04:49.040]                           grepl <- base::grepl
[16:04:49.040]                           restarts <- computeRestarts(cond)
[16:04:49.040]                           for (restart in restarts) {
[16:04:49.040]                             name <- restart$name
[16:04:49.040]                             if (is.null(name)) 
[16:04:49.040]                               next
[16:04:49.040]                             if (!grepl(pattern, name)) 
[16:04:49.040]                               next
[16:04:49.040]                             invokeRestart(restart)
[16:04:49.040]                             muffled <- TRUE
[16:04:49.040]                             break
[16:04:49.040]                           }
[16:04:49.040]                         }
[16:04:49.040]                       }
[16:04:49.040]                       invisible(muffled)
[16:04:49.040]                     }
[16:04:49.040]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.040]                   }
[16:04:49.040]                 }
[16:04:49.040]                 else {
[16:04:49.040]                   if (TRUE) {
[16:04:49.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.040]                     {
[16:04:49.040]                       inherits <- base::inherits
[16:04:49.040]                       invokeRestart <- base::invokeRestart
[16:04:49.040]                       is.null <- base::is.null
[16:04:49.040]                       muffled <- FALSE
[16:04:49.040]                       if (inherits(cond, "message")) {
[16:04:49.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.040]                         if (muffled) 
[16:04:49.040]                           invokeRestart("muffleMessage")
[16:04:49.040]                       }
[16:04:49.040]                       else if (inherits(cond, "warning")) {
[16:04:49.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.040]                         if (muffled) 
[16:04:49.040]                           invokeRestart("muffleWarning")
[16:04:49.040]                       }
[16:04:49.040]                       else if (inherits(cond, "condition")) {
[16:04:49.040]                         if (!is.null(pattern)) {
[16:04:49.040]                           computeRestarts <- base::computeRestarts
[16:04:49.040]                           grepl <- base::grepl
[16:04:49.040]                           restarts <- computeRestarts(cond)
[16:04:49.040]                           for (restart in restarts) {
[16:04:49.040]                             name <- restart$name
[16:04:49.040]                             if (is.null(name)) 
[16:04:49.040]                               next
[16:04:49.040]                             if (!grepl(pattern, name)) 
[16:04:49.040]                               next
[16:04:49.040]                             invokeRestart(restart)
[16:04:49.040]                             muffled <- TRUE
[16:04:49.040]                             break
[16:04:49.040]                           }
[16:04:49.040]                         }
[16:04:49.040]                       }
[16:04:49.040]                       invisible(muffled)
[16:04:49.040]                     }
[16:04:49.040]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.040]                   }
[16:04:49.040]                 }
[16:04:49.040]             }
[16:04:49.040]         }))
[16:04:49.040]     }, error = function(ex) {
[16:04:49.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.040]                 ...future.rng), started = ...future.startTime, 
[16:04:49.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.040]             version = "1.8"), class = "FutureResult")
[16:04:49.040]     }, finally = {
[16:04:49.040]         if (!identical(...future.workdir, getwd())) 
[16:04:49.040]             setwd(...future.workdir)
[16:04:49.040]         {
[16:04:49.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.040]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.040]             }
[16:04:49.040]             base::options(...future.oldOptions)
[16:04:49.040]             if (.Platform$OS.type == "windows") {
[16:04:49.040]                 old_names <- names(...future.oldEnvVars)
[16:04:49.040]                 envs <- base::Sys.getenv()
[16:04:49.040]                 names <- names(envs)
[16:04:49.040]                 common <- intersect(names, old_names)
[16:04:49.040]                 added <- setdiff(names, old_names)
[16:04:49.040]                 removed <- setdiff(old_names, names)
[16:04:49.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.040]                   envs[common]]
[16:04:49.040]                 NAMES <- toupper(changed)
[16:04:49.040]                 args <- list()
[16:04:49.040]                 for (kk in seq_along(NAMES)) {
[16:04:49.040]                   name <- changed[[kk]]
[16:04:49.040]                   NAME <- NAMES[[kk]]
[16:04:49.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.040]                     next
[16:04:49.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.040]                 }
[16:04:49.040]                 NAMES <- toupper(added)
[16:04:49.040]                 for (kk in seq_along(NAMES)) {
[16:04:49.040]                   name <- added[[kk]]
[16:04:49.040]                   NAME <- NAMES[[kk]]
[16:04:49.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.040]                     next
[16:04:49.040]                   args[[name]] <- ""
[16:04:49.040]                 }
[16:04:49.040]                 NAMES <- toupper(removed)
[16:04:49.040]                 for (kk in seq_along(NAMES)) {
[16:04:49.040]                   name <- removed[[kk]]
[16:04:49.040]                   NAME <- NAMES[[kk]]
[16:04:49.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.040]                     next
[16:04:49.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.040]                 }
[16:04:49.040]                 if (length(args) > 0) 
[16:04:49.040]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.040]             }
[16:04:49.040]             else {
[16:04:49.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.040]             }
[16:04:49.040]             {
[16:04:49.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.040]                   0L) {
[16:04:49.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.040]                   base::options(opts)
[16:04:49.040]                 }
[16:04:49.040]                 {
[16:04:49.040]                   {
[16:04:49.040]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.040]                     NULL
[16:04:49.040]                   }
[16:04:49.040]                   options(future.plan = NULL)
[16:04:49.040]                   if (is.na(NA_character_)) 
[16:04:49.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.040]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:49.040]                     envir = parent.frame()) 
[16:04:49.040]                   {
[16:04:49.040]                     default_workers <- missing(workers)
[16:04:49.040]                     if (is.function(workers)) 
[16:04:49.040]                       workers <- workers()
[16:04:49.040]                     workers <- structure(as.integer(workers), 
[16:04:49.040]                       class = class(workers))
[16:04:49.040]                     stop_if_not(is.finite(workers), workers >= 
[16:04:49.040]                       1L)
[16:04:49.040]                     if ((workers == 1L && !inherits(workers, 
[16:04:49.040]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:49.040]                       if (default_workers) 
[16:04:49.040]                         supportsMulticore(warn = TRUE)
[16:04:49.040]                       return(sequential(..., envir = envir))
[16:04:49.040]                     }
[16:04:49.040]                     oopts <- options(mc.cores = workers)
[16:04:49.040]                     on.exit(options(oopts))
[16:04:49.040]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:49.040]                       envir = envir)
[16:04:49.040]                     if (!future$lazy) 
[16:04:49.040]                       future <- run(future)
[16:04:49.040]                     invisible(future)
[16:04:49.040]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.040]                 }
[16:04:49.040]             }
[16:04:49.040]         }
[16:04:49.040]     })
[16:04:49.040]     if (TRUE) {
[16:04:49.040]         base::sink(type = "output", split = FALSE)
[16:04:49.040]         if (TRUE) {
[16:04:49.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.040]         }
[16:04:49.040]         else {
[16:04:49.040]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.040]         }
[16:04:49.040]         base::close(...future.stdout)
[16:04:49.040]         ...future.stdout <- NULL
[16:04:49.040]     }
[16:04:49.040]     ...future.result$conditions <- ...future.conditions
[16:04:49.040]     ...future.result$finished <- base::Sys.time()
[16:04:49.040]     ...future.result
[16:04:49.040] }
[16:04:49.042] assign_globals() ...
[16:04:49.042] List of 3
[16:04:49.042]  $ outer_function:function (x)  
[16:04:49.042]  $ map           :function (.x, .f, ...)  
[16:04:49.042]  $ inner_function:function (x)  
[16:04:49.042]  - attr(*, "where")=List of 3
[16:04:49.042]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:04:49.042]   ..$ map           :<environment: R_EmptyEnv> 
[16:04:49.042]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:04:49.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:49.042]  - attr(*, "resolved")= logi FALSE
[16:04:49.042]  - attr(*, "total_size")= num 7704
[16:04:49.042]  - attr(*, "already-done")= logi TRUE
[16:04:49.046] - reassign environment for ‘outer_function’
[16:04:49.046] - copied ‘outer_function’ to environment
[16:04:49.046] - reassign environment for ‘map’
[16:04:49.046] - copied ‘map’ to environment
[16:04:49.046] - reassign environment for ‘inner_function’
[16:04:49.046] - copied ‘inner_function’ to environment
[16:04:49.047] assign_globals() ... done
[16:04:49.047] requestCore(): workers = 2
[16:04:49.048] MulticoreFuture started
[16:04:49.049] - Launch lazy future ... done
[16:04:49.049] run() for ‘MulticoreFuture’ ... done
[16:04:49.049] result() for MulticoreFuture ...
[16:04:49.050] plan(): Setting new future strategy stack:
[16:04:49.050] List of future strategies:
[16:04:49.050] 1. sequential:
[16:04:49.050]    - args: function (..., envir = parent.frame())
[16:04:49.050]    - tweaked: FALSE
[16:04:49.050]    - call: NULL
[16:04:49.051] plan(): nbrOfWorkers() = 1
[16:04:49.053] plan(): Setting new future strategy stack:
[16:04:49.053] List of future strategies:
[16:04:49.053] 1. multicore:
[16:04:49.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:49.053]    - tweaked: FALSE
[16:04:49.053]    - call: plan(strategy)
[16:04:49.058] plan(): nbrOfWorkers() = 2
[16:04:49.059] result() for MulticoreFuture ...
[16:04:49.059] result() for MulticoreFuture ... done
[16:04:49.059] result() for MulticoreFuture ... done
[16:04:49.059] result() for MulticoreFuture ...
[16:04:49.059] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:04:49.061] getGlobalsAndPackages() ...
[16:04:49.061] Searching for globals...
[16:04:49.069] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:49.070] Searching for globals ... DONE
[16:04:49.070] Resolving globals: FALSE
[16:04:49.071] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:49.071] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:49.071] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:49.071] 
[16:04:49.072] getGlobalsAndPackages() ... DONE
[16:04:49.072] run() for ‘Future’ ...
[16:04:49.072] - state: ‘created’
[16:04:49.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.076] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:49.076]   - Field: ‘label’
[16:04:49.076]   - Field: ‘local’
[16:04:49.076]   - Field: ‘owner’
[16:04:49.077]   - Field: ‘envir’
[16:04:49.077]   - Field: ‘workers’
[16:04:49.077]   - Field: ‘packages’
[16:04:49.077]   - Field: ‘gc’
[16:04:49.077]   - Field: ‘job’
[16:04:49.077]   - Field: ‘conditions’
[16:04:49.077]   - Field: ‘expr’
[16:04:49.077]   - Field: ‘uuid’
[16:04:49.077]   - Field: ‘seed’
[16:04:49.078]   - Field: ‘version’
[16:04:49.078]   - Field: ‘result’
[16:04:49.078]   - Field: ‘asynchronous’
[16:04:49.078]   - Field: ‘calls’
[16:04:49.078]   - Field: ‘globals’
[16:04:49.078]   - Field: ‘stdout’
[16:04:49.078]   - Field: ‘earlySignal’
[16:04:49.078]   - Field: ‘lazy’
[16:04:49.078]   - Field: ‘state’
[16:04:49.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:49.079] - Launch lazy future ...
[16:04:49.079] Packages needed by the future expression (n = 0): <none>
[16:04:49.079] Packages needed by future strategies (n = 0): <none>
[16:04:49.080] {
[16:04:49.080]     {
[16:04:49.080]         {
[16:04:49.080]             ...future.startTime <- base::Sys.time()
[16:04:49.080]             {
[16:04:49.080]                 {
[16:04:49.080]                   {
[16:04:49.080]                     {
[16:04:49.080]                       base::local({
[16:04:49.080]                         has_future <- base::requireNamespace("future", 
[16:04:49.080]                           quietly = TRUE)
[16:04:49.080]                         if (has_future) {
[16:04:49.080]                           ns <- base::getNamespace("future")
[16:04:49.080]                           version <- ns[[".package"]][["version"]]
[16:04:49.080]                           if (is.null(version)) 
[16:04:49.080]                             version <- utils::packageVersion("future")
[16:04:49.080]                         }
[16:04:49.080]                         else {
[16:04:49.080]                           version <- NULL
[16:04:49.080]                         }
[16:04:49.080]                         if (!has_future || version < "1.8.0") {
[16:04:49.080]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.080]                             "", base::R.version$version.string), 
[16:04:49.080]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:49.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:49.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.080]                               "release", "version")], collapse = " "), 
[16:04:49.080]                             hostname = base::Sys.info()[["nodename"]])
[16:04:49.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.080]                             info)
[16:04:49.080]                           info <- base::paste(info, collapse = "; ")
[16:04:49.080]                           if (!has_future) {
[16:04:49.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.080]                               info)
[16:04:49.080]                           }
[16:04:49.080]                           else {
[16:04:49.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.080]                               info, version)
[16:04:49.080]                           }
[16:04:49.080]                           base::stop(msg)
[16:04:49.080]                         }
[16:04:49.080]                       })
[16:04:49.080]                     }
[16:04:49.080]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.080]                     base::options(mc.cores = 1L)
[16:04:49.080]                   }
[16:04:49.080]                   options(future.plan = NULL)
[16:04:49.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.080]                 }
[16:04:49.080]                 ...future.workdir <- getwd()
[16:04:49.080]             }
[16:04:49.080]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.080]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.080]         }
[16:04:49.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.080]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.080]             base::names(...future.oldOptions))
[16:04:49.080]     }
[16:04:49.080]     if (FALSE) {
[16:04:49.080]     }
[16:04:49.080]     else {
[16:04:49.080]         if (TRUE) {
[16:04:49.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.080]                 open = "w")
[16:04:49.080]         }
[16:04:49.080]         else {
[16:04:49.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.080]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.080]         }
[16:04:49.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.080]             base::sink(type = "output", split = FALSE)
[16:04:49.080]             base::close(...future.stdout)
[16:04:49.080]         }, add = TRUE)
[16:04:49.080]     }
[16:04:49.080]     ...future.frame <- base::sys.nframe()
[16:04:49.080]     ...future.conditions <- base::list()
[16:04:49.080]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.080]     if (FALSE) {
[16:04:49.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.080]     }
[16:04:49.080]     ...future.result <- base::tryCatch({
[16:04:49.080]         base::withCallingHandlers({
[16:04:49.080]             ...future.value <- base::withVisible(base::local({
[16:04:49.080]                 withCallingHandlers({
[16:04:49.080]                   {
[16:04:49.080]                     outer_function(1L)
[16:04:49.080]                   }
[16:04:49.080]                 }, immediateCondition = function(cond) {
[16:04:49.080]                   save_rds <- function (object, pathname, ...) 
[16:04:49.080]                   {
[16:04:49.080]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:49.080]                     if (file_test("-f", pathname_tmp)) {
[16:04:49.080]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.080]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:49.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.080]                         fi_tmp[["mtime"]])
[16:04:49.080]                     }
[16:04:49.080]                     tryCatch({
[16:04:49.080]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:49.080]                     }, error = function(ex) {
[16:04:49.080]                       msg <- conditionMessage(ex)
[16:04:49.080]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.080]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:49.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.080]                         fi_tmp[["mtime"]], msg)
[16:04:49.080]                       ex$message <- msg
[16:04:49.080]                       stop(ex)
[16:04:49.080]                     })
[16:04:49.080]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:49.080]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:49.080]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:49.080]                       fi_tmp <- file.info(pathname_tmp)
[16:04:49.080]                       fi <- file.info(pathname)
[16:04:49.080]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:49.080]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:49.080]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:49.080]                         fi[["size"]], fi[["mtime"]])
[16:04:49.080]                       stop(msg)
[16:04:49.080]                     }
[16:04:49.080]                     invisible(pathname)
[16:04:49.080]                   }
[16:04:49.080]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:49.080]                     rootPath = tempdir()) 
[16:04:49.080]                   {
[16:04:49.080]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:49.080]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:49.080]                       tmpdir = path, fileext = ".rds")
[16:04:49.080]                     save_rds(obj, file)
[16:04:49.080]                   }
[16:04:49.080]                   saveImmediateCondition(cond, path = "/tmp/RtmpKAOwSQ/.future/immediateConditions")
[16:04:49.080]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.080]                   {
[16:04:49.080]                     inherits <- base::inherits
[16:04:49.080]                     invokeRestart <- base::invokeRestart
[16:04:49.080]                     is.null <- base::is.null
[16:04:49.080]                     muffled <- FALSE
[16:04:49.080]                     if (inherits(cond, "message")) {
[16:04:49.080]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.080]                       if (muffled) 
[16:04:49.080]                         invokeRestart("muffleMessage")
[16:04:49.080]                     }
[16:04:49.080]                     else if (inherits(cond, "warning")) {
[16:04:49.080]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.080]                       if (muffled) 
[16:04:49.080]                         invokeRestart("muffleWarning")
[16:04:49.080]                     }
[16:04:49.080]                     else if (inherits(cond, "condition")) {
[16:04:49.080]                       if (!is.null(pattern)) {
[16:04:49.080]                         computeRestarts <- base::computeRestarts
[16:04:49.080]                         grepl <- base::grepl
[16:04:49.080]                         restarts <- computeRestarts(cond)
[16:04:49.080]                         for (restart in restarts) {
[16:04:49.080]                           name <- restart$name
[16:04:49.080]                           if (is.null(name)) 
[16:04:49.080]                             next
[16:04:49.080]                           if (!grepl(pattern, name)) 
[16:04:49.080]                             next
[16:04:49.080]                           invokeRestart(restart)
[16:04:49.080]                           muffled <- TRUE
[16:04:49.080]                           break
[16:04:49.080]                         }
[16:04:49.080]                       }
[16:04:49.080]                     }
[16:04:49.080]                     invisible(muffled)
[16:04:49.080]                   }
[16:04:49.080]                   muffleCondition(cond)
[16:04:49.080]                 })
[16:04:49.080]             }))
[16:04:49.080]             future::FutureResult(value = ...future.value$value, 
[16:04:49.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.080]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.080]                     ...future.globalenv.names))
[16:04:49.080]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.080]         }, condition = base::local({
[16:04:49.080]             c <- base::c
[16:04:49.080]             inherits <- base::inherits
[16:04:49.080]             invokeRestart <- base::invokeRestart
[16:04:49.080]             length <- base::length
[16:04:49.080]             list <- base::list
[16:04:49.080]             seq.int <- base::seq.int
[16:04:49.080]             signalCondition <- base::signalCondition
[16:04:49.080]             sys.calls <- base::sys.calls
[16:04:49.080]             `[[` <- base::`[[`
[16:04:49.080]             `+` <- base::`+`
[16:04:49.080]             `<<-` <- base::`<<-`
[16:04:49.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.080]                   3L)]
[16:04:49.080]             }
[16:04:49.080]             function(cond) {
[16:04:49.080]                 is_error <- inherits(cond, "error")
[16:04:49.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.080]                   NULL)
[16:04:49.080]                 if (is_error) {
[16:04:49.080]                   sessionInformation <- function() {
[16:04:49.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.080]                       search = base::search(), system = base::Sys.info())
[16:04:49.080]                   }
[16:04:49.080]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.080]                     cond$call), session = sessionInformation(), 
[16:04:49.080]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.080]                   signalCondition(cond)
[16:04:49.080]                 }
[16:04:49.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.080]                 "immediateCondition"))) {
[16:04:49.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.080]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.080]                   if (TRUE && !signal) {
[16:04:49.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.080]                     {
[16:04:49.080]                       inherits <- base::inherits
[16:04:49.080]                       invokeRestart <- base::invokeRestart
[16:04:49.080]                       is.null <- base::is.null
[16:04:49.080]                       muffled <- FALSE
[16:04:49.080]                       if (inherits(cond, "message")) {
[16:04:49.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.080]                         if (muffled) 
[16:04:49.080]                           invokeRestart("muffleMessage")
[16:04:49.080]                       }
[16:04:49.080]                       else if (inherits(cond, "warning")) {
[16:04:49.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.080]                         if (muffled) 
[16:04:49.080]                           invokeRestart("muffleWarning")
[16:04:49.080]                       }
[16:04:49.080]                       else if (inherits(cond, "condition")) {
[16:04:49.080]                         if (!is.null(pattern)) {
[16:04:49.080]                           computeRestarts <- base::computeRestarts
[16:04:49.080]                           grepl <- base::grepl
[16:04:49.080]                           restarts <- computeRestarts(cond)
[16:04:49.080]                           for (restart in restarts) {
[16:04:49.080]                             name <- restart$name
[16:04:49.080]                             if (is.null(name)) 
[16:04:49.080]                               next
[16:04:49.080]                             if (!grepl(pattern, name)) 
[16:04:49.080]                               next
[16:04:49.080]                             invokeRestart(restart)
[16:04:49.080]                             muffled <- TRUE
[16:04:49.080]                             break
[16:04:49.080]                           }
[16:04:49.080]                         }
[16:04:49.080]                       }
[16:04:49.080]                       invisible(muffled)
[16:04:49.080]                     }
[16:04:49.080]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.080]                   }
[16:04:49.080]                 }
[16:04:49.080]                 else {
[16:04:49.080]                   if (TRUE) {
[16:04:49.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.080]                     {
[16:04:49.080]                       inherits <- base::inherits
[16:04:49.080]                       invokeRestart <- base::invokeRestart
[16:04:49.080]                       is.null <- base::is.null
[16:04:49.080]                       muffled <- FALSE
[16:04:49.080]                       if (inherits(cond, "message")) {
[16:04:49.080]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.080]                         if (muffled) 
[16:04:49.080]                           invokeRestart("muffleMessage")
[16:04:49.080]                       }
[16:04:49.080]                       else if (inherits(cond, "warning")) {
[16:04:49.080]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.080]                         if (muffled) 
[16:04:49.080]                           invokeRestart("muffleWarning")
[16:04:49.080]                       }
[16:04:49.080]                       else if (inherits(cond, "condition")) {
[16:04:49.080]                         if (!is.null(pattern)) {
[16:04:49.080]                           computeRestarts <- base::computeRestarts
[16:04:49.080]                           grepl <- base::grepl
[16:04:49.080]                           restarts <- computeRestarts(cond)
[16:04:49.080]                           for (restart in restarts) {
[16:04:49.080]                             name <- restart$name
[16:04:49.080]                             if (is.null(name)) 
[16:04:49.080]                               next
[16:04:49.080]                             if (!grepl(pattern, name)) 
[16:04:49.080]                               next
[16:04:49.080]                             invokeRestart(restart)
[16:04:49.080]                             muffled <- TRUE
[16:04:49.080]                             break
[16:04:49.080]                           }
[16:04:49.080]                         }
[16:04:49.080]                       }
[16:04:49.080]                       invisible(muffled)
[16:04:49.080]                     }
[16:04:49.080]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.080]                   }
[16:04:49.080]                 }
[16:04:49.080]             }
[16:04:49.080]         }))
[16:04:49.080]     }, error = function(ex) {
[16:04:49.080]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.080]                 ...future.rng), started = ...future.startTime, 
[16:04:49.080]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.080]             version = "1.8"), class = "FutureResult")
[16:04:49.080]     }, finally = {
[16:04:49.080]         if (!identical(...future.workdir, getwd())) 
[16:04:49.080]             setwd(...future.workdir)
[16:04:49.080]         {
[16:04:49.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.080]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.080]             }
[16:04:49.080]             base::options(...future.oldOptions)
[16:04:49.080]             if (.Platform$OS.type == "windows") {
[16:04:49.080]                 old_names <- names(...future.oldEnvVars)
[16:04:49.080]                 envs <- base::Sys.getenv()
[16:04:49.080]                 names <- names(envs)
[16:04:49.080]                 common <- intersect(names, old_names)
[16:04:49.080]                 added <- setdiff(names, old_names)
[16:04:49.080]                 removed <- setdiff(old_names, names)
[16:04:49.080]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.080]                   envs[common]]
[16:04:49.080]                 NAMES <- toupper(changed)
[16:04:49.080]                 args <- list()
[16:04:49.080]                 for (kk in seq_along(NAMES)) {
[16:04:49.080]                   name <- changed[[kk]]
[16:04:49.080]                   NAME <- NAMES[[kk]]
[16:04:49.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.080]                     next
[16:04:49.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.080]                 }
[16:04:49.080]                 NAMES <- toupper(added)
[16:04:49.080]                 for (kk in seq_along(NAMES)) {
[16:04:49.080]                   name <- added[[kk]]
[16:04:49.080]                   NAME <- NAMES[[kk]]
[16:04:49.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.080]                     next
[16:04:49.080]                   args[[name]] <- ""
[16:04:49.080]                 }
[16:04:49.080]                 NAMES <- toupper(removed)
[16:04:49.080]                 for (kk in seq_along(NAMES)) {
[16:04:49.080]                   name <- removed[[kk]]
[16:04:49.080]                   NAME <- NAMES[[kk]]
[16:04:49.080]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.080]                     next
[16:04:49.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.080]                 }
[16:04:49.080]                 if (length(args) > 0) 
[16:04:49.080]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.080]             }
[16:04:49.080]             else {
[16:04:49.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.080]             }
[16:04:49.080]             {
[16:04:49.080]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.080]                   0L) {
[16:04:49.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.080]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.080]                   base::options(opts)
[16:04:49.080]                 }
[16:04:49.080]                 {
[16:04:49.080]                   {
[16:04:49.080]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.080]                     NULL
[16:04:49.080]                   }
[16:04:49.080]                   options(future.plan = NULL)
[16:04:49.080]                   if (is.na(NA_character_)) 
[16:04:49.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.080]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:49.080]                     envir = parent.frame()) 
[16:04:49.080]                   {
[16:04:49.080]                     default_workers <- missing(workers)
[16:04:49.080]                     if (is.function(workers)) 
[16:04:49.080]                       workers <- workers()
[16:04:49.080]                     workers <- structure(as.integer(workers), 
[16:04:49.080]                       class = class(workers))
[16:04:49.080]                     stop_if_not(is.finite(workers), workers >= 
[16:04:49.080]                       1L)
[16:04:49.080]                     if ((workers == 1L && !inherits(workers, 
[16:04:49.080]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:49.080]                       if (default_workers) 
[16:04:49.080]                         supportsMulticore(warn = TRUE)
[16:04:49.080]                       return(sequential(..., envir = envir))
[16:04:49.080]                     }
[16:04:49.080]                     oopts <- options(mc.cores = workers)
[16:04:49.080]                     on.exit(options(oopts))
[16:04:49.080]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:49.080]                       envir = envir)
[16:04:49.080]                     if (!future$lazy) 
[16:04:49.080]                       future <- run(future)
[16:04:49.080]                     invisible(future)
[16:04:49.080]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.080]                 }
[16:04:49.080]             }
[16:04:49.080]         }
[16:04:49.080]     })
[16:04:49.080]     if (TRUE) {
[16:04:49.080]         base::sink(type = "output", split = FALSE)
[16:04:49.080]         if (TRUE) {
[16:04:49.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.080]         }
[16:04:49.080]         else {
[16:04:49.080]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.080]         }
[16:04:49.080]         base::close(...future.stdout)
[16:04:49.080]         ...future.stdout <- NULL
[16:04:49.080]     }
[16:04:49.080]     ...future.result$conditions <- ...future.conditions
[16:04:49.080]     ...future.result$finished <- base::Sys.time()
[16:04:49.080]     ...future.result
[16:04:49.080] }
[16:04:49.082] assign_globals() ...
[16:04:49.082] List of 3
[16:04:49.082]  $ outer_function:function (x)  
[16:04:49.082]  $ map           :function (.x, .f, ...)  
[16:04:49.082]  $ inner_function:function (x)  
[16:04:49.082]  - attr(*, "where")=List of 3
[16:04:49.082]   ..$ outer_function:<environment: R_EmptyEnv> 
[16:04:49.082]   ..$ map           :<environment: R_EmptyEnv> 
[16:04:49.082]   ..$ inner_function:<environment: R_EmptyEnv> 
[16:04:49.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:49.082]  - attr(*, "resolved")= logi FALSE
[16:04:49.082]  - attr(*, "total_size")= num 7704
[16:04:49.082]  - attr(*, "already-done")= logi TRUE
[16:04:49.086] - reassign environment for ‘outer_function’
[16:04:49.086] - copied ‘outer_function’ to environment
[16:04:49.086] - reassign environment for ‘map’
[16:04:49.086] - copied ‘map’ to environment
[16:04:49.086] - reassign environment for ‘inner_function’
[16:04:49.086] - copied ‘inner_function’ to environment
[16:04:49.086] assign_globals() ... done
[16:04:49.086] requestCore(): workers = 2
[16:04:49.088] MulticoreFuture started
[16:04:49.088] - Launch lazy future ... done
[16:04:49.089] run() for ‘MulticoreFuture’ ... done
[16:04:49.089] result() for MulticoreFuture ...
[16:04:49.089] plan(): Setting new future strategy stack:
[16:04:49.089] List of future strategies:
[16:04:49.089] 1. sequential:
[16:04:49.089]    - args: function (..., envir = parent.frame())
[16:04:49.089]    - tweaked: FALSE
[16:04:49.089]    - call: NULL
[16:04:49.090] plan(): nbrOfWorkers() = 1
[16:04:49.092] plan(): Setting new future strategy stack:
[16:04:49.092] List of future strategies:
[16:04:49.092] 1. multicore:
[16:04:49.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:49.092]    - tweaked: FALSE
[16:04:49.092]    - call: plan(strategy)
[16:04:49.097] plan(): nbrOfWorkers() = 2
[16:04:49.098] result() for MulticoreFuture ...
[16:04:49.098] result() for MulticoreFuture ... done
[16:04:49.098] result() for MulticoreFuture ... done
[16:04:49.098] result() for MulticoreFuture ...
[16:04:49.099] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[16:04:49.100] plan(): Setting new future strategy stack:
[16:04:49.101] List of future strategies:
[16:04:49.101] 1. multisession:
[16:04:49.101]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:49.101]    - tweaked: FALSE
[16:04:49.101]    - call: plan(strategy)
[16:04:49.101] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:49.101] multisession:
[16:04:49.101] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:49.101] - tweaked: FALSE
[16:04:49.101] - call: plan(strategy)
[16:04:49.108] getGlobalsAndPackages() ...
[16:04:49.108] Not searching for globals
[16:04:49.108] - globals: [0] <none>
[16:04:49.109] getGlobalsAndPackages() ... DONE
[16:04:49.109] [local output] makeClusterPSOCK() ...
[16:04:49.152] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:49.153] [local output] Base port: 11699
[16:04:49.153] [local output] Getting setup options for 2 cluster nodes ...
[16:04:49.153] [local output]  - Node 1 of 2 ...
[16:04:49.153] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:49.154] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKAOwSQ/worker.rank=1.parallelly.parent=84024.14838537b3ee5.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpKAOwSQ/worker.rank=1.parallelly.parent=84024.14838537b3ee5.pid")'’
[16:04:49.339] - Possible to infer worker's PID: TRUE
[16:04:49.339] [local output] Rscript port: 11699

[16:04:49.339] [local output]  - Node 2 of 2 ...
[16:04:49.340] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:49.340] [local output] Rscript port: 11699

[16:04:49.341] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:49.341] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:49.341] [local output] Setting up PSOCK nodes in parallel
[16:04:49.342] List of 36
[16:04:49.342]  $ worker          : chr "localhost"
[16:04:49.342]   ..- attr(*, "localhost")= logi TRUE
[16:04:49.342]  $ master          : chr "localhost"
[16:04:49.342]  $ port            : int 11699
[16:04:49.342]  $ connectTimeout  : num 120
[16:04:49.342]  $ timeout         : num 2592000
[16:04:49.342]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:49.342]  $ homogeneous     : logi TRUE
[16:04:49.342]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:49.342]  $ rscript_envs    : NULL
[16:04:49.342]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:49.342]  $ rscript_startup : NULL
[16:04:49.342]  $ rscript_sh      : chr "sh"
[16:04:49.342]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:49.342]  $ methods         : logi TRUE
[16:04:49.342]  $ socketOptions   : chr "no-delay"
[16:04:49.342]  $ useXDR          : logi FALSE
[16:04:49.342]  $ outfile         : chr "/dev/null"
[16:04:49.342]  $ renice          : int NA
[16:04:49.342]  $ rshcmd          : NULL
[16:04:49.342]  $ user            : chr(0) 
[16:04:49.342]  $ revtunnel       : logi FALSE
[16:04:49.342]  $ rshlogfile      : NULL
[16:04:49.342]  $ rshopts         : chr(0) 
[16:04:49.342]  $ rank            : int 1
[16:04:49.342]  $ manual          : logi FALSE
[16:04:49.342]  $ dryrun          : logi FALSE
[16:04:49.342]  $ quiet           : logi FALSE
[16:04:49.342]  $ setup_strategy  : chr "parallel"
[16:04:49.342]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:49.342]  $ pidfile         : chr "/tmp/RtmpKAOwSQ/worker.rank=1.parallelly.parent=84024.14838537b3ee5.pid"
[16:04:49.342]  $ rshcmd_label    : NULL
[16:04:49.342]  $ rsh_call        : NULL
[16:04:49.342]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:49.342]  $ localMachine    : logi TRUE
[16:04:49.342]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:49.342]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:49.342]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:49.342]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:49.342]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:49.342]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:49.342]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:49.342]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:49.342]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:49.342]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:49.342]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:49.342]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:49.342]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:49.342]  $ arguments       :List of 28
[16:04:49.342]   ..$ worker          : chr "localhost"
[16:04:49.342]   ..$ master          : NULL
[16:04:49.342]   ..$ port            : int 11699
[16:04:49.342]   ..$ connectTimeout  : num 120
[16:04:49.342]   ..$ timeout         : num 2592000
[16:04:49.342]   ..$ rscript         : NULL
[16:04:49.342]   ..$ homogeneous     : NULL
[16:04:49.342]   ..$ rscript_args    : NULL
[16:04:49.342]   ..$ rscript_envs    : NULL
[16:04:49.342]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:49.342]   ..$ rscript_startup : NULL
[16:04:49.342]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:49.342]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:49.342]   ..$ methods         : logi TRUE
[16:04:49.342]   ..$ socketOptions   : chr "no-delay"
[16:04:49.342]   ..$ useXDR          : logi FALSE
[16:04:49.342]   ..$ outfile         : chr "/dev/null"
[16:04:49.342]   ..$ renice          : int NA
[16:04:49.342]   ..$ rshcmd          : NULL
[16:04:49.342]   ..$ user            : NULL
[16:04:49.342]   ..$ revtunnel       : logi NA
[16:04:49.342]   ..$ rshlogfile      : NULL
[16:04:49.342]   ..$ rshopts         : NULL
[16:04:49.342]   ..$ rank            : int 1
[16:04:49.342]   ..$ manual          : logi FALSE
[16:04:49.342]   ..$ dryrun          : logi FALSE
[16:04:49.342]   ..$ quiet           : logi FALSE
[16:04:49.342]   ..$ setup_strategy  : chr "parallel"
[16:04:49.342]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:49.359] [local output] System call to launch all workers:
[16:04:49.359] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKAOwSQ/worker.rank=1.parallelly.parent=84024.14838537b3ee5.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11699 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:49.359] [local output] Starting PSOCK main server
[16:04:49.364] [local output] Workers launched
[16:04:49.365] [local output] Waiting for workers to connect back
[16:04:49.365]  - [local output] 0 workers out of 2 ready
[16:04:49.607]  - [local output] 0 workers out of 2 ready
[16:04:49.608]  - [local output] 1 workers out of 2 ready
[16:04:49.608]  - [local output] 2 workers out of 2 ready
[16:04:49.608] [local output] Launching of workers completed
[16:04:49.608] [local output] Collecting session information from workers
[16:04:49.609] [local output]  - Worker #1 of 2
[16:04:49.610] [local output]  - Worker #2 of 2
[16:04:49.610] [local output] makeClusterPSOCK() ... done
[16:04:49.621] Packages needed by the future expression (n = 0): <none>
[16:04:49.621] Packages needed by future strategies (n = 0): <none>
[16:04:49.622] {
[16:04:49.622]     {
[16:04:49.622]         {
[16:04:49.622]             ...future.startTime <- base::Sys.time()
[16:04:49.622]             {
[16:04:49.622]                 {
[16:04:49.622]                   {
[16:04:49.622]                     {
[16:04:49.622]                       base::local({
[16:04:49.622]                         has_future <- base::requireNamespace("future", 
[16:04:49.622]                           quietly = TRUE)
[16:04:49.622]                         if (has_future) {
[16:04:49.622]                           ns <- base::getNamespace("future")
[16:04:49.622]                           version <- ns[[".package"]][["version"]]
[16:04:49.622]                           if (is.null(version)) 
[16:04:49.622]                             version <- utils::packageVersion("future")
[16:04:49.622]                         }
[16:04:49.622]                         else {
[16:04:49.622]                           version <- NULL
[16:04:49.622]                         }
[16:04:49.622]                         if (!has_future || version < "1.8.0") {
[16:04:49.622]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.622]                             "", base::R.version$version.string), 
[16:04:49.622]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:49.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:49.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.622]                               "release", "version")], collapse = " "), 
[16:04:49.622]                             hostname = base::Sys.info()[["nodename"]])
[16:04:49.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.622]                             info)
[16:04:49.622]                           info <- base::paste(info, collapse = "; ")
[16:04:49.622]                           if (!has_future) {
[16:04:49.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.622]                               info)
[16:04:49.622]                           }
[16:04:49.622]                           else {
[16:04:49.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.622]                               info, version)
[16:04:49.622]                           }
[16:04:49.622]                           base::stop(msg)
[16:04:49.622]                         }
[16:04:49.622]                       })
[16:04:49.622]                     }
[16:04:49.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.622]                     base::options(mc.cores = 1L)
[16:04:49.622]                   }
[16:04:49.622]                   options(future.plan = NULL)
[16:04:49.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.622]                 }
[16:04:49.622]                 ...future.workdir <- getwd()
[16:04:49.622]             }
[16:04:49.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.622]         }
[16:04:49.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.622]             base::names(...future.oldOptions))
[16:04:49.622]     }
[16:04:49.622]     if (FALSE) {
[16:04:49.622]     }
[16:04:49.622]     else {
[16:04:49.622]         if (TRUE) {
[16:04:49.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.622]                 open = "w")
[16:04:49.622]         }
[16:04:49.622]         else {
[16:04:49.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.622]         }
[16:04:49.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.622]             base::sink(type = "output", split = FALSE)
[16:04:49.622]             base::close(...future.stdout)
[16:04:49.622]         }, add = TRUE)
[16:04:49.622]     }
[16:04:49.622]     ...future.frame <- base::sys.nframe()
[16:04:49.622]     ...future.conditions <- base::list()
[16:04:49.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.622]     if (FALSE) {
[16:04:49.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.622]     }
[16:04:49.622]     ...future.result <- base::tryCatch({
[16:04:49.622]         base::withCallingHandlers({
[16:04:49.622]             ...future.value <- base::withVisible(base::local({
[16:04:49.622]                 ...future.makeSendCondition <- base::local({
[16:04:49.622]                   sendCondition <- NULL
[16:04:49.622]                   function(frame = 1L) {
[16:04:49.622]                     if (is.function(sendCondition)) 
[16:04:49.622]                       return(sendCondition)
[16:04:49.622]                     ns <- getNamespace("parallel")
[16:04:49.622]                     if (exists("sendData", mode = "function", 
[16:04:49.622]                       envir = ns)) {
[16:04:49.622]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:49.622]                         envir = ns)
[16:04:49.622]                       envir <- sys.frame(frame)
[16:04:49.622]                       master <- NULL
[16:04:49.622]                       while (!identical(envir, .GlobalEnv) && 
[16:04:49.622]                         !identical(envir, emptyenv())) {
[16:04:49.622]                         if (exists("master", mode = "list", envir = envir, 
[16:04:49.622]                           inherits = FALSE)) {
[16:04:49.622]                           master <- get("master", mode = "list", 
[16:04:49.622]                             envir = envir, inherits = FALSE)
[16:04:49.622]                           if (inherits(master, c("SOCKnode", 
[16:04:49.622]                             "SOCK0node"))) {
[16:04:49.622]                             sendCondition <<- function(cond) {
[16:04:49.622]                               data <- list(type = "VALUE", value = cond, 
[16:04:49.622]                                 success = TRUE)
[16:04:49.622]                               parallel_sendData(master, data)
[16:04:49.622]                             }
[16:04:49.622]                             return(sendCondition)
[16:04:49.622]                           }
[16:04:49.622]                         }
[16:04:49.622]                         frame <- frame + 1L
[16:04:49.622]                         envir <- sys.frame(frame)
[16:04:49.622]                       }
[16:04:49.622]                     }
[16:04:49.622]                     sendCondition <<- function(cond) NULL
[16:04:49.622]                   }
[16:04:49.622]                 })
[16:04:49.622]                 withCallingHandlers({
[16:04:49.622]                   NA
[16:04:49.622]                 }, immediateCondition = function(cond) {
[16:04:49.622]                   sendCondition <- ...future.makeSendCondition()
[16:04:49.622]                   sendCondition(cond)
[16:04:49.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.622]                   {
[16:04:49.622]                     inherits <- base::inherits
[16:04:49.622]                     invokeRestart <- base::invokeRestart
[16:04:49.622]                     is.null <- base::is.null
[16:04:49.622]                     muffled <- FALSE
[16:04:49.622]                     if (inherits(cond, "message")) {
[16:04:49.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.622]                       if (muffled) 
[16:04:49.622]                         invokeRestart("muffleMessage")
[16:04:49.622]                     }
[16:04:49.622]                     else if (inherits(cond, "warning")) {
[16:04:49.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.622]                       if (muffled) 
[16:04:49.622]                         invokeRestart("muffleWarning")
[16:04:49.622]                     }
[16:04:49.622]                     else if (inherits(cond, "condition")) {
[16:04:49.622]                       if (!is.null(pattern)) {
[16:04:49.622]                         computeRestarts <- base::computeRestarts
[16:04:49.622]                         grepl <- base::grepl
[16:04:49.622]                         restarts <- computeRestarts(cond)
[16:04:49.622]                         for (restart in restarts) {
[16:04:49.622]                           name <- restart$name
[16:04:49.622]                           if (is.null(name)) 
[16:04:49.622]                             next
[16:04:49.622]                           if (!grepl(pattern, name)) 
[16:04:49.622]                             next
[16:04:49.622]                           invokeRestart(restart)
[16:04:49.622]                           muffled <- TRUE
[16:04:49.622]                           break
[16:04:49.622]                         }
[16:04:49.622]                       }
[16:04:49.622]                     }
[16:04:49.622]                     invisible(muffled)
[16:04:49.622]                   }
[16:04:49.622]                   muffleCondition(cond)
[16:04:49.622]                 })
[16:04:49.622]             }))
[16:04:49.622]             future::FutureResult(value = ...future.value$value, 
[16:04:49.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.622]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.622]                     ...future.globalenv.names))
[16:04:49.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.622]         }, condition = base::local({
[16:04:49.622]             c <- base::c
[16:04:49.622]             inherits <- base::inherits
[16:04:49.622]             invokeRestart <- base::invokeRestart
[16:04:49.622]             length <- base::length
[16:04:49.622]             list <- base::list
[16:04:49.622]             seq.int <- base::seq.int
[16:04:49.622]             signalCondition <- base::signalCondition
[16:04:49.622]             sys.calls <- base::sys.calls
[16:04:49.622]             `[[` <- base::`[[`
[16:04:49.622]             `+` <- base::`+`
[16:04:49.622]             `<<-` <- base::`<<-`
[16:04:49.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.622]                   3L)]
[16:04:49.622]             }
[16:04:49.622]             function(cond) {
[16:04:49.622]                 is_error <- inherits(cond, "error")
[16:04:49.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.622]                   NULL)
[16:04:49.622]                 if (is_error) {
[16:04:49.622]                   sessionInformation <- function() {
[16:04:49.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.622]                       search = base::search(), system = base::Sys.info())
[16:04:49.622]                   }
[16:04:49.622]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.622]                     cond$call), session = sessionInformation(), 
[16:04:49.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.622]                   signalCondition(cond)
[16:04:49.622]                 }
[16:04:49.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.622]                 "immediateCondition"))) {
[16:04:49.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.622]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.622]                   if (TRUE && !signal) {
[16:04:49.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.622]                     {
[16:04:49.622]                       inherits <- base::inherits
[16:04:49.622]                       invokeRestart <- base::invokeRestart
[16:04:49.622]                       is.null <- base::is.null
[16:04:49.622]                       muffled <- FALSE
[16:04:49.622]                       if (inherits(cond, "message")) {
[16:04:49.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.622]                         if (muffled) 
[16:04:49.622]                           invokeRestart("muffleMessage")
[16:04:49.622]                       }
[16:04:49.622]                       else if (inherits(cond, "warning")) {
[16:04:49.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.622]                         if (muffled) 
[16:04:49.622]                           invokeRestart("muffleWarning")
[16:04:49.622]                       }
[16:04:49.622]                       else if (inherits(cond, "condition")) {
[16:04:49.622]                         if (!is.null(pattern)) {
[16:04:49.622]                           computeRestarts <- base::computeRestarts
[16:04:49.622]                           grepl <- base::grepl
[16:04:49.622]                           restarts <- computeRestarts(cond)
[16:04:49.622]                           for (restart in restarts) {
[16:04:49.622]                             name <- restart$name
[16:04:49.622]                             if (is.null(name)) 
[16:04:49.622]                               next
[16:04:49.622]                             if (!grepl(pattern, name)) 
[16:04:49.622]                               next
[16:04:49.622]                             invokeRestart(restart)
[16:04:49.622]                             muffled <- TRUE
[16:04:49.622]                             break
[16:04:49.622]                           }
[16:04:49.622]                         }
[16:04:49.622]                       }
[16:04:49.622]                       invisible(muffled)
[16:04:49.622]                     }
[16:04:49.622]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.622]                   }
[16:04:49.622]                 }
[16:04:49.622]                 else {
[16:04:49.622]                   if (TRUE) {
[16:04:49.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.622]                     {
[16:04:49.622]                       inherits <- base::inherits
[16:04:49.622]                       invokeRestart <- base::invokeRestart
[16:04:49.622]                       is.null <- base::is.null
[16:04:49.622]                       muffled <- FALSE
[16:04:49.622]                       if (inherits(cond, "message")) {
[16:04:49.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.622]                         if (muffled) 
[16:04:49.622]                           invokeRestart("muffleMessage")
[16:04:49.622]                       }
[16:04:49.622]                       else if (inherits(cond, "warning")) {
[16:04:49.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.622]                         if (muffled) 
[16:04:49.622]                           invokeRestart("muffleWarning")
[16:04:49.622]                       }
[16:04:49.622]                       else if (inherits(cond, "condition")) {
[16:04:49.622]                         if (!is.null(pattern)) {
[16:04:49.622]                           computeRestarts <- base::computeRestarts
[16:04:49.622]                           grepl <- base::grepl
[16:04:49.622]                           restarts <- computeRestarts(cond)
[16:04:49.622]                           for (restart in restarts) {
[16:04:49.622]                             name <- restart$name
[16:04:49.622]                             if (is.null(name)) 
[16:04:49.622]                               next
[16:04:49.622]                             if (!grepl(pattern, name)) 
[16:04:49.622]                               next
[16:04:49.622]                             invokeRestart(restart)
[16:04:49.622]                             muffled <- TRUE
[16:04:49.622]                             break
[16:04:49.622]                           }
[16:04:49.622]                         }
[16:04:49.622]                       }
[16:04:49.622]                       invisible(muffled)
[16:04:49.622]                     }
[16:04:49.622]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.622]                   }
[16:04:49.622]                 }
[16:04:49.622]             }
[16:04:49.622]         }))
[16:04:49.622]     }, error = function(ex) {
[16:04:49.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.622]                 ...future.rng), started = ...future.startTime, 
[16:04:49.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.622]             version = "1.8"), class = "FutureResult")
[16:04:49.622]     }, finally = {
[16:04:49.622]         if (!identical(...future.workdir, getwd())) 
[16:04:49.622]             setwd(...future.workdir)
[16:04:49.622]         {
[16:04:49.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.622]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.622]             }
[16:04:49.622]             base::options(...future.oldOptions)
[16:04:49.622]             if (.Platform$OS.type == "windows") {
[16:04:49.622]                 old_names <- names(...future.oldEnvVars)
[16:04:49.622]                 envs <- base::Sys.getenv()
[16:04:49.622]                 names <- names(envs)
[16:04:49.622]                 common <- intersect(names, old_names)
[16:04:49.622]                 added <- setdiff(names, old_names)
[16:04:49.622]                 removed <- setdiff(old_names, names)
[16:04:49.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.622]                   envs[common]]
[16:04:49.622]                 NAMES <- toupper(changed)
[16:04:49.622]                 args <- list()
[16:04:49.622]                 for (kk in seq_along(NAMES)) {
[16:04:49.622]                   name <- changed[[kk]]
[16:04:49.622]                   NAME <- NAMES[[kk]]
[16:04:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.622]                     next
[16:04:49.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.622]                 }
[16:04:49.622]                 NAMES <- toupper(added)
[16:04:49.622]                 for (kk in seq_along(NAMES)) {
[16:04:49.622]                   name <- added[[kk]]
[16:04:49.622]                   NAME <- NAMES[[kk]]
[16:04:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.622]                     next
[16:04:49.622]                   args[[name]] <- ""
[16:04:49.622]                 }
[16:04:49.622]                 NAMES <- toupper(removed)
[16:04:49.622]                 for (kk in seq_along(NAMES)) {
[16:04:49.622]                   name <- removed[[kk]]
[16:04:49.622]                   NAME <- NAMES[[kk]]
[16:04:49.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.622]                     next
[16:04:49.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.622]                 }
[16:04:49.622]                 if (length(args) > 0) 
[16:04:49.622]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.622]             }
[16:04:49.622]             else {
[16:04:49.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.622]             }
[16:04:49.622]             {
[16:04:49.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.622]                   0L) {
[16:04:49.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.622]                   base::options(opts)
[16:04:49.622]                 }
[16:04:49.622]                 {
[16:04:49.622]                   {
[16:04:49.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.622]                     NULL
[16:04:49.622]                   }
[16:04:49.622]                   options(future.plan = NULL)
[16:04:49.622]                   if (is.na(NA_character_)) 
[16:04:49.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.622]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:49.622]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:49.622]                     envir = parent.frame()) 
[16:04:49.622]                   {
[16:04:49.622]                     if (is.function(workers)) 
[16:04:49.622]                       workers <- workers()
[16:04:49.622]                     workers <- structure(as.integer(workers), 
[16:04:49.622]                       class = class(workers))
[16:04:49.622]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:49.622]                       workers >= 1)
[16:04:49.622]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:49.622]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:49.622]                     }
[16:04:49.622]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:49.622]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:49.622]                       envir = envir)
[16:04:49.622]                     if (!future$lazy) 
[16:04:49.622]                       future <- run(future)
[16:04:49.622]                     invisible(future)
[16:04:49.622]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.622]                 }
[16:04:49.622]             }
[16:04:49.622]         }
[16:04:49.622]     })
[16:04:49.622]     if (TRUE) {
[16:04:49.622]         base::sink(type = "output", split = FALSE)
[16:04:49.622]         if (TRUE) {
[16:04:49.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.622]         }
[16:04:49.622]         else {
[16:04:49.622]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.622]         }
[16:04:49.622]         base::close(...future.stdout)
[16:04:49.622]         ...future.stdout <- NULL
[16:04:49.622]     }
[16:04:49.622]     ...future.result$conditions <- ...future.conditions
[16:04:49.622]     ...future.result$finished <- base::Sys.time()
[16:04:49.622]     ...future.result
[16:04:49.622] }
[16:04:49.676] MultisessionFuture started
[16:04:49.676] result() for ClusterFuture ...
[16:04:49.677] receiveMessageFromWorker() for ClusterFuture ...
[16:04:49.677] - Validating connection of MultisessionFuture
[16:04:49.721] - received message: FutureResult
[16:04:49.721] - Received FutureResult
[16:04:49.721] - Erased future from FutureRegistry
[16:04:49.721] result() for ClusterFuture ...
[16:04:49.721] - result already collected: FutureResult
[16:04:49.721] result() for ClusterFuture ... done
[16:04:49.721] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:49.722] result() for ClusterFuture ... done
[16:04:49.722] result() for ClusterFuture ...
[16:04:49.722] - result already collected: FutureResult
[16:04:49.722] result() for ClusterFuture ... done
[16:04:49.722] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:49.726] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[16:04:49.726] getGlobalsAndPackages() ...
[16:04:49.726] Searching for globals...
[16:04:49.728] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:49.728] Searching for globals ... DONE
[16:04:49.728] Resolving globals: FALSE
[16:04:49.729] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:49.729] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:49.730] - globals: [2] ‘weight’, ‘group’
[16:04:49.730] - packages: [1] ‘stats’
[16:04:49.730] getGlobalsAndPackages() ... DONE
[16:04:49.730] run() for ‘Future’ ...
[16:04:49.730] - state: ‘created’
[16:04:49.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:49.745]   - Field: ‘node’
[16:04:49.745]   - Field: ‘label’
[16:04:49.745]   - Field: ‘local’
[16:04:49.745]   - Field: ‘owner’
[16:04:49.745]   - Field: ‘envir’
[16:04:49.746]   - Field: ‘workers’
[16:04:49.746]   - Field: ‘packages’
[16:04:49.746]   - Field: ‘gc’
[16:04:49.746]   - Field: ‘conditions’
[16:04:49.746]   - Field: ‘persistent’
[16:04:49.746]   - Field: ‘expr’
[16:04:49.746]   - Field: ‘uuid’
[16:04:49.746]   - Field: ‘seed’
[16:04:49.746]   - Field: ‘version’
[16:04:49.747]   - Field: ‘result’
[16:04:49.747]   - Field: ‘asynchronous’
[16:04:49.747]   - Field: ‘calls’
[16:04:49.747]   - Field: ‘globals’
[16:04:49.747]   - Field: ‘stdout’
[16:04:49.747]   - Field: ‘earlySignal’
[16:04:49.747]   - Field: ‘lazy’
[16:04:49.747]   - Field: ‘state’
[16:04:49.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:49.748] - Launch lazy future ...
[16:04:49.748] Packages needed by the future expression (n = 1): ‘stats’
[16:04:49.748] Packages needed by future strategies (n = 0): <none>
[16:04:49.749] {
[16:04:49.749]     {
[16:04:49.749]         {
[16:04:49.749]             ...future.startTime <- base::Sys.time()
[16:04:49.749]             {
[16:04:49.749]                 {
[16:04:49.749]                   {
[16:04:49.749]                     {
[16:04:49.749]                       {
[16:04:49.749]                         base::local({
[16:04:49.749]                           has_future <- base::requireNamespace("future", 
[16:04:49.749]                             quietly = TRUE)
[16:04:49.749]                           if (has_future) {
[16:04:49.749]                             ns <- base::getNamespace("future")
[16:04:49.749]                             version <- ns[[".package"]][["version"]]
[16:04:49.749]                             if (is.null(version)) 
[16:04:49.749]                               version <- utils::packageVersion("future")
[16:04:49.749]                           }
[16:04:49.749]                           else {
[16:04:49.749]                             version <- NULL
[16:04:49.749]                           }
[16:04:49.749]                           if (!has_future || version < "1.8.0") {
[16:04:49.749]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.749]                               "", base::R.version$version.string), 
[16:04:49.749]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:49.749]                                 base::R.version$platform, 8 * 
[16:04:49.749]                                   base::.Machine$sizeof.pointer), 
[16:04:49.749]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.749]                                 "release", "version")], collapse = " "), 
[16:04:49.749]                               hostname = base::Sys.info()[["nodename"]])
[16:04:49.749]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.749]                               info)
[16:04:49.749]                             info <- base::paste(info, collapse = "; ")
[16:04:49.749]                             if (!has_future) {
[16:04:49.749]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.749]                                 info)
[16:04:49.749]                             }
[16:04:49.749]                             else {
[16:04:49.749]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.749]                                 info, version)
[16:04:49.749]                             }
[16:04:49.749]                             base::stop(msg)
[16:04:49.749]                           }
[16:04:49.749]                         })
[16:04:49.749]                       }
[16:04:49.749]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.749]                       base::options(mc.cores = 1L)
[16:04:49.749]                     }
[16:04:49.749]                     base::local({
[16:04:49.749]                       for (pkg in "stats") {
[16:04:49.749]                         base::loadNamespace(pkg)
[16:04:49.749]                         base::library(pkg, character.only = TRUE)
[16:04:49.749]                       }
[16:04:49.749]                     })
[16:04:49.749]                   }
[16:04:49.749]                   options(future.plan = NULL)
[16:04:49.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.749]                 }
[16:04:49.749]                 ...future.workdir <- getwd()
[16:04:49.749]             }
[16:04:49.749]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.749]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.749]         }
[16:04:49.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.749]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.749]             base::names(...future.oldOptions))
[16:04:49.749]     }
[16:04:49.749]     if (FALSE) {
[16:04:49.749]     }
[16:04:49.749]     else {
[16:04:49.749]         if (TRUE) {
[16:04:49.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.749]                 open = "w")
[16:04:49.749]         }
[16:04:49.749]         else {
[16:04:49.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.749]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.749]         }
[16:04:49.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.749]             base::sink(type = "output", split = FALSE)
[16:04:49.749]             base::close(...future.stdout)
[16:04:49.749]         }, add = TRUE)
[16:04:49.749]     }
[16:04:49.749]     ...future.frame <- base::sys.nframe()
[16:04:49.749]     ...future.conditions <- base::list()
[16:04:49.749]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.749]     if (FALSE) {
[16:04:49.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.749]     }
[16:04:49.749]     ...future.result <- base::tryCatch({
[16:04:49.749]         base::withCallingHandlers({
[16:04:49.749]             ...future.value <- base::withVisible(base::local({
[16:04:49.749]                 ...future.makeSendCondition <- base::local({
[16:04:49.749]                   sendCondition <- NULL
[16:04:49.749]                   function(frame = 1L) {
[16:04:49.749]                     if (is.function(sendCondition)) 
[16:04:49.749]                       return(sendCondition)
[16:04:49.749]                     ns <- getNamespace("parallel")
[16:04:49.749]                     if (exists("sendData", mode = "function", 
[16:04:49.749]                       envir = ns)) {
[16:04:49.749]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:49.749]                         envir = ns)
[16:04:49.749]                       envir <- sys.frame(frame)
[16:04:49.749]                       master <- NULL
[16:04:49.749]                       while (!identical(envir, .GlobalEnv) && 
[16:04:49.749]                         !identical(envir, emptyenv())) {
[16:04:49.749]                         if (exists("master", mode = "list", envir = envir, 
[16:04:49.749]                           inherits = FALSE)) {
[16:04:49.749]                           master <- get("master", mode = "list", 
[16:04:49.749]                             envir = envir, inherits = FALSE)
[16:04:49.749]                           if (inherits(master, c("SOCKnode", 
[16:04:49.749]                             "SOCK0node"))) {
[16:04:49.749]                             sendCondition <<- function(cond) {
[16:04:49.749]                               data <- list(type = "VALUE", value = cond, 
[16:04:49.749]                                 success = TRUE)
[16:04:49.749]                               parallel_sendData(master, data)
[16:04:49.749]                             }
[16:04:49.749]                             return(sendCondition)
[16:04:49.749]                           }
[16:04:49.749]                         }
[16:04:49.749]                         frame <- frame + 1L
[16:04:49.749]                         envir <- sys.frame(frame)
[16:04:49.749]                       }
[16:04:49.749]                     }
[16:04:49.749]                     sendCondition <<- function(cond) NULL
[16:04:49.749]                   }
[16:04:49.749]                 })
[16:04:49.749]                 withCallingHandlers({
[16:04:49.749]                   {
[16:04:49.749]                     lm(weight ~ group - 1)
[16:04:49.749]                   }
[16:04:49.749]                 }, immediateCondition = function(cond) {
[16:04:49.749]                   sendCondition <- ...future.makeSendCondition()
[16:04:49.749]                   sendCondition(cond)
[16:04:49.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.749]                   {
[16:04:49.749]                     inherits <- base::inherits
[16:04:49.749]                     invokeRestart <- base::invokeRestart
[16:04:49.749]                     is.null <- base::is.null
[16:04:49.749]                     muffled <- FALSE
[16:04:49.749]                     if (inherits(cond, "message")) {
[16:04:49.749]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.749]                       if (muffled) 
[16:04:49.749]                         invokeRestart("muffleMessage")
[16:04:49.749]                     }
[16:04:49.749]                     else if (inherits(cond, "warning")) {
[16:04:49.749]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.749]                       if (muffled) 
[16:04:49.749]                         invokeRestart("muffleWarning")
[16:04:49.749]                     }
[16:04:49.749]                     else if (inherits(cond, "condition")) {
[16:04:49.749]                       if (!is.null(pattern)) {
[16:04:49.749]                         computeRestarts <- base::computeRestarts
[16:04:49.749]                         grepl <- base::grepl
[16:04:49.749]                         restarts <- computeRestarts(cond)
[16:04:49.749]                         for (restart in restarts) {
[16:04:49.749]                           name <- restart$name
[16:04:49.749]                           if (is.null(name)) 
[16:04:49.749]                             next
[16:04:49.749]                           if (!grepl(pattern, name)) 
[16:04:49.749]                             next
[16:04:49.749]                           invokeRestart(restart)
[16:04:49.749]                           muffled <- TRUE
[16:04:49.749]                           break
[16:04:49.749]                         }
[16:04:49.749]                       }
[16:04:49.749]                     }
[16:04:49.749]                     invisible(muffled)
[16:04:49.749]                   }
[16:04:49.749]                   muffleCondition(cond)
[16:04:49.749]                 })
[16:04:49.749]             }))
[16:04:49.749]             future::FutureResult(value = ...future.value$value, 
[16:04:49.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.749]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.749]                     ...future.globalenv.names))
[16:04:49.749]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.749]         }, condition = base::local({
[16:04:49.749]             c <- base::c
[16:04:49.749]             inherits <- base::inherits
[16:04:49.749]             invokeRestart <- base::invokeRestart
[16:04:49.749]             length <- base::length
[16:04:49.749]             list <- base::list
[16:04:49.749]             seq.int <- base::seq.int
[16:04:49.749]             signalCondition <- base::signalCondition
[16:04:49.749]             sys.calls <- base::sys.calls
[16:04:49.749]             `[[` <- base::`[[`
[16:04:49.749]             `+` <- base::`+`
[16:04:49.749]             `<<-` <- base::`<<-`
[16:04:49.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.749]                   3L)]
[16:04:49.749]             }
[16:04:49.749]             function(cond) {
[16:04:49.749]                 is_error <- inherits(cond, "error")
[16:04:49.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.749]                   NULL)
[16:04:49.749]                 if (is_error) {
[16:04:49.749]                   sessionInformation <- function() {
[16:04:49.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.749]                       search = base::search(), system = base::Sys.info())
[16:04:49.749]                   }
[16:04:49.749]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.749]                     cond$call), session = sessionInformation(), 
[16:04:49.749]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.749]                   signalCondition(cond)
[16:04:49.749]                 }
[16:04:49.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.749]                 "immediateCondition"))) {
[16:04:49.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.749]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.749]                   if (TRUE && !signal) {
[16:04:49.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.749]                     {
[16:04:49.749]                       inherits <- base::inherits
[16:04:49.749]                       invokeRestart <- base::invokeRestart
[16:04:49.749]                       is.null <- base::is.null
[16:04:49.749]                       muffled <- FALSE
[16:04:49.749]                       if (inherits(cond, "message")) {
[16:04:49.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.749]                         if (muffled) 
[16:04:49.749]                           invokeRestart("muffleMessage")
[16:04:49.749]                       }
[16:04:49.749]                       else if (inherits(cond, "warning")) {
[16:04:49.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.749]                         if (muffled) 
[16:04:49.749]                           invokeRestart("muffleWarning")
[16:04:49.749]                       }
[16:04:49.749]                       else if (inherits(cond, "condition")) {
[16:04:49.749]                         if (!is.null(pattern)) {
[16:04:49.749]                           computeRestarts <- base::computeRestarts
[16:04:49.749]                           grepl <- base::grepl
[16:04:49.749]                           restarts <- computeRestarts(cond)
[16:04:49.749]                           for (restart in restarts) {
[16:04:49.749]                             name <- restart$name
[16:04:49.749]                             if (is.null(name)) 
[16:04:49.749]                               next
[16:04:49.749]                             if (!grepl(pattern, name)) 
[16:04:49.749]                               next
[16:04:49.749]                             invokeRestart(restart)
[16:04:49.749]                             muffled <- TRUE
[16:04:49.749]                             break
[16:04:49.749]                           }
[16:04:49.749]                         }
[16:04:49.749]                       }
[16:04:49.749]                       invisible(muffled)
[16:04:49.749]                     }
[16:04:49.749]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.749]                   }
[16:04:49.749]                 }
[16:04:49.749]                 else {
[16:04:49.749]                   if (TRUE) {
[16:04:49.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.749]                     {
[16:04:49.749]                       inherits <- base::inherits
[16:04:49.749]                       invokeRestart <- base::invokeRestart
[16:04:49.749]                       is.null <- base::is.null
[16:04:49.749]                       muffled <- FALSE
[16:04:49.749]                       if (inherits(cond, "message")) {
[16:04:49.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.749]                         if (muffled) 
[16:04:49.749]                           invokeRestart("muffleMessage")
[16:04:49.749]                       }
[16:04:49.749]                       else if (inherits(cond, "warning")) {
[16:04:49.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.749]                         if (muffled) 
[16:04:49.749]                           invokeRestart("muffleWarning")
[16:04:49.749]                       }
[16:04:49.749]                       else if (inherits(cond, "condition")) {
[16:04:49.749]                         if (!is.null(pattern)) {
[16:04:49.749]                           computeRestarts <- base::computeRestarts
[16:04:49.749]                           grepl <- base::grepl
[16:04:49.749]                           restarts <- computeRestarts(cond)
[16:04:49.749]                           for (restart in restarts) {
[16:04:49.749]                             name <- restart$name
[16:04:49.749]                             if (is.null(name)) 
[16:04:49.749]                               next
[16:04:49.749]                             if (!grepl(pattern, name)) 
[16:04:49.749]                               next
[16:04:49.749]                             invokeRestart(restart)
[16:04:49.749]                             muffled <- TRUE
[16:04:49.749]                             break
[16:04:49.749]                           }
[16:04:49.749]                         }
[16:04:49.749]                       }
[16:04:49.749]                       invisible(muffled)
[16:04:49.749]                     }
[16:04:49.749]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.749]                   }
[16:04:49.749]                 }
[16:04:49.749]             }
[16:04:49.749]         }))
[16:04:49.749]     }, error = function(ex) {
[16:04:49.749]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.749]                 ...future.rng), started = ...future.startTime, 
[16:04:49.749]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.749]             version = "1.8"), class = "FutureResult")
[16:04:49.749]     }, finally = {
[16:04:49.749]         if (!identical(...future.workdir, getwd())) 
[16:04:49.749]             setwd(...future.workdir)
[16:04:49.749]         {
[16:04:49.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.749]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.749]             }
[16:04:49.749]             base::options(...future.oldOptions)
[16:04:49.749]             if (.Platform$OS.type == "windows") {
[16:04:49.749]                 old_names <- names(...future.oldEnvVars)
[16:04:49.749]                 envs <- base::Sys.getenv()
[16:04:49.749]                 names <- names(envs)
[16:04:49.749]                 common <- intersect(names, old_names)
[16:04:49.749]                 added <- setdiff(names, old_names)
[16:04:49.749]                 removed <- setdiff(old_names, names)
[16:04:49.749]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.749]                   envs[common]]
[16:04:49.749]                 NAMES <- toupper(changed)
[16:04:49.749]                 args <- list()
[16:04:49.749]                 for (kk in seq_along(NAMES)) {
[16:04:49.749]                   name <- changed[[kk]]
[16:04:49.749]                   NAME <- NAMES[[kk]]
[16:04:49.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.749]                     next
[16:04:49.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.749]                 }
[16:04:49.749]                 NAMES <- toupper(added)
[16:04:49.749]                 for (kk in seq_along(NAMES)) {
[16:04:49.749]                   name <- added[[kk]]
[16:04:49.749]                   NAME <- NAMES[[kk]]
[16:04:49.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.749]                     next
[16:04:49.749]                   args[[name]] <- ""
[16:04:49.749]                 }
[16:04:49.749]                 NAMES <- toupper(removed)
[16:04:49.749]                 for (kk in seq_along(NAMES)) {
[16:04:49.749]                   name <- removed[[kk]]
[16:04:49.749]                   NAME <- NAMES[[kk]]
[16:04:49.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.749]                     next
[16:04:49.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.749]                 }
[16:04:49.749]                 if (length(args) > 0) 
[16:04:49.749]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.749]             }
[16:04:49.749]             else {
[16:04:49.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.749]             }
[16:04:49.749]             {
[16:04:49.749]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.749]                   0L) {
[16:04:49.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.749]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.749]                   base::options(opts)
[16:04:49.749]                 }
[16:04:49.749]                 {
[16:04:49.749]                   {
[16:04:49.749]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.749]                     NULL
[16:04:49.749]                   }
[16:04:49.749]                   options(future.plan = NULL)
[16:04:49.749]                   if (is.na(NA_character_)) 
[16:04:49.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.749]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:49.749]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:49.749]                     envir = parent.frame()) 
[16:04:49.749]                   {
[16:04:49.749]                     if (is.function(workers)) 
[16:04:49.749]                       workers <- workers()
[16:04:49.749]                     workers <- structure(as.integer(workers), 
[16:04:49.749]                       class = class(workers))
[16:04:49.749]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:49.749]                       workers >= 1)
[16:04:49.749]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:49.749]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:49.749]                     }
[16:04:49.749]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:49.749]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:49.749]                       envir = envir)
[16:04:49.749]                     if (!future$lazy) 
[16:04:49.749]                       future <- run(future)
[16:04:49.749]                     invisible(future)
[16:04:49.749]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.749]                 }
[16:04:49.749]             }
[16:04:49.749]         }
[16:04:49.749]     })
[16:04:49.749]     if (TRUE) {
[16:04:49.749]         base::sink(type = "output", split = FALSE)
[16:04:49.749]         if (TRUE) {
[16:04:49.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.749]         }
[16:04:49.749]         else {
[16:04:49.749]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.749]         }
[16:04:49.749]         base::close(...future.stdout)
[16:04:49.749]         ...future.stdout <- NULL
[16:04:49.749]     }
[16:04:49.749]     ...future.result$conditions <- ...future.conditions
[16:04:49.749]     ...future.result$finished <- base::Sys.time()
[16:04:49.749]     ...future.result
[16:04:49.749] }
[16:04:49.752] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:04:49.752] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:04:49.752] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:04:49.753] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:04:49.753] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:04:49.753] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:04:49.754] MultisessionFuture started
[16:04:49.754] - Launch lazy future ... done
[16:04:49.754] run() for ‘MultisessionFuture’ ... done
[16:04:49.754] result() for ClusterFuture ...
[16:04:49.754] receiveMessageFromWorker() for ClusterFuture ...
[16:04:49.754] - Validating connection of MultisessionFuture
[16:04:49.803] - received message: FutureResult
[16:04:49.804] - Received FutureResult
[16:04:49.804] - Erased future from FutureRegistry
[16:04:49.804] result() for ClusterFuture ...
[16:04:49.804] - result already collected: FutureResult
[16:04:49.804] result() for ClusterFuture ... done
[16:04:49.804] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:49.805] result() for ClusterFuture ... done
[16:04:49.805] result() for ClusterFuture ...
[16:04:49.805] - result already collected: FutureResult
[16:04:49.805] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:49.807] getGlobalsAndPackages() ...
[16:04:49.807] Searching for globals...
[16:04:49.809] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:49.810] Searching for globals ... DONE
[16:04:49.810] Resolving globals: FALSE
[16:04:49.810] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:49.811] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:49.811] - globals: [2] ‘weight’, ‘group’
[16:04:49.811] - packages: [1] ‘stats’
[16:04:49.811] getGlobalsAndPackages() ... DONE
[16:04:49.812] run() for ‘Future’ ...
[16:04:49.812] - state: ‘created’
[16:04:49.812] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:49.827]   - Field: ‘node’
[16:04:49.827]   - Field: ‘label’
[16:04:49.827]   - Field: ‘local’
[16:04:49.827]   - Field: ‘owner’
[16:04:49.827]   - Field: ‘envir’
[16:04:49.827]   - Field: ‘workers’
[16:04:49.827]   - Field: ‘packages’
[16:04:49.827]   - Field: ‘gc’
[16:04:49.827]   - Field: ‘conditions’
[16:04:49.827]   - Field: ‘persistent’
[16:04:49.828]   - Field: ‘expr’
[16:04:49.828]   - Field: ‘uuid’
[16:04:49.828]   - Field: ‘seed’
[16:04:49.828]   - Field: ‘version’
[16:04:49.828]   - Field: ‘result’
[16:04:49.828]   - Field: ‘asynchronous’
[16:04:49.828]   - Field: ‘calls’
[16:04:49.828]   - Field: ‘globals’
[16:04:49.828]   - Field: ‘stdout’
[16:04:49.829]   - Field: ‘earlySignal’
[16:04:49.829]   - Field: ‘lazy’
[16:04:49.829]   - Field: ‘state’
[16:04:49.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:49.829] - Launch lazy future ...
[16:04:49.829] Packages needed by the future expression (n = 1): ‘stats’
[16:04:49.830] Packages needed by future strategies (n = 0): <none>
[16:04:49.830] {
[16:04:49.830]     {
[16:04:49.830]         {
[16:04:49.830]             ...future.startTime <- base::Sys.time()
[16:04:49.830]             {
[16:04:49.830]                 {
[16:04:49.830]                   {
[16:04:49.830]                     {
[16:04:49.830]                       {
[16:04:49.830]                         base::local({
[16:04:49.830]                           has_future <- base::requireNamespace("future", 
[16:04:49.830]                             quietly = TRUE)
[16:04:49.830]                           if (has_future) {
[16:04:49.830]                             ns <- base::getNamespace("future")
[16:04:49.830]                             version <- ns[[".package"]][["version"]]
[16:04:49.830]                             if (is.null(version)) 
[16:04:49.830]                               version <- utils::packageVersion("future")
[16:04:49.830]                           }
[16:04:49.830]                           else {
[16:04:49.830]                             version <- NULL
[16:04:49.830]                           }
[16:04:49.830]                           if (!has_future || version < "1.8.0") {
[16:04:49.830]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.830]                               "", base::R.version$version.string), 
[16:04:49.830]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:49.830]                                 base::R.version$platform, 8 * 
[16:04:49.830]                                   base::.Machine$sizeof.pointer), 
[16:04:49.830]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.830]                                 "release", "version")], collapse = " "), 
[16:04:49.830]                               hostname = base::Sys.info()[["nodename"]])
[16:04:49.830]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.830]                               info)
[16:04:49.830]                             info <- base::paste(info, collapse = "; ")
[16:04:49.830]                             if (!has_future) {
[16:04:49.830]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.830]                                 info)
[16:04:49.830]                             }
[16:04:49.830]                             else {
[16:04:49.830]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.830]                                 info, version)
[16:04:49.830]                             }
[16:04:49.830]                             base::stop(msg)
[16:04:49.830]                           }
[16:04:49.830]                         })
[16:04:49.830]                       }
[16:04:49.830]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.830]                       base::options(mc.cores = 1L)
[16:04:49.830]                     }
[16:04:49.830]                     base::local({
[16:04:49.830]                       for (pkg in "stats") {
[16:04:49.830]                         base::loadNamespace(pkg)
[16:04:49.830]                         base::library(pkg, character.only = TRUE)
[16:04:49.830]                       }
[16:04:49.830]                     })
[16:04:49.830]                   }
[16:04:49.830]                   options(future.plan = NULL)
[16:04:49.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.830]                 }
[16:04:49.830]                 ...future.workdir <- getwd()
[16:04:49.830]             }
[16:04:49.830]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.830]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.830]         }
[16:04:49.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.830]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.830]             base::names(...future.oldOptions))
[16:04:49.830]     }
[16:04:49.830]     if (FALSE) {
[16:04:49.830]     }
[16:04:49.830]     else {
[16:04:49.830]         if (TRUE) {
[16:04:49.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.830]                 open = "w")
[16:04:49.830]         }
[16:04:49.830]         else {
[16:04:49.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.830]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.830]         }
[16:04:49.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.830]             base::sink(type = "output", split = FALSE)
[16:04:49.830]             base::close(...future.stdout)
[16:04:49.830]         }, add = TRUE)
[16:04:49.830]     }
[16:04:49.830]     ...future.frame <- base::sys.nframe()
[16:04:49.830]     ...future.conditions <- base::list()
[16:04:49.830]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.830]     if (FALSE) {
[16:04:49.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.830]     }
[16:04:49.830]     ...future.result <- base::tryCatch({
[16:04:49.830]         base::withCallingHandlers({
[16:04:49.830]             ...future.value <- base::withVisible(base::local({
[16:04:49.830]                 ...future.makeSendCondition <- base::local({
[16:04:49.830]                   sendCondition <- NULL
[16:04:49.830]                   function(frame = 1L) {
[16:04:49.830]                     if (is.function(sendCondition)) 
[16:04:49.830]                       return(sendCondition)
[16:04:49.830]                     ns <- getNamespace("parallel")
[16:04:49.830]                     if (exists("sendData", mode = "function", 
[16:04:49.830]                       envir = ns)) {
[16:04:49.830]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:49.830]                         envir = ns)
[16:04:49.830]                       envir <- sys.frame(frame)
[16:04:49.830]                       master <- NULL
[16:04:49.830]                       while (!identical(envir, .GlobalEnv) && 
[16:04:49.830]                         !identical(envir, emptyenv())) {
[16:04:49.830]                         if (exists("master", mode = "list", envir = envir, 
[16:04:49.830]                           inherits = FALSE)) {
[16:04:49.830]                           master <- get("master", mode = "list", 
[16:04:49.830]                             envir = envir, inherits = FALSE)
[16:04:49.830]                           if (inherits(master, c("SOCKnode", 
[16:04:49.830]                             "SOCK0node"))) {
[16:04:49.830]                             sendCondition <<- function(cond) {
[16:04:49.830]                               data <- list(type = "VALUE", value = cond, 
[16:04:49.830]                                 success = TRUE)
[16:04:49.830]                               parallel_sendData(master, data)
[16:04:49.830]                             }
[16:04:49.830]                             return(sendCondition)
[16:04:49.830]                           }
[16:04:49.830]                         }
[16:04:49.830]                         frame <- frame + 1L
[16:04:49.830]                         envir <- sys.frame(frame)
[16:04:49.830]                       }
[16:04:49.830]                     }
[16:04:49.830]                     sendCondition <<- function(cond) NULL
[16:04:49.830]                   }
[16:04:49.830]                 })
[16:04:49.830]                 withCallingHandlers({
[16:04:49.830]                   {
[16:04:49.830]                     lm(weight ~ group - 1)
[16:04:49.830]                   }
[16:04:49.830]                 }, immediateCondition = function(cond) {
[16:04:49.830]                   sendCondition <- ...future.makeSendCondition()
[16:04:49.830]                   sendCondition(cond)
[16:04:49.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.830]                   {
[16:04:49.830]                     inherits <- base::inherits
[16:04:49.830]                     invokeRestart <- base::invokeRestart
[16:04:49.830]                     is.null <- base::is.null
[16:04:49.830]                     muffled <- FALSE
[16:04:49.830]                     if (inherits(cond, "message")) {
[16:04:49.830]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.830]                       if (muffled) 
[16:04:49.830]                         invokeRestart("muffleMessage")
[16:04:49.830]                     }
[16:04:49.830]                     else if (inherits(cond, "warning")) {
[16:04:49.830]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.830]                       if (muffled) 
[16:04:49.830]                         invokeRestart("muffleWarning")
[16:04:49.830]                     }
[16:04:49.830]                     else if (inherits(cond, "condition")) {
[16:04:49.830]                       if (!is.null(pattern)) {
[16:04:49.830]                         computeRestarts <- base::computeRestarts
[16:04:49.830]                         grepl <- base::grepl
[16:04:49.830]                         restarts <- computeRestarts(cond)
[16:04:49.830]                         for (restart in restarts) {
[16:04:49.830]                           name <- restart$name
[16:04:49.830]                           if (is.null(name)) 
[16:04:49.830]                             next
[16:04:49.830]                           if (!grepl(pattern, name)) 
[16:04:49.830]                             next
[16:04:49.830]                           invokeRestart(restart)
[16:04:49.830]                           muffled <- TRUE
[16:04:49.830]                           break
[16:04:49.830]                         }
[16:04:49.830]                       }
[16:04:49.830]                     }
[16:04:49.830]                     invisible(muffled)
[16:04:49.830]                   }
[16:04:49.830]                   muffleCondition(cond)
[16:04:49.830]                 })
[16:04:49.830]             }))
[16:04:49.830]             future::FutureResult(value = ...future.value$value, 
[16:04:49.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.830]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.830]                     ...future.globalenv.names))
[16:04:49.830]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.830]         }, condition = base::local({
[16:04:49.830]             c <- base::c
[16:04:49.830]             inherits <- base::inherits
[16:04:49.830]             invokeRestart <- base::invokeRestart
[16:04:49.830]             length <- base::length
[16:04:49.830]             list <- base::list
[16:04:49.830]             seq.int <- base::seq.int
[16:04:49.830]             signalCondition <- base::signalCondition
[16:04:49.830]             sys.calls <- base::sys.calls
[16:04:49.830]             `[[` <- base::`[[`
[16:04:49.830]             `+` <- base::`+`
[16:04:49.830]             `<<-` <- base::`<<-`
[16:04:49.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.830]                   3L)]
[16:04:49.830]             }
[16:04:49.830]             function(cond) {
[16:04:49.830]                 is_error <- inherits(cond, "error")
[16:04:49.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.830]                   NULL)
[16:04:49.830]                 if (is_error) {
[16:04:49.830]                   sessionInformation <- function() {
[16:04:49.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.830]                       search = base::search(), system = base::Sys.info())
[16:04:49.830]                   }
[16:04:49.830]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.830]                     cond$call), session = sessionInformation(), 
[16:04:49.830]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.830]                   signalCondition(cond)
[16:04:49.830]                 }
[16:04:49.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.830]                 "immediateCondition"))) {
[16:04:49.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.830]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.830]                   if (TRUE && !signal) {
[16:04:49.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.830]                     {
[16:04:49.830]                       inherits <- base::inherits
[16:04:49.830]                       invokeRestart <- base::invokeRestart
[16:04:49.830]                       is.null <- base::is.null
[16:04:49.830]                       muffled <- FALSE
[16:04:49.830]                       if (inherits(cond, "message")) {
[16:04:49.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.830]                         if (muffled) 
[16:04:49.830]                           invokeRestart("muffleMessage")
[16:04:49.830]                       }
[16:04:49.830]                       else if (inherits(cond, "warning")) {
[16:04:49.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.830]                         if (muffled) 
[16:04:49.830]                           invokeRestart("muffleWarning")
[16:04:49.830]                       }
[16:04:49.830]                       else if (inherits(cond, "condition")) {
[16:04:49.830]                         if (!is.null(pattern)) {
[16:04:49.830]                           computeRestarts <- base::computeRestarts
[16:04:49.830]                           grepl <- base::grepl
[16:04:49.830]                           restarts <- computeRestarts(cond)
[16:04:49.830]                           for (restart in restarts) {
[16:04:49.830]                             name <- restart$name
[16:04:49.830]                             if (is.null(name)) 
[16:04:49.830]                               next
[16:04:49.830]                             if (!grepl(pattern, name)) 
[16:04:49.830]                               next
[16:04:49.830]                             invokeRestart(restart)
[16:04:49.830]                             muffled <- TRUE
[16:04:49.830]                             break
[16:04:49.830]                           }
[16:04:49.830]                         }
[16:04:49.830]                       }
[16:04:49.830]                       invisible(muffled)
[16:04:49.830]                     }
[16:04:49.830]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.830]                   }
[16:04:49.830]                 }
[16:04:49.830]                 else {
[16:04:49.830]                   if (TRUE) {
[16:04:49.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.830]                     {
[16:04:49.830]                       inherits <- base::inherits
[16:04:49.830]                       invokeRestart <- base::invokeRestart
[16:04:49.830]                       is.null <- base::is.null
[16:04:49.830]                       muffled <- FALSE
[16:04:49.830]                       if (inherits(cond, "message")) {
[16:04:49.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.830]                         if (muffled) 
[16:04:49.830]                           invokeRestart("muffleMessage")
[16:04:49.830]                       }
[16:04:49.830]                       else if (inherits(cond, "warning")) {
[16:04:49.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.830]                         if (muffled) 
[16:04:49.830]                           invokeRestart("muffleWarning")
[16:04:49.830]                       }
[16:04:49.830]                       else if (inherits(cond, "condition")) {
[16:04:49.830]                         if (!is.null(pattern)) {
[16:04:49.830]                           computeRestarts <- base::computeRestarts
[16:04:49.830]                           grepl <- base::grepl
[16:04:49.830]                           restarts <- computeRestarts(cond)
[16:04:49.830]                           for (restart in restarts) {
[16:04:49.830]                             name <- restart$name
[16:04:49.830]                             if (is.null(name)) 
[16:04:49.830]                               next
[16:04:49.830]                             if (!grepl(pattern, name)) 
[16:04:49.830]                               next
[16:04:49.830]                             invokeRestart(restart)
[16:04:49.830]                             muffled <- TRUE
[16:04:49.830]                             break
[16:04:49.830]                           }
[16:04:49.830]                         }
[16:04:49.830]                       }
[16:04:49.830]                       invisible(muffled)
[16:04:49.830]                     }
[16:04:49.830]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.830]                   }
[16:04:49.830]                 }
[16:04:49.830]             }
[16:04:49.830]         }))
[16:04:49.830]     }, error = function(ex) {
[16:04:49.830]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.830]                 ...future.rng), started = ...future.startTime, 
[16:04:49.830]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.830]             version = "1.8"), class = "FutureResult")
[16:04:49.830]     }, finally = {
[16:04:49.830]         if (!identical(...future.workdir, getwd())) 
[16:04:49.830]             setwd(...future.workdir)
[16:04:49.830]         {
[16:04:49.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.830]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.830]             }
[16:04:49.830]             base::options(...future.oldOptions)
[16:04:49.830]             if (.Platform$OS.type == "windows") {
[16:04:49.830]                 old_names <- names(...future.oldEnvVars)
[16:04:49.830]                 envs <- base::Sys.getenv()
[16:04:49.830]                 names <- names(envs)
[16:04:49.830]                 common <- intersect(names, old_names)
[16:04:49.830]                 added <- setdiff(names, old_names)
[16:04:49.830]                 removed <- setdiff(old_names, names)
[16:04:49.830]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.830]                   envs[common]]
[16:04:49.830]                 NAMES <- toupper(changed)
[16:04:49.830]                 args <- list()
[16:04:49.830]                 for (kk in seq_along(NAMES)) {
[16:04:49.830]                   name <- changed[[kk]]
[16:04:49.830]                   NAME <- NAMES[[kk]]
[16:04:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.830]                     next
[16:04:49.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.830]                 }
[16:04:49.830]                 NAMES <- toupper(added)
[16:04:49.830]                 for (kk in seq_along(NAMES)) {
[16:04:49.830]                   name <- added[[kk]]
[16:04:49.830]                   NAME <- NAMES[[kk]]
[16:04:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.830]                     next
[16:04:49.830]                   args[[name]] <- ""
[16:04:49.830]                 }
[16:04:49.830]                 NAMES <- toupper(removed)
[16:04:49.830]                 for (kk in seq_along(NAMES)) {
[16:04:49.830]                   name <- removed[[kk]]
[16:04:49.830]                   NAME <- NAMES[[kk]]
[16:04:49.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.830]                     next
[16:04:49.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.830]                 }
[16:04:49.830]                 if (length(args) > 0) 
[16:04:49.830]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.830]             }
[16:04:49.830]             else {
[16:04:49.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.830]             }
[16:04:49.830]             {
[16:04:49.830]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.830]                   0L) {
[16:04:49.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.830]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.830]                   base::options(opts)
[16:04:49.830]                 }
[16:04:49.830]                 {
[16:04:49.830]                   {
[16:04:49.830]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.830]                     NULL
[16:04:49.830]                   }
[16:04:49.830]                   options(future.plan = NULL)
[16:04:49.830]                   if (is.na(NA_character_)) 
[16:04:49.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.830]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:49.830]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:49.830]                     envir = parent.frame()) 
[16:04:49.830]                   {
[16:04:49.830]                     if (is.function(workers)) 
[16:04:49.830]                       workers <- workers()
[16:04:49.830]                     workers <- structure(as.integer(workers), 
[16:04:49.830]                       class = class(workers))
[16:04:49.830]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:49.830]                       workers >= 1)
[16:04:49.830]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:49.830]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:49.830]                     }
[16:04:49.830]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:49.830]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:49.830]                       envir = envir)
[16:04:49.830]                     if (!future$lazy) 
[16:04:49.830]                       future <- run(future)
[16:04:49.830]                     invisible(future)
[16:04:49.830]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.830]                 }
[16:04:49.830]             }
[16:04:49.830]         }
[16:04:49.830]     })
[16:04:49.830]     if (TRUE) {
[16:04:49.830]         base::sink(type = "output", split = FALSE)
[16:04:49.830]         if (TRUE) {
[16:04:49.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.830]         }
[16:04:49.830]         else {
[16:04:49.830]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.830]         }
[16:04:49.830]         base::close(...future.stdout)
[16:04:49.830]         ...future.stdout <- NULL
[16:04:49.830]     }
[16:04:49.830]     ...future.result$conditions <- ...future.conditions
[16:04:49.830]     ...future.result$finished <- base::Sys.time()
[16:04:49.830]     ...future.result
[16:04:49.830] }
[16:04:49.833] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:04:49.833] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:04:49.834] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:04:49.834] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:04:49.834] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:04:49.834] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:04:49.835] MultisessionFuture started
[16:04:49.835] - Launch lazy future ... done
[16:04:49.835] run() for ‘MultisessionFuture’ ... done
[16:04:49.835] result() for ClusterFuture ...
[16:04:49.836] receiveMessageFromWorker() for ClusterFuture ...
[16:04:49.836] - Validating connection of MultisessionFuture
[16:04:49.885] - received message: FutureResult
[16:04:49.885] - Received FutureResult
[16:04:49.885] - Erased future from FutureRegistry
[16:04:49.885] result() for ClusterFuture ...
[16:04:49.885] - result already collected: FutureResult
[16:04:49.885] result() for ClusterFuture ... done
[16:04:49.885] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:49.886] result() for ClusterFuture ... done
[16:04:49.886] result() for ClusterFuture ...
[16:04:49.886] - result already collected: FutureResult
[16:04:49.886] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:49.888] getGlobalsAndPackages() ...
[16:04:49.888] Searching for globals...
[16:04:49.890] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:49.890] Searching for globals ... DONE
[16:04:49.890] Resolving globals: FALSE
[16:04:49.891] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:49.892] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:49.892] - globals: [2] ‘weight’, ‘group’
[16:04:49.892] - packages: [1] ‘stats’
[16:04:49.892] getGlobalsAndPackages() ... DONE
[16:04:49.892] run() for ‘Future’ ...
[16:04:49.892] - state: ‘created’
[16:04:49.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.907] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:49.907]   - Field: ‘node’
[16:04:49.907]   - Field: ‘label’
[16:04:49.907]   - Field: ‘local’
[16:04:49.907]   - Field: ‘owner’
[16:04:49.908]   - Field: ‘envir’
[16:04:49.908]   - Field: ‘workers’
[16:04:49.908]   - Field: ‘packages’
[16:04:49.908]   - Field: ‘gc’
[16:04:49.908]   - Field: ‘conditions’
[16:04:49.908]   - Field: ‘persistent’
[16:04:49.908]   - Field: ‘expr’
[16:04:49.908]   - Field: ‘uuid’
[16:04:49.908]   - Field: ‘seed’
[16:04:49.909]   - Field: ‘version’
[16:04:49.909]   - Field: ‘result’
[16:04:49.909]   - Field: ‘asynchronous’
[16:04:49.909]   - Field: ‘calls’
[16:04:49.909]   - Field: ‘globals’
[16:04:49.909]   - Field: ‘stdout’
[16:04:49.909]   - Field: ‘earlySignal’
[16:04:49.909]   - Field: ‘lazy’
[16:04:49.909]   - Field: ‘state’
[16:04:49.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:49.910] - Launch lazy future ...
[16:04:49.910] Packages needed by the future expression (n = 1): ‘stats’
[16:04:49.910] Packages needed by future strategies (n = 0): <none>
[16:04:49.911] {
[16:04:49.911]     {
[16:04:49.911]         {
[16:04:49.911]             ...future.startTime <- base::Sys.time()
[16:04:49.911]             {
[16:04:49.911]                 {
[16:04:49.911]                   {
[16:04:49.911]                     {
[16:04:49.911]                       {
[16:04:49.911]                         base::local({
[16:04:49.911]                           has_future <- base::requireNamespace("future", 
[16:04:49.911]                             quietly = TRUE)
[16:04:49.911]                           if (has_future) {
[16:04:49.911]                             ns <- base::getNamespace("future")
[16:04:49.911]                             version <- ns[[".package"]][["version"]]
[16:04:49.911]                             if (is.null(version)) 
[16:04:49.911]                               version <- utils::packageVersion("future")
[16:04:49.911]                           }
[16:04:49.911]                           else {
[16:04:49.911]                             version <- NULL
[16:04:49.911]                           }
[16:04:49.911]                           if (!has_future || version < "1.8.0") {
[16:04:49.911]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.911]                               "", base::R.version$version.string), 
[16:04:49.911]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:49.911]                                 base::R.version$platform, 8 * 
[16:04:49.911]                                   base::.Machine$sizeof.pointer), 
[16:04:49.911]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.911]                                 "release", "version")], collapse = " "), 
[16:04:49.911]                               hostname = base::Sys.info()[["nodename"]])
[16:04:49.911]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.911]                               info)
[16:04:49.911]                             info <- base::paste(info, collapse = "; ")
[16:04:49.911]                             if (!has_future) {
[16:04:49.911]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.911]                                 info)
[16:04:49.911]                             }
[16:04:49.911]                             else {
[16:04:49.911]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.911]                                 info, version)
[16:04:49.911]                             }
[16:04:49.911]                             base::stop(msg)
[16:04:49.911]                           }
[16:04:49.911]                         })
[16:04:49.911]                       }
[16:04:49.911]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.911]                       base::options(mc.cores = 1L)
[16:04:49.911]                     }
[16:04:49.911]                     base::local({
[16:04:49.911]                       for (pkg in "stats") {
[16:04:49.911]                         base::loadNamespace(pkg)
[16:04:49.911]                         base::library(pkg, character.only = TRUE)
[16:04:49.911]                       }
[16:04:49.911]                     })
[16:04:49.911]                   }
[16:04:49.911]                   options(future.plan = NULL)
[16:04:49.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.911]                 }
[16:04:49.911]                 ...future.workdir <- getwd()
[16:04:49.911]             }
[16:04:49.911]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.911]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.911]         }
[16:04:49.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.911]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.911]             base::names(...future.oldOptions))
[16:04:49.911]     }
[16:04:49.911]     if (FALSE) {
[16:04:49.911]     }
[16:04:49.911]     else {
[16:04:49.911]         if (TRUE) {
[16:04:49.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.911]                 open = "w")
[16:04:49.911]         }
[16:04:49.911]         else {
[16:04:49.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.911]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.911]         }
[16:04:49.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.911]             base::sink(type = "output", split = FALSE)
[16:04:49.911]             base::close(...future.stdout)
[16:04:49.911]         }, add = TRUE)
[16:04:49.911]     }
[16:04:49.911]     ...future.frame <- base::sys.nframe()
[16:04:49.911]     ...future.conditions <- base::list()
[16:04:49.911]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.911]     if (FALSE) {
[16:04:49.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.911]     }
[16:04:49.911]     ...future.result <- base::tryCatch({
[16:04:49.911]         base::withCallingHandlers({
[16:04:49.911]             ...future.value <- base::withVisible(base::local({
[16:04:49.911]                 ...future.makeSendCondition <- base::local({
[16:04:49.911]                   sendCondition <- NULL
[16:04:49.911]                   function(frame = 1L) {
[16:04:49.911]                     if (is.function(sendCondition)) 
[16:04:49.911]                       return(sendCondition)
[16:04:49.911]                     ns <- getNamespace("parallel")
[16:04:49.911]                     if (exists("sendData", mode = "function", 
[16:04:49.911]                       envir = ns)) {
[16:04:49.911]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:49.911]                         envir = ns)
[16:04:49.911]                       envir <- sys.frame(frame)
[16:04:49.911]                       master <- NULL
[16:04:49.911]                       while (!identical(envir, .GlobalEnv) && 
[16:04:49.911]                         !identical(envir, emptyenv())) {
[16:04:49.911]                         if (exists("master", mode = "list", envir = envir, 
[16:04:49.911]                           inherits = FALSE)) {
[16:04:49.911]                           master <- get("master", mode = "list", 
[16:04:49.911]                             envir = envir, inherits = FALSE)
[16:04:49.911]                           if (inherits(master, c("SOCKnode", 
[16:04:49.911]                             "SOCK0node"))) {
[16:04:49.911]                             sendCondition <<- function(cond) {
[16:04:49.911]                               data <- list(type = "VALUE", value = cond, 
[16:04:49.911]                                 success = TRUE)
[16:04:49.911]                               parallel_sendData(master, data)
[16:04:49.911]                             }
[16:04:49.911]                             return(sendCondition)
[16:04:49.911]                           }
[16:04:49.911]                         }
[16:04:49.911]                         frame <- frame + 1L
[16:04:49.911]                         envir <- sys.frame(frame)
[16:04:49.911]                       }
[16:04:49.911]                     }
[16:04:49.911]                     sendCondition <<- function(cond) NULL
[16:04:49.911]                   }
[16:04:49.911]                 })
[16:04:49.911]                 withCallingHandlers({
[16:04:49.911]                   {
[16:04:49.911]                     lm(weight ~ group - 1)
[16:04:49.911]                   }
[16:04:49.911]                 }, immediateCondition = function(cond) {
[16:04:49.911]                   sendCondition <- ...future.makeSendCondition()
[16:04:49.911]                   sendCondition(cond)
[16:04:49.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.911]                   {
[16:04:49.911]                     inherits <- base::inherits
[16:04:49.911]                     invokeRestart <- base::invokeRestart
[16:04:49.911]                     is.null <- base::is.null
[16:04:49.911]                     muffled <- FALSE
[16:04:49.911]                     if (inherits(cond, "message")) {
[16:04:49.911]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.911]                       if (muffled) 
[16:04:49.911]                         invokeRestart("muffleMessage")
[16:04:49.911]                     }
[16:04:49.911]                     else if (inherits(cond, "warning")) {
[16:04:49.911]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.911]                       if (muffled) 
[16:04:49.911]                         invokeRestart("muffleWarning")
[16:04:49.911]                     }
[16:04:49.911]                     else if (inherits(cond, "condition")) {
[16:04:49.911]                       if (!is.null(pattern)) {
[16:04:49.911]                         computeRestarts <- base::computeRestarts
[16:04:49.911]                         grepl <- base::grepl
[16:04:49.911]                         restarts <- computeRestarts(cond)
[16:04:49.911]                         for (restart in restarts) {
[16:04:49.911]                           name <- restart$name
[16:04:49.911]                           if (is.null(name)) 
[16:04:49.911]                             next
[16:04:49.911]                           if (!grepl(pattern, name)) 
[16:04:49.911]                             next
[16:04:49.911]                           invokeRestart(restart)
[16:04:49.911]                           muffled <- TRUE
[16:04:49.911]                           break
[16:04:49.911]                         }
[16:04:49.911]                       }
[16:04:49.911]                     }
[16:04:49.911]                     invisible(muffled)
[16:04:49.911]                   }
[16:04:49.911]                   muffleCondition(cond)
[16:04:49.911]                 })
[16:04:49.911]             }))
[16:04:49.911]             future::FutureResult(value = ...future.value$value, 
[16:04:49.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.911]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.911]                     ...future.globalenv.names))
[16:04:49.911]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.911]         }, condition = base::local({
[16:04:49.911]             c <- base::c
[16:04:49.911]             inherits <- base::inherits
[16:04:49.911]             invokeRestart <- base::invokeRestart
[16:04:49.911]             length <- base::length
[16:04:49.911]             list <- base::list
[16:04:49.911]             seq.int <- base::seq.int
[16:04:49.911]             signalCondition <- base::signalCondition
[16:04:49.911]             sys.calls <- base::sys.calls
[16:04:49.911]             `[[` <- base::`[[`
[16:04:49.911]             `+` <- base::`+`
[16:04:49.911]             `<<-` <- base::`<<-`
[16:04:49.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.911]                   3L)]
[16:04:49.911]             }
[16:04:49.911]             function(cond) {
[16:04:49.911]                 is_error <- inherits(cond, "error")
[16:04:49.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.911]                   NULL)
[16:04:49.911]                 if (is_error) {
[16:04:49.911]                   sessionInformation <- function() {
[16:04:49.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.911]                       search = base::search(), system = base::Sys.info())
[16:04:49.911]                   }
[16:04:49.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.911]                     cond$call), session = sessionInformation(), 
[16:04:49.911]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.911]                   signalCondition(cond)
[16:04:49.911]                 }
[16:04:49.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.911]                 "immediateCondition"))) {
[16:04:49.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.911]                   if (TRUE && !signal) {
[16:04:49.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.911]                     {
[16:04:49.911]                       inherits <- base::inherits
[16:04:49.911]                       invokeRestart <- base::invokeRestart
[16:04:49.911]                       is.null <- base::is.null
[16:04:49.911]                       muffled <- FALSE
[16:04:49.911]                       if (inherits(cond, "message")) {
[16:04:49.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.911]                         if (muffled) 
[16:04:49.911]                           invokeRestart("muffleMessage")
[16:04:49.911]                       }
[16:04:49.911]                       else if (inherits(cond, "warning")) {
[16:04:49.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.911]                         if (muffled) 
[16:04:49.911]                           invokeRestart("muffleWarning")
[16:04:49.911]                       }
[16:04:49.911]                       else if (inherits(cond, "condition")) {
[16:04:49.911]                         if (!is.null(pattern)) {
[16:04:49.911]                           computeRestarts <- base::computeRestarts
[16:04:49.911]                           grepl <- base::grepl
[16:04:49.911]                           restarts <- computeRestarts(cond)
[16:04:49.911]                           for (restart in restarts) {
[16:04:49.911]                             name <- restart$name
[16:04:49.911]                             if (is.null(name)) 
[16:04:49.911]                               next
[16:04:49.911]                             if (!grepl(pattern, name)) 
[16:04:49.911]                               next
[16:04:49.911]                             invokeRestart(restart)
[16:04:49.911]                             muffled <- TRUE
[16:04:49.911]                             break
[16:04:49.911]                           }
[16:04:49.911]                         }
[16:04:49.911]                       }
[16:04:49.911]                       invisible(muffled)
[16:04:49.911]                     }
[16:04:49.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.911]                   }
[16:04:49.911]                 }
[16:04:49.911]                 else {
[16:04:49.911]                   if (TRUE) {
[16:04:49.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.911]                     {
[16:04:49.911]                       inherits <- base::inherits
[16:04:49.911]                       invokeRestart <- base::invokeRestart
[16:04:49.911]                       is.null <- base::is.null
[16:04:49.911]                       muffled <- FALSE
[16:04:49.911]                       if (inherits(cond, "message")) {
[16:04:49.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.911]                         if (muffled) 
[16:04:49.911]                           invokeRestart("muffleMessage")
[16:04:49.911]                       }
[16:04:49.911]                       else if (inherits(cond, "warning")) {
[16:04:49.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.911]                         if (muffled) 
[16:04:49.911]                           invokeRestart("muffleWarning")
[16:04:49.911]                       }
[16:04:49.911]                       else if (inherits(cond, "condition")) {
[16:04:49.911]                         if (!is.null(pattern)) {
[16:04:49.911]                           computeRestarts <- base::computeRestarts
[16:04:49.911]                           grepl <- base::grepl
[16:04:49.911]                           restarts <- computeRestarts(cond)
[16:04:49.911]                           for (restart in restarts) {
[16:04:49.911]                             name <- restart$name
[16:04:49.911]                             if (is.null(name)) 
[16:04:49.911]                               next
[16:04:49.911]                             if (!grepl(pattern, name)) 
[16:04:49.911]                               next
[16:04:49.911]                             invokeRestart(restart)
[16:04:49.911]                             muffled <- TRUE
[16:04:49.911]                             break
[16:04:49.911]                           }
[16:04:49.911]                         }
[16:04:49.911]                       }
[16:04:49.911]                       invisible(muffled)
[16:04:49.911]                     }
[16:04:49.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.911]                   }
[16:04:49.911]                 }
[16:04:49.911]             }
[16:04:49.911]         }))
[16:04:49.911]     }, error = function(ex) {
[16:04:49.911]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.911]                 ...future.rng), started = ...future.startTime, 
[16:04:49.911]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.911]             version = "1.8"), class = "FutureResult")
[16:04:49.911]     }, finally = {
[16:04:49.911]         if (!identical(...future.workdir, getwd())) 
[16:04:49.911]             setwd(...future.workdir)
[16:04:49.911]         {
[16:04:49.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.911]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.911]             }
[16:04:49.911]             base::options(...future.oldOptions)
[16:04:49.911]             if (.Platform$OS.type == "windows") {
[16:04:49.911]                 old_names <- names(...future.oldEnvVars)
[16:04:49.911]                 envs <- base::Sys.getenv()
[16:04:49.911]                 names <- names(envs)
[16:04:49.911]                 common <- intersect(names, old_names)
[16:04:49.911]                 added <- setdiff(names, old_names)
[16:04:49.911]                 removed <- setdiff(old_names, names)
[16:04:49.911]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.911]                   envs[common]]
[16:04:49.911]                 NAMES <- toupper(changed)
[16:04:49.911]                 args <- list()
[16:04:49.911]                 for (kk in seq_along(NAMES)) {
[16:04:49.911]                   name <- changed[[kk]]
[16:04:49.911]                   NAME <- NAMES[[kk]]
[16:04:49.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.911]                     next
[16:04:49.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.911]                 }
[16:04:49.911]                 NAMES <- toupper(added)
[16:04:49.911]                 for (kk in seq_along(NAMES)) {
[16:04:49.911]                   name <- added[[kk]]
[16:04:49.911]                   NAME <- NAMES[[kk]]
[16:04:49.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.911]                     next
[16:04:49.911]                   args[[name]] <- ""
[16:04:49.911]                 }
[16:04:49.911]                 NAMES <- toupper(removed)
[16:04:49.911]                 for (kk in seq_along(NAMES)) {
[16:04:49.911]                   name <- removed[[kk]]
[16:04:49.911]                   NAME <- NAMES[[kk]]
[16:04:49.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.911]                     next
[16:04:49.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.911]                 }
[16:04:49.911]                 if (length(args) > 0) 
[16:04:49.911]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.911]             }
[16:04:49.911]             else {
[16:04:49.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.911]             }
[16:04:49.911]             {
[16:04:49.911]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.911]                   0L) {
[16:04:49.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.911]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.911]                   base::options(opts)
[16:04:49.911]                 }
[16:04:49.911]                 {
[16:04:49.911]                   {
[16:04:49.911]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.911]                     NULL
[16:04:49.911]                   }
[16:04:49.911]                   options(future.plan = NULL)
[16:04:49.911]                   if (is.na(NA_character_)) 
[16:04:49.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.911]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:49.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:49.911]                     envir = parent.frame()) 
[16:04:49.911]                   {
[16:04:49.911]                     if (is.function(workers)) 
[16:04:49.911]                       workers <- workers()
[16:04:49.911]                     workers <- structure(as.integer(workers), 
[16:04:49.911]                       class = class(workers))
[16:04:49.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:49.911]                       workers >= 1)
[16:04:49.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:49.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:49.911]                     }
[16:04:49.911]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:49.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:49.911]                       envir = envir)
[16:04:49.911]                     if (!future$lazy) 
[16:04:49.911]                       future <- run(future)
[16:04:49.911]                     invisible(future)
[16:04:49.911]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.911]                 }
[16:04:49.911]             }
[16:04:49.911]         }
[16:04:49.911]     })
[16:04:49.911]     if (TRUE) {
[16:04:49.911]         base::sink(type = "output", split = FALSE)
[16:04:49.911]         if (TRUE) {
[16:04:49.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.911]         }
[16:04:49.911]         else {
[16:04:49.911]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.911]         }
[16:04:49.911]         base::close(...future.stdout)
[16:04:49.911]         ...future.stdout <- NULL
[16:04:49.911]     }
[16:04:49.911]     ...future.result$conditions <- ...future.conditions
[16:04:49.911]     ...future.result$finished <- base::Sys.time()
[16:04:49.911]     ...future.result
[16:04:49.911] }
[16:04:49.914] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:04:49.914] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:04:49.914] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:04:49.915] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:04:49.917] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:04:49.917] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:04:49.918] MultisessionFuture started
[16:04:49.918] - Launch lazy future ... done
[16:04:49.918] run() for ‘MultisessionFuture’ ... done
[16:04:49.918] result() for ClusterFuture ...
[16:04:49.918] receiveMessageFromWorker() for ClusterFuture ...
[16:04:49.918] - Validating connection of MultisessionFuture
[16:04:49.965] - received message: FutureResult
[16:04:49.965] - Received FutureResult
[16:04:49.965] - Erased future from FutureRegistry
[16:04:49.966] result() for ClusterFuture ...
[16:04:49.966] - result already collected: FutureResult
[16:04:49.966] result() for ClusterFuture ... done
[16:04:49.966] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:49.966] result() for ClusterFuture ... done
[16:04:49.966] result() for ClusterFuture ...
[16:04:49.966] - result already collected: FutureResult
[16:04:49.966] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:49.968] getGlobalsAndPackages() ...
[16:04:49.968] Searching for globals...
[16:04:49.970] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:49.970] Searching for globals ... DONE
[16:04:49.970] Resolving globals: FALSE
[16:04:49.970] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:49.971] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:49.971] - globals: [2] ‘weight’, ‘group’
[16:04:49.971] - packages: [1] ‘stats’
[16:04:49.971] getGlobalsAndPackages() ... DONE
[16:04:49.972] run() for ‘Future’ ...
[16:04:49.972] - state: ‘created’
[16:04:49.972] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:49.985] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:49.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:49.986]   - Field: ‘node’
[16:04:49.986]   - Field: ‘label’
[16:04:49.986]   - Field: ‘local’
[16:04:49.986]   - Field: ‘owner’
[16:04:49.986]   - Field: ‘envir’
[16:04:49.986]   - Field: ‘workers’
[16:04:49.986]   - Field: ‘packages’
[16:04:49.986]   - Field: ‘gc’
[16:04:49.986]   - Field: ‘conditions’
[16:04:49.987]   - Field: ‘persistent’
[16:04:49.987]   - Field: ‘expr’
[16:04:49.987]   - Field: ‘uuid’
[16:04:49.987]   - Field: ‘seed’
[16:04:49.987]   - Field: ‘version’
[16:04:49.987]   - Field: ‘result’
[16:04:49.987]   - Field: ‘asynchronous’
[16:04:49.987]   - Field: ‘calls’
[16:04:49.987]   - Field: ‘globals’
[16:04:49.987]   - Field: ‘stdout’
[16:04:49.988]   - Field: ‘earlySignal’
[16:04:49.988]   - Field: ‘lazy’
[16:04:49.988]   - Field: ‘state’
[16:04:49.988] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:49.988] - Launch lazy future ...
[16:04:49.988] Packages needed by the future expression (n = 1): ‘stats’
[16:04:49.988] Packages needed by future strategies (n = 0): <none>
[16:04:49.989] {
[16:04:49.989]     {
[16:04:49.989]         {
[16:04:49.989]             ...future.startTime <- base::Sys.time()
[16:04:49.989]             {
[16:04:49.989]                 {
[16:04:49.989]                   {
[16:04:49.989]                     {
[16:04:49.989]                       {
[16:04:49.989]                         base::local({
[16:04:49.989]                           has_future <- base::requireNamespace("future", 
[16:04:49.989]                             quietly = TRUE)
[16:04:49.989]                           if (has_future) {
[16:04:49.989]                             ns <- base::getNamespace("future")
[16:04:49.989]                             version <- ns[[".package"]][["version"]]
[16:04:49.989]                             if (is.null(version)) 
[16:04:49.989]                               version <- utils::packageVersion("future")
[16:04:49.989]                           }
[16:04:49.989]                           else {
[16:04:49.989]                             version <- NULL
[16:04:49.989]                           }
[16:04:49.989]                           if (!has_future || version < "1.8.0") {
[16:04:49.989]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:49.989]                               "", base::R.version$version.string), 
[16:04:49.989]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:49.989]                                 base::R.version$platform, 8 * 
[16:04:49.989]                                   base::.Machine$sizeof.pointer), 
[16:04:49.989]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:49.989]                                 "release", "version")], collapse = " "), 
[16:04:49.989]                               hostname = base::Sys.info()[["nodename"]])
[16:04:49.989]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:49.989]                               info)
[16:04:49.989]                             info <- base::paste(info, collapse = "; ")
[16:04:49.989]                             if (!has_future) {
[16:04:49.989]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:49.989]                                 info)
[16:04:49.989]                             }
[16:04:49.989]                             else {
[16:04:49.989]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:49.989]                                 info, version)
[16:04:49.989]                             }
[16:04:49.989]                             base::stop(msg)
[16:04:49.989]                           }
[16:04:49.989]                         })
[16:04:49.989]                       }
[16:04:49.989]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:49.989]                       base::options(mc.cores = 1L)
[16:04:49.989]                     }
[16:04:49.989]                     base::local({
[16:04:49.989]                       for (pkg in "stats") {
[16:04:49.989]                         base::loadNamespace(pkg)
[16:04:49.989]                         base::library(pkg, character.only = TRUE)
[16:04:49.989]                       }
[16:04:49.989]                     })
[16:04:49.989]                   }
[16:04:49.989]                   options(future.plan = NULL)
[16:04:49.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:49.989]                 }
[16:04:49.989]                 ...future.workdir <- getwd()
[16:04:49.989]             }
[16:04:49.989]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:49.989]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:49.989]         }
[16:04:49.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:49.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:49.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:49.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:49.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:49.989]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:49.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:49.989]             base::names(...future.oldOptions))
[16:04:49.989]     }
[16:04:49.989]     if (FALSE) {
[16:04:49.989]     }
[16:04:49.989]     else {
[16:04:49.989]         if (TRUE) {
[16:04:49.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:49.989]                 open = "w")
[16:04:49.989]         }
[16:04:49.989]         else {
[16:04:49.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:49.989]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:49.989]         }
[16:04:49.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:49.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:49.989]             base::sink(type = "output", split = FALSE)
[16:04:49.989]             base::close(...future.stdout)
[16:04:49.989]         }, add = TRUE)
[16:04:49.989]     }
[16:04:49.989]     ...future.frame <- base::sys.nframe()
[16:04:49.989]     ...future.conditions <- base::list()
[16:04:49.989]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:49.989]     if (FALSE) {
[16:04:49.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:49.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:49.989]     }
[16:04:49.989]     ...future.result <- base::tryCatch({
[16:04:49.989]         base::withCallingHandlers({
[16:04:49.989]             ...future.value <- base::withVisible(base::local({
[16:04:49.989]                 ...future.makeSendCondition <- base::local({
[16:04:49.989]                   sendCondition <- NULL
[16:04:49.989]                   function(frame = 1L) {
[16:04:49.989]                     if (is.function(sendCondition)) 
[16:04:49.989]                       return(sendCondition)
[16:04:49.989]                     ns <- getNamespace("parallel")
[16:04:49.989]                     if (exists("sendData", mode = "function", 
[16:04:49.989]                       envir = ns)) {
[16:04:49.989]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:49.989]                         envir = ns)
[16:04:49.989]                       envir <- sys.frame(frame)
[16:04:49.989]                       master <- NULL
[16:04:49.989]                       while (!identical(envir, .GlobalEnv) && 
[16:04:49.989]                         !identical(envir, emptyenv())) {
[16:04:49.989]                         if (exists("master", mode = "list", envir = envir, 
[16:04:49.989]                           inherits = FALSE)) {
[16:04:49.989]                           master <- get("master", mode = "list", 
[16:04:49.989]                             envir = envir, inherits = FALSE)
[16:04:49.989]                           if (inherits(master, c("SOCKnode", 
[16:04:49.989]                             "SOCK0node"))) {
[16:04:49.989]                             sendCondition <<- function(cond) {
[16:04:49.989]                               data <- list(type = "VALUE", value = cond, 
[16:04:49.989]                                 success = TRUE)
[16:04:49.989]                               parallel_sendData(master, data)
[16:04:49.989]                             }
[16:04:49.989]                             return(sendCondition)
[16:04:49.989]                           }
[16:04:49.989]                         }
[16:04:49.989]                         frame <- frame + 1L
[16:04:49.989]                         envir <- sys.frame(frame)
[16:04:49.989]                       }
[16:04:49.989]                     }
[16:04:49.989]                     sendCondition <<- function(cond) NULL
[16:04:49.989]                   }
[16:04:49.989]                 })
[16:04:49.989]                 withCallingHandlers({
[16:04:49.989]                   {
[16:04:49.989]                     lm(weight ~ group - 1)
[16:04:49.989]                   }
[16:04:49.989]                 }, immediateCondition = function(cond) {
[16:04:49.989]                   sendCondition <- ...future.makeSendCondition()
[16:04:49.989]                   sendCondition(cond)
[16:04:49.989]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.989]                   {
[16:04:49.989]                     inherits <- base::inherits
[16:04:49.989]                     invokeRestart <- base::invokeRestart
[16:04:49.989]                     is.null <- base::is.null
[16:04:49.989]                     muffled <- FALSE
[16:04:49.989]                     if (inherits(cond, "message")) {
[16:04:49.989]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:49.989]                       if (muffled) 
[16:04:49.989]                         invokeRestart("muffleMessage")
[16:04:49.989]                     }
[16:04:49.989]                     else if (inherits(cond, "warning")) {
[16:04:49.989]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:49.989]                       if (muffled) 
[16:04:49.989]                         invokeRestart("muffleWarning")
[16:04:49.989]                     }
[16:04:49.989]                     else if (inherits(cond, "condition")) {
[16:04:49.989]                       if (!is.null(pattern)) {
[16:04:49.989]                         computeRestarts <- base::computeRestarts
[16:04:49.989]                         grepl <- base::grepl
[16:04:49.989]                         restarts <- computeRestarts(cond)
[16:04:49.989]                         for (restart in restarts) {
[16:04:49.989]                           name <- restart$name
[16:04:49.989]                           if (is.null(name)) 
[16:04:49.989]                             next
[16:04:49.989]                           if (!grepl(pattern, name)) 
[16:04:49.989]                             next
[16:04:49.989]                           invokeRestart(restart)
[16:04:49.989]                           muffled <- TRUE
[16:04:49.989]                           break
[16:04:49.989]                         }
[16:04:49.989]                       }
[16:04:49.989]                     }
[16:04:49.989]                     invisible(muffled)
[16:04:49.989]                   }
[16:04:49.989]                   muffleCondition(cond)
[16:04:49.989]                 })
[16:04:49.989]             }))
[16:04:49.989]             future::FutureResult(value = ...future.value$value, 
[16:04:49.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.989]                   ...future.rng), globalenv = if (FALSE) 
[16:04:49.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:49.989]                     ...future.globalenv.names))
[16:04:49.989]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:49.989]         }, condition = base::local({
[16:04:49.989]             c <- base::c
[16:04:49.989]             inherits <- base::inherits
[16:04:49.989]             invokeRestart <- base::invokeRestart
[16:04:49.989]             length <- base::length
[16:04:49.989]             list <- base::list
[16:04:49.989]             seq.int <- base::seq.int
[16:04:49.989]             signalCondition <- base::signalCondition
[16:04:49.989]             sys.calls <- base::sys.calls
[16:04:49.989]             `[[` <- base::`[[`
[16:04:49.989]             `+` <- base::`+`
[16:04:49.989]             `<<-` <- base::`<<-`
[16:04:49.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:49.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:49.989]                   3L)]
[16:04:49.989]             }
[16:04:49.989]             function(cond) {
[16:04:49.989]                 is_error <- inherits(cond, "error")
[16:04:49.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:49.989]                   NULL)
[16:04:49.989]                 if (is_error) {
[16:04:49.989]                   sessionInformation <- function() {
[16:04:49.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:49.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:49.989]                       search = base::search(), system = base::Sys.info())
[16:04:49.989]                   }
[16:04:49.989]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:49.989]                     cond$call), session = sessionInformation(), 
[16:04:49.989]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:49.989]                   signalCondition(cond)
[16:04:49.989]                 }
[16:04:49.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:49.989]                 "immediateCondition"))) {
[16:04:49.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:49.989]                   ...future.conditions[[length(...future.conditions) + 
[16:04:49.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:49.989]                   if (TRUE && !signal) {
[16:04:49.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.989]                     {
[16:04:49.989]                       inherits <- base::inherits
[16:04:49.989]                       invokeRestart <- base::invokeRestart
[16:04:49.989]                       is.null <- base::is.null
[16:04:49.989]                       muffled <- FALSE
[16:04:49.989]                       if (inherits(cond, "message")) {
[16:04:49.989]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.989]                         if (muffled) 
[16:04:49.989]                           invokeRestart("muffleMessage")
[16:04:49.989]                       }
[16:04:49.989]                       else if (inherits(cond, "warning")) {
[16:04:49.989]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.989]                         if (muffled) 
[16:04:49.989]                           invokeRestart("muffleWarning")
[16:04:49.989]                       }
[16:04:49.989]                       else if (inherits(cond, "condition")) {
[16:04:49.989]                         if (!is.null(pattern)) {
[16:04:49.989]                           computeRestarts <- base::computeRestarts
[16:04:49.989]                           grepl <- base::grepl
[16:04:49.989]                           restarts <- computeRestarts(cond)
[16:04:49.989]                           for (restart in restarts) {
[16:04:49.989]                             name <- restart$name
[16:04:49.989]                             if (is.null(name)) 
[16:04:49.989]                               next
[16:04:49.989]                             if (!grepl(pattern, name)) 
[16:04:49.989]                               next
[16:04:49.989]                             invokeRestart(restart)
[16:04:49.989]                             muffled <- TRUE
[16:04:49.989]                             break
[16:04:49.989]                           }
[16:04:49.989]                         }
[16:04:49.989]                       }
[16:04:49.989]                       invisible(muffled)
[16:04:49.989]                     }
[16:04:49.989]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.989]                   }
[16:04:49.989]                 }
[16:04:49.989]                 else {
[16:04:49.989]                   if (TRUE) {
[16:04:49.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:49.989]                     {
[16:04:49.989]                       inherits <- base::inherits
[16:04:49.989]                       invokeRestart <- base::invokeRestart
[16:04:49.989]                       is.null <- base::is.null
[16:04:49.989]                       muffled <- FALSE
[16:04:49.989]                       if (inherits(cond, "message")) {
[16:04:49.989]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:49.989]                         if (muffled) 
[16:04:49.989]                           invokeRestart("muffleMessage")
[16:04:49.989]                       }
[16:04:49.989]                       else if (inherits(cond, "warning")) {
[16:04:49.989]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:49.989]                         if (muffled) 
[16:04:49.989]                           invokeRestart("muffleWarning")
[16:04:49.989]                       }
[16:04:49.989]                       else if (inherits(cond, "condition")) {
[16:04:49.989]                         if (!is.null(pattern)) {
[16:04:49.989]                           computeRestarts <- base::computeRestarts
[16:04:49.989]                           grepl <- base::grepl
[16:04:49.989]                           restarts <- computeRestarts(cond)
[16:04:49.989]                           for (restart in restarts) {
[16:04:49.989]                             name <- restart$name
[16:04:49.989]                             if (is.null(name)) 
[16:04:49.989]                               next
[16:04:49.989]                             if (!grepl(pattern, name)) 
[16:04:49.989]                               next
[16:04:49.989]                             invokeRestart(restart)
[16:04:49.989]                             muffled <- TRUE
[16:04:49.989]                             break
[16:04:49.989]                           }
[16:04:49.989]                         }
[16:04:49.989]                       }
[16:04:49.989]                       invisible(muffled)
[16:04:49.989]                     }
[16:04:49.989]                     muffleCondition(cond, pattern = "^muffle")
[16:04:49.989]                   }
[16:04:49.989]                 }
[16:04:49.989]             }
[16:04:49.989]         }))
[16:04:49.989]     }, error = function(ex) {
[16:04:49.989]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:49.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:49.989]                 ...future.rng), started = ...future.startTime, 
[16:04:49.989]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:49.989]             version = "1.8"), class = "FutureResult")
[16:04:49.989]     }, finally = {
[16:04:49.989]         if (!identical(...future.workdir, getwd())) 
[16:04:49.989]             setwd(...future.workdir)
[16:04:49.989]         {
[16:04:49.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:49.989]                 ...future.oldOptions$nwarnings <- NULL
[16:04:49.989]             }
[16:04:49.989]             base::options(...future.oldOptions)
[16:04:49.989]             if (.Platform$OS.type == "windows") {
[16:04:49.989]                 old_names <- names(...future.oldEnvVars)
[16:04:49.989]                 envs <- base::Sys.getenv()
[16:04:49.989]                 names <- names(envs)
[16:04:49.989]                 common <- intersect(names, old_names)
[16:04:49.989]                 added <- setdiff(names, old_names)
[16:04:49.989]                 removed <- setdiff(old_names, names)
[16:04:49.989]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:49.989]                   envs[common]]
[16:04:49.989]                 NAMES <- toupper(changed)
[16:04:49.989]                 args <- list()
[16:04:49.989]                 for (kk in seq_along(NAMES)) {
[16:04:49.989]                   name <- changed[[kk]]
[16:04:49.989]                   NAME <- NAMES[[kk]]
[16:04:49.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.989]                     next
[16:04:49.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.989]                 }
[16:04:49.989]                 NAMES <- toupper(added)
[16:04:49.989]                 for (kk in seq_along(NAMES)) {
[16:04:49.989]                   name <- added[[kk]]
[16:04:49.989]                   NAME <- NAMES[[kk]]
[16:04:49.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.989]                     next
[16:04:49.989]                   args[[name]] <- ""
[16:04:49.989]                 }
[16:04:49.989]                 NAMES <- toupper(removed)
[16:04:49.989]                 for (kk in seq_along(NAMES)) {
[16:04:49.989]                   name <- removed[[kk]]
[16:04:49.989]                   NAME <- NAMES[[kk]]
[16:04:49.989]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:49.989]                     next
[16:04:49.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:49.989]                 }
[16:04:49.989]                 if (length(args) > 0) 
[16:04:49.989]                   base::do.call(base::Sys.setenv, args = args)
[16:04:49.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:49.989]             }
[16:04:49.989]             else {
[16:04:49.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:49.989]             }
[16:04:49.989]             {
[16:04:49.989]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:49.989]                   0L) {
[16:04:49.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:49.989]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:49.989]                   base::options(opts)
[16:04:49.989]                 }
[16:04:49.989]                 {
[16:04:49.989]                   {
[16:04:49.989]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:49.989]                     NULL
[16:04:49.989]                   }
[16:04:49.989]                   options(future.plan = NULL)
[16:04:49.989]                   if (is.na(NA_character_)) 
[16:04:49.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:49.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:49.989]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:49.989]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:49.989]                     envir = parent.frame()) 
[16:04:49.989]                   {
[16:04:49.989]                     if (is.function(workers)) 
[16:04:49.989]                       workers <- workers()
[16:04:49.989]                     workers <- structure(as.integer(workers), 
[16:04:49.989]                       class = class(workers))
[16:04:49.989]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:49.989]                       workers >= 1)
[16:04:49.989]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:49.989]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:49.989]                     }
[16:04:49.989]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:49.989]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:49.989]                       envir = envir)
[16:04:49.989]                     if (!future$lazy) 
[16:04:49.989]                       future <- run(future)
[16:04:49.989]                     invisible(future)
[16:04:49.989]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:49.989]                 }
[16:04:49.989]             }
[16:04:49.989]         }
[16:04:49.989]     })
[16:04:49.989]     if (TRUE) {
[16:04:49.989]         base::sink(type = "output", split = FALSE)
[16:04:49.989]         if (TRUE) {
[16:04:49.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:49.989]         }
[16:04:49.989]         else {
[16:04:49.989]             ...future.result["stdout"] <- base::list(NULL)
[16:04:49.989]         }
[16:04:49.989]         base::close(...future.stdout)
[16:04:49.989]         ...future.stdout <- NULL
[16:04:49.989]     }
[16:04:49.989]     ...future.result$conditions <- ...future.conditions
[16:04:49.989]     ...future.result$finished <- base::Sys.time()
[16:04:49.989]     ...future.result
[16:04:49.989] }
[16:04:49.991] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:04:49.992] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:04:49.992] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:04:49.992] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:04:49.992] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:04:49.993] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:04:49.993] MultisessionFuture started
[16:04:49.993] - Launch lazy future ... done
[16:04:49.993] run() for ‘MultisessionFuture’ ... done
[16:04:49.993] result() for ClusterFuture ...
[16:04:49.993] receiveMessageFromWorker() for ClusterFuture ...
[16:04:49.994] - Validating connection of MultisessionFuture
[16:04:50.041] - received message: FutureResult
[16:04:50.041] - Received FutureResult
[16:04:50.041] - Erased future from FutureRegistry
[16:04:50.041] result() for ClusterFuture ...
[16:04:50.041] - result already collected: FutureResult
[16:04:50.041] result() for ClusterFuture ... done
[16:04:50.042] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.042] result() for ClusterFuture ... done
[16:04:50.042] result() for ClusterFuture ...
[16:04:50.042] - result already collected: FutureResult
[16:04:50.042] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[16:04:50.044] getGlobalsAndPackages() ...
[16:04:50.044] Searching for globals...
[16:04:50.045] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[16:04:50.045] Searching for globals ... DONE
[16:04:50.046] Resolving globals: FALSE
[16:04:50.046] The total size of the 2 globals is 896 bytes (896 bytes)
[16:04:50.046] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[16:04:50.047] - globals: [2] ‘weight’, ‘group’
[16:04:50.047] - packages: [1] ‘stats’
[16:04:50.047] getGlobalsAndPackages() ... DONE
[16:04:50.047] run() for ‘Future’ ...
[16:04:50.047] - state: ‘created’
[16:04:50.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.063]   - Field: ‘node’
[16:04:50.063]   - Field: ‘label’
[16:04:50.063]   - Field: ‘local’
[16:04:50.063]   - Field: ‘owner’
[16:04:50.063]   - Field: ‘envir’
[16:04:50.063]   - Field: ‘workers’
[16:04:50.063]   - Field: ‘packages’
[16:04:50.064]   - Field: ‘gc’
[16:04:50.064]   - Field: ‘conditions’
[16:04:50.064]   - Field: ‘persistent’
[16:04:50.064]   - Field: ‘expr’
[16:04:50.064]   - Field: ‘uuid’
[16:04:50.064]   - Field: ‘seed’
[16:04:50.064]   - Field: ‘version’
[16:04:50.064]   - Field: ‘result’
[16:04:50.064]   - Field: ‘asynchronous’
[16:04:50.064]   - Field: ‘calls’
[16:04:50.064]   - Field: ‘globals’
[16:04:50.065]   - Field: ‘stdout’
[16:04:50.065]   - Field: ‘earlySignal’
[16:04:50.065]   - Field: ‘lazy’
[16:04:50.065]   - Field: ‘state’
[16:04:50.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.065] - Launch lazy future ...
[16:04:50.065] Packages needed by the future expression (n = 1): ‘stats’
[16:04:50.065] Packages needed by future strategies (n = 0): <none>
[16:04:50.066] {
[16:04:50.066]     {
[16:04:50.066]         {
[16:04:50.066]             ...future.startTime <- base::Sys.time()
[16:04:50.066]             {
[16:04:50.066]                 {
[16:04:50.066]                   {
[16:04:50.066]                     {
[16:04:50.066]                       {
[16:04:50.066]                         base::local({
[16:04:50.066]                           has_future <- base::requireNamespace("future", 
[16:04:50.066]                             quietly = TRUE)
[16:04:50.066]                           if (has_future) {
[16:04:50.066]                             ns <- base::getNamespace("future")
[16:04:50.066]                             version <- ns[[".package"]][["version"]]
[16:04:50.066]                             if (is.null(version)) 
[16:04:50.066]                               version <- utils::packageVersion("future")
[16:04:50.066]                           }
[16:04:50.066]                           else {
[16:04:50.066]                             version <- NULL
[16:04:50.066]                           }
[16:04:50.066]                           if (!has_future || version < "1.8.0") {
[16:04:50.066]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.066]                               "", base::R.version$version.string), 
[16:04:50.066]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.066]                                 base::R.version$platform, 8 * 
[16:04:50.066]                                   base::.Machine$sizeof.pointer), 
[16:04:50.066]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.066]                                 "release", "version")], collapse = " "), 
[16:04:50.066]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.066]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.066]                               info)
[16:04:50.066]                             info <- base::paste(info, collapse = "; ")
[16:04:50.066]                             if (!has_future) {
[16:04:50.066]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.066]                                 info)
[16:04:50.066]                             }
[16:04:50.066]                             else {
[16:04:50.066]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.066]                                 info, version)
[16:04:50.066]                             }
[16:04:50.066]                             base::stop(msg)
[16:04:50.066]                           }
[16:04:50.066]                         })
[16:04:50.066]                       }
[16:04:50.066]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.066]                       base::options(mc.cores = 1L)
[16:04:50.066]                     }
[16:04:50.066]                     base::local({
[16:04:50.066]                       for (pkg in "stats") {
[16:04:50.066]                         base::loadNamespace(pkg)
[16:04:50.066]                         base::library(pkg, character.only = TRUE)
[16:04:50.066]                       }
[16:04:50.066]                     })
[16:04:50.066]                   }
[16:04:50.066]                   options(future.plan = NULL)
[16:04:50.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.066]                 }
[16:04:50.066]                 ...future.workdir <- getwd()
[16:04:50.066]             }
[16:04:50.066]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.066]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.066]         }
[16:04:50.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.066]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.066]             base::names(...future.oldOptions))
[16:04:50.066]     }
[16:04:50.066]     if (FALSE) {
[16:04:50.066]     }
[16:04:50.066]     else {
[16:04:50.066]         if (TRUE) {
[16:04:50.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.066]                 open = "w")
[16:04:50.066]         }
[16:04:50.066]         else {
[16:04:50.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.066]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.066]         }
[16:04:50.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.066]             base::sink(type = "output", split = FALSE)
[16:04:50.066]             base::close(...future.stdout)
[16:04:50.066]         }, add = TRUE)
[16:04:50.066]     }
[16:04:50.066]     ...future.frame <- base::sys.nframe()
[16:04:50.066]     ...future.conditions <- base::list()
[16:04:50.066]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.066]     if (FALSE) {
[16:04:50.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.066]     }
[16:04:50.066]     ...future.result <- base::tryCatch({
[16:04:50.066]         base::withCallingHandlers({
[16:04:50.066]             ...future.value <- base::withVisible(base::local({
[16:04:50.066]                 ...future.makeSendCondition <- base::local({
[16:04:50.066]                   sendCondition <- NULL
[16:04:50.066]                   function(frame = 1L) {
[16:04:50.066]                     if (is.function(sendCondition)) 
[16:04:50.066]                       return(sendCondition)
[16:04:50.066]                     ns <- getNamespace("parallel")
[16:04:50.066]                     if (exists("sendData", mode = "function", 
[16:04:50.066]                       envir = ns)) {
[16:04:50.066]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.066]                         envir = ns)
[16:04:50.066]                       envir <- sys.frame(frame)
[16:04:50.066]                       master <- NULL
[16:04:50.066]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.066]                         !identical(envir, emptyenv())) {
[16:04:50.066]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.066]                           inherits = FALSE)) {
[16:04:50.066]                           master <- get("master", mode = "list", 
[16:04:50.066]                             envir = envir, inherits = FALSE)
[16:04:50.066]                           if (inherits(master, c("SOCKnode", 
[16:04:50.066]                             "SOCK0node"))) {
[16:04:50.066]                             sendCondition <<- function(cond) {
[16:04:50.066]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.066]                                 success = TRUE)
[16:04:50.066]                               parallel_sendData(master, data)
[16:04:50.066]                             }
[16:04:50.066]                             return(sendCondition)
[16:04:50.066]                           }
[16:04:50.066]                         }
[16:04:50.066]                         frame <- frame + 1L
[16:04:50.066]                         envir <- sys.frame(frame)
[16:04:50.066]                       }
[16:04:50.066]                     }
[16:04:50.066]                     sendCondition <<- function(cond) NULL
[16:04:50.066]                   }
[16:04:50.066]                 })
[16:04:50.066]                 withCallingHandlers({
[16:04:50.066]                   {
[16:04:50.066]                     lm(weight ~ group - 1)
[16:04:50.066]                   }
[16:04:50.066]                 }, immediateCondition = function(cond) {
[16:04:50.066]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.066]                   sendCondition(cond)
[16:04:50.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.066]                   {
[16:04:50.066]                     inherits <- base::inherits
[16:04:50.066]                     invokeRestart <- base::invokeRestart
[16:04:50.066]                     is.null <- base::is.null
[16:04:50.066]                     muffled <- FALSE
[16:04:50.066]                     if (inherits(cond, "message")) {
[16:04:50.066]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.066]                       if (muffled) 
[16:04:50.066]                         invokeRestart("muffleMessage")
[16:04:50.066]                     }
[16:04:50.066]                     else if (inherits(cond, "warning")) {
[16:04:50.066]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.066]                       if (muffled) 
[16:04:50.066]                         invokeRestart("muffleWarning")
[16:04:50.066]                     }
[16:04:50.066]                     else if (inherits(cond, "condition")) {
[16:04:50.066]                       if (!is.null(pattern)) {
[16:04:50.066]                         computeRestarts <- base::computeRestarts
[16:04:50.066]                         grepl <- base::grepl
[16:04:50.066]                         restarts <- computeRestarts(cond)
[16:04:50.066]                         for (restart in restarts) {
[16:04:50.066]                           name <- restart$name
[16:04:50.066]                           if (is.null(name)) 
[16:04:50.066]                             next
[16:04:50.066]                           if (!grepl(pattern, name)) 
[16:04:50.066]                             next
[16:04:50.066]                           invokeRestart(restart)
[16:04:50.066]                           muffled <- TRUE
[16:04:50.066]                           break
[16:04:50.066]                         }
[16:04:50.066]                       }
[16:04:50.066]                     }
[16:04:50.066]                     invisible(muffled)
[16:04:50.066]                   }
[16:04:50.066]                   muffleCondition(cond)
[16:04:50.066]                 })
[16:04:50.066]             }))
[16:04:50.066]             future::FutureResult(value = ...future.value$value, 
[16:04:50.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.066]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.066]                     ...future.globalenv.names))
[16:04:50.066]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.066]         }, condition = base::local({
[16:04:50.066]             c <- base::c
[16:04:50.066]             inherits <- base::inherits
[16:04:50.066]             invokeRestart <- base::invokeRestart
[16:04:50.066]             length <- base::length
[16:04:50.066]             list <- base::list
[16:04:50.066]             seq.int <- base::seq.int
[16:04:50.066]             signalCondition <- base::signalCondition
[16:04:50.066]             sys.calls <- base::sys.calls
[16:04:50.066]             `[[` <- base::`[[`
[16:04:50.066]             `+` <- base::`+`
[16:04:50.066]             `<<-` <- base::`<<-`
[16:04:50.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.066]                   3L)]
[16:04:50.066]             }
[16:04:50.066]             function(cond) {
[16:04:50.066]                 is_error <- inherits(cond, "error")
[16:04:50.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.066]                   NULL)
[16:04:50.066]                 if (is_error) {
[16:04:50.066]                   sessionInformation <- function() {
[16:04:50.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.066]                       search = base::search(), system = base::Sys.info())
[16:04:50.066]                   }
[16:04:50.066]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.066]                     cond$call), session = sessionInformation(), 
[16:04:50.066]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.066]                   signalCondition(cond)
[16:04:50.066]                 }
[16:04:50.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.066]                 "immediateCondition"))) {
[16:04:50.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.066]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.066]                   if (TRUE && !signal) {
[16:04:50.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.066]                     {
[16:04:50.066]                       inherits <- base::inherits
[16:04:50.066]                       invokeRestart <- base::invokeRestart
[16:04:50.066]                       is.null <- base::is.null
[16:04:50.066]                       muffled <- FALSE
[16:04:50.066]                       if (inherits(cond, "message")) {
[16:04:50.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.066]                         if (muffled) 
[16:04:50.066]                           invokeRestart("muffleMessage")
[16:04:50.066]                       }
[16:04:50.066]                       else if (inherits(cond, "warning")) {
[16:04:50.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.066]                         if (muffled) 
[16:04:50.066]                           invokeRestart("muffleWarning")
[16:04:50.066]                       }
[16:04:50.066]                       else if (inherits(cond, "condition")) {
[16:04:50.066]                         if (!is.null(pattern)) {
[16:04:50.066]                           computeRestarts <- base::computeRestarts
[16:04:50.066]                           grepl <- base::grepl
[16:04:50.066]                           restarts <- computeRestarts(cond)
[16:04:50.066]                           for (restart in restarts) {
[16:04:50.066]                             name <- restart$name
[16:04:50.066]                             if (is.null(name)) 
[16:04:50.066]                               next
[16:04:50.066]                             if (!grepl(pattern, name)) 
[16:04:50.066]                               next
[16:04:50.066]                             invokeRestart(restart)
[16:04:50.066]                             muffled <- TRUE
[16:04:50.066]                             break
[16:04:50.066]                           }
[16:04:50.066]                         }
[16:04:50.066]                       }
[16:04:50.066]                       invisible(muffled)
[16:04:50.066]                     }
[16:04:50.066]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.066]                   }
[16:04:50.066]                 }
[16:04:50.066]                 else {
[16:04:50.066]                   if (TRUE) {
[16:04:50.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.066]                     {
[16:04:50.066]                       inherits <- base::inherits
[16:04:50.066]                       invokeRestart <- base::invokeRestart
[16:04:50.066]                       is.null <- base::is.null
[16:04:50.066]                       muffled <- FALSE
[16:04:50.066]                       if (inherits(cond, "message")) {
[16:04:50.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.066]                         if (muffled) 
[16:04:50.066]                           invokeRestart("muffleMessage")
[16:04:50.066]                       }
[16:04:50.066]                       else if (inherits(cond, "warning")) {
[16:04:50.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.066]                         if (muffled) 
[16:04:50.066]                           invokeRestart("muffleWarning")
[16:04:50.066]                       }
[16:04:50.066]                       else if (inherits(cond, "condition")) {
[16:04:50.066]                         if (!is.null(pattern)) {
[16:04:50.066]                           computeRestarts <- base::computeRestarts
[16:04:50.066]                           grepl <- base::grepl
[16:04:50.066]                           restarts <- computeRestarts(cond)
[16:04:50.066]                           for (restart in restarts) {
[16:04:50.066]                             name <- restart$name
[16:04:50.066]                             if (is.null(name)) 
[16:04:50.066]                               next
[16:04:50.066]                             if (!grepl(pattern, name)) 
[16:04:50.066]                               next
[16:04:50.066]                             invokeRestart(restart)
[16:04:50.066]                             muffled <- TRUE
[16:04:50.066]                             break
[16:04:50.066]                           }
[16:04:50.066]                         }
[16:04:50.066]                       }
[16:04:50.066]                       invisible(muffled)
[16:04:50.066]                     }
[16:04:50.066]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.066]                   }
[16:04:50.066]                 }
[16:04:50.066]             }
[16:04:50.066]         }))
[16:04:50.066]     }, error = function(ex) {
[16:04:50.066]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.066]                 ...future.rng), started = ...future.startTime, 
[16:04:50.066]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.066]             version = "1.8"), class = "FutureResult")
[16:04:50.066]     }, finally = {
[16:04:50.066]         if (!identical(...future.workdir, getwd())) 
[16:04:50.066]             setwd(...future.workdir)
[16:04:50.066]         {
[16:04:50.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.066]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.066]             }
[16:04:50.066]             base::options(...future.oldOptions)
[16:04:50.066]             if (.Platform$OS.type == "windows") {
[16:04:50.066]                 old_names <- names(...future.oldEnvVars)
[16:04:50.066]                 envs <- base::Sys.getenv()
[16:04:50.066]                 names <- names(envs)
[16:04:50.066]                 common <- intersect(names, old_names)
[16:04:50.066]                 added <- setdiff(names, old_names)
[16:04:50.066]                 removed <- setdiff(old_names, names)
[16:04:50.066]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.066]                   envs[common]]
[16:04:50.066]                 NAMES <- toupper(changed)
[16:04:50.066]                 args <- list()
[16:04:50.066]                 for (kk in seq_along(NAMES)) {
[16:04:50.066]                   name <- changed[[kk]]
[16:04:50.066]                   NAME <- NAMES[[kk]]
[16:04:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.066]                     next
[16:04:50.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.066]                 }
[16:04:50.066]                 NAMES <- toupper(added)
[16:04:50.066]                 for (kk in seq_along(NAMES)) {
[16:04:50.066]                   name <- added[[kk]]
[16:04:50.066]                   NAME <- NAMES[[kk]]
[16:04:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.066]                     next
[16:04:50.066]                   args[[name]] <- ""
[16:04:50.066]                 }
[16:04:50.066]                 NAMES <- toupper(removed)
[16:04:50.066]                 for (kk in seq_along(NAMES)) {
[16:04:50.066]                   name <- removed[[kk]]
[16:04:50.066]                   NAME <- NAMES[[kk]]
[16:04:50.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.066]                     next
[16:04:50.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.066]                 }
[16:04:50.066]                 if (length(args) > 0) 
[16:04:50.066]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.066]             }
[16:04:50.066]             else {
[16:04:50.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.066]             }
[16:04:50.066]             {
[16:04:50.066]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.066]                   0L) {
[16:04:50.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.066]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.066]                   base::options(opts)
[16:04:50.066]                 }
[16:04:50.066]                 {
[16:04:50.066]                   {
[16:04:50.066]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.066]                     NULL
[16:04:50.066]                   }
[16:04:50.066]                   options(future.plan = NULL)
[16:04:50.066]                   if (is.na(NA_character_)) 
[16:04:50.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.066]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.066]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.066]                     envir = parent.frame()) 
[16:04:50.066]                   {
[16:04:50.066]                     if (is.function(workers)) 
[16:04:50.066]                       workers <- workers()
[16:04:50.066]                     workers <- structure(as.integer(workers), 
[16:04:50.066]                       class = class(workers))
[16:04:50.066]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.066]                       workers >= 1)
[16:04:50.066]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.066]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.066]                     }
[16:04:50.066]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.066]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.066]                       envir = envir)
[16:04:50.066]                     if (!future$lazy) 
[16:04:50.066]                       future <- run(future)
[16:04:50.066]                     invisible(future)
[16:04:50.066]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.066]                 }
[16:04:50.066]             }
[16:04:50.066]         }
[16:04:50.066]     })
[16:04:50.066]     if (TRUE) {
[16:04:50.066]         base::sink(type = "output", split = FALSE)
[16:04:50.066]         if (TRUE) {
[16:04:50.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.066]         }
[16:04:50.066]         else {
[16:04:50.066]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.066]         }
[16:04:50.066]         base::close(...future.stdout)
[16:04:50.066]         ...future.stdout <- NULL
[16:04:50.066]     }
[16:04:50.066]     ...future.result$conditions <- ...future.conditions
[16:04:50.066]     ...future.result$finished <- base::Sys.time()
[16:04:50.066]     ...future.result
[16:04:50.066] }
[16:04:50.069] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[16:04:50.069] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[16:04:50.069] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[16:04:50.069] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[16:04:50.070] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[16:04:50.070] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[16:04:50.070] MultisessionFuture started
[16:04:50.070] - Launch lazy future ... done
[16:04:50.070] run() for ‘MultisessionFuture’ ... done
[16:04:50.071] result() for ClusterFuture ...
[16:04:50.071] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.071] - Validating connection of MultisessionFuture
[16:04:50.117] - received message: FutureResult
[16:04:50.117] - Received FutureResult
[16:04:50.117] - Erased future from FutureRegistry
[16:04:50.118] result() for ClusterFuture ...
[16:04:50.118] - result already collected: FutureResult
[16:04:50.118] result() for ClusterFuture ... done
[16:04:50.118] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.118] result() for ClusterFuture ... done
[16:04:50.118] result() for ClusterFuture ...
[16:04:50.118] - result already collected: FutureResult
[16:04:50.118] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[16:04:50.120] getGlobalsAndPackages() ...
[16:04:50.120] Searching for globals...
[16:04:50.121] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:50.121] Searching for globals ... DONE
[16:04:50.121] Resolving globals: FALSE
[16:04:50.122] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:50.122] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:50.122] - globals: [1] ‘x’
[16:04:50.123] - packages: [1] ‘stats’
[16:04:50.123] getGlobalsAndPackages() ... DONE
[16:04:50.123] run() for ‘Future’ ...
[16:04:50.123] - state: ‘created’
[16:04:50.123] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.137]   - Field: ‘node’
[16:04:50.137]   - Field: ‘label’
[16:04:50.137]   - Field: ‘local’
[16:04:50.137]   - Field: ‘owner’
[16:04:50.137]   - Field: ‘envir’
[16:04:50.137]   - Field: ‘workers’
[16:04:50.137]   - Field: ‘packages’
[16:04:50.137]   - Field: ‘gc’
[16:04:50.138]   - Field: ‘conditions’
[16:04:50.138]   - Field: ‘persistent’
[16:04:50.138]   - Field: ‘expr’
[16:04:50.138]   - Field: ‘uuid’
[16:04:50.138]   - Field: ‘seed’
[16:04:50.138]   - Field: ‘version’
[16:04:50.138]   - Field: ‘result’
[16:04:50.138]   - Field: ‘asynchronous’
[16:04:50.138]   - Field: ‘calls’
[16:04:50.138]   - Field: ‘globals’
[16:04:50.138]   - Field: ‘stdout’
[16:04:50.139]   - Field: ‘earlySignal’
[16:04:50.139]   - Field: ‘lazy’
[16:04:50.139]   - Field: ‘state’
[16:04:50.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.139] - Launch lazy future ...
[16:04:50.139] Packages needed by the future expression (n = 1): ‘stats’
[16:04:50.139] Packages needed by future strategies (n = 0): <none>
[16:04:50.140] {
[16:04:50.140]     {
[16:04:50.140]         {
[16:04:50.140]             ...future.startTime <- base::Sys.time()
[16:04:50.140]             {
[16:04:50.140]                 {
[16:04:50.140]                   {
[16:04:50.140]                     {
[16:04:50.140]                       {
[16:04:50.140]                         base::local({
[16:04:50.140]                           has_future <- base::requireNamespace("future", 
[16:04:50.140]                             quietly = TRUE)
[16:04:50.140]                           if (has_future) {
[16:04:50.140]                             ns <- base::getNamespace("future")
[16:04:50.140]                             version <- ns[[".package"]][["version"]]
[16:04:50.140]                             if (is.null(version)) 
[16:04:50.140]                               version <- utils::packageVersion("future")
[16:04:50.140]                           }
[16:04:50.140]                           else {
[16:04:50.140]                             version <- NULL
[16:04:50.140]                           }
[16:04:50.140]                           if (!has_future || version < "1.8.0") {
[16:04:50.140]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.140]                               "", base::R.version$version.string), 
[16:04:50.140]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.140]                                 base::R.version$platform, 8 * 
[16:04:50.140]                                   base::.Machine$sizeof.pointer), 
[16:04:50.140]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.140]                                 "release", "version")], collapse = " "), 
[16:04:50.140]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.140]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.140]                               info)
[16:04:50.140]                             info <- base::paste(info, collapse = "; ")
[16:04:50.140]                             if (!has_future) {
[16:04:50.140]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.140]                                 info)
[16:04:50.140]                             }
[16:04:50.140]                             else {
[16:04:50.140]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.140]                                 info, version)
[16:04:50.140]                             }
[16:04:50.140]                             base::stop(msg)
[16:04:50.140]                           }
[16:04:50.140]                         })
[16:04:50.140]                       }
[16:04:50.140]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.140]                       base::options(mc.cores = 1L)
[16:04:50.140]                     }
[16:04:50.140]                     base::local({
[16:04:50.140]                       for (pkg in "stats") {
[16:04:50.140]                         base::loadNamespace(pkg)
[16:04:50.140]                         base::library(pkg, character.only = TRUE)
[16:04:50.140]                       }
[16:04:50.140]                     })
[16:04:50.140]                   }
[16:04:50.140]                   options(future.plan = NULL)
[16:04:50.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.140]                 }
[16:04:50.140]                 ...future.workdir <- getwd()
[16:04:50.140]             }
[16:04:50.140]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.140]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.140]         }
[16:04:50.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.140]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.140]             base::names(...future.oldOptions))
[16:04:50.140]     }
[16:04:50.140]     if (FALSE) {
[16:04:50.140]     }
[16:04:50.140]     else {
[16:04:50.140]         if (TRUE) {
[16:04:50.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.140]                 open = "w")
[16:04:50.140]         }
[16:04:50.140]         else {
[16:04:50.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.140]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.140]         }
[16:04:50.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.140]             base::sink(type = "output", split = FALSE)
[16:04:50.140]             base::close(...future.stdout)
[16:04:50.140]         }, add = TRUE)
[16:04:50.140]     }
[16:04:50.140]     ...future.frame <- base::sys.nframe()
[16:04:50.140]     ...future.conditions <- base::list()
[16:04:50.140]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.140]     if (FALSE) {
[16:04:50.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.140]     }
[16:04:50.140]     ...future.result <- base::tryCatch({
[16:04:50.140]         base::withCallingHandlers({
[16:04:50.140]             ...future.value <- base::withVisible(base::local({
[16:04:50.140]                 ...future.makeSendCondition <- base::local({
[16:04:50.140]                   sendCondition <- NULL
[16:04:50.140]                   function(frame = 1L) {
[16:04:50.140]                     if (is.function(sendCondition)) 
[16:04:50.140]                       return(sendCondition)
[16:04:50.140]                     ns <- getNamespace("parallel")
[16:04:50.140]                     if (exists("sendData", mode = "function", 
[16:04:50.140]                       envir = ns)) {
[16:04:50.140]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.140]                         envir = ns)
[16:04:50.140]                       envir <- sys.frame(frame)
[16:04:50.140]                       master <- NULL
[16:04:50.140]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.140]                         !identical(envir, emptyenv())) {
[16:04:50.140]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.140]                           inherits = FALSE)) {
[16:04:50.140]                           master <- get("master", mode = "list", 
[16:04:50.140]                             envir = envir, inherits = FALSE)
[16:04:50.140]                           if (inherits(master, c("SOCKnode", 
[16:04:50.140]                             "SOCK0node"))) {
[16:04:50.140]                             sendCondition <<- function(cond) {
[16:04:50.140]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.140]                                 success = TRUE)
[16:04:50.140]                               parallel_sendData(master, data)
[16:04:50.140]                             }
[16:04:50.140]                             return(sendCondition)
[16:04:50.140]                           }
[16:04:50.140]                         }
[16:04:50.140]                         frame <- frame + 1L
[16:04:50.140]                         envir <- sys.frame(frame)
[16:04:50.140]                       }
[16:04:50.140]                     }
[16:04:50.140]                     sendCondition <<- function(cond) NULL
[16:04:50.140]                   }
[16:04:50.140]                 })
[16:04:50.140]                 withCallingHandlers({
[16:04:50.140]                   {
[16:04:50.140]                     xtabs(~x)
[16:04:50.140]                   }
[16:04:50.140]                 }, immediateCondition = function(cond) {
[16:04:50.140]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.140]                   sendCondition(cond)
[16:04:50.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.140]                   {
[16:04:50.140]                     inherits <- base::inherits
[16:04:50.140]                     invokeRestart <- base::invokeRestart
[16:04:50.140]                     is.null <- base::is.null
[16:04:50.140]                     muffled <- FALSE
[16:04:50.140]                     if (inherits(cond, "message")) {
[16:04:50.140]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.140]                       if (muffled) 
[16:04:50.140]                         invokeRestart("muffleMessage")
[16:04:50.140]                     }
[16:04:50.140]                     else if (inherits(cond, "warning")) {
[16:04:50.140]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.140]                       if (muffled) 
[16:04:50.140]                         invokeRestart("muffleWarning")
[16:04:50.140]                     }
[16:04:50.140]                     else if (inherits(cond, "condition")) {
[16:04:50.140]                       if (!is.null(pattern)) {
[16:04:50.140]                         computeRestarts <- base::computeRestarts
[16:04:50.140]                         grepl <- base::grepl
[16:04:50.140]                         restarts <- computeRestarts(cond)
[16:04:50.140]                         for (restart in restarts) {
[16:04:50.140]                           name <- restart$name
[16:04:50.140]                           if (is.null(name)) 
[16:04:50.140]                             next
[16:04:50.140]                           if (!grepl(pattern, name)) 
[16:04:50.140]                             next
[16:04:50.140]                           invokeRestart(restart)
[16:04:50.140]                           muffled <- TRUE
[16:04:50.140]                           break
[16:04:50.140]                         }
[16:04:50.140]                       }
[16:04:50.140]                     }
[16:04:50.140]                     invisible(muffled)
[16:04:50.140]                   }
[16:04:50.140]                   muffleCondition(cond)
[16:04:50.140]                 })
[16:04:50.140]             }))
[16:04:50.140]             future::FutureResult(value = ...future.value$value, 
[16:04:50.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.140]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.140]                     ...future.globalenv.names))
[16:04:50.140]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.140]         }, condition = base::local({
[16:04:50.140]             c <- base::c
[16:04:50.140]             inherits <- base::inherits
[16:04:50.140]             invokeRestart <- base::invokeRestart
[16:04:50.140]             length <- base::length
[16:04:50.140]             list <- base::list
[16:04:50.140]             seq.int <- base::seq.int
[16:04:50.140]             signalCondition <- base::signalCondition
[16:04:50.140]             sys.calls <- base::sys.calls
[16:04:50.140]             `[[` <- base::`[[`
[16:04:50.140]             `+` <- base::`+`
[16:04:50.140]             `<<-` <- base::`<<-`
[16:04:50.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.140]                   3L)]
[16:04:50.140]             }
[16:04:50.140]             function(cond) {
[16:04:50.140]                 is_error <- inherits(cond, "error")
[16:04:50.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.140]                   NULL)
[16:04:50.140]                 if (is_error) {
[16:04:50.140]                   sessionInformation <- function() {
[16:04:50.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.140]                       search = base::search(), system = base::Sys.info())
[16:04:50.140]                   }
[16:04:50.140]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.140]                     cond$call), session = sessionInformation(), 
[16:04:50.140]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.140]                   signalCondition(cond)
[16:04:50.140]                 }
[16:04:50.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.140]                 "immediateCondition"))) {
[16:04:50.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.140]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.140]                   if (TRUE && !signal) {
[16:04:50.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.140]                     {
[16:04:50.140]                       inherits <- base::inherits
[16:04:50.140]                       invokeRestart <- base::invokeRestart
[16:04:50.140]                       is.null <- base::is.null
[16:04:50.140]                       muffled <- FALSE
[16:04:50.140]                       if (inherits(cond, "message")) {
[16:04:50.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.140]                         if (muffled) 
[16:04:50.140]                           invokeRestart("muffleMessage")
[16:04:50.140]                       }
[16:04:50.140]                       else if (inherits(cond, "warning")) {
[16:04:50.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.140]                         if (muffled) 
[16:04:50.140]                           invokeRestart("muffleWarning")
[16:04:50.140]                       }
[16:04:50.140]                       else if (inherits(cond, "condition")) {
[16:04:50.140]                         if (!is.null(pattern)) {
[16:04:50.140]                           computeRestarts <- base::computeRestarts
[16:04:50.140]                           grepl <- base::grepl
[16:04:50.140]                           restarts <- computeRestarts(cond)
[16:04:50.140]                           for (restart in restarts) {
[16:04:50.140]                             name <- restart$name
[16:04:50.140]                             if (is.null(name)) 
[16:04:50.140]                               next
[16:04:50.140]                             if (!grepl(pattern, name)) 
[16:04:50.140]                               next
[16:04:50.140]                             invokeRestart(restart)
[16:04:50.140]                             muffled <- TRUE
[16:04:50.140]                             break
[16:04:50.140]                           }
[16:04:50.140]                         }
[16:04:50.140]                       }
[16:04:50.140]                       invisible(muffled)
[16:04:50.140]                     }
[16:04:50.140]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.140]                   }
[16:04:50.140]                 }
[16:04:50.140]                 else {
[16:04:50.140]                   if (TRUE) {
[16:04:50.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.140]                     {
[16:04:50.140]                       inherits <- base::inherits
[16:04:50.140]                       invokeRestart <- base::invokeRestart
[16:04:50.140]                       is.null <- base::is.null
[16:04:50.140]                       muffled <- FALSE
[16:04:50.140]                       if (inherits(cond, "message")) {
[16:04:50.140]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.140]                         if (muffled) 
[16:04:50.140]                           invokeRestart("muffleMessage")
[16:04:50.140]                       }
[16:04:50.140]                       else if (inherits(cond, "warning")) {
[16:04:50.140]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.140]                         if (muffled) 
[16:04:50.140]                           invokeRestart("muffleWarning")
[16:04:50.140]                       }
[16:04:50.140]                       else if (inherits(cond, "condition")) {
[16:04:50.140]                         if (!is.null(pattern)) {
[16:04:50.140]                           computeRestarts <- base::computeRestarts
[16:04:50.140]                           grepl <- base::grepl
[16:04:50.140]                           restarts <- computeRestarts(cond)
[16:04:50.140]                           for (restart in restarts) {
[16:04:50.140]                             name <- restart$name
[16:04:50.140]                             if (is.null(name)) 
[16:04:50.140]                               next
[16:04:50.140]                             if (!grepl(pattern, name)) 
[16:04:50.140]                               next
[16:04:50.140]                             invokeRestart(restart)
[16:04:50.140]                             muffled <- TRUE
[16:04:50.140]                             break
[16:04:50.140]                           }
[16:04:50.140]                         }
[16:04:50.140]                       }
[16:04:50.140]                       invisible(muffled)
[16:04:50.140]                     }
[16:04:50.140]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.140]                   }
[16:04:50.140]                 }
[16:04:50.140]             }
[16:04:50.140]         }))
[16:04:50.140]     }, error = function(ex) {
[16:04:50.140]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.140]                 ...future.rng), started = ...future.startTime, 
[16:04:50.140]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.140]             version = "1.8"), class = "FutureResult")
[16:04:50.140]     }, finally = {
[16:04:50.140]         if (!identical(...future.workdir, getwd())) 
[16:04:50.140]             setwd(...future.workdir)
[16:04:50.140]         {
[16:04:50.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.140]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.140]             }
[16:04:50.140]             base::options(...future.oldOptions)
[16:04:50.140]             if (.Platform$OS.type == "windows") {
[16:04:50.140]                 old_names <- names(...future.oldEnvVars)
[16:04:50.140]                 envs <- base::Sys.getenv()
[16:04:50.140]                 names <- names(envs)
[16:04:50.140]                 common <- intersect(names, old_names)
[16:04:50.140]                 added <- setdiff(names, old_names)
[16:04:50.140]                 removed <- setdiff(old_names, names)
[16:04:50.140]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.140]                   envs[common]]
[16:04:50.140]                 NAMES <- toupper(changed)
[16:04:50.140]                 args <- list()
[16:04:50.140]                 for (kk in seq_along(NAMES)) {
[16:04:50.140]                   name <- changed[[kk]]
[16:04:50.140]                   NAME <- NAMES[[kk]]
[16:04:50.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.140]                     next
[16:04:50.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.140]                 }
[16:04:50.140]                 NAMES <- toupper(added)
[16:04:50.140]                 for (kk in seq_along(NAMES)) {
[16:04:50.140]                   name <- added[[kk]]
[16:04:50.140]                   NAME <- NAMES[[kk]]
[16:04:50.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.140]                     next
[16:04:50.140]                   args[[name]] <- ""
[16:04:50.140]                 }
[16:04:50.140]                 NAMES <- toupper(removed)
[16:04:50.140]                 for (kk in seq_along(NAMES)) {
[16:04:50.140]                   name <- removed[[kk]]
[16:04:50.140]                   NAME <- NAMES[[kk]]
[16:04:50.140]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.140]                     next
[16:04:50.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.140]                 }
[16:04:50.140]                 if (length(args) > 0) 
[16:04:50.140]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.140]             }
[16:04:50.140]             else {
[16:04:50.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.140]             }
[16:04:50.140]             {
[16:04:50.140]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.140]                   0L) {
[16:04:50.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.140]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.140]                   base::options(opts)
[16:04:50.140]                 }
[16:04:50.140]                 {
[16:04:50.140]                   {
[16:04:50.140]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.140]                     NULL
[16:04:50.140]                   }
[16:04:50.140]                   options(future.plan = NULL)
[16:04:50.140]                   if (is.na(NA_character_)) 
[16:04:50.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.140]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.140]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.140]                     envir = parent.frame()) 
[16:04:50.140]                   {
[16:04:50.140]                     if (is.function(workers)) 
[16:04:50.140]                       workers <- workers()
[16:04:50.140]                     workers <- structure(as.integer(workers), 
[16:04:50.140]                       class = class(workers))
[16:04:50.140]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.140]                       workers >= 1)
[16:04:50.140]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.140]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.140]                     }
[16:04:50.140]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.140]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.140]                       envir = envir)
[16:04:50.140]                     if (!future$lazy) 
[16:04:50.140]                       future <- run(future)
[16:04:50.140]                     invisible(future)
[16:04:50.140]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.140]                 }
[16:04:50.140]             }
[16:04:50.140]         }
[16:04:50.140]     })
[16:04:50.140]     if (TRUE) {
[16:04:50.140]         base::sink(type = "output", split = FALSE)
[16:04:50.140]         if (TRUE) {
[16:04:50.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.140]         }
[16:04:50.140]         else {
[16:04:50.140]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.140]         }
[16:04:50.140]         base::close(...future.stdout)
[16:04:50.140]         ...future.stdout <- NULL
[16:04:50.140]     }
[16:04:50.140]     ...future.result$conditions <- ...future.conditions
[16:04:50.140]     ...future.result$finished <- base::Sys.time()
[16:04:50.140]     ...future.result
[16:04:50.140] }
[16:04:50.143] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:04:50.143] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:04:50.143] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:04:50.143] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:04:50.144] MultisessionFuture started
[16:04:50.144] - Launch lazy future ... done
[16:04:50.144] run() for ‘MultisessionFuture’ ... done
[16:04:50.144] result() for ClusterFuture ...
[16:04:50.144] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.144] - Validating connection of MultisessionFuture
[16:04:50.193] - received message: FutureResult
[16:04:50.193] - Received FutureResult
[16:04:50.193] - Erased future from FutureRegistry
[16:04:50.193] result() for ClusterFuture ...
[16:04:50.194] - result already collected: FutureResult
[16:04:50.194] result() for ClusterFuture ... done
[16:04:50.194] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.194] result() for ClusterFuture ... done
[16:04:50.194] result() for ClusterFuture ...
[16:04:50.194] - result already collected: FutureResult
[16:04:50.194] result() for ClusterFuture ... done
x
1 2 
2 3 
[16:04:50.195] getGlobalsAndPackages() ...
[16:04:50.195] Searching for globals...
[16:04:50.196] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[16:04:50.196] Searching for globals ... DONE
[16:04:50.196] Resolving globals: FALSE
[16:04:50.197] The total size of the 1 globals is 96 bytes (96 bytes)
[16:04:50.197] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[16:04:50.197] - globals: [1] ‘x’
[16:04:50.197] - packages: [1] ‘stats’
[16:04:50.198] getGlobalsAndPackages() ... DONE
[16:04:50.198] run() for ‘Future’ ...
[16:04:50.198] - state: ‘created’
[16:04:50.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.212]   - Field: ‘node’
[16:04:50.212]   - Field: ‘label’
[16:04:50.212]   - Field: ‘local’
[16:04:50.212]   - Field: ‘owner’
[16:04:50.212]   - Field: ‘envir’
[16:04:50.212]   - Field: ‘workers’
[16:04:50.212]   - Field: ‘packages’
[16:04:50.213]   - Field: ‘gc’
[16:04:50.213]   - Field: ‘conditions’
[16:04:50.213]   - Field: ‘persistent’
[16:04:50.213]   - Field: ‘expr’
[16:04:50.213]   - Field: ‘uuid’
[16:04:50.213]   - Field: ‘seed’
[16:04:50.213]   - Field: ‘version’
[16:04:50.213]   - Field: ‘result’
[16:04:50.213]   - Field: ‘asynchronous’
[16:04:50.213]   - Field: ‘calls’
[16:04:50.213]   - Field: ‘globals’
[16:04:50.214]   - Field: ‘stdout’
[16:04:50.214]   - Field: ‘earlySignal’
[16:04:50.214]   - Field: ‘lazy’
[16:04:50.214]   - Field: ‘state’
[16:04:50.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.214] - Launch lazy future ...
[16:04:50.214] Packages needed by the future expression (n = 1): ‘stats’
[16:04:50.214] Packages needed by future strategies (n = 0): <none>
[16:04:50.215] {
[16:04:50.215]     {
[16:04:50.215]         {
[16:04:50.215]             ...future.startTime <- base::Sys.time()
[16:04:50.215]             {
[16:04:50.215]                 {
[16:04:50.215]                   {
[16:04:50.215]                     {
[16:04:50.215]                       {
[16:04:50.215]                         base::local({
[16:04:50.215]                           has_future <- base::requireNamespace("future", 
[16:04:50.215]                             quietly = TRUE)
[16:04:50.215]                           if (has_future) {
[16:04:50.215]                             ns <- base::getNamespace("future")
[16:04:50.215]                             version <- ns[[".package"]][["version"]]
[16:04:50.215]                             if (is.null(version)) 
[16:04:50.215]                               version <- utils::packageVersion("future")
[16:04:50.215]                           }
[16:04:50.215]                           else {
[16:04:50.215]                             version <- NULL
[16:04:50.215]                           }
[16:04:50.215]                           if (!has_future || version < "1.8.0") {
[16:04:50.215]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.215]                               "", base::R.version$version.string), 
[16:04:50.215]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.215]                                 base::R.version$platform, 8 * 
[16:04:50.215]                                   base::.Machine$sizeof.pointer), 
[16:04:50.215]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.215]                                 "release", "version")], collapse = " "), 
[16:04:50.215]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.215]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.215]                               info)
[16:04:50.215]                             info <- base::paste(info, collapse = "; ")
[16:04:50.215]                             if (!has_future) {
[16:04:50.215]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.215]                                 info)
[16:04:50.215]                             }
[16:04:50.215]                             else {
[16:04:50.215]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.215]                                 info, version)
[16:04:50.215]                             }
[16:04:50.215]                             base::stop(msg)
[16:04:50.215]                           }
[16:04:50.215]                         })
[16:04:50.215]                       }
[16:04:50.215]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.215]                       base::options(mc.cores = 1L)
[16:04:50.215]                     }
[16:04:50.215]                     base::local({
[16:04:50.215]                       for (pkg in "stats") {
[16:04:50.215]                         base::loadNamespace(pkg)
[16:04:50.215]                         base::library(pkg, character.only = TRUE)
[16:04:50.215]                       }
[16:04:50.215]                     })
[16:04:50.215]                   }
[16:04:50.215]                   options(future.plan = NULL)
[16:04:50.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.215]                 }
[16:04:50.215]                 ...future.workdir <- getwd()
[16:04:50.215]             }
[16:04:50.215]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.215]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.215]         }
[16:04:50.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.215]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.215]             base::names(...future.oldOptions))
[16:04:50.215]     }
[16:04:50.215]     if (FALSE) {
[16:04:50.215]     }
[16:04:50.215]     else {
[16:04:50.215]         if (TRUE) {
[16:04:50.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.215]                 open = "w")
[16:04:50.215]         }
[16:04:50.215]         else {
[16:04:50.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.215]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.215]         }
[16:04:50.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.215]             base::sink(type = "output", split = FALSE)
[16:04:50.215]             base::close(...future.stdout)
[16:04:50.215]         }, add = TRUE)
[16:04:50.215]     }
[16:04:50.215]     ...future.frame <- base::sys.nframe()
[16:04:50.215]     ...future.conditions <- base::list()
[16:04:50.215]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.215]     if (FALSE) {
[16:04:50.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.215]     }
[16:04:50.215]     ...future.result <- base::tryCatch({
[16:04:50.215]         base::withCallingHandlers({
[16:04:50.215]             ...future.value <- base::withVisible(base::local({
[16:04:50.215]                 ...future.makeSendCondition <- base::local({
[16:04:50.215]                   sendCondition <- NULL
[16:04:50.215]                   function(frame = 1L) {
[16:04:50.215]                     if (is.function(sendCondition)) 
[16:04:50.215]                       return(sendCondition)
[16:04:50.215]                     ns <- getNamespace("parallel")
[16:04:50.215]                     if (exists("sendData", mode = "function", 
[16:04:50.215]                       envir = ns)) {
[16:04:50.215]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.215]                         envir = ns)
[16:04:50.215]                       envir <- sys.frame(frame)
[16:04:50.215]                       master <- NULL
[16:04:50.215]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.215]                         !identical(envir, emptyenv())) {
[16:04:50.215]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.215]                           inherits = FALSE)) {
[16:04:50.215]                           master <- get("master", mode = "list", 
[16:04:50.215]                             envir = envir, inherits = FALSE)
[16:04:50.215]                           if (inherits(master, c("SOCKnode", 
[16:04:50.215]                             "SOCK0node"))) {
[16:04:50.215]                             sendCondition <<- function(cond) {
[16:04:50.215]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.215]                                 success = TRUE)
[16:04:50.215]                               parallel_sendData(master, data)
[16:04:50.215]                             }
[16:04:50.215]                             return(sendCondition)
[16:04:50.215]                           }
[16:04:50.215]                         }
[16:04:50.215]                         frame <- frame + 1L
[16:04:50.215]                         envir <- sys.frame(frame)
[16:04:50.215]                       }
[16:04:50.215]                     }
[16:04:50.215]                     sendCondition <<- function(cond) NULL
[16:04:50.215]                   }
[16:04:50.215]                 })
[16:04:50.215]                 withCallingHandlers({
[16:04:50.215]                   {
[16:04:50.215]                     xtabs(~x)
[16:04:50.215]                   }
[16:04:50.215]                 }, immediateCondition = function(cond) {
[16:04:50.215]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.215]                   sendCondition(cond)
[16:04:50.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.215]                   {
[16:04:50.215]                     inherits <- base::inherits
[16:04:50.215]                     invokeRestart <- base::invokeRestart
[16:04:50.215]                     is.null <- base::is.null
[16:04:50.215]                     muffled <- FALSE
[16:04:50.215]                     if (inherits(cond, "message")) {
[16:04:50.215]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.215]                       if (muffled) 
[16:04:50.215]                         invokeRestart("muffleMessage")
[16:04:50.215]                     }
[16:04:50.215]                     else if (inherits(cond, "warning")) {
[16:04:50.215]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.215]                       if (muffled) 
[16:04:50.215]                         invokeRestart("muffleWarning")
[16:04:50.215]                     }
[16:04:50.215]                     else if (inherits(cond, "condition")) {
[16:04:50.215]                       if (!is.null(pattern)) {
[16:04:50.215]                         computeRestarts <- base::computeRestarts
[16:04:50.215]                         grepl <- base::grepl
[16:04:50.215]                         restarts <- computeRestarts(cond)
[16:04:50.215]                         for (restart in restarts) {
[16:04:50.215]                           name <- restart$name
[16:04:50.215]                           if (is.null(name)) 
[16:04:50.215]                             next
[16:04:50.215]                           if (!grepl(pattern, name)) 
[16:04:50.215]                             next
[16:04:50.215]                           invokeRestart(restart)
[16:04:50.215]                           muffled <- TRUE
[16:04:50.215]                           break
[16:04:50.215]                         }
[16:04:50.215]                       }
[16:04:50.215]                     }
[16:04:50.215]                     invisible(muffled)
[16:04:50.215]                   }
[16:04:50.215]                   muffleCondition(cond)
[16:04:50.215]                 })
[16:04:50.215]             }))
[16:04:50.215]             future::FutureResult(value = ...future.value$value, 
[16:04:50.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.215]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.215]                     ...future.globalenv.names))
[16:04:50.215]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.215]         }, condition = base::local({
[16:04:50.215]             c <- base::c
[16:04:50.215]             inherits <- base::inherits
[16:04:50.215]             invokeRestart <- base::invokeRestart
[16:04:50.215]             length <- base::length
[16:04:50.215]             list <- base::list
[16:04:50.215]             seq.int <- base::seq.int
[16:04:50.215]             signalCondition <- base::signalCondition
[16:04:50.215]             sys.calls <- base::sys.calls
[16:04:50.215]             `[[` <- base::`[[`
[16:04:50.215]             `+` <- base::`+`
[16:04:50.215]             `<<-` <- base::`<<-`
[16:04:50.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.215]                   3L)]
[16:04:50.215]             }
[16:04:50.215]             function(cond) {
[16:04:50.215]                 is_error <- inherits(cond, "error")
[16:04:50.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.215]                   NULL)
[16:04:50.215]                 if (is_error) {
[16:04:50.215]                   sessionInformation <- function() {
[16:04:50.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.215]                       search = base::search(), system = base::Sys.info())
[16:04:50.215]                   }
[16:04:50.215]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.215]                     cond$call), session = sessionInformation(), 
[16:04:50.215]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.215]                   signalCondition(cond)
[16:04:50.215]                 }
[16:04:50.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.215]                 "immediateCondition"))) {
[16:04:50.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.215]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.215]                   if (TRUE && !signal) {
[16:04:50.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.215]                     {
[16:04:50.215]                       inherits <- base::inherits
[16:04:50.215]                       invokeRestart <- base::invokeRestart
[16:04:50.215]                       is.null <- base::is.null
[16:04:50.215]                       muffled <- FALSE
[16:04:50.215]                       if (inherits(cond, "message")) {
[16:04:50.215]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.215]                         if (muffled) 
[16:04:50.215]                           invokeRestart("muffleMessage")
[16:04:50.215]                       }
[16:04:50.215]                       else if (inherits(cond, "warning")) {
[16:04:50.215]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.215]                         if (muffled) 
[16:04:50.215]                           invokeRestart("muffleWarning")
[16:04:50.215]                       }
[16:04:50.215]                       else if (inherits(cond, "condition")) {
[16:04:50.215]                         if (!is.null(pattern)) {
[16:04:50.215]                           computeRestarts <- base::computeRestarts
[16:04:50.215]                           grepl <- base::grepl
[16:04:50.215]                           restarts <- computeRestarts(cond)
[16:04:50.215]                           for (restart in restarts) {
[16:04:50.215]                             name <- restart$name
[16:04:50.215]                             if (is.null(name)) 
[16:04:50.215]                               next
[16:04:50.215]                             if (!grepl(pattern, name)) 
[16:04:50.215]                               next
[16:04:50.215]                             invokeRestart(restart)
[16:04:50.215]                             muffled <- TRUE
[16:04:50.215]                             break
[16:04:50.215]                           }
[16:04:50.215]                         }
[16:04:50.215]                       }
[16:04:50.215]                       invisible(muffled)
[16:04:50.215]                     }
[16:04:50.215]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.215]                   }
[16:04:50.215]                 }
[16:04:50.215]                 else {
[16:04:50.215]                   if (TRUE) {
[16:04:50.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.215]                     {
[16:04:50.215]                       inherits <- base::inherits
[16:04:50.215]                       invokeRestart <- base::invokeRestart
[16:04:50.215]                       is.null <- base::is.null
[16:04:50.215]                       muffled <- FALSE
[16:04:50.215]                       if (inherits(cond, "message")) {
[16:04:50.215]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.215]                         if (muffled) 
[16:04:50.215]                           invokeRestart("muffleMessage")
[16:04:50.215]                       }
[16:04:50.215]                       else if (inherits(cond, "warning")) {
[16:04:50.215]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.215]                         if (muffled) 
[16:04:50.215]                           invokeRestart("muffleWarning")
[16:04:50.215]                       }
[16:04:50.215]                       else if (inherits(cond, "condition")) {
[16:04:50.215]                         if (!is.null(pattern)) {
[16:04:50.215]                           computeRestarts <- base::computeRestarts
[16:04:50.215]                           grepl <- base::grepl
[16:04:50.215]                           restarts <- computeRestarts(cond)
[16:04:50.215]                           for (restart in restarts) {
[16:04:50.215]                             name <- restart$name
[16:04:50.215]                             if (is.null(name)) 
[16:04:50.215]                               next
[16:04:50.215]                             if (!grepl(pattern, name)) 
[16:04:50.215]                               next
[16:04:50.215]                             invokeRestart(restart)
[16:04:50.215]                             muffled <- TRUE
[16:04:50.215]                             break
[16:04:50.215]                           }
[16:04:50.215]                         }
[16:04:50.215]                       }
[16:04:50.215]                       invisible(muffled)
[16:04:50.215]                     }
[16:04:50.215]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.215]                   }
[16:04:50.215]                 }
[16:04:50.215]             }
[16:04:50.215]         }))
[16:04:50.215]     }, error = function(ex) {
[16:04:50.215]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.215]                 ...future.rng), started = ...future.startTime, 
[16:04:50.215]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.215]             version = "1.8"), class = "FutureResult")
[16:04:50.215]     }, finally = {
[16:04:50.215]         if (!identical(...future.workdir, getwd())) 
[16:04:50.215]             setwd(...future.workdir)
[16:04:50.215]         {
[16:04:50.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.215]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.215]             }
[16:04:50.215]             base::options(...future.oldOptions)
[16:04:50.215]             if (.Platform$OS.type == "windows") {
[16:04:50.215]                 old_names <- names(...future.oldEnvVars)
[16:04:50.215]                 envs <- base::Sys.getenv()
[16:04:50.215]                 names <- names(envs)
[16:04:50.215]                 common <- intersect(names, old_names)
[16:04:50.215]                 added <- setdiff(names, old_names)
[16:04:50.215]                 removed <- setdiff(old_names, names)
[16:04:50.215]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.215]                   envs[common]]
[16:04:50.215]                 NAMES <- toupper(changed)
[16:04:50.215]                 args <- list()
[16:04:50.215]                 for (kk in seq_along(NAMES)) {
[16:04:50.215]                   name <- changed[[kk]]
[16:04:50.215]                   NAME <- NAMES[[kk]]
[16:04:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.215]                     next
[16:04:50.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.215]                 }
[16:04:50.215]                 NAMES <- toupper(added)
[16:04:50.215]                 for (kk in seq_along(NAMES)) {
[16:04:50.215]                   name <- added[[kk]]
[16:04:50.215]                   NAME <- NAMES[[kk]]
[16:04:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.215]                     next
[16:04:50.215]                   args[[name]] <- ""
[16:04:50.215]                 }
[16:04:50.215]                 NAMES <- toupper(removed)
[16:04:50.215]                 for (kk in seq_along(NAMES)) {
[16:04:50.215]                   name <- removed[[kk]]
[16:04:50.215]                   NAME <- NAMES[[kk]]
[16:04:50.215]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.215]                     next
[16:04:50.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.215]                 }
[16:04:50.215]                 if (length(args) > 0) 
[16:04:50.215]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.215]             }
[16:04:50.215]             else {
[16:04:50.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.215]             }
[16:04:50.215]             {
[16:04:50.215]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.215]                   0L) {
[16:04:50.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.215]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.215]                   base::options(opts)
[16:04:50.215]                 }
[16:04:50.215]                 {
[16:04:50.215]                   {
[16:04:50.215]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.215]                     NULL
[16:04:50.215]                   }
[16:04:50.215]                   options(future.plan = NULL)
[16:04:50.215]                   if (is.na(NA_character_)) 
[16:04:50.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.215]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.215]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.215]                     envir = parent.frame()) 
[16:04:50.215]                   {
[16:04:50.215]                     if (is.function(workers)) 
[16:04:50.215]                       workers <- workers()
[16:04:50.215]                     workers <- structure(as.integer(workers), 
[16:04:50.215]                       class = class(workers))
[16:04:50.215]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.215]                       workers >= 1)
[16:04:50.215]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.215]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.215]                     }
[16:04:50.215]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.215]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.215]                       envir = envir)
[16:04:50.215]                     if (!future$lazy) 
[16:04:50.215]                       future <- run(future)
[16:04:50.215]                     invisible(future)
[16:04:50.215]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.215]                 }
[16:04:50.215]             }
[16:04:50.215]         }
[16:04:50.215]     })
[16:04:50.215]     if (TRUE) {
[16:04:50.215]         base::sink(type = "output", split = FALSE)
[16:04:50.215]         if (TRUE) {
[16:04:50.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.215]         }
[16:04:50.215]         else {
[16:04:50.215]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.215]         }
[16:04:50.215]         base::close(...future.stdout)
[16:04:50.215]         ...future.stdout <- NULL
[16:04:50.215]     }
[16:04:50.215]     ...future.result$conditions <- ...future.conditions
[16:04:50.215]     ...future.result$finished <- base::Sys.time()
[16:04:50.215]     ...future.result
[16:04:50.215] }
[16:04:50.218] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[16:04:50.218] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[16:04:50.218] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[16:04:50.218] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[16:04:50.219] MultisessionFuture started
[16:04:50.219] - Launch lazy future ... done
[16:04:50.219] run() for ‘MultisessionFuture’ ... done
[16:04:50.219] result() for ClusterFuture ...
[16:04:50.219] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.219] - Validating connection of MultisessionFuture
[16:04:50.264] - received message: FutureResult
[16:04:50.265] - Received FutureResult
[16:04:50.265] - Erased future from FutureRegistry
[16:04:50.265] result() for ClusterFuture ...
[16:04:50.265] - result already collected: FutureResult
[16:04:50.265] result() for ClusterFuture ... done
[16:04:50.265] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.265] result() for ClusterFuture ... done
[16:04:50.265] result() for ClusterFuture ...
[16:04:50.266] - result already collected: FutureResult
[16:04:50.266] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[16:04:50.267] getGlobalsAndPackages() ...
[16:04:50.267] Searching for globals...
[16:04:50.269] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[16:04:50.269] Searching for globals ... DONE
[16:04:50.269] Resolving globals: FALSE
[16:04:50.270] 
[16:04:50.270] - packages: [2] ‘stats’, ‘datasets’
[16:04:50.270] getGlobalsAndPackages() ... DONE
[16:04:50.270] run() for ‘Future’ ...
[16:04:50.270] - state: ‘created’
[16:04:50.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.285]   - Field: ‘node’
[16:04:50.285]   - Field: ‘label’
[16:04:50.285]   - Field: ‘local’
[16:04:50.285]   - Field: ‘owner’
[16:04:50.285]   - Field: ‘envir’
[16:04:50.285]   - Field: ‘workers’
[16:04:50.285]   - Field: ‘packages’
[16:04:50.285]   - Field: ‘gc’
[16:04:50.285]   - Field: ‘conditions’
[16:04:50.286]   - Field: ‘persistent’
[16:04:50.286]   - Field: ‘expr’
[16:04:50.286]   - Field: ‘uuid’
[16:04:50.286]   - Field: ‘seed’
[16:04:50.286]   - Field: ‘version’
[16:04:50.286]   - Field: ‘result’
[16:04:50.286]   - Field: ‘asynchronous’
[16:04:50.286]   - Field: ‘calls’
[16:04:50.286]   - Field: ‘globals’
[16:04:50.286]   - Field: ‘stdout’
[16:04:50.287]   - Field: ‘earlySignal’
[16:04:50.287]   - Field: ‘lazy’
[16:04:50.287]   - Field: ‘state’
[16:04:50.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.287] - Launch lazy future ...
[16:04:50.287] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:50.288] Packages needed by future strategies (n = 0): <none>
[16:04:50.288] {
[16:04:50.288]     {
[16:04:50.288]         {
[16:04:50.288]             ...future.startTime <- base::Sys.time()
[16:04:50.288]             {
[16:04:50.288]                 {
[16:04:50.288]                   {
[16:04:50.288]                     {
[16:04:50.288]                       {
[16:04:50.288]                         base::local({
[16:04:50.288]                           has_future <- base::requireNamespace("future", 
[16:04:50.288]                             quietly = TRUE)
[16:04:50.288]                           if (has_future) {
[16:04:50.288]                             ns <- base::getNamespace("future")
[16:04:50.288]                             version <- ns[[".package"]][["version"]]
[16:04:50.288]                             if (is.null(version)) 
[16:04:50.288]                               version <- utils::packageVersion("future")
[16:04:50.288]                           }
[16:04:50.288]                           else {
[16:04:50.288]                             version <- NULL
[16:04:50.288]                           }
[16:04:50.288]                           if (!has_future || version < "1.8.0") {
[16:04:50.288]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.288]                               "", base::R.version$version.string), 
[16:04:50.288]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.288]                                 base::R.version$platform, 8 * 
[16:04:50.288]                                   base::.Machine$sizeof.pointer), 
[16:04:50.288]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.288]                                 "release", "version")], collapse = " "), 
[16:04:50.288]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.288]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.288]                               info)
[16:04:50.288]                             info <- base::paste(info, collapse = "; ")
[16:04:50.288]                             if (!has_future) {
[16:04:50.288]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.288]                                 info)
[16:04:50.288]                             }
[16:04:50.288]                             else {
[16:04:50.288]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.288]                                 info, version)
[16:04:50.288]                             }
[16:04:50.288]                             base::stop(msg)
[16:04:50.288]                           }
[16:04:50.288]                         })
[16:04:50.288]                       }
[16:04:50.288]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.288]                       base::options(mc.cores = 1L)
[16:04:50.288]                     }
[16:04:50.288]                     base::local({
[16:04:50.288]                       for (pkg in c("stats", "datasets")) {
[16:04:50.288]                         base::loadNamespace(pkg)
[16:04:50.288]                         base::library(pkg, character.only = TRUE)
[16:04:50.288]                       }
[16:04:50.288]                     })
[16:04:50.288]                   }
[16:04:50.288]                   options(future.plan = NULL)
[16:04:50.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.288]                 }
[16:04:50.288]                 ...future.workdir <- getwd()
[16:04:50.288]             }
[16:04:50.288]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.288]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.288]         }
[16:04:50.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.288]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.288]             base::names(...future.oldOptions))
[16:04:50.288]     }
[16:04:50.288]     if (FALSE) {
[16:04:50.288]     }
[16:04:50.288]     else {
[16:04:50.288]         if (TRUE) {
[16:04:50.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.288]                 open = "w")
[16:04:50.288]         }
[16:04:50.288]         else {
[16:04:50.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.288]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.288]         }
[16:04:50.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.288]             base::sink(type = "output", split = FALSE)
[16:04:50.288]             base::close(...future.stdout)
[16:04:50.288]         }, add = TRUE)
[16:04:50.288]     }
[16:04:50.288]     ...future.frame <- base::sys.nframe()
[16:04:50.288]     ...future.conditions <- base::list()
[16:04:50.288]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.288]     if (FALSE) {
[16:04:50.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.288]     }
[16:04:50.288]     ...future.result <- base::tryCatch({
[16:04:50.288]         base::withCallingHandlers({
[16:04:50.288]             ...future.value <- base::withVisible(base::local({
[16:04:50.288]                 ...future.makeSendCondition <- base::local({
[16:04:50.288]                   sendCondition <- NULL
[16:04:50.288]                   function(frame = 1L) {
[16:04:50.288]                     if (is.function(sendCondition)) 
[16:04:50.288]                       return(sendCondition)
[16:04:50.288]                     ns <- getNamespace("parallel")
[16:04:50.288]                     if (exists("sendData", mode = "function", 
[16:04:50.288]                       envir = ns)) {
[16:04:50.288]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.288]                         envir = ns)
[16:04:50.288]                       envir <- sys.frame(frame)
[16:04:50.288]                       master <- NULL
[16:04:50.288]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.288]                         !identical(envir, emptyenv())) {
[16:04:50.288]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.288]                           inherits = FALSE)) {
[16:04:50.288]                           master <- get("master", mode = "list", 
[16:04:50.288]                             envir = envir, inherits = FALSE)
[16:04:50.288]                           if (inherits(master, c("SOCKnode", 
[16:04:50.288]                             "SOCK0node"))) {
[16:04:50.288]                             sendCondition <<- function(cond) {
[16:04:50.288]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.288]                                 success = TRUE)
[16:04:50.288]                               parallel_sendData(master, data)
[16:04:50.288]                             }
[16:04:50.288]                             return(sendCondition)
[16:04:50.288]                           }
[16:04:50.288]                         }
[16:04:50.288]                         frame <- frame + 1L
[16:04:50.288]                         envir <- sys.frame(frame)
[16:04:50.288]                       }
[16:04:50.288]                     }
[16:04:50.288]                     sendCondition <<- function(cond) NULL
[16:04:50.288]                   }
[16:04:50.288]                 })
[16:04:50.288]                 withCallingHandlers({
[16:04:50.288]                   {
[16:04:50.288]                     lm(dist ~ . - 1, data = cars)
[16:04:50.288]                   }
[16:04:50.288]                 }, immediateCondition = function(cond) {
[16:04:50.288]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.288]                   sendCondition(cond)
[16:04:50.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.288]                   {
[16:04:50.288]                     inherits <- base::inherits
[16:04:50.288]                     invokeRestart <- base::invokeRestart
[16:04:50.288]                     is.null <- base::is.null
[16:04:50.288]                     muffled <- FALSE
[16:04:50.288]                     if (inherits(cond, "message")) {
[16:04:50.288]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.288]                       if (muffled) 
[16:04:50.288]                         invokeRestart("muffleMessage")
[16:04:50.288]                     }
[16:04:50.288]                     else if (inherits(cond, "warning")) {
[16:04:50.288]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.288]                       if (muffled) 
[16:04:50.288]                         invokeRestart("muffleWarning")
[16:04:50.288]                     }
[16:04:50.288]                     else if (inherits(cond, "condition")) {
[16:04:50.288]                       if (!is.null(pattern)) {
[16:04:50.288]                         computeRestarts <- base::computeRestarts
[16:04:50.288]                         grepl <- base::grepl
[16:04:50.288]                         restarts <- computeRestarts(cond)
[16:04:50.288]                         for (restart in restarts) {
[16:04:50.288]                           name <- restart$name
[16:04:50.288]                           if (is.null(name)) 
[16:04:50.288]                             next
[16:04:50.288]                           if (!grepl(pattern, name)) 
[16:04:50.288]                             next
[16:04:50.288]                           invokeRestart(restart)
[16:04:50.288]                           muffled <- TRUE
[16:04:50.288]                           break
[16:04:50.288]                         }
[16:04:50.288]                       }
[16:04:50.288]                     }
[16:04:50.288]                     invisible(muffled)
[16:04:50.288]                   }
[16:04:50.288]                   muffleCondition(cond)
[16:04:50.288]                 })
[16:04:50.288]             }))
[16:04:50.288]             future::FutureResult(value = ...future.value$value, 
[16:04:50.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.288]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.288]                     ...future.globalenv.names))
[16:04:50.288]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.288]         }, condition = base::local({
[16:04:50.288]             c <- base::c
[16:04:50.288]             inherits <- base::inherits
[16:04:50.288]             invokeRestart <- base::invokeRestart
[16:04:50.288]             length <- base::length
[16:04:50.288]             list <- base::list
[16:04:50.288]             seq.int <- base::seq.int
[16:04:50.288]             signalCondition <- base::signalCondition
[16:04:50.288]             sys.calls <- base::sys.calls
[16:04:50.288]             `[[` <- base::`[[`
[16:04:50.288]             `+` <- base::`+`
[16:04:50.288]             `<<-` <- base::`<<-`
[16:04:50.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.288]                   3L)]
[16:04:50.288]             }
[16:04:50.288]             function(cond) {
[16:04:50.288]                 is_error <- inherits(cond, "error")
[16:04:50.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.288]                   NULL)
[16:04:50.288]                 if (is_error) {
[16:04:50.288]                   sessionInformation <- function() {
[16:04:50.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.288]                       search = base::search(), system = base::Sys.info())
[16:04:50.288]                   }
[16:04:50.288]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.288]                     cond$call), session = sessionInformation(), 
[16:04:50.288]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.288]                   signalCondition(cond)
[16:04:50.288]                 }
[16:04:50.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.288]                 "immediateCondition"))) {
[16:04:50.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.288]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.288]                   if (TRUE && !signal) {
[16:04:50.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.288]                     {
[16:04:50.288]                       inherits <- base::inherits
[16:04:50.288]                       invokeRestart <- base::invokeRestart
[16:04:50.288]                       is.null <- base::is.null
[16:04:50.288]                       muffled <- FALSE
[16:04:50.288]                       if (inherits(cond, "message")) {
[16:04:50.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.288]                         if (muffled) 
[16:04:50.288]                           invokeRestart("muffleMessage")
[16:04:50.288]                       }
[16:04:50.288]                       else if (inherits(cond, "warning")) {
[16:04:50.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.288]                         if (muffled) 
[16:04:50.288]                           invokeRestart("muffleWarning")
[16:04:50.288]                       }
[16:04:50.288]                       else if (inherits(cond, "condition")) {
[16:04:50.288]                         if (!is.null(pattern)) {
[16:04:50.288]                           computeRestarts <- base::computeRestarts
[16:04:50.288]                           grepl <- base::grepl
[16:04:50.288]                           restarts <- computeRestarts(cond)
[16:04:50.288]                           for (restart in restarts) {
[16:04:50.288]                             name <- restart$name
[16:04:50.288]                             if (is.null(name)) 
[16:04:50.288]                               next
[16:04:50.288]                             if (!grepl(pattern, name)) 
[16:04:50.288]                               next
[16:04:50.288]                             invokeRestart(restart)
[16:04:50.288]                             muffled <- TRUE
[16:04:50.288]                             break
[16:04:50.288]                           }
[16:04:50.288]                         }
[16:04:50.288]                       }
[16:04:50.288]                       invisible(muffled)
[16:04:50.288]                     }
[16:04:50.288]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.288]                   }
[16:04:50.288]                 }
[16:04:50.288]                 else {
[16:04:50.288]                   if (TRUE) {
[16:04:50.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.288]                     {
[16:04:50.288]                       inherits <- base::inherits
[16:04:50.288]                       invokeRestart <- base::invokeRestart
[16:04:50.288]                       is.null <- base::is.null
[16:04:50.288]                       muffled <- FALSE
[16:04:50.288]                       if (inherits(cond, "message")) {
[16:04:50.288]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.288]                         if (muffled) 
[16:04:50.288]                           invokeRestart("muffleMessage")
[16:04:50.288]                       }
[16:04:50.288]                       else if (inherits(cond, "warning")) {
[16:04:50.288]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.288]                         if (muffled) 
[16:04:50.288]                           invokeRestart("muffleWarning")
[16:04:50.288]                       }
[16:04:50.288]                       else if (inherits(cond, "condition")) {
[16:04:50.288]                         if (!is.null(pattern)) {
[16:04:50.288]                           computeRestarts <- base::computeRestarts
[16:04:50.288]                           grepl <- base::grepl
[16:04:50.288]                           restarts <- computeRestarts(cond)
[16:04:50.288]                           for (restart in restarts) {
[16:04:50.288]                             name <- restart$name
[16:04:50.288]                             if (is.null(name)) 
[16:04:50.288]                               next
[16:04:50.288]                             if (!grepl(pattern, name)) 
[16:04:50.288]                               next
[16:04:50.288]                             invokeRestart(restart)
[16:04:50.288]                             muffled <- TRUE
[16:04:50.288]                             break
[16:04:50.288]                           }
[16:04:50.288]                         }
[16:04:50.288]                       }
[16:04:50.288]                       invisible(muffled)
[16:04:50.288]                     }
[16:04:50.288]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.288]                   }
[16:04:50.288]                 }
[16:04:50.288]             }
[16:04:50.288]         }))
[16:04:50.288]     }, error = function(ex) {
[16:04:50.288]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.288]                 ...future.rng), started = ...future.startTime, 
[16:04:50.288]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.288]             version = "1.8"), class = "FutureResult")
[16:04:50.288]     }, finally = {
[16:04:50.288]         if (!identical(...future.workdir, getwd())) 
[16:04:50.288]             setwd(...future.workdir)
[16:04:50.288]         {
[16:04:50.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.288]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.288]             }
[16:04:50.288]             base::options(...future.oldOptions)
[16:04:50.288]             if (.Platform$OS.type == "windows") {
[16:04:50.288]                 old_names <- names(...future.oldEnvVars)
[16:04:50.288]                 envs <- base::Sys.getenv()
[16:04:50.288]                 names <- names(envs)
[16:04:50.288]                 common <- intersect(names, old_names)
[16:04:50.288]                 added <- setdiff(names, old_names)
[16:04:50.288]                 removed <- setdiff(old_names, names)
[16:04:50.288]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.288]                   envs[common]]
[16:04:50.288]                 NAMES <- toupper(changed)
[16:04:50.288]                 args <- list()
[16:04:50.288]                 for (kk in seq_along(NAMES)) {
[16:04:50.288]                   name <- changed[[kk]]
[16:04:50.288]                   NAME <- NAMES[[kk]]
[16:04:50.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.288]                     next
[16:04:50.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.288]                 }
[16:04:50.288]                 NAMES <- toupper(added)
[16:04:50.288]                 for (kk in seq_along(NAMES)) {
[16:04:50.288]                   name <- added[[kk]]
[16:04:50.288]                   NAME <- NAMES[[kk]]
[16:04:50.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.288]                     next
[16:04:50.288]                   args[[name]] <- ""
[16:04:50.288]                 }
[16:04:50.288]                 NAMES <- toupper(removed)
[16:04:50.288]                 for (kk in seq_along(NAMES)) {
[16:04:50.288]                   name <- removed[[kk]]
[16:04:50.288]                   NAME <- NAMES[[kk]]
[16:04:50.288]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.288]                     next
[16:04:50.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.288]                 }
[16:04:50.288]                 if (length(args) > 0) 
[16:04:50.288]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.288]             }
[16:04:50.288]             else {
[16:04:50.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.288]             }
[16:04:50.288]             {
[16:04:50.288]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.288]                   0L) {
[16:04:50.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.288]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.288]                   base::options(opts)
[16:04:50.288]                 }
[16:04:50.288]                 {
[16:04:50.288]                   {
[16:04:50.288]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.288]                     NULL
[16:04:50.288]                   }
[16:04:50.288]                   options(future.plan = NULL)
[16:04:50.288]                   if (is.na(NA_character_)) 
[16:04:50.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.288]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.288]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.288]                     envir = parent.frame()) 
[16:04:50.288]                   {
[16:04:50.288]                     if (is.function(workers)) 
[16:04:50.288]                       workers <- workers()
[16:04:50.288]                     workers <- structure(as.integer(workers), 
[16:04:50.288]                       class = class(workers))
[16:04:50.288]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.288]                       workers >= 1)
[16:04:50.288]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.288]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.288]                     }
[16:04:50.288]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.288]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.288]                       envir = envir)
[16:04:50.288]                     if (!future$lazy) 
[16:04:50.288]                       future <- run(future)
[16:04:50.288]                     invisible(future)
[16:04:50.288]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.288]                 }
[16:04:50.288]             }
[16:04:50.288]         }
[16:04:50.288]     })
[16:04:50.288]     if (TRUE) {
[16:04:50.288]         base::sink(type = "output", split = FALSE)
[16:04:50.288]         if (TRUE) {
[16:04:50.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.288]         }
[16:04:50.288]         else {
[16:04:50.288]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.288]         }
[16:04:50.288]         base::close(...future.stdout)
[16:04:50.288]         ...future.stdout <- NULL
[16:04:50.288]     }
[16:04:50.288]     ...future.result$conditions <- ...future.conditions
[16:04:50.288]     ...future.result$finished <- base::Sys.time()
[16:04:50.288]     ...future.result
[16:04:50.288] }
[16:04:50.292] MultisessionFuture started
[16:04:50.292] - Launch lazy future ... done
[16:04:50.292] run() for ‘MultisessionFuture’ ... done
[16:04:50.292] result() for ClusterFuture ...
[16:04:50.292] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.293] - Validating connection of MultisessionFuture
[16:04:50.341] - received message: FutureResult
[16:04:50.341] - Received FutureResult
[16:04:50.342] - Erased future from FutureRegistry
[16:04:50.342] result() for ClusterFuture ...
[16:04:50.342] - result already collected: FutureResult
[16:04:50.342] result() for ClusterFuture ... done
[16:04:50.342] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.342] result() for ClusterFuture ... done
[16:04:50.342] result() for ClusterFuture ...
[16:04:50.342] - result already collected: FutureResult
[16:04:50.342] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[16:04:50.347] getGlobalsAndPackages() ...
[16:04:50.347] Searching for globals...
[16:04:50.349] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[16:04:50.349] Searching for globals ... DONE
[16:04:50.349] Resolving globals: FALSE
[16:04:50.349] 
[16:04:50.349] - packages: [2] ‘stats’, ‘datasets’
[16:04:50.349] getGlobalsAndPackages() ... DONE
[16:04:50.350] run() for ‘Future’ ...
[16:04:50.350] - state: ‘created’
[16:04:50.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.365]   - Field: ‘node’
[16:04:50.365]   - Field: ‘label’
[16:04:50.365]   - Field: ‘local’
[16:04:50.365]   - Field: ‘owner’
[16:04:50.365]   - Field: ‘envir’
[16:04:50.365]   - Field: ‘workers’
[16:04:50.365]   - Field: ‘packages’
[16:04:50.365]   - Field: ‘gc’
[16:04:50.365]   - Field: ‘conditions’
[16:04:50.365]   - Field: ‘persistent’
[16:04:50.365]   - Field: ‘expr’
[16:04:50.366]   - Field: ‘uuid’
[16:04:50.366]   - Field: ‘seed’
[16:04:50.366]   - Field: ‘version’
[16:04:50.366]   - Field: ‘result’
[16:04:50.366]   - Field: ‘asynchronous’
[16:04:50.366]   - Field: ‘calls’
[16:04:50.366]   - Field: ‘globals’
[16:04:50.366]   - Field: ‘stdout’
[16:04:50.366]   - Field: ‘earlySignal’
[16:04:50.366]   - Field: ‘lazy’
[16:04:50.366]   - Field: ‘state’
[16:04:50.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.367] - Launch lazy future ...
[16:04:50.367] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:50.367] Packages needed by future strategies (n = 0): <none>
[16:04:50.368] {
[16:04:50.368]     {
[16:04:50.368]         {
[16:04:50.368]             ...future.startTime <- base::Sys.time()
[16:04:50.368]             {
[16:04:50.368]                 {
[16:04:50.368]                   {
[16:04:50.368]                     {
[16:04:50.368]                       {
[16:04:50.368]                         base::local({
[16:04:50.368]                           has_future <- base::requireNamespace("future", 
[16:04:50.368]                             quietly = TRUE)
[16:04:50.368]                           if (has_future) {
[16:04:50.368]                             ns <- base::getNamespace("future")
[16:04:50.368]                             version <- ns[[".package"]][["version"]]
[16:04:50.368]                             if (is.null(version)) 
[16:04:50.368]                               version <- utils::packageVersion("future")
[16:04:50.368]                           }
[16:04:50.368]                           else {
[16:04:50.368]                             version <- NULL
[16:04:50.368]                           }
[16:04:50.368]                           if (!has_future || version < "1.8.0") {
[16:04:50.368]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.368]                               "", base::R.version$version.string), 
[16:04:50.368]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.368]                                 base::R.version$platform, 8 * 
[16:04:50.368]                                   base::.Machine$sizeof.pointer), 
[16:04:50.368]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.368]                                 "release", "version")], collapse = " "), 
[16:04:50.368]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.368]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.368]                               info)
[16:04:50.368]                             info <- base::paste(info, collapse = "; ")
[16:04:50.368]                             if (!has_future) {
[16:04:50.368]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.368]                                 info)
[16:04:50.368]                             }
[16:04:50.368]                             else {
[16:04:50.368]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.368]                                 info, version)
[16:04:50.368]                             }
[16:04:50.368]                             base::stop(msg)
[16:04:50.368]                           }
[16:04:50.368]                         })
[16:04:50.368]                       }
[16:04:50.368]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.368]                       base::options(mc.cores = 1L)
[16:04:50.368]                     }
[16:04:50.368]                     base::local({
[16:04:50.368]                       for (pkg in c("stats", "datasets")) {
[16:04:50.368]                         base::loadNamespace(pkg)
[16:04:50.368]                         base::library(pkg, character.only = TRUE)
[16:04:50.368]                       }
[16:04:50.368]                     })
[16:04:50.368]                   }
[16:04:50.368]                   options(future.plan = NULL)
[16:04:50.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.368]                 }
[16:04:50.368]                 ...future.workdir <- getwd()
[16:04:50.368]             }
[16:04:50.368]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.368]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.368]         }
[16:04:50.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.368]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.368]             base::names(...future.oldOptions))
[16:04:50.368]     }
[16:04:50.368]     if (FALSE) {
[16:04:50.368]     }
[16:04:50.368]     else {
[16:04:50.368]         if (TRUE) {
[16:04:50.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.368]                 open = "w")
[16:04:50.368]         }
[16:04:50.368]         else {
[16:04:50.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.368]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.368]         }
[16:04:50.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.368]             base::sink(type = "output", split = FALSE)
[16:04:50.368]             base::close(...future.stdout)
[16:04:50.368]         }, add = TRUE)
[16:04:50.368]     }
[16:04:50.368]     ...future.frame <- base::sys.nframe()
[16:04:50.368]     ...future.conditions <- base::list()
[16:04:50.368]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.368]     if (FALSE) {
[16:04:50.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.368]     }
[16:04:50.368]     ...future.result <- base::tryCatch({
[16:04:50.368]         base::withCallingHandlers({
[16:04:50.368]             ...future.value <- base::withVisible(base::local({
[16:04:50.368]                 ...future.makeSendCondition <- base::local({
[16:04:50.368]                   sendCondition <- NULL
[16:04:50.368]                   function(frame = 1L) {
[16:04:50.368]                     if (is.function(sendCondition)) 
[16:04:50.368]                       return(sendCondition)
[16:04:50.368]                     ns <- getNamespace("parallel")
[16:04:50.368]                     if (exists("sendData", mode = "function", 
[16:04:50.368]                       envir = ns)) {
[16:04:50.368]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.368]                         envir = ns)
[16:04:50.368]                       envir <- sys.frame(frame)
[16:04:50.368]                       master <- NULL
[16:04:50.368]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.368]                         !identical(envir, emptyenv())) {
[16:04:50.368]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.368]                           inherits = FALSE)) {
[16:04:50.368]                           master <- get("master", mode = "list", 
[16:04:50.368]                             envir = envir, inherits = FALSE)
[16:04:50.368]                           if (inherits(master, c("SOCKnode", 
[16:04:50.368]                             "SOCK0node"))) {
[16:04:50.368]                             sendCondition <<- function(cond) {
[16:04:50.368]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.368]                                 success = TRUE)
[16:04:50.368]                               parallel_sendData(master, data)
[16:04:50.368]                             }
[16:04:50.368]                             return(sendCondition)
[16:04:50.368]                           }
[16:04:50.368]                         }
[16:04:50.368]                         frame <- frame + 1L
[16:04:50.368]                         envir <- sys.frame(frame)
[16:04:50.368]                       }
[16:04:50.368]                     }
[16:04:50.368]                     sendCondition <<- function(cond) NULL
[16:04:50.368]                   }
[16:04:50.368]                 })
[16:04:50.368]                 withCallingHandlers({
[16:04:50.368]                   {
[16:04:50.368]                     lm(dist ~ . + 0, data = cars)
[16:04:50.368]                   }
[16:04:50.368]                 }, immediateCondition = function(cond) {
[16:04:50.368]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.368]                   sendCondition(cond)
[16:04:50.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.368]                   {
[16:04:50.368]                     inherits <- base::inherits
[16:04:50.368]                     invokeRestart <- base::invokeRestart
[16:04:50.368]                     is.null <- base::is.null
[16:04:50.368]                     muffled <- FALSE
[16:04:50.368]                     if (inherits(cond, "message")) {
[16:04:50.368]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.368]                       if (muffled) 
[16:04:50.368]                         invokeRestart("muffleMessage")
[16:04:50.368]                     }
[16:04:50.368]                     else if (inherits(cond, "warning")) {
[16:04:50.368]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.368]                       if (muffled) 
[16:04:50.368]                         invokeRestart("muffleWarning")
[16:04:50.368]                     }
[16:04:50.368]                     else if (inherits(cond, "condition")) {
[16:04:50.368]                       if (!is.null(pattern)) {
[16:04:50.368]                         computeRestarts <- base::computeRestarts
[16:04:50.368]                         grepl <- base::grepl
[16:04:50.368]                         restarts <- computeRestarts(cond)
[16:04:50.368]                         for (restart in restarts) {
[16:04:50.368]                           name <- restart$name
[16:04:50.368]                           if (is.null(name)) 
[16:04:50.368]                             next
[16:04:50.368]                           if (!grepl(pattern, name)) 
[16:04:50.368]                             next
[16:04:50.368]                           invokeRestart(restart)
[16:04:50.368]                           muffled <- TRUE
[16:04:50.368]                           break
[16:04:50.368]                         }
[16:04:50.368]                       }
[16:04:50.368]                     }
[16:04:50.368]                     invisible(muffled)
[16:04:50.368]                   }
[16:04:50.368]                   muffleCondition(cond)
[16:04:50.368]                 })
[16:04:50.368]             }))
[16:04:50.368]             future::FutureResult(value = ...future.value$value, 
[16:04:50.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.368]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.368]                     ...future.globalenv.names))
[16:04:50.368]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.368]         }, condition = base::local({
[16:04:50.368]             c <- base::c
[16:04:50.368]             inherits <- base::inherits
[16:04:50.368]             invokeRestart <- base::invokeRestart
[16:04:50.368]             length <- base::length
[16:04:50.368]             list <- base::list
[16:04:50.368]             seq.int <- base::seq.int
[16:04:50.368]             signalCondition <- base::signalCondition
[16:04:50.368]             sys.calls <- base::sys.calls
[16:04:50.368]             `[[` <- base::`[[`
[16:04:50.368]             `+` <- base::`+`
[16:04:50.368]             `<<-` <- base::`<<-`
[16:04:50.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.368]                   3L)]
[16:04:50.368]             }
[16:04:50.368]             function(cond) {
[16:04:50.368]                 is_error <- inherits(cond, "error")
[16:04:50.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.368]                   NULL)
[16:04:50.368]                 if (is_error) {
[16:04:50.368]                   sessionInformation <- function() {
[16:04:50.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.368]                       search = base::search(), system = base::Sys.info())
[16:04:50.368]                   }
[16:04:50.368]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.368]                     cond$call), session = sessionInformation(), 
[16:04:50.368]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.368]                   signalCondition(cond)
[16:04:50.368]                 }
[16:04:50.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.368]                 "immediateCondition"))) {
[16:04:50.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.368]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.368]                   if (TRUE && !signal) {
[16:04:50.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.368]                     {
[16:04:50.368]                       inherits <- base::inherits
[16:04:50.368]                       invokeRestart <- base::invokeRestart
[16:04:50.368]                       is.null <- base::is.null
[16:04:50.368]                       muffled <- FALSE
[16:04:50.368]                       if (inherits(cond, "message")) {
[16:04:50.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.368]                         if (muffled) 
[16:04:50.368]                           invokeRestart("muffleMessage")
[16:04:50.368]                       }
[16:04:50.368]                       else if (inherits(cond, "warning")) {
[16:04:50.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.368]                         if (muffled) 
[16:04:50.368]                           invokeRestart("muffleWarning")
[16:04:50.368]                       }
[16:04:50.368]                       else if (inherits(cond, "condition")) {
[16:04:50.368]                         if (!is.null(pattern)) {
[16:04:50.368]                           computeRestarts <- base::computeRestarts
[16:04:50.368]                           grepl <- base::grepl
[16:04:50.368]                           restarts <- computeRestarts(cond)
[16:04:50.368]                           for (restart in restarts) {
[16:04:50.368]                             name <- restart$name
[16:04:50.368]                             if (is.null(name)) 
[16:04:50.368]                               next
[16:04:50.368]                             if (!grepl(pattern, name)) 
[16:04:50.368]                               next
[16:04:50.368]                             invokeRestart(restart)
[16:04:50.368]                             muffled <- TRUE
[16:04:50.368]                             break
[16:04:50.368]                           }
[16:04:50.368]                         }
[16:04:50.368]                       }
[16:04:50.368]                       invisible(muffled)
[16:04:50.368]                     }
[16:04:50.368]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.368]                   }
[16:04:50.368]                 }
[16:04:50.368]                 else {
[16:04:50.368]                   if (TRUE) {
[16:04:50.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.368]                     {
[16:04:50.368]                       inherits <- base::inherits
[16:04:50.368]                       invokeRestart <- base::invokeRestart
[16:04:50.368]                       is.null <- base::is.null
[16:04:50.368]                       muffled <- FALSE
[16:04:50.368]                       if (inherits(cond, "message")) {
[16:04:50.368]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.368]                         if (muffled) 
[16:04:50.368]                           invokeRestart("muffleMessage")
[16:04:50.368]                       }
[16:04:50.368]                       else if (inherits(cond, "warning")) {
[16:04:50.368]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.368]                         if (muffled) 
[16:04:50.368]                           invokeRestart("muffleWarning")
[16:04:50.368]                       }
[16:04:50.368]                       else if (inherits(cond, "condition")) {
[16:04:50.368]                         if (!is.null(pattern)) {
[16:04:50.368]                           computeRestarts <- base::computeRestarts
[16:04:50.368]                           grepl <- base::grepl
[16:04:50.368]                           restarts <- computeRestarts(cond)
[16:04:50.368]                           for (restart in restarts) {
[16:04:50.368]                             name <- restart$name
[16:04:50.368]                             if (is.null(name)) 
[16:04:50.368]                               next
[16:04:50.368]                             if (!grepl(pattern, name)) 
[16:04:50.368]                               next
[16:04:50.368]                             invokeRestart(restart)
[16:04:50.368]                             muffled <- TRUE
[16:04:50.368]                             break
[16:04:50.368]                           }
[16:04:50.368]                         }
[16:04:50.368]                       }
[16:04:50.368]                       invisible(muffled)
[16:04:50.368]                     }
[16:04:50.368]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.368]                   }
[16:04:50.368]                 }
[16:04:50.368]             }
[16:04:50.368]         }))
[16:04:50.368]     }, error = function(ex) {
[16:04:50.368]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.368]                 ...future.rng), started = ...future.startTime, 
[16:04:50.368]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.368]             version = "1.8"), class = "FutureResult")
[16:04:50.368]     }, finally = {
[16:04:50.368]         if (!identical(...future.workdir, getwd())) 
[16:04:50.368]             setwd(...future.workdir)
[16:04:50.368]         {
[16:04:50.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.368]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.368]             }
[16:04:50.368]             base::options(...future.oldOptions)
[16:04:50.368]             if (.Platform$OS.type == "windows") {
[16:04:50.368]                 old_names <- names(...future.oldEnvVars)
[16:04:50.368]                 envs <- base::Sys.getenv()
[16:04:50.368]                 names <- names(envs)
[16:04:50.368]                 common <- intersect(names, old_names)
[16:04:50.368]                 added <- setdiff(names, old_names)
[16:04:50.368]                 removed <- setdiff(old_names, names)
[16:04:50.368]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.368]                   envs[common]]
[16:04:50.368]                 NAMES <- toupper(changed)
[16:04:50.368]                 args <- list()
[16:04:50.368]                 for (kk in seq_along(NAMES)) {
[16:04:50.368]                   name <- changed[[kk]]
[16:04:50.368]                   NAME <- NAMES[[kk]]
[16:04:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.368]                     next
[16:04:50.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.368]                 }
[16:04:50.368]                 NAMES <- toupper(added)
[16:04:50.368]                 for (kk in seq_along(NAMES)) {
[16:04:50.368]                   name <- added[[kk]]
[16:04:50.368]                   NAME <- NAMES[[kk]]
[16:04:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.368]                     next
[16:04:50.368]                   args[[name]] <- ""
[16:04:50.368]                 }
[16:04:50.368]                 NAMES <- toupper(removed)
[16:04:50.368]                 for (kk in seq_along(NAMES)) {
[16:04:50.368]                   name <- removed[[kk]]
[16:04:50.368]                   NAME <- NAMES[[kk]]
[16:04:50.368]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.368]                     next
[16:04:50.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.368]                 }
[16:04:50.368]                 if (length(args) > 0) 
[16:04:50.368]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.368]             }
[16:04:50.368]             else {
[16:04:50.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.368]             }
[16:04:50.368]             {
[16:04:50.368]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.368]                   0L) {
[16:04:50.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.368]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.368]                   base::options(opts)
[16:04:50.368]                 }
[16:04:50.368]                 {
[16:04:50.368]                   {
[16:04:50.368]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.368]                     NULL
[16:04:50.368]                   }
[16:04:50.368]                   options(future.plan = NULL)
[16:04:50.368]                   if (is.na(NA_character_)) 
[16:04:50.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.368]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.368]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.368]                     envir = parent.frame()) 
[16:04:50.368]                   {
[16:04:50.368]                     if (is.function(workers)) 
[16:04:50.368]                       workers <- workers()
[16:04:50.368]                     workers <- structure(as.integer(workers), 
[16:04:50.368]                       class = class(workers))
[16:04:50.368]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.368]                       workers >= 1)
[16:04:50.368]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.368]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.368]                     }
[16:04:50.368]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.368]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.368]                       envir = envir)
[16:04:50.368]                     if (!future$lazy) 
[16:04:50.368]                       future <- run(future)
[16:04:50.368]                     invisible(future)
[16:04:50.368]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.368]                 }
[16:04:50.368]             }
[16:04:50.368]         }
[16:04:50.368]     })
[16:04:50.368]     if (TRUE) {
[16:04:50.368]         base::sink(type = "output", split = FALSE)
[16:04:50.368]         if (TRUE) {
[16:04:50.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.368]         }
[16:04:50.368]         else {
[16:04:50.368]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.368]         }
[16:04:50.368]         base::close(...future.stdout)
[16:04:50.368]         ...future.stdout <- NULL
[16:04:50.368]     }
[16:04:50.368]     ...future.result$conditions <- ...future.conditions
[16:04:50.368]     ...future.result$finished <- base::Sys.time()
[16:04:50.368]     ...future.result
[16:04:50.368] }
[16:04:50.371] MultisessionFuture started
[16:04:50.371] - Launch lazy future ... done
[16:04:50.371] run() for ‘MultisessionFuture’ ... done
[16:04:50.371] result() for ClusterFuture ...
[16:04:50.371] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.372] - Validating connection of MultisessionFuture
[16:04:50.417] - received message: FutureResult
[16:04:50.417] - Received FutureResult
[16:04:50.417] - Erased future from FutureRegistry
[16:04:50.417] result() for ClusterFuture ...
[16:04:50.418] - result already collected: FutureResult
[16:04:50.418] result() for ClusterFuture ... done
[16:04:50.418] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.418] result() for ClusterFuture ... done
[16:04:50.418] result() for ClusterFuture ...
[16:04:50.418] - result already collected: FutureResult
[16:04:50.418] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[16:04:50.421] getGlobalsAndPackages() ...
[16:04:50.421] Searching for globals...
[16:04:50.423] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[16:04:50.423] Searching for globals ... DONE
[16:04:50.423] Resolving globals: FALSE
[16:04:50.424] 
[16:04:50.424] - packages: [2] ‘stats’, ‘datasets’
[16:04:50.424] getGlobalsAndPackages() ... DONE
[16:04:50.424] run() for ‘Future’ ...
[16:04:50.424] - state: ‘created’
[16:04:50.424] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.439]   - Field: ‘node’
[16:04:50.439]   - Field: ‘label’
[16:04:50.439]   - Field: ‘local’
[16:04:50.439]   - Field: ‘owner’
[16:04:50.439]   - Field: ‘envir’
[16:04:50.440]   - Field: ‘workers’
[16:04:50.440]   - Field: ‘packages’
[16:04:50.440]   - Field: ‘gc’
[16:04:50.440]   - Field: ‘conditions’
[16:04:50.440]   - Field: ‘persistent’
[16:04:50.440]   - Field: ‘expr’
[16:04:50.440]   - Field: ‘uuid’
[16:04:50.440]   - Field: ‘seed’
[16:04:50.440]   - Field: ‘version’
[16:04:50.440]   - Field: ‘result’
[16:04:50.440]   - Field: ‘asynchronous’
[16:04:50.441]   - Field: ‘calls’
[16:04:50.441]   - Field: ‘globals’
[16:04:50.441]   - Field: ‘stdout’
[16:04:50.441]   - Field: ‘earlySignal’
[16:04:50.441]   - Field: ‘lazy’
[16:04:50.441]   - Field: ‘state’
[16:04:50.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.441] - Launch lazy future ...
[16:04:50.442] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:50.442] Packages needed by future strategies (n = 0): <none>
[16:04:50.442] {
[16:04:50.442]     {
[16:04:50.442]         {
[16:04:50.442]             ...future.startTime <- base::Sys.time()
[16:04:50.442]             {
[16:04:50.442]                 {
[16:04:50.442]                   {
[16:04:50.442]                     {
[16:04:50.442]                       {
[16:04:50.442]                         base::local({
[16:04:50.442]                           has_future <- base::requireNamespace("future", 
[16:04:50.442]                             quietly = TRUE)
[16:04:50.442]                           if (has_future) {
[16:04:50.442]                             ns <- base::getNamespace("future")
[16:04:50.442]                             version <- ns[[".package"]][["version"]]
[16:04:50.442]                             if (is.null(version)) 
[16:04:50.442]                               version <- utils::packageVersion("future")
[16:04:50.442]                           }
[16:04:50.442]                           else {
[16:04:50.442]                             version <- NULL
[16:04:50.442]                           }
[16:04:50.442]                           if (!has_future || version < "1.8.0") {
[16:04:50.442]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.442]                               "", base::R.version$version.string), 
[16:04:50.442]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.442]                                 base::R.version$platform, 8 * 
[16:04:50.442]                                   base::.Machine$sizeof.pointer), 
[16:04:50.442]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.442]                                 "release", "version")], collapse = " "), 
[16:04:50.442]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.442]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.442]                               info)
[16:04:50.442]                             info <- base::paste(info, collapse = "; ")
[16:04:50.442]                             if (!has_future) {
[16:04:50.442]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.442]                                 info)
[16:04:50.442]                             }
[16:04:50.442]                             else {
[16:04:50.442]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.442]                                 info, version)
[16:04:50.442]                             }
[16:04:50.442]                             base::stop(msg)
[16:04:50.442]                           }
[16:04:50.442]                         })
[16:04:50.442]                       }
[16:04:50.442]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.442]                       base::options(mc.cores = 1L)
[16:04:50.442]                     }
[16:04:50.442]                     base::local({
[16:04:50.442]                       for (pkg in c("stats", "datasets")) {
[16:04:50.442]                         base::loadNamespace(pkg)
[16:04:50.442]                         base::library(pkg, character.only = TRUE)
[16:04:50.442]                       }
[16:04:50.442]                     })
[16:04:50.442]                   }
[16:04:50.442]                   options(future.plan = NULL)
[16:04:50.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.442]                 }
[16:04:50.442]                 ...future.workdir <- getwd()
[16:04:50.442]             }
[16:04:50.442]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.442]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.442]         }
[16:04:50.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.442]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.442]             base::names(...future.oldOptions))
[16:04:50.442]     }
[16:04:50.442]     if (FALSE) {
[16:04:50.442]     }
[16:04:50.442]     else {
[16:04:50.442]         if (TRUE) {
[16:04:50.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.442]                 open = "w")
[16:04:50.442]         }
[16:04:50.442]         else {
[16:04:50.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.442]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.442]         }
[16:04:50.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.442]             base::sink(type = "output", split = FALSE)
[16:04:50.442]             base::close(...future.stdout)
[16:04:50.442]         }, add = TRUE)
[16:04:50.442]     }
[16:04:50.442]     ...future.frame <- base::sys.nframe()
[16:04:50.442]     ...future.conditions <- base::list()
[16:04:50.442]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.442]     if (FALSE) {
[16:04:50.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.442]     }
[16:04:50.442]     ...future.result <- base::tryCatch({
[16:04:50.442]         base::withCallingHandlers({
[16:04:50.442]             ...future.value <- base::withVisible(base::local({
[16:04:50.442]                 ...future.makeSendCondition <- base::local({
[16:04:50.442]                   sendCondition <- NULL
[16:04:50.442]                   function(frame = 1L) {
[16:04:50.442]                     if (is.function(sendCondition)) 
[16:04:50.442]                       return(sendCondition)
[16:04:50.442]                     ns <- getNamespace("parallel")
[16:04:50.442]                     if (exists("sendData", mode = "function", 
[16:04:50.442]                       envir = ns)) {
[16:04:50.442]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.442]                         envir = ns)
[16:04:50.442]                       envir <- sys.frame(frame)
[16:04:50.442]                       master <- NULL
[16:04:50.442]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.442]                         !identical(envir, emptyenv())) {
[16:04:50.442]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.442]                           inherits = FALSE)) {
[16:04:50.442]                           master <- get("master", mode = "list", 
[16:04:50.442]                             envir = envir, inherits = FALSE)
[16:04:50.442]                           if (inherits(master, c("SOCKnode", 
[16:04:50.442]                             "SOCK0node"))) {
[16:04:50.442]                             sendCondition <<- function(cond) {
[16:04:50.442]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.442]                                 success = TRUE)
[16:04:50.442]                               parallel_sendData(master, data)
[16:04:50.442]                             }
[16:04:50.442]                             return(sendCondition)
[16:04:50.442]                           }
[16:04:50.442]                         }
[16:04:50.442]                         frame <- frame + 1L
[16:04:50.442]                         envir <- sys.frame(frame)
[16:04:50.442]                       }
[16:04:50.442]                     }
[16:04:50.442]                     sendCondition <<- function(cond) NULL
[16:04:50.442]                   }
[16:04:50.442]                 })
[16:04:50.442]                 withCallingHandlers({
[16:04:50.442]                   {
[16:04:50.442]                     lm(dist ~ speed + speed^2, data = cars)
[16:04:50.442]                   }
[16:04:50.442]                 }, immediateCondition = function(cond) {
[16:04:50.442]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.442]                   sendCondition(cond)
[16:04:50.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.442]                   {
[16:04:50.442]                     inherits <- base::inherits
[16:04:50.442]                     invokeRestart <- base::invokeRestart
[16:04:50.442]                     is.null <- base::is.null
[16:04:50.442]                     muffled <- FALSE
[16:04:50.442]                     if (inherits(cond, "message")) {
[16:04:50.442]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.442]                       if (muffled) 
[16:04:50.442]                         invokeRestart("muffleMessage")
[16:04:50.442]                     }
[16:04:50.442]                     else if (inherits(cond, "warning")) {
[16:04:50.442]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.442]                       if (muffled) 
[16:04:50.442]                         invokeRestart("muffleWarning")
[16:04:50.442]                     }
[16:04:50.442]                     else if (inherits(cond, "condition")) {
[16:04:50.442]                       if (!is.null(pattern)) {
[16:04:50.442]                         computeRestarts <- base::computeRestarts
[16:04:50.442]                         grepl <- base::grepl
[16:04:50.442]                         restarts <- computeRestarts(cond)
[16:04:50.442]                         for (restart in restarts) {
[16:04:50.442]                           name <- restart$name
[16:04:50.442]                           if (is.null(name)) 
[16:04:50.442]                             next
[16:04:50.442]                           if (!grepl(pattern, name)) 
[16:04:50.442]                             next
[16:04:50.442]                           invokeRestart(restart)
[16:04:50.442]                           muffled <- TRUE
[16:04:50.442]                           break
[16:04:50.442]                         }
[16:04:50.442]                       }
[16:04:50.442]                     }
[16:04:50.442]                     invisible(muffled)
[16:04:50.442]                   }
[16:04:50.442]                   muffleCondition(cond)
[16:04:50.442]                 })
[16:04:50.442]             }))
[16:04:50.442]             future::FutureResult(value = ...future.value$value, 
[16:04:50.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.442]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.442]                     ...future.globalenv.names))
[16:04:50.442]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.442]         }, condition = base::local({
[16:04:50.442]             c <- base::c
[16:04:50.442]             inherits <- base::inherits
[16:04:50.442]             invokeRestart <- base::invokeRestart
[16:04:50.442]             length <- base::length
[16:04:50.442]             list <- base::list
[16:04:50.442]             seq.int <- base::seq.int
[16:04:50.442]             signalCondition <- base::signalCondition
[16:04:50.442]             sys.calls <- base::sys.calls
[16:04:50.442]             `[[` <- base::`[[`
[16:04:50.442]             `+` <- base::`+`
[16:04:50.442]             `<<-` <- base::`<<-`
[16:04:50.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.442]                   3L)]
[16:04:50.442]             }
[16:04:50.442]             function(cond) {
[16:04:50.442]                 is_error <- inherits(cond, "error")
[16:04:50.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.442]                   NULL)
[16:04:50.442]                 if (is_error) {
[16:04:50.442]                   sessionInformation <- function() {
[16:04:50.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.442]                       search = base::search(), system = base::Sys.info())
[16:04:50.442]                   }
[16:04:50.442]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.442]                     cond$call), session = sessionInformation(), 
[16:04:50.442]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.442]                   signalCondition(cond)
[16:04:50.442]                 }
[16:04:50.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.442]                 "immediateCondition"))) {
[16:04:50.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.442]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.442]                   if (TRUE && !signal) {
[16:04:50.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.442]                     {
[16:04:50.442]                       inherits <- base::inherits
[16:04:50.442]                       invokeRestart <- base::invokeRestart
[16:04:50.442]                       is.null <- base::is.null
[16:04:50.442]                       muffled <- FALSE
[16:04:50.442]                       if (inherits(cond, "message")) {
[16:04:50.442]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.442]                         if (muffled) 
[16:04:50.442]                           invokeRestart("muffleMessage")
[16:04:50.442]                       }
[16:04:50.442]                       else if (inherits(cond, "warning")) {
[16:04:50.442]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.442]                         if (muffled) 
[16:04:50.442]                           invokeRestart("muffleWarning")
[16:04:50.442]                       }
[16:04:50.442]                       else if (inherits(cond, "condition")) {
[16:04:50.442]                         if (!is.null(pattern)) {
[16:04:50.442]                           computeRestarts <- base::computeRestarts
[16:04:50.442]                           grepl <- base::grepl
[16:04:50.442]                           restarts <- computeRestarts(cond)
[16:04:50.442]                           for (restart in restarts) {
[16:04:50.442]                             name <- restart$name
[16:04:50.442]                             if (is.null(name)) 
[16:04:50.442]                               next
[16:04:50.442]                             if (!grepl(pattern, name)) 
[16:04:50.442]                               next
[16:04:50.442]                             invokeRestart(restart)
[16:04:50.442]                             muffled <- TRUE
[16:04:50.442]                             break
[16:04:50.442]                           }
[16:04:50.442]                         }
[16:04:50.442]                       }
[16:04:50.442]                       invisible(muffled)
[16:04:50.442]                     }
[16:04:50.442]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.442]                   }
[16:04:50.442]                 }
[16:04:50.442]                 else {
[16:04:50.442]                   if (TRUE) {
[16:04:50.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.442]                     {
[16:04:50.442]                       inherits <- base::inherits
[16:04:50.442]                       invokeRestart <- base::invokeRestart
[16:04:50.442]                       is.null <- base::is.null
[16:04:50.442]                       muffled <- FALSE
[16:04:50.442]                       if (inherits(cond, "message")) {
[16:04:50.442]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.442]                         if (muffled) 
[16:04:50.442]                           invokeRestart("muffleMessage")
[16:04:50.442]                       }
[16:04:50.442]                       else if (inherits(cond, "warning")) {
[16:04:50.442]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.442]                         if (muffled) 
[16:04:50.442]                           invokeRestart("muffleWarning")
[16:04:50.442]                       }
[16:04:50.442]                       else if (inherits(cond, "condition")) {
[16:04:50.442]                         if (!is.null(pattern)) {
[16:04:50.442]                           computeRestarts <- base::computeRestarts
[16:04:50.442]                           grepl <- base::grepl
[16:04:50.442]                           restarts <- computeRestarts(cond)
[16:04:50.442]                           for (restart in restarts) {
[16:04:50.442]                             name <- restart$name
[16:04:50.442]                             if (is.null(name)) 
[16:04:50.442]                               next
[16:04:50.442]                             if (!grepl(pattern, name)) 
[16:04:50.442]                               next
[16:04:50.442]                             invokeRestart(restart)
[16:04:50.442]                             muffled <- TRUE
[16:04:50.442]                             break
[16:04:50.442]                           }
[16:04:50.442]                         }
[16:04:50.442]                       }
[16:04:50.442]                       invisible(muffled)
[16:04:50.442]                     }
[16:04:50.442]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.442]                   }
[16:04:50.442]                 }
[16:04:50.442]             }
[16:04:50.442]         }))
[16:04:50.442]     }, error = function(ex) {
[16:04:50.442]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.442]                 ...future.rng), started = ...future.startTime, 
[16:04:50.442]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.442]             version = "1.8"), class = "FutureResult")
[16:04:50.442]     }, finally = {
[16:04:50.442]         if (!identical(...future.workdir, getwd())) 
[16:04:50.442]             setwd(...future.workdir)
[16:04:50.442]         {
[16:04:50.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.442]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.442]             }
[16:04:50.442]             base::options(...future.oldOptions)
[16:04:50.442]             if (.Platform$OS.type == "windows") {
[16:04:50.442]                 old_names <- names(...future.oldEnvVars)
[16:04:50.442]                 envs <- base::Sys.getenv()
[16:04:50.442]                 names <- names(envs)
[16:04:50.442]                 common <- intersect(names, old_names)
[16:04:50.442]                 added <- setdiff(names, old_names)
[16:04:50.442]                 removed <- setdiff(old_names, names)
[16:04:50.442]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.442]                   envs[common]]
[16:04:50.442]                 NAMES <- toupper(changed)
[16:04:50.442]                 args <- list()
[16:04:50.442]                 for (kk in seq_along(NAMES)) {
[16:04:50.442]                   name <- changed[[kk]]
[16:04:50.442]                   NAME <- NAMES[[kk]]
[16:04:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.442]                     next
[16:04:50.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.442]                 }
[16:04:50.442]                 NAMES <- toupper(added)
[16:04:50.442]                 for (kk in seq_along(NAMES)) {
[16:04:50.442]                   name <- added[[kk]]
[16:04:50.442]                   NAME <- NAMES[[kk]]
[16:04:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.442]                     next
[16:04:50.442]                   args[[name]] <- ""
[16:04:50.442]                 }
[16:04:50.442]                 NAMES <- toupper(removed)
[16:04:50.442]                 for (kk in seq_along(NAMES)) {
[16:04:50.442]                   name <- removed[[kk]]
[16:04:50.442]                   NAME <- NAMES[[kk]]
[16:04:50.442]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.442]                     next
[16:04:50.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.442]                 }
[16:04:50.442]                 if (length(args) > 0) 
[16:04:50.442]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.442]             }
[16:04:50.442]             else {
[16:04:50.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.442]             }
[16:04:50.442]             {
[16:04:50.442]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.442]                   0L) {
[16:04:50.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.442]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.442]                   base::options(opts)
[16:04:50.442]                 }
[16:04:50.442]                 {
[16:04:50.442]                   {
[16:04:50.442]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.442]                     NULL
[16:04:50.442]                   }
[16:04:50.442]                   options(future.plan = NULL)
[16:04:50.442]                   if (is.na(NA_character_)) 
[16:04:50.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.442]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.442]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.442]                     envir = parent.frame()) 
[16:04:50.442]                   {
[16:04:50.442]                     if (is.function(workers)) 
[16:04:50.442]                       workers <- workers()
[16:04:50.442]                     workers <- structure(as.integer(workers), 
[16:04:50.442]                       class = class(workers))
[16:04:50.442]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.442]                       workers >= 1)
[16:04:50.442]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.442]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.442]                     }
[16:04:50.442]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.442]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.442]                       envir = envir)
[16:04:50.442]                     if (!future$lazy) 
[16:04:50.442]                       future <- run(future)
[16:04:50.442]                     invisible(future)
[16:04:50.442]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.442]                 }
[16:04:50.442]             }
[16:04:50.442]         }
[16:04:50.442]     })
[16:04:50.442]     if (TRUE) {
[16:04:50.442]         base::sink(type = "output", split = FALSE)
[16:04:50.442]         if (TRUE) {
[16:04:50.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.442]         }
[16:04:50.442]         else {
[16:04:50.442]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.442]         }
[16:04:50.442]         base::close(...future.stdout)
[16:04:50.442]         ...future.stdout <- NULL
[16:04:50.442]     }
[16:04:50.442]     ...future.result$conditions <- ...future.conditions
[16:04:50.442]     ...future.result$finished <- base::Sys.time()
[16:04:50.442]     ...future.result
[16:04:50.442] }
[16:04:50.445] MultisessionFuture started
[16:04:50.445] - Launch lazy future ... done
[16:04:50.446] run() for ‘MultisessionFuture’ ... done
[16:04:50.446] result() for ClusterFuture ...
[16:04:50.446] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.446] - Validating connection of MultisessionFuture
[16:04:50.493] - received message: FutureResult
[16:04:50.493] - Received FutureResult
[16:04:50.493] - Erased future from FutureRegistry
[16:04:50.493] result() for ClusterFuture ...
[16:04:50.493] - result already collected: FutureResult
[16:04:50.494] result() for ClusterFuture ... done
[16:04:50.494] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.494] result() for ClusterFuture ... done
[16:04:50.494] result() for ClusterFuture ...
[16:04:50.494] - result already collected: FutureResult
[16:04:50.494] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[16:04:50.497] getGlobalsAndPackages() ...
[16:04:50.497] Searching for globals...
[16:04:50.499] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[16:04:50.499] Searching for globals ... DONE
[16:04:50.499] Resolving globals: FALSE
[16:04:50.499] 
[16:04:50.500] - packages: [2] ‘stats’, ‘datasets’
[16:04:50.500] getGlobalsAndPackages() ... DONE
[16:04:50.500] run() for ‘Future’ ...
[16:04:50.500] - state: ‘created’
[16:04:50.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.514]   - Field: ‘node’
[16:04:50.515]   - Field: ‘label’
[16:04:50.515]   - Field: ‘local’
[16:04:50.515]   - Field: ‘owner’
[16:04:50.515]   - Field: ‘envir’
[16:04:50.515]   - Field: ‘workers’
[16:04:50.515]   - Field: ‘packages’
[16:04:50.515]   - Field: ‘gc’
[16:04:50.515]   - Field: ‘conditions’
[16:04:50.515]   - Field: ‘persistent’
[16:04:50.515]   - Field: ‘expr’
[16:04:50.516]   - Field: ‘uuid’
[16:04:50.516]   - Field: ‘seed’
[16:04:50.516]   - Field: ‘version’
[16:04:50.516]   - Field: ‘result’
[16:04:50.516]   - Field: ‘asynchronous’
[16:04:50.516]   - Field: ‘calls’
[16:04:50.516]   - Field: ‘globals’
[16:04:50.516]   - Field: ‘stdout’
[16:04:50.516]   - Field: ‘earlySignal’
[16:04:50.516]   - Field: ‘lazy’
[16:04:50.516]   - Field: ‘state’
[16:04:50.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.517] - Launch lazy future ...
[16:04:50.517] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:50.517] Packages needed by future strategies (n = 0): <none>
[16:04:50.518] {
[16:04:50.518]     {
[16:04:50.518]         {
[16:04:50.518]             ...future.startTime <- base::Sys.time()
[16:04:50.518]             {
[16:04:50.518]                 {
[16:04:50.518]                   {
[16:04:50.518]                     {
[16:04:50.518]                       {
[16:04:50.518]                         base::local({
[16:04:50.518]                           has_future <- base::requireNamespace("future", 
[16:04:50.518]                             quietly = TRUE)
[16:04:50.518]                           if (has_future) {
[16:04:50.518]                             ns <- base::getNamespace("future")
[16:04:50.518]                             version <- ns[[".package"]][["version"]]
[16:04:50.518]                             if (is.null(version)) 
[16:04:50.518]                               version <- utils::packageVersion("future")
[16:04:50.518]                           }
[16:04:50.518]                           else {
[16:04:50.518]                             version <- NULL
[16:04:50.518]                           }
[16:04:50.518]                           if (!has_future || version < "1.8.0") {
[16:04:50.518]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.518]                               "", base::R.version$version.string), 
[16:04:50.518]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.518]                                 base::R.version$platform, 8 * 
[16:04:50.518]                                   base::.Machine$sizeof.pointer), 
[16:04:50.518]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.518]                                 "release", "version")], collapse = " "), 
[16:04:50.518]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.518]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.518]                               info)
[16:04:50.518]                             info <- base::paste(info, collapse = "; ")
[16:04:50.518]                             if (!has_future) {
[16:04:50.518]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.518]                                 info)
[16:04:50.518]                             }
[16:04:50.518]                             else {
[16:04:50.518]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.518]                                 info, version)
[16:04:50.518]                             }
[16:04:50.518]                             base::stop(msg)
[16:04:50.518]                           }
[16:04:50.518]                         })
[16:04:50.518]                       }
[16:04:50.518]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.518]                       base::options(mc.cores = 1L)
[16:04:50.518]                     }
[16:04:50.518]                     base::local({
[16:04:50.518]                       for (pkg in c("stats", "datasets")) {
[16:04:50.518]                         base::loadNamespace(pkg)
[16:04:50.518]                         base::library(pkg, character.only = TRUE)
[16:04:50.518]                       }
[16:04:50.518]                     })
[16:04:50.518]                   }
[16:04:50.518]                   options(future.plan = NULL)
[16:04:50.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.518]                 }
[16:04:50.518]                 ...future.workdir <- getwd()
[16:04:50.518]             }
[16:04:50.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.518]         }
[16:04:50.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.518]             base::names(...future.oldOptions))
[16:04:50.518]     }
[16:04:50.518]     if (FALSE) {
[16:04:50.518]     }
[16:04:50.518]     else {
[16:04:50.518]         if (TRUE) {
[16:04:50.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.518]                 open = "w")
[16:04:50.518]         }
[16:04:50.518]         else {
[16:04:50.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.518]         }
[16:04:50.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.518]             base::sink(type = "output", split = FALSE)
[16:04:50.518]             base::close(...future.stdout)
[16:04:50.518]         }, add = TRUE)
[16:04:50.518]     }
[16:04:50.518]     ...future.frame <- base::sys.nframe()
[16:04:50.518]     ...future.conditions <- base::list()
[16:04:50.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.518]     if (FALSE) {
[16:04:50.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.518]     }
[16:04:50.518]     ...future.result <- base::tryCatch({
[16:04:50.518]         base::withCallingHandlers({
[16:04:50.518]             ...future.value <- base::withVisible(base::local({
[16:04:50.518]                 ...future.makeSendCondition <- base::local({
[16:04:50.518]                   sendCondition <- NULL
[16:04:50.518]                   function(frame = 1L) {
[16:04:50.518]                     if (is.function(sendCondition)) 
[16:04:50.518]                       return(sendCondition)
[16:04:50.518]                     ns <- getNamespace("parallel")
[16:04:50.518]                     if (exists("sendData", mode = "function", 
[16:04:50.518]                       envir = ns)) {
[16:04:50.518]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.518]                         envir = ns)
[16:04:50.518]                       envir <- sys.frame(frame)
[16:04:50.518]                       master <- NULL
[16:04:50.518]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.518]                         !identical(envir, emptyenv())) {
[16:04:50.518]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.518]                           inherits = FALSE)) {
[16:04:50.518]                           master <- get("master", mode = "list", 
[16:04:50.518]                             envir = envir, inherits = FALSE)
[16:04:50.518]                           if (inherits(master, c("SOCKnode", 
[16:04:50.518]                             "SOCK0node"))) {
[16:04:50.518]                             sendCondition <<- function(cond) {
[16:04:50.518]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.518]                                 success = TRUE)
[16:04:50.518]                               parallel_sendData(master, data)
[16:04:50.518]                             }
[16:04:50.518]                             return(sendCondition)
[16:04:50.518]                           }
[16:04:50.518]                         }
[16:04:50.518]                         frame <- frame + 1L
[16:04:50.518]                         envir <- sys.frame(frame)
[16:04:50.518]                       }
[16:04:50.518]                     }
[16:04:50.518]                     sendCondition <<- function(cond) NULL
[16:04:50.518]                   }
[16:04:50.518]                 })
[16:04:50.518]                 withCallingHandlers({
[16:04:50.518]                   {
[16:04:50.518]                     lm(dist ~ speed + I(speed^2), data = cars)
[16:04:50.518]                   }
[16:04:50.518]                 }, immediateCondition = function(cond) {
[16:04:50.518]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.518]                   sendCondition(cond)
[16:04:50.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.518]                   {
[16:04:50.518]                     inherits <- base::inherits
[16:04:50.518]                     invokeRestart <- base::invokeRestart
[16:04:50.518]                     is.null <- base::is.null
[16:04:50.518]                     muffled <- FALSE
[16:04:50.518]                     if (inherits(cond, "message")) {
[16:04:50.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.518]                       if (muffled) 
[16:04:50.518]                         invokeRestart("muffleMessage")
[16:04:50.518]                     }
[16:04:50.518]                     else if (inherits(cond, "warning")) {
[16:04:50.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.518]                       if (muffled) 
[16:04:50.518]                         invokeRestart("muffleWarning")
[16:04:50.518]                     }
[16:04:50.518]                     else if (inherits(cond, "condition")) {
[16:04:50.518]                       if (!is.null(pattern)) {
[16:04:50.518]                         computeRestarts <- base::computeRestarts
[16:04:50.518]                         grepl <- base::grepl
[16:04:50.518]                         restarts <- computeRestarts(cond)
[16:04:50.518]                         for (restart in restarts) {
[16:04:50.518]                           name <- restart$name
[16:04:50.518]                           if (is.null(name)) 
[16:04:50.518]                             next
[16:04:50.518]                           if (!grepl(pattern, name)) 
[16:04:50.518]                             next
[16:04:50.518]                           invokeRestart(restart)
[16:04:50.518]                           muffled <- TRUE
[16:04:50.518]                           break
[16:04:50.518]                         }
[16:04:50.518]                       }
[16:04:50.518]                     }
[16:04:50.518]                     invisible(muffled)
[16:04:50.518]                   }
[16:04:50.518]                   muffleCondition(cond)
[16:04:50.518]                 })
[16:04:50.518]             }))
[16:04:50.518]             future::FutureResult(value = ...future.value$value, 
[16:04:50.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.518]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.518]                     ...future.globalenv.names))
[16:04:50.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.518]         }, condition = base::local({
[16:04:50.518]             c <- base::c
[16:04:50.518]             inherits <- base::inherits
[16:04:50.518]             invokeRestart <- base::invokeRestart
[16:04:50.518]             length <- base::length
[16:04:50.518]             list <- base::list
[16:04:50.518]             seq.int <- base::seq.int
[16:04:50.518]             signalCondition <- base::signalCondition
[16:04:50.518]             sys.calls <- base::sys.calls
[16:04:50.518]             `[[` <- base::`[[`
[16:04:50.518]             `+` <- base::`+`
[16:04:50.518]             `<<-` <- base::`<<-`
[16:04:50.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.518]                   3L)]
[16:04:50.518]             }
[16:04:50.518]             function(cond) {
[16:04:50.518]                 is_error <- inherits(cond, "error")
[16:04:50.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.518]                   NULL)
[16:04:50.518]                 if (is_error) {
[16:04:50.518]                   sessionInformation <- function() {
[16:04:50.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.518]                       search = base::search(), system = base::Sys.info())
[16:04:50.518]                   }
[16:04:50.518]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.518]                     cond$call), session = sessionInformation(), 
[16:04:50.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.518]                   signalCondition(cond)
[16:04:50.518]                 }
[16:04:50.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.518]                 "immediateCondition"))) {
[16:04:50.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.518]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.518]                   if (TRUE && !signal) {
[16:04:50.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.518]                     {
[16:04:50.518]                       inherits <- base::inherits
[16:04:50.518]                       invokeRestart <- base::invokeRestart
[16:04:50.518]                       is.null <- base::is.null
[16:04:50.518]                       muffled <- FALSE
[16:04:50.518]                       if (inherits(cond, "message")) {
[16:04:50.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.518]                         if (muffled) 
[16:04:50.518]                           invokeRestart("muffleMessage")
[16:04:50.518]                       }
[16:04:50.518]                       else if (inherits(cond, "warning")) {
[16:04:50.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.518]                         if (muffled) 
[16:04:50.518]                           invokeRestart("muffleWarning")
[16:04:50.518]                       }
[16:04:50.518]                       else if (inherits(cond, "condition")) {
[16:04:50.518]                         if (!is.null(pattern)) {
[16:04:50.518]                           computeRestarts <- base::computeRestarts
[16:04:50.518]                           grepl <- base::grepl
[16:04:50.518]                           restarts <- computeRestarts(cond)
[16:04:50.518]                           for (restart in restarts) {
[16:04:50.518]                             name <- restart$name
[16:04:50.518]                             if (is.null(name)) 
[16:04:50.518]                               next
[16:04:50.518]                             if (!grepl(pattern, name)) 
[16:04:50.518]                               next
[16:04:50.518]                             invokeRestart(restart)
[16:04:50.518]                             muffled <- TRUE
[16:04:50.518]                             break
[16:04:50.518]                           }
[16:04:50.518]                         }
[16:04:50.518]                       }
[16:04:50.518]                       invisible(muffled)
[16:04:50.518]                     }
[16:04:50.518]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.518]                   }
[16:04:50.518]                 }
[16:04:50.518]                 else {
[16:04:50.518]                   if (TRUE) {
[16:04:50.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.518]                     {
[16:04:50.518]                       inherits <- base::inherits
[16:04:50.518]                       invokeRestart <- base::invokeRestart
[16:04:50.518]                       is.null <- base::is.null
[16:04:50.518]                       muffled <- FALSE
[16:04:50.518]                       if (inherits(cond, "message")) {
[16:04:50.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.518]                         if (muffled) 
[16:04:50.518]                           invokeRestart("muffleMessage")
[16:04:50.518]                       }
[16:04:50.518]                       else if (inherits(cond, "warning")) {
[16:04:50.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.518]                         if (muffled) 
[16:04:50.518]                           invokeRestart("muffleWarning")
[16:04:50.518]                       }
[16:04:50.518]                       else if (inherits(cond, "condition")) {
[16:04:50.518]                         if (!is.null(pattern)) {
[16:04:50.518]                           computeRestarts <- base::computeRestarts
[16:04:50.518]                           grepl <- base::grepl
[16:04:50.518]                           restarts <- computeRestarts(cond)
[16:04:50.518]                           for (restart in restarts) {
[16:04:50.518]                             name <- restart$name
[16:04:50.518]                             if (is.null(name)) 
[16:04:50.518]                               next
[16:04:50.518]                             if (!grepl(pattern, name)) 
[16:04:50.518]                               next
[16:04:50.518]                             invokeRestart(restart)
[16:04:50.518]                             muffled <- TRUE
[16:04:50.518]                             break
[16:04:50.518]                           }
[16:04:50.518]                         }
[16:04:50.518]                       }
[16:04:50.518]                       invisible(muffled)
[16:04:50.518]                     }
[16:04:50.518]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.518]                   }
[16:04:50.518]                 }
[16:04:50.518]             }
[16:04:50.518]         }))
[16:04:50.518]     }, error = function(ex) {
[16:04:50.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.518]                 ...future.rng), started = ...future.startTime, 
[16:04:50.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.518]             version = "1.8"), class = "FutureResult")
[16:04:50.518]     }, finally = {
[16:04:50.518]         if (!identical(...future.workdir, getwd())) 
[16:04:50.518]             setwd(...future.workdir)
[16:04:50.518]         {
[16:04:50.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.518]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.518]             }
[16:04:50.518]             base::options(...future.oldOptions)
[16:04:50.518]             if (.Platform$OS.type == "windows") {
[16:04:50.518]                 old_names <- names(...future.oldEnvVars)
[16:04:50.518]                 envs <- base::Sys.getenv()
[16:04:50.518]                 names <- names(envs)
[16:04:50.518]                 common <- intersect(names, old_names)
[16:04:50.518]                 added <- setdiff(names, old_names)
[16:04:50.518]                 removed <- setdiff(old_names, names)
[16:04:50.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.518]                   envs[common]]
[16:04:50.518]                 NAMES <- toupper(changed)
[16:04:50.518]                 args <- list()
[16:04:50.518]                 for (kk in seq_along(NAMES)) {
[16:04:50.518]                   name <- changed[[kk]]
[16:04:50.518]                   NAME <- NAMES[[kk]]
[16:04:50.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.518]                     next
[16:04:50.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.518]                 }
[16:04:50.518]                 NAMES <- toupper(added)
[16:04:50.518]                 for (kk in seq_along(NAMES)) {
[16:04:50.518]                   name <- added[[kk]]
[16:04:50.518]                   NAME <- NAMES[[kk]]
[16:04:50.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.518]                     next
[16:04:50.518]                   args[[name]] <- ""
[16:04:50.518]                 }
[16:04:50.518]                 NAMES <- toupper(removed)
[16:04:50.518]                 for (kk in seq_along(NAMES)) {
[16:04:50.518]                   name <- removed[[kk]]
[16:04:50.518]                   NAME <- NAMES[[kk]]
[16:04:50.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.518]                     next
[16:04:50.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.518]                 }
[16:04:50.518]                 if (length(args) > 0) 
[16:04:50.518]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.518]             }
[16:04:50.518]             else {
[16:04:50.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.518]             }
[16:04:50.518]             {
[16:04:50.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.518]                   0L) {
[16:04:50.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.518]                   base::options(opts)
[16:04:50.518]                 }
[16:04:50.518]                 {
[16:04:50.518]                   {
[16:04:50.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.518]                     NULL
[16:04:50.518]                   }
[16:04:50.518]                   options(future.plan = NULL)
[16:04:50.518]                   if (is.na(NA_character_)) 
[16:04:50.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.518]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.518]                     envir = parent.frame()) 
[16:04:50.518]                   {
[16:04:50.518]                     if (is.function(workers)) 
[16:04:50.518]                       workers <- workers()
[16:04:50.518]                     workers <- structure(as.integer(workers), 
[16:04:50.518]                       class = class(workers))
[16:04:50.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.518]                       workers >= 1)
[16:04:50.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.518]                     }
[16:04:50.518]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.518]                       envir = envir)
[16:04:50.518]                     if (!future$lazy) 
[16:04:50.518]                       future <- run(future)
[16:04:50.518]                     invisible(future)
[16:04:50.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.518]                 }
[16:04:50.518]             }
[16:04:50.518]         }
[16:04:50.518]     })
[16:04:50.518]     if (TRUE) {
[16:04:50.518]         base::sink(type = "output", split = FALSE)
[16:04:50.518]         if (TRUE) {
[16:04:50.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.518]         }
[16:04:50.518]         else {
[16:04:50.518]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.518]         }
[16:04:50.518]         base::close(...future.stdout)
[16:04:50.518]         ...future.stdout <- NULL
[16:04:50.518]     }
[16:04:50.518]     ...future.result$conditions <- ...future.conditions
[16:04:50.518]     ...future.result$finished <- base::Sys.time()
[16:04:50.518]     ...future.result
[16:04:50.518] }
[16:04:50.521] MultisessionFuture started
[16:04:50.521] - Launch lazy future ... done
[16:04:50.521] run() for ‘MultisessionFuture’ ... done
[16:04:50.521] result() for ClusterFuture ...
[16:04:50.521] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.521] - Validating connection of MultisessionFuture
[16:04:50.571] - received message: FutureResult
[16:04:50.571] - Received FutureResult
[16:04:50.571] - Erased future from FutureRegistry
[16:04:50.571] result() for ClusterFuture ...
[16:04:50.571] - result already collected: FutureResult
[16:04:50.571] result() for ClusterFuture ... done
[16:04:50.571] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.571] result() for ClusterFuture ... done
[16:04:50.572] result() for ClusterFuture ...
[16:04:50.572] - result already collected: FutureResult
[16:04:50.572] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[16:04:50.575] getGlobalsAndPackages() ...
[16:04:50.575] Searching for globals...
[16:04:50.576] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[16:04:50.576] Searching for globals ... DONE
[16:04:50.576] Resolving globals: FALSE
[16:04:50.577] 
[16:04:50.577] - packages: [2] ‘stats’, ‘datasets’
[16:04:50.577] getGlobalsAndPackages() ... DONE
[16:04:50.577] run() for ‘Future’ ...
[16:04:50.578] - state: ‘created’
[16:04:50.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.591] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.592]   - Field: ‘node’
[16:04:50.592]   - Field: ‘label’
[16:04:50.592]   - Field: ‘local’
[16:04:50.592]   - Field: ‘owner’
[16:04:50.592]   - Field: ‘envir’
[16:04:50.592]   - Field: ‘workers’
[16:04:50.592]   - Field: ‘packages’
[16:04:50.592]   - Field: ‘gc’
[16:04:50.592]   - Field: ‘conditions’
[16:04:50.592]   - Field: ‘persistent’
[16:04:50.593]   - Field: ‘expr’
[16:04:50.593]   - Field: ‘uuid’
[16:04:50.593]   - Field: ‘seed’
[16:04:50.593]   - Field: ‘version’
[16:04:50.593]   - Field: ‘result’
[16:04:50.593]   - Field: ‘asynchronous’
[16:04:50.593]   - Field: ‘calls’
[16:04:50.593]   - Field: ‘globals’
[16:04:50.593]   - Field: ‘stdout’
[16:04:50.593]   - Field: ‘earlySignal’
[16:04:50.593]   - Field: ‘lazy’
[16:04:50.594]   - Field: ‘state’
[16:04:50.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.594] - Launch lazy future ...
[16:04:50.594] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[16:04:50.594] Packages needed by future strategies (n = 0): <none>
[16:04:50.595] {
[16:04:50.595]     {
[16:04:50.595]         {
[16:04:50.595]             ...future.startTime <- base::Sys.time()
[16:04:50.595]             {
[16:04:50.595]                 {
[16:04:50.595]                   {
[16:04:50.595]                     {
[16:04:50.595]                       {
[16:04:50.595]                         base::local({
[16:04:50.595]                           has_future <- base::requireNamespace("future", 
[16:04:50.595]                             quietly = TRUE)
[16:04:50.595]                           if (has_future) {
[16:04:50.595]                             ns <- base::getNamespace("future")
[16:04:50.595]                             version <- ns[[".package"]][["version"]]
[16:04:50.595]                             if (is.null(version)) 
[16:04:50.595]                               version <- utils::packageVersion("future")
[16:04:50.595]                           }
[16:04:50.595]                           else {
[16:04:50.595]                             version <- NULL
[16:04:50.595]                           }
[16:04:50.595]                           if (!has_future || version < "1.8.0") {
[16:04:50.595]                             info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.595]                               "", base::R.version$version.string), 
[16:04:50.595]                               platform = base::sprintf("%s (%s-bit)", 
[16:04:50.595]                                 base::R.version$platform, 8 * 
[16:04:50.595]                                   base::.Machine$sizeof.pointer), 
[16:04:50.595]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.595]                                 "release", "version")], collapse = " "), 
[16:04:50.595]                               hostname = base::Sys.info()[["nodename"]])
[16:04:50.595]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.595]                               info)
[16:04:50.595]                             info <- base::paste(info, collapse = "; ")
[16:04:50.595]                             if (!has_future) {
[16:04:50.595]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.595]                                 info)
[16:04:50.595]                             }
[16:04:50.595]                             else {
[16:04:50.595]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.595]                                 info, version)
[16:04:50.595]                             }
[16:04:50.595]                             base::stop(msg)
[16:04:50.595]                           }
[16:04:50.595]                         })
[16:04:50.595]                       }
[16:04:50.595]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.595]                       base::options(mc.cores = 1L)
[16:04:50.595]                     }
[16:04:50.595]                     base::local({
[16:04:50.595]                       for (pkg in c("stats", "datasets")) {
[16:04:50.595]                         base::loadNamespace(pkg)
[16:04:50.595]                         base::library(pkg, character.only = TRUE)
[16:04:50.595]                       }
[16:04:50.595]                     })
[16:04:50.595]                   }
[16:04:50.595]                   options(future.plan = NULL)
[16:04:50.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.595]                 }
[16:04:50.595]                 ...future.workdir <- getwd()
[16:04:50.595]             }
[16:04:50.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.595]         }
[16:04:50.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.595]             base::names(...future.oldOptions))
[16:04:50.595]     }
[16:04:50.595]     if (FALSE) {
[16:04:50.595]     }
[16:04:50.595]     else {
[16:04:50.595]         if (TRUE) {
[16:04:50.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.595]                 open = "w")
[16:04:50.595]         }
[16:04:50.595]         else {
[16:04:50.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.595]         }
[16:04:50.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.595]             base::sink(type = "output", split = FALSE)
[16:04:50.595]             base::close(...future.stdout)
[16:04:50.595]         }, add = TRUE)
[16:04:50.595]     }
[16:04:50.595]     ...future.frame <- base::sys.nframe()
[16:04:50.595]     ...future.conditions <- base::list()
[16:04:50.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.595]     if (FALSE) {
[16:04:50.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.595]     }
[16:04:50.595]     ...future.result <- base::tryCatch({
[16:04:50.595]         base::withCallingHandlers({
[16:04:50.595]             ...future.value <- base::withVisible(base::local({
[16:04:50.595]                 ...future.makeSendCondition <- base::local({
[16:04:50.595]                   sendCondition <- NULL
[16:04:50.595]                   function(frame = 1L) {
[16:04:50.595]                     if (is.function(sendCondition)) 
[16:04:50.595]                       return(sendCondition)
[16:04:50.595]                     ns <- getNamespace("parallel")
[16:04:50.595]                     if (exists("sendData", mode = "function", 
[16:04:50.595]                       envir = ns)) {
[16:04:50.595]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.595]                         envir = ns)
[16:04:50.595]                       envir <- sys.frame(frame)
[16:04:50.595]                       master <- NULL
[16:04:50.595]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.595]                         !identical(envir, emptyenv())) {
[16:04:50.595]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.595]                           inherits = FALSE)) {
[16:04:50.595]                           master <- get("master", mode = "list", 
[16:04:50.595]                             envir = envir, inherits = FALSE)
[16:04:50.595]                           if (inherits(master, c("SOCKnode", 
[16:04:50.595]                             "SOCK0node"))) {
[16:04:50.595]                             sendCondition <<- function(cond) {
[16:04:50.595]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.595]                                 success = TRUE)
[16:04:50.595]                               parallel_sendData(master, data)
[16:04:50.595]                             }
[16:04:50.595]                             return(sendCondition)
[16:04:50.595]                           }
[16:04:50.595]                         }
[16:04:50.595]                         frame <- frame + 1L
[16:04:50.595]                         envir <- sys.frame(frame)
[16:04:50.595]                       }
[16:04:50.595]                     }
[16:04:50.595]                     sendCondition <<- function(cond) NULL
[16:04:50.595]                   }
[16:04:50.595]                 })
[16:04:50.595]                 withCallingHandlers({
[16:04:50.595]                   {
[16:04:50.595]                     lm(dist ~ poly(speed, 2), data = cars)
[16:04:50.595]                   }
[16:04:50.595]                 }, immediateCondition = function(cond) {
[16:04:50.595]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.595]                   sendCondition(cond)
[16:04:50.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.595]                   {
[16:04:50.595]                     inherits <- base::inherits
[16:04:50.595]                     invokeRestart <- base::invokeRestart
[16:04:50.595]                     is.null <- base::is.null
[16:04:50.595]                     muffled <- FALSE
[16:04:50.595]                     if (inherits(cond, "message")) {
[16:04:50.595]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.595]                       if (muffled) 
[16:04:50.595]                         invokeRestart("muffleMessage")
[16:04:50.595]                     }
[16:04:50.595]                     else if (inherits(cond, "warning")) {
[16:04:50.595]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.595]                       if (muffled) 
[16:04:50.595]                         invokeRestart("muffleWarning")
[16:04:50.595]                     }
[16:04:50.595]                     else if (inherits(cond, "condition")) {
[16:04:50.595]                       if (!is.null(pattern)) {
[16:04:50.595]                         computeRestarts <- base::computeRestarts
[16:04:50.595]                         grepl <- base::grepl
[16:04:50.595]                         restarts <- computeRestarts(cond)
[16:04:50.595]                         for (restart in restarts) {
[16:04:50.595]                           name <- restart$name
[16:04:50.595]                           if (is.null(name)) 
[16:04:50.595]                             next
[16:04:50.595]                           if (!grepl(pattern, name)) 
[16:04:50.595]                             next
[16:04:50.595]                           invokeRestart(restart)
[16:04:50.595]                           muffled <- TRUE
[16:04:50.595]                           break
[16:04:50.595]                         }
[16:04:50.595]                       }
[16:04:50.595]                     }
[16:04:50.595]                     invisible(muffled)
[16:04:50.595]                   }
[16:04:50.595]                   muffleCondition(cond)
[16:04:50.595]                 })
[16:04:50.595]             }))
[16:04:50.595]             future::FutureResult(value = ...future.value$value, 
[16:04:50.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.595]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.595]                     ...future.globalenv.names))
[16:04:50.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.595]         }, condition = base::local({
[16:04:50.595]             c <- base::c
[16:04:50.595]             inherits <- base::inherits
[16:04:50.595]             invokeRestart <- base::invokeRestart
[16:04:50.595]             length <- base::length
[16:04:50.595]             list <- base::list
[16:04:50.595]             seq.int <- base::seq.int
[16:04:50.595]             signalCondition <- base::signalCondition
[16:04:50.595]             sys.calls <- base::sys.calls
[16:04:50.595]             `[[` <- base::`[[`
[16:04:50.595]             `+` <- base::`+`
[16:04:50.595]             `<<-` <- base::`<<-`
[16:04:50.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.595]                   3L)]
[16:04:50.595]             }
[16:04:50.595]             function(cond) {
[16:04:50.595]                 is_error <- inherits(cond, "error")
[16:04:50.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.595]                   NULL)
[16:04:50.595]                 if (is_error) {
[16:04:50.595]                   sessionInformation <- function() {
[16:04:50.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.595]                       search = base::search(), system = base::Sys.info())
[16:04:50.595]                   }
[16:04:50.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.595]                     cond$call), session = sessionInformation(), 
[16:04:50.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.595]                   signalCondition(cond)
[16:04:50.595]                 }
[16:04:50.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.595]                 "immediateCondition"))) {
[16:04:50.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.595]                   if (TRUE && !signal) {
[16:04:50.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.595]                     {
[16:04:50.595]                       inherits <- base::inherits
[16:04:50.595]                       invokeRestart <- base::invokeRestart
[16:04:50.595]                       is.null <- base::is.null
[16:04:50.595]                       muffled <- FALSE
[16:04:50.595]                       if (inherits(cond, "message")) {
[16:04:50.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.595]                         if (muffled) 
[16:04:50.595]                           invokeRestart("muffleMessage")
[16:04:50.595]                       }
[16:04:50.595]                       else if (inherits(cond, "warning")) {
[16:04:50.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.595]                         if (muffled) 
[16:04:50.595]                           invokeRestart("muffleWarning")
[16:04:50.595]                       }
[16:04:50.595]                       else if (inherits(cond, "condition")) {
[16:04:50.595]                         if (!is.null(pattern)) {
[16:04:50.595]                           computeRestarts <- base::computeRestarts
[16:04:50.595]                           grepl <- base::grepl
[16:04:50.595]                           restarts <- computeRestarts(cond)
[16:04:50.595]                           for (restart in restarts) {
[16:04:50.595]                             name <- restart$name
[16:04:50.595]                             if (is.null(name)) 
[16:04:50.595]                               next
[16:04:50.595]                             if (!grepl(pattern, name)) 
[16:04:50.595]                               next
[16:04:50.595]                             invokeRestart(restart)
[16:04:50.595]                             muffled <- TRUE
[16:04:50.595]                             break
[16:04:50.595]                           }
[16:04:50.595]                         }
[16:04:50.595]                       }
[16:04:50.595]                       invisible(muffled)
[16:04:50.595]                     }
[16:04:50.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.595]                   }
[16:04:50.595]                 }
[16:04:50.595]                 else {
[16:04:50.595]                   if (TRUE) {
[16:04:50.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.595]                     {
[16:04:50.595]                       inherits <- base::inherits
[16:04:50.595]                       invokeRestart <- base::invokeRestart
[16:04:50.595]                       is.null <- base::is.null
[16:04:50.595]                       muffled <- FALSE
[16:04:50.595]                       if (inherits(cond, "message")) {
[16:04:50.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.595]                         if (muffled) 
[16:04:50.595]                           invokeRestart("muffleMessage")
[16:04:50.595]                       }
[16:04:50.595]                       else if (inherits(cond, "warning")) {
[16:04:50.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.595]                         if (muffled) 
[16:04:50.595]                           invokeRestart("muffleWarning")
[16:04:50.595]                       }
[16:04:50.595]                       else if (inherits(cond, "condition")) {
[16:04:50.595]                         if (!is.null(pattern)) {
[16:04:50.595]                           computeRestarts <- base::computeRestarts
[16:04:50.595]                           grepl <- base::grepl
[16:04:50.595]                           restarts <- computeRestarts(cond)
[16:04:50.595]                           for (restart in restarts) {
[16:04:50.595]                             name <- restart$name
[16:04:50.595]                             if (is.null(name)) 
[16:04:50.595]                               next
[16:04:50.595]                             if (!grepl(pattern, name)) 
[16:04:50.595]                               next
[16:04:50.595]                             invokeRestart(restart)
[16:04:50.595]                             muffled <- TRUE
[16:04:50.595]                             break
[16:04:50.595]                           }
[16:04:50.595]                         }
[16:04:50.595]                       }
[16:04:50.595]                       invisible(muffled)
[16:04:50.595]                     }
[16:04:50.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.595]                   }
[16:04:50.595]                 }
[16:04:50.595]             }
[16:04:50.595]         }))
[16:04:50.595]     }, error = function(ex) {
[16:04:50.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.595]                 ...future.rng), started = ...future.startTime, 
[16:04:50.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.595]             version = "1.8"), class = "FutureResult")
[16:04:50.595]     }, finally = {
[16:04:50.595]         if (!identical(...future.workdir, getwd())) 
[16:04:50.595]             setwd(...future.workdir)
[16:04:50.595]         {
[16:04:50.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.595]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.595]             }
[16:04:50.595]             base::options(...future.oldOptions)
[16:04:50.595]             if (.Platform$OS.type == "windows") {
[16:04:50.595]                 old_names <- names(...future.oldEnvVars)
[16:04:50.595]                 envs <- base::Sys.getenv()
[16:04:50.595]                 names <- names(envs)
[16:04:50.595]                 common <- intersect(names, old_names)
[16:04:50.595]                 added <- setdiff(names, old_names)
[16:04:50.595]                 removed <- setdiff(old_names, names)
[16:04:50.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.595]                   envs[common]]
[16:04:50.595]                 NAMES <- toupper(changed)
[16:04:50.595]                 args <- list()
[16:04:50.595]                 for (kk in seq_along(NAMES)) {
[16:04:50.595]                   name <- changed[[kk]]
[16:04:50.595]                   NAME <- NAMES[[kk]]
[16:04:50.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.595]                     next
[16:04:50.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.595]                 }
[16:04:50.595]                 NAMES <- toupper(added)
[16:04:50.595]                 for (kk in seq_along(NAMES)) {
[16:04:50.595]                   name <- added[[kk]]
[16:04:50.595]                   NAME <- NAMES[[kk]]
[16:04:50.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.595]                     next
[16:04:50.595]                   args[[name]] <- ""
[16:04:50.595]                 }
[16:04:50.595]                 NAMES <- toupper(removed)
[16:04:50.595]                 for (kk in seq_along(NAMES)) {
[16:04:50.595]                   name <- removed[[kk]]
[16:04:50.595]                   NAME <- NAMES[[kk]]
[16:04:50.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.595]                     next
[16:04:50.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.595]                 }
[16:04:50.595]                 if (length(args) > 0) 
[16:04:50.595]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.595]             }
[16:04:50.595]             else {
[16:04:50.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.595]             }
[16:04:50.595]             {
[16:04:50.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.595]                   0L) {
[16:04:50.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.595]                   base::options(opts)
[16:04:50.595]                 }
[16:04:50.595]                 {
[16:04:50.595]                   {
[16:04:50.595]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.595]                     NULL
[16:04:50.595]                   }
[16:04:50.595]                   options(future.plan = NULL)
[16:04:50.595]                   if (is.na(NA_character_)) 
[16:04:50.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.595]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.595]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.595]                     envir = parent.frame()) 
[16:04:50.595]                   {
[16:04:50.595]                     if (is.function(workers)) 
[16:04:50.595]                       workers <- workers()
[16:04:50.595]                     workers <- structure(as.integer(workers), 
[16:04:50.595]                       class = class(workers))
[16:04:50.595]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.595]                       workers >= 1)
[16:04:50.595]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.595]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.595]                     }
[16:04:50.595]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.595]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.595]                       envir = envir)
[16:04:50.595]                     if (!future$lazy) 
[16:04:50.595]                       future <- run(future)
[16:04:50.595]                     invisible(future)
[16:04:50.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.595]                 }
[16:04:50.595]             }
[16:04:50.595]         }
[16:04:50.595]     })
[16:04:50.595]     if (TRUE) {
[16:04:50.595]         base::sink(type = "output", split = FALSE)
[16:04:50.595]         if (TRUE) {
[16:04:50.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.595]         }
[16:04:50.595]         else {
[16:04:50.595]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.595]         }
[16:04:50.595]         base::close(...future.stdout)
[16:04:50.595]         ...future.stdout <- NULL
[16:04:50.595]     }
[16:04:50.595]     ...future.result$conditions <- ...future.conditions
[16:04:50.595]     ...future.result$finished <- base::Sys.time()
[16:04:50.595]     ...future.result
[16:04:50.595] }
[16:04:50.598] MultisessionFuture started
[16:04:50.598] - Launch lazy future ... done
[16:04:50.598] run() for ‘MultisessionFuture’ ... done
[16:04:50.598] result() for ClusterFuture ...
[16:04:50.598] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.598] - Validating connection of MultisessionFuture
[16:04:50.650] - received message: FutureResult
[16:04:50.650] - Received FutureResult
[16:04:50.650] - Erased future from FutureRegistry
[16:04:50.650] result() for ClusterFuture ...
[16:04:50.650] - result already collected: FutureResult
[16:04:50.650] result() for ClusterFuture ... done
[16:04:50.650] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.650] result() for ClusterFuture ... done
[16:04:50.651] result() for ClusterFuture ...
[16:04:50.651] - result already collected: FutureResult
[16:04:50.651] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[16:04:50.653] getGlobalsAndPackages() ...
[16:04:50.653] Searching for globals...
[16:04:50.657] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:50.657] Searching for globals ... DONE
[16:04:50.657] Resolving globals: FALSE
[16:04:50.658] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:50.658] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:50.658] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:50.658] 
[16:04:50.658] getGlobalsAndPackages() ... DONE
[16:04:50.659] run() for ‘Future’ ...
[16:04:50.659] - state: ‘created’
[16:04:50.659] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.673] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.673]   - Field: ‘node’
[16:04:50.673]   - Field: ‘label’
[16:04:50.673]   - Field: ‘local’
[16:04:50.673]   - Field: ‘owner’
[16:04:50.673]   - Field: ‘envir’
[16:04:50.673]   - Field: ‘workers’
[16:04:50.673]   - Field: ‘packages’
[16:04:50.673]   - Field: ‘gc’
[16:04:50.674]   - Field: ‘conditions’
[16:04:50.676]   - Field: ‘persistent’
[16:04:50.676]   - Field: ‘expr’
[16:04:50.676]   - Field: ‘uuid’
[16:04:50.676]   - Field: ‘seed’
[16:04:50.676]   - Field: ‘version’
[16:04:50.676]   - Field: ‘result’
[16:04:50.676]   - Field: ‘asynchronous’
[16:04:50.676]   - Field: ‘calls’
[16:04:50.676]   - Field: ‘globals’
[16:04:50.676]   - Field: ‘stdout’
[16:04:50.677]   - Field: ‘earlySignal’
[16:04:50.677]   - Field: ‘lazy’
[16:04:50.677]   - Field: ‘state’
[16:04:50.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.677] - Launch lazy future ...
[16:04:50.677] Packages needed by the future expression (n = 0): <none>
[16:04:50.677] Packages needed by future strategies (n = 0): <none>
[16:04:50.678] {
[16:04:50.678]     {
[16:04:50.678]         {
[16:04:50.678]             ...future.startTime <- base::Sys.time()
[16:04:50.678]             {
[16:04:50.678]                 {
[16:04:50.678]                   {
[16:04:50.678]                     {
[16:04:50.678]                       base::local({
[16:04:50.678]                         has_future <- base::requireNamespace("future", 
[16:04:50.678]                           quietly = TRUE)
[16:04:50.678]                         if (has_future) {
[16:04:50.678]                           ns <- base::getNamespace("future")
[16:04:50.678]                           version <- ns[[".package"]][["version"]]
[16:04:50.678]                           if (is.null(version)) 
[16:04:50.678]                             version <- utils::packageVersion("future")
[16:04:50.678]                         }
[16:04:50.678]                         else {
[16:04:50.678]                           version <- NULL
[16:04:50.678]                         }
[16:04:50.678]                         if (!has_future || version < "1.8.0") {
[16:04:50.678]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.678]                             "", base::R.version$version.string), 
[16:04:50.678]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:50.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:50.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.678]                               "release", "version")], collapse = " "), 
[16:04:50.678]                             hostname = base::Sys.info()[["nodename"]])
[16:04:50.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.678]                             info)
[16:04:50.678]                           info <- base::paste(info, collapse = "; ")
[16:04:50.678]                           if (!has_future) {
[16:04:50.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.678]                               info)
[16:04:50.678]                           }
[16:04:50.678]                           else {
[16:04:50.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.678]                               info, version)
[16:04:50.678]                           }
[16:04:50.678]                           base::stop(msg)
[16:04:50.678]                         }
[16:04:50.678]                       })
[16:04:50.678]                     }
[16:04:50.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.678]                     base::options(mc.cores = 1L)
[16:04:50.678]                   }
[16:04:50.678]                   options(future.plan = NULL)
[16:04:50.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.678]                 }
[16:04:50.678]                 ...future.workdir <- getwd()
[16:04:50.678]             }
[16:04:50.678]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.678]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.678]         }
[16:04:50.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.678]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.678]             base::names(...future.oldOptions))
[16:04:50.678]     }
[16:04:50.678]     if (FALSE) {
[16:04:50.678]     }
[16:04:50.678]     else {
[16:04:50.678]         if (TRUE) {
[16:04:50.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.678]                 open = "w")
[16:04:50.678]         }
[16:04:50.678]         else {
[16:04:50.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.678]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.678]         }
[16:04:50.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.678]             base::sink(type = "output", split = FALSE)
[16:04:50.678]             base::close(...future.stdout)
[16:04:50.678]         }, add = TRUE)
[16:04:50.678]     }
[16:04:50.678]     ...future.frame <- base::sys.nframe()
[16:04:50.678]     ...future.conditions <- base::list()
[16:04:50.678]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.678]     if (FALSE) {
[16:04:50.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.678]     }
[16:04:50.678]     ...future.result <- base::tryCatch({
[16:04:50.678]         base::withCallingHandlers({
[16:04:50.678]             ...future.value <- base::withVisible(base::local({
[16:04:50.678]                 ...future.makeSendCondition <- base::local({
[16:04:50.678]                   sendCondition <- NULL
[16:04:50.678]                   function(frame = 1L) {
[16:04:50.678]                     if (is.function(sendCondition)) 
[16:04:50.678]                       return(sendCondition)
[16:04:50.678]                     ns <- getNamespace("parallel")
[16:04:50.678]                     if (exists("sendData", mode = "function", 
[16:04:50.678]                       envir = ns)) {
[16:04:50.678]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.678]                         envir = ns)
[16:04:50.678]                       envir <- sys.frame(frame)
[16:04:50.678]                       master <- NULL
[16:04:50.678]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.678]                         !identical(envir, emptyenv())) {
[16:04:50.678]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.678]                           inherits = FALSE)) {
[16:04:50.678]                           master <- get("master", mode = "list", 
[16:04:50.678]                             envir = envir, inherits = FALSE)
[16:04:50.678]                           if (inherits(master, c("SOCKnode", 
[16:04:50.678]                             "SOCK0node"))) {
[16:04:50.678]                             sendCondition <<- function(cond) {
[16:04:50.678]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.678]                                 success = TRUE)
[16:04:50.678]                               parallel_sendData(master, data)
[16:04:50.678]                             }
[16:04:50.678]                             return(sendCondition)
[16:04:50.678]                           }
[16:04:50.678]                         }
[16:04:50.678]                         frame <- frame + 1L
[16:04:50.678]                         envir <- sys.frame(frame)
[16:04:50.678]                       }
[16:04:50.678]                     }
[16:04:50.678]                     sendCondition <<- function(cond) NULL
[16:04:50.678]                   }
[16:04:50.678]                 })
[16:04:50.678]                 withCallingHandlers({
[16:04:50.678]                   {
[16:04:50.678]                     outer_function(1L)
[16:04:50.678]                   }
[16:04:50.678]                 }, immediateCondition = function(cond) {
[16:04:50.678]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.678]                   sendCondition(cond)
[16:04:50.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.678]                   {
[16:04:50.678]                     inherits <- base::inherits
[16:04:50.678]                     invokeRestart <- base::invokeRestart
[16:04:50.678]                     is.null <- base::is.null
[16:04:50.678]                     muffled <- FALSE
[16:04:50.678]                     if (inherits(cond, "message")) {
[16:04:50.678]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.678]                       if (muffled) 
[16:04:50.678]                         invokeRestart("muffleMessage")
[16:04:50.678]                     }
[16:04:50.678]                     else if (inherits(cond, "warning")) {
[16:04:50.678]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.678]                       if (muffled) 
[16:04:50.678]                         invokeRestart("muffleWarning")
[16:04:50.678]                     }
[16:04:50.678]                     else if (inherits(cond, "condition")) {
[16:04:50.678]                       if (!is.null(pattern)) {
[16:04:50.678]                         computeRestarts <- base::computeRestarts
[16:04:50.678]                         grepl <- base::grepl
[16:04:50.678]                         restarts <- computeRestarts(cond)
[16:04:50.678]                         for (restart in restarts) {
[16:04:50.678]                           name <- restart$name
[16:04:50.678]                           if (is.null(name)) 
[16:04:50.678]                             next
[16:04:50.678]                           if (!grepl(pattern, name)) 
[16:04:50.678]                             next
[16:04:50.678]                           invokeRestart(restart)
[16:04:50.678]                           muffled <- TRUE
[16:04:50.678]                           break
[16:04:50.678]                         }
[16:04:50.678]                       }
[16:04:50.678]                     }
[16:04:50.678]                     invisible(muffled)
[16:04:50.678]                   }
[16:04:50.678]                   muffleCondition(cond)
[16:04:50.678]                 })
[16:04:50.678]             }))
[16:04:50.678]             future::FutureResult(value = ...future.value$value, 
[16:04:50.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.678]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.678]                     ...future.globalenv.names))
[16:04:50.678]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.678]         }, condition = base::local({
[16:04:50.678]             c <- base::c
[16:04:50.678]             inherits <- base::inherits
[16:04:50.678]             invokeRestart <- base::invokeRestart
[16:04:50.678]             length <- base::length
[16:04:50.678]             list <- base::list
[16:04:50.678]             seq.int <- base::seq.int
[16:04:50.678]             signalCondition <- base::signalCondition
[16:04:50.678]             sys.calls <- base::sys.calls
[16:04:50.678]             `[[` <- base::`[[`
[16:04:50.678]             `+` <- base::`+`
[16:04:50.678]             `<<-` <- base::`<<-`
[16:04:50.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.678]                   3L)]
[16:04:50.678]             }
[16:04:50.678]             function(cond) {
[16:04:50.678]                 is_error <- inherits(cond, "error")
[16:04:50.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.678]                   NULL)
[16:04:50.678]                 if (is_error) {
[16:04:50.678]                   sessionInformation <- function() {
[16:04:50.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.678]                       search = base::search(), system = base::Sys.info())
[16:04:50.678]                   }
[16:04:50.678]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.678]                     cond$call), session = sessionInformation(), 
[16:04:50.678]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.678]                   signalCondition(cond)
[16:04:50.678]                 }
[16:04:50.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.678]                 "immediateCondition"))) {
[16:04:50.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.678]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.678]                   if (TRUE && !signal) {
[16:04:50.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.678]                     {
[16:04:50.678]                       inherits <- base::inherits
[16:04:50.678]                       invokeRestart <- base::invokeRestart
[16:04:50.678]                       is.null <- base::is.null
[16:04:50.678]                       muffled <- FALSE
[16:04:50.678]                       if (inherits(cond, "message")) {
[16:04:50.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.678]                         if (muffled) 
[16:04:50.678]                           invokeRestart("muffleMessage")
[16:04:50.678]                       }
[16:04:50.678]                       else if (inherits(cond, "warning")) {
[16:04:50.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.678]                         if (muffled) 
[16:04:50.678]                           invokeRestart("muffleWarning")
[16:04:50.678]                       }
[16:04:50.678]                       else if (inherits(cond, "condition")) {
[16:04:50.678]                         if (!is.null(pattern)) {
[16:04:50.678]                           computeRestarts <- base::computeRestarts
[16:04:50.678]                           grepl <- base::grepl
[16:04:50.678]                           restarts <- computeRestarts(cond)
[16:04:50.678]                           for (restart in restarts) {
[16:04:50.678]                             name <- restart$name
[16:04:50.678]                             if (is.null(name)) 
[16:04:50.678]                               next
[16:04:50.678]                             if (!grepl(pattern, name)) 
[16:04:50.678]                               next
[16:04:50.678]                             invokeRestart(restart)
[16:04:50.678]                             muffled <- TRUE
[16:04:50.678]                             break
[16:04:50.678]                           }
[16:04:50.678]                         }
[16:04:50.678]                       }
[16:04:50.678]                       invisible(muffled)
[16:04:50.678]                     }
[16:04:50.678]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.678]                   }
[16:04:50.678]                 }
[16:04:50.678]                 else {
[16:04:50.678]                   if (TRUE) {
[16:04:50.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.678]                     {
[16:04:50.678]                       inherits <- base::inherits
[16:04:50.678]                       invokeRestart <- base::invokeRestart
[16:04:50.678]                       is.null <- base::is.null
[16:04:50.678]                       muffled <- FALSE
[16:04:50.678]                       if (inherits(cond, "message")) {
[16:04:50.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.678]                         if (muffled) 
[16:04:50.678]                           invokeRestart("muffleMessage")
[16:04:50.678]                       }
[16:04:50.678]                       else if (inherits(cond, "warning")) {
[16:04:50.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.678]                         if (muffled) 
[16:04:50.678]                           invokeRestart("muffleWarning")
[16:04:50.678]                       }
[16:04:50.678]                       else if (inherits(cond, "condition")) {
[16:04:50.678]                         if (!is.null(pattern)) {
[16:04:50.678]                           computeRestarts <- base::computeRestarts
[16:04:50.678]                           grepl <- base::grepl
[16:04:50.678]                           restarts <- computeRestarts(cond)
[16:04:50.678]                           for (restart in restarts) {
[16:04:50.678]                             name <- restart$name
[16:04:50.678]                             if (is.null(name)) 
[16:04:50.678]                               next
[16:04:50.678]                             if (!grepl(pattern, name)) 
[16:04:50.678]                               next
[16:04:50.678]                             invokeRestart(restart)
[16:04:50.678]                             muffled <- TRUE
[16:04:50.678]                             break
[16:04:50.678]                           }
[16:04:50.678]                         }
[16:04:50.678]                       }
[16:04:50.678]                       invisible(muffled)
[16:04:50.678]                     }
[16:04:50.678]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.678]                   }
[16:04:50.678]                 }
[16:04:50.678]             }
[16:04:50.678]         }))
[16:04:50.678]     }, error = function(ex) {
[16:04:50.678]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.678]                 ...future.rng), started = ...future.startTime, 
[16:04:50.678]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.678]             version = "1.8"), class = "FutureResult")
[16:04:50.678]     }, finally = {
[16:04:50.678]         if (!identical(...future.workdir, getwd())) 
[16:04:50.678]             setwd(...future.workdir)
[16:04:50.678]         {
[16:04:50.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.678]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.678]             }
[16:04:50.678]             base::options(...future.oldOptions)
[16:04:50.678]             if (.Platform$OS.type == "windows") {
[16:04:50.678]                 old_names <- names(...future.oldEnvVars)
[16:04:50.678]                 envs <- base::Sys.getenv()
[16:04:50.678]                 names <- names(envs)
[16:04:50.678]                 common <- intersect(names, old_names)
[16:04:50.678]                 added <- setdiff(names, old_names)
[16:04:50.678]                 removed <- setdiff(old_names, names)
[16:04:50.678]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.678]                   envs[common]]
[16:04:50.678]                 NAMES <- toupper(changed)
[16:04:50.678]                 args <- list()
[16:04:50.678]                 for (kk in seq_along(NAMES)) {
[16:04:50.678]                   name <- changed[[kk]]
[16:04:50.678]                   NAME <- NAMES[[kk]]
[16:04:50.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.678]                     next
[16:04:50.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.678]                 }
[16:04:50.678]                 NAMES <- toupper(added)
[16:04:50.678]                 for (kk in seq_along(NAMES)) {
[16:04:50.678]                   name <- added[[kk]]
[16:04:50.678]                   NAME <- NAMES[[kk]]
[16:04:50.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.678]                     next
[16:04:50.678]                   args[[name]] <- ""
[16:04:50.678]                 }
[16:04:50.678]                 NAMES <- toupper(removed)
[16:04:50.678]                 for (kk in seq_along(NAMES)) {
[16:04:50.678]                   name <- removed[[kk]]
[16:04:50.678]                   NAME <- NAMES[[kk]]
[16:04:50.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.678]                     next
[16:04:50.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.678]                 }
[16:04:50.678]                 if (length(args) > 0) 
[16:04:50.678]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.678]             }
[16:04:50.678]             else {
[16:04:50.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.678]             }
[16:04:50.678]             {
[16:04:50.678]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.678]                   0L) {
[16:04:50.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.678]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.678]                   base::options(opts)
[16:04:50.678]                 }
[16:04:50.678]                 {
[16:04:50.678]                   {
[16:04:50.678]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.678]                     NULL
[16:04:50.678]                   }
[16:04:50.678]                   options(future.plan = NULL)
[16:04:50.678]                   if (is.na(NA_character_)) 
[16:04:50.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.678]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.678]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.678]                     envir = parent.frame()) 
[16:04:50.678]                   {
[16:04:50.678]                     if (is.function(workers)) 
[16:04:50.678]                       workers <- workers()
[16:04:50.678]                     workers <- structure(as.integer(workers), 
[16:04:50.678]                       class = class(workers))
[16:04:50.678]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.678]                       workers >= 1)
[16:04:50.678]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.678]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.678]                     }
[16:04:50.678]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.678]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.678]                       envir = envir)
[16:04:50.678]                     if (!future$lazy) 
[16:04:50.678]                       future <- run(future)
[16:04:50.678]                     invisible(future)
[16:04:50.678]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.678]                 }
[16:04:50.678]             }
[16:04:50.678]         }
[16:04:50.678]     })
[16:04:50.678]     if (TRUE) {
[16:04:50.678]         base::sink(type = "output", split = FALSE)
[16:04:50.678]         if (TRUE) {
[16:04:50.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.678]         }
[16:04:50.678]         else {
[16:04:50.678]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.678]         }
[16:04:50.678]         base::close(...future.stdout)
[16:04:50.678]         ...future.stdout <- NULL
[16:04:50.678]     }
[16:04:50.678]     ...future.result$conditions <- ...future.conditions
[16:04:50.678]     ...future.result$finished <- base::Sys.time()
[16:04:50.678]     ...future.result
[16:04:50.678] }
[16:04:50.680] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:04:50.680] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:04:50.681] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:04:50.681] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:04:50.681] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:04:50.681] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:04:50.682] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:04:50.682] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:04:50.682] MultisessionFuture started
[16:04:50.682] - Launch lazy future ... done
[16:04:50.682] run() for ‘MultisessionFuture’ ... done
[16:04:50.683] result() for ClusterFuture ...
[16:04:50.683] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.683] - Validating connection of MultisessionFuture
[16:04:50.733] - received message: FutureResult
[16:04:50.733] - Received FutureResult
[16:04:50.733] - Erased future from FutureRegistry
[16:04:50.733] result() for ClusterFuture ...
[16:04:50.733] - result already collected: FutureResult
[16:04:50.733] result() for ClusterFuture ... done
[16:04:50.734] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.734] result() for ClusterFuture ... done
[16:04:50.734] result() for ClusterFuture ...
[16:04:50.734] - result already collected: FutureResult
[16:04:50.734] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[16:04:50.735] getGlobalsAndPackages() ...
[16:04:50.736] Searching for globals...
[16:04:50.740] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[16:04:50.740] Searching for globals ... DONE
[16:04:50.740] Resolving globals: FALSE
[16:04:50.741] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[16:04:50.741] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[16:04:50.741] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[16:04:50.741] 
[16:04:50.741] getGlobalsAndPackages() ... DONE
[16:04:50.742] run() for ‘Future’ ...
[16:04:50.742] - state: ‘created’
[16:04:50.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:50.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:50.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:50.756]   - Field: ‘node’
[16:04:50.756]   - Field: ‘label’
[16:04:50.756]   - Field: ‘local’
[16:04:50.756]   - Field: ‘owner’
[16:04:50.756]   - Field: ‘envir’
[16:04:50.756]   - Field: ‘workers’
[16:04:50.757]   - Field: ‘packages’
[16:04:50.757]   - Field: ‘gc’
[16:04:50.757]   - Field: ‘conditions’
[16:04:50.757]   - Field: ‘persistent’
[16:04:50.757]   - Field: ‘expr’
[16:04:50.757]   - Field: ‘uuid’
[16:04:50.757]   - Field: ‘seed’
[16:04:50.757]   - Field: ‘version’
[16:04:50.757]   - Field: ‘result’
[16:04:50.757]   - Field: ‘asynchronous’
[16:04:50.757]   - Field: ‘calls’
[16:04:50.758]   - Field: ‘globals’
[16:04:50.758]   - Field: ‘stdout’
[16:04:50.758]   - Field: ‘earlySignal’
[16:04:50.758]   - Field: ‘lazy’
[16:04:50.758]   - Field: ‘state’
[16:04:50.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:50.758] - Launch lazy future ...
[16:04:50.758] Packages needed by the future expression (n = 0): <none>
[16:04:50.759] Packages needed by future strategies (n = 0): <none>
[16:04:50.759] {
[16:04:50.759]     {
[16:04:50.759]         {
[16:04:50.759]             ...future.startTime <- base::Sys.time()
[16:04:50.759]             {
[16:04:50.759]                 {
[16:04:50.759]                   {
[16:04:50.759]                     {
[16:04:50.759]                       base::local({
[16:04:50.759]                         has_future <- base::requireNamespace("future", 
[16:04:50.759]                           quietly = TRUE)
[16:04:50.759]                         if (has_future) {
[16:04:50.759]                           ns <- base::getNamespace("future")
[16:04:50.759]                           version <- ns[[".package"]][["version"]]
[16:04:50.759]                           if (is.null(version)) 
[16:04:50.759]                             version <- utils::packageVersion("future")
[16:04:50.759]                         }
[16:04:50.759]                         else {
[16:04:50.759]                           version <- NULL
[16:04:50.759]                         }
[16:04:50.759]                         if (!has_future || version < "1.8.0") {
[16:04:50.759]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:50.759]                             "", base::R.version$version.string), 
[16:04:50.759]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:50.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:50.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:50.759]                               "release", "version")], collapse = " "), 
[16:04:50.759]                             hostname = base::Sys.info()[["nodename"]])
[16:04:50.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:50.759]                             info)
[16:04:50.759]                           info <- base::paste(info, collapse = "; ")
[16:04:50.759]                           if (!has_future) {
[16:04:50.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:50.759]                               info)
[16:04:50.759]                           }
[16:04:50.759]                           else {
[16:04:50.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:50.759]                               info, version)
[16:04:50.759]                           }
[16:04:50.759]                           base::stop(msg)
[16:04:50.759]                         }
[16:04:50.759]                       })
[16:04:50.759]                     }
[16:04:50.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:50.759]                     base::options(mc.cores = 1L)
[16:04:50.759]                   }
[16:04:50.759]                   options(future.plan = NULL)
[16:04:50.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:50.759]                 }
[16:04:50.759]                 ...future.workdir <- getwd()
[16:04:50.759]             }
[16:04:50.759]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:50.759]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:50.759]         }
[16:04:50.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:50.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:50.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:50.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:50.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:50.759]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:50.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:50.759]             base::names(...future.oldOptions))
[16:04:50.759]     }
[16:04:50.759]     if (FALSE) {
[16:04:50.759]     }
[16:04:50.759]     else {
[16:04:50.759]         if (TRUE) {
[16:04:50.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:50.759]                 open = "w")
[16:04:50.759]         }
[16:04:50.759]         else {
[16:04:50.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:50.759]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:50.759]         }
[16:04:50.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:50.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:50.759]             base::sink(type = "output", split = FALSE)
[16:04:50.759]             base::close(...future.stdout)
[16:04:50.759]         }, add = TRUE)
[16:04:50.759]     }
[16:04:50.759]     ...future.frame <- base::sys.nframe()
[16:04:50.759]     ...future.conditions <- base::list()
[16:04:50.759]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:50.759]     if (FALSE) {
[16:04:50.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:50.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:50.759]     }
[16:04:50.759]     ...future.result <- base::tryCatch({
[16:04:50.759]         base::withCallingHandlers({
[16:04:50.759]             ...future.value <- base::withVisible(base::local({
[16:04:50.759]                 ...future.makeSendCondition <- base::local({
[16:04:50.759]                   sendCondition <- NULL
[16:04:50.759]                   function(frame = 1L) {
[16:04:50.759]                     if (is.function(sendCondition)) 
[16:04:50.759]                       return(sendCondition)
[16:04:50.759]                     ns <- getNamespace("parallel")
[16:04:50.759]                     if (exists("sendData", mode = "function", 
[16:04:50.759]                       envir = ns)) {
[16:04:50.759]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:50.759]                         envir = ns)
[16:04:50.759]                       envir <- sys.frame(frame)
[16:04:50.759]                       master <- NULL
[16:04:50.759]                       while (!identical(envir, .GlobalEnv) && 
[16:04:50.759]                         !identical(envir, emptyenv())) {
[16:04:50.759]                         if (exists("master", mode = "list", envir = envir, 
[16:04:50.759]                           inherits = FALSE)) {
[16:04:50.759]                           master <- get("master", mode = "list", 
[16:04:50.759]                             envir = envir, inherits = FALSE)
[16:04:50.759]                           if (inherits(master, c("SOCKnode", 
[16:04:50.759]                             "SOCK0node"))) {
[16:04:50.759]                             sendCondition <<- function(cond) {
[16:04:50.759]                               data <- list(type = "VALUE", value = cond, 
[16:04:50.759]                                 success = TRUE)
[16:04:50.759]                               parallel_sendData(master, data)
[16:04:50.759]                             }
[16:04:50.759]                             return(sendCondition)
[16:04:50.759]                           }
[16:04:50.759]                         }
[16:04:50.759]                         frame <- frame + 1L
[16:04:50.759]                         envir <- sys.frame(frame)
[16:04:50.759]                       }
[16:04:50.759]                     }
[16:04:50.759]                     sendCondition <<- function(cond) NULL
[16:04:50.759]                   }
[16:04:50.759]                 })
[16:04:50.759]                 withCallingHandlers({
[16:04:50.759]                   {
[16:04:50.759]                     outer_function(1L)
[16:04:50.759]                   }
[16:04:50.759]                 }, immediateCondition = function(cond) {
[16:04:50.759]                   sendCondition <- ...future.makeSendCondition()
[16:04:50.759]                   sendCondition(cond)
[16:04:50.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.759]                   {
[16:04:50.759]                     inherits <- base::inherits
[16:04:50.759]                     invokeRestart <- base::invokeRestart
[16:04:50.759]                     is.null <- base::is.null
[16:04:50.759]                     muffled <- FALSE
[16:04:50.759]                     if (inherits(cond, "message")) {
[16:04:50.759]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:50.759]                       if (muffled) 
[16:04:50.759]                         invokeRestart("muffleMessage")
[16:04:50.759]                     }
[16:04:50.759]                     else if (inherits(cond, "warning")) {
[16:04:50.759]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:50.759]                       if (muffled) 
[16:04:50.759]                         invokeRestart("muffleWarning")
[16:04:50.759]                     }
[16:04:50.759]                     else if (inherits(cond, "condition")) {
[16:04:50.759]                       if (!is.null(pattern)) {
[16:04:50.759]                         computeRestarts <- base::computeRestarts
[16:04:50.759]                         grepl <- base::grepl
[16:04:50.759]                         restarts <- computeRestarts(cond)
[16:04:50.759]                         for (restart in restarts) {
[16:04:50.759]                           name <- restart$name
[16:04:50.759]                           if (is.null(name)) 
[16:04:50.759]                             next
[16:04:50.759]                           if (!grepl(pattern, name)) 
[16:04:50.759]                             next
[16:04:50.759]                           invokeRestart(restart)
[16:04:50.759]                           muffled <- TRUE
[16:04:50.759]                           break
[16:04:50.759]                         }
[16:04:50.759]                       }
[16:04:50.759]                     }
[16:04:50.759]                     invisible(muffled)
[16:04:50.759]                   }
[16:04:50.759]                   muffleCondition(cond)
[16:04:50.759]                 })
[16:04:50.759]             }))
[16:04:50.759]             future::FutureResult(value = ...future.value$value, 
[16:04:50.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.759]                   ...future.rng), globalenv = if (FALSE) 
[16:04:50.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:50.759]                     ...future.globalenv.names))
[16:04:50.759]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:50.759]         }, condition = base::local({
[16:04:50.759]             c <- base::c
[16:04:50.759]             inherits <- base::inherits
[16:04:50.759]             invokeRestart <- base::invokeRestart
[16:04:50.759]             length <- base::length
[16:04:50.759]             list <- base::list
[16:04:50.759]             seq.int <- base::seq.int
[16:04:50.759]             signalCondition <- base::signalCondition
[16:04:50.759]             sys.calls <- base::sys.calls
[16:04:50.759]             `[[` <- base::`[[`
[16:04:50.759]             `+` <- base::`+`
[16:04:50.759]             `<<-` <- base::`<<-`
[16:04:50.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:50.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:50.759]                   3L)]
[16:04:50.759]             }
[16:04:50.759]             function(cond) {
[16:04:50.759]                 is_error <- inherits(cond, "error")
[16:04:50.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:50.759]                   NULL)
[16:04:50.759]                 if (is_error) {
[16:04:50.759]                   sessionInformation <- function() {
[16:04:50.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:50.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:50.759]                       search = base::search(), system = base::Sys.info())
[16:04:50.759]                   }
[16:04:50.759]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:50.759]                     cond$call), session = sessionInformation(), 
[16:04:50.759]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:50.759]                   signalCondition(cond)
[16:04:50.759]                 }
[16:04:50.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:50.759]                 "immediateCondition"))) {
[16:04:50.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:50.759]                   ...future.conditions[[length(...future.conditions) + 
[16:04:50.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:50.759]                   if (TRUE && !signal) {
[16:04:50.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.759]                     {
[16:04:50.759]                       inherits <- base::inherits
[16:04:50.759]                       invokeRestart <- base::invokeRestart
[16:04:50.759]                       is.null <- base::is.null
[16:04:50.759]                       muffled <- FALSE
[16:04:50.759]                       if (inherits(cond, "message")) {
[16:04:50.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.759]                         if (muffled) 
[16:04:50.759]                           invokeRestart("muffleMessage")
[16:04:50.759]                       }
[16:04:50.759]                       else if (inherits(cond, "warning")) {
[16:04:50.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.759]                         if (muffled) 
[16:04:50.759]                           invokeRestart("muffleWarning")
[16:04:50.759]                       }
[16:04:50.759]                       else if (inherits(cond, "condition")) {
[16:04:50.759]                         if (!is.null(pattern)) {
[16:04:50.759]                           computeRestarts <- base::computeRestarts
[16:04:50.759]                           grepl <- base::grepl
[16:04:50.759]                           restarts <- computeRestarts(cond)
[16:04:50.759]                           for (restart in restarts) {
[16:04:50.759]                             name <- restart$name
[16:04:50.759]                             if (is.null(name)) 
[16:04:50.759]                               next
[16:04:50.759]                             if (!grepl(pattern, name)) 
[16:04:50.759]                               next
[16:04:50.759]                             invokeRestart(restart)
[16:04:50.759]                             muffled <- TRUE
[16:04:50.759]                             break
[16:04:50.759]                           }
[16:04:50.759]                         }
[16:04:50.759]                       }
[16:04:50.759]                       invisible(muffled)
[16:04:50.759]                     }
[16:04:50.759]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.759]                   }
[16:04:50.759]                 }
[16:04:50.759]                 else {
[16:04:50.759]                   if (TRUE) {
[16:04:50.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:50.759]                     {
[16:04:50.759]                       inherits <- base::inherits
[16:04:50.759]                       invokeRestart <- base::invokeRestart
[16:04:50.759]                       is.null <- base::is.null
[16:04:50.759]                       muffled <- FALSE
[16:04:50.759]                       if (inherits(cond, "message")) {
[16:04:50.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:50.759]                         if (muffled) 
[16:04:50.759]                           invokeRestart("muffleMessage")
[16:04:50.759]                       }
[16:04:50.759]                       else if (inherits(cond, "warning")) {
[16:04:50.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:50.759]                         if (muffled) 
[16:04:50.759]                           invokeRestart("muffleWarning")
[16:04:50.759]                       }
[16:04:50.759]                       else if (inherits(cond, "condition")) {
[16:04:50.759]                         if (!is.null(pattern)) {
[16:04:50.759]                           computeRestarts <- base::computeRestarts
[16:04:50.759]                           grepl <- base::grepl
[16:04:50.759]                           restarts <- computeRestarts(cond)
[16:04:50.759]                           for (restart in restarts) {
[16:04:50.759]                             name <- restart$name
[16:04:50.759]                             if (is.null(name)) 
[16:04:50.759]                               next
[16:04:50.759]                             if (!grepl(pattern, name)) 
[16:04:50.759]                               next
[16:04:50.759]                             invokeRestart(restart)
[16:04:50.759]                             muffled <- TRUE
[16:04:50.759]                             break
[16:04:50.759]                           }
[16:04:50.759]                         }
[16:04:50.759]                       }
[16:04:50.759]                       invisible(muffled)
[16:04:50.759]                     }
[16:04:50.759]                     muffleCondition(cond, pattern = "^muffle")
[16:04:50.759]                   }
[16:04:50.759]                 }
[16:04:50.759]             }
[16:04:50.759]         }))
[16:04:50.759]     }, error = function(ex) {
[16:04:50.759]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:50.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:50.759]                 ...future.rng), started = ...future.startTime, 
[16:04:50.759]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:50.759]             version = "1.8"), class = "FutureResult")
[16:04:50.759]     }, finally = {
[16:04:50.759]         if (!identical(...future.workdir, getwd())) 
[16:04:50.759]             setwd(...future.workdir)
[16:04:50.759]         {
[16:04:50.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:50.759]                 ...future.oldOptions$nwarnings <- NULL
[16:04:50.759]             }
[16:04:50.759]             base::options(...future.oldOptions)
[16:04:50.759]             if (.Platform$OS.type == "windows") {
[16:04:50.759]                 old_names <- names(...future.oldEnvVars)
[16:04:50.759]                 envs <- base::Sys.getenv()
[16:04:50.759]                 names <- names(envs)
[16:04:50.759]                 common <- intersect(names, old_names)
[16:04:50.759]                 added <- setdiff(names, old_names)
[16:04:50.759]                 removed <- setdiff(old_names, names)
[16:04:50.759]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:50.759]                   envs[common]]
[16:04:50.759]                 NAMES <- toupper(changed)
[16:04:50.759]                 args <- list()
[16:04:50.759]                 for (kk in seq_along(NAMES)) {
[16:04:50.759]                   name <- changed[[kk]]
[16:04:50.759]                   NAME <- NAMES[[kk]]
[16:04:50.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.759]                     next
[16:04:50.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.759]                 }
[16:04:50.759]                 NAMES <- toupper(added)
[16:04:50.759]                 for (kk in seq_along(NAMES)) {
[16:04:50.759]                   name <- added[[kk]]
[16:04:50.759]                   NAME <- NAMES[[kk]]
[16:04:50.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.759]                     next
[16:04:50.759]                   args[[name]] <- ""
[16:04:50.759]                 }
[16:04:50.759]                 NAMES <- toupper(removed)
[16:04:50.759]                 for (kk in seq_along(NAMES)) {
[16:04:50.759]                   name <- removed[[kk]]
[16:04:50.759]                   NAME <- NAMES[[kk]]
[16:04:50.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:50.759]                     next
[16:04:50.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:50.759]                 }
[16:04:50.759]                 if (length(args) > 0) 
[16:04:50.759]                   base::do.call(base::Sys.setenv, args = args)
[16:04:50.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:50.759]             }
[16:04:50.759]             else {
[16:04:50.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:50.759]             }
[16:04:50.759]             {
[16:04:50.759]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:50.759]                   0L) {
[16:04:50.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:50.759]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:50.759]                   base::options(opts)
[16:04:50.759]                 }
[16:04:50.759]                 {
[16:04:50.759]                   {
[16:04:50.759]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:50.759]                     NULL
[16:04:50.759]                   }
[16:04:50.759]                   options(future.plan = NULL)
[16:04:50.759]                   if (is.na(NA_character_)) 
[16:04:50.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:50.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:50.759]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:50.759]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:50.759]                     envir = parent.frame()) 
[16:04:50.759]                   {
[16:04:50.759]                     if (is.function(workers)) 
[16:04:50.759]                       workers <- workers()
[16:04:50.759]                     workers <- structure(as.integer(workers), 
[16:04:50.759]                       class = class(workers))
[16:04:50.759]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:50.759]                       workers >= 1)
[16:04:50.759]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:50.759]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:50.759]                     }
[16:04:50.759]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:50.759]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:50.759]                       envir = envir)
[16:04:50.759]                     if (!future$lazy) 
[16:04:50.759]                       future <- run(future)
[16:04:50.759]                     invisible(future)
[16:04:50.759]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:50.759]                 }
[16:04:50.759]             }
[16:04:50.759]         }
[16:04:50.759]     })
[16:04:50.759]     if (TRUE) {
[16:04:50.759]         base::sink(type = "output", split = FALSE)
[16:04:50.759]         if (TRUE) {
[16:04:50.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:50.759]         }
[16:04:50.759]         else {
[16:04:50.759]             ...future.result["stdout"] <- base::list(NULL)
[16:04:50.759]         }
[16:04:50.759]         base::close(...future.stdout)
[16:04:50.759]         ...future.stdout <- NULL
[16:04:50.759]     }
[16:04:50.759]     ...future.result$conditions <- ...future.conditions
[16:04:50.759]     ...future.result$finished <- base::Sys.time()
[16:04:50.759]     ...future.result
[16:04:50.759] }
[16:04:50.762] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[16:04:50.762] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[16:04:50.762] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[16:04:50.762] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[16:04:50.763] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[16:04:50.763] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[16:04:50.763] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[16:04:50.763] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[16:04:50.764] MultisessionFuture started
[16:04:50.764] - Launch lazy future ... done
[16:04:50.764] run() for ‘MultisessionFuture’ ... done
[16:04:50.764] result() for ClusterFuture ...
[16:04:50.764] receiveMessageFromWorker() for ClusterFuture ...
[16:04:50.764] - Validating connection of MultisessionFuture
[16:04:50.812] - received message: FutureResult
[16:04:50.812] - Received FutureResult
[16:04:50.812] - Erased future from FutureRegistry
[16:04:50.812] result() for ClusterFuture ...
[16:04:50.812] - result already collected: FutureResult
[16:04:50.813] result() for ClusterFuture ... done
[16:04:50.813] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:50.813] result() for ClusterFuture ... done
[16:04:50.813] result() for ClusterFuture ...
[16:04:50.813] - result already collected: FutureResult
[16:04:50.813] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[16:04:50.815] plan(): Setting new future strategy stack:
[16:04:50.815] List of future strategies:
[16:04:50.815] 1. FutureStrategy:
[16:04:50.815]    - args: function (..., envir = parent.frame())
[16:04:50.815]    - tweaked: FALSE
[16:04:50.815]    - call: future::plan(oplan)
[16:04:50.816] plan(): nbrOfWorkers() = 1
> 
