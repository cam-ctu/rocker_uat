
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:25:53.323] plan(): Setting new future strategy stack:
[10:25:53.324] List of future strategies:
[10:25:53.324] 1. sequential:
[10:25:53.324]    - args: function (..., envir = parent.frame())
[10:25:53.324]    - tweaked: FALSE
[10:25:53.324]    - call: future::plan("sequential")
[10:25:53.338] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:25:53.394] plan(): Setting new future strategy stack:
[10:25:53.394] List of future strategies:
[10:25:53.394] 1. sequential:
[10:25:53.394]    - args: function (..., envir = parent.frame())
[10:25:53.394]    - tweaked: FALSE
[10:25:53.394]    - call: plan(strategy)
[10:25:53.406] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[10:25:53.407] getGlobalsAndPackages() ...
[10:25:53.407] Searching for globals...
[10:25:53.414] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.414] Searching for globals ... DONE
[10:25:53.414] Resolving globals: FALSE
[10:25:53.415] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.416] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.416] - globals: [2] ‘weight’, ‘group’
[10:25:53.416] - packages: [1] ‘stats’
[10:25:53.416] getGlobalsAndPackages() ... DONE
[10:25:53.417] run() for ‘Future’ ...
[10:25:53.417] - state: ‘created’
[10:25:53.417] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.418]   - Field: ‘label’
[10:25:53.418]   - Field: ‘local’
[10:25:53.418]   - Field: ‘owner’
[10:25:53.418]   - Field: ‘envir’
[10:25:53.418]   - Field: ‘packages’
[10:25:53.418]   - Field: ‘gc’
[10:25:53.418]   - Field: ‘conditions’
[10:25:53.418]   - Field: ‘expr’
[10:25:53.418]   - Field: ‘uuid’
[10:25:53.419]   - Field: ‘seed’
[10:25:53.419]   - Field: ‘version’
[10:25:53.419]   - Field: ‘result’
[10:25:53.419]   - Field: ‘asynchronous’
[10:25:53.419]   - Field: ‘calls’
[10:25:53.419]   - Field: ‘globals’
[10:25:53.419]   - Field: ‘stdout’
[10:25:53.419]   - Field: ‘earlySignal’
[10:25:53.419]   - Field: ‘lazy’
[10:25:53.419]   - Field: ‘state’
[10:25:53.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.419] - Launch lazy future ...
[10:25:53.420] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.420] Packages needed by future strategies (n = 0): <none>
[10:25:53.421] {
[10:25:53.421]     {
[10:25:53.421]         {
[10:25:53.421]             ...future.startTime <- base::Sys.time()
[10:25:53.421]             {
[10:25:53.421]                 {
[10:25:53.421]                   {
[10:25:53.421]                     {
[10:25:53.421]                       base::local({
[10:25:53.421]                         has_future <- base::requireNamespace("future", 
[10:25:53.421]                           quietly = TRUE)
[10:25:53.421]                         if (has_future) {
[10:25:53.421]                           ns <- base::getNamespace("future")
[10:25:53.421]                           version <- ns[[".package"]][["version"]]
[10:25:53.421]                           if (is.null(version)) 
[10:25:53.421]                             version <- utils::packageVersion("future")
[10:25:53.421]                         }
[10:25:53.421]                         else {
[10:25:53.421]                           version <- NULL
[10:25:53.421]                         }
[10:25:53.421]                         if (!has_future || version < "1.8.0") {
[10:25:53.421]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.421]                             "", base::R.version$version.string), 
[10:25:53.421]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.421]                               "release", "version")], collapse = " "), 
[10:25:53.421]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.421]                             info)
[10:25:53.421]                           info <- base::paste(info, collapse = "; ")
[10:25:53.421]                           if (!has_future) {
[10:25:53.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.421]                               info)
[10:25:53.421]                           }
[10:25:53.421]                           else {
[10:25:53.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.421]                               info, version)
[10:25:53.421]                           }
[10:25:53.421]                           base::stop(msg)
[10:25:53.421]                         }
[10:25:53.421]                       })
[10:25:53.421]                     }
[10:25:53.421]                     base::local({
[10:25:53.421]                       for (pkg in "stats") {
[10:25:53.421]                         base::loadNamespace(pkg)
[10:25:53.421]                         base::library(pkg, character.only = TRUE)
[10:25:53.421]                       }
[10:25:53.421]                     })
[10:25:53.421]                   }
[10:25:53.421]                   options(future.plan = NULL)
[10:25:53.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.421]                 }
[10:25:53.421]                 ...future.workdir <- getwd()
[10:25:53.421]             }
[10:25:53.421]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.421]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.421]         }
[10:25:53.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.421]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.421]             base::names(...future.oldOptions))
[10:25:53.421]     }
[10:25:53.421]     if (FALSE) {
[10:25:53.421]     }
[10:25:53.421]     else {
[10:25:53.421]         if (TRUE) {
[10:25:53.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.421]                 open = "w")
[10:25:53.421]         }
[10:25:53.421]         else {
[10:25:53.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.421]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.421]         }
[10:25:53.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.421]             base::sink(type = "output", split = FALSE)
[10:25:53.421]             base::close(...future.stdout)
[10:25:53.421]         }, add = TRUE)
[10:25:53.421]     }
[10:25:53.421]     ...future.frame <- base::sys.nframe()
[10:25:53.421]     ...future.conditions <- base::list()
[10:25:53.421]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.421]     if (FALSE) {
[10:25:53.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.421]     }
[10:25:53.421]     ...future.result <- base::tryCatch({
[10:25:53.421]         base::withCallingHandlers({
[10:25:53.421]             ...future.value <- base::withVisible(base::local({
[10:25:53.421]                 lm(weight ~ group - 1)
[10:25:53.421]             }))
[10:25:53.421]             future::FutureResult(value = ...future.value$value, 
[10:25:53.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.421]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.421]                     ...future.globalenv.names))
[10:25:53.421]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.421]         }, condition = base::local({
[10:25:53.421]             c <- base::c
[10:25:53.421]             inherits <- base::inherits
[10:25:53.421]             invokeRestart <- base::invokeRestart
[10:25:53.421]             length <- base::length
[10:25:53.421]             list <- base::list
[10:25:53.421]             seq.int <- base::seq.int
[10:25:53.421]             signalCondition <- base::signalCondition
[10:25:53.421]             sys.calls <- base::sys.calls
[10:25:53.421]             `[[` <- base::`[[`
[10:25:53.421]             `+` <- base::`+`
[10:25:53.421]             `<<-` <- base::`<<-`
[10:25:53.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.421]                   3L)]
[10:25:53.421]             }
[10:25:53.421]             function(cond) {
[10:25:53.421]                 is_error <- inherits(cond, "error")
[10:25:53.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.421]                   NULL)
[10:25:53.421]                 if (is_error) {
[10:25:53.421]                   sessionInformation <- function() {
[10:25:53.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.421]                       search = base::search(), system = base::Sys.info())
[10:25:53.421]                   }
[10:25:53.421]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.421]                     cond$call), session = sessionInformation(), 
[10:25:53.421]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.421]                   signalCondition(cond)
[10:25:53.421]                 }
[10:25:53.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.421]                 "immediateCondition"))) {
[10:25:53.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.421]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.421]                   if (TRUE && !signal) {
[10:25:53.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.421]                     {
[10:25:53.421]                       inherits <- base::inherits
[10:25:53.421]                       invokeRestart <- base::invokeRestart
[10:25:53.421]                       is.null <- base::is.null
[10:25:53.421]                       muffled <- FALSE
[10:25:53.421]                       if (inherits(cond, "message")) {
[10:25:53.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.421]                         if (muffled) 
[10:25:53.421]                           invokeRestart("muffleMessage")
[10:25:53.421]                       }
[10:25:53.421]                       else if (inherits(cond, "warning")) {
[10:25:53.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.421]                         if (muffled) 
[10:25:53.421]                           invokeRestart("muffleWarning")
[10:25:53.421]                       }
[10:25:53.421]                       else if (inherits(cond, "condition")) {
[10:25:53.421]                         if (!is.null(pattern)) {
[10:25:53.421]                           computeRestarts <- base::computeRestarts
[10:25:53.421]                           grepl <- base::grepl
[10:25:53.421]                           restarts <- computeRestarts(cond)
[10:25:53.421]                           for (restart in restarts) {
[10:25:53.421]                             name <- restart$name
[10:25:53.421]                             if (is.null(name)) 
[10:25:53.421]                               next
[10:25:53.421]                             if (!grepl(pattern, name)) 
[10:25:53.421]                               next
[10:25:53.421]                             invokeRestart(restart)
[10:25:53.421]                             muffled <- TRUE
[10:25:53.421]                             break
[10:25:53.421]                           }
[10:25:53.421]                         }
[10:25:53.421]                       }
[10:25:53.421]                       invisible(muffled)
[10:25:53.421]                     }
[10:25:53.421]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.421]                   }
[10:25:53.421]                 }
[10:25:53.421]                 else {
[10:25:53.421]                   if (TRUE) {
[10:25:53.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.421]                     {
[10:25:53.421]                       inherits <- base::inherits
[10:25:53.421]                       invokeRestart <- base::invokeRestart
[10:25:53.421]                       is.null <- base::is.null
[10:25:53.421]                       muffled <- FALSE
[10:25:53.421]                       if (inherits(cond, "message")) {
[10:25:53.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.421]                         if (muffled) 
[10:25:53.421]                           invokeRestart("muffleMessage")
[10:25:53.421]                       }
[10:25:53.421]                       else if (inherits(cond, "warning")) {
[10:25:53.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.421]                         if (muffled) 
[10:25:53.421]                           invokeRestart("muffleWarning")
[10:25:53.421]                       }
[10:25:53.421]                       else if (inherits(cond, "condition")) {
[10:25:53.421]                         if (!is.null(pattern)) {
[10:25:53.421]                           computeRestarts <- base::computeRestarts
[10:25:53.421]                           grepl <- base::grepl
[10:25:53.421]                           restarts <- computeRestarts(cond)
[10:25:53.421]                           for (restart in restarts) {
[10:25:53.421]                             name <- restart$name
[10:25:53.421]                             if (is.null(name)) 
[10:25:53.421]                               next
[10:25:53.421]                             if (!grepl(pattern, name)) 
[10:25:53.421]                               next
[10:25:53.421]                             invokeRestart(restart)
[10:25:53.421]                             muffled <- TRUE
[10:25:53.421]                             break
[10:25:53.421]                           }
[10:25:53.421]                         }
[10:25:53.421]                       }
[10:25:53.421]                       invisible(muffled)
[10:25:53.421]                     }
[10:25:53.421]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.421]                   }
[10:25:53.421]                 }
[10:25:53.421]             }
[10:25:53.421]         }))
[10:25:53.421]     }, error = function(ex) {
[10:25:53.421]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.421]                 ...future.rng), started = ...future.startTime, 
[10:25:53.421]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.421]             version = "1.8"), class = "FutureResult")
[10:25:53.421]     }, finally = {
[10:25:53.421]         if (!identical(...future.workdir, getwd())) 
[10:25:53.421]             setwd(...future.workdir)
[10:25:53.421]         {
[10:25:53.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.421]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.421]             }
[10:25:53.421]             base::options(...future.oldOptions)
[10:25:53.421]             if (.Platform$OS.type == "windows") {
[10:25:53.421]                 old_names <- names(...future.oldEnvVars)
[10:25:53.421]                 envs <- base::Sys.getenv()
[10:25:53.421]                 names <- names(envs)
[10:25:53.421]                 common <- intersect(names, old_names)
[10:25:53.421]                 added <- setdiff(names, old_names)
[10:25:53.421]                 removed <- setdiff(old_names, names)
[10:25:53.421]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.421]                   envs[common]]
[10:25:53.421]                 NAMES <- toupper(changed)
[10:25:53.421]                 args <- list()
[10:25:53.421]                 for (kk in seq_along(NAMES)) {
[10:25:53.421]                   name <- changed[[kk]]
[10:25:53.421]                   NAME <- NAMES[[kk]]
[10:25:53.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.421]                     next
[10:25:53.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.421]                 }
[10:25:53.421]                 NAMES <- toupper(added)
[10:25:53.421]                 for (kk in seq_along(NAMES)) {
[10:25:53.421]                   name <- added[[kk]]
[10:25:53.421]                   NAME <- NAMES[[kk]]
[10:25:53.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.421]                     next
[10:25:53.421]                   args[[name]] <- ""
[10:25:53.421]                 }
[10:25:53.421]                 NAMES <- toupper(removed)
[10:25:53.421]                 for (kk in seq_along(NAMES)) {
[10:25:53.421]                   name <- removed[[kk]]
[10:25:53.421]                   NAME <- NAMES[[kk]]
[10:25:53.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.421]                     next
[10:25:53.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.421]                 }
[10:25:53.421]                 if (length(args) > 0) 
[10:25:53.421]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.421]             }
[10:25:53.421]             else {
[10:25:53.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.421]             }
[10:25:53.421]             {
[10:25:53.421]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.421]                   0L) {
[10:25:53.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.421]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.421]                   base::options(opts)
[10:25:53.421]                 }
[10:25:53.421]                 {
[10:25:53.421]                   {
[10:25:53.421]                     NULL
[10:25:53.421]                     RNGkind("Mersenne-Twister")
[10:25:53.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.421]                       inherits = FALSE)
[10:25:53.421]                   }
[10:25:53.421]                   options(future.plan = NULL)
[10:25:53.421]                   if (is.na(NA_character_)) 
[10:25:53.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.421]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.421]                   {
[10:25:53.421]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.421]                     if (!future$lazy) 
[10:25:53.421]                       future <- run(future)
[10:25:53.421]                     invisible(future)
[10:25:53.421]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.421]                 }
[10:25:53.421]             }
[10:25:53.421]         }
[10:25:53.421]     })
[10:25:53.421]     if (TRUE) {
[10:25:53.421]         base::sink(type = "output", split = FALSE)
[10:25:53.421]         if (TRUE) {
[10:25:53.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.421]         }
[10:25:53.421]         else {
[10:25:53.421]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.421]         }
[10:25:53.421]         base::close(...future.stdout)
[10:25:53.421]         ...future.stdout <- NULL
[10:25:53.421]     }
[10:25:53.421]     ...future.result$conditions <- ...future.conditions
[10:25:53.421]     ...future.result$finished <- base::Sys.time()
[10:25:53.421]     ...future.result
[10:25:53.421] }
[10:25:53.423] assign_globals() ...
[10:25:53.423] List of 2
[10:25:53.423]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.423]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.423]  - attr(*, "where")=List of 2
[10:25:53.423]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.423]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.423]  - attr(*, "resolved")= logi FALSE
[10:25:53.423]  - attr(*, "total_size")= num 896
[10:25:53.423]  - attr(*, "already-done")= logi TRUE
[10:25:53.426] - copied ‘weight’ to environment
[10:25:53.426] - copied ‘group’ to environment
[10:25:53.427] assign_globals() ... done
[10:25:53.427] plan(): Setting new future strategy stack:
[10:25:53.427] List of future strategies:
[10:25:53.427] 1. sequential:
[10:25:53.427]    - args: function (..., envir = parent.frame())
[10:25:53.427]    - tweaked: FALSE
[10:25:53.427]    - call: NULL
[10:25:53.427] plan(): nbrOfWorkers() = 1
[10:25:53.429] plan(): Setting new future strategy stack:
[10:25:53.429] List of future strategies:
[10:25:53.429] 1. sequential:
[10:25:53.429]    - args: function (..., envir = parent.frame())
[10:25:53.429]    - tweaked: FALSE
[10:25:53.429]    - call: plan(strategy)
[10:25:53.430] plan(): nbrOfWorkers() = 1
[10:25:53.430] SequentialFuture started (and completed)
[10:25:53.430] - Launch lazy future ... done
[10:25:53.430] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.435] getGlobalsAndPackages() ...
[10:25:53.435] Searching for globals...
[10:25:53.436] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.437] Searching for globals ... DONE
[10:25:53.437] Resolving globals: FALSE
[10:25:53.437] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.438] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.438] - globals: [2] ‘weight’, ‘group’
[10:25:53.438] - packages: [1] ‘stats’
[10:25:53.438] getGlobalsAndPackages() ... DONE
[10:25:53.438] run() for ‘Future’ ...
[10:25:53.438] - state: ‘created’
[10:25:53.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.439]   - Field: ‘label’
[10:25:53.439]   - Field: ‘local’
[10:25:53.439]   - Field: ‘owner’
[10:25:53.439]   - Field: ‘envir’
[10:25:53.439]   - Field: ‘packages’
[10:25:53.439]   - Field: ‘gc’
[10:25:53.439]   - Field: ‘conditions’
[10:25:53.439]   - Field: ‘expr’
[10:25:53.440]   - Field: ‘uuid’
[10:25:53.440]   - Field: ‘seed’
[10:25:53.440]   - Field: ‘version’
[10:25:53.440]   - Field: ‘result’
[10:25:53.440]   - Field: ‘asynchronous’
[10:25:53.440]   - Field: ‘calls’
[10:25:53.440]   - Field: ‘globals’
[10:25:53.440]   - Field: ‘stdout’
[10:25:53.440]   - Field: ‘earlySignal’
[10:25:53.440]   - Field: ‘lazy’
[10:25:53.440]   - Field: ‘state’
[10:25:53.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.441] - Launch lazy future ...
[10:25:53.441] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.441] Packages needed by future strategies (n = 0): <none>
[10:25:53.441] {
[10:25:53.441]     {
[10:25:53.441]         {
[10:25:53.441]             ...future.startTime <- base::Sys.time()
[10:25:53.441]             {
[10:25:53.441]                 {
[10:25:53.441]                   {
[10:25:53.441]                     {
[10:25:53.441]                       base::local({
[10:25:53.441]                         has_future <- base::requireNamespace("future", 
[10:25:53.441]                           quietly = TRUE)
[10:25:53.441]                         if (has_future) {
[10:25:53.441]                           ns <- base::getNamespace("future")
[10:25:53.441]                           version <- ns[[".package"]][["version"]]
[10:25:53.441]                           if (is.null(version)) 
[10:25:53.441]                             version <- utils::packageVersion("future")
[10:25:53.441]                         }
[10:25:53.441]                         else {
[10:25:53.441]                           version <- NULL
[10:25:53.441]                         }
[10:25:53.441]                         if (!has_future || version < "1.8.0") {
[10:25:53.441]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.441]                             "", base::R.version$version.string), 
[10:25:53.441]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.441]                               "release", "version")], collapse = " "), 
[10:25:53.441]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.441]                             info)
[10:25:53.441]                           info <- base::paste(info, collapse = "; ")
[10:25:53.441]                           if (!has_future) {
[10:25:53.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.441]                               info)
[10:25:53.441]                           }
[10:25:53.441]                           else {
[10:25:53.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.441]                               info, version)
[10:25:53.441]                           }
[10:25:53.441]                           base::stop(msg)
[10:25:53.441]                         }
[10:25:53.441]                       })
[10:25:53.441]                     }
[10:25:53.441]                     base::local({
[10:25:53.441]                       for (pkg in "stats") {
[10:25:53.441]                         base::loadNamespace(pkg)
[10:25:53.441]                         base::library(pkg, character.only = TRUE)
[10:25:53.441]                       }
[10:25:53.441]                     })
[10:25:53.441]                   }
[10:25:53.441]                   options(future.plan = NULL)
[10:25:53.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.441]                 }
[10:25:53.441]                 ...future.workdir <- getwd()
[10:25:53.441]             }
[10:25:53.441]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.441]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.441]         }
[10:25:53.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.441]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.441]             base::names(...future.oldOptions))
[10:25:53.441]     }
[10:25:53.441]     if (FALSE) {
[10:25:53.441]     }
[10:25:53.441]     else {
[10:25:53.441]         if (TRUE) {
[10:25:53.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.441]                 open = "w")
[10:25:53.441]         }
[10:25:53.441]         else {
[10:25:53.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.441]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.441]         }
[10:25:53.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.441]             base::sink(type = "output", split = FALSE)
[10:25:53.441]             base::close(...future.stdout)
[10:25:53.441]         }, add = TRUE)
[10:25:53.441]     }
[10:25:53.441]     ...future.frame <- base::sys.nframe()
[10:25:53.441]     ...future.conditions <- base::list()
[10:25:53.441]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.441]     if (FALSE) {
[10:25:53.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.441]     }
[10:25:53.441]     ...future.result <- base::tryCatch({
[10:25:53.441]         base::withCallingHandlers({
[10:25:53.441]             ...future.value <- base::withVisible(base::local({
[10:25:53.441]                 lm(weight ~ group - 1)
[10:25:53.441]             }))
[10:25:53.441]             future::FutureResult(value = ...future.value$value, 
[10:25:53.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.441]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.441]                     ...future.globalenv.names))
[10:25:53.441]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.441]         }, condition = base::local({
[10:25:53.441]             c <- base::c
[10:25:53.441]             inherits <- base::inherits
[10:25:53.441]             invokeRestart <- base::invokeRestart
[10:25:53.441]             length <- base::length
[10:25:53.441]             list <- base::list
[10:25:53.441]             seq.int <- base::seq.int
[10:25:53.441]             signalCondition <- base::signalCondition
[10:25:53.441]             sys.calls <- base::sys.calls
[10:25:53.441]             `[[` <- base::`[[`
[10:25:53.441]             `+` <- base::`+`
[10:25:53.441]             `<<-` <- base::`<<-`
[10:25:53.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.441]                   3L)]
[10:25:53.441]             }
[10:25:53.441]             function(cond) {
[10:25:53.441]                 is_error <- inherits(cond, "error")
[10:25:53.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.441]                   NULL)
[10:25:53.441]                 if (is_error) {
[10:25:53.441]                   sessionInformation <- function() {
[10:25:53.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.441]                       search = base::search(), system = base::Sys.info())
[10:25:53.441]                   }
[10:25:53.441]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.441]                     cond$call), session = sessionInformation(), 
[10:25:53.441]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.441]                   signalCondition(cond)
[10:25:53.441]                 }
[10:25:53.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.441]                 "immediateCondition"))) {
[10:25:53.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.441]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.441]                   if (TRUE && !signal) {
[10:25:53.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.441]                     {
[10:25:53.441]                       inherits <- base::inherits
[10:25:53.441]                       invokeRestart <- base::invokeRestart
[10:25:53.441]                       is.null <- base::is.null
[10:25:53.441]                       muffled <- FALSE
[10:25:53.441]                       if (inherits(cond, "message")) {
[10:25:53.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.441]                         if (muffled) 
[10:25:53.441]                           invokeRestart("muffleMessage")
[10:25:53.441]                       }
[10:25:53.441]                       else if (inherits(cond, "warning")) {
[10:25:53.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.441]                         if (muffled) 
[10:25:53.441]                           invokeRestart("muffleWarning")
[10:25:53.441]                       }
[10:25:53.441]                       else if (inherits(cond, "condition")) {
[10:25:53.441]                         if (!is.null(pattern)) {
[10:25:53.441]                           computeRestarts <- base::computeRestarts
[10:25:53.441]                           grepl <- base::grepl
[10:25:53.441]                           restarts <- computeRestarts(cond)
[10:25:53.441]                           for (restart in restarts) {
[10:25:53.441]                             name <- restart$name
[10:25:53.441]                             if (is.null(name)) 
[10:25:53.441]                               next
[10:25:53.441]                             if (!grepl(pattern, name)) 
[10:25:53.441]                               next
[10:25:53.441]                             invokeRestart(restart)
[10:25:53.441]                             muffled <- TRUE
[10:25:53.441]                             break
[10:25:53.441]                           }
[10:25:53.441]                         }
[10:25:53.441]                       }
[10:25:53.441]                       invisible(muffled)
[10:25:53.441]                     }
[10:25:53.441]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.441]                   }
[10:25:53.441]                 }
[10:25:53.441]                 else {
[10:25:53.441]                   if (TRUE) {
[10:25:53.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.441]                     {
[10:25:53.441]                       inherits <- base::inherits
[10:25:53.441]                       invokeRestart <- base::invokeRestart
[10:25:53.441]                       is.null <- base::is.null
[10:25:53.441]                       muffled <- FALSE
[10:25:53.441]                       if (inherits(cond, "message")) {
[10:25:53.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.441]                         if (muffled) 
[10:25:53.441]                           invokeRestart("muffleMessage")
[10:25:53.441]                       }
[10:25:53.441]                       else if (inherits(cond, "warning")) {
[10:25:53.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.441]                         if (muffled) 
[10:25:53.441]                           invokeRestart("muffleWarning")
[10:25:53.441]                       }
[10:25:53.441]                       else if (inherits(cond, "condition")) {
[10:25:53.441]                         if (!is.null(pattern)) {
[10:25:53.441]                           computeRestarts <- base::computeRestarts
[10:25:53.441]                           grepl <- base::grepl
[10:25:53.441]                           restarts <- computeRestarts(cond)
[10:25:53.441]                           for (restart in restarts) {
[10:25:53.441]                             name <- restart$name
[10:25:53.441]                             if (is.null(name)) 
[10:25:53.441]                               next
[10:25:53.441]                             if (!grepl(pattern, name)) 
[10:25:53.441]                               next
[10:25:53.441]                             invokeRestart(restart)
[10:25:53.441]                             muffled <- TRUE
[10:25:53.441]                             break
[10:25:53.441]                           }
[10:25:53.441]                         }
[10:25:53.441]                       }
[10:25:53.441]                       invisible(muffled)
[10:25:53.441]                     }
[10:25:53.441]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.441]                   }
[10:25:53.441]                 }
[10:25:53.441]             }
[10:25:53.441]         }))
[10:25:53.441]     }, error = function(ex) {
[10:25:53.441]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.441]                 ...future.rng), started = ...future.startTime, 
[10:25:53.441]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.441]             version = "1.8"), class = "FutureResult")
[10:25:53.441]     }, finally = {
[10:25:53.441]         if (!identical(...future.workdir, getwd())) 
[10:25:53.441]             setwd(...future.workdir)
[10:25:53.441]         {
[10:25:53.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.441]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.441]             }
[10:25:53.441]             base::options(...future.oldOptions)
[10:25:53.441]             if (.Platform$OS.type == "windows") {
[10:25:53.441]                 old_names <- names(...future.oldEnvVars)
[10:25:53.441]                 envs <- base::Sys.getenv()
[10:25:53.441]                 names <- names(envs)
[10:25:53.441]                 common <- intersect(names, old_names)
[10:25:53.441]                 added <- setdiff(names, old_names)
[10:25:53.441]                 removed <- setdiff(old_names, names)
[10:25:53.441]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.441]                   envs[common]]
[10:25:53.441]                 NAMES <- toupper(changed)
[10:25:53.441]                 args <- list()
[10:25:53.441]                 for (kk in seq_along(NAMES)) {
[10:25:53.441]                   name <- changed[[kk]]
[10:25:53.441]                   NAME <- NAMES[[kk]]
[10:25:53.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.441]                     next
[10:25:53.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.441]                 }
[10:25:53.441]                 NAMES <- toupper(added)
[10:25:53.441]                 for (kk in seq_along(NAMES)) {
[10:25:53.441]                   name <- added[[kk]]
[10:25:53.441]                   NAME <- NAMES[[kk]]
[10:25:53.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.441]                     next
[10:25:53.441]                   args[[name]] <- ""
[10:25:53.441]                 }
[10:25:53.441]                 NAMES <- toupper(removed)
[10:25:53.441]                 for (kk in seq_along(NAMES)) {
[10:25:53.441]                   name <- removed[[kk]]
[10:25:53.441]                   NAME <- NAMES[[kk]]
[10:25:53.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.441]                     next
[10:25:53.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.441]                 }
[10:25:53.441]                 if (length(args) > 0) 
[10:25:53.441]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.441]             }
[10:25:53.441]             else {
[10:25:53.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.441]             }
[10:25:53.441]             {
[10:25:53.441]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.441]                   0L) {
[10:25:53.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.441]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.441]                   base::options(opts)
[10:25:53.441]                 }
[10:25:53.441]                 {
[10:25:53.441]                   {
[10:25:53.441]                     NULL
[10:25:53.441]                     RNGkind("Mersenne-Twister")
[10:25:53.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.441]                       inherits = FALSE)
[10:25:53.441]                   }
[10:25:53.441]                   options(future.plan = NULL)
[10:25:53.441]                   if (is.na(NA_character_)) 
[10:25:53.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.441]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.441]                   {
[10:25:53.441]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.441]                     if (!future$lazy) 
[10:25:53.441]                       future <- run(future)
[10:25:53.441]                     invisible(future)
[10:25:53.441]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.441]                 }
[10:25:53.441]             }
[10:25:53.441]         }
[10:25:53.441]     })
[10:25:53.441]     if (TRUE) {
[10:25:53.441]         base::sink(type = "output", split = FALSE)
[10:25:53.441]         if (TRUE) {
[10:25:53.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.441]         }
[10:25:53.441]         else {
[10:25:53.441]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.441]         }
[10:25:53.441]         base::close(...future.stdout)
[10:25:53.441]         ...future.stdout <- NULL
[10:25:53.441]     }
[10:25:53.441]     ...future.result$conditions <- ...future.conditions
[10:25:53.441]     ...future.result$finished <- base::Sys.time()
[10:25:53.441]     ...future.result
[10:25:53.441] }
[10:25:53.443] assign_globals() ...
[10:25:53.443] List of 2
[10:25:53.443]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.443]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.443]  - attr(*, "where")=List of 2
[10:25:53.443]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.443]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.443]  - attr(*, "resolved")= logi FALSE
[10:25:53.443]  - attr(*, "total_size")= num 896
[10:25:53.443]  - attr(*, "already-done")= logi TRUE
[10:25:53.446] - copied ‘weight’ to environment
[10:25:53.446] - copied ‘group’ to environment
[10:25:53.446] assign_globals() ... done
[10:25:53.446] plan(): Setting new future strategy stack:
[10:25:53.447] List of future strategies:
[10:25:53.447] 1. sequential:
[10:25:53.447]    - args: function (..., envir = parent.frame())
[10:25:53.447]    - tweaked: FALSE
[10:25:53.447]    - call: NULL
[10:25:53.447] plan(): nbrOfWorkers() = 1
[10:25:53.448] plan(): Setting new future strategy stack:
[10:25:53.448] List of future strategies:
[10:25:53.448] 1. sequential:
[10:25:53.448]    - args: function (..., envir = parent.frame())
[10:25:53.448]    - tweaked: FALSE
[10:25:53.448]    - call: plan(strategy)
[10:25:53.449] plan(): nbrOfWorkers() = 1
[10:25:53.449] SequentialFuture started (and completed)
[10:25:53.449] - Launch lazy future ... done
[10:25:53.449] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.451] getGlobalsAndPackages() ...
[10:25:53.452] Searching for globals...
[10:25:53.453] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.453] Searching for globals ... DONE
[10:25:53.453] Resolving globals: FALSE
[10:25:53.454] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.454] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.454] - globals: [2] ‘weight’, ‘group’
[10:25:53.454] - packages: [1] ‘stats’
[10:25:53.454] getGlobalsAndPackages() ... DONE
[10:25:53.455] run() for ‘Future’ ...
[10:25:53.455] - state: ‘created’
[10:25:53.455] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.455] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.455]   - Field: ‘label’
[10:25:53.455]   - Field: ‘local’
[10:25:53.455]   - Field: ‘owner’
[10:25:53.456]   - Field: ‘envir’
[10:25:53.456]   - Field: ‘packages’
[10:25:53.456]   - Field: ‘gc’
[10:25:53.456]   - Field: ‘conditions’
[10:25:53.456]   - Field: ‘expr’
[10:25:53.456]   - Field: ‘uuid’
[10:25:53.456]   - Field: ‘seed’
[10:25:53.456]   - Field: ‘version’
[10:25:53.456]   - Field: ‘result’
[10:25:53.456]   - Field: ‘asynchronous’
[10:25:53.456]   - Field: ‘calls’
[10:25:53.457]   - Field: ‘globals’
[10:25:53.457]   - Field: ‘stdout’
[10:25:53.457]   - Field: ‘earlySignal’
[10:25:53.457]   - Field: ‘lazy’
[10:25:53.457]   - Field: ‘state’
[10:25:53.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.457] - Launch lazy future ...
[10:25:53.457] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.457] Packages needed by future strategies (n = 0): <none>
[10:25:53.459] {
[10:25:53.459]     {
[10:25:53.459]         {
[10:25:53.459]             ...future.startTime <- base::Sys.time()
[10:25:53.459]             {
[10:25:53.459]                 {
[10:25:53.459]                   {
[10:25:53.459]                     {
[10:25:53.459]                       base::local({
[10:25:53.459]                         has_future <- base::requireNamespace("future", 
[10:25:53.459]                           quietly = TRUE)
[10:25:53.459]                         if (has_future) {
[10:25:53.459]                           ns <- base::getNamespace("future")
[10:25:53.459]                           version <- ns[[".package"]][["version"]]
[10:25:53.459]                           if (is.null(version)) 
[10:25:53.459]                             version <- utils::packageVersion("future")
[10:25:53.459]                         }
[10:25:53.459]                         else {
[10:25:53.459]                           version <- NULL
[10:25:53.459]                         }
[10:25:53.459]                         if (!has_future || version < "1.8.0") {
[10:25:53.459]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.459]                             "", base::R.version$version.string), 
[10:25:53.459]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.459]                               "release", "version")], collapse = " "), 
[10:25:53.459]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.459]                             info)
[10:25:53.459]                           info <- base::paste(info, collapse = "; ")
[10:25:53.459]                           if (!has_future) {
[10:25:53.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.459]                               info)
[10:25:53.459]                           }
[10:25:53.459]                           else {
[10:25:53.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.459]                               info, version)
[10:25:53.459]                           }
[10:25:53.459]                           base::stop(msg)
[10:25:53.459]                         }
[10:25:53.459]                       })
[10:25:53.459]                     }
[10:25:53.459]                     base::local({
[10:25:53.459]                       for (pkg in "stats") {
[10:25:53.459]                         base::loadNamespace(pkg)
[10:25:53.459]                         base::library(pkg, character.only = TRUE)
[10:25:53.459]                       }
[10:25:53.459]                     })
[10:25:53.459]                   }
[10:25:53.459]                   options(future.plan = NULL)
[10:25:53.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.459]                 }
[10:25:53.459]                 ...future.workdir <- getwd()
[10:25:53.459]             }
[10:25:53.459]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.459]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.459]         }
[10:25:53.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.459]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.459]             base::names(...future.oldOptions))
[10:25:53.459]     }
[10:25:53.459]     if (FALSE) {
[10:25:53.459]     }
[10:25:53.459]     else {
[10:25:53.459]         if (TRUE) {
[10:25:53.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.459]                 open = "w")
[10:25:53.459]         }
[10:25:53.459]         else {
[10:25:53.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.459]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.459]         }
[10:25:53.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.459]             base::sink(type = "output", split = FALSE)
[10:25:53.459]             base::close(...future.stdout)
[10:25:53.459]         }, add = TRUE)
[10:25:53.459]     }
[10:25:53.459]     ...future.frame <- base::sys.nframe()
[10:25:53.459]     ...future.conditions <- base::list()
[10:25:53.459]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.459]     if (FALSE) {
[10:25:53.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.459]     }
[10:25:53.459]     ...future.result <- base::tryCatch({
[10:25:53.459]         base::withCallingHandlers({
[10:25:53.459]             ...future.value <- base::withVisible(base::local({
[10:25:53.459]                 lm(weight ~ group - 1)
[10:25:53.459]             }))
[10:25:53.459]             future::FutureResult(value = ...future.value$value, 
[10:25:53.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.459]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.459]                     ...future.globalenv.names))
[10:25:53.459]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.459]         }, condition = base::local({
[10:25:53.459]             c <- base::c
[10:25:53.459]             inherits <- base::inherits
[10:25:53.459]             invokeRestart <- base::invokeRestart
[10:25:53.459]             length <- base::length
[10:25:53.459]             list <- base::list
[10:25:53.459]             seq.int <- base::seq.int
[10:25:53.459]             signalCondition <- base::signalCondition
[10:25:53.459]             sys.calls <- base::sys.calls
[10:25:53.459]             `[[` <- base::`[[`
[10:25:53.459]             `+` <- base::`+`
[10:25:53.459]             `<<-` <- base::`<<-`
[10:25:53.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.459]                   3L)]
[10:25:53.459]             }
[10:25:53.459]             function(cond) {
[10:25:53.459]                 is_error <- inherits(cond, "error")
[10:25:53.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.459]                   NULL)
[10:25:53.459]                 if (is_error) {
[10:25:53.459]                   sessionInformation <- function() {
[10:25:53.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.459]                       search = base::search(), system = base::Sys.info())
[10:25:53.459]                   }
[10:25:53.459]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.459]                     cond$call), session = sessionInformation(), 
[10:25:53.459]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.459]                   signalCondition(cond)
[10:25:53.459]                 }
[10:25:53.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.459]                 "immediateCondition"))) {
[10:25:53.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.459]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.459]                   if (TRUE && !signal) {
[10:25:53.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.459]                     {
[10:25:53.459]                       inherits <- base::inherits
[10:25:53.459]                       invokeRestart <- base::invokeRestart
[10:25:53.459]                       is.null <- base::is.null
[10:25:53.459]                       muffled <- FALSE
[10:25:53.459]                       if (inherits(cond, "message")) {
[10:25:53.459]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.459]                         if (muffled) 
[10:25:53.459]                           invokeRestart("muffleMessage")
[10:25:53.459]                       }
[10:25:53.459]                       else if (inherits(cond, "warning")) {
[10:25:53.459]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.459]                         if (muffled) 
[10:25:53.459]                           invokeRestart("muffleWarning")
[10:25:53.459]                       }
[10:25:53.459]                       else if (inherits(cond, "condition")) {
[10:25:53.459]                         if (!is.null(pattern)) {
[10:25:53.459]                           computeRestarts <- base::computeRestarts
[10:25:53.459]                           grepl <- base::grepl
[10:25:53.459]                           restarts <- computeRestarts(cond)
[10:25:53.459]                           for (restart in restarts) {
[10:25:53.459]                             name <- restart$name
[10:25:53.459]                             if (is.null(name)) 
[10:25:53.459]                               next
[10:25:53.459]                             if (!grepl(pattern, name)) 
[10:25:53.459]                               next
[10:25:53.459]                             invokeRestart(restart)
[10:25:53.459]                             muffled <- TRUE
[10:25:53.459]                             break
[10:25:53.459]                           }
[10:25:53.459]                         }
[10:25:53.459]                       }
[10:25:53.459]                       invisible(muffled)
[10:25:53.459]                     }
[10:25:53.459]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.459]                   }
[10:25:53.459]                 }
[10:25:53.459]                 else {
[10:25:53.459]                   if (TRUE) {
[10:25:53.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.459]                     {
[10:25:53.459]                       inherits <- base::inherits
[10:25:53.459]                       invokeRestart <- base::invokeRestart
[10:25:53.459]                       is.null <- base::is.null
[10:25:53.459]                       muffled <- FALSE
[10:25:53.459]                       if (inherits(cond, "message")) {
[10:25:53.459]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.459]                         if (muffled) 
[10:25:53.459]                           invokeRestart("muffleMessage")
[10:25:53.459]                       }
[10:25:53.459]                       else if (inherits(cond, "warning")) {
[10:25:53.459]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.459]                         if (muffled) 
[10:25:53.459]                           invokeRestart("muffleWarning")
[10:25:53.459]                       }
[10:25:53.459]                       else if (inherits(cond, "condition")) {
[10:25:53.459]                         if (!is.null(pattern)) {
[10:25:53.459]                           computeRestarts <- base::computeRestarts
[10:25:53.459]                           grepl <- base::grepl
[10:25:53.459]                           restarts <- computeRestarts(cond)
[10:25:53.459]                           for (restart in restarts) {
[10:25:53.459]                             name <- restart$name
[10:25:53.459]                             if (is.null(name)) 
[10:25:53.459]                               next
[10:25:53.459]                             if (!grepl(pattern, name)) 
[10:25:53.459]                               next
[10:25:53.459]                             invokeRestart(restart)
[10:25:53.459]                             muffled <- TRUE
[10:25:53.459]                             break
[10:25:53.459]                           }
[10:25:53.459]                         }
[10:25:53.459]                       }
[10:25:53.459]                       invisible(muffled)
[10:25:53.459]                     }
[10:25:53.459]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.459]                   }
[10:25:53.459]                 }
[10:25:53.459]             }
[10:25:53.459]         }))
[10:25:53.459]     }, error = function(ex) {
[10:25:53.459]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.459]                 ...future.rng), started = ...future.startTime, 
[10:25:53.459]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.459]             version = "1.8"), class = "FutureResult")
[10:25:53.459]     }, finally = {
[10:25:53.459]         if (!identical(...future.workdir, getwd())) 
[10:25:53.459]             setwd(...future.workdir)
[10:25:53.459]         {
[10:25:53.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.459]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.459]             }
[10:25:53.459]             base::options(...future.oldOptions)
[10:25:53.459]             if (.Platform$OS.type == "windows") {
[10:25:53.459]                 old_names <- names(...future.oldEnvVars)
[10:25:53.459]                 envs <- base::Sys.getenv()
[10:25:53.459]                 names <- names(envs)
[10:25:53.459]                 common <- intersect(names, old_names)
[10:25:53.459]                 added <- setdiff(names, old_names)
[10:25:53.459]                 removed <- setdiff(old_names, names)
[10:25:53.459]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.459]                   envs[common]]
[10:25:53.459]                 NAMES <- toupper(changed)
[10:25:53.459]                 args <- list()
[10:25:53.459]                 for (kk in seq_along(NAMES)) {
[10:25:53.459]                   name <- changed[[kk]]
[10:25:53.459]                   NAME <- NAMES[[kk]]
[10:25:53.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.459]                     next
[10:25:53.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.459]                 }
[10:25:53.459]                 NAMES <- toupper(added)
[10:25:53.459]                 for (kk in seq_along(NAMES)) {
[10:25:53.459]                   name <- added[[kk]]
[10:25:53.459]                   NAME <- NAMES[[kk]]
[10:25:53.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.459]                     next
[10:25:53.459]                   args[[name]] <- ""
[10:25:53.459]                 }
[10:25:53.459]                 NAMES <- toupper(removed)
[10:25:53.459]                 for (kk in seq_along(NAMES)) {
[10:25:53.459]                   name <- removed[[kk]]
[10:25:53.459]                   NAME <- NAMES[[kk]]
[10:25:53.459]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.459]                     next
[10:25:53.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.459]                 }
[10:25:53.459]                 if (length(args) > 0) 
[10:25:53.459]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.459]             }
[10:25:53.459]             else {
[10:25:53.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.459]             }
[10:25:53.459]             {
[10:25:53.459]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.459]                   0L) {
[10:25:53.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.459]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.459]                   base::options(opts)
[10:25:53.459]                 }
[10:25:53.459]                 {
[10:25:53.459]                   {
[10:25:53.459]                     NULL
[10:25:53.459]                     RNGkind("Mersenne-Twister")
[10:25:53.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.459]                       inherits = FALSE)
[10:25:53.459]                   }
[10:25:53.459]                   options(future.plan = NULL)
[10:25:53.459]                   if (is.na(NA_character_)) 
[10:25:53.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.459]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.459]                   {
[10:25:53.459]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.459]                     if (!future$lazy) 
[10:25:53.459]                       future <- run(future)
[10:25:53.459]                     invisible(future)
[10:25:53.459]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.459]                 }
[10:25:53.459]             }
[10:25:53.459]         }
[10:25:53.459]     })
[10:25:53.459]     if (TRUE) {
[10:25:53.459]         base::sink(type = "output", split = FALSE)
[10:25:53.459]         if (TRUE) {
[10:25:53.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.459]         }
[10:25:53.459]         else {
[10:25:53.459]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.459]         }
[10:25:53.459]         base::close(...future.stdout)
[10:25:53.459]         ...future.stdout <- NULL
[10:25:53.459]     }
[10:25:53.459]     ...future.result$conditions <- ...future.conditions
[10:25:53.459]     ...future.result$finished <- base::Sys.time()
[10:25:53.459]     ...future.result
[10:25:53.459] }
[10:25:53.461] assign_globals() ...
[10:25:53.461] List of 2
[10:25:53.461]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.461]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.461]  - attr(*, "where")=List of 2
[10:25:53.461]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.461]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.461]  - attr(*, "resolved")= logi FALSE
[10:25:53.461]  - attr(*, "total_size")= num 896
[10:25:53.461]  - attr(*, "already-done")= logi TRUE
[10:25:53.464] - copied ‘weight’ to environment
[10:25:53.464] - copied ‘group’ to environment
[10:25:53.464] assign_globals() ... done
[10:25:53.464] plan(): Setting new future strategy stack:
[10:25:53.464] List of future strategies:
[10:25:53.464] 1. sequential:
[10:25:53.464]    - args: function (..., envir = parent.frame())
[10:25:53.464]    - tweaked: FALSE
[10:25:53.464]    - call: NULL
[10:25:53.465] plan(): nbrOfWorkers() = 1
[10:25:53.466] plan(): Setting new future strategy stack:
[10:25:53.466] List of future strategies:
[10:25:53.466] 1. sequential:
[10:25:53.466]    - args: function (..., envir = parent.frame())
[10:25:53.466]    - tweaked: FALSE
[10:25:53.466]    - call: plan(strategy)
[10:25:53.466] plan(): nbrOfWorkers() = 1
[10:25:53.467] SequentialFuture started (and completed)
[10:25:53.467] - Launch lazy future ... done
[10:25:53.467] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.469] getGlobalsAndPackages() ...
[10:25:53.469] Searching for globals...
[10:25:53.470] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.470] Searching for globals ... DONE
[10:25:53.470] Resolving globals: FALSE
[10:25:53.471] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.471] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.471] - globals: [2] ‘weight’, ‘group’
[10:25:53.471] - packages: [1] ‘stats’
[10:25:53.471] getGlobalsAndPackages() ... DONE
[10:25:53.472] run() for ‘Future’ ...
[10:25:53.472] - state: ‘created’
[10:25:53.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.472]   - Field: ‘label’
[10:25:53.472]   - Field: ‘local’
[10:25:53.472]   - Field: ‘owner’
[10:25:53.472]   - Field: ‘envir’
[10:25:53.473]   - Field: ‘packages’
[10:25:53.473]   - Field: ‘gc’
[10:25:53.473]   - Field: ‘conditions’
[10:25:53.473]   - Field: ‘expr’
[10:25:53.473]   - Field: ‘uuid’
[10:25:53.473]   - Field: ‘seed’
[10:25:53.473]   - Field: ‘version’
[10:25:53.473]   - Field: ‘result’
[10:25:53.473]   - Field: ‘asynchronous’
[10:25:53.473]   - Field: ‘calls’
[10:25:53.473]   - Field: ‘globals’
[10:25:53.473]   - Field: ‘stdout’
[10:25:53.474]   - Field: ‘earlySignal’
[10:25:53.474]   - Field: ‘lazy’
[10:25:53.474]   - Field: ‘state’
[10:25:53.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.474] - Launch lazy future ...
[10:25:53.474] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.474] Packages needed by future strategies (n = 0): <none>
[10:25:53.475] {
[10:25:53.475]     {
[10:25:53.475]         {
[10:25:53.475]             ...future.startTime <- base::Sys.time()
[10:25:53.475]             {
[10:25:53.475]                 {
[10:25:53.475]                   {
[10:25:53.475]                     {
[10:25:53.475]                       base::local({
[10:25:53.475]                         has_future <- base::requireNamespace("future", 
[10:25:53.475]                           quietly = TRUE)
[10:25:53.475]                         if (has_future) {
[10:25:53.475]                           ns <- base::getNamespace("future")
[10:25:53.475]                           version <- ns[[".package"]][["version"]]
[10:25:53.475]                           if (is.null(version)) 
[10:25:53.475]                             version <- utils::packageVersion("future")
[10:25:53.475]                         }
[10:25:53.475]                         else {
[10:25:53.475]                           version <- NULL
[10:25:53.475]                         }
[10:25:53.475]                         if (!has_future || version < "1.8.0") {
[10:25:53.475]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.475]                             "", base::R.version$version.string), 
[10:25:53.475]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.475]                               "release", "version")], collapse = " "), 
[10:25:53.475]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.475]                             info)
[10:25:53.475]                           info <- base::paste(info, collapse = "; ")
[10:25:53.475]                           if (!has_future) {
[10:25:53.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.475]                               info)
[10:25:53.475]                           }
[10:25:53.475]                           else {
[10:25:53.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.475]                               info, version)
[10:25:53.475]                           }
[10:25:53.475]                           base::stop(msg)
[10:25:53.475]                         }
[10:25:53.475]                       })
[10:25:53.475]                     }
[10:25:53.475]                     base::local({
[10:25:53.475]                       for (pkg in "stats") {
[10:25:53.475]                         base::loadNamespace(pkg)
[10:25:53.475]                         base::library(pkg, character.only = TRUE)
[10:25:53.475]                       }
[10:25:53.475]                     })
[10:25:53.475]                   }
[10:25:53.475]                   options(future.plan = NULL)
[10:25:53.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.475]                 }
[10:25:53.475]                 ...future.workdir <- getwd()
[10:25:53.475]             }
[10:25:53.475]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.475]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.475]         }
[10:25:53.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.475]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.475]             base::names(...future.oldOptions))
[10:25:53.475]     }
[10:25:53.475]     if (FALSE) {
[10:25:53.475]     }
[10:25:53.475]     else {
[10:25:53.475]         if (TRUE) {
[10:25:53.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.475]                 open = "w")
[10:25:53.475]         }
[10:25:53.475]         else {
[10:25:53.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.475]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.475]         }
[10:25:53.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.475]             base::sink(type = "output", split = FALSE)
[10:25:53.475]             base::close(...future.stdout)
[10:25:53.475]         }, add = TRUE)
[10:25:53.475]     }
[10:25:53.475]     ...future.frame <- base::sys.nframe()
[10:25:53.475]     ...future.conditions <- base::list()
[10:25:53.475]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.475]     if (FALSE) {
[10:25:53.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.475]     }
[10:25:53.475]     ...future.result <- base::tryCatch({
[10:25:53.475]         base::withCallingHandlers({
[10:25:53.475]             ...future.value <- base::withVisible(base::local({
[10:25:53.475]                 lm(weight ~ group - 1)
[10:25:53.475]             }))
[10:25:53.475]             future::FutureResult(value = ...future.value$value, 
[10:25:53.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.475]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.475]                     ...future.globalenv.names))
[10:25:53.475]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.475]         }, condition = base::local({
[10:25:53.475]             c <- base::c
[10:25:53.475]             inherits <- base::inherits
[10:25:53.475]             invokeRestart <- base::invokeRestart
[10:25:53.475]             length <- base::length
[10:25:53.475]             list <- base::list
[10:25:53.475]             seq.int <- base::seq.int
[10:25:53.475]             signalCondition <- base::signalCondition
[10:25:53.475]             sys.calls <- base::sys.calls
[10:25:53.475]             `[[` <- base::`[[`
[10:25:53.475]             `+` <- base::`+`
[10:25:53.475]             `<<-` <- base::`<<-`
[10:25:53.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.475]                   3L)]
[10:25:53.475]             }
[10:25:53.475]             function(cond) {
[10:25:53.475]                 is_error <- inherits(cond, "error")
[10:25:53.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.475]                   NULL)
[10:25:53.475]                 if (is_error) {
[10:25:53.475]                   sessionInformation <- function() {
[10:25:53.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.475]                       search = base::search(), system = base::Sys.info())
[10:25:53.475]                   }
[10:25:53.475]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.475]                     cond$call), session = sessionInformation(), 
[10:25:53.475]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.475]                   signalCondition(cond)
[10:25:53.475]                 }
[10:25:53.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.475]                 "immediateCondition"))) {
[10:25:53.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.475]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.475]                   if (TRUE && !signal) {
[10:25:53.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.475]                     {
[10:25:53.475]                       inherits <- base::inherits
[10:25:53.475]                       invokeRestart <- base::invokeRestart
[10:25:53.475]                       is.null <- base::is.null
[10:25:53.475]                       muffled <- FALSE
[10:25:53.475]                       if (inherits(cond, "message")) {
[10:25:53.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.475]                         if (muffled) 
[10:25:53.475]                           invokeRestart("muffleMessage")
[10:25:53.475]                       }
[10:25:53.475]                       else if (inherits(cond, "warning")) {
[10:25:53.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.475]                         if (muffled) 
[10:25:53.475]                           invokeRestart("muffleWarning")
[10:25:53.475]                       }
[10:25:53.475]                       else if (inherits(cond, "condition")) {
[10:25:53.475]                         if (!is.null(pattern)) {
[10:25:53.475]                           computeRestarts <- base::computeRestarts
[10:25:53.475]                           grepl <- base::grepl
[10:25:53.475]                           restarts <- computeRestarts(cond)
[10:25:53.475]                           for (restart in restarts) {
[10:25:53.475]                             name <- restart$name
[10:25:53.475]                             if (is.null(name)) 
[10:25:53.475]                               next
[10:25:53.475]                             if (!grepl(pattern, name)) 
[10:25:53.475]                               next
[10:25:53.475]                             invokeRestart(restart)
[10:25:53.475]                             muffled <- TRUE
[10:25:53.475]                             break
[10:25:53.475]                           }
[10:25:53.475]                         }
[10:25:53.475]                       }
[10:25:53.475]                       invisible(muffled)
[10:25:53.475]                     }
[10:25:53.475]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.475]                   }
[10:25:53.475]                 }
[10:25:53.475]                 else {
[10:25:53.475]                   if (TRUE) {
[10:25:53.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.475]                     {
[10:25:53.475]                       inherits <- base::inherits
[10:25:53.475]                       invokeRestart <- base::invokeRestart
[10:25:53.475]                       is.null <- base::is.null
[10:25:53.475]                       muffled <- FALSE
[10:25:53.475]                       if (inherits(cond, "message")) {
[10:25:53.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.475]                         if (muffled) 
[10:25:53.475]                           invokeRestart("muffleMessage")
[10:25:53.475]                       }
[10:25:53.475]                       else if (inherits(cond, "warning")) {
[10:25:53.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.475]                         if (muffled) 
[10:25:53.475]                           invokeRestart("muffleWarning")
[10:25:53.475]                       }
[10:25:53.475]                       else if (inherits(cond, "condition")) {
[10:25:53.475]                         if (!is.null(pattern)) {
[10:25:53.475]                           computeRestarts <- base::computeRestarts
[10:25:53.475]                           grepl <- base::grepl
[10:25:53.475]                           restarts <- computeRestarts(cond)
[10:25:53.475]                           for (restart in restarts) {
[10:25:53.475]                             name <- restart$name
[10:25:53.475]                             if (is.null(name)) 
[10:25:53.475]                               next
[10:25:53.475]                             if (!grepl(pattern, name)) 
[10:25:53.475]                               next
[10:25:53.475]                             invokeRestart(restart)
[10:25:53.475]                             muffled <- TRUE
[10:25:53.475]                             break
[10:25:53.475]                           }
[10:25:53.475]                         }
[10:25:53.475]                       }
[10:25:53.475]                       invisible(muffled)
[10:25:53.475]                     }
[10:25:53.475]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.475]                   }
[10:25:53.475]                 }
[10:25:53.475]             }
[10:25:53.475]         }))
[10:25:53.475]     }, error = function(ex) {
[10:25:53.475]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.475]                 ...future.rng), started = ...future.startTime, 
[10:25:53.475]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.475]             version = "1.8"), class = "FutureResult")
[10:25:53.475]     }, finally = {
[10:25:53.475]         if (!identical(...future.workdir, getwd())) 
[10:25:53.475]             setwd(...future.workdir)
[10:25:53.475]         {
[10:25:53.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.475]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.475]             }
[10:25:53.475]             base::options(...future.oldOptions)
[10:25:53.475]             if (.Platform$OS.type == "windows") {
[10:25:53.475]                 old_names <- names(...future.oldEnvVars)
[10:25:53.475]                 envs <- base::Sys.getenv()
[10:25:53.475]                 names <- names(envs)
[10:25:53.475]                 common <- intersect(names, old_names)
[10:25:53.475]                 added <- setdiff(names, old_names)
[10:25:53.475]                 removed <- setdiff(old_names, names)
[10:25:53.475]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.475]                   envs[common]]
[10:25:53.475]                 NAMES <- toupper(changed)
[10:25:53.475]                 args <- list()
[10:25:53.475]                 for (kk in seq_along(NAMES)) {
[10:25:53.475]                   name <- changed[[kk]]
[10:25:53.475]                   NAME <- NAMES[[kk]]
[10:25:53.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.475]                     next
[10:25:53.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.475]                 }
[10:25:53.475]                 NAMES <- toupper(added)
[10:25:53.475]                 for (kk in seq_along(NAMES)) {
[10:25:53.475]                   name <- added[[kk]]
[10:25:53.475]                   NAME <- NAMES[[kk]]
[10:25:53.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.475]                     next
[10:25:53.475]                   args[[name]] <- ""
[10:25:53.475]                 }
[10:25:53.475]                 NAMES <- toupper(removed)
[10:25:53.475]                 for (kk in seq_along(NAMES)) {
[10:25:53.475]                   name <- removed[[kk]]
[10:25:53.475]                   NAME <- NAMES[[kk]]
[10:25:53.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.475]                     next
[10:25:53.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.475]                 }
[10:25:53.475]                 if (length(args) > 0) 
[10:25:53.475]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.475]             }
[10:25:53.475]             else {
[10:25:53.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.475]             }
[10:25:53.475]             {
[10:25:53.475]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.475]                   0L) {
[10:25:53.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.475]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.475]                   base::options(opts)
[10:25:53.475]                 }
[10:25:53.475]                 {
[10:25:53.475]                   {
[10:25:53.475]                     NULL
[10:25:53.475]                     RNGkind("Mersenne-Twister")
[10:25:53.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.475]                       inherits = FALSE)
[10:25:53.475]                   }
[10:25:53.475]                   options(future.plan = NULL)
[10:25:53.475]                   if (is.na(NA_character_)) 
[10:25:53.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.475]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.475]                   {
[10:25:53.475]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.475]                     if (!future$lazy) 
[10:25:53.475]                       future <- run(future)
[10:25:53.475]                     invisible(future)
[10:25:53.475]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.475]                 }
[10:25:53.475]             }
[10:25:53.475]         }
[10:25:53.475]     })
[10:25:53.475]     if (TRUE) {
[10:25:53.475]         base::sink(type = "output", split = FALSE)
[10:25:53.475]         if (TRUE) {
[10:25:53.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.475]         }
[10:25:53.475]         else {
[10:25:53.475]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.475]         }
[10:25:53.475]         base::close(...future.stdout)
[10:25:53.475]         ...future.stdout <- NULL
[10:25:53.475]     }
[10:25:53.475]     ...future.result$conditions <- ...future.conditions
[10:25:53.475]     ...future.result$finished <- base::Sys.time()
[10:25:53.475]     ...future.result
[10:25:53.475] }
[10:25:53.476] assign_globals() ...
[10:25:53.476] List of 2
[10:25:53.476]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.476]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.476]  - attr(*, "where")=List of 2
[10:25:53.476]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.476]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.476]  - attr(*, "resolved")= logi FALSE
[10:25:53.476]  - attr(*, "total_size")= num 896
[10:25:53.476]  - attr(*, "already-done")= logi TRUE
[10:25:53.479] - copied ‘weight’ to environment
[10:25:53.479] - copied ‘group’ to environment
[10:25:53.480] assign_globals() ... done
[10:25:53.480] plan(): Setting new future strategy stack:
[10:25:53.480] List of future strategies:
[10:25:53.480] 1. sequential:
[10:25:53.480]    - args: function (..., envir = parent.frame())
[10:25:53.480]    - tweaked: FALSE
[10:25:53.480]    - call: NULL
[10:25:53.480] plan(): nbrOfWorkers() = 1
[10:25:53.482] plan(): Setting new future strategy stack:
[10:25:53.482] List of future strategies:
[10:25:53.482] 1. sequential:
[10:25:53.482]    - args: function (..., envir = parent.frame())
[10:25:53.482]    - tweaked: FALSE
[10:25:53.482]    - call: plan(strategy)
[10:25:53.482] plan(): nbrOfWorkers() = 1
[10:25:53.482] SequentialFuture started (and completed)
[10:25:53.482] - Launch lazy future ... done
[10:25:53.482] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.485] getGlobalsAndPackages() ...
[10:25:53.485] Searching for globals...
[10:25:53.487] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.487] Searching for globals ... DONE
[10:25:53.487] Resolving globals: FALSE
[10:25:53.487] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.488] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.488] - globals: [2] ‘weight’, ‘group’
[10:25:53.488] - packages: [1] ‘stats’
[10:25:53.488] getGlobalsAndPackages() ... DONE
[10:25:53.488] run() for ‘Future’ ...
[10:25:53.488] - state: ‘created’
[10:25:53.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.489] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.489]   - Field: ‘label’
[10:25:53.489]   - Field: ‘local’
[10:25:53.489]   - Field: ‘owner’
[10:25:53.489]   - Field: ‘envir’
[10:25:53.489]   - Field: ‘packages’
[10:25:53.490]   - Field: ‘gc’
[10:25:53.490]   - Field: ‘conditions’
[10:25:53.490]   - Field: ‘expr’
[10:25:53.490]   - Field: ‘uuid’
[10:25:53.490]   - Field: ‘seed’
[10:25:53.490]   - Field: ‘version’
[10:25:53.490]   - Field: ‘result’
[10:25:53.490]   - Field: ‘asynchronous’
[10:25:53.490]   - Field: ‘calls’
[10:25:53.490]   - Field: ‘globals’
[10:25:53.490]   - Field: ‘stdout’
[10:25:53.490]   - Field: ‘earlySignal’
[10:25:53.491]   - Field: ‘lazy’
[10:25:53.491]   - Field: ‘state’
[10:25:53.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.491] - Launch lazy future ...
[10:25:53.491] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.491] Packages needed by future strategies (n = 0): <none>
[10:25:53.492] {
[10:25:53.492]     {
[10:25:53.492]         {
[10:25:53.492]             ...future.startTime <- base::Sys.time()
[10:25:53.492]             {
[10:25:53.492]                 {
[10:25:53.492]                   {
[10:25:53.492]                     {
[10:25:53.492]                       base::local({
[10:25:53.492]                         has_future <- base::requireNamespace("future", 
[10:25:53.492]                           quietly = TRUE)
[10:25:53.492]                         if (has_future) {
[10:25:53.492]                           ns <- base::getNamespace("future")
[10:25:53.492]                           version <- ns[[".package"]][["version"]]
[10:25:53.492]                           if (is.null(version)) 
[10:25:53.492]                             version <- utils::packageVersion("future")
[10:25:53.492]                         }
[10:25:53.492]                         else {
[10:25:53.492]                           version <- NULL
[10:25:53.492]                         }
[10:25:53.492]                         if (!has_future || version < "1.8.0") {
[10:25:53.492]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.492]                             "", base::R.version$version.string), 
[10:25:53.492]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.492]                               "release", "version")], collapse = " "), 
[10:25:53.492]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.492]                             info)
[10:25:53.492]                           info <- base::paste(info, collapse = "; ")
[10:25:53.492]                           if (!has_future) {
[10:25:53.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.492]                               info)
[10:25:53.492]                           }
[10:25:53.492]                           else {
[10:25:53.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.492]                               info, version)
[10:25:53.492]                           }
[10:25:53.492]                           base::stop(msg)
[10:25:53.492]                         }
[10:25:53.492]                       })
[10:25:53.492]                     }
[10:25:53.492]                     base::local({
[10:25:53.492]                       for (pkg in "stats") {
[10:25:53.492]                         base::loadNamespace(pkg)
[10:25:53.492]                         base::library(pkg, character.only = TRUE)
[10:25:53.492]                       }
[10:25:53.492]                     })
[10:25:53.492]                   }
[10:25:53.492]                   options(future.plan = NULL)
[10:25:53.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.492]                 }
[10:25:53.492]                 ...future.workdir <- getwd()
[10:25:53.492]             }
[10:25:53.492]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.492]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.492]         }
[10:25:53.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.492]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.492]             base::names(...future.oldOptions))
[10:25:53.492]     }
[10:25:53.492]     if (FALSE) {
[10:25:53.492]     }
[10:25:53.492]     else {
[10:25:53.492]         if (TRUE) {
[10:25:53.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.492]                 open = "w")
[10:25:53.492]         }
[10:25:53.492]         else {
[10:25:53.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.492]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.492]         }
[10:25:53.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.492]             base::sink(type = "output", split = FALSE)
[10:25:53.492]             base::close(...future.stdout)
[10:25:53.492]         }, add = TRUE)
[10:25:53.492]     }
[10:25:53.492]     ...future.frame <- base::sys.nframe()
[10:25:53.492]     ...future.conditions <- base::list()
[10:25:53.492]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.492]     if (FALSE) {
[10:25:53.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.492]     }
[10:25:53.492]     ...future.result <- base::tryCatch({
[10:25:53.492]         base::withCallingHandlers({
[10:25:53.492]             ...future.value <- base::withVisible(base::local({
[10:25:53.492]                 lm(weight ~ group - 1)
[10:25:53.492]             }))
[10:25:53.492]             future::FutureResult(value = ...future.value$value, 
[10:25:53.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.492]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.492]                     ...future.globalenv.names))
[10:25:53.492]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.492]         }, condition = base::local({
[10:25:53.492]             c <- base::c
[10:25:53.492]             inherits <- base::inherits
[10:25:53.492]             invokeRestart <- base::invokeRestart
[10:25:53.492]             length <- base::length
[10:25:53.492]             list <- base::list
[10:25:53.492]             seq.int <- base::seq.int
[10:25:53.492]             signalCondition <- base::signalCondition
[10:25:53.492]             sys.calls <- base::sys.calls
[10:25:53.492]             `[[` <- base::`[[`
[10:25:53.492]             `+` <- base::`+`
[10:25:53.492]             `<<-` <- base::`<<-`
[10:25:53.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.492]                   3L)]
[10:25:53.492]             }
[10:25:53.492]             function(cond) {
[10:25:53.492]                 is_error <- inherits(cond, "error")
[10:25:53.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.492]                   NULL)
[10:25:53.492]                 if (is_error) {
[10:25:53.492]                   sessionInformation <- function() {
[10:25:53.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.492]                       search = base::search(), system = base::Sys.info())
[10:25:53.492]                   }
[10:25:53.492]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.492]                     cond$call), session = sessionInformation(), 
[10:25:53.492]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.492]                   signalCondition(cond)
[10:25:53.492]                 }
[10:25:53.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.492]                 "immediateCondition"))) {
[10:25:53.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.492]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.492]                   if (TRUE && !signal) {
[10:25:53.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.492]                     {
[10:25:53.492]                       inherits <- base::inherits
[10:25:53.492]                       invokeRestart <- base::invokeRestart
[10:25:53.492]                       is.null <- base::is.null
[10:25:53.492]                       muffled <- FALSE
[10:25:53.492]                       if (inherits(cond, "message")) {
[10:25:53.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.492]                         if (muffled) 
[10:25:53.492]                           invokeRestart("muffleMessage")
[10:25:53.492]                       }
[10:25:53.492]                       else if (inherits(cond, "warning")) {
[10:25:53.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.492]                         if (muffled) 
[10:25:53.492]                           invokeRestart("muffleWarning")
[10:25:53.492]                       }
[10:25:53.492]                       else if (inherits(cond, "condition")) {
[10:25:53.492]                         if (!is.null(pattern)) {
[10:25:53.492]                           computeRestarts <- base::computeRestarts
[10:25:53.492]                           grepl <- base::grepl
[10:25:53.492]                           restarts <- computeRestarts(cond)
[10:25:53.492]                           for (restart in restarts) {
[10:25:53.492]                             name <- restart$name
[10:25:53.492]                             if (is.null(name)) 
[10:25:53.492]                               next
[10:25:53.492]                             if (!grepl(pattern, name)) 
[10:25:53.492]                               next
[10:25:53.492]                             invokeRestart(restart)
[10:25:53.492]                             muffled <- TRUE
[10:25:53.492]                             break
[10:25:53.492]                           }
[10:25:53.492]                         }
[10:25:53.492]                       }
[10:25:53.492]                       invisible(muffled)
[10:25:53.492]                     }
[10:25:53.492]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.492]                   }
[10:25:53.492]                 }
[10:25:53.492]                 else {
[10:25:53.492]                   if (TRUE) {
[10:25:53.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.492]                     {
[10:25:53.492]                       inherits <- base::inherits
[10:25:53.492]                       invokeRestart <- base::invokeRestart
[10:25:53.492]                       is.null <- base::is.null
[10:25:53.492]                       muffled <- FALSE
[10:25:53.492]                       if (inherits(cond, "message")) {
[10:25:53.492]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.492]                         if (muffled) 
[10:25:53.492]                           invokeRestart("muffleMessage")
[10:25:53.492]                       }
[10:25:53.492]                       else if (inherits(cond, "warning")) {
[10:25:53.492]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.492]                         if (muffled) 
[10:25:53.492]                           invokeRestart("muffleWarning")
[10:25:53.492]                       }
[10:25:53.492]                       else if (inherits(cond, "condition")) {
[10:25:53.492]                         if (!is.null(pattern)) {
[10:25:53.492]                           computeRestarts <- base::computeRestarts
[10:25:53.492]                           grepl <- base::grepl
[10:25:53.492]                           restarts <- computeRestarts(cond)
[10:25:53.492]                           for (restart in restarts) {
[10:25:53.492]                             name <- restart$name
[10:25:53.492]                             if (is.null(name)) 
[10:25:53.492]                               next
[10:25:53.492]                             if (!grepl(pattern, name)) 
[10:25:53.492]                               next
[10:25:53.492]                             invokeRestart(restart)
[10:25:53.492]                             muffled <- TRUE
[10:25:53.492]                             break
[10:25:53.492]                           }
[10:25:53.492]                         }
[10:25:53.492]                       }
[10:25:53.492]                       invisible(muffled)
[10:25:53.492]                     }
[10:25:53.492]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.492]                   }
[10:25:53.492]                 }
[10:25:53.492]             }
[10:25:53.492]         }))
[10:25:53.492]     }, error = function(ex) {
[10:25:53.492]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.492]                 ...future.rng), started = ...future.startTime, 
[10:25:53.492]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.492]             version = "1.8"), class = "FutureResult")
[10:25:53.492]     }, finally = {
[10:25:53.492]         if (!identical(...future.workdir, getwd())) 
[10:25:53.492]             setwd(...future.workdir)
[10:25:53.492]         {
[10:25:53.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.492]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.492]             }
[10:25:53.492]             base::options(...future.oldOptions)
[10:25:53.492]             if (.Platform$OS.type == "windows") {
[10:25:53.492]                 old_names <- names(...future.oldEnvVars)
[10:25:53.492]                 envs <- base::Sys.getenv()
[10:25:53.492]                 names <- names(envs)
[10:25:53.492]                 common <- intersect(names, old_names)
[10:25:53.492]                 added <- setdiff(names, old_names)
[10:25:53.492]                 removed <- setdiff(old_names, names)
[10:25:53.492]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.492]                   envs[common]]
[10:25:53.492]                 NAMES <- toupper(changed)
[10:25:53.492]                 args <- list()
[10:25:53.492]                 for (kk in seq_along(NAMES)) {
[10:25:53.492]                   name <- changed[[kk]]
[10:25:53.492]                   NAME <- NAMES[[kk]]
[10:25:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.492]                     next
[10:25:53.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.492]                 }
[10:25:53.492]                 NAMES <- toupper(added)
[10:25:53.492]                 for (kk in seq_along(NAMES)) {
[10:25:53.492]                   name <- added[[kk]]
[10:25:53.492]                   NAME <- NAMES[[kk]]
[10:25:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.492]                     next
[10:25:53.492]                   args[[name]] <- ""
[10:25:53.492]                 }
[10:25:53.492]                 NAMES <- toupper(removed)
[10:25:53.492]                 for (kk in seq_along(NAMES)) {
[10:25:53.492]                   name <- removed[[kk]]
[10:25:53.492]                   NAME <- NAMES[[kk]]
[10:25:53.492]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.492]                     next
[10:25:53.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.492]                 }
[10:25:53.492]                 if (length(args) > 0) 
[10:25:53.492]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.492]             }
[10:25:53.492]             else {
[10:25:53.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.492]             }
[10:25:53.492]             {
[10:25:53.492]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.492]                   0L) {
[10:25:53.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.492]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.492]                   base::options(opts)
[10:25:53.492]                 }
[10:25:53.492]                 {
[10:25:53.492]                   {
[10:25:53.492]                     NULL
[10:25:53.492]                     RNGkind("Mersenne-Twister")
[10:25:53.492]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.492]                       inherits = FALSE)
[10:25:53.492]                   }
[10:25:53.492]                   options(future.plan = NULL)
[10:25:53.492]                   if (is.na(NA_character_)) 
[10:25:53.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.492]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.492]                   {
[10:25:53.492]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.492]                     if (!future$lazy) 
[10:25:53.492]                       future <- run(future)
[10:25:53.492]                     invisible(future)
[10:25:53.492]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.492]                 }
[10:25:53.492]             }
[10:25:53.492]         }
[10:25:53.492]     })
[10:25:53.492]     if (TRUE) {
[10:25:53.492]         base::sink(type = "output", split = FALSE)
[10:25:53.492]         if (TRUE) {
[10:25:53.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.492]         }
[10:25:53.492]         else {
[10:25:53.492]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.492]         }
[10:25:53.492]         base::close(...future.stdout)
[10:25:53.492]         ...future.stdout <- NULL
[10:25:53.492]     }
[10:25:53.492]     ...future.result$conditions <- ...future.conditions
[10:25:53.492]     ...future.result$finished <- base::Sys.time()
[10:25:53.492]     ...future.result
[10:25:53.492] }
[10:25:53.493] assign_globals() ...
[10:25:53.493] List of 2
[10:25:53.493]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.493]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.493]  - attr(*, "where")=List of 2
[10:25:53.493]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.493]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.493]  - attr(*, "resolved")= logi FALSE
[10:25:53.493]  - attr(*, "total_size")= num 896
[10:25:53.493]  - attr(*, "already-done")= logi TRUE
[10:25:53.496] - copied ‘weight’ to environment
[10:25:53.496] - copied ‘group’ to environment
[10:25:53.496] assign_globals() ... done
[10:25:53.497] plan(): Setting new future strategy stack:
[10:25:53.497] List of future strategies:
[10:25:53.497] 1. sequential:
[10:25:53.497]    - args: function (..., envir = parent.frame())
[10:25:53.497]    - tweaked: FALSE
[10:25:53.497]    - call: NULL
[10:25:53.497] plan(): nbrOfWorkers() = 1
[10:25:53.498] plan(): Setting new future strategy stack:
[10:25:53.499] List of future strategies:
[10:25:53.499] 1. sequential:
[10:25:53.499]    - args: function (..., envir = parent.frame())
[10:25:53.499]    - tweaked: FALSE
[10:25:53.499]    - call: plan(strategy)
[10:25:53.499] plan(): nbrOfWorkers() = 1
[10:25:53.499] SequentialFuture started (and completed)
[10:25:53.499] - Launch lazy future ... done
[10:25:53.499] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:25:53.501] getGlobalsAndPackages() ...
[10:25:53.501] Searching for globals...
[10:25:53.502] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:53.502] Searching for globals ... DONE
[10:25:53.502] Resolving globals: FALSE
[10:25:53.503] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:53.503] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:53.503] - globals: [1] ‘x’
[10:25:53.503] - packages: [1] ‘stats’
[10:25:53.503] getGlobalsAndPackages() ... DONE
[10:25:53.503] run() for ‘Future’ ...
[10:25:53.504] - state: ‘created’
[10:25:53.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.504] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.504]   - Field: ‘label’
[10:25:53.504]   - Field: ‘local’
[10:25:53.504]   - Field: ‘owner’
[10:25:53.504]   - Field: ‘envir’
[10:25:53.504]   - Field: ‘packages’
[10:25:53.505]   - Field: ‘gc’
[10:25:53.505]   - Field: ‘conditions’
[10:25:53.505]   - Field: ‘expr’
[10:25:53.505]   - Field: ‘uuid’
[10:25:53.505]   - Field: ‘seed’
[10:25:53.505]   - Field: ‘version’
[10:25:53.505]   - Field: ‘result’
[10:25:53.505]   - Field: ‘asynchronous’
[10:25:53.505]   - Field: ‘calls’
[10:25:53.506]   - Field: ‘globals’
[10:25:53.506]   - Field: ‘stdout’
[10:25:53.506]   - Field: ‘earlySignal’
[10:25:53.507]   - Field: ‘lazy’
[10:25:53.507]   - Field: ‘state’
[10:25:53.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.507] - Launch lazy future ...
[10:25:53.507] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.507] Packages needed by future strategies (n = 0): <none>
[10:25:53.508] {
[10:25:53.508]     {
[10:25:53.508]         {
[10:25:53.508]             ...future.startTime <- base::Sys.time()
[10:25:53.508]             {
[10:25:53.508]                 {
[10:25:53.508]                   {
[10:25:53.508]                     {
[10:25:53.508]                       base::local({
[10:25:53.508]                         has_future <- base::requireNamespace("future", 
[10:25:53.508]                           quietly = TRUE)
[10:25:53.508]                         if (has_future) {
[10:25:53.508]                           ns <- base::getNamespace("future")
[10:25:53.508]                           version <- ns[[".package"]][["version"]]
[10:25:53.508]                           if (is.null(version)) 
[10:25:53.508]                             version <- utils::packageVersion("future")
[10:25:53.508]                         }
[10:25:53.508]                         else {
[10:25:53.508]                           version <- NULL
[10:25:53.508]                         }
[10:25:53.508]                         if (!has_future || version < "1.8.0") {
[10:25:53.508]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.508]                             "", base::R.version$version.string), 
[10:25:53.508]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.508]                               "release", "version")], collapse = " "), 
[10:25:53.508]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.508]                             info)
[10:25:53.508]                           info <- base::paste(info, collapse = "; ")
[10:25:53.508]                           if (!has_future) {
[10:25:53.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.508]                               info)
[10:25:53.508]                           }
[10:25:53.508]                           else {
[10:25:53.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.508]                               info, version)
[10:25:53.508]                           }
[10:25:53.508]                           base::stop(msg)
[10:25:53.508]                         }
[10:25:53.508]                       })
[10:25:53.508]                     }
[10:25:53.508]                     base::local({
[10:25:53.508]                       for (pkg in "stats") {
[10:25:53.508]                         base::loadNamespace(pkg)
[10:25:53.508]                         base::library(pkg, character.only = TRUE)
[10:25:53.508]                       }
[10:25:53.508]                     })
[10:25:53.508]                   }
[10:25:53.508]                   options(future.plan = NULL)
[10:25:53.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.508]                 }
[10:25:53.508]                 ...future.workdir <- getwd()
[10:25:53.508]             }
[10:25:53.508]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.508]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.508]         }
[10:25:53.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.508]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.508]             base::names(...future.oldOptions))
[10:25:53.508]     }
[10:25:53.508]     if (FALSE) {
[10:25:53.508]     }
[10:25:53.508]     else {
[10:25:53.508]         if (TRUE) {
[10:25:53.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.508]                 open = "w")
[10:25:53.508]         }
[10:25:53.508]         else {
[10:25:53.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.508]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.508]         }
[10:25:53.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.508]             base::sink(type = "output", split = FALSE)
[10:25:53.508]             base::close(...future.stdout)
[10:25:53.508]         }, add = TRUE)
[10:25:53.508]     }
[10:25:53.508]     ...future.frame <- base::sys.nframe()
[10:25:53.508]     ...future.conditions <- base::list()
[10:25:53.508]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.508]     if (FALSE) {
[10:25:53.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.508]     }
[10:25:53.508]     ...future.result <- base::tryCatch({
[10:25:53.508]         base::withCallingHandlers({
[10:25:53.508]             ...future.value <- base::withVisible(base::local({
[10:25:53.508]                 xtabs(~x)
[10:25:53.508]             }))
[10:25:53.508]             future::FutureResult(value = ...future.value$value, 
[10:25:53.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.508]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.508]                     ...future.globalenv.names))
[10:25:53.508]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.508]         }, condition = base::local({
[10:25:53.508]             c <- base::c
[10:25:53.508]             inherits <- base::inherits
[10:25:53.508]             invokeRestart <- base::invokeRestart
[10:25:53.508]             length <- base::length
[10:25:53.508]             list <- base::list
[10:25:53.508]             seq.int <- base::seq.int
[10:25:53.508]             signalCondition <- base::signalCondition
[10:25:53.508]             sys.calls <- base::sys.calls
[10:25:53.508]             `[[` <- base::`[[`
[10:25:53.508]             `+` <- base::`+`
[10:25:53.508]             `<<-` <- base::`<<-`
[10:25:53.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.508]                   3L)]
[10:25:53.508]             }
[10:25:53.508]             function(cond) {
[10:25:53.508]                 is_error <- inherits(cond, "error")
[10:25:53.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.508]                   NULL)
[10:25:53.508]                 if (is_error) {
[10:25:53.508]                   sessionInformation <- function() {
[10:25:53.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.508]                       search = base::search(), system = base::Sys.info())
[10:25:53.508]                   }
[10:25:53.508]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.508]                     cond$call), session = sessionInformation(), 
[10:25:53.508]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.508]                   signalCondition(cond)
[10:25:53.508]                 }
[10:25:53.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.508]                 "immediateCondition"))) {
[10:25:53.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.508]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.508]                   if (TRUE && !signal) {
[10:25:53.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.508]                     {
[10:25:53.508]                       inherits <- base::inherits
[10:25:53.508]                       invokeRestart <- base::invokeRestart
[10:25:53.508]                       is.null <- base::is.null
[10:25:53.508]                       muffled <- FALSE
[10:25:53.508]                       if (inherits(cond, "message")) {
[10:25:53.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.508]                         if (muffled) 
[10:25:53.508]                           invokeRestart("muffleMessage")
[10:25:53.508]                       }
[10:25:53.508]                       else if (inherits(cond, "warning")) {
[10:25:53.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.508]                         if (muffled) 
[10:25:53.508]                           invokeRestart("muffleWarning")
[10:25:53.508]                       }
[10:25:53.508]                       else if (inherits(cond, "condition")) {
[10:25:53.508]                         if (!is.null(pattern)) {
[10:25:53.508]                           computeRestarts <- base::computeRestarts
[10:25:53.508]                           grepl <- base::grepl
[10:25:53.508]                           restarts <- computeRestarts(cond)
[10:25:53.508]                           for (restart in restarts) {
[10:25:53.508]                             name <- restart$name
[10:25:53.508]                             if (is.null(name)) 
[10:25:53.508]                               next
[10:25:53.508]                             if (!grepl(pattern, name)) 
[10:25:53.508]                               next
[10:25:53.508]                             invokeRestart(restart)
[10:25:53.508]                             muffled <- TRUE
[10:25:53.508]                             break
[10:25:53.508]                           }
[10:25:53.508]                         }
[10:25:53.508]                       }
[10:25:53.508]                       invisible(muffled)
[10:25:53.508]                     }
[10:25:53.508]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.508]                   }
[10:25:53.508]                 }
[10:25:53.508]                 else {
[10:25:53.508]                   if (TRUE) {
[10:25:53.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.508]                     {
[10:25:53.508]                       inherits <- base::inherits
[10:25:53.508]                       invokeRestart <- base::invokeRestart
[10:25:53.508]                       is.null <- base::is.null
[10:25:53.508]                       muffled <- FALSE
[10:25:53.508]                       if (inherits(cond, "message")) {
[10:25:53.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.508]                         if (muffled) 
[10:25:53.508]                           invokeRestart("muffleMessage")
[10:25:53.508]                       }
[10:25:53.508]                       else if (inherits(cond, "warning")) {
[10:25:53.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.508]                         if (muffled) 
[10:25:53.508]                           invokeRestart("muffleWarning")
[10:25:53.508]                       }
[10:25:53.508]                       else if (inherits(cond, "condition")) {
[10:25:53.508]                         if (!is.null(pattern)) {
[10:25:53.508]                           computeRestarts <- base::computeRestarts
[10:25:53.508]                           grepl <- base::grepl
[10:25:53.508]                           restarts <- computeRestarts(cond)
[10:25:53.508]                           for (restart in restarts) {
[10:25:53.508]                             name <- restart$name
[10:25:53.508]                             if (is.null(name)) 
[10:25:53.508]                               next
[10:25:53.508]                             if (!grepl(pattern, name)) 
[10:25:53.508]                               next
[10:25:53.508]                             invokeRestart(restart)
[10:25:53.508]                             muffled <- TRUE
[10:25:53.508]                             break
[10:25:53.508]                           }
[10:25:53.508]                         }
[10:25:53.508]                       }
[10:25:53.508]                       invisible(muffled)
[10:25:53.508]                     }
[10:25:53.508]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.508]                   }
[10:25:53.508]                 }
[10:25:53.508]             }
[10:25:53.508]         }))
[10:25:53.508]     }, error = function(ex) {
[10:25:53.508]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.508]                 ...future.rng), started = ...future.startTime, 
[10:25:53.508]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.508]             version = "1.8"), class = "FutureResult")
[10:25:53.508]     }, finally = {
[10:25:53.508]         if (!identical(...future.workdir, getwd())) 
[10:25:53.508]             setwd(...future.workdir)
[10:25:53.508]         {
[10:25:53.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.508]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.508]             }
[10:25:53.508]             base::options(...future.oldOptions)
[10:25:53.508]             if (.Platform$OS.type == "windows") {
[10:25:53.508]                 old_names <- names(...future.oldEnvVars)
[10:25:53.508]                 envs <- base::Sys.getenv()
[10:25:53.508]                 names <- names(envs)
[10:25:53.508]                 common <- intersect(names, old_names)
[10:25:53.508]                 added <- setdiff(names, old_names)
[10:25:53.508]                 removed <- setdiff(old_names, names)
[10:25:53.508]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.508]                   envs[common]]
[10:25:53.508]                 NAMES <- toupper(changed)
[10:25:53.508]                 args <- list()
[10:25:53.508]                 for (kk in seq_along(NAMES)) {
[10:25:53.508]                   name <- changed[[kk]]
[10:25:53.508]                   NAME <- NAMES[[kk]]
[10:25:53.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.508]                     next
[10:25:53.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.508]                 }
[10:25:53.508]                 NAMES <- toupper(added)
[10:25:53.508]                 for (kk in seq_along(NAMES)) {
[10:25:53.508]                   name <- added[[kk]]
[10:25:53.508]                   NAME <- NAMES[[kk]]
[10:25:53.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.508]                     next
[10:25:53.508]                   args[[name]] <- ""
[10:25:53.508]                 }
[10:25:53.508]                 NAMES <- toupper(removed)
[10:25:53.508]                 for (kk in seq_along(NAMES)) {
[10:25:53.508]                   name <- removed[[kk]]
[10:25:53.508]                   NAME <- NAMES[[kk]]
[10:25:53.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.508]                     next
[10:25:53.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.508]                 }
[10:25:53.508]                 if (length(args) > 0) 
[10:25:53.508]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.508]             }
[10:25:53.508]             else {
[10:25:53.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.508]             }
[10:25:53.508]             {
[10:25:53.508]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.508]                   0L) {
[10:25:53.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.508]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.508]                   base::options(opts)
[10:25:53.508]                 }
[10:25:53.508]                 {
[10:25:53.508]                   {
[10:25:53.508]                     NULL
[10:25:53.508]                     RNGkind("Mersenne-Twister")
[10:25:53.508]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.508]                       inherits = FALSE)
[10:25:53.508]                   }
[10:25:53.508]                   options(future.plan = NULL)
[10:25:53.508]                   if (is.na(NA_character_)) 
[10:25:53.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.508]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.508]                   {
[10:25:53.508]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.508]                     if (!future$lazy) 
[10:25:53.508]                       future <- run(future)
[10:25:53.508]                     invisible(future)
[10:25:53.508]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.508]                 }
[10:25:53.508]             }
[10:25:53.508]         }
[10:25:53.508]     })
[10:25:53.508]     if (TRUE) {
[10:25:53.508]         base::sink(type = "output", split = FALSE)
[10:25:53.508]         if (TRUE) {
[10:25:53.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.508]         }
[10:25:53.508]         else {
[10:25:53.508]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.508]         }
[10:25:53.508]         base::close(...future.stdout)
[10:25:53.508]         ...future.stdout <- NULL
[10:25:53.508]     }
[10:25:53.508]     ...future.result$conditions <- ...future.conditions
[10:25:53.508]     ...future.result$finished <- base::Sys.time()
[10:25:53.508]     ...future.result
[10:25:53.508] }
[10:25:53.509] assign_globals() ...
[10:25:53.509] List of 1
[10:25:53.509]  $ x: num [1:5] 1 1 2 2 2
[10:25:53.509]  - attr(*, "where")=List of 1
[10:25:53.509]   ..$ x:<environment: R_EmptyEnv> 
[10:25:53.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.509]  - attr(*, "resolved")= logi FALSE
[10:25:53.509]  - attr(*, "total_size")= num 96
[10:25:53.509]  - attr(*, "already-done")= logi TRUE
[10:25:53.512] - copied ‘x’ to environment
[10:25:53.512] assign_globals() ... done
[10:25:53.512] plan(): Setting new future strategy stack:
[10:25:53.512] List of future strategies:
[10:25:53.512] 1. sequential:
[10:25:53.512]    - args: function (..., envir = parent.frame())
[10:25:53.512]    - tweaked: FALSE
[10:25:53.512]    - call: NULL
[10:25:53.512] plan(): nbrOfWorkers() = 1
[10:25:53.513] plan(): Setting new future strategy stack:
[10:25:53.514] List of future strategies:
[10:25:53.514] 1. sequential:
[10:25:53.514]    - args: function (..., envir = parent.frame())
[10:25:53.514]    - tweaked: FALSE
[10:25:53.514]    - call: plan(strategy)
[10:25:53.514] plan(): nbrOfWorkers() = 1
[10:25:53.514] SequentialFuture started (and completed)
[10:25:53.514] - Launch lazy future ... done
[10:25:53.514] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[10:25:53.515] getGlobalsAndPackages() ...
[10:25:53.515] Searching for globals...
[10:25:53.516] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:53.516] Searching for globals ... DONE
[10:25:53.516] Resolving globals: FALSE
[10:25:53.517] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:53.517] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:53.517] - globals: [1] ‘x’
[10:25:53.517] - packages: [1] ‘stats’
[10:25:53.517] getGlobalsAndPackages() ... DONE
[10:25:53.518] run() for ‘Future’ ...
[10:25:53.518] - state: ‘created’
[10:25:53.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.518]   - Field: ‘label’
[10:25:53.518]   - Field: ‘local’
[10:25:53.518]   - Field: ‘owner’
[10:25:53.518]   - Field: ‘envir’
[10:25:53.519]   - Field: ‘packages’
[10:25:53.519]   - Field: ‘gc’
[10:25:53.519]   - Field: ‘conditions’
[10:25:53.519]   - Field: ‘expr’
[10:25:53.519]   - Field: ‘uuid’
[10:25:53.519]   - Field: ‘seed’
[10:25:53.519]   - Field: ‘version’
[10:25:53.519]   - Field: ‘result’
[10:25:53.519]   - Field: ‘asynchronous’
[10:25:53.519]   - Field: ‘calls’
[10:25:53.519]   - Field: ‘globals’
[10:25:53.519]   - Field: ‘stdout’
[10:25:53.520]   - Field: ‘earlySignal’
[10:25:53.520]   - Field: ‘lazy’
[10:25:53.520]   - Field: ‘state’
[10:25:53.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.520] - Launch lazy future ...
[10:25:53.520] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.520] Packages needed by future strategies (n = 0): <none>
[10:25:53.521] {
[10:25:53.521]     {
[10:25:53.521]         {
[10:25:53.521]             ...future.startTime <- base::Sys.time()
[10:25:53.521]             {
[10:25:53.521]                 {
[10:25:53.521]                   {
[10:25:53.521]                     {
[10:25:53.521]                       base::local({
[10:25:53.521]                         has_future <- base::requireNamespace("future", 
[10:25:53.521]                           quietly = TRUE)
[10:25:53.521]                         if (has_future) {
[10:25:53.521]                           ns <- base::getNamespace("future")
[10:25:53.521]                           version <- ns[[".package"]][["version"]]
[10:25:53.521]                           if (is.null(version)) 
[10:25:53.521]                             version <- utils::packageVersion("future")
[10:25:53.521]                         }
[10:25:53.521]                         else {
[10:25:53.521]                           version <- NULL
[10:25:53.521]                         }
[10:25:53.521]                         if (!has_future || version < "1.8.0") {
[10:25:53.521]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.521]                             "", base::R.version$version.string), 
[10:25:53.521]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.521]                               "release", "version")], collapse = " "), 
[10:25:53.521]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.521]                             info)
[10:25:53.521]                           info <- base::paste(info, collapse = "; ")
[10:25:53.521]                           if (!has_future) {
[10:25:53.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.521]                               info)
[10:25:53.521]                           }
[10:25:53.521]                           else {
[10:25:53.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.521]                               info, version)
[10:25:53.521]                           }
[10:25:53.521]                           base::stop(msg)
[10:25:53.521]                         }
[10:25:53.521]                       })
[10:25:53.521]                     }
[10:25:53.521]                     base::local({
[10:25:53.521]                       for (pkg in "stats") {
[10:25:53.521]                         base::loadNamespace(pkg)
[10:25:53.521]                         base::library(pkg, character.only = TRUE)
[10:25:53.521]                       }
[10:25:53.521]                     })
[10:25:53.521]                   }
[10:25:53.521]                   options(future.plan = NULL)
[10:25:53.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.521]                 }
[10:25:53.521]                 ...future.workdir <- getwd()
[10:25:53.521]             }
[10:25:53.521]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.521]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.521]         }
[10:25:53.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.521]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.521]             base::names(...future.oldOptions))
[10:25:53.521]     }
[10:25:53.521]     if (FALSE) {
[10:25:53.521]     }
[10:25:53.521]     else {
[10:25:53.521]         if (TRUE) {
[10:25:53.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.521]                 open = "w")
[10:25:53.521]         }
[10:25:53.521]         else {
[10:25:53.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.521]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.521]         }
[10:25:53.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.521]             base::sink(type = "output", split = FALSE)
[10:25:53.521]             base::close(...future.stdout)
[10:25:53.521]         }, add = TRUE)
[10:25:53.521]     }
[10:25:53.521]     ...future.frame <- base::sys.nframe()
[10:25:53.521]     ...future.conditions <- base::list()
[10:25:53.521]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.521]     if (FALSE) {
[10:25:53.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.521]     }
[10:25:53.521]     ...future.result <- base::tryCatch({
[10:25:53.521]         base::withCallingHandlers({
[10:25:53.521]             ...future.value <- base::withVisible(base::local({
[10:25:53.521]                 xtabs(~x)
[10:25:53.521]             }))
[10:25:53.521]             future::FutureResult(value = ...future.value$value, 
[10:25:53.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.521]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.521]                     ...future.globalenv.names))
[10:25:53.521]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.521]         }, condition = base::local({
[10:25:53.521]             c <- base::c
[10:25:53.521]             inherits <- base::inherits
[10:25:53.521]             invokeRestart <- base::invokeRestart
[10:25:53.521]             length <- base::length
[10:25:53.521]             list <- base::list
[10:25:53.521]             seq.int <- base::seq.int
[10:25:53.521]             signalCondition <- base::signalCondition
[10:25:53.521]             sys.calls <- base::sys.calls
[10:25:53.521]             `[[` <- base::`[[`
[10:25:53.521]             `+` <- base::`+`
[10:25:53.521]             `<<-` <- base::`<<-`
[10:25:53.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.521]                   3L)]
[10:25:53.521]             }
[10:25:53.521]             function(cond) {
[10:25:53.521]                 is_error <- inherits(cond, "error")
[10:25:53.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.521]                   NULL)
[10:25:53.521]                 if (is_error) {
[10:25:53.521]                   sessionInformation <- function() {
[10:25:53.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.521]                       search = base::search(), system = base::Sys.info())
[10:25:53.521]                   }
[10:25:53.521]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.521]                     cond$call), session = sessionInformation(), 
[10:25:53.521]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.521]                   signalCondition(cond)
[10:25:53.521]                 }
[10:25:53.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.521]                 "immediateCondition"))) {
[10:25:53.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.521]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.521]                   if (TRUE && !signal) {
[10:25:53.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.521]                     {
[10:25:53.521]                       inherits <- base::inherits
[10:25:53.521]                       invokeRestart <- base::invokeRestart
[10:25:53.521]                       is.null <- base::is.null
[10:25:53.521]                       muffled <- FALSE
[10:25:53.521]                       if (inherits(cond, "message")) {
[10:25:53.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.521]                         if (muffled) 
[10:25:53.521]                           invokeRestart("muffleMessage")
[10:25:53.521]                       }
[10:25:53.521]                       else if (inherits(cond, "warning")) {
[10:25:53.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.521]                         if (muffled) 
[10:25:53.521]                           invokeRestart("muffleWarning")
[10:25:53.521]                       }
[10:25:53.521]                       else if (inherits(cond, "condition")) {
[10:25:53.521]                         if (!is.null(pattern)) {
[10:25:53.521]                           computeRestarts <- base::computeRestarts
[10:25:53.521]                           grepl <- base::grepl
[10:25:53.521]                           restarts <- computeRestarts(cond)
[10:25:53.521]                           for (restart in restarts) {
[10:25:53.521]                             name <- restart$name
[10:25:53.521]                             if (is.null(name)) 
[10:25:53.521]                               next
[10:25:53.521]                             if (!grepl(pattern, name)) 
[10:25:53.521]                               next
[10:25:53.521]                             invokeRestart(restart)
[10:25:53.521]                             muffled <- TRUE
[10:25:53.521]                             break
[10:25:53.521]                           }
[10:25:53.521]                         }
[10:25:53.521]                       }
[10:25:53.521]                       invisible(muffled)
[10:25:53.521]                     }
[10:25:53.521]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.521]                   }
[10:25:53.521]                 }
[10:25:53.521]                 else {
[10:25:53.521]                   if (TRUE) {
[10:25:53.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.521]                     {
[10:25:53.521]                       inherits <- base::inherits
[10:25:53.521]                       invokeRestart <- base::invokeRestart
[10:25:53.521]                       is.null <- base::is.null
[10:25:53.521]                       muffled <- FALSE
[10:25:53.521]                       if (inherits(cond, "message")) {
[10:25:53.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.521]                         if (muffled) 
[10:25:53.521]                           invokeRestart("muffleMessage")
[10:25:53.521]                       }
[10:25:53.521]                       else if (inherits(cond, "warning")) {
[10:25:53.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.521]                         if (muffled) 
[10:25:53.521]                           invokeRestart("muffleWarning")
[10:25:53.521]                       }
[10:25:53.521]                       else if (inherits(cond, "condition")) {
[10:25:53.521]                         if (!is.null(pattern)) {
[10:25:53.521]                           computeRestarts <- base::computeRestarts
[10:25:53.521]                           grepl <- base::grepl
[10:25:53.521]                           restarts <- computeRestarts(cond)
[10:25:53.521]                           for (restart in restarts) {
[10:25:53.521]                             name <- restart$name
[10:25:53.521]                             if (is.null(name)) 
[10:25:53.521]                               next
[10:25:53.521]                             if (!grepl(pattern, name)) 
[10:25:53.521]                               next
[10:25:53.521]                             invokeRestart(restart)
[10:25:53.521]                             muffled <- TRUE
[10:25:53.521]                             break
[10:25:53.521]                           }
[10:25:53.521]                         }
[10:25:53.521]                       }
[10:25:53.521]                       invisible(muffled)
[10:25:53.521]                     }
[10:25:53.521]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.521]                   }
[10:25:53.521]                 }
[10:25:53.521]             }
[10:25:53.521]         }))
[10:25:53.521]     }, error = function(ex) {
[10:25:53.521]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.521]                 ...future.rng), started = ...future.startTime, 
[10:25:53.521]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.521]             version = "1.8"), class = "FutureResult")
[10:25:53.521]     }, finally = {
[10:25:53.521]         if (!identical(...future.workdir, getwd())) 
[10:25:53.521]             setwd(...future.workdir)
[10:25:53.521]         {
[10:25:53.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.521]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.521]             }
[10:25:53.521]             base::options(...future.oldOptions)
[10:25:53.521]             if (.Platform$OS.type == "windows") {
[10:25:53.521]                 old_names <- names(...future.oldEnvVars)
[10:25:53.521]                 envs <- base::Sys.getenv()
[10:25:53.521]                 names <- names(envs)
[10:25:53.521]                 common <- intersect(names, old_names)
[10:25:53.521]                 added <- setdiff(names, old_names)
[10:25:53.521]                 removed <- setdiff(old_names, names)
[10:25:53.521]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.521]                   envs[common]]
[10:25:53.521]                 NAMES <- toupper(changed)
[10:25:53.521]                 args <- list()
[10:25:53.521]                 for (kk in seq_along(NAMES)) {
[10:25:53.521]                   name <- changed[[kk]]
[10:25:53.521]                   NAME <- NAMES[[kk]]
[10:25:53.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.521]                     next
[10:25:53.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.521]                 }
[10:25:53.521]                 NAMES <- toupper(added)
[10:25:53.521]                 for (kk in seq_along(NAMES)) {
[10:25:53.521]                   name <- added[[kk]]
[10:25:53.521]                   NAME <- NAMES[[kk]]
[10:25:53.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.521]                     next
[10:25:53.521]                   args[[name]] <- ""
[10:25:53.521]                 }
[10:25:53.521]                 NAMES <- toupper(removed)
[10:25:53.521]                 for (kk in seq_along(NAMES)) {
[10:25:53.521]                   name <- removed[[kk]]
[10:25:53.521]                   NAME <- NAMES[[kk]]
[10:25:53.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.521]                     next
[10:25:53.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.521]                 }
[10:25:53.521]                 if (length(args) > 0) 
[10:25:53.521]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.521]             }
[10:25:53.521]             else {
[10:25:53.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.521]             }
[10:25:53.521]             {
[10:25:53.521]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.521]                   0L) {
[10:25:53.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.521]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.521]                   base::options(opts)
[10:25:53.521]                 }
[10:25:53.521]                 {
[10:25:53.521]                   {
[10:25:53.521]                     NULL
[10:25:53.521]                     RNGkind("Mersenne-Twister")
[10:25:53.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.521]                       inherits = FALSE)
[10:25:53.521]                   }
[10:25:53.521]                   options(future.plan = NULL)
[10:25:53.521]                   if (is.na(NA_character_)) 
[10:25:53.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.521]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.521]                   {
[10:25:53.521]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.521]                     if (!future$lazy) 
[10:25:53.521]                       future <- run(future)
[10:25:53.521]                     invisible(future)
[10:25:53.521]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.521]                 }
[10:25:53.521]             }
[10:25:53.521]         }
[10:25:53.521]     })
[10:25:53.521]     if (TRUE) {
[10:25:53.521]         base::sink(type = "output", split = FALSE)
[10:25:53.521]         if (TRUE) {
[10:25:53.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.521]         }
[10:25:53.521]         else {
[10:25:53.521]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.521]         }
[10:25:53.521]         base::close(...future.stdout)
[10:25:53.521]         ...future.stdout <- NULL
[10:25:53.521]     }
[10:25:53.521]     ...future.result$conditions <- ...future.conditions
[10:25:53.521]     ...future.result$finished <- base::Sys.time()
[10:25:53.521]     ...future.result
[10:25:53.521] }
[10:25:53.522] assign_globals() ...
[10:25:53.522] List of 1
[10:25:53.522]  $ x: num [1:5] 1 1 2 2 2
[10:25:53.522]  - attr(*, "where")=List of 1
[10:25:53.522]   ..$ x:<environment: R_EmptyEnv> 
[10:25:53.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.522]  - attr(*, "resolved")= logi FALSE
[10:25:53.522]  - attr(*, "total_size")= num 96
[10:25:53.522]  - attr(*, "already-done")= logi TRUE
[10:25:53.525] - copied ‘x’ to environment
[10:25:53.525] assign_globals() ... done
[10:25:53.525] plan(): Setting new future strategy stack:
[10:25:53.525] List of future strategies:
[10:25:53.525] 1. sequential:
[10:25:53.525]    - args: function (..., envir = parent.frame())
[10:25:53.525]    - tweaked: FALSE
[10:25:53.525]    - call: NULL
[10:25:53.526] plan(): nbrOfWorkers() = 1
[10:25:53.527] plan(): Setting new future strategy stack:
[10:25:53.527] List of future strategies:
[10:25:53.527] 1. sequential:
[10:25:53.527]    - args: function (..., envir = parent.frame())
[10:25:53.527]    - tweaked: FALSE
[10:25:53.527]    - call: plan(strategy)
[10:25:53.527] plan(): nbrOfWorkers() = 1
[10:25:53.527] SequentialFuture started (and completed)
[10:25:53.527] - Launch lazy future ... done
[10:25:53.527] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:25:53.529] getGlobalsAndPackages() ...
[10:25:53.529] Searching for globals...
[10:25:53.532] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:25:53.532] Searching for globals ... DONE
[10:25:53.532] Resolving globals: FALSE
[10:25:53.533] 
[10:25:53.533] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.533] getGlobalsAndPackages() ... DONE
[10:25:53.533] run() for ‘Future’ ...
[10:25:53.533] - state: ‘created’
[10:25:53.534] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.534] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.534]   - Field: ‘label’
[10:25:53.534]   - Field: ‘local’
[10:25:53.534]   - Field: ‘owner’
[10:25:53.534]   - Field: ‘envir’
[10:25:53.534]   - Field: ‘packages’
[10:25:53.534]   - Field: ‘gc’
[10:25:53.535]   - Field: ‘conditions’
[10:25:53.535]   - Field: ‘expr’
[10:25:53.535]   - Field: ‘uuid’
[10:25:53.535]   - Field: ‘seed’
[10:25:53.535]   - Field: ‘version’
[10:25:53.535]   - Field: ‘result’
[10:25:53.535]   - Field: ‘asynchronous’
[10:25:53.535]   - Field: ‘calls’
[10:25:53.535]   - Field: ‘globals’
[10:25:53.535]   - Field: ‘stdout’
[10:25:53.535]   - Field: ‘earlySignal’
[10:25:53.536]   - Field: ‘lazy’
[10:25:53.536]   - Field: ‘state’
[10:25:53.536] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.536] - Launch lazy future ...
[10:25:53.536] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.536] Packages needed by future strategies (n = 0): <none>
[10:25:53.537] {
[10:25:53.537]     {
[10:25:53.537]         {
[10:25:53.537]             ...future.startTime <- base::Sys.time()
[10:25:53.537]             {
[10:25:53.537]                 {
[10:25:53.537]                   {
[10:25:53.537]                     {
[10:25:53.537]                       base::local({
[10:25:53.537]                         has_future <- base::requireNamespace("future", 
[10:25:53.537]                           quietly = TRUE)
[10:25:53.537]                         if (has_future) {
[10:25:53.537]                           ns <- base::getNamespace("future")
[10:25:53.537]                           version <- ns[[".package"]][["version"]]
[10:25:53.537]                           if (is.null(version)) 
[10:25:53.537]                             version <- utils::packageVersion("future")
[10:25:53.537]                         }
[10:25:53.537]                         else {
[10:25:53.537]                           version <- NULL
[10:25:53.537]                         }
[10:25:53.537]                         if (!has_future || version < "1.8.0") {
[10:25:53.537]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.537]                             "", base::R.version$version.string), 
[10:25:53.537]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.537]                               "release", "version")], collapse = " "), 
[10:25:53.537]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.537]                             info)
[10:25:53.537]                           info <- base::paste(info, collapse = "; ")
[10:25:53.537]                           if (!has_future) {
[10:25:53.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.537]                               info)
[10:25:53.537]                           }
[10:25:53.537]                           else {
[10:25:53.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.537]                               info, version)
[10:25:53.537]                           }
[10:25:53.537]                           base::stop(msg)
[10:25:53.537]                         }
[10:25:53.537]                       })
[10:25:53.537]                     }
[10:25:53.537]                     base::local({
[10:25:53.537]                       for (pkg in c("stats", "datasets")) {
[10:25:53.537]                         base::loadNamespace(pkg)
[10:25:53.537]                         base::library(pkg, character.only = TRUE)
[10:25:53.537]                       }
[10:25:53.537]                     })
[10:25:53.537]                   }
[10:25:53.537]                   options(future.plan = NULL)
[10:25:53.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.537]                 }
[10:25:53.537]                 ...future.workdir <- getwd()
[10:25:53.537]             }
[10:25:53.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.537]         }
[10:25:53.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.537]             base::names(...future.oldOptions))
[10:25:53.537]     }
[10:25:53.537]     if (FALSE) {
[10:25:53.537]     }
[10:25:53.537]     else {
[10:25:53.537]         if (TRUE) {
[10:25:53.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.537]                 open = "w")
[10:25:53.537]         }
[10:25:53.537]         else {
[10:25:53.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.537]         }
[10:25:53.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.537]             base::sink(type = "output", split = FALSE)
[10:25:53.537]             base::close(...future.stdout)
[10:25:53.537]         }, add = TRUE)
[10:25:53.537]     }
[10:25:53.537]     ...future.frame <- base::sys.nframe()
[10:25:53.537]     ...future.conditions <- base::list()
[10:25:53.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.537]     if (FALSE) {
[10:25:53.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.537]     }
[10:25:53.537]     ...future.result <- base::tryCatch({
[10:25:53.537]         base::withCallingHandlers({
[10:25:53.537]             ...future.value <- base::withVisible(base::local({
[10:25:53.537]                 lm(dist ~ . - 1, data = cars)
[10:25:53.537]             }))
[10:25:53.537]             future::FutureResult(value = ...future.value$value, 
[10:25:53.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.537]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.537]                     ...future.globalenv.names))
[10:25:53.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.537]         }, condition = base::local({
[10:25:53.537]             c <- base::c
[10:25:53.537]             inherits <- base::inherits
[10:25:53.537]             invokeRestart <- base::invokeRestart
[10:25:53.537]             length <- base::length
[10:25:53.537]             list <- base::list
[10:25:53.537]             seq.int <- base::seq.int
[10:25:53.537]             signalCondition <- base::signalCondition
[10:25:53.537]             sys.calls <- base::sys.calls
[10:25:53.537]             `[[` <- base::`[[`
[10:25:53.537]             `+` <- base::`+`
[10:25:53.537]             `<<-` <- base::`<<-`
[10:25:53.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.537]                   3L)]
[10:25:53.537]             }
[10:25:53.537]             function(cond) {
[10:25:53.537]                 is_error <- inherits(cond, "error")
[10:25:53.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.537]                   NULL)
[10:25:53.537]                 if (is_error) {
[10:25:53.537]                   sessionInformation <- function() {
[10:25:53.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.537]                       search = base::search(), system = base::Sys.info())
[10:25:53.537]                   }
[10:25:53.537]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.537]                     cond$call), session = sessionInformation(), 
[10:25:53.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.537]                   signalCondition(cond)
[10:25:53.537]                 }
[10:25:53.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.537]                 "immediateCondition"))) {
[10:25:53.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.537]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.537]                   if (TRUE && !signal) {
[10:25:53.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.537]                     {
[10:25:53.537]                       inherits <- base::inherits
[10:25:53.537]                       invokeRestart <- base::invokeRestart
[10:25:53.537]                       is.null <- base::is.null
[10:25:53.537]                       muffled <- FALSE
[10:25:53.537]                       if (inherits(cond, "message")) {
[10:25:53.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.537]                         if (muffled) 
[10:25:53.537]                           invokeRestart("muffleMessage")
[10:25:53.537]                       }
[10:25:53.537]                       else if (inherits(cond, "warning")) {
[10:25:53.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.537]                         if (muffled) 
[10:25:53.537]                           invokeRestart("muffleWarning")
[10:25:53.537]                       }
[10:25:53.537]                       else if (inherits(cond, "condition")) {
[10:25:53.537]                         if (!is.null(pattern)) {
[10:25:53.537]                           computeRestarts <- base::computeRestarts
[10:25:53.537]                           grepl <- base::grepl
[10:25:53.537]                           restarts <- computeRestarts(cond)
[10:25:53.537]                           for (restart in restarts) {
[10:25:53.537]                             name <- restart$name
[10:25:53.537]                             if (is.null(name)) 
[10:25:53.537]                               next
[10:25:53.537]                             if (!grepl(pattern, name)) 
[10:25:53.537]                               next
[10:25:53.537]                             invokeRestart(restart)
[10:25:53.537]                             muffled <- TRUE
[10:25:53.537]                             break
[10:25:53.537]                           }
[10:25:53.537]                         }
[10:25:53.537]                       }
[10:25:53.537]                       invisible(muffled)
[10:25:53.537]                     }
[10:25:53.537]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.537]                   }
[10:25:53.537]                 }
[10:25:53.537]                 else {
[10:25:53.537]                   if (TRUE) {
[10:25:53.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.537]                     {
[10:25:53.537]                       inherits <- base::inherits
[10:25:53.537]                       invokeRestart <- base::invokeRestart
[10:25:53.537]                       is.null <- base::is.null
[10:25:53.537]                       muffled <- FALSE
[10:25:53.537]                       if (inherits(cond, "message")) {
[10:25:53.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.537]                         if (muffled) 
[10:25:53.537]                           invokeRestart("muffleMessage")
[10:25:53.537]                       }
[10:25:53.537]                       else if (inherits(cond, "warning")) {
[10:25:53.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.537]                         if (muffled) 
[10:25:53.537]                           invokeRestart("muffleWarning")
[10:25:53.537]                       }
[10:25:53.537]                       else if (inherits(cond, "condition")) {
[10:25:53.537]                         if (!is.null(pattern)) {
[10:25:53.537]                           computeRestarts <- base::computeRestarts
[10:25:53.537]                           grepl <- base::grepl
[10:25:53.537]                           restarts <- computeRestarts(cond)
[10:25:53.537]                           for (restart in restarts) {
[10:25:53.537]                             name <- restart$name
[10:25:53.537]                             if (is.null(name)) 
[10:25:53.537]                               next
[10:25:53.537]                             if (!grepl(pattern, name)) 
[10:25:53.537]                               next
[10:25:53.537]                             invokeRestart(restart)
[10:25:53.537]                             muffled <- TRUE
[10:25:53.537]                             break
[10:25:53.537]                           }
[10:25:53.537]                         }
[10:25:53.537]                       }
[10:25:53.537]                       invisible(muffled)
[10:25:53.537]                     }
[10:25:53.537]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.537]                   }
[10:25:53.537]                 }
[10:25:53.537]             }
[10:25:53.537]         }))
[10:25:53.537]     }, error = function(ex) {
[10:25:53.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.537]                 ...future.rng), started = ...future.startTime, 
[10:25:53.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.537]             version = "1.8"), class = "FutureResult")
[10:25:53.537]     }, finally = {
[10:25:53.537]         if (!identical(...future.workdir, getwd())) 
[10:25:53.537]             setwd(...future.workdir)
[10:25:53.537]         {
[10:25:53.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.537]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.537]             }
[10:25:53.537]             base::options(...future.oldOptions)
[10:25:53.537]             if (.Platform$OS.type == "windows") {
[10:25:53.537]                 old_names <- names(...future.oldEnvVars)
[10:25:53.537]                 envs <- base::Sys.getenv()
[10:25:53.537]                 names <- names(envs)
[10:25:53.537]                 common <- intersect(names, old_names)
[10:25:53.537]                 added <- setdiff(names, old_names)
[10:25:53.537]                 removed <- setdiff(old_names, names)
[10:25:53.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.537]                   envs[common]]
[10:25:53.537]                 NAMES <- toupper(changed)
[10:25:53.537]                 args <- list()
[10:25:53.537]                 for (kk in seq_along(NAMES)) {
[10:25:53.537]                   name <- changed[[kk]]
[10:25:53.537]                   NAME <- NAMES[[kk]]
[10:25:53.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.537]                     next
[10:25:53.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.537]                 }
[10:25:53.537]                 NAMES <- toupper(added)
[10:25:53.537]                 for (kk in seq_along(NAMES)) {
[10:25:53.537]                   name <- added[[kk]]
[10:25:53.537]                   NAME <- NAMES[[kk]]
[10:25:53.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.537]                     next
[10:25:53.537]                   args[[name]] <- ""
[10:25:53.537]                 }
[10:25:53.537]                 NAMES <- toupper(removed)
[10:25:53.537]                 for (kk in seq_along(NAMES)) {
[10:25:53.537]                   name <- removed[[kk]]
[10:25:53.537]                   NAME <- NAMES[[kk]]
[10:25:53.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.537]                     next
[10:25:53.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.537]                 }
[10:25:53.537]                 if (length(args) > 0) 
[10:25:53.537]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.537]             }
[10:25:53.537]             else {
[10:25:53.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.537]             }
[10:25:53.537]             {
[10:25:53.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.537]                   0L) {
[10:25:53.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.537]                   base::options(opts)
[10:25:53.537]                 }
[10:25:53.537]                 {
[10:25:53.537]                   {
[10:25:53.537]                     NULL
[10:25:53.537]                     RNGkind("Mersenne-Twister")
[10:25:53.537]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.537]                       inherits = FALSE)
[10:25:53.537]                   }
[10:25:53.537]                   options(future.plan = NULL)
[10:25:53.537]                   if (is.na(NA_character_)) 
[10:25:53.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.537]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.537]                   {
[10:25:53.537]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.537]                     if (!future$lazy) 
[10:25:53.537]                       future <- run(future)
[10:25:53.537]                     invisible(future)
[10:25:53.537]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.537]                 }
[10:25:53.537]             }
[10:25:53.537]         }
[10:25:53.537]     })
[10:25:53.537]     if (TRUE) {
[10:25:53.537]         base::sink(type = "output", split = FALSE)
[10:25:53.537]         if (TRUE) {
[10:25:53.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.537]         }
[10:25:53.537]         else {
[10:25:53.537]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.537]         }
[10:25:53.537]         base::close(...future.stdout)
[10:25:53.537]         ...future.stdout <- NULL
[10:25:53.537]     }
[10:25:53.537]     ...future.result$conditions <- ...future.conditions
[10:25:53.537]     ...future.result$finished <- base::Sys.time()
[10:25:53.537]     ...future.result
[10:25:53.537] }
[10:25:53.538] plan(): Setting new future strategy stack:
[10:25:53.539] List of future strategies:
[10:25:53.539] 1. sequential:
[10:25:53.539]    - args: function (..., envir = parent.frame())
[10:25:53.539]    - tweaked: FALSE
[10:25:53.539]    - call: NULL
[10:25:53.539] plan(): nbrOfWorkers() = 1
[10:25:53.540] plan(): Setting new future strategy stack:
[10:25:53.540] List of future strategies:
[10:25:53.540] 1. sequential:
[10:25:53.540]    - args: function (..., envir = parent.frame())
[10:25:53.540]    - tweaked: FALSE
[10:25:53.540]    - call: plan(strategy)
[10:25:53.541] plan(): nbrOfWorkers() = 1
[10:25:53.541] SequentialFuture started (and completed)
[10:25:53.541] - Launch lazy future ... done
[10:25:53.541] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:25:53.543] getGlobalsAndPackages() ...
[10:25:53.543] Searching for globals...
[10:25:53.545] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:25:53.545] Searching for globals ... DONE
[10:25:53.545] Resolving globals: FALSE
[10:25:53.545] 
[10:25:53.545] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.545] getGlobalsAndPackages() ... DONE
[10:25:53.546] run() for ‘Future’ ...
[10:25:53.546] - state: ‘created’
[10:25:53.546] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.546] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.546]   - Field: ‘label’
[10:25:53.546]   - Field: ‘local’
[10:25:53.547]   - Field: ‘owner’
[10:25:53.547]   - Field: ‘envir’
[10:25:53.547]   - Field: ‘packages’
[10:25:53.547]   - Field: ‘gc’
[10:25:53.547]   - Field: ‘conditions’
[10:25:53.547]   - Field: ‘expr’
[10:25:53.547]   - Field: ‘uuid’
[10:25:53.547]   - Field: ‘seed’
[10:25:53.547]   - Field: ‘version’
[10:25:53.547]   - Field: ‘result’
[10:25:53.547]   - Field: ‘asynchronous’
[10:25:53.547]   - Field: ‘calls’
[10:25:53.548]   - Field: ‘globals’
[10:25:53.548]   - Field: ‘stdout’
[10:25:53.548]   - Field: ‘earlySignal’
[10:25:53.548]   - Field: ‘lazy’
[10:25:53.548]   - Field: ‘state’
[10:25:53.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.548] - Launch lazy future ...
[10:25:53.548] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.548] Packages needed by future strategies (n = 0): <none>
[10:25:53.549] {
[10:25:53.549]     {
[10:25:53.549]         {
[10:25:53.549]             ...future.startTime <- base::Sys.time()
[10:25:53.549]             {
[10:25:53.549]                 {
[10:25:53.549]                   {
[10:25:53.549]                     {
[10:25:53.549]                       base::local({
[10:25:53.549]                         has_future <- base::requireNamespace("future", 
[10:25:53.549]                           quietly = TRUE)
[10:25:53.549]                         if (has_future) {
[10:25:53.549]                           ns <- base::getNamespace("future")
[10:25:53.549]                           version <- ns[[".package"]][["version"]]
[10:25:53.549]                           if (is.null(version)) 
[10:25:53.549]                             version <- utils::packageVersion("future")
[10:25:53.549]                         }
[10:25:53.549]                         else {
[10:25:53.549]                           version <- NULL
[10:25:53.549]                         }
[10:25:53.549]                         if (!has_future || version < "1.8.0") {
[10:25:53.549]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.549]                             "", base::R.version$version.string), 
[10:25:53.549]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.549]                               "release", "version")], collapse = " "), 
[10:25:53.549]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.549]                             info)
[10:25:53.549]                           info <- base::paste(info, collapse = "; ")
[10:25:53.549]                           if (!has_future) {
[10:25:53.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.549]                               info)
[10:25:53.549]                           }
[10:25:53.549]                           else {
[10:25:53.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.549]                               info, version)
[10:25:53.549]                           }
[10:25:53.549]                           base::stop(msg)
[10:25:53.549]                         }
[10:25:53.549]                       })
[10:25:53.549]                     }
[10:25:53.549]                     base::local({
[10:25:53.549]                       for (pkg in c("stats", "datasets")) {
[10:25:53.549]                         base::loadNamespace(pkg)
[10:25:53.549]                         base::library(pkg, character.only = TRUE)
[10:25:53.549]                       }
[10:25:53.549]                     })
[10:25:53.549]                   }
[10:25:53.549]                   options(future.plan = NULL)
[10:25:53.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.549]                 }
[10:25:53.549]                 ...future.workdir <- getwd()
[10:25:53.549]             }
[10:25:53.549]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.549]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.549]         }
[10:25:53.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.549]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.549]             base::names(...future.oldOptions))
[10:25:53.549]     }
[10:25:53.549]     if (FALSE) {
[10:25:53.549]     }
[10:25:53.549]     else {
[10:25:53.549]         if (TRUE) {
[10:25:53.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.549]                 open = "w")
[10:25:53.549]         }
[10:25:53.549]         else {
[10:25:53.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.549]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.549]         }
[10:25:53.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.549]             base::sink(type = "output", split = FALSE)
[10:25:53.549]             base::close(...future.stdout)
[10:25:53.549]         }, add = TRUE)
[10:25:53.549]     }
[10:25:53.549]     ...future.frame <- base::sys.nframe()
[10:25:53.549]     ...future.conditions <- base::list()
[10:25:53.549]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.549]     if (FALSE) {
[10:25:53.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.549]     }
[10:25:53.549]     ...future.result <- base::tryCatch({
[10:25:53.549]         base::withCallingHandlers({
[10:25:53.549]             ...future.value <- base::withVisible(base::local({
[10:25:53.549]                 lm(dist ~ . + 0, data = cars)
[10:25:53.549]             }))
[10:25:53.549]             future::FutureResult(value = ...future.value$value, 
[10:25:53.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.549]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.549]                     ...future.globalenv.names))
[10:25:53.549]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.549]         }, condition = base::local({
[10:25:53.549]             c <- base::c
[10:25:53.549]             inherits <- base::inherits
[10:25:53.549]             invokeRestart <- base::invokeRestart
[10:25:53.549]             length <- base::length
[10:25:53.549]             list <- base::list
[10:25:53.549]             seq.int <- base::seq.int
[10:25:53.549]             signalCondition <- base::signalCondition
[10:25:53.549]             sys.calls <- base::sys.calls
[10:25:53.549]             `[[` <- base::`[[`
[10:25:53.549]             `+` <- base::`+`
[10:25:53.549]             `<<-` <- base::`<<-`
[10:25:53.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.549]                   3L)]
[10:25:53.549]             }
[10:25:53.549]             function(cond) {
[10:25:53.549]                 is_error <- inherits(cond, "error")
[10:25:53.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.549]                   NULL)
[10:25:53.549]                 if (is_error) {
[10:25:53.549]                   sessionInformation <- function() {
[10:25:53.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.549]                       search = base::search(), system = base::Sys.info())
[10:25:53.549]                   }
[10:25:53.549]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.549]                     cond$call), session = sessionInformation(), 
[10:25:53.549]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.549]                   signalCondition(cond)
[10:25:53.549]                 }
[10:25:53.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.549]                 "immediateCondition"))) {
[10:25:53.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.549]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.549]                   if (TRUE && !signal) {
[10:25:53.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.549]                     {
[10:25:53.549]                       inherits <- base::inherits
[10:25:53.549]                       invokeRestart <- base::invokeRestart
[10:25:53.549]                       is.null <- base::is.null
[10:25:53.549]                       muffled <- FALSE
[10:25:53.549]                       if (inherits(cond, "message")) {
[10:25:53.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.549]                         if (muffled) 
[10:25:53.549]                           invokeRestart("muffleMessage")
[10:25:53.549]                       }
[10:25:53.549]                       else if (inherits(cond, "warning")) {
[10:25:53.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.549]                         if (muffled) 
[10:25:53.549]                           invokeRestart("muffleWarning")
[10:25:53.549]                       }
[10:25:53.549]                       else if (inherits(cond, "condition")) {
[10:25:53.549]                         if (!is.null(pattern)) {
[10:25:53.549]                           computeRestarts <- base::computeRestarts
[10:25:53.549]                           grepl <- base::grepl
[10:25:53.549]                           restarts <- computeRestarts(cond)
[10:25:53.549]                           for (restart in restarts) {
[10:25:53.549]                             name <- restart$name
[10:25:53.549]                             if (is.null(name)) 
[10:25:53.549]                               next
[10:25:53.549]                             if (!grepl(pattern, name)) 
[10:25:53.549]                               next
[10:25:53.549]                             invokeRestart(restart)
[10:25:53.549]                             muffled <- TRUE
[10:25:53.549]                             break
[10:25:53.549]                           }
[10:25:53.549]                         }
[10:25:53.549]                       }
[10:25:53.549]                       invisible(muffled)
[10:25:53.549]                     }
[10:25:53.549]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.549]                   }
[10:25:53.549]                 }
[10:25:53.549]                 else {
[10:25:53.549]                   if (TRUE) {
[10:25:53.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.549]                     {
[10:25:53.549]                       inherits <- base::inherits
[10:25:53.549]                       invokeRestart <- base::invokeRestart
[10:25:53.549]                       is.null <- base::is.null
[10:25:53.549]                       muffled <- FALSE
[10:25:53.549]                       if (inherits(cond, "message")) {
[10:25:53.549]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.549]                         if (muffled) 
[10:25:53.549]                           invokeRestart("muffleMessage")
[10:25:53.549]                       }
[10:25:53.549]                       else if (inherits(cond, "warning")) {
[10:25:53.549]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.549]                         if (muffled) 
[10:25:53.549]                           invokeRestart("muffleWarning")
[10:25:53.549]                       }
[10:25:53.549]                       else if (inherits(cond, "condition")) {
[10:25:53.549]                         if (!is.null(pattern)) {
[10:25:53.549]                           computeRestarts <- base::computeRestarts
[10:25:53.549]                           grepl <- base::grepl
[10:25:53.549]                           restarts <- computeRestarts(cond)
[10:25:53.549]                           for (restart in restarts) {
[10:25:53.549]                             name <- restart$name
[10:25:53.549]                             if (is.null(name)) 
[10:25:53.549]                               next
[10:25:53.549]                             if (!grepl(pattern, name)) 
[10:25:53.549]                               next
[10:25:53.549]                             invokeRestart(restart)
[10:25:53.549]                             muffled <- TRUE
[10:25:53.549]                             break
[10:25:53.549]                           }
[10:25:53.549]                         }
[10:25:53.549]                       }
[10:25:53.549]                       invisible(muffled)
[10:25:53.549]                     }
[10:25:53.549]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.549]                   }
[10:25:53.549]                 }
[10:25:53.549]             }
[10:25:53.549]         }))
[10:25:53.549]     }, error = function(ex) {
[10:25:53.549]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.549]                 ...future.rng), started = ...future.startTime, 
[10:25:53.549]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.549]             version = "1.8"), class = "FutureResult")
[10:25:53.549]     }, finally = {
[10:25:53.549]         if (!identical(...future.workdir, getwd())) 
[10:25:53.549]             setwd(...future.workdir)
[10:25:53.549]         {
[10:25:53.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.549]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.549]             }
[10:25:53.549]             base::options(...future.oldOptions)
[10:25:53.549]             if (.Platform$OS.type == "windows") {
[10:25:53.549]                 old_names <- names(...future.oldEnvVars)
[10:25:53.549]                 envs <- base::Sys.getenv()
[10:25:53.549]                 names <- names(envs)
[10:25:53.549]                 common <- intersect(names, old_names)
[10:25:53.549]                 added <- setdiff(names, old_names)
[10:25:53.549]                 removed <- setdiff(old_names, names)
[10:25:53.549]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.549]                   envs[common]]
[10:25:53.549]                 NAMES <- toupper(changed)
[10:25:53.549]                 args <- list()
[10:25:53.549]                 for (kk in seq_along(NAMES)) {
[10:25:53.549]                   name <- changed[[kk]]
[10:25:53.549]                   NAME <- NAMES[[kk]]
[10:25:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.549]                     next
[10:25:53.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.549]                 }
[10:25:53.549]                 NAMES <- toupper(added)
[10:25:53.549]                 for (kk in seq_along(NAMES)) {
[10:25:53.549]                   name <- added[[kk]]
[10:25:53.549]                   NAME <- NAMES[[kk]]
[10:25:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.549]                     next
[10:25:53.549]                   args[[name]] <- ""
[10:25:53.549]                 }
[10:25:53.549]                 NAMES <- toupper(removed)
[10:25:53.549]                 for (kk in seq_along(NAMES)) {
[10:25:53.549]                   name <- removed[[kk]]
[10:25:53.549]                   NAME <- NAMES[[kk]]
[10:25:53.549]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.549]                     next
[10:25:53.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.549]                 }
[10:25:53.549]                 if (length(args) > 0) 
[10:25:53.549]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.549]             }
[10:25:53.549]             else {
[10:25:53.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.549]             }
[10:25:53.549]             {
[10:25:53.549]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.549]                   0L) {
[10:25:53.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.549]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.549]                   base::options(opts)
[10:25:53.549]                 }
[10:25:53.549]                 {
[10:25:53.549]                   {
[10:25:53.549]                     NULL
[10:25:53.549]                     RNGkind("Mersenne-Twister")
[10:25:53.549]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.549]                       inherits = FALSE)
[10:25:53.549]                   }
[10:25:53.549]                   options(future.plan = NULL)
[10:25:53.549]                   if (is.na(NA_character_)) 
[10:25:53.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.549]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.549]                   {
[10:25:53.549]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.549]                     if (!future$lazy) 
[10:25:53.549]                       future <- run(future)
[10:25:53.549]                     invisible(future)
[10:25:53.549]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.549]                 }
[10:25:53.549]             }
[10:25:53.549]         }
[10:25:53.549]     })
[10:25:53.549]     if (TRUE) {
[10:25:53.549]         base::sink(type = "output", split = FALSE)
[10:25:53.549]         if (TRUE) {
[10:25:53.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.549]         }
[10:25:53.549]         else {
[10:25:53.549]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.549]         }
[10:25:53.549]         base::close(...future.stdout)
[10:25:53.549]         ...future.stdout <- NULL
[10:25:53.549]     }
[10:25:53.549]     ...future.result$conditions <- ...future.conditions
[10:25:53.549]     ...future.result$finished <- base::Sys.time()
[10:25:53.549]     ...future.result
[10:25:53.549] }
[10:25:53.551] plan(): Setting new future strategy stack:
[10:25:53.551] List of future strategies:
[10:25:53.551] 1. sequential:
[10:25:53.551]    - args: function (..., envir = parent.frame())
[10:25:53.551]    - tweaked: FALSE
[10:25:53.551]    - call: NULL
[10:25:53.551] plan(): nbrOfWorkers() = 1
[10:25:53.552] plan(): Setting new future strategy stack:
[10:25:53.552] List of future strategies:
[10:25:53.552] 1. sequential:
[10:25:53.552]    - args: function (..., envir = parent.frame())
[10:25:53.552]    - tweaked: FALSE
[10:25:53.552]    - call: plan(strategy)
[10:25:53.553] plan(): nbrOfWorkers() = 1
[10:25:53.553] SequentialFuture started (and completed)
[10:25:53.553] - Launch lazy future ... done
[10:25:53.553] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:25:53.556] getGlobalsAndPackages() ...
[10:25:53.557] Searching for globals...
[10:25:53.558] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:25:53.558] Searching for globals ... DONE
[10:25:53.558] Resolving globals: FALSE
[10:25:53.559] 
[10:25:53.559] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.559] getGlobalsAndPackages() ... DONE
[10:25:53.559] run() for ‘Future’ ...
[10:25:53.559] - state: ‘created’
[10:25:53.560] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.560] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.560] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.560]   - Field: ‘label’
[10:25:53.560]   - Field: ‘local’
[10:25:53.560]   - Field: ‘owner’
[10:25:53.560]   - Field: ‘envir’
[10:25:53.560]   - Field: ‘packages’
[10:25:53.560]   - Field: ‘gc’
[10:25:53.561]   - Field: ‘conditions’
[10:25:53.561]   - Field: ‘expr’
[10:25:53.561]   - Field: ‘uuid’
[10:25:53.561]   - Field: ‘seed’
[10:25:53.561]   - Field: ‘version’
[10:25:53.561]   - Field: ‘result’
[10:25:53.561]   - Field: ‘asynchronous’
[10:25:53.561]   - Field: ‘calls’
[10:25:53.561]   - Field: ‘globals’
[10:25:53.561]   - Field: ‘stdout’
[10:25:53.561]   - Field: ‘earlySignal’
[10:25:53.562]   - Field: ‘lazy’
[10:25:53.562]   - Field: ‘state’
[10:25:53.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.562] - Launch lazy future ...
[10:25:53.562] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.562] Packages needed by future strategies (n = 0): <none>
[10:25:53.563] {
[10:25:53.563]     {
[10:25:53.563]         {
[10:25:53.563]             ...future.startTime <- base::Sys.time()
[10:25:53.563]             {
[10:25:53.563]                 {
[10:25:53.563]                   {
[10:25:53.563]                     {
[10:25:53.563]                       base::local({
[10:25:53.563]                         has_future <- base::requireNamespace("future", 
[10:25:53.563]                           quietly = TRUE)
[10:25:53.563]                         if (has_future) {
[10:25:53.563]                           ns <- base::getNamespace("future")
[10:25:53.563]                           version <- ns[[".package"]][["version"]]
[10:25:53.563]                           if (is.null(version)) 
[10:25:53.563]                             version <- utils::packageVersion("future")
[10:25:53.563]                         }
[10:25:53.563]                         else {
[10:25:53.563]                           version <- NULL
[10:25:53.563]                         }
[10:25:53.563]                         if (!has_future || version < "1.8.0") {
[10:25:53.563]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.563]                             "", base::R.version$version.string), 
[10:25:53.563]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.563]                               "release", "version")], collapse = " "), 
[10:25:53.563]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.563]                             info)
[10:25:53.563]                           info <- base::paste(info, collapse = "; ")
[10:25:53.563]                           if (!has_future) {
[10:25:53.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.563]                               info)
[10:25:53.563]                           }
[10:25:53.563]                           else {
[10:25:53.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.563]                               info, version)
[10:25:53.563]                           }
[10:25:53.563]                           base::stop(msg)
[10:25:53.563]                         }
[10:25:53.563]                       })
[10:25:53.563]                     }
[10:25:53.563]                     base::local({
[10:25:53.563]                       for (pkg in c("stats", "datasets")) {
[10:25:53.563]                         base::loadNamespace(pkg)
[10:25:53.563]                         base::library(pkg, character.only = TRUE)
[10:25:53.563]                       }
[10:25:53.563]                     })
[10:25:53.563]                   }
[10:25:53.563]                   options(future.plan = NULL)
[10:25:53.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.563]                 }
[10:25:53.563]                 ...future.workdir <- getwd()
[10:25:53.563]             }
[10:25:53.563]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.563]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.563]         }
[10:25:53.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.563]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.563]             base::names(...future.oldOptions))
[10:25:53.563]     }
[10:25:53.563]     if (FALSE) {
[10:25:53.563]     }
[10:25:53.563]     else {
[10:25:53.563]         if (TRUE) {
[10:25:53.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.563]                 open = "w")
[10:25:53.563]         }
[10:25:53.563]         else {
[10:25:53.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.563]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.563]         }
[10:25:53.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.563]             base::sink(type = "output", split = FALSE)
[10:25:53.563]             base::close(...future.stdout)
[10:25:53.563]         }, add = TRUE)
[10:25:53.563]     }
[10:25:53.563]     ...future.frame <- base::sys.nframe()
[10:25:53.563]     ...future.conditions <- base::list()
[10:25:53.563]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.563]     if (FALSE) {
[10:25:53.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.563]     }
[10:25:53.563]     ...future.result <- base::tryCatch({
[10:25:53.563]         base::withCallingHandlers({
[10:25:53.563]             ...future.value <- base::withVisible(base::local({
[10:25:53.563]                 lm(dist ~ speed + speed^2, data = cars)
[10:25:53.563]             }))
[10:25:53.563]             future::FutureResult(value = ...future.value$value, 
[10:25:53.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.563]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.563]                     ...future.globalenv.names))
[10:25:53.563]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.563]         }, condition = base::local({
[10:25:53.563]             c <- base::c
[10:25:53.563]             inherits <- base::inherits
[10:25:53.563]             invokeRestart <- base::invokeRestart
[10:25:53.563]             length <- base::length
[10:25:53.563]             list <- base::list
[10:25:53.563]             seq.int <- base::seq.int
[10:25:53.563]             signalCondition <- base::signalCondition
[10:25:53.563]             sys.calls <- base::sys.calls
[10:25:53.563]             `[[` <- base::`[[`
[10:25:53.563]             `+` <- base::`+`
[10:25:53.563]             `<<-` <- base::`<<-`
[10:25:53.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.563]                   3L)]
[10:25:53.563]             }
[10:25:53.563]             function(cond) {
[10:25:53.563]                 is_error <- inherits(cond, "error")
[10:25:53.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.563]                   NULL)
[10:25:53.563]                 if (is_error) {
[10:25:53.563]                   sessionInformation <- function() {
[10:25:53.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.563]                       search = base::search(), system = base::Sys.info())
[10:25:53.563]                   }
[10:25:53.563]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.563]                     cond$call), session = sessionInformation(), 
[10:25:53.563]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.563]                   signalCondition(cond)
[10:25:53.563]                 }
[10:25:53.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.563]                 "immediateCondition"))) {
[10:25:53.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.563]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.563]                   if (TRUE && !signal) {
[10:25:53.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.563]                     {
[10:25:53.563]                       inherits <- base::inherits
[10:25:53.563]                       invokeRestart <- base::invokeRestart
[10:25:53.563]                       is.null <- base::is.null
[10:25:53.563]                       muffled <- FALSE
[10:25:53.563]                       if (inherits(cond, "message")) {
[10:25:53.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.563]                         if (muffled) 
[10:25:53.563]                           invokeRestart("muffleMessage")
[10:25:53.563]                       }
[10:25:53.563]                       else if (inherits(cond, "warning")) {
[10:25:53.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.563]                         if (muffled) 
[10:25:53.563]                           invokeRestart("muffleWarning")
[10:25:53.563]                       }
[10:25:53.563]                       else if (inherits(cond, "condition")) {
[10:25:53.563]                         if (!is.null(pattern)) {
[10:25:53.563]                           computeRestarts <- base::computeRestarts
[10:25:53.563]                           grepl <- base::grepl
[10:25:53.563]                           restarts <- computeRestarts(cond)
[10:25:53.563]                           for (restart in restarts) {
[10:25:53.563]                             name <- restart$name
[10:25:53.563]                             if (is.null(name)) 
[10:25:53.563]                               next
[10:25:53.563]                             if (!grepl(pattern, name)) 
[10:25:53.563]                               next
[10:25:53.563]                             invokeRestart(restart)
[10:25:53.563]                             muffled <- TRUE
[10:25:53.563]                             break
[10:25:53.563]                           }
[10:25:53.563]                         }
[10:25:53.563]                       }
[10:25:53.563]                       invisible(muffled)
[10:25:53.563]                     }
[10:25:53.563]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.563]                   }
[10:25:53.563]                 }
[10:25:53.563]                 else {
[10:25:53.563]                   if (TRUE) {
[10:25:53.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.563]                     {
[10:25:53.563]                       inherits <- base::inherits
[10:25:53.563]                       invokeRestart <- base::invokeRestart
[10:25:53.563]                       is.null <- base::is.null
[10:25:53.563]                       muffled <- FALSE
[10:25:53.563]                       if (inherits(cond, "message")) {
[10:25:53.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.563]                         if (muffled) 
[10:25:53.563]                           invokeRestart("muffleMessage")
[10:25:53.563]                       }
[10:25:53.563]                       else if (inherits(cond, "warning")) {
[10:25:53.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.563]                         if (muffled) 
[10:25:53.563]                           invokeRestart("muffleWarning")
[10:25:53.563]                       }
[10:25:53.563]                       else if (inherits(cond, "condition")) {
[10:25:53.563]                         if (!is.null(pattern)) {
[10:25:53.563]                           computeRestarts <- base::computeRestarts
[10:25:53.563]                           grepl <- base::grepl
[10:25:53.563]                           restarts <- computeRestarts(cond)
[10:25:53.563]                           for (restart in restarts) {
[10:25:53.563]                             name <- restart$name
[10:25:53.563]                             if (is.null(name)) 
[10:25:53.563]                               next
[10:25:53.563]                             if (!grepl(pattern, name)) 
[10:25:53.563]                               next
[10:25:53.563]                             invokeRestart(restart)
[10:25:53.563]                             muffled <- TRUE
[10:25:53.563]                             break
[10:25:53.563]                           }
[10:25:53.563]                         }
[10:25:53.563]                       }
[10:25:53.563]                       invisible(muffled)
[10:25:53.563]                     }
[10:25:53.563]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.563]                   }
[10:25:53.563]                 }
[10:25:53.563]             }
[10:25:53.563]         }))
[10:25:53.563]     }, error = function(ex) {
[10:25:53.563]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.563]                 ...future.rng), started = ...future.startTime, 
[10:25:53.563]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.563]             version = "1.8"), class = "FutureResult")
[10:25:53.563]     }, finally = {
[10:25:53.563]         if (!identical(...future.workdir, getwd())) 
[10:25:53.563]             setwd(...future.workdir)
[10:25:53.563]         {
[10:25:53.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.563]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.563]             }
[10:25:53.563]             base::options(...future.oldOptions)
[10:25:53.563]             if (.Platform$OS.type == "windows") {
[10:25:53.563]                 old_names <- names(...future.oldEnvVars)
[10:25:53.563]                 envs <- base::Sys.getenv()
[10:25:53.563]                 names <- names(envs)
[10:25:53.563]                 common <- intersect(names, old_names)
[10:25:53.563]                 added <- setdiff(names, old_names)
[10:25:53.563]                 removed <- setdiff(old_names, names)
[10:25:53.563]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.563]                   envs[common]]
[10:25:53.563]                 NAMES <- toupper(changed)
[10:25:53.563]                 args <- list()
[10:25:53.563]                 for (kk in seq_along(NAMES)) {
[10:25:53.563]                   name <- changed[[kk]]
[10:25:53.563]                   NAME <- NAMES[[kk]]
[10:25:53.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.563]                     next
[10:25:53.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.563]                 }
[10:25:53.563]                 NAMES <- toupper(added)
[10:25:53.563]                 for (kk in seq_along(NAMES)) {
[10:25:53.563]                   name <- added[[kk]]
[10:25:53.563]                   NAME <- NAMES[[kk]]
[10:25:53.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.563]                     next
[10:25:53.563]                   args[[name]] <- ""
[10:25:53.563]                 }
[10:25:53.563]                 NAMES <- toupper(removed)
[10:25:53.563]                 for (kk in seq_along(NAMES)) {
[10:25:53.563]                   name <- removed[[kk]]
[10:25:53.563]                   NAME <- NAMES[[kk]]
[10:25:53.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.563]                     next
[10:25:53.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.563]                 }
[10:25:53.563]                 if (length(args) > 0) 
[10:25:53.563]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.563]             }
[10:25:53.563]             else {
[10:25:53.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.563]             }
[10:25:53.563]             {
[10:25:53.563]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.563]                   0L) {
[10:25:53.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.563]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.563]                   base::options(opts)
[10:25:53.563]                 }
[10:25:53.563]                 {
[10:25:53.563]                   {
[10:25:53.563]                     NULL
[10:25:53.563]                     RNGkind("Mersenne-Twister")
[10:25:53.563]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.563]                       inherits = FALSE)
[10:25:53.563]                   }
[10:25:53.563]                   options(future.plan = NULL)
[10:25:53.563]                   if (is.na(NA_character_)) 
[10:25:53.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.563]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.563]                   {
[10:25:53.563]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.563]                     if (!future$lazy) 
[10:25:53.563]                       future <- run(future)
[10:25:53.563]                     invisible(future)
[10:25:53.563]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.563]                 }
[10:25:53.563]             }
[10:25:53.563]         }
[10:25:53.563]     })
[10:25:53.563]     if (TRUE) {
[10:25:53.563]         base::sink(type = "output", split = FALSE)
[10:25:53.563]         if (TRUE) {
[10:25:53.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.563]         }
[10:25:53.563]         else {
[10:25:53.563]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.563]         }
[10:25:53.563]         base::close(...future.stdout)
[10:25:53.563]         ...future.stdout <- NULL
[10:25:53.563]     }
[10:25:53.563]     ...future.result$conditions <- ...future.conditions
[10:25:53.563]     ...future.result$finished <- base::Sys.time()
[10:25:53.563]     ...future.result
[10:25:53.563] }
[10:25:53.564] plan(): Setting new future strategy stack:
[10:25:53.565] List of future strategies:
[10:25:53.565] 1. sequential:
[10:25:53.565]    - args: function (..., envir = parent.frame())
[10:25:53.565]    - tweaked: FALSE
[10:25:53.565]    - call: NULL
[10:25:53.565] plan(): nbrOfWorkers() = 1
[10:25:53.566] plan(): Setting new future strategy stack:
[10:25:53.566] List of future strategies:
[10:25:53.566] 1. sequential:
[10:25:53.566]    - args: function (..., envir = parent.frame())
[10:25:53.566]    - tweaked: FALSE
[10:25:53.566]    - call: plan(strategy)
[10:25:53.567] plan(): nbrOfWorkers() = 1
[10:25:53.567] SequentialFuture started (and completed)
[10:25:53.567] - Launch lazy future ... done
[10:25:53.567] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:25:53.569] getGlobalsAndPackages() ...
[10:25:53.569] Searching for globals...
[10:25:53.571] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:25:53.571] Searching for globals ... DONE
[10:25:53.572] Resolving globals: FALSE
[10:25:53.572] 
[10:25:53.572] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.572] getGlobalsAndPackages() ... DONE
[10:25:53.572] run() for ‘Future’ ...
[10:25:53.573] - state: ‘created’
[10:25:53.573] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.573] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.573]   - Field: ‘label’
[10:25:53.573]   - Field: ‘local’
[10:25:53.573]   - Field: ‘owner’
[10:25:53.573]   - Field: ‘envir’
[10:25:53.574]   - Field: ‘packages’
[10:25:53.574]   - Field: ‘gc’
[10:25:53.574]   - Field: ‘conditions’
[10:25:53.574]   - Field: ‘expr’
[10:25:53.574]   - Field: ‘uuid’
[10:25:53.574]   - Field: ‘seed’
[10:25:53.574]   - Field: ‘version’
[10:25:53.574]   - Field: ‘result’
[10:25:53.574]   - Field: ‘asynchronous’
[10:25:53.574]   - Field: ‘calls’
[10:25:53.574]   - Field: ‘globals’
[10:25:53.575]   - Field: ‘stdout’
[10:25:53.575]   - Field: ‘earlySignal’
[10:25:53.575]   - Field: ‘lazy’
[10:25:53.575]   - Field: ‘state’
[10:25:53.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.575] - Launch lazy future ...
[10:25:53.575] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.575] Packages needed by future strategies (n = 0): <none>
[10:25:53.576] {
[10:25:53.576]     {
[10:25:53.576]         {
[10:25:53.576]             ...future.startTime <- base::Sys.time()
[10:25:53.576]             {
[10:25:53.576]                 {
[10:25:53.576]                   {
[10:25:53.576]                     {
[10:25:53.576]                       base::local({
[10:25:53.576]                         has_future <- base::requireNamespace("future", 
[10:25:53.576]                           quietly = TRUE)
[10:25:53.576]                         if (has_future) {
[10:25:53.576]                           ns <- base::getNamespace("future")
[10:25:53.576]                           version <- ns[[".package"]][["version"]]
[10:25:53.576]                           if (is.null(version)) 
[10:25:53.576]                             version <- utils::packageVersion("future")
[10:25:53.576]                         }
[10:25:53.576]                         else {
[10:25:53.576]                           version <- NULL
[10:25:53.576]                         }
[10:25:53.576]                         if (!has_future || version < "1.8.0") {
[10:25:53.576]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.576]                             "", base::R.version$version.string), 
[10:25:53.576]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.576]                               "release", "version")], collapse = " "), 
[10:25:53.576]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.576]                             info)
[10:25:53.576]                           info <- base::paste(info, collapse = "; ")
[10:25:53.576]                           if (!has_future) {
[10:25:53.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.576]                               info)
[10:25:53.576]                           }
[10:25:53.576]                           else {
[10:25:53.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.576]                               info, version)
[10:25:53.576]                           }
[10:25:53.576]                           base::stop(msg)
[10:25:53.576]                         }
[10:25:53.576]                       })
[10:25:53.576]                     }
[10:25:53.576]                     base::local({
[10:25:53.576]                       for (pkg in c("stats", "datasets")) {
[10:25:53.576]                         base::loadNamespace(pkg)
[10:25:53.576]                         base::library(pkg, character.only = TRUE)
[10:25:53.576]                       }
[10:25:53.576]                     })
[10:25:53.576]                   }
[10:25:53.576]                   options(future.plan = NULL)
[10:25:53.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.576]                 }
[10:25:53.576]                 ...future.workdir <- getwd()
[10:25:53.576]             }
[10:25:53.576]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.576]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.576]         }
[10:25:53.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.576]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.576]             base::names(...future.oldOptions))
[10:25:53.576]     }
[10:25:53.576]     if (FALSE) {
[10:25:53.576]     }
[10:25:53.576]     else {
[10:25:53.576]         if (TRUE) {
[10:25:53.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.576]                 open = "w")
[10:25:53.576]         }
[10:25:53.576]         else {
[10:25:53.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.576]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.576]         }
[10:25:53.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.576]             base::sink(type = "output", split = FALSE)
[10:25:53.576]             base::close(...future.stdout)
[10:25:53.576]         }, add = TRUE)
[10:25:53.576]     }
[10:25:53.576]     ...future.frame <- base::sys.nframe()
[10:25:53.576]     ...future.conditions <- base::list()
[10:25:53.576]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.576]     if (FALSE) {
[10:25:53.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.576]     }
[10:25:53.576]     ...future.result <- base::tryCatch({
[10:25:53.576]         base::withCallingHandlers({
[10:25:53.576]             ...future.value <- base::withVisible(base::local({
[10:25:53.576]                 lm(dist ~ speed + I(speed^2), data = cars)
[10:25:53.576]             }))
[10:25:53.576]             future::FutureResult(value = ...future.value$value, 
[10:25:53.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.576]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.576]                     ...future.globalenv.names))
[10:25:53.576]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.576]         }, condition = base::local({
[10:25:53.576]             c <- base::c
[10:25:53.576]             inherits <- base::inherits
[10:25:53.576]             invokeRestart <- base::invokeRestart
[10:25:53.576]             length <- base::length
[10:25:53.576]             list <- base::list
[10:25:53.576]             seq.int <- base::seq.int
[10:25:53.576]             signalCondition <- base::signalCondition
[10:25:53.576]             sys.calls <- base::sys.calls
[10:25:53.576]             `[[` <- base::`[[`
[10:25:53.576]             `+` <- base::`+`
[10:25:53.576]             `<<-` <- base::`<<-`
[10:25:53.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.576]                   3L)]
[10:25:53.576]             }
[10:25:53.576]             function(cond) {
[10:25:53.576]                 is_error <- inherits(cond, "error")
[10:25:53.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.576]                   NULL)
[10:25:53.576]                 if (is_error) {
[10:25:53.576]                   sessionInformation <- function() {
[10:25:53.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.576]                       search = base::search(), system = base::Sys.info())
[10:25:53.576]                   }
[10:25:53.576]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.576]                     cond$call), session = sessionInformation(), 
[10:25:53.576]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.576]                   signalCondition(cond)
[10:25:53.576]                 }
[10:25:53.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.576]                 "immediateCondition"))) {
[10:25:53.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.576]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.576]                   if (TRUE && !signal) {
[10:25:53.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.576]                     {
[10:25:53.576]                       inherits <- base::inherits
[10:25:53.576]                       invokeRestart <- base::invokeRestart
[10:25:53.576]                       is.null <- base::is.null
[10:25:53.576]                       muffled <- FALSE
[10:25:53.576]                       if (inherits(cond, "message")) {
[10:25:53.576]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.576]                         if (muffled) 
[10:25:53.576]                           invokeRestart("muffleMessage")
[10:25:53.576]                       }
[10:25:53.576]                       else if (inherits(cond, "warning")) {
[10:25:53.576]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.576]                         if (muffled) 
[10:25:53.576]                           invokeRestart("muffleWarning")
[10:25:53.576]                       }
[10:25:53.576]                       else if (inherits(cond, "condition")) {
[10:25:53.576]                         if (!is.null(pattern)) {
[10:25:53.576]                           computeRestarts <- base::computeRestarts
[10:25:53.576]                           grepl <- base::grepl
[10:25:53.576]                           restarts <- computeRestarts(cond)
[10:25:53.576]                           for (restart in restarts) {
[10:25:53.576]                             name <- restart$name
[10:25:53.576]                             if (is.null(name)) 
[10:25:53.576]                               next
[10:25:53.576]                             if (!grepl(pattern, name)) 
[10:25:53.576]                               next
[10:25:53.576]                             invokeRestart(restart)
[10:25:53.576]                             muffled <- TRUE
[10:25:53.576]                             break
[10:25:53.576]                           }
[10:25:53.576]                         }
[10:25:53.576]                       }
[10:25:53.576]                       invisible(muffled)
[10:25:53.576]                     }
[10:25:53.576]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.576]                   }
[10:25:53.576]                 }
[10:25:53.576]                 else {
[10:25:53.576]                   if (TRUE) {
[10:25:53.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.576]                     {
[10:25:53.576]                       inherits <- base::inherits
[10:25:53.576]                       invokeRestart <- base::invokeRestart
[10:25:53.576]                       is.null <- base::is.null
[10:25:53.576]                       muffled <- FALSE
[10:25:53.576]                       if (inherits(cond, "message")) {
[10:25:53.576]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.576]                         if (muffled) 
[10:25:53.576]                           invokeRestart("muffleMessage")
[10:25:53.576]                       }
[10:25:53.576]                       else if (inherits(cond, "warning")) {
[10:25:53.576]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.576]                         if (muffled) 
[10:25:53.576]                           invokeRestart("muffleWarning")
[10:25:53.576]                       }
[10:25:53.576]                       else if (inherits(cond, "condition")) {
[10:25:53.576]                         if (!is.null(pattern)) {
[10:25:53.576]                           computeRestarts <- base::computeRestarts
[10:25:53.576]                           grepl <- base::grepl
[10:25:53.576]                           restarts <- computeRestarts(cond)
[10:25:53.576]                           for (restart in restarts) {
[10:25:53.576]                             name <- restart$name
[10:25:53.576]                             if (is.null(name)) 
[10:25:53.576]                               next
[10:25:53.576]                             if (!grepl(pattern, name)) 
[10:25:53.576]                               next
[10:25:53.576]                             invokeRestart(restart)
[10:25:53.576]                             muffled <- TRUE
[10:25:53.576]                             break
[10:25:53.576]                           }
[10:25:53.576]                         }
[10:25:53.576]                       }
[10:25:53.576]                       invisible(muffled)
[10:25:53.576]                     }
[10:25:53.576]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.576]                   }
[10:25:53.576]                 }
[10:25:53.576]             }
[10:25:53.576]         }))
[10:25:53.576]     }, error = function(ex) {
[10:25:53.576]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.576]                 ...future.rng), started = ...future.startTime, 
[10:25:53.576]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.576]             version = "1.8"), class = "FutureResult")
[10:25:53.576]     }, finally = {
[10:25:53.576]         if (!identical(...future.workdir, getwd())) 
[10:25:53.576]             setwd(...future.workdir)
[10:25:53.576]         {
[10:25:53.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.576]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.576]             }
[10:25:53.576]             base::options(...future.oldOptions)
[10:25:53.576]             if (.Platform$OS.type == "windows") {
[10:25:53.576]                 old_names <- names(...future.oldEnvVars)
[10:25:53.576]                 envs <- base::Sys.getenv()
[10:25:53.576]                 names <- names(envs)
[10:25:53.576]                 common <- intersect(names, old_names)
[10:25:53.576]                 added <- setdiff(names, old_names)
[10:25:53.576]                 removed <- setdiff(old_names, names)
[10:25:53.576]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.576]                   envs[common]]
[10:25:53.576]                 NAMES <- toupper(changed)
[10:25:53.576]                 args <- list()
[10:25:53.576]                 for (kk in seq_along(NAMES)) {
[10:25:53.576]                   name <- changed[[kk]]
[10:25:53.576]                   NAME <- NAMES[[kk]]
[10:25:53.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.576]                     next
[10:25:53.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.576]                 }
[10:25:53.576]                 NAMES <- toupper(added)
[10:25:53.576]                 for (kk in seq_along(NAMES)) {
[10:25:53.576]                   name <- added[[kk]]
[10:25:53.576]                   NAME <- NAMES[[kk]]
[10:25:53.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.576]                     next
[10:25:53.576]                   args[[name]] <- ""
[10:25:53.576]                 }
[10:25:53.576]                 NAMES <- toupper(removed)
[10:25:53.576]                 for (kk in seq_along(NAMES)) {
[10:25:53.576]                   name <- removed[[kk]]
[10:25:53.576]                   NAME <- NAMES[[kk]]
[10:25:53.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.576]                     next
[10:25:53.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.576]                 }
[10:25:53.576]                 if (length(args) > 0) 
[10:25:53.576]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.576]             }
[10:25:53.576]             else {
[10:25:53.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.576]             }
[10:25:53.576]             {
[10:25:53.576]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.576]                   0L) {
[10:25:53.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.576]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.576]                   base::options(opts)
[10:25:53.576]                 }
[10:25:53.576]                 {
[10:25:53.576]                   {
[10:25:53.576]                     NULL
[10:25:53.576]                     RNGkind("Mersenne-Twister")
[10:25:53.576]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.576]                       inherits = FALSE)
[10:25:53.576]                   }
[10:25:53.576]                   options(future.plan = NULL)
[10:25:53.576]                   if (is.na(NA_character_)) 
[10:25:53.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.576]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.576]                   {
[10:25:53.576]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.576]                     if (!future$lazy) 
[10:25:53.576]                       future <- run(future)
[10:25:53.576]                     invisible(future)
[10:25:53.576]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.576]                 }
[10:25:53.576]             }
[10:25:53.576]         }
[10:25:53.576]     })
[10:25:53.576]     if (TRUE) {
[10:25:53.576]         base::sink(type = "output", split = FALSE)
[10:25:53.576]         if (TRUE) {
[10:25:53.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.576]         }
[10:25:53.576]         else {
[10:25:53.576]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.576]         }
[10:25:53.576]         base::close(...future.stdout)
[10:25:53.576]         ...future.stdout <- NULL
[10:25:53.576]     }
[10:25:53.576]     ...future.result$conditions <- ...future.conditions
[10:25:53.576]     ...future.result$finished <- base::Sys.time()
[10:25:53.576]     ...future.result
[10:25:53.576] }
[10:25:53.578] plan(): Setting new future strategy stack:
[10:25:53.578] List of future strategies:
[10:25:53.578] 1. sequential:
[10:25:53.578]    - args: function (..., envir = parent.frame())
[10:25:53.578]    - tweaked: FALSE
[10:25:53.578]    - call: NULL
[10:25:53.578] plan(): nbrOfWorkers() = 1
[10:25:53.581] plan(): Setting new future strategy stack:
[10:25:53.581] List of future strategies:
[10:25:53.581] 1. sequential:
[10:25:53.581]    - args: function (..., envir = parent.frame())
[10:25:53.581]    - tweaked: FALSE
[10:25:53.581]    - call: plan(strategy)
[10:25:53.582] plan(): nbrOfWorkers() = 1
[10:25:53.582] SequentialFuture started (and completed)
[10:25:53.582] - Launch lazy future ... done
[10:25:53.582] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:25:53.585] getGlobalsAndPackages() ...
[10:25:53.585] Searching for globals...
[10:25:53.587] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:25:53.587] Searching for globals ... DONE
[10:25:53.587] Resolving globals: FALSE
[10:25:53.588] 
[10:25:53.588] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.588] getGlobalsAndPackages() ... DONE
[10:25:53.588] run() for ‘Future’ ...
[10:25:53.588] - state: ‘created’
[10:25:53.588] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.589]   - Field: ‘label’
[10:25:53.589]   - Field: ‘local’
[10:25:53.589]   - Field: ‘owner’
[10:25:53.589]   - Field: ‘envir’
[10:25:53.589]   - Field: ‘packages’
[10:25:53.589]   - Field: ‘gc’
[10:25:53.589]   - Field: ‘conditions’
[10:25:53.589]   - Field: ‘expr’
[10:25:53.589]   - Field: ‘uuid’
[10:25:53.590]   - Field: ‘seed’
[10:25:53.590]   - Field: ‘version’
[10:25:53.590]   - Field: ‘result’
[10:25:53.590]   - Field: ‘asynchronous’
[10:25:53.590]   - Field: ‘calls’
[10:25:53.590]   - Field: ‘globals’
[10:25:53.590]   - Field: ‘stdout’
[10:25:53.590]   - Field: ‘earlySignal’
[10:25:53.590]   - Field: ‘lazy’
[10:25:53.590]   - Field: ‘state’
[10:25:53.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.590] - Launch lazy future ...
[10:25:53.591] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.591] Packages needed by future strategies (n = 0): <none>
[10:25:53.591] {
[10:25:53.591]     {
[10:25:53.591]         {
[10:25:53.591]             ...future.startTime <- base::Sys.time()
[10:25:53.591]             {
[10:25:53.591]                 {
[10:25:53.591]                   {
[10:25:53.591]                     {
[10:25:53.591]                       base::local({
[10:25:53.591]                         has_future <- base::requireNamespace("future", 
[10:25:53.591]                           quietly = TRUE)
[10:25:53.591]                         if (has_future) {
[10:25:53.591]                           ns <- base::getNamespace("future")
[10:25:53.591]                           version <- ns[[".package"]][["version"]]
[10:25:53.591]                           if (is.null(version)) 
[10:25:53.591]                             version <- utils::packageVersion("future")
[10:25:53.591]                         }
[10:25:53.591]                         else {
[10:25:53.591]                           version <- NULL
[10:25:53.591]                         }
[10:25:53.591]                         if (!has_future || version < "1.8.0") {
[10:25:53.591]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.591]                             "", base::R.version$version.string), 
[10:25:53.591]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:53.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.591]                               "release", "version")], collapse = " "), 
[10:25:53.591]                             hostname = base::Sys.info()[["nodename"]])
[10:25:53.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.591]                             info)
[10:25:53.591]                           info <- base::paste(info, collapse = "; ")
[10:25:53.591]                           if (!has_future) {
[10:25:53.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.591]                               info)
[10:25:53.591]                           }
[10:25:53.591]                           else {
[10:25:53.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.591]                               info, version)
[10:25:53.591]                           }
[10:25:53.591]                           base::stop(msg)
[10:25:53.591]                         }
[10:25:53.591]                       })
[10:25:53.591]                     }
[10:25:53.591]                     base::local({
[10:25:53.591]                       for (pkg in c("stats", "datasets")) {
[10:25:53.591]                         base::loadNamespace(pkg)
[10:25:53.591]                         base::library(pkg, character.only = TRUE)
[10:25:53.591]                       }
[10:25:53.591]                     })
[10:25:53.591]                   }
[10:25:53.591]                   options(future.plan = NULL)
[10:25:53.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.591]                 }
[10:25:53.591]                 ...future.workdir <- getwd()
[10:25:53.591]             }
[10:25:53.591]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.591]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.591]         }
[10:25:53.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.591]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.591]             base::names(...future.oldOptions))
[10:25:53.591]     }
[10:25:53.591]     if (FALSE) {
[10:25:53.591]     }
[10:25:53.591]     else {
[10:25:53.591]         if (TRUE) {
[10:25:53.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.591]                 open = "w")
[10:25:53.591]         }
[10:25:53.591]         else {
[10:25:53.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.591]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.591]         }
[10:25:53.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.591]             base::sink(type = "output", split = FALSE)
[10:25:53.591]             base::close(...future.stdout)
[10:25:53.591]         }, add = TRUE)
[10:25:53.591]     }
[10:25:53.591]     ...future.frame <- base::sys.nframe()
[10:25:53.591]     ...future.conditions <- base::list()
[10:25:53.591]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.591]     if (FALSE) {
[10:25:53.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.591]     }
[10:25:53.591]     ...future.result <- base::tryCatch({
[10:25:53.591]         base::withCallingHandlers({
[10:25:53.591]             ...future.value <- base::withVisible(base::local({
[10:25:53.591]                 lm(dist ~ poly(speed, 2), data = cars)
[10:25:53.591]             }))
[10:25:53.591]             future::FutureResult(value = ...future.value$value, 
[10:25:53.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.591]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.591]                     ...future.globalenv.names))
[10:25:53.591]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.591]         }, condition = base::local({
[10:25:53.591]             c <- base::c
[10:25:53.591]             inherits <- base::inherits
[10:25:53.591]             invokeRestart <- base::invokeRestart
[10:25:53.591]             length <- base::length
[10:25:53.591]             list <- base::list
[10:25:53.591]             seq.int <- base::seq.int
[10:25:53.591]             signalCondition <- base::signalCondition
[10:25:53.591]             sys.calls <- base::sys.calls
[10:25:53.591]             `[[` <- base::`[[`
[10:25:53.591]             `+` <- base::`+`
[10:25:53.591]             `<<-` <- base::`<<-`
[10:25:53.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.591]                   3L)]
[10:25:53.591]             }
[10:25:53.591]             function(cond) {
[10:25:53.591]                 is_error <- inherits(cond, "error")
[10:25:53.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.591]                   NULL)
[10:25:53.591]                 if (is_error) {
[10:25:53.591]                   sessionInformation <- function() {
[10:25:53.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.591]                       search = base::search(), system = base::Sys.info())
[10:25:53.591]                   }
[10:25:53.591]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.591]                     cond$call), session = sessionInformation(), 
[10:25:53.591]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.591]                   signalCondition(cond)
[10:25:53.591]                 }
[10:25:53.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.591]                 "immediateCondition"))) {
[10:25:53.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.591]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.591]                   if (TRUE && !signal) {
[10:25:53.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.591]                     {
[10:25:53.591]                       inherits <- base::inherits
[10:25:53.591]                       invokeRestart <- base::invokeRestart
[10:25:53.591]                       is.null <- base::is.null
[10:25:53.591]                       muffled <- FALSE
[10:25:53.591]                       if (inherits(cond, "message")) {
[10:25:53.591]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.591]                         if (muffled) 
[10:25:53.591]                           invokeRestart("muffleMessage")
[10:25:53.591]                       }
[10:25:53.591]                       else if (inherits(cond, "warning")) {
[10:25:53.591]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.591]                         if (muffled) 
[10:25:53.591]                           invokeRestart("muffleWarning")
[10:25:53.591]                       }
[10:25:53.591]                       else if (inherits(cond, "condition")) {
[10:25:53.591]                         if (!is.null(pattern)) {
[10:25:53.591]                           computeRestarts <- base::computeRestarts
[10:25:53.591]                           grepl <- base::grepl
[10:25:53.591]                           restarts <- computeRestarts(cond)
[10:25:53.591]                           for (restart in restarts) {
[10:25:53.591]                             name <- restart$name
[10:25:53.591]                             if (is.null(name)) 
[10:25:53.591]                               next
[10:25:53.591]                             if (!grepl(pattern, name)) 
[10:25:53.591]                               next
[10:25:53.591]                             invokeRestart(restart)
[10:25:53.591]                             muffled <- TRUE
[10:25:53.591]                             break
[10:25:53.591]                           }
[10:25:53.591]                         }
[10:25:53.591]                       }
[10:25:53.591]                       invisible(muffled)
[10:25:53.591]                     }
[10:25:53.591]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.591]                   }
[10:25:53.591]                 }
[10:25:53.591]                 else {
[10:25:53.591]                   if (TRUE) {
[10:25:53.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.591]                     {
[10:25:53.591]                       inherits <- base::inherits
[10:25:53.591]                       invokeRestart <- base::invokeRestart
[10:25:53.591]                       is.null <- base::is.null
[10:25:53.591]                       muffled <- FALSE
[10:25:53.591]                       if (inherits(cond, "message")) {
[10:25:53.591]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.591]                         if (muffled) 
[10:25:53.591]                           invokeRestart("muffleMessage")
[10:25:53.591]                       }
[10:25:53.591]                       else if (inherits(cond, "warning")) {
[10:25:53.591]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.591]                         if (muffled) 
[10:25:53.591]                           invokeRestart("muffleWarning")
[10:25:53.591]                       }
[10:25:53.591]                       else if (inherits(cond, "condition")) {
[10:25:53.591]                         if (!is.null(pattern)) {
[10:25:53.591]                           computeRestarts <- base::computeRestarts
[10:25:53.591]                           grepl <- base::grepl
[10:25:53.591]                           restarts <- computeRestarts(cond)
[10:25:53.591]                           for (restart in restarts) {
[10:25:53.591]                             name <- restart$name
[10:25:53.591]                             if (is.null(name)) 
[10:25:53.591]                               next
[10:25:53.591]                             if (!grepl(pattern, name)) 
[10:25:53.591]                               next
[10:25:53.591]                             invokeRestart(restart)
[10:25:53.591]                             muffled <- TRUE
[10:25:53.591]                             break
[10:25:53.591]                           }
[10:25:53.591]                         }
[10:25:53.591]                       }
[10:25:53.591]                       invisible(muffled)
[10:25:53.591]                     }
[10:25:53.591]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.591]                   }
[10:25:53.591]                 }
[10:25:53.591]             }
[10:25:53.591]         }))
[10:25:53.591]     }, error = function(ex) {
[10:25:53.591]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.591]                 ...future.rng), started = ...future.startTime, 
[10:25:53.591]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.591]             version = "1.8"), class = "FutureResult")
[10:25:53.591]     }, finally = {
[10:25:53.591]         if (!identical(...future.workdir, getwd())) 
[10:25:53.591]             setwd(...future.workdir)
[10:25:53.591]         {
[10:25:53.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.591]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.591]             }
[10:25:53.591]             base::options(...future.oldOptions)
[10:25:53.591]             if (.Platform$OS.type == "windows") {
[10:25:53.591]                 old_names <- names(...future.oldEnvVars)
[10:25:53.591]                 envs <- base::Sys.getenv()
[10:25:53.591]                 names <- names(envs)
[10:25:53.591]                 common <- intersect(names, old_names)
[10:25:53.591]                 added <- setdiff(names, old_names)
[10:25:53.591]                 removed <- setdiff(old_names, names)
[10:25:53.591]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.591]                   envs[common]]
[10:25:53.591]                 NAMES <- toupper(changed)
[10:25:53.591]                 args <- list()
[10:25:53.591]                 for (kk in seq_along(NAMES)) {
[10:25:53.591]                   name <- changed[[kk]]
[10:25:53.591]                   NAME <- NAMES[[kk]]
[10:25:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.591]                     next
[10:25:53.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.591]                 }
[10:25:53.591]                 NAMES <- toupper(added)
[10:25:53.591]                 for (kk in seq_along(NAMES)) {
[10:25:53.591]                   name <- added[[kk]]
[10:25:53.591]                   NAME <- NAMES[[kk]]
[10:25:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.591]                     next
[10:25:53.591]                   args[[name]] <- ""
[10:25:53.591]                 }
[10:25:53.591]                 NAMES <- toupper(removed)
[10:25:53.591]                 for (kk in seq_along(NAMES)) {
[10:25:53.591]                   name <- removed[[kk]]
[10:25:53.591]                   NAME <- NAMES[[kk]]
[10:25:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.591]                     next
[10:25:53.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.591]                 }
[10:25:53.591]                 if (length(args) > 0) 
[10:25:53.591]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.591]             }
[10:25:53.591]             else {
[10:25:53.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.591]             }
[10:25:53.591]             {
[10:25:53.591]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.591]                   0L) {
[10:25:53.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.591]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.591]                   base::options(opts)
[10:25:53.591]                 }
[10:25:53.591]                 {
[10:25:53.591]                   {
[10:25:53.591]                     NULL
[10:25:53.591]                     RNGkind("Mersenne-Twister")
[10:25:53.591]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.591]                       inherits = FALSE)
[10:25:53.591]                   }
[10:25:53.591]                   options(future.plan = NULL)
[10:25:53.591]                   if (is.na(NA_character_)) 
[10:25:53.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.591]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.591]                   {
[10:25:53.591]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.591]                     if (!future$lazy) 
[10:25:53.591]                       future <- run(future)
[10:25:53.591]                     invisible(future)
[10:25:53.591]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.591]                 }
[10:25:53.591]             }
[10:25:53.591]         }
[10:25:53.591]     })
[10:25:53.591]     if (TRUE) {
[10:25:53.591]         base::sink(type = "output", split = FALSE)
[10:25:53.591]         if (TRUE) {
[10:25:53.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.591]         }
[10:25:53.591]         else {
[10:25:53.591]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.591]         }
[10:25:53.591]         base::close(...future.stdout)
[10:25:53.591]         ...future.stdout <- NULL
[10:25:53.591]     }
[10:25:53.591]     ...future.result$conditions <- ...future.conditions
[10:25:53.591]     ...future.result$finished <- base::Sys.time()
[10:25:53.591]     ...future.result
[10:25:53.591] }
[10:25:53.593] plan(): Setting new future strategy stack:
[10:25:53.593] List of future strategies:
[10:25:53.593] 1. sequential:
[10:25:53.593]    - args: function (..., envir = parent.frame())
[10:25:53.593]    - tweaked: FALSE
[10:25:53.593]    - call: NULL
[10:25:53.594] plan(): nbrOfWorkers() = 1
[10:25:53.595] plan(): Setting new future strategy stack:
[10:25:53.595] List of future strategies:
[10:25:53.595] 1. sequential:
[10:25:53.595]    - args: function (..., envir = parent.frame())
[10:25:53.595]    - tweaked: FALSE
[10:25:53.595]    - call: plan(strategy)
[10:25:53.595] plan(): nbrOfWorkers() = 1
[10:25:53.596] SequentialFuture started (and completed)
[10:25:53.596] - Launch lazy future ... done
[10:25:53.596] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:25:53.598] getGlobalsAndPackages() ...
[10:25:53.598] Searching for globals...
[10:25:53.604] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:53.604] Searching for globals ... DONE
[10:25:53.604] Resolving globals: FALSE
[10:25:53.605] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:53.605] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:53.605] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:53.605] 
[10:25:53.605] getGlobalsAndPackages() ... DONE
[10:25:53.606] run() for ‘Future’ ...
[10:25:53.606] - state: ‘created’
[10:25:53.606] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.606] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.606]   - Field: ‘label’
[10:25:53.606]   - Field: ‘local’
[10:25:53.607]   - Field: ‘owner’
[10:25:53.607]   - Field: ‘envir’
[10:25:53.607]   - Field: ‘packages’
[10:25:53.607]   - Field: ‘gc’
[10:25:53.607]   - Field: ‘conditions’
[10:25:53.607]   - Field: ‘expr’
[10:25:53.607]   - Field: ‘uuid’
[10:25:53.607]   - Field: ‘seed’
[10:25:53.607]   - Field: ‘version’
[10:25:53.607]   - Field: ‘result’
[10:25:53.607]   - Field: ‘asynchronous’
[10:25:53.608]   - Field: ‘calls’
[10:25:53.608]   - Field: ‘globals’
[10:25:53.608]   - Field: ‘stdout’
[10:25:53.608]   - Field: ‘earlySignal’
[10:25:53.608]   - Field: ‘lazy’
[10:25:53.608]   - Field: ‘state’
[10:25:53.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.608] - Launch lazy future ...
[10:25:53.608] Packages needed by the future expression (n = 0): <none>
[10:25:53.608] Packages needed by future strategies (n = 0): <none>
[10:25:53.609] {
[10:25:53.609]     {
[10:25:53.609]         {
[10:25:53.609]             ...future.startTime <- base::Sys.time()
[10:25:53.609]             {
[10:25:53.609]                 {
[10:25:53.609]                   {
[10:25:53.609]                     base::local({
[10:25:53.609]                       has_future <- base::requireNamespace("future", 
[10:25:53.609]                         quietly = TRUE)
[10:25:53.609]                       if (has_future) {
[10:25:53.609]                         ns <- base::getNamespace("future")
[10:25:53.609]                         version <- ns[[".package"]][["version"]]
[10:25:53.609]                         if (is.null(version)) 
[10:25:53.609]                           version <- utils::packageVersion("future")
[10:25:53.609]                       }
[10:25:53.609]                       else {
[10:25:53.609]                         version <- NULL
[10:25:53.609]                       }
[10:25:53.609]                       if (!has_future || version < "1.8.0") {
[10:25:53.609]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.609]                           "", base::R.version$version.string), 
[10:25:53.609]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:53.609]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.609]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.609]                             "release", "version")], collapse = " "), 
[10:25:53.609]                           hostname = base::Sys.info()[["nodename"]])
[10:25:53.609]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.609]                           info)
[10:25:53.609]                         info <- base::paste(info, collapse = "; ")
[10:25:53.609]                         if (!has_future) {
[10:25:53.609]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.609]                             info)
[10:25:53.609]                         }
[10:25:53.609]                         else {
[10:25:53.609]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.609]                             info, version)
[10:25:53.609]                         }
[10:25:53.609]                         base::stop(msg)
[10:25:53.609]                       }
[10:25:53.609]                     })
[10:25:53.609]                   }
[10:25:53.609]                   options(future.plan = NULL)
[10:25:53.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.609]                 }
[10:25:53.609]                 ...future.workdir <- getwd()
[10:25:53.609]             }
[10:25:53.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.609]         }
[10:25:53.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.609]             base::names(...future.oldOptions))
[10:25:53.609]     }
[10:25:53.609]     if (FALSE) {
[10:25:53.609]     }
[10:25:53.609]     else {
[10:25:53.609]         if (TRUE) {
[10:25:53.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.609]                 open = "w")
[10:25:53.609]         }
[10:25:53.609]         else {
[10:25:53.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.609]         }
[10:25:53.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.609]             base::sink(type = "output", split = FALSE)
[10:25:53.609]             base::close(...future.stdout)
[10:25:53.609]         }, add = TRUE)
[10:25:53.609]     }
[10:25:53.609]     ...future.frame <- base::sys.nframe()
[10:25:53.609]     ...future.conditions <- base::list()
[10:25:53.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.609]     if (FALSE) {
[10:25:53.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.609]     }
[10:25:53.609]     ...future.result <- base::tryCatch({
[10:25:53.609]         base::withCallingHandlers({
[10:25:53.609]             ...future.value <- base::withVisible(base::local({
[10:25:53.609]                 outer_function(1L)
[10:25:53.609]             }))
[10:25:53.609]             future::FutureResult(value = ...future.value$value, 
[10:25:53.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.609]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.609]                     ...future.globalenv.names))
[10:25:53.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.609]         }, condition = base::local({
[10:25:53.609]             c <- base::c
[10:25:53.609]             inherits <- base::inherits
[10:25:53.609]             invokeRestart <- base::invokeRestart
[10:25:53.609]             length <- base::length
[10:25:53.609]             list <- base::list
[10:25:53.609]             seq.int <- base::seq.int
[10:25:53.609]             signalCondition <- base::signalCondition
[10:25:53.609]             sys.calls <- base::sys.calls
[10:25:53.609]             `[[` <- base::`[[`
[10:25:53.609]             `+` <- base::`+`
[10:25:53.609]             `<<-` <- base::`<<-`
[10:25:53.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.609]                   3L)]
[10:25:53.609]             }
[10:25:53.609]             function(cond) {
[10:25:53.609]                 is_error <- inherits(cond, "error")
[10:25:53.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.609]                   NULL)
[10:25:53.609]                 if (is_error) {
[10:25:53.609]                   sessionInformation <- function() {
[10:25:53.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.609]                       search = base::search(), system = base::Sys.info())
[10:25:53.609]                   }
[10:25:53.609]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.609]                     cond$call), session = sessionInformation(), 
[10:25:53.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.609]                   signalCondition(cond)
[10:25:53.609]                 }
[10:25:53.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.609]                 "immediateCondition"))) {
[10:25:53.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.609]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.609]                   if (TRUE && !signal) {
[10:25:53.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.609]                     {
[10:25:53.609]                       inherits <- base::inherits
[10:25:53.609]                       invokeRestart <- base::invokeRestart
[10:25:53.609]                       is.null <- base::is.null
[10:25:53.609]                       muffled <- FALSE
[10:25:53.609]                       if (inherits(cond, "message")) {
[10:25:53.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.609]                         if (muffled) 
[10:25:53.609]                           invokeRestart("muffleMessage")
[10:25:53.609]                       }
[10:25:53.609]                       else if (inherits(cond, "warning")) {
[10:25:53.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.609]                         if (muffled) 
[10:25:53.609]                           invokeRestart("muffleWarning")
[10:25:53.609]                       }
[10:25:53.609]                       else if (inherits(cond, "condition")) {
[10:25:53.609]                         if (!is.null(pattern)) {
[10:25:53.609]                           computeRestarts <- base::computeRestarts
[10:25:53.609]                           grepl <- base::grepl
[10:25:53.609]                           restarts <- computeRestarts(cond)
[10:25:53.609]                           for (restart in restarts) {
[10:25:53.609]                             name <- restart$name
[10:25:53.609]                             if (is.null(name)) 
[10:25:53.609]                               next
[10:25:53.609]                             if (!grepl(pattern, name)) 
[10:25:53.609]                               next
[10:25:53.609]                             invokeRestart(restart)
[10:25:53.609]                             muffled <- TRUE
[10:25:53.609]                             break
[10:25:53.609]                           }
[10:25:53.609]                         }
[10:25:53.609]                       }
[10:25:53.609]                       invisible(muffled)
[10:25:53.609]                     }
[10:25:53.609]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.609]                   }
[10:25:53.609]                 }
[10:25:53.609]                 else {
[10:25:53.609]                   if (TRUE) {
[10:25:53.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.609]                     {
[10:25:53.609]                       inherits <- base::inherits
[10:25:53.609]                       invokeRestart <- base::invokeRestart
[10:25:53.609]                       is.null <- base::is.null
[10:25:53.609]                       muffled <- FALSE
[10:25:53.609]                       if (inherits(cond, "message")) {
[10:25:53.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.609]                         if (muffled) 
[10:25:53.609]                           invokeRestart("muffleMessage")
[10:25:53.609]                       }
[10:25:53.609]                       else if (inherits(cond, "warning")) {
[10:25:53.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.609]                         if (muffled) 
[10:25:53.609]                           invokeRestart("muffleWarning")
[10:25:53.609]                       }
[10:25:53.609]                       else if (inherits(cond, "condition")) {
[10:25:53.609]                         if (!is.null(pattern)) {
[10:25:53.609]                           computeRestarts <- base::computeRestarts
[10:25:53.609]                           grepl <- base::grepl
[10:25:53.609]                           restarts <- computeRestarts(cond)
[10:25:53.609]                           for (restart in restarts) {
[10:25:53.609]                             name <- restart$name
[10:25:53.609]                             if (is.null(name)) 
[10:25:53.609]                               next
[10:25:53.609]                             if (!grepl(pattern, name)) 
[10:25:53.609]                               next
[10:25:53.609]                             invokeRestart(restart)
[10:25:53.609]                             muffled <- TRUE
[10:25:53.609]                             break
[10:25:53.609]                           }
[10:25:53.609]                         }
[10:25:53.609]                       }
[10:25:53.609]                       invisible(muffled)
[10:25:53.609]                     }
[10:25:53.609]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.609]                   }
[10:25:53.609]                 }
[10:25:53.609]             }
[10:25:53.609]         }))
[10:25:53.609]     }, error = function(ex) {
[10:25:53.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.609]                 ...future.rng), started = ...future.startTime, 
[10:25:53.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.609]             version = "1.8"), class = "FutureResult")
[10:25:53.609]     }, finally = {
[10:25:53.609]         if (!identical(...future.workdir, getwd())) 
[10:25:53.609]             setwd(...future.workdir)
[10:25:53.609]         {
[10:25:53.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.609]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.609]             }
[10:25:53.609]             base::options(...future.oldOptions)
[10:25:53.609]             if (.Platform$OS.type == "windows") {
[10:25:53.609]                 old_names <- names(...future.oldEnvVars)
[10:25:53.609]                 envs <- base::Sys.getenv()
[10:25:53.609]                 names <- names(envs)
[10:25:53.609]                 common <- intersect(names, old_names)
[10:25:53.609]                 added <- setdiff(names, old_names)
[10:25:53.609]                 removed <- setdiff(old_names, names)
[10:25:53.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.609]                   envs[common]]
[10:25:53.609]                 NAMES <- toupper(changed)
[10:25:53.609]                 args <- list()
[10:25:53.609]                 for (kk in seq_along(NAMES)) {
[10:25:53.609]                   name <- changed[[kk]]
[10:25:53.609]                   NAME <- NAMES[[kk]]
[10:25:53.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.609]                     next
[10:25:53.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.609]                 }
[10:25:53.609]                 NAMES <- toupper(added)
[10:25:53.609]                 for (kk in seq_along(NAMES)) {
[10:25:53.609]                   name <- added[[kk]]
[10:25:53.609]                   NAME <- NAMES[[kk]]
[10:25:53.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.609]                     next
[10:25:53.609]                   args[[name]] <- ""
[10:25:53.609]                 }
[10:25:53.609]                 NAMES <- toupper(removed)
[10:25:53.609]                 for (kk in seq_along(NAMES)) {
[10:25:53.609]                   name <- removed[[kk]]
[10:25:53.609]                   NAME <- NAMES[[kk]]
[10:25:53.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.609]                     next
[10:25:53.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.609]                 }
[10:25:53.609]                 if (length(args) > 0) 
[10:25:53.609]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.609]             }
[10:25:53.609]             else {
[10:25:53.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.609]             }
[10:25:53.609]             {
[10:25:53.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.609]                   0L) {
[10:25:53.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.609]                   base::options(opts)
[10:25:53.609]                 }
[10:25:53.609]                 {
[10:25:53.609]                   {
[10:25:53.609]                     NULL
[10:25:53.609]                     RNGkind("Mersenne-Twister")
[10:25:53.609]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.609]                       inherits = FALSE)
[10:25:53.609]                   }
[10:25:53.609]                   options(future.plan = NULL)
[10:25:53.609]                   if (is.na(NA_character_)) 
[10:25:53.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.609]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.609]                   {
[10:25:53.609]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.609]                     if (!future$lazy) 
[10:25:53.609]                       future <- run(future)
[10:25:53.609]                     invisible(future)
[10:25:53.609]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.609]                 }
[10:25:53.609]             }
[10:25:53.609]         }
[10:25:53.609]     })
[10:25:53.609]     if (TRUE) {
[10:25:53.609]         base::sink(type = "output", split = FALSE)
[10:25:53.609]         if (TRUE) {
[10:25:53.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.609]         }
[10:25:53.609]         else {
[10:25:53.609]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.609]         }
[10:25:53.609]         base::close(...future.stdout)
[10:25:53.609]         ...future.stdout <- NULL
[10:25:53.609]     }
[10:25:53.609]     ...future.result$conditions <- ...future.conditions
[10:25:53.609]     ...future.result$finished <- base::Sys.time()
[10:25:53.609]     ...future.result
[10:25:53.609] }
[10:25:53.610] assign_globals() ...
[10:25:53.610] List of 3
[10:25:53.610]  $ outer_function:function (x)  
[10:25:53.610]  $ map           :function (.x, .f, ...)  
[10:25:53.610]  $ inner_function:function (x)  
[10:25:53.610]  - attr(*, "where")=List of 3
[10:25:53.610]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:25:53.610]   ..$ map           :<environment: R_EmptyEnv> 
[10:25:53.610]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:25:53.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.610]  - attr(*, "resolved")= logi FALSE
[10:25:53.610]  - attr(*, "total_size")= num 7704
[10:25:53.610]  - attr(*, "already-done")= logi TRUE
[10:25:53.614] - reassign environment for ‘outer_function’
[10:25:53.614] - copied ‘outer_function’ to environment
[10:25:53.614] - reassign environment for ‘map’
[10:25:53.614] - copied ‘map’ to environment
[10:25:53.614] - reassign environment for ‘inner_function’
[10:25:53.614] - copied ‘inner_function’ to environment
[10:25:53.614] assign_globals() ... done
[10:25:53.614] plan(): Setting new future strategy stack:
[10:25:53.615] List of future strategies:
[10:25:53.615] 1. sequential:
[10:25:53.615]    - args: function (..., envir = parent.frame())
[10:25:53.615]    - tweaked: FALSE
[10:25:53.615]    - call: NULL
[10:25:53.615] plan(): nbrOfWorkers() = 1
[10:25:53.620] plan(): Setting new future strategy stack:
[10:25:53.620] List of future strategies:
[10:25:53.620] 1. sequential:
[10:25:53.620]    - args: function (..., envir = parent.frame())
[10:25:53.620]    - tweaked: FALSE
[10:25:53.620]    - call: plan(strategy)
[10:25:53.620] plan(): nbrOfWorkers() = 1
[10:25:53.620] SequentialFuture started (and completed)
[10:25:53.620] - Launch lazy future ... done
[10:25:53.620] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:25:53.622] getGlobalsAndPackages() ...
[10:25:53.622] Searching for globals...
[10:25:53.627] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:53.627] Searching for globals ... DONE
[10:25:53.627] Resolving globals: FALSE
[10:25:53.628] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:53.628] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:53.628] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:53.628] 
[10:25:53.628] getGlobalsAndPackages() ... DONE
[10:25:53.629] run() for ‘Future’ ...
[10:25:53.629] - state: ‘created’
[10:25:53.629] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:53.629] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:53.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:53.629]   - Field: ‘label’
[10:25:53.629]   - Field: ‘local’
[10:25:53.629]   - Field: ‘owner’
[10:25:53.630]   - Field: ‘envir’
[10:25:53.630]   - Field: ‘packages’
[10:25:53.630]   - Field: ‘gc’
[10:25:53.630]   - Field: ‘conditions’
[10:25:53.630]   - Field: ‘expr’
[10:25:53.630]   - Field: ‘uuid’
[10:25:53.630]   - Field: ‘seed’
[10:25:53.630]   - Field: ‘version’
[10:25:53.630]   - Field: ‘result’
[10:25:53.630]   - Field: ‘asynchronous’
[10:25:53.630]   - Field: ‘calls’
[10:25:53.631]   - Field: ‘globals’
[10:25:53.631]   - Field: ‘stdout’
[10:25:53.631]   - Field: ‘earlySignal’
[10:25:53.631]   - Field: ‘lazy’
[10:25:53.631]   - Field: ‘state’
[10:25:53.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:53.631] - Launch lazy future ...
[10:25:53.631] Packages needed by the future expression (n = 0): <none>
[10:25:53.631] Packages needed by future strategies (n = 0): <none>
[10:25:53.632] {
[10:25:53.632]     {
[10:25:53.632]         {
[10:25:53.632]             ...future.startTime <- base::Sys.time()
[10:25:53.632]             {
[10:25:53.632]                 {
[10:25:53.632]                   {
[10:25:53.632]                     base::local({
[10:25:53.632]                       has_future <- base::requireNamespace("future", 
[10:25:53.632]                         quietly = TRUE)
[10:25:53.632]                       if (has_future) {
[10:25:53.632]                         ns <- base::getNamespace("future")
[10:25:53.632]                         version <- ns[[".package"]][["version"]]
[10:25:53.632]                         if (is.null(version)) 
[10:25:53.632]                           version <- utils::packageVersion("future")
[10:25:53.632]                       }
[10:25:53.632]                       else {
[10:25:53.632]                         version <- NULL
[10:25:53.632]                       }
[10:25:53.632]                       if (!has_future || version < "1.8.0") {
[10:25:53.632]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.632]                           "", base::R.version$version.string), 
[10:25:53.632]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:53.632]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:53.632]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.632]                             "release", "version")], collapse = " "), 
[10:25:53.632]                           hostname = base::Sys.info()[["nodename"]])
[10:25:53.632]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.632]                           info)
[10:25:53.632]                         info <- base::paste(info, collapse = "; ")
[10:25:53.632]                         if (!has_future) {
[10:25:53.632]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.632]                             info)
[10:25:53.632]                         }
[10:25:53.632]                         else {
[10:25:53.632]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.632]                             info, version)
[10:25:53.632]                         }
[10:25:53.632]                         base::stop(msg)
[10:25:53.632]                       }
[10:25:53.632]                     })
[10:25:53.632]                   }
[10:25:53.632]                   options(future.plan = NULL)
[10:25:53.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.632]                 }
[10:25:53.632]                 ...future.workdir <- getwd()
[10:25:53.632]             }
[10:25:53.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.632]         }
[10:25:53.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.632]             base::names(...future.oldOptions))
[10:25:53.632]     }
[10:25:53.632]     if (FALSE) {
[10:25:53.632]     }
[10:25:53.632]     else {
[10:25:53.632]         if (TRUE) {
[10:25:53.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.632]                 open = "w")
[10:25:53.632]         }
[10:25:53.632]         else {
[10:25:53.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.632]         }
[10:25:53.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.632]             base::sink(type = "output", split = FALSE)
[10:25:53.632]             base::close(...future.stdout)
[10:25:53.632]         }, add = TRUE)
[10:25:53.632]     }
[10:25:53.632]     ...future.frame <- base::sys.nframe()
[10:25:53.632]     ...future.conditions <- base::list()
[10:25:53.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.632]     if (FALSE) {
[10:25:53.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.632]     }
[10:25:53.632]     ...future.result <- base::tryCatch({
[10:25:53.632]         base::withCallingHandlers({
[10:25:53.632]             ...future.value <- base::withVisible(base::local({
[10:25:53.632]                 outer_function(1L)
[10:25:53.632]             }))
[10:25:53.632]             future::FutureResult(value = ...future.value$value, 
[10:25:53.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.632]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.632]                     ...future.globalenv.names))
[10:25:53.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.632]         }, condition = base::local({
[10:25:53.632]             c <- base::c
[10:25:53.632]             inherits <- base::inherits
[10:25:53.632]             invokeRestart <- base::invokeRestart
[10:25:53.632]             length <- base::length
[10:25:53.632]             list <- base::list
[10:25:53.632]             seq.int <- base::seq.int
[10:25:53.632]             signalCondition <- base::signalCondition
[10:25:53.632]             sys.calls <- base::sys.calls
[10:25:53.632]             `[[` <- base::`[[`
[10:25:53.632]             `+` <- base::`+`
[10:25:53.632]             `<<-` <- base::`<<-`
[10:25:53.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.632]                   3L)]
[10:25:53.632]             }
[10:25:53.632]             function(cond) {
[10:25:53.632]                 is_error <- inherits(cond, "error")
[10:25:53.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.632]                   NULL)
[10:25:53.632]                 if (is_error) {
[10:25:53.632]                   sessionInformation <- function() {
[10:25:53.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.632]                       search = base::search(), system = base::Sys.info())
[10:25:53.632]                   }
[10:25:53.632]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.632]                     cond$call), session = sessionInformation(), 
[10:25:53.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.632]                   signalCondition(cond)
[10:25:53.632]                 }
[10:25:53.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.632]                 "immediateCondition"))) {
[10:25:53.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.632]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.632]                   if (TRUE && !signal) {
[10:25:53.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.632]                     {
[10:25:53.632]                       inherits <- base::inherits
[10:25:53.632]                       invokeRestart <- base::invokeRestart
[10:25:53.632]                       is.null <- base::is.null
[10:25:53.632]                       muffled <- FALSE
[10:25:53.632]                       if (inherits(cond, "message")) {
[10:25:53.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.632]                         if (muffled) 
[10:25:53.632]                           invokeRestart("muffleMessage")
[10:25:53.632]                       }
[10:25:53.632]                       else if (inherits(cond, "warning")) {
[10:25:53.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.632]                         if (muffled) 
[10:25:53.632]                           invokeRestart("muffleWarning")
[10:25:53.632]                       }
[10:25:53.632]                       else if (inherits(cond, "condition")) {
[10:25:53.632]                         if (!is.null(pattern)) {
[10:25:53.632]                           computeRestarts <- base::computeRestarts
[10:25:53.632]                           grepl <- base::grepl
[10:25:53.632]                           restarts <- computeRestarts(cond)
[10:25:53.632]                           for (restart in restarts) {
[10:25:53.632]                             name <- restart$name
[10:25:53.632]                             if (is.null(name)) 
[10:25:53.632]                               next
[10:25:53.632]                             if (!grepl(pattern, name)) 
[10:25:53.632]                               next
[10:25:53.632]                             invokeRestart(restart)
[10:25:53.632]                             muffled <- TRUE
[10:25:53.632]                             break
[10:25:53.632]                           }
[10:25:53.632]                         }
[10:25:53.632]                       }
[10:25:53.632]                       invisible(muffled)
[10:25:53.632]                     }
[10:25:53.632]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.632]                   }
[10:25:53.632]                 }
[10:25:53.632]                 else {
[10:25:53.632]                   if (TRUE) {
[10:25:53.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.632]                     {
[10:25:53.632]                       inherits <- base::inherits
[10:25:53.632]                       invokeRestart <- base::invokeRestart
[10:25:53.632]                       is.null <- base::is.null
[10:25:53.632]                       muffled <- FALSE
[10:25:53.632]                       if (inherits(cond, "message")) {
[10:25:53.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.632]                         if (muffled) 
[10:25:53.632]                           invokeRestart("muffleMessage")
[10:25:53.632]                       }
[10:25:53.632]                       else if (inherits(cond, "warning")) {
[10:25:53.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.632]                         if (muffled) 
[10:25:53.632]                           invokeRestart("muffleWarning")
[10:25:53.632]                       }
[10:25:53.632]                       else if (inherits(cond, "condition")) {
[10:25:53.632]                         if (!is.null(pattern)) {
[10:25:53.632]                           computeRestarts <- base::computeRestarts
[10:25:53.632]                           grepl <- base::grepl
[10:25:53.632]                           restarts <- computeRestarts(cond)
[10:25:53.632]                           for (restart in restarts) {
[10:25:53.632]                             name <- restart$name
[10:25:53.632]                             if (is.null(name)) 
[10:25:53.632]                               next
[10:25:53.632]                             if (!grepl(pattern, name)) 
[10:25:53.632]                               next
[10:25:53.632]                             invokeRestart(restart)
[10:25:53.632]                             muffled <- TRUE
[10:25:53.632]                             break
[10:25:53.632]                           }
[10:25:53.632]                         }
[10:25:53.632]                       }
[10:25:53.632]                       invisible(muffled)
[10:25:53.632]                     }
[10:25:53.632]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.632]                   }
[10:25:53.632]                 }
[10:25:53.632]             }
[10:25:53.632]         }))
[10:25:53.632]     }, error = function(ex) {
[10:25:53.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.632]                 ...future.rng), started = ...future.startTime, 
[10:25:53.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.632]             version = "1.8"), class = "FutureResult")
[10:25:53.632]     }, finally = {
[10:25:53.632]         if (!identical(...future.workdir, getwd())) 
[10:25:53.632]             setwd(...future.workdir)
[10:25:53.632]         {
[10:25:53.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.632]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.632]             }
[10:25:53.632]             base::options(...future.oldOptions)
[10:25:53.632]             if (.Platform$OS.type == "windows") {
[10:25:53.632]                 old_names <- names(...future.oldEnvVars)
[10:25:53.632]                 envs <- base::Sys.getenv()
[10:25:53.632]                 names <- names(envs)
[10:25:53.632]                 common <- intersect(names, old_names)
[10:25:53.632]                 added <- setdiff(names, old_names)
[10:25:53.632]                 removed <- setdiff(old_names, names)
[10:25:53.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.632]                   envs[common]]
[10:25:53.632]                 NAMES <- toupper(changed)
[10:25:53.632]                 args <- list()
[10:25:53.632]                 for (kk in seq_along(NAMES)) {
[10:25:53.632]                   name <- changed[[kk]]
[10:25:53.632]                   NAME <- NAMES[[kk]]
[10:25:53.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.632]                     next
[10:25:53.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.632]                 }
[10:25:53.632]                 NAMES <- toupper(added)
[10:25:53.632]                 for (kk in seq_along(NAMES)) {
[10:25:53.632]                   name <- added[[kk]]
[10:25:53.632]                   NAME <- NAMES[[kk]]
[10:25:53.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.632]                     next
[10:25:53.632]                   args[[name]] <- ""
[10:25:53.632]                 }
[10:25:53.632]                 NAMES <- toupper(removed)
[10:25:53.632]                 for (kk in seq_along(NAMES)) {
[10:25:53.632]                   name <- removed[[kk]]
[10:25:53.632]                   NAME <- NAMES[[kk]]
[10:25:53.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.632]                     next
[10:25:53.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.632]                 }
[10:25:53.632]                 if (length(args) > 0) 
[10:25:53.632]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.632]             }
[10:25:53.632]             else {
[10:25:53.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.632]             }
[10:25:53.632]             {
[10:25:53.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.632]                   0L) {
[10:25:53.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.632]                   base::options(opts)
[10:25:53.632]                 }
[10:25:53.632]                 {
[10:25:53.632]                   {
[10:25:53.632]                     NULL
[10:25:53.632]                     RNGkind("Mersenne-Twister")
[10:25:53.632]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:53.632]                       inherits = FALSE)
[10:25:53.632]                   }
[10:25:53.632]                   options(future.plan = NULL)
[10:25:53.632]                   if (is.na(NA_character_)) 
[10:25:53.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.632]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:53.632]                   {
[10:25:53.632]                     future <- SequentialFuture(..., envir = envir)
[10:25:53.632]                     if (!future$lazy) 
[10:25:53.632]                       future <- run(future)
[10:25:53.632]                     invisible(future)
[10:25:53.632]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.632]                 }
[10:25:53.632]             }
[10:25:53.632]         }
[10:25:53.632]     })
[10:25:53.632]     if (TRUE) {
[10:25:53.632]         base::sink(type = "output", split = FALSE)
[10:25:53.632]         if (TRUE) {
[10:25:53.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.632]         }
[10:25:53.632]         else {
[10:25:53.632]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.632]         }
[10:25:53.632]         base::close(...future.stdout)
[10:25:53.632]         ...future.stdout <- NULL
[10:25:53.632]     }
[10:25:53.632]     ...future.result$conditions <- ...future.conditions
[10:25:53.632]     ...future.result$finished <- base::Sys.time()
[10:25:53.632]     ...future.result
[10:25:53.632] }
[10:25:53.633] assign_globals() ...
[10:25:53.633] List of 3
[10:25:53.633]  $ outer_function:function (x)  
[10:25:53.633]  $ map           :function (.x, .f, ...)  
[10:25:53.633]  $ inner_function:function (x)  
[10:25:53.633]  - attr(*, "where")=List of 3
[10:25:53.633]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:25:53.633]   ..$ map           :<environment: R_EmptyEnv> 
[10:25:53.633]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:25:53.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.633]  - attr(*, "resolved")= logi FALSE
[10:25:53.633]  - attr(*, "total_size")= num 7704
[10:25:53.633]  - attr(*, "already-done")= logi TRUE
[10:25:53.636] - reassign environment for ‘outer_function’
[10:25:53.636] - copied ‘outer_function’ to environment
[10:25:53.637] - reassign environment for ‘map’
[10:25:53.637] - copied ‘map’ to environment
[10:25:53.637] - reassign environment for ‘inner_function’
[10:25:53.637] - copied ‘inner_function’ to environment
[10:25:53.637] assign_globals() ... done
[10:25:53.637] plan(): Setting new future strategy stack:
[10:25:53.637] List of future strategies:
[10:25:53.637] 1. sequential:
[10:25:53.637]    - args: function (..., envir = parent.frame())
[10:25:53.637]    - tweaked: FALSE
[10:25:53.637]    - call: NULL
[10:25:53.638] plan(): nbrOfWorkers() = 1
[10:25:53.638] plan(): Setting new future strategy stack:
[10:25:53.638] List of future strategies:
[10:25:53.638] 1. sequential:
[10:25:53.638]    - args: function (..., envir = parent.frame())
[10:25:53.638]    - tweaked: FALSE
[10:25:53.638]    - call: plan(strategy)
[10:25:53.639] plan(): nbrOfWorkers() = 1
[10:25:53.639] SequentialFuture started (and completed)
[10:25:53.639] - Launch lazy future ... done
[10:25:53.639] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:25:53.650] plan(): Setting new future strategy stack:
[10:25:53.650] List of future strategies:
[10:25:53.650] 1. multicore:
[10:25:53.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.650]    - tweaked: FALSE
[10:25:53.650]    - call: plan(strategy)
[10:25:53.654] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:25:53.654] getGlobalsAndPackages() ...
[10:25:53.654] Searching for globals...
[10:25:53.656] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.656] Searching for globals ... DONE
[10:25:53.656] Resolving globals: FALSE
[10:25:53.656] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.657] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.657] - globals: [2] ‘weight’, ‘group’
[10:25:53.657] - packages: [1] ‘stats’
[10:25:53.657] getGlobalsAndPackages() ... DONE
[10:25:53.657] run() for ‘Future’ ...
[10:25:53.657] - state: ‘created’
[10:25:53.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.661]   - Field: ‘label’
[10:25:53.661]   - Field: ‘local’
[10:25:53.661]   - Field: ‘owner’
[10:25:53.661]   - Field: ‘envir’
[10:25:53.661]   - Field: ‘workers’
[10:25:53.662]   - Field: ‘packages’
[10:25:53.662]   - Field: ‘gc’
[10:25:53.662]   - Field: ‘job’
[10:25:53.662]   - Field: ‘conditions’
[10:25:53.662]   - Field: ‘expr’
[10:25:53.662]   - Field: ‘uuid’
[10:25:53.662]   - Field: ‘seed’
[10:25:53.662]   - Field: ‘version’
[10:25:53.662]   - Field: ‘result’
[10:25:53.662]   - Field: ‘asynchronous’
[10:25:53.662]   - Field: ‘calls’
[10:25:53.663]   - Field: ‘globals’
[10:25:53.663]   - Field: ‘stdout’
[10:25:53.663]   - Field: ‘earlySignal’
[10:25:53.663]   - Field: ‘lazy’
[10:25:53.663]   - Field: ‘state’
[10:25:53.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.663] - Launch lazy future ...
[10:25:53.664] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.664] Packages needed by future strategies (n = 0): <none>
[10:25:53.665] {
[10:25:53.665]     {
[10:25:53.665]         {
[10:25:53.665]             ...future.startTime <- base::Sys.time()
[10:25:53.665]             {
[10:25:53.665]                 {
[10:25:53.665]                   {
[10:25:53.665]                     {
[10:25:53.665]                       {
[10:25:53.665]                         base::local({
[10:25:53.665]                           has_future <- base::requireNamespace("future", 
[10:25:53.665]                             quietly = TRUE)
[10:25:53.665]                           if (has_future) {
[10:25:53.665]                             ns <- base::getNamespace("future")
[10:25:53.665]                             version <- ns[[".package"]][["version"]]
[10:25:53.665]                             if (is.null(version)) 
[10:25:53.665]                               version <- utils::packageVersion("future")
[10:25:53.665]                           }
[10:25:53.665]                           else {
[10:25:53.665]                             version <- NULL
[10:25:53.665]                           }
[10:25:53.665]                           if (!has_future || version < "1.8.0") {
[10:25:53.665]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.665]                               "", base::R.version$version.string), 
[10:25:53.665]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.665]                                 base::R.version$platform, 8 * 
[10:25:53.665]                                   base::.Machine$sizeof.pointer), 
[10:25:53.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.665]                                 "release", "version")], collapse = " "), 
[10:25:53.665]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.665]                               info)
[10:25:53.665]                             info <- base::paste(info, collapse = "; ")
[10:25:53.665]                             if (!has_future) {
[10:25:53.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.665]                                 info)
[10:25:53.665]                             }
[10:25:53.665]                             else {
[10:25:53.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.665]                                 info, version)
[10:25:53.665]                             }
[10:25:53.665]                             base::stop(msg)
[10:25:53.665]                           }
[10:25:53.665]                         })
[10:25:53.665]                       }
[10:25:53.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.665]                       base::options(mc.cores = 1L)
[10:25:53.665]                     }
[10:25:53.665]                     base::local({
[10:25:53.665]                       for (pkg in "stats") {
[10:25:53.665]                         base::loadNamespace(pkg)
[10:25:53.665]                         base::library(pkg, character.only = TRUE)
[10:25:53.665]                       }
[10:25:53.665]                     })
[10:25:53.665]                   }
[10:25:53.665]                   options(future.plan = NULL)
[10:25:53.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.665]                 }
[10:25:53.665]                 ...future.workdir <- getwd()
[10:25:53.665]             }
[10:25:53.665]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.665]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.665]         }
[10:25:53.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.665]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.665]             base::names(...future.oldOptions))
[10:25:53.665]     }
[10:25:53.665]     if (FALSE) {
[10:25:53.665]     }
[10:25:53.665]     else {
[10:25:53.665]         if (TRUE) {
[10:25:53.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.665]                 open = "w")
[10:25:53.665]         }
[10:25:53.665]         else {
[10:25:53.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.665]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.665]         }
[10:25:53.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.665]             base::sink(type = "output", split = FALSE)
[10:25:53.665]             base::close(...future.stdout)
[10:25:53.665]         }, add = TRUE)
[10:25:53.665]     }
[10:25:53.665]     ...future.frame <- base::sys.nframe()
[10:25:53.665]     ...future.conditions <- base::list()
[10:25:53.665]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.665]     if (FALSE) {
[10:25:53.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.665]     }
[10:25:53.665]     ...future.result <- base::tryCatch({
[10:25:53.665]         base::withCallingHandlers({
[10:25:53.665]             ...future.value <- base::withVisible(base::local({
[10:25:53.665]                 withCallingHandlers({
[10:25:53.665]                   {
[10:25:53.665]                     lm(weight ~ group - 1)
[10:25:53.665]                   }
[10:25:53.665]                 }, immediateCondition = function(cond) {
[10:25:53.665]                   save_rds <- function (object, pathname, ...) 
[10:25:53.665]                   {
[10:25:53.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.665]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.665]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.665]                         fi_tmp[["mtime"]])
[10:25:53.665]                     }
[10:25:53.665]                     tryCatch({
[10:25:53.665]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.665]                     }, error = function(ex) {
[10:25:53.665]                       msg <- conditionMessage(ex)
[10:25:53.665]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.665]                         fi_tmp[["mtime"]], msg)
[10:25:53.665]                       ex$message <- msg
[10:25:53.665]                       stop(ex)
[10:25:53.665]                     })
[10:25:53.665]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.665]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.665]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.665]                       fi <- file.info(pathname)
[10:25:53.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.665]                         fi[["size"]], fi[["mtime"]])
[10:25:53.665]                       stop(msg)
[10:25:53.665]                     }
[10:25:53.665]                     invisible(pathname)
[10:25:53.665]                   }
[10:25:53.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.665]                     rootPath = tempdir()) 
[10:25:53.665]                   {
[10:25:53.665]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.665]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.665]                       tmpdir = path, fileext = ".rds")
[10:25:53.665]                     save_rds(obj, file)
[10:25:53.665]                   }
[10:25:53.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.665]                   {
[10:25:53.665]                     inherits <- base::inherits
[10:25:53.665]                     invokeRestart <- base::invokeRestart
[10:25:53.665]                     is.null <- base::is.null
[10:25:53.665]                     muffled <- FALSE
[10:25:53.665]                     if (inherits(cond, "message")) {
[10:25:53.665]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.665]                       if (muffled) 
[10:25:53.665]                         invokeRestart("muffleMessage")
[10:25:53.665]                     }
[10:25:53.665]                     else if (inherits(cond, "warning")) {
[10:25:53.665]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.665]                       if (muffled) 
[10:25:53.665]                         invokeRestart("muffleWarning")
[10:25:53.665]                     }
[10:25:53.665]                     else if (inherits(cond, "condition")) {
[10:25:53.665]                       if (!is.null(pattern)) {
[10:25:53.665]                         computeRestarts <- base::computeRestarts
[10:25:53.665]                         grepl <- base::grepl
[10:25:53.665]                         restarts <- computeRestarts(cond)
[10:25:53.665]                         for (restart in restarts) {
[10:25:53.665]                           name <- restart$name
[10:25:53.665]                           if (is.null(name)) 
[10:25:53.665]                             next
[10:25:53.665]                           if (!grepl(pattern, name)) 
[10:25:53.665]                             next
[10:25:53.665]                           invokeRestart(restart)
[10:25:53.665]                           muffled <- TRUE
[10:25:53.665]                           break
[10:25:53.665]                         }
[10:25:53.665]                       }
[10:25:53.665]                     }
[10:25:53.665]                     invisible(muffled)
[10:25:53.665]                   }
[10:25:53.665]                   muffleCondition(cond)
[10:25:53.665]                 })
[10:25:53.665]             }))
[10:25:53.665]             future::FutureResult(value = ...future.value$value, 
[10:25:53.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.665]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.665]                     ...future.globalenv.names))
[10:25:53.665]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.665]         }, condition = base::local({
[10:25:53.665]             c <- base::c
[10:25:53.665]             inherits <- base::inherits
[10:25:53.665]             invokeRestart <- base::invokeRestart
[10:25:53.665]             length <- base::length
[10:25:53.665]             list <- base::list
[10:25:53.665]             seq.int <- base::seq.int
[10:25:53.665]             signalCondition <- base::signalCondition
[10:25:53.665]             sys.calls <- base::sys.calls
[10:25:53.665]             `[[` <- base::`[[`
[10:25:53.665]             `+` <- base::`+`
[10:25:53.665]             `<<-` <- base::`<<-`
[10:25:53.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.665]                   3L)]
[10:25:53.665]             }
[10:25:53.665]             function(cond) {
[10:25:53.665]                 is_error <- inherits(cond, "error")
[10:25:53.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.665]                   NULL)
[10:25:53.665]                 if (is_error) {
[10:25:53.665]                   sessionInformation <- function() {
[10:25:53.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.665]                       search = base::search(), system = base::Sys.info())
[10:25:53.665]                   }
[10:25:53.665]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.665]                     cond$call), session = sessionInformation(), 
[10:25:53.665]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.665]                   signalCondition(cond)
[10:25:53.665]                 }
[10:25:53.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.665]                 "immediateCondition"))) {
[10:25:53.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.665]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.665]                   if (TRUE && !signal) {
[10:25:53.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.665]                     {
[10:25:53.665]                       inherits <- base::inherits
[10:25:53.665]                       invokeRestart <- base::invokeRestart
[10:25:53.665]                       is.null <- base::is.null
[10:25:53.665]                       muffled <- FALSE
[10:25:53.665]                       if (inherits(cond, "message")) {
[10:25:53.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.665]                         if (muffled) 
[10:25:53.665]                           invokeRestart("muffleMessage")
[10:25:53.665]                       }
[10:25:53.665]                       else if (inherits(cond, "warning")) {
[10:25:53.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.665]                         if (muffled) 
[10:25:53.665]                           invokeRestart("muffleWarning")
[10:25:53.665]                       }
[10:25:53.665]                       else if (inherits(cond, "condition")) {
[10:25:53.665]                         if (!is.null(pattern)) {
[10:25:53.665]                           computeRestarts <- base::computeRestarts
[10:25:53.665]                           grepl <- base::grepl
[10:25:53.665]                           restarts <- computeRestarts(cond)
[10:25:53.665]                           for (restart in restarts) {
[10:25:53.665]                             name <- restart$name
[10:25:53.665]                             if (is.null(name)) 
[10:25:53.665]                               next
[10:25:53.665]                             if (!grepl(pattern, name)) 
[10:25:53.665]                               next
[10:25:53.665]                             invokeRestart(restart)
[10:25:53.665]                             muffled <- TRUE
[10:25:53.665]                             break
[10:25:53.665]                           }
[10:25:53.665]                         }
[10:25:53.665]                       }
[10:25:53.665]                       invisible(muffled)
[10:25:53.665]                     }
[10:25:53.665]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.665]                   }
[10:25:53.665]                 }
[10:25:53.665]                 else {
[10:25:53.665]                   if (TRUE) {
[10:25:53.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.665]                     {
[10:25:53.665]                       inherits <- base::inherits
[10:25:53.665]                       invokeRestart <- base::invokeRestart
[10:25:53.665]                       is.null <- base::is.null
[10:25:53.665]                       muffled <- FALSE
[10:25:53.665]                       if (inherits(cond, "message")) {
[10:25:53.665]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.665]                         if (muffled) 
[10:25:53.665]                           invokeRestart("muffleMessage")
[10:25:53.665]                       }
[10:25:53.665]                       else if (inherits(cond, "warning")) {
[10:25:53.665]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.665]                         if (muffled) 
[10:25:53.665]                           invokeRestart("muffleWarning")
[10:25:53.665]                       }
[10:25:53.665]                       else if (inherits(cond, "condition")) {
[10:25:53.665]                         if (!is.null(pattern)) {
[10:25:53.665]                           computeRestarts <- base::computeRestarts
[10:25:53.665]                           grepl <- base::grepl
[10:25:53.665]                           restarts <- computeRestarts(cond)
[10:25:53.665]                           for (restart in restarts) {
[10:25:53.665]                             name <- restart$name
[10:25:53.665]                             if (is.null(name)) 
[10:25:53.665]                               next
[10:25:53.665]                             if (!grepl(pattern, name)) 
[10:25:53.665]                               next
[10:25:53.665]                             invokeRestart(restart)
[10:25:53.665]                             muffled <- TRUE
[10:25:53.665]                             break
[10:25:53.665]                           }
[10:25:53.665]                         }
[10:25:53.665]                       }
[10:25:53.665]                       invisible(muffled)
[10:25:53.665]                     }
[10:25:53.665]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.665]                   }
[10:25:53.665]                 }
[10:25:53.665]             }
[10:25:53.665]         }))
[10:25:53.665]     }, error = function(ex) {
[10:25:53.665]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.665]                 ...future.rng), started = ...future.startTime, 
[10:25:53.665]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.665]             version = "1.8"), class = "FutureResult")
[10:25:53.665]     }, finally = {
[10:25:53.665]         if (!identical(...future.workdir, getwd())) 
[10:25:53.665]             setwd(...future.workdir)
[10:25:53.665]         {
[10:25:53.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.665]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.665]             }
[10:25:53.665]             base::options(...future.oldOptions)
[10:25:53.665]             if (.Platform$OS.type == "windows") {
[10:25:53.665]                 old_names <- names(...future.oldEnvVars)
[10:25:53.665]                 envs <- base::Sys.getenv()
[10:25:53.665]                 names <- names(envs)
[10:25:53.665]                 common <- intersect(names, old_names)
[10:25:53.665]                 added <- setdiff(names, old_names)
[10:25:53.665]                 removed <- setdiff(old_names, names)
[10:25:53.665]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.665]                   envs[common]]
[10:25:53.665]                 NAMES <- toupper(changed)
[10:25:53.665]                 args <- list()
[10:25:53.665]                 for (kk in seq_along(NAMES)) {
[10:25:53.665]                   name <- changed[[kk]]
[10:25:53.665]                   NAME <- NAMES[[kk]]
[10:25:53.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.665]                     next
[10:25:53.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.665]                 }
[10:25:53.665]                 NAMES <- toupper(added)
[10:25:53.665]                 for (kk in seq_along(NAMES)) {
[10:25:53.665]                   name <- added[[kk]]
[10:25:53.665]                   NAME <- NAMES[[kk]]
[10:25:53.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.665]                     next
[10:25:53.665]                   args[[name]] <- ""
[10:25:53.665]                 }
[10:25:53.665]                 NAMES <- toupper(removed)
[10:25:53.665]                 for (kk in seq_along(NAMES)) {
[10:25:53.665]                   name <- removed[[kk]]
[10:25:53.665]                   NAME <- NAMES[[kk]]
[10:25:53.665]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.665]                     next
[10:25:53.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.665]                 }
[10:25:53.665]                 if (length(args) > 0) 
[10:25:53.665]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.665]             }
[10:25:53.665]             else {
[10:25:53.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.665]             }
[10:25:53.665]             {
[10:25:53.665]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.665]                   0L) {
[10:25:53.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.665]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.665]                   base::options(opts)
[10:25:53.665]                 }
[10:25:53.665]                 {
[10:25:53.665]                   {
[10:25:53.665]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.665]                     NULL
[10:25:53.665]                   }
[10:25:53.665]                   options(future.plan = NULL)
[10:25:53.665]                   if (is.na(NA_character_)) 
[10:25:53.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.665]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.665]                     envir = parent.frame()) 
[10:25:53.665]                   {
[10:25:53.665]                     default_workers <- missing(workers)
[10:25:53.665]                     if (is.function(workers)) 
[10:25:53.665]                       workers <- workers()
[10:25:53.665]                     workers <- structure(as.integer(workers), 
[10:25:53.665]                       class = class(workers))
[10:25:53.665]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.665]                       1L)
[10:25:53.665]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.665]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.665]                       if (default_workers) 
[10:25:53.665]                         supportsMulticore(warn = TRUE)
[10:25:53.665]                       return(sequential(..., envir = envir))
[10:25:53.665]                     }
[10:25:53.665]                     oopts <- options(mc.cores = workers)
[10:25:53.665]                     on.exit(options(oopts))
[10:25:53.665]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.665]                       envir = envir)
[10:25:53.665]                     if (!future$lazy) 
[10:25:53.665]                       future <- run(future)
[10:25:53.665]                     invisible(future)
[10:25:53.665]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.665]                 }
[10:25:53.665]             }
[10:25:53.665]         }
[10:25:53.665]     })
[10:25:53.665]     if (TRUE) {
[10:25:53.665]         base::sink(type = "output", split = FALSE)
[10:25:53.665]         if (TRUE) {
[10:25:53.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.665]         }
[10:25:53.665]         else {
[10:25:53.665]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.665]         }
[10:25:53.665]         base::close(...future.stdout)
[10:25:53.665]         ...future.stdout <- NULL
[10:25:53.665]     }
[10:25:53.665]     ...future.result$conditions <- ...future.conditions
[10:25:53.665]     ...future.result$finished <- base::Sys.time()
[10:25:53.665]     ...future.result
[10:25:53.665] }
[10:25:53.667] assign_globals() ...
[10:25:53.667] List of 2
[10:25:53.667]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.667]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.667]  - attr(*, "where")=List of 2
[10:25:53.667]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.667]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.667]  - attr(*, "resolved")= logi FALSE
[10:25:53.667]  - attr(*, "total_size")= num 896
[10:25:53.667]  - attr(*, "already-done")= logi TRUE
[10:25:53.670] - copied ‘weight’ to environment
[10:25:53.670] - copied ‘group’ to environment
[10:25:53.670] assign_globals() ... done
[10:25:53.670] requestCore(): workers = 2
[10:25:53.673] MulticoreFuture started
[10:25:53.674] - Launch lazy future ... done
[10:25:53.674] run() for ‘MulticoreFuture’ ... done
[10:25:53.675] plan(): Setting new future strategy stack:
[10:25:53.675] result() for MulticoreFuture ...
[10:25:53.675] List of future strategies:
[10:25:53.675] 1. sequential:
[10:25:53.675]    - args: function (..., envir = parent.frame())
[10:25:53.675]    - tweaked: FALSE
[10:25:53.675]    - call: NULL
[10:25:53.676] plan(): nbrOfWorkers() = 1
[10:25:53.679] plan(): Setting new future strategy stack:
[10:25:53.679] List of future strategies:
[10:25:53.679] 1. multicore:
[10:25:53.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.679]    - tweaked: FALSE
[10:25:53.679]    - call: plan(strategy)
[10:25:53.684] plan(): nbrOfWorkers() = 2
[10:25:53.696] result() for MulticoreFuture ...
[10:25:53.696] result() for MulticoreFuture ... done
[10:25:53.696] result() for MulticoreFuture ... done
[10:25:53.696] result() for MulticoreFuture ...
[10:25:53.696] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.699] getGlobalsAndPackages() ...
[10:25:53.699] Searching for globals...
[10:25:53.701] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.701] Searching for globals ... DONE
[10:25:53.701] Resolving globals: FALSE
[10:25:53.702] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.702] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.702] - globals: [2] ‘weight’, ‘group’
[10:25:53.703] - packages: [1] ‘stats’
[10:25:53.703] getGlobalsAndPackages() ... DONE
[10:25:53.703] run() for ‘Future’ ...
[10:25:53.703] - state: ‘created’
[10:25:53.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.707]   - Field: ‘label’
[10:25:53.708]   - Field: ‘local’
[10:25:53.708]   - Field: ‘owner’
[10:25:53.708]   - Field: ‘envir’
[10:25:53.708]   - Field: ‘workers’
[10:25:53.708]   - Field: ‘packages’
[10:25:53.708]   - Field: ‘gc’
[10:25:53.708]   - Field: ‘job’
[10:25:53.708]   - Field: ‘conditions’
[10:25:53.708]   - Field: ‘expr’
[10:25:53.709]   - Field: ‘uuid’
[10:25:53.709]   - Field: ‘seed’
[10:25:53.709]   - Field: ‘version’
[10:25:53.709]   - Field: ‘result’
[10:25:53.709]   - Field: ‘asynchronous’
[10:25:53.709]   - Field: ‘calls’
[10:25:53.709]   - Field: ‘globals’
[10:25:53.709]   - Field: ‘stdout’
[10:25:53.709]   - Field: ‘earlySignal’
[10:25:53.710]   - Field: ‘lazy’
[10:25:53.710]   - Field: ‘state’
[10:25:53.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.710] - Launch lazy future ...
[10:25:53.710] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.710] Packages needed by future strategies (n = 0): <none>
[10:25:53.711] {
[10:25:53.711]     {
[10:25:53.711]         {
[10:25:53.711]             ...future.startTime <- base::Sys.time()
[10:25:53.711]             {
[10:25:53.711]                 {
[10:25:53.711]                   {
[10:25:53.711]                     {
[10:25:53.711]                       {
[10:25:53.711]                         base::local({
[10:25:53.711]                           has_future <- base::requireNamespace("future", 
[10:25:53.711]                             quietly = TRUE)
[10:25:53.711]                           if (has_future) {
[10:25:53.711]                             ns <- base::getNamespace("future")
[10:25:53.711]                             version <- ns[[".package"]][["version"]]
[10:25:53.711]                             if (is.null(version)) 
[10:25:53.711]                               version <- utils::packageVersion("future")
[10:25:53.711]                           }
[10:25:53.711]                           else {
[10:25:53.711]                             version <- NULL
[10:25:53.711]                           }
[10:25:53.711]                           if (!has_future || version < "1.8.0") {
[10:25:53.711]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.711]                               "", base::R.version$version.string), 
[10:25:53.711]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.711]                                 base::R.version$platform, 8 * 
[10:25:53.711]                                   base::.Machine$sizeof.pointer), 
[10:25:53.711]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.711]                                 "release", "version")], collapse = " "), 
[10:25:53.711]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.711]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.711]                               info)
[10:25:53.711]                             info <- base::paste(info, collapse = "; ")
[10:25:53.711]                             if (!has_future) {
[10:25:53.711]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.711]                                 info)
[10:25:53.711]                             }
[10:25:53.711]                             else {
[10:25:53.711]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.711]                                 info, version)
[10:25:53.711]                             }
[10:25:53.711]                             base::stop(msg)
[10:25:53.711]                           }
[10:25:53.711]                         })
[10:25:53.711]                       }
[10:25:53.711]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.711]                       base::options(mc.cores = 1L)
[10:25:53.711]                     }
[10:25:53.711]                     base::local({
[10:25:53.711]                       for (pkg in "stats") {
[10:25:53.711]                         base::loadNamespace(pkg)
[10:25:53.711]                         base::library(pkg, character.only = TRUE)
[10:25:53.711]                       }
[10:25:53.711]                     })
[10:25:53.711]                   }
[10:25:53.711]                   options(future.plan = NULL)
[10:25:53.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.711]                 }
[10:25:53.711]                 ...future.workdir <- getwd()
[10:25:53.711]             }
[10:25:53.711]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.711]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.711]         }
[10:25:53.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.711]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.711]             base::names(...future.oldOptions))
[10:25:53.711]     }
[10:25:53.711]     if (FALSE) {
[10:25:53.711]     }
[10:25:53.711]     else {
[10:25:53.711]         if (TRUE) {
[10:25:53.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.711]                 open = "w")
[10:25:53.711]         }
[10:25:53.711]         else {
[10:25:53.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.711]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.711]         }
[10:25:53.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.711]             base::sink(type = "output", split = FALSE)
[10:25:53.711]             base::close(...future.stdout)
[10:25:53.711]         }, add = TRUE)
[10:25:53.711]     }
[10:25:53.711]     ...future.frame <- base::sys.nframe()
[10:25:53.711]     ...future.conditions <- base::list()
[10:25:53.711]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.711]     if (FALSE) {
[10:25:53.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.711]     }
[10:25:53.711]     ...future.result <- base::tryCatch({
[10:25:53.711]         base::withCallingHandlers({
[10:25:53.711]             ...future.value <- base::withVisible(base::local({
[10:25:53.711]                 withCallingHandlers({
[10:25:53.711]                   {
[10:25:53.711]                     lm(weight ~ group - 1)
[10:25:53.711]                   }
[10:25:53.711]                 }, immediateCondition = function(cond) {
[10:25:53.711]                   save_rds <- function (object, pathname, ...) 
[10:25:53.711]                   {
[10:25:53.711]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.711]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.711]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.711]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.711]                         fi_tmp[["mtime"]])
[10:25:53.711]                     }
[10:25:53.711]                     tryCatch({
[10:25:53.711]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.711]                     }, error = function(ex) {
[10:25:53.711]                       msg <- conditionMessage(ex)
[10:25:53.711]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.711]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.711]                         fi_tmp[["mtime"]], msg)
[10:25:53.711]                       ex$message <- msg
[10:25:53.711]                       stop(ex)
[10:25:53.711]                     })
[10:25:53.711]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.711]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.711]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.711]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.711]                       fi <- file.info(pathname)
[10:25:53.711]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.711]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.711]                         fi[["size"]], fi[["mtime"]])
[10:25:53.711]                       stop(msg)
[10:25:53.711]                     }
[10:25:53.711]                     invisible(pathname)
[10:25:53.711]                   }
[10:25:53.711]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.711]                     rootPath = tempdir()) 
[10:25:53.711]                   {
[10:25:53.711]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.711]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.711]                       tmpdir = path, fileext = ".rds")
[10:25:53.711]                     save_rds(obj, file)
[10:25:53.711]                   }
[10:25:53.711]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.711]                   {
[10:25:53.711]                     inherits <- base::inherits
[10:25:53.711]                     invokeRestart <- base::invokeRestart
[10:25:53.711]                     is.null <- base::is.null
[10:25:53.711]                     muffled <- FALSE
[10:25:53.711]                     if (inherits(cond, "message")) {
[10:25:53.711]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.711]                       if (muffled) 
[10:25:53.711]                         invokeRestart("muffleMessage")
[10:25:53.711]                     }
[10:25:53.711]                     else if (inherits(cond, "warning")) {
[10:25:53.711]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.711]                       if (muffled) 
[10:25:53.711]                         invokeRestart("muffleWarning")
[10:25:53.711]                     }
[10:25:53.711]                     else if (inherits(cond, "condition")) {
[10:25:53.711]                       if (!is.null(pattern)) {
[10:25:53.711]                         computeRestarts <- base::computeRestarts
[10:25:53.711]                         grepl <- base::grepl
[10:25:53.711]                         restarts <- computeRestarts(cond)
[10:25:53.711]                         for (restart in restarts) {
[10:25:53.711]                           name <- restart$name
[10:25:53.711]                           if (is.null(name)) 
[10:25:53.711]                             next
[10:25:53.711]                           if (!grepl(pattern, name)) 
[10:25:53.711]                             next
[10:25:53.711]                           invokeRestart(restart)
[10:25:53.711]                           muffled <- TRUE
[10:25:53.711]                           break
[10:25:53.711]                         }
[10:25:53.711]                       }
[10:25:53.711]                     }
[10:25:53.711]                     invisible(muffled)
[10:25:53.711]                   }
[10:25:53.711]                   muffleCondition(cond)
[10:25:53.711]                 })
[10:25:53.711]             }))
[10:25:53.711]             future::FutureResult(value = ...future.value$value, 
[10:25:53.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.711]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.711]                     ...future.globalenv.names))
[10:25:53.711]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.711]         }, condition = base::local({
[10:25:53.711]             c <- base::c
[10:25:53.711]             inherits <- base::inherits
[10:25:53.711]             invokeRestart <- base::invokeRestart
[10:25:53.711]             length <- base::length
[10:25:53.711]             list <- base::list
[10:25:53.711]             seq.int <- base::seq.int
[10:25:53.711]             signalCondition <- base::signalCondition
[10:25:53.711]             sys.calls <- base::sys.calls
[10:25:53.711]             `[[` <- base::`[[`
[10:25:53.711]             `+` <- base::`+`
[10:25:53.711]             `<<-` <- base::`<<-`
[10:25:53.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.711]                   3L)]
[10:25:53.711]             }
[10:25:53.711]             function(cond) {
[10:25:53.711]                 is_error <- inherits(cond, "error")
[10:25:53.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.711]                   NULL)
[10:25:53.711]                 if (is_error) {
[10:25:53.711]                   sessionInformation <- function() {
[10:25:53.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.711]                       search = base::search(), system = base::Sys.info())
[10:25:53.711]                   }
[10:25:53.711]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.711]                     cond$call), session = sessionInformation(), 
[10:25:53.711]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.711]                   signalCondition(cond)
[10:25:53.711]                 }
[10:25:53.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.711]                 "immediateCondition"))) {
[10:25:53.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.711]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.711]                   if (TRUE && !signal) {
[10:25:53.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.711]                     {
[10:25:53.711]                       inherits <- base::inherits
[10:25:53.711]                       invokeRestart <- base::invokeRestart
[10:25:53.711]                       is.null <- base::is.null
[10:25:53.711]                       muffled <- FALSE
[10:25:53.711]                       if (inherits(cond, "message")) {
[10:25:53.711]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.711]                         if (muffled) 
[10:25:53.711]                           invokeRestart("muffleMessage")
[10:25:53.711]                       }
[10:25:53.711]                       else if (inherits(cond, "warning")) {
[10:25:53.711]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.711]                         if (muffled) 
[10:25:53.711]                           invokeRestart("muffleWarning")
[10:25:53.711]                       }
[10:25:53.711]                       else if (inherits(cond, "condition")) {
[10:25:53.711]                         if (!is.null(pattern)) {
[10:25:53.711]                           computeRestarts <- base::computeRestarts
[10:25:53.711]                           grepl <- base::grepl
[10:25:53.711]                           restarts <- computeRestarts(cond)
[10:25:53.711]                           for (restart in restarts) {
[10:25:53.711]                             name <- restart$name
[10:25:53.711]                             if (is.null(name)) 
[10:25:53.711]                               next
[10:25:53.711]                             if (!grepl(pattern, name)) 
[10:25:53.711]                               next
[10:25:53.711]                             invokeRestart(restart)
[10:25:53.711]                             muffled <- TRUE
[10:25:53.711]                             break
[10:25:53.711]                           }
[10:25:53.711]                         }
[10:25:53.711]                       }
[10:25:53.711]                       invisible(muffled)
[10:25:53.711]                     }
[10:25:53.711]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.711]                   }
[10:25:53.711]                 }
[10:25:53.711]                 else {
[10:25:53.711]                   if (TRUE) {
[10:25:53.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.711]                     {
[10:25:53.711]                       inherits <- base::inherits
[10:25:53.711]                       invokeRestart <- base::invokeRestart
[10:25:53.711]                       is.null <- base::is.null
[10:25:53.711]                       muffled <- FALSE
[10:25:53.711]                       if (inherits(cond, "message")) {
[10:25:53.711]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.711]                         if (muffled) 
[10:25:53.711]                           invokeRestart("muffleMessage")
[10:25:53.711]                       }
[10:25:53.711]                       else if (inherits(cond, "warning")) {
[10:25:53.711]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.711]                         if (muffled) 
[10:25:53.711]                           invokeRestart("muffleWarning")
[10:25:53.711]                       }
[10:25:53.711]                       else if (inherits(cond, "condition")) {
[10:25:53.711]                         if (!is.null(pattern)) {
[10:25:53.711]                           computeRestarts <- base::computeRestarts
[10:25:53.711]                           grepl <- base::grepl
[10:25:53.711]                           restarts <- computeRestarts(cond)
[10:25:53.711]                           for (restart in restarts) {
[10:25:53.711]                             name <- restart$name
[10:25:53.711]                             if (is.null(name)) 
[10:25:53.711]                               next
[10:25:53.711]                             if (!grepl(pattern, name)) 
[10:25:53.711]                               next
[10:25:53.711]                             invokeRestart(restart)
[10:25:53.711]                             muffled <- TRUE
[10:25:53.711]                             break
[10:25:53.711]                           }
[10:25:53.711]                         }
[10:25:53.711]                       }
[10:25:53.711]                       invisible(muffled)
[10:25:53.711]                     }
[10:25:53.711]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.711]                   }
[10:25:53.711]                 }
[10:25:53.711]             }
[10:25:53.711]         }))
[10:25:53.711]     }, error = function(ex) {
[10:25:53.711]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.711]                 ...future.rng), started = ...future.startTime, 
[10:25:53.711]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.711]             version = "1.8"), class = "FutureResult")
[10:25:53.711]     }, finally = {
[10:25:53.711]         if (!identical(...future.workdir, getwd())) 
[10:25:53.711]             setwd(...future.workdir)
[10:25:53.711]         {
[10:25:53.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.711]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.711]             }
[10:25:53.711]             base::options(...future.oldOptions)
[10:25:53.711]             if (.Platform$OS.type == "windows") {
[10:25:53.711]                 old_names <- names(...future.oldEnvVars)
[10:25:53.711]                 envs <- base::Sys.getenv()
[10:25:53.711]                 names <- names(envs)
[10:25:53.711]                 common <- intersect(names, old_names)
[10:25:53.711]                 added <- setdiff(names, old_names)
[10:25:53.711]                 removed <- setdiff(old_names, names)
[10:25:53.711]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.711]                   envs[common]]
[10:25:53.711]                 NAMES <- toupper(changed)
[10:25:53.711]                 args <- list()
[10:25:53.711]                 for (kk in seq_along(NAMES)) {
[10:25:53.711]                   name <- changed[[kk]]
[10:25:53.711]                   NAME <- NAMES[[kk]]
[10:25:53.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.711]                     next
[10:25:53.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.711]                 }
[10:25:53.711]                 NAMES <- toupper(added)
[10:25:53.711]                 for (kk in seq_along(NAMES)) {
[10:25:53.711]                   name <- added[[kk]]
[10:25:53.711]                   NAME <- NAMES[[kk]]
[10:25:53.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.711]                     next
[10:25:53.711]                   args[[name]] <- ""
[10:25:53.711]                 }
[10:25:53.711]                 NAMES <- toupper(removed)
[10:25:53.711]                 for (kk in seq_along(NAMES)) {
[10:25:53.711]                   name <- removed[[kk]]
[10:25:53.711]                   NAME <- NAMES[[kk]]
[10:25:53.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.711]                     next
[10:25:53.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.711]                 }
[10:25:53.711]                 if (length(args) > 0) 
[10:25:53.711]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.711]             }
[10:25:53.711]             else {
[10:25:53.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.711]             }
[10:25:53.711]             {
[10:25:53.711]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.711]                   0L) {
[10:25:53.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.711]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.711]                   base::options(opts)
[10:25:53.711]                 }
[10:25:53.711]                 {
[10:25:53.711]                   {
[10:25:53.711]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.711]                     NULL
[10:25:53.711]                   }
[10:25:53.711]                   options(future.plan = NULL)
[10:25:53.711]                   if (is.na(NA_character_)) 
[10:25:53.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.711]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.711]                     envir = parent.frame()) 
[10:25:53.711]                   {
[10:25:53.711]                     default_workers <- missing(workers)
[10:25:53.711]                     if (is.function(workers)) 
[10:25:53.711]                       workers <- workers()
[10:25:53.711]                     workers <- structure(as.integer(workers), 
[10:25:53.711]                       class = class(workers))
[10:25:53.711]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.711]                       1L)
[10:25:53.711]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.711]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.711]                       if (default_workers) 
[10:25:53.711]                         supportsMulticore(warn = TRUE)
[10:25:53.711]                       return(sequential(..., envir = envir))
[10:25:53.711]                     }
[10:25:53.711]                     oopts <- options(mc.cores = workers)
[10:25:53.711]                     on.exit(options(oopts))
[10:25:53.711]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.711]                       envir = envir)
[10:25:53.711]                     if (!future$lazy) 
[10:25:53.711]                       future <- run(future)
[10:25:53.711]                     invisible(future)
[10:25:53.711]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.711]                 }
[10:25:53.711]             }
[10:25:53.711]         }
[10:25:53.711]     })
[10:25:53.711]     if (TRUE) {
[10:25:53.711]         base::sink(type = "output", split = FALSE)
[10:25:53.711]         if (TRUE) {
[10:25:53.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.711]         }
[10:25:53.711]         else {
[10:25:53.711]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.711]         }
[10:25:53.711]         base::close(...future.stdout)
[10:25:53.711]         ...future.stdout <- NULL
[10:25:53.711]     }
[10:25:53.711]     ...future.result$conditions <- ...future.conditions
[10:25:53.711]     ...future.result$finished <- base::Sys.time()
[10:25:53.711]     ...future.result
[10:25:53.711] }
[10:25:53.713] assign_globals() ...
[10:25:53.713] List of 2
[10:25:53.713]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.713]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.713]  - attr(*, "where")=List of 2
[10:25:53.713]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.713]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.713]  - attr(*, "resolved")= logi FALSE
[10:25:53.713]  - attr(*, "total_size")= num 896
[10:25:53.713]  - attr(*, "already-done")= logi TRUE
[10:25:53.717] - copied ‘weight’ to environment
[10:25:53.717] - copied ‘group’ to environment
[10:25:53.717] assign_globals() ... done
[10:25:53.717] requestCore(): workers = 2
[10:25:53.719] MulticoreFuture started
[10:25:53.720] - Launch lazy future ... done
[10:25:53.720] run() for ‘MulticoreFuture’ ... done
[10:25:53.720] result() for MulticoreFuture ...
[10:25:53.721] plan(): Setting new future strategy stack:
[10:25:53.721] List of future strategies:
[10:25:53.721] 1. sequential:
[10:25:53.721]    - args: function (..., envir = parent.frame())
[10:25:53.721]    - tweaked: FALSE
[10:25:53.721]    - call: NULL
[10:25:53.722] plan(): nbrOfWorkers() = 1
[10:25:53.725] plan(): Setting new future strategy stack:
[10:25:53.726] List of future strategies:
[10:25:53.726] 1. multicore:
[10:25:53.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.726]    - tweaked: FALSE
[10:25:53.726]    - call: plan(strategy)
[10:25:53.730] plan(): nbrOfWorkers() = 2
[10:25:53.732] result() for MulticoreFuture ...
[10:25:53.733] result() for MulticoreFuture ... done
[10:25:53.733] result() for MulticoreFuture ... done
[10:25:53.733] result() for MulticoreFuture ...
[10:25:53.733] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.736] getGlobalsAndPackages() ...
[10:25:53.736] Searching for globals...
[10:25:53.740] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.741] Searching for globals ... DONE
[10:25:53.741] Resolving globals: FALSE
[10:25:53.742] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.742] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.742] - globals: [2] ‘weight’, ‘group’
[10:25:53.743] - packages: [1] ‘stats’
[10:25:53.743] getGlobalsAndPackages() ... DONE
[10:25:53.743] run() for ‘Future’ ...
[10:25:53.743] - state: ‘created’
[10:25:53.743] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.747] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.748]   - Field: ‘label’
[10:25:53.748]   - Field: ‘local’
[10:25:53.748]   - Field: ‘owner’
[10:25:53.748]   - Field: ‘envir’
[10:25:53.748]   - Field: ‘workers’
[10:25:53.748]   - Field: ‘packages’
[10:25:53.748]   - Field: ‘gc’
[10:25:53.749]   - Field: ‘job’
[10:25:53.749]   - Field: ‘conditions’
[10:25:53.749]   - Field: ‘expr’
[10:25:53.749]   - Field: ‘uuid’
[10:25:53.749]   - Field: ‘seed’
[10:25:53.749]   - Field: ‘version’
[10:25:53.749]   - Field: ‘result’
[10:25:53.749]   - Field: ‘asynchronous’
[10:25:53.749]   - Field: ‘calls’
[10:25:53.750]   - Field: ‘globals’
[10:25:53.750]   - Field: ‘stdout’
[10:25:53.750]   - Field: ‘earlySignal’
[10:25:53.750]   - Field: ‘lazy’
[10:25:53.750]   - Field: ‘state’
[10:25:53.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.750] - Launch lazy future ...
[10:25:53.751] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.751] Packages needed by future strategies (n = 0): <none>
[10:25:53.751] {
[10:25:53.751]     {
[10:25:53.751]         {
[10:25:53.751]             ...future.startTime <- base::Sys.time()
[10:25:53.751]             {
[10:25:53.751]                 {
[10:25:53.751]                   {
[10:25:53.751]                     {
[10:25:53.751]                       {
[10:25:53.751]                         base::local({
[10:25:53.751]                           has_future <- base::requireNamespace("future", 
[10:25:53.751]                             quietly = TRUE)
[10:25:53.751]                           if (has_future) {
[10:25:53.751]                             ns <- base::getNamespace("future")
[10:25:53.751]                             version <- ns[[".package"]][["version"]]
[10:25:53.751]                             if (is.null(version)) 
[10:25:53.751]                               version <- utils::packageVersion("future")
[10:25:53.751]                           }
[10:25:53.751]                           else {
[10:25:53.751]                             version <- NULL
[10:25:53.751]                           }
[10:25:53.751]                           if (!has_future || version < "1.8.0") {
[10:25:53.751]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.751]                               "", base::R.version$version.string), 
[10:25:53.751]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.751]                                 base::R.version$platform, 8 * 
[10:25:53.751]                                   base::.Machine$sizeof.pointer), 
[10:25:53.751]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.751]                                 "release", "version")], collapse = " "), 
[10:25:53.751]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.751]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.751]                               info)
[10:25:53.751]                             info <- base::paste(info, collapse = "; ")
[10:25:53.751]                             if (!has_future) {
[10:25:53.751]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.751]                                 info)
[10:25:53.751]                             }
[10:25:53.751]                             else {
[10:25:53.751]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.751]                                 info, version)
[10:25:53.751]                             }
[10:25:53.751]                             base::stop(msg)
[10:25:53.751]                           }
[10:25:53.751]                         })
[10:25:53.751]                       }
[10:25:53.751]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.751]                       base::options(mc.cores = 1L)
[10:25:53.751]                     }
[10:25:53.751]                     base::local({
[10:25:53.751]                       for (pkg in "stats") {
[10:25:53.751]                         base::loadNamespace(pkg)
[10:25:53.751]                         base::library(pkg, character.only = TRUE)
[10:25:53.751]                       }
[10:25:53.751]                     })
[10:25:53.751]                   }
[10:25:53.751]                   options(future.plan = NULL)
[10:25:53.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.751]                 }
[10:25:53.751]                 ...future.workdir <- getwd()
[10:25:53.751]             }
[10:25:53.751]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.751]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.751]         }
[10:25:53.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.751]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.751]             base::names(...future.oldOptions))
[10:25:53.751]     }
[10:25:53.751]     if (FALSE) {
[10:25:53.751]     }
[10:25:53.751]     else {
[10:25:53.751]         if (TRUE) {
[10:25:53.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.751]                 open = "w")
[10:25:53.751]         }
[10:25:53.751]         else {
[10:25:53.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.751]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.751]         }
[10:25:53.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.751]             base::sink(type = "output", split = FALSE)
[10:25:53.751]             base::close(...future.stdout)
[10:25:53.751]         }, add = TRUE)
[10:25:53.751]     }
[10:25:53.751]     ...future.frame <- base::sys.nframe()
[10:25:53.751]     ...future.conditions <- base::list()
[10:25:53.751]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.751]     if (FALSE) {
[10:25:53.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.751]     }
[10:25:53.751]     ...future.result <- base::tryCatch({
[10:25:53.751]         base::withCallingHandlers({
[10:25:53.751]             ...future.value <- base::withVisible(base::local({
[10:25:53.751]                 withCallingHandlers({
[10:25:53.751]                   {
[10:25:53.751]                     lm(weight ~ group - 1)
[10:25:53.751]                   }
[10:25:53.751]                 }, immediateCondition = function(cond) {
[10:25:53.751]                   save_rds <- function (object, pathname, ...) 
[10:25:53.751]                   {
[10:25:53.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.751]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.751]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.751]                         fi_tmp[["mtime"]])
[10:25:53.751]                     }
[10:25:53.751]                     tryCatch({
[10:25:53.751]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.751]                     }, error = function(ex) {
[10:25:53.751]                       msg <- conditionMessage(ex)
[10:25:53.751]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.751]                         fi_tmp[["mtime"]], msg)
[10:25:53.751]                       ex$message <- msg
[10:25:53.751]                       stop(ex)
[10:25:53.751]                     })
[10:25:53.751]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.751]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.751]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.751]                       fi <- file.info(pathname)
[10:25:53.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.751]                         fi[["size"]], fi[["mtime"]])
[10:25:53.751]                       stop(msg)
[10:25:53.751]                     }
[10:25:53.751]                     invisible(pathname)
[10:25:53.751]                   }
[10:25:53.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.751]                     rootPath = tempdir()) 
[10:25:53.751]                   {
[10:25:53.751]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.751]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.751]                       tmpdir = path, fileext = ".rds")
[10:25:53.751]                     save_rds(obj, file)
[10:25:53.751]                   }
[10:25:53.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.751]                   {
[10:25:53.751]                     inherits <- base::inherits
[10:25:53.751]                     invokeRestart <- base::invokeRestart
[10:25:53.751]                     is.null <- base::is.null
[10:25:53.751]                     muffled <- FALSE
[10:25:53.751]                     if (inherits(cond, "message")) {
[10:25:53.751]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.751]                       if (muffled) 
[10:25:53.751]                         invokeRestart("muffleMessage")
[10:25:53.751]                     }
[10:25:53.751]                     else if (inherits(cond, "warning")) {
[10:25:53.751]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.751]                       if (muffled) 
[10:25:53.751]                         invokeRestart("muffleWarning")
[10:25:53.751]                     }
[10:25:53.751]                     else if (inherits(cond, "condition")) {
[10:25:53.751]                       if (!is.null(pattern)) {
[10:25:53.751]                         computeRestarts <- base::computeRestarts
[10:25:53.751]                         grepl <- base::grepl
[10:25:53.751]                         restarts <- computeRestarts(cond)
[10:25:53.751]                         for (restart in restarts) {
[10:25:53.751]                           name <- restart$name
[10:25:53.751]                           if (is.null(name)) 
[10:25:53.751]                             next
[10:25:53.751]                           if (!grepl(pattern, name)) 
[10:25:53.751]                             next
[10:25:53.751]                           invokeRestart(restart)
[10:25:53.751]                           muffled <- TRUE
[10:25:53.751]                           break
[10:25:53.751]                         }
[10:25:53.751]                       }
[10:25:53.751]                     }
[10:25:53.751]                     invisible(muffled)
[10:25:53.751]                   }
[10:25:53.751]                   muffleCondition(cond)
[10:25:53.751]                 })
[10:25:53.751]             }))
[10:25:53.751]             future::FutureResult(value = ...future.value$value, 
[10:25:53.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.751]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.751]                     ...future.globalenv.names))
[10:25:53.751]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.751]         }, condition = base::local({
[10:25:53.751]             c <- base::c
[10:25:53.751]             inherits <- base::inherits
[10:25:53.751]             invokeRestart <- base::invokeRestart
[10:25:53.751]             length <- base::length
[10:25:53.751]             list <- base::list
[10:25:53.751]             seq.int <- base::seq.int
[10:25:53.751]             signalCondition <- base::signalCondition
[10:25:53.751]             sys.calls <- base::sys.calls
[10:25:53.751]             `[[` <- base::`[[`
[10:25:53.751]             `+` <- base::`+`
[10:25:53.751]             `<<-` <- base::`<<-`
[10:25:53.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.751]                   3L)]
[10:25:53.751]             }
[10:25:53.751]             function(cond) {
[10:25:53.751]                 is_error <- inherits(cond, "error")
[10:25:53.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.751]                   NULL)
[10:25:53.751]                 if (is_error) {
[10:25:53.751]                   sessionInformation <- function() {
[10:25:53.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.751]                       search = base::search(), system = base::Sys.info())
[10:25:53.751]                   }
[10:25:53.751]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.751]                     cond$call), session = sessionInformation(), 
[10:25:53.751]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.751]                   signalCondition(cond)
[10:25:53.751]                 }
[10:25:53.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.751]                 "immediateCondition"))) {
[10:25:53.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.751]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.751]                   if (TRUE && !signal) {
[10:25:53.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.751]                     {
[10:25:53.751]                       inherits <- base::inherits
[10:25:53.751]                       invokeRestart <- base::invokeRestart
[10:25:53.751]                       is.null <- base::is.null
[10:25:53.751]                       muffled <- FALSE
[10:25:53.751]                       if (inherits(cond, "message")) {
[10:25:53.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.751]                         if (muffled) 
[10:25:53.751]                           invokeRestart("muffleMessage")
[10:25:53.751]                       }
[10:25:53.751]                       else if (inherits(cond, "warning")) {
[10:25:53.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.751]                         if (muffled) 
[10:25:53.751]                           invokeRestart("muffleWarning")
[10:25:53.751]                       }
[10:25:53.751]                       else if (inherits(cond, "condition")) {
[10:25:53.751]                         if (!is.null(pattern)) {
[10:25:53.751]                           computeRestarts <- base::computeRestarts
[10:25:53.751]                           grepl <- base::grepl
[10:25:53.751]                           restarts <- computeRestarts(cond)
[10:25:53.751]                           for (restart in restarts) {
[10:25:53.751]                             name <- restart$name
[10:25:53.751]                             if (is.null(name)) 
[10:25:53.751]                               next
[10:25:53.751]                             if (!grepl(pattern, name)) 
[10:25:53.751]                               next
[10:25:53.751]                             invokeRestart(restart)
[10:25:53.751]                             muffled <- TRUE
[10:25:53.751]                             break
[10:25:53.751]                           }
[10:25:53.751]                         }
[10:25:53.751]                       }
[10:25:53.751]                       invisible(muffled)
[10:25:53.751]                     }
[10:25:53.751]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.751]                   }
[10:25:53.751]                 }
[10:25:53.751]                 else {
[10:25:53.751]                   if (TRUE) {
[10:25:53.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.751]                     {
[10:25:53.751]                       inherits <- base::inherits
[10:25:53.751]                       invokeRestart <- base::invokeRestart
[10:25:53.751]                       is.null <- base::is.null
[10:25:53.751]                       muffled <- FALSE
[10:25:53.751]                       if (inherits(cond, "message")) {
[10:25:53.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.751]                         if (muffled) 
[10:25:53.751]                           invokeRestart("muffleMessage")
[10:25:53.751]                       }
[10:25:53.751]                       else if (inherits(cond, "warning")) {
[10:25:53.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.751]                         if (muffled) 
[10:25:53.751]                           invokeRestart("muffleWarning")
[10:25:53.751]                       }
[10:25:53.751]                       else if (inherits(cond, "condition")) {
[10:25:53.751]                         if (!is.null(pattern)) {
[10:25:53.751]                           computeRestarts <- base::computeRestarts
[10:25:53.751]                           grepl <- base::grepl
[10:25:53.751]                           restarts <- computeRestarts(cond)
[10:25:53.751]                           for (restart in restarts) {
[10:25:53.751]                             name <- restart$name
[10:25:53.751]                             if (is.null(name)) 
[10:25:53.751]                               next
[10:25:53.751]                             if (!grepl(pattern, name)) 
[10:25:53.751]                               next
[10:25:53.751]                             invokeRestart(restart)
[10:25:53.751]                             muffled <- TRUE
[10:25:53.751]                             break
[10:25:53.751]                           }
[10:25:53.751]                         }
[10:25:53.751]                       }
[10:25:53.751]                       invisible(muffled)
[10:25:53.751]                     }
[10:25:53.751]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.751]                   }
[10:25:53.751]                 }
[10:25:53.751]             }
[10:25:53.751]         }))
[10:25:53.751]     }, error = function(ex) {
[10:25:53.751]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.751]                 ...future.rng), started = ...future.startTime, 
[10:25:53.751]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.751]             version = "1.8"), class = "FutureResult")
[10:25:53.751]     }, finally = {
[10:25:53.751]         if (!identical(...future.workdir, getwd())) 
[10:25:53.751]             setwd(...future.workdir)
[10:25:53.751]         {
[10:25:53.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.751]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.751]             }
[10:25:53.751]             base::options(...future.oldOptions)
[10:25:53.751]             if (.Platform$OS.type == "windows") {
[10:25:53.751]                 old_names <- names(...future.oldEnvVars)
[10:25:53.751]                 envs <- base::Sys.getenv()
[10:25:53.751]                 names <- names(envs)
[10:25:53.751]                 common <- intersect(names, old_names)
[10:25:53.751]                 added <- setdiff(names, old_names)
[10:25:53.751]                 removed <- setdiff(old_names, names)
[10:25:53.751]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.751]                   envs[common]]
[10:25:53.751]                 NAMES <- toupper(changed)
[10:25:53.751]                 args <- list()
[10:25:53.751]                 for (kk in seq_along(NAMES)) {
[10:25:53.751]                   name <- changed[[kk]]
[10:25:53.751]                   NAME <- NAMES[[kk]]
[10:25:53.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.751]                     next
[10:25:53.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.751]                 }
[10:25:53.751]                 NAMES <- toupper(added)
[10:25:53.751]                 for (kk in seq_along(NAMES)) {
[10:25:53.751]                   name <- added[[kk]]
[10:25:53.751]                   NAME <- NAMES[[kk]]
[10:25:53.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.751]                     next
[10:25:53.751]                   args[[name]] <- ""
[10:25:53.751]                 }
[10:25:53.751]                 NAMES <- toupper(removed)
[10:25:53.751]                 for (kk in seq_along(NAMES)) {
[10:25:53.751]                   name <- removed[[kk]]
[10:25:53.751]                   NAME <- NAMES[[kk]]
[10:25:53.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.751]                     next
[10:25:53.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.751]                 }
[10:25:53.751]                 if (length(args) > 0) 
[10:25:53.751]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.751]             }
[10:25:53.751]             else {
[10:25:53.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.751]             }
[10:25:53.751]             {
[10:25:53.751]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.751]                   0L) {
[10:25:53.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.751]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.751]                   base::options(opts)
[10:25:53.751]                 }
[10:25:53.751]                 {
[10:25:53.751]                   {
[10:25:53.751]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.751]                     NULL
[10:25:53.751]                   }
[10:25:53.751]                   options(future.plan = NULL)
[10:25:53.751]                   if (is.na(NA_character_)) 
[10:25:53.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.751]                     envir = parent.frame()) 
[10:25:53.751]                   {
[10:25:53.751]                     default_workers <- missing(workers)
[10:25:53.751]                     if (is.function(workers)) 
[10:25:53.751]                       workers <- workers()
[10:25:53.751]                     workers <- structure(as.integer(workers), 
[10:25:53.751]                       class = class(workers))
[10:25:53.751]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.751]                       1L)
[10:25:53.751]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.751]                       if (default_workers) 
[10:25:53.751]                         supportsMulticore(warn = TRUE)
[10:25:53.751]                       return(sequential(..., envir = envir))
[10:25:53.751]                     }
[10:25:53.751]                     oopts <- options(mc.cores = workers)
[10:25:53.751]                     on.exit(options(oopts))
[10:25:53.751]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.751]                       envir = envir)
[10:25:53.751]                     if (!future$lazy) 
[10:25:53.751]                       future <- run(future)
[10:25:53.751]                     invisible(future)
[10:25:53.751]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.751]                 }
[10:25:53.751]             }
[10:25:53.751]         }
[10:25:53.751]     })
[10:25:53.751]     if (TRUE) {
[10:25:53.751]         base::sink(type = "output", split = FALSE)
[10:25:53.751]         if (TRUE) {
[10:25:53.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.751]         }
[10:25:53.751]         else {
[10:25:53.751]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.751]         }
[10:25:53.751]         base::close(...future.stdout)
[10:25:53.751]         ...future.stdout <- NULL
[10:25:53.751]     }
[10:25:53.751]     ...future.result$conditions <- ...future.conditions
[10:25:53.751]     ...future.result$finished <- base::Sys.time()
[10:25:53.751]     ...future.result
[10:25:53.751] }
[10:25:53.754] assign_globals() ...
[10:25:53.754] List of 2
[10:25:53.754]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.754]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.754]  - attr(*, "where")=List of 2
[10:25:53.754]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.754]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.754]  - attr(*, "resolved")= logi FALSE
[10:25:53.754]  - attr(*, "total_size")= num 896
[10:25:53.754]  - attr(*, "already-done")= logi TRUE
[10:25:53.758] - copied ‘weight’ to environment
[10:25:53.758] - copied ‘group’ to environment
[10:25:53.758] assign_globals() ... done
[10:25:53.758] requestCore(): workers = 2
[10:25:53.760] MulticoreFuture started
[10:25:53.760] - Launch lazy future ... done
[10:25:53.760] run() for ‘MulticoreFuture’ ... done
[10:25:53.761] result() for MulticoreFuture ...
[10:25:53.761] plan(): Setting new future strategy stack:
[10:25:53.762] List of future strategies:
[10:25:53.762] 1. sequential:
[10:25:53.762]    - args: function (..., envir = parent.frame())
[10:25:53.762]    - tweaked: FALSE
[10:25:53.762]    - call: NULL
[10:25:53.762] plan(): nbrOfWorkers() = 1
[10:25:53.766] plan(): Setting new future strategy stack:
[10:25:53.766] List of future strategies:
[10:25:53.766] 1. multicore:
[10:25:53.766]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.766]    - tweaked: FALSE
[10:25:53.766]    - call: plan(strategy)
[10:25:53.771] plan(): nbrOfWorkers() = 2
[10:25:53.773] result() for MulticoreFuture ...
[10:25:53.773] result() for MulticoreFuture ... done
[10:25:53.773] result() for MulticoreFuture ... done
[10:25:53.774] result() for MulticoreFuture ...
[10:25:53.774] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.776] getGlobalsAndPackages() ...
[10:25:53.776] Searching for globals...
[10:25:53.778] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.779] Searching for globals ... DONE
[10:25:53.779] Resolving globals: FALSE
[10:25:53.779] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.780] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.780] - globals: [2] ‘weight’, ‘group’
[10:25:53.780] - packages: [1] ‘stats’
[10:25:53.780] getGlobalsAndPackages() ... DONE
[10:25:53.781] run() for ‘Future’ ...
[10:25:53.781] - state: ‘created’
[10:25:53.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.788]   - Field: ‘label’
[10:25:53.788]   - Field: ‘local’
[10:25:53.789]   - Field: ‘owner’
[10:25:53.789]   - Field: ‘envir’
[10:25:53.789]   - Field: ‘workers’
[10:25:53.789]   - Field: ‘packages’
[10:25:53.789]   - Field: ‘gc’
[10:25:53.789]   - Field: ‘job’
[10:25:53.789]   - Field: ‘conditions’
[10:25:53.789]   - Field: ‘expr’
[10:25:53.790]   - Field: ‘uuid’
[10:25:53.790]   - Field: ‘seed’
[10:25:53.790]   - Field: ‘version’
[10:25:53.790]   - Field: ‘result’
[10:25:53.790]   - Field: ‘asynchronous’
[10:25:53.790]   - Field: ‘calls’
[10:25:53.790]   - Field: ‘globals’
[10:25:53.790]   - Field: ‘stdout’
[10:25:53.791]   - Field: ‘earlySignal’
[10:25:53.791]   - Field: ‘lazy’
[10:25:53.791]   - Field: ‘state’
[10:25:53.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.791] - Launch lazy future ...
[10:25:53.791] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.792] Packages needed by future strategies (n = 0): <none>
[10:25:53.792] {
[10:25:53.792]     {
[10:25:53.792]         {
[10:25:53.792]             ...future.startTime <- base::Sys.time()
[10:25:53.792]             {
[10:25:53.792]                 {
[10:25:53.792]                   {
[10:25:53.792]                     {
[10:25:53.792]                       {
[10:25:53.792]                         base::local({
[10:25:53.792]                           has_future <- base::requireNamespace("future", 
[10:25:53.792]                             quietly = TRUE)
[10:25:53.792]                           if (has_future) {
[10:25:53.792]                             ns <- base::getNamespace("future")
[10:25:53.792]                             version <- ns[[".package"]][["version"]]
[10:25:53.792]                             if (is.null(version)) 
[10:25:53.792]                               version <- utils::packageVersion("future")
[10:25:53.792]                           }
[10:25:53.792]                           else {
[10:25:53.792]                             version <- NULL
[10:25:53.792]                           }
[10:25:53.792]                           if (!has_future || version < "1.8.0") {
[10:25:53.792]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.792]                               "", base::R.version$version.string), 
[10:25:53.792]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.792]                                 base::R.version$platform, 8 * 
[10:25:53.792]                                   base::.Machine$sizeof.pointer), 
[10:25:53.792]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.792]                                 "release", "version")], collapse = " "), 
[10:25:53.792]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.792]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.792]                               info)
[10:25:53.792]                             info <- base::paste(info, collapse = "; ")
[10:25:53.792]                             if (!has_future) {
[10:25:53.792]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.792]                                 info)
[10:25:53.792]                             }
[10:25:53.792]                             else {
[10:25:53.792]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.792]                                 info, version)
[10:25:53.792]                             }
[10:25:53.792]                             base::stop(msg)
[10:25:53.792]                           }
[10:25:53.792]                         })
[10:25:53.792]                       }
[10:25:53.792]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.792]                       base::options(mc.cores = 1L)
[10:25:53.792]                     }
[10:25:53.792]                     base::local({
[10:25:53.792]                       for (pkg in "stats") {
[10:25:53.792]                         base::loadNamespace(pkg)
[10:25:53.792]                         base::library(pkg, character.only = TRUE)
[10:25:53.792]                       }
[10:25:53.792]                     })
[10:25:53.792]                   }
[10:25:53.792]                   options(future.plan = NULL)
[10:25:53.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.792]                 }
[10:25:53.792]                 ...future.workdir <- getwd()
[10:25:53.792]             }
[10:25:53.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.792]         }
[10:25:53.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.792]             base::names(...future.oldOptions))
[10:25:53.792]     }
[10:25:53.792]     if (FALSE) {
[10:25:53.792]     }
[10:25:53.792]     else {
[10:25:53.792]         if (TRUE) {
[10:25:53.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.792]                 open = "w")
[10:25:53.792]         }
[10:25:53.792]         else {
[10:25:53.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.792]         }
[10:25:53.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.792]             base::sink(type = "output", split = FALSE)
[10:25:53.792]             base::close(...future.stdout)
[10:25:53.792]         }, add = TRUE)
[10:25:53.792]     }
[10:25:53.792]     ...future.frame <- base::sys.nframe()
[10:25:53.792]     ...future.conditions <- base::list()
[10:25:53.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.792]     if (FALSE) {
[10:25:53.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.792]     }
[10:25:53.792]     ...future.result <- base::tryCatch({
[10:25:53.792]         base::withCallingHandlers({
[10:25:53.792]             ...future.value <- base::withVisible(base::local({
[10:25:53.792]                 withCallingHandlers({
[10:25:53.792]                   {
[10:25:53.792]                     lm(weight ~ group - 1)
[10:25:53.792]                   }
[10:25:53.792]                 }, immediateCondition = function(cond) {
[10:25:53.792]                   save_rds <- function (object, pathname, ...) 
[10:25:53.792]                   {
[10:25:53.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.792]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.792]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.792]                         fi_tmp[["mtime"]])
[10:25:53.792]                     }
[10:25:53.792]                     tryCatch({
[10:25:53.792]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.792]                     }, error = function(ex) {
[10:25:53.792]                       msg <- conditionMessage(ex)
[10:25:53.792]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.792]                         fi_tmp[["mtime"]], msg)
[10:25:53.792]                       ex$message <- msg
[10:25:53.792]                       stop(ex)
[10:25:53.792]                     })
[10:25:53.792]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.792]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.792]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.792]                       fi <- file.info(pathname)
[10:25:53.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.792]                         fi[["size"]], fi[["mtime"]])
[10:25:53.792]                       stop(msg)
[10:25:53.792]                     }
[10:25:53.792]                     invisible(pathname)
[10:25:53.792]                   }
[10:25:53.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.792]                     rootPath = tempdir()) 
[10:25:53.792]                   {
[10:25:53.792]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.792]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.792]                       tmpdir = path, fileext = ".rds")
[10:25:53.792]                     save_rds(obj, file)
[10:25:53.792]                   }
[10:25:53.792]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.792]                   {
[10:25:53.792]                     inherits <- base::inherits
[10:25:53.792]                     invokeRestart <- base::invokeRestart
[10:25:53.792]                     is.null <- base::is.null
[10:25:53.792]                     muffled <- FALSE
[10:25:53.792]                     if (inherits(cond, "message")) {
[10:25:53.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.792]                       if (muffled) 
[10:25:53.792]                         invokeRestart("muffleMessage")
[10:25:53.792]                     }
[10:25:53.792]                     else if (inherits(cond, "warning")) {
[10:25:53.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.792]                       if (muffled) 
[10:25:53.792]                         invokeRestart("muffleWarning")
[10:25:53.792]                     }
[10:25:53.792]                     else if (inherits(cond, "condition")) {
[10:25:53.792]                       if (!is.null(pattern)) {
[10:25:53.792]                         computeRestarts <- base::computeRestarts
[10:25:53.792]                         grepl <- base::grepl
[10:25:53.792]                         restarts <- computeRestarts(cond)
[10:25:53.792]                         for (restart in restarts) {
[10:25:53.792]                           name <- restart$name
[10:25:53.792]                           if (is.null(name)) 
[10:25:53.792]                             next
[10:25:53.792]                           if (!grepl(pattern, name)) 
[10:25:53.792]                             next
[10:25:53.792]                           invokeRestart(restart)
[10:25:53.792]                           muffled <- TRUE
[10:25:53.792]                           break
[10:25:53.792]                         }
[10:25:53.792]                       }
[10:25:53.792]                     }
[10:25:53.792]                     invisible(muffled)
[10:25:53.792]                   }
[10:25:53.792]                   muffleCondition(cond)
[10:25:53.792]                 })
[10:25:53.792]             }))
[10:25:53.792]             future::FutureResult(value = ...future.value$value, 
[10:25:53.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.792]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.792]                     ...future.globalenv.names))
[10:25:53.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.792]         }, condition = base::local({
[10:25:53.792]             c <- base::c
[10:25:53.792]             inherits <- base::inherits
[10:25:53.792]             invokeRestart <- base::invokeRestart
[10:25:53.792]             length <- base::length
[10:25:53.792]             list <- base::list
[10:25:53.792]             seq.int <- base::seq.int
[10:25:53.792]             signalCondition <- base::signalCondition
[10:25:53.792]             sys.calls <- base::sys.calls
[10:25:53.792]             `[[` <- base::`[[`
[10:25:53.792]             `+` <- base::`+`
[10:25:53.792]             `<<-` <- base::`<<-`
[10:25:53.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.792]                   3L)]
[10:25:53.792]             }
[10:25:53.792]             function(cond) {
[10:25:53.792]                 is_error <- inherits(cond, "error")
[10:25:53.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.792]                   NULL)
[10:25:53.792]                 if (is_error) {
[10:25:53.792]                   sessionInformation <- function() {
[10:25:53.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.792]                       search = base::search(), system = base::Sys.info())
[10:25:53.792]                   }
[10:25:53.792]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.792]                     cond$call), session = sessionInformation(), 
[10:25:53.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.792]                   signalCondition(cond)
[10:25:53.792]                 }
[10:25:53.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.792]                 "immediateCondition"))) {
[10:25:53.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.792]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.792]                   if (TRUE && !signal) {
[10:25:53.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.792]                     {
[10:25:53.792]                       inherits <- base::inherits
[10:25:53.792]                       invokeRestart <- base::invokeRestart
[10:25:53.792]                       is.null <- base::is.null
[10:25:53.792]                       muffled <- FALSE
[10:25:53.792]                       if (inherits(cond, "message")) {
[10:25:53.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.792]                         if (muffled) 
[10:25:53.792]                           invokeRestart("muffleMessage")
[10:25:53.792]                       }
[10:25:53.792]                       else if (inherits(cond, "warning")) {
[10:25:53.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.792]                         if (muffled) 
[10:25:53.792]                           invokeRestart("muffleWarning")
[10:25:53.792]                       }
[10:25:53.792]                       else if (inherits(cond, "condition")) {
[10:25:53.792]                         if (!is.null(pattern)) {
[10:25:53.792]                           computeRestarts <- base::computeRestarts
[10:25:53.792]                           grepl <- base::grepl
[10:25:53.792]                           restarts <- computeRestarts(cond)
[10:25:53.792]                           for (restart in restarts) {
[10:25:53.792]                             name <- restart$name
[10:25:53.792]                             if (is.null(name)) 
[10:25:53.792]                               next
[10:25:53.792]                             if (!grepl(pattern, name)) 
[10:25:53.792]                               next
[10:25:53.792]                             invokeRestart(restart)
[10:25:53.792]                             muffled <- TRUE
[10:25:53.792]                             break
[10:25:53.792]                           }
[10:25:53.792]                         }
[10:25:53.792]                       }
[10:25:53.792]                       invisible(muffled)
[10:25:53.792]                     }
[10:25:53.792]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.792]                   }
[10:25:53.792]                 }
[10:25:53.792]                 else {
[10:25:53.792]                   if (TRUE) {
[10:25:53.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.792]                     {
[10:25:53.792]                       inherits <- base::inherits
[10:25:53.792]                       invokeRestart <- base::invokeRestart
[10:25:53.792]                       is.null <- base::is.null
[10:25:53.792]                       muffled <- FALSE
[10:25:53.792]                       if (inherits(cond, "message")) {
[10:25:53.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.792]                         if (muffled) 
[10:25:53.792]                           invokeRestart("muffleMessage")
[10:25:53.792]                       }
[10:25:53.792]                       else if (inherits(cond, "warning")) {
[10:25:53.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.792]                         if (muffled) 
[10:25:53.792]                           invokeRestart("muffleWarning")
[10:25:53.792]                       }
[10:25:53.792]                       else if (inherits(cond, "condition")) {
[10:25:53.792]                         if (!is.null(pattern)) {
[10:25:53.792]                           computeRestarts <- base::computeRestarts
[10:25:53.792]                           grepl <- base::grepl
[10:25:53.792]                           restarts <- computeRestarts(cond)
[10:25:53.792]                           for (restart in restarts) {
[10:25:53.792]                             name <- restart$name
[10:25:53.792]                             if (is.null(name)) 
[10:25:53.792]                               next
[10:25:53.792]                             if (!grepl(pattern, name)) 
[10:25:53.792]                               next
[10:25:53.792]                             invokeRestart(restart)
[10:25:53.792]                             muffled <- TRUE
[10:25:53.792]                             break
[10:25:53.792]                           }
[10:25:53.792]                         }
[10:25:53.792]                       }
[10:25:53.792]                       invisible(muffled)
[10:25:53.792]                     }
[10:25:53.792]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.792]                   }
[10:25:53.792]                 }
[10:25:53.792]             }
[10:25:53.792]         }))
[10:25:53.792]     }, error = function(ex) {
[10:25:53.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.792]                 ...future.rng), started = ...future.startTime, 
[10:25:53.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.792]             version = "1.8"), class = "FutureResult")
[10:25:53.792]     }, finally = {
[10:25:53.792]         if (!identical(...future.workdir, getwd())) 
[10:25:53.792]             setwd(...future.workdir)
[10:25:53.792]         {
[10:25:53.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.792]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.792]             }
[10:25:53.792]             base::options(...future.oldOptions)
[10:25:53.792]             if (.Platform$OS.type == "windows") {
[10:25:53.792]                 old_names <- names(...future.oldEnvVars)
[10:25:53.792]                 envs <- base::Sys.getenv()
[10:25:53.792]                 names <- names(envs)
[10:25:53.792]                 common <- intersect(names, old_names)
[10:25:53.792]                 added <- setdiff(names, old_names)
[10:25:53.792]                 removed <- setdiff(old_names, names)
[10:25:53.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.792]                   envs[common]]
[10:25:53.792]                 NAMES <- toupper(changed)
[10:25:53.792]                 args <- list()
[10:25:53.792]                 for (kk in seq_along(NAMES)) {
[10:25:53.792]                   name <- changed[[kk]]
[10:25:53.792]                   NAME <- NAMES[[kk]]
[10:25:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.792]                     next
[10:25:53.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.792]                 }
[10:25:53.792]                 NAMES <- toupper(added)
[10:25:53.792]                 for (kk in seq_along(NAMES)) {
[10:25:53.792]                   name <- added[[kk]]
[10:25:53.792]                   NAME <- NAMES[[kk]]
[10:25:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.792]                     next
[10:25:53.792]                   args[[name]] <- ""
[10:25:53.792]                 }
[10:25:53.792]                 NAMES <- toupper(removed)
[10:25:53.792]                 for (kk in seq_along(NAMES)) {
[10:25:53.792]                   name <- removed[[kk]]
[10:25:53.792]                   NAME <- NAMES[[kk]]
[10:25:53.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.792]                     next
[10:25:53.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.792]                 }
[10:25:53.792]                 if (length(args) > 0) 
[10:25:53.792]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.792]             }
[10:25:53.792]             else {
[10:25:53.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.792]             }
[10:25:53.792]             {
[10:25:53.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.792]                   0L) {
[10:25:53.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.792]                   base::options(opts)
[10:25:53.792]                 }
[10:25:53.792]                 {
[10:25:53.792]                   {
[10:25:53.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.792]                     NULL
[10:25:53.792]                   }
[10:25:53.792]                   options(future.plan = NULL)
[10:25:53.792]                   if (is.na(NA_character_)) 
[10:25:53.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.792]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.792]                     envir = parent.frame()) 
[10:25:53.792]                   {
[10:25:53.792]                     default_workers <- missing(workers)
[10:25:53.792]                     if (is.function(workers)) 
[10:25:53.792]                       workers <- workers()
[10:25:53.792]                     workers <- structure(as.integer(workers), 
[10:25:53.792]                       class = class(workers))
[10:25:53.792]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.792]                       1L)
[10:25:53.792]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.792]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.792]                       if (default_workers) 
[10:25:53.792]                         supportsMulticore(warn = TRUE)
[10:25:53.792]                       return(sequential(..., envir = envir))
[10:25:53.792]                     }
[10:25:53.792]                     oopts <- options(mc.cores = workers)
[10:25:53.792]                     on.exit(options(oopts))
[10:25:53.792]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.792]                       envir = envir)
[10:25:53.792]                     if (!future$lazy) 
[10:25:53.792]                       future <- run(future)
[10:25:53.792]                     invisible(future)
[10:25:53.792]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.792]                 }
[10:25:53.792]             }
[10:25:53.792]         }
[10:25:53.792]     })
[10:25:53.792]     if (TRUE) {
[10:25:53.792]         base::sink(type = "output", split = FALSE)
[10:25:53.792]         if (TRUE) {
[10:25:53.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.792]         }
[10:25:53.792]         else {
[10:25:53.792]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.792]         }
[10:25:53.792]         base::close(...future.stdout)
[10:25:53.792]         ...future.stdout <- NULL
[10:25:53.792]     }
[10:25:53.792]     ...future.result$conditions <- ...future.conditions
[10:25:53.792]     ...future.result$finished <- base::Sys.time()
[10:25:53.792]     ...future.result
[10:25:53.792] }
[10:25:53.795] assign_globals() ...
[10:25:53.795] List of 2
[10:25:53.795]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.795]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.795]  - attr(*, "where")=List of 2
[10:25:53.795]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.795]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.795]  - attr(*, "resolved")= logi FALSE
[10:25:53.795]  - attr(*, "total_size")= num 896
[10:25:53.795]  - attr(*, "already-done")= logi TRUE
[10:25:53.799] - copied ‘weight’ to environment
[10:25:53.799] - copied ‘group’ to environment
[10:25:53.799] assign_globals() ... done
[10:25:53.799] requestCore(): workers = 2
[10:25:53.801] MulticoreFuture started
[10:25:53.802] - Launch lazy future ... done
[10:25:53.802] run() for ‘MulticoreFuture’ ... done
[10:25:53.802] result() for MulticoreFuture ...
[10:25:53.803] plan(): Setting new future strategy stack:
[10:25:53.803] List of future strategies:
[10:25:53.803] 1. sequential:
[10:25:53.803]    - args: function (..., envir = parent.frame())
[10:25:53.803]    - tweaked: FALSE
[10:25:53.803]    - call: NULL
[10:25:53.804] plan(): nbrOfWorkers() = 1
[10:25:53.807] plan(): Setting new future strategy stack:
[10:25:53.808] List of future strategies:
[10:25:53.808] 1. multicore:
[10:25:53.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.808]    - tweaked: FALSE
[10:25:53.808]    - call: plan(strategy)
[10:25:53.812] plan(): nbrOfWorkers() = 2
[10:25:53.815] result() for MulticoreFuture ...
[10:25:53.815] result() for MulticoreFuture ... done
[10:25:53.815] result() for MulticoreFuture ... done
[10:25:53.815] result() for MulticoreFuture ...
[10:25:53.815] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:53.818] getGlobalsAndPackages() ...
[10:25:53.818] Searching for globals...
[10:25:53.820] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:53.820] Searching for globals ... DONE
[10:25:53.820] Resolving globals: FALSE
[10:25:53.821] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:53.821] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:53.822] - globals: [2] ‘weight’, ‘group’
[10:25:53.822] - packages: [1] ‘stats’
[10:25:53.822] getGlobalsAndPackages() ... DONE
[10:25:53.822] run() for ‘Future’ ...
[10:25:53.822] - state: ‘created’
[10:25:53.823] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.827]   - Field: ‘label’
[10:25:53.827]   - Field: ‘local’
[10:25:53.827]   - Field: ‘owner’
[10:25:53.827]   - Field: ‘envir’
[10:25:53.827]   - Field: ‘workers’
[10:25:53.827]   - Field: ‘packages’
[10:25:53.828]   - Field: ‘gc’
[10:25:53.828]   - Field: ‘job’
[10:25:53.828]   - Field: ‘conditions’
[10:25:53.828]   - Field: ‘expr’
[10:25:53.828]   - Field: ‘uuid’
[10:25:53.828]   - Field: ‘seed’
[10:25:53.828]   - Field: ‘version’
[10:25:53.828]   - Field: ‘result’
[10:25:53.828]   - Field: ‘asynchronous’
[10:25:53.829]   - Field: ‘calls’
[10:25:53.829]   - Field: ‘globals’
[10:25:53.829]   - Field: ‘stdout’
[10:25:53.831]   - Field: ‘earlySignal’
[10:25:53.832]   - Field: ‘lazy’
[10:25:53.832]   - Field: ‘state’
[10:25:53.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.832] - Launch lazy future ...
[10:25:53.832] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.832] Packages needed by future strategies (n = 0): <none>
[10:25:53.833] {
[10:25:53.833]     {
[10:25:53.833]         {
[10:25:53.833]             ...future.startTime <- base::Sys.time()
[10:25:53.833]             {
[10:25:53.833]                 {
[10:25:53.833]                   {
[10:25:53.833]                     {
[10:25:53.833]                       {
[10:25:53.833]                         base::local({
[10:25:53.833]                           has_future <- base::requireNamespace("future", 
[10:25:53.833]                             quietly = TRUE)
[10:25:53.833]                           if (has_future) {
[10:25:53.833]                             ns <- base::getNamespace("future")
[10:25:53.833]                             version <- ns[[".package"]][["version"]]
[10:25:53.833]                             if (is.null(version)) 
[10:25:53.833]                               version <- utils::packageVersion("future")
[10:25:53.833]                           }
[10:25:53.833]                           else {
[10:25:53.833]                             version <- NULL
[10:25:53.833]                           }
[10:25:53.833]                           if (!has_future || version < "1.8.0") {
[10:25:53.833]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.833]                               "", base::R.version$version.string), 
[10:25:53.833]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.833]                                 base::R.version$platform, 8 * 
[10:25:53.833]                                   base::.Machine$sizeof.pointer), 
[10:25:53.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.833]                                 "release", "version")], collapse = " "), 
[10:25:53.833]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.833]                               info)
[10:25:53.833]                             info <- base::paste(info, collapse = "; ")
[10:25:53.833]                             if (!has_future) {
[10:25:53.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.833]                                 info)
[10:25:53.833]                             }
[10:25:53.833]                             else {
[10:25:53.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.833]                                 info, version)
[10:25:53.833]                             }
[10:25:53.833]                             base::stop(msg)
[10:25:53.833]                           }
[10:25:53.833]                         })
[10:25:53.833]                       }
[10:25:53.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.833]                       base::options(mc.cores = 1L)
[10:25:53.833]                     }
[10:25:53.833]                     base::local({
[10:25:53.833]                       for (pkg in "stats") {
[10:25:53.833]                         base::loadNamespace(pkg)
[10:25:53.833]                         base::library(pkg, character.only = TRUE)
[10:25:53.833]                       }
[10:25:53.833]                     })
[10:25:53.833]                   }
[10:25:53.833]                   options(future.plan = NULL)
[10:25:53.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.833]                 }
[10:25:53.833]                 ...future.workdir <- getwd()
[10:25:53.833]             }
[10:25:53.833]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.833]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.833]         }
[10:25:53.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.833]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.833]             base::names(...future.oldOptions))
[10:25:53.833]     }
[10:25:53.833]     if (FALSE) {
[10:25:53.833]     }
[10:25:53.833]     else {
[10:25:53.833]         if (TRUE) {
[10:25:53.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.833]                 open = "w")
[10:25:53.833]         }
[10:25:53.833]         else {
[10:25:53.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.833]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.833]         }
[10:25:53.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.833]             base::sink(type = "output", split = FALSE)
[10:25:53.833]             base::close(...future.stdout)
[10:25:53.833]         }, add = TRUE)
[10:25:53.833]     }
[10:25:53.833]     ...future.frame <- base::sys.nframe()
[10:25:53.833]     ...future.conditions <- base::list()
[10:25:53.833]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.833]     if (FALSE) {
[10:25:53.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.833]     }
[10:25:53.833]     ...future.result <- base::tryCatch({
[10:25:53.833]         base::withCallingHandlers({
[10:25:53.833]             ...future.value <- base::withVisible(base::local({
[10:25:53.833]                 withCallingHandlers({
[10:25:53.833]                   {
[10:25:53.833]                     lm(weight ~ group - 1)
[10:25:53.833]                   }
[10:25:53.833]                 }, immediateCondition = function(cond) {
[10:25:53.833]                   save_rds <- function (object, pathname, ...) 
[10:25:53.833]                   {
[10:25:53.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.833]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.833]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.833]                         fi_tmp[["mtime"]])
[10:25:53.833]                     }
[10:25:53.833]                     tryCatch({
[10:25:53.833]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.833]                     }, error = function(ex) {
[10:25:53.833]                       msg <- conditionMessage(ex)
[10:25:53.833]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.833]                         fi_tmp[["mtime"]], msg)
[10:25:53.833]                       ex$message <- msg
[10:25:53.833]                       stop(ex)
[10:25:53.833]                     })
[10:25:53.833]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.833]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.833]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.833]                       fi <- file.info(pathname)
[10:25:53.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.833]                         fi[["size"]], fi[["mtime"]])
[10:25:53.833]                       stop(msg)
[10:25:53.833]                     }
[10:25:53.833]                     invisible(pathname)
[10:25:53.833]                   }
[10:25:53.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.833]                     rootPath = tempdir()) 
[10:25:53.833]                   {
[10:25:53.833]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.833]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.833]                       tmpdir = path, fileext = ".rds")
[10:25:53.833]                     save_rds(obj, file)
[10:25:53.833]                   }
[10:25:53.833]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.833]                   {
[10:25:53.833]                     inherits <- base::inherits
[10:25:53.833]                     invokeRestart <- base::invokeRestart
[10:25:53.833]                     is.null <- base::is.null
[10:25:53.833]                     muffled <- FALSE
[10:25:53.833]                     if (inherits(cond, "message")) {
[10:25:53.833]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.833]                       if (muffled) 
[10:25:53.833]                         invokeRestart("muffleMessage")
[10:25:53.833]                     }
[10:25:53.833]                     else if (inherits(cond, "warning")) {
[10:25:53.833]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.833]                       if (muffled) 
[10:25:53.833]                         invokeRestart("muffleWarning")
[10:25:53.833]                     }
[10:25:53.833]                     else if (inherits(cond, "condition")) {
[10:25:53.833]                       if (!is.null(pattern)) {
[10:25:53.833]                         computeRestarts <- base::computeRestarts
[10:25:53.833]                         grepl <- base::grepl
[10:25:53.833]                         restarts <- computeRestarts(cond)
[10:25:53.833]                         for (restart in restarts) {
[10:25:53.833]                           name <- restart$name
[10:25:53.833]                           if (is.null(name)) 
[10:25:53.833]                             next
[10:25:53.833]                           if (!grepl(pattern, name)) 
[10:25:53.833]                             next
[10:25:53.833]                           invokeRestart(restart)
[10:25:53.833]                           muffled <- TRUE
[10:25:53.833]                           break
[10:25:53.833]                         }
[10:25:53.833]                       }
[10:25:53.833]                     }
[10:25:53.833]                     invisible(muffled)
[10:25:53.833]                   }
[10:25:53.833]                   muffleCondition(cond)
[10:25:53.833]                 })
[10:25:53.833]             }))
[10:25:53.833]             future::FutureResult(value = ...future.value$value, 
[10:25:53.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.833]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.833]                     ...future.globalenv.names))
[10:25:53.833]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.833]         }, condition = base::local({
[10:25:53.833]             c <- base::c
[10:25:53.833]             inherits <- base::inherits
[10:25:53.833]             invokeRestart <- base::invokeRestart
[10:25:53.833]             length <- base::length
[10:25:53.833]             list <- base::list
[10:25:53.833]             seq.int <- base::seq.int
[10:25:53.833]             signalCondition <- base::signalCondition
[10:25:53.833]             sys.calls <- base::sys.calls
[10:25:53.833]             `[[` <- base::`[[`
[10:25:53.833]             `+` <- base::`+`
[10:25:53.833]             `<<-` <- base::`<<-`
[10:25:53.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.833]                   3L)]
[10:25:53.833]             }
[10:25:53.833]             function(cond) {
[10:25:53.833]                 is_error <- inherits(cond, "error")
[10:25:53.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.833]                   NULL)
[10:25:53.833]                 if (is_error) {
[10:25:53.833]                   sessionInformation <- function() {
[10:25:53.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.833]                       search = base::search(), system = base::Sys.info())
[10:25:53.833]                   }
[10:25:53.833]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.833]                     cond$call), session = sessionInformation(), 
[10:25:53.833]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.833]                   signalCondition(cond)
[10:25:53.833]                 }
[10:25:53.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.833]                 "immediateCondition"))) {
[10:25:53.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.833]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.833]                   if (TRUE && !signal) {
[10:25:53.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.833]                     {
[10:25:53.833]                       inherits <- base::inherits
[10:25:53.833]                       invokeRestart <- base::invokeRestart
[10:25:53.833]                       is.null <- base::is.null
[10:25:53.833]                       muffled <- FALSE
[10:25:53.833]                       if (inherits(cond, "message")) {
[10:25:53.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.833]                         if (muffled) 
[10:25:53.833]                           invokeRestart("muffleMessage")
[10:25:53.833]                       }
[10:25:53.833]                       else if (inherits(cond, "warning")) {
[10:25:53.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.833]                         if (muffled) 
[10:25:53.833]                           invokeRestart("muffleWarning")
[10:25:53.833]                       }
[10:25:53.833]                       else if (inherits(cond, "condition")) {
[10:25:53.833]                         if (!is.null(pattern)) {
[10:25:53.833]                           computeRestarts <- base::computeRestarts
[10:25:53.833]                           grepl <- base::grepl
[10:25:53.833]                           restarts <- computeRestarts(cond)
[10:25:53.833]                           for (restart in restarts) {
[10:25:53.833]                             name <- restart$name
[10:25:53.833]                             if (is.null(name)) 
[10:25:53.833]                               next
[10:25:53.833]                             if (!grepl(pattern, name)) 
[10:25:53.833]                               next
[10:25:53.833]                             invokeRestart(restart)
[10:25:53.833]                             muffled <- TRUE
[10:25:53.833]                             break
[10:25:53.833]                           }
[10:25:53.833]                         }
[10:25:53.833]                       }
[10:25:53.833]                       invisible(muffled)
[10:25:53.833]                     }
[10:25:53.833]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.833]                   }
[10:25:53.833]                 }
[10:25:53.833]                 else {
[10:25:53.833]                   if (TRUE) {
[10:25:53.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.833]                     {
[10:25:53.833]                       inherits <- base::inherits
[10:25:53.833]                       invokeRestart <- base::invokeRestart
[10:25:53.833]                       is.null <- base::is.null
[10:25:53.833]                       muffled <- FALSE
[10:25:53.833]                       if (inherits(cond, "message")) {
[10:25:53.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.833]                         if (muffled) 
[10:25:53.833]                           invokeRestart("muffleMessage")
[10:25:53.833]                       }
[10:25:53.833]                       else if (inherits(cond, "warning")) {
[10:25:53.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.833]                         if (muffled) 
[10:25:53.833]                           invokeRestart("muffleWarning")
[10:25:53.833]                       }
[10:25:53.833]                       else if (inherits(cond, "condition")) {
[10:25:53.833]                         if (!is.null(pattern)) {
[10:25:53.833]                           computeRestarts <- base::computeRestarts
[10:25:53.833]                           grepl <- base::grepl
[10:25:53.833]                           restarts <- computeRestarts(cond)
[10:25:53.833]                           for (restart in restarts) {
[10:25:53.833]                             name <- restart$name
[10:25:53.833]                             if (is.null(name)) 
[10:25:53.833]                               next
[10:25:53.833]                             if (!grepl(pattern, name)) 
[10:25:53.833]                               next
[10:25:53.833]                             invokeRestart(restart)
[10:25:53.833]                             muffled <- TRUE
[10:25:53.833]                             break
[10:25:53.833]                           }
[10:25:53.833]                         }
[10:25:53.833]                       }
[10:25:53.833]                       invisible(muffled)
[10:25:53.833]                     }
[10:25:53.833]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.833]                   }
[10:25:53.833]                 }
[10:25:53.833]             }
[10:25:53.833]         }))
[10:25:53.833]     }, error = function(ex) {
[10:25:53.833]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.833]                 ...future.rng), started = ...future.startTime, 
[10:25:53.833]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.833]             version = "1.8"), class = "FutureResult")
[10:25:53.833]     }, finally = {
[10:25:53.833]         if (!identical(...future.workdir, getwd())) 
[10:25:53.833]             setwd(...future.workdir)
[10:25:53.833]         {
[10:25:53.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.833]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.833]             }
[10:25:53.833]             base::options(...future.oldOptions)
[10:25:53.833]             if (.Platform$OS.type == "windows") {
[10:25:53.833]                 old_names <- names(...future.oldEnvVars)
[10:25:53.833]                 envs <- base::Sys.getenv()
[10:25:53.833]                 names <- names(envs)
[10:25:53.833]                 common <- intersect(names, old_names)
[10:25:53.833]                 added <- setdiff(names, old_names)
[10:25:53.833]                 removed <- setdiff(old_names, names)
[10:25:53.833]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.833]                   envs[common]]
[10:25:53.833]                 NAMES <- toupper(changed)
[10:25:53.833]                 args <- list()
[10:25:53.833]                 for (kk in seq_along(NAMES)) {
[10:25:53.833]                   name <- changed[[kk]]
[10:25:53.833]                   NAME <- NAMES[[kk]]
[10:25:53.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.833]                     next
[10:25:53.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.833]                 }
[10:25:53.833]                 NAMES <- toupper(added)
[10:25:53.833]                 for (kk in seq_along(NAMES)) {
[10:25:53.833]                   name <- added[[kk]]
[10:25:53.833]                   NAME <- NAMES[[kk]]
[10:25:53.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.833]                     next
[10:25:53.833]                   args[[name]] <- ""
[10:25:53.833]                 }
[10:25:53.833]                 NAMES <- toupper(removed)
[10:25:53.833]                 for (kk in seq_along(NAMES)) {
[10:25:53.833]                   name <- removed[[kk]]
[10:25:53.833]                   NAME <- NAMES[[kk]]
[10:25:53.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.833]                     next
[10:25:53.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.833]                 }
[10:25:53.833]                 if (length(args) > 0) 
[10:25:53.833]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.833]             }
[10:25:53.833]             else {
[10:25:53.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.833]             }
[10:25:53.833]             {
[10:25:53.833]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.833]                   0L) {
[10:25:53.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.833]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.833]                   base::options(opts)
[10:25:53.833]                 }
[10:25:53.833]                 {
[10:25:53.833]                   {
[10:25:53.833]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.833]                     NULL
[10:25:53.833]                   }
[10:25:53.833]                   options(future.plan = NULL)
[10:25:53.833]                   if (is.na(NA_character_)) 
[10:25:53.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.833]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.833]                     envir = parent.frame()) 
[10:25:53.833]                   {
[10:25:53.833]                     default_workers <- missing(workers)
[10:25:53.833]                     if (is.function(workers)) 
[10:25:53.833]                       workers <- workers()
[10:25:53.833]                     workers <- structure(as.integer(workers), 
[10:25:53.833]                       class = class(workers))
[10:25:53.833]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.833]                       1L)
[10:25:53.833]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.833]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.833]                       if (default_workers) 
[10:25:53.833]                         supportsMulticore(warn = TRUE)
[10:25:53.833]                       return(sequential(..., envir = envir))
[10:25:53.833]                     }
[10:25:53.833]                     oopts <- options(mc.cores = workers)
[10:25:53.833]                     on.exit(options(oopts))
[10:25:53.833]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.833]                       envir = envir)
[10:25:53.833]                     if (!future$lazy) 
[10:25:53.833]                       future <- run(future)
[10:25:53.833]                     invisible(future)
[10:25:53.833]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.833]                 }
[10:25:53.833]             }
[10:25:53.833]         }
[10:25:53.833]     })
[10:25:53.833]     if (TRUE) {
[10:25:53.833]         base::sink(type = "output", split = FALSE)
[10:25:53.833]         if (TRUE) {
[10:25:53.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.833]         }
[10:25:53.833]         else {
[10:25:53.833]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.833]         }
[10:25:53.833]         base::close(...future.stdout)
[10:25:53.833]         ...future.stdout <- NULL
[10:25:53.833]     }
[10:25:53.833]     ...future.result$conditions <- ...future.conditions
[10:25:53.833]     ...future.result$finished <- base::Sys.time()
[10:25:53.833]     ...future.result
[10:25:53.833] }
[10:25:53.836] assign_globals() ...
[10:25:53.836] List of 2
[10:25:53.836]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:25:53.836]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:25:53.836]  - attr(*, "where")=List of 2
[10:25:53.836]   ..$ weight:<environment: R_EmptyEnv> 
[10:25:53.836]   ..$ group :<environment: R_EmptyEnv> 
[10:25:53.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.836]  - attr(*, "resolved")= logi FALSE
[10:25:53.836]  - attr(*, "total_size")= num 896
[10:25:53.836]  - attr(*, "already-done")= logi TRUE
[10:25:53.840] - copied ‘weight’ to environment
[10:25:53.840] - copied ‘group’ to environment
[10:25:53.840] assign_globals() ... done
[10:25:53.841] requestCore(): workers = 2
[10:25:53.843] MulticoreFuture started
[10:25:53.843] - Launch lazy future ... done
[10:25:53.843] run() for ‘MulticoreFuture’ ... done
[10:25:53.843] result() for MulticoreFuture ...
[10:25:53.844] plan(): Setting new future strategy stack:
[10:25:53.844] List of future strategies:
[10:25:53.844] 1. sequential:
[10:25:53.844]    - args: function (..., envir = parent.frame())
[10:25:53.844]    - tweaked: FALSE
[10:25:53.844]    - call: NULL
[10:25:53.845] plan(): nbrOfWorkers() = 1
[10:25:53.849] plan(): Setting new future strategy stack:
[10:25:53.849] List of future strategies:
[10:25:53.849] 1. multicore:
[10:25:53.849]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.849]    - tweaked: FALSE
[10:25:53.849]    - call: plan(strategy)
[10:25:53.854] plan(): nbrOfWorkers() = 2
[10:25:53.856] result() for MulticoreFuture ...
[10:25:53.856] result() for MulticoreFuture ... done
[10:25:53.856] result() for MulticoreFuture ... done
[10:25:53.856] result() for MulticoreFuture ...
[10:25:53.856] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:25:53.859] getGlobalsAndPackages() ...
[10:25:53.859] Searching for globals...
[10:25:53.860] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:53.861] Searching for globals ... DONE
[10:25:53.861] Resolving globals: FALSE
[10:25:53.861] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:53.862] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:53.862] - globals: [1] ‘x’
[10:25:53.862] - packages: [1] ‘stats’
[10:25:53.862] getGlobalsAndPackages() ... DONE
[10:25:53.863] run() for ‘Future’ ...
[10:25:53.863] - state: ‘created’
[10:25:53.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.867]   - Field: ‘label’
[10:25:53.867]   - Field: ‘local’
[10:25:53.868]   - Field: ‘owner’
[10:25:53.868]   - Field: ‘envir’
[10:25:53.868]   - Field: ‘workers’
[10:25:53.868]   - Field: ‘packages’
[10:25:53.868]   - Field: ‘gc’
[10:25:53.868]   - Field: ‘job’
[10:25:53.868]   - Field: ‘conditions’
[10:25:53.868]   - Field: ‘expr’
[10:25:53.868]   - Field: ‘uuid’
[10:25:53.869]   - Field: ‘seed’
[10:25:53.869]   - Field: ‘version’
[10:25:53.869]   - Field: ‘result’
[10:25:53.869]   - Field: ‘asynchronous’
[10:25:53.869]   - Field: ‘calls’
[10:25:53.869]   - Field: ‘globals’
[10:25:53.869]   - Field: ‘stdout’
[10:25:53.869]   - Field: ‘earlySignal’
[10:25:53.870]   - Field: ‘lazy’
[10:25:53.870]   - Field: ‘state’
[10:25:53.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.870] - Launch lazy future ...
[10:25:53.870] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.870] Packages needed by future strategies (n = 0): <none>
[10:25:53.871] {
[10:25:53.871]     {
[10:25:53.871]         {
[10:25:53.871]             ...future.startTime <- base::Sys.time()
[10:25:53.871]             {
[10:25:53.871]                 {
[10:25:53.871]                   {
[10:25:53.871]                     {
[10:25:53.871]                       {
[10:25:53.871]                         base::local({
[10:25:53.871]                           has_future <- base::requireNamespace("future", 
[10:25:53.871]                             quietly = TRUE)
[10:25:53.871]                           if (has_future) {
[10:25:53.871]                             ns <- base::getNamespace("future")
[10:25:53.871]                             version <- ns[[".package"]][["version"]]
[10:25:53.871]                             if (is.null(version)) 
[10:25:53.871]                               version <- utils::packageVersion("future")
[10:25:53.871]                           }
[10:25:53.871]                           else {
[10:25:53.871]                             version <- NULL
[10:25:53.871]                           }
[10:25:53.871]                           if (!has_future || version < "1.8.0") {
[10:25:53.871]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.871]                               "", base::R.version$version.string), 
[10:25:53.871]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.871]                                 base::R.version$platform, 8 * 
[10:25:53.871]                                   base::.Machine$sizeof.pointer), 
[10:25:53.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.871]                                 "release", "version")], collapse = " "), 
[10:25:53.871]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.871]                               info)
[10:25:53.871]                             info <- base::paste(info, collapse = "; ")
[10:25:53.871]                             if (!has_future) {
[10:25:53.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.871]                                 info)
[10:25:53.871]                             }
[10:25:53.871]                             else {
[10:25:53.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.871]                                 info, version)
[10:25:53.871]                             }
[10:25:53.871]                             base::stop(msg)
[10:25:53.871]                           }
[10:25:53.871]                         })
[10:25:53.871]                       }
[10:25:53.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.871]                       base::options(mc.cores = 1L)
[10:25:53.871]                     }
[10:25:53.871]                     base::local({
[10:25:53.871]                       for (pkg in "stats") {
[10:25:53.871]                         base::loadNamespace(pkg)
[10:25:53.871]                         base::library(pkg, character.only = TRUE)
[10:25:53.871]                       }
[10:25:53.871]                     })
[10:25:53.871]                   }
[10:25:53.871]                   options(future.plan = NULL)
[10:25:53.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.871]                 }
[10:25:53.871]                 ...future.workdir <- getwd()
[10:25:53.871]             }
[10:25:53.871]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.871]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.871]         }
[10:25:53.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.871]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.871]             base::names(...future.oldOptions))
[10:25:53.871]     }
[10:25:53.871]     if (FALSE) {
[10:25:53.871]     }
[10:25:53.871]     else {
[10:25:53.871]         if (TRUE) {
[10:25:53.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.871]                 open = "w")
[10:25:53.871]         }
[10:25:53.871]         else {
[10:25:53.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.871]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.871]         }
[10:25:53.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.871]             base::sink(type = "output", split = FALSE)
[10:25:53.871]             base::close(...future.stdout)
[10:25:53.871]         }, add = TRUE)
[10:25:53.871]     }
[10:25:53.871]     ...future.frame <- base::sys.nframe()
[10:25:53.871]     ...future.conditions <- base::list()
[10:25:53.871]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.871]     if (FALSE) {
[10:25:53.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.871]     }
[10:25:53.871]     ...future.result <- base::tryCatch({
[10:25:53.871]         base::withCallingHandlers({
[10:25:53.871]             ...future.value <- base::withVisible(base::local({
[10:25:53.871]                 withCallingHandlers({
[10:25:53.871]                   {
[10:25:53.871]                     xtabs(~x)
[10:25:53.871]                   }
[10:25:53.871]                 }, immediateCondition = function(cond) {
[10:25:53.871]                   save_rds <- function (object, pathname, ...) 
[10:25:53.871]                   {
[10:25:53.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.871]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.871]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.871]                         fi_tmp[["mtime"]])
[10:25:53.871]                     }
[10:25:53.871]                     tryCatch({
[10:25:53.871]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.871]                     }, error = function(ex) {
[10:25:53.871]                       msg <- conditionMessage(ex)
[10:25:53.871]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.871]                         fi_tmp[["mtime"]], msg)
[10:25:53.871]                       ex$message <- msg
[10:25:53.871]                       stop(ex)
[10:25:53.871]                     })
[10:25:53.871]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.871]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.871]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.871]                       fi <- file.info(pathname)
[10:25:53.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.871]                         fi[["size"]], fi[["mtime"]])
[10:25:53.871]                       stop(msg)
[10:25:53.871]                     }
[10:25:53.871]                     invisible(pathname)
[10:25:53.871]                   }
[10:25:53.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.871]                     rootPath = tempdir()) 
[10:25:53.871]                   {
[10:25:53.871]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.871]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.871]                       tmpdir = path, fileext = ".rds")
[10:25:53.871]                     save_rds(obj, file)
[10:25:53.871]                   }
[10:25:53.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.871]                   {
[10:25:53.871]                     inherits <- base::inherits
[10:25:53.871]                     invokeRestart <- base::invokeRestart
[10:25:53.871]                     is.null <- base::is.null
[10:25:53.871]                     muffled <- FALSE
[10:25:53.871]                     if (inherits(cond, "message")) {
[10:25:53.871]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.871]                       if (muffled) 
[10:25:53.871]                         invokeRestart("muffleMessage")
[10:25:53.871]                     }
[10:25:53.871]                     else if (inherits(cond, "warning")) {
[10:25:53.871]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.871]                       if (muffled) 
[10:25:53.871]                         invokeRestart("muffleWarning")
[10:25:53.871]                     }
[10:25:53.871]                     else if (inherits(cond, "condition")) {
[10:25:53.871]                       if (!is.null(pattern)) {
[10:25:53.871]                         computeRestarts <- base::computeRestarts
[10:25:53.871]                         grepl <- base::grepl
[10:25:53.871]                         restarts <- computeRestarts(cond)
[10:25:53.871]                         for (restart in restarts) {
[10:25:53.871]                           name <- restart$name
[10:25:53.871]                           if (is.null(name)) 
[10:25:53.871]                             next
[10:25:53.871]                           if (!grepl(pattern, name)) 
[10:25:53.871]                             next
[10:25:53.871]                           invokeRestart(restart)
[10:25:53.871]                           muffled <- TRUE
[10:25:53.871]                           break
[10:25:53.871]                         }
[10:25:53.871]                       }
[10:25:53.871]                     }
[10:25:53.871]                     invisible(muffled)
[10:25:53.871]                   }
[10:25:53.871]                   muffleCondition(cond)
[10:25:53.871]                 })
[10:25:53.871]             }))
[10:25:53.871]             future::FutureResult(value = ...future.value$value, 
[10:25:53.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.871]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.871]                     ...future.globalenv.names))
[10:25:53.871]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.871]         }, condition = base::local({
[10:25:53.871]             c <- base::c
[10:25:53.871]             inherits <- base::inherits
[10:25:53.871]             invokeRestart <- base::invokeRestart
[10:25:53.871]             length <- base::length
[10:25:53.871]             list <- base::list
[10:25:53.871]             seq.int <- base::seq.int
[10:25:53.871]             signalCondition <- base::signalCondition
[10:25:53.871]             sys.calls <- base::sys.calls
[10:25:53.871]             `[[` <- base::`[[`
[10:25:53.871]             `+` <- base::`+`
[10:25:53.871]             `<<-` <- base::`<<-`
[10:25:53.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.871]                   3L)]
[10:25:53.871]             }
[10:25:53.871]             function(cond) {
[10:25:53.871]                 is_error <- inherits(cond, "error")
[10:25:53.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.871]                   NULL)
[10:25:53.871]                 if (is_error) {
[10:25:53.871]                   sessionInformation <- function() {
[10:25:53.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.871]                       search = base::search(), system = base::Sys.info())
[10:25:53.871]                   }
[10:25:53.871]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.871]                     cond$call), session = sessionInformation(), 
[10:25:53.871]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.871]                   signalCondition(cond)
[10:25:53.871]                 }
[10:25:53.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.871]                 "immediateCondition"))) {
[10:25:53.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.871]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.871]                   if (TRUE && !signal) {
[10:25:53.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.871]                     {
[10:25:53.871]                       inherits <- base::inherits
[10:25:53.871]                       invokeRestart <- base::invokeRestart
[10:25:53.871]                       is.null <- base::is.null
[10:25:53.871]                       muffled <- FALSE
[10:25:53.871]                       if (inherits(cond, "message")) {
[10:25:53.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.871]                         if (muffled) 
[10:25:53.871]                           invokeRestart("muffleMessage")
[10:25:53.871]                       }
[10:25:53.871]                       else if (inherits(cond, "warning")) {
[10:25:53.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.871]                         if (muffled) 
[10:25:53.871]                           invokeRestart("muffleWarning")
[10:25:53.871]                       }
[10:25:53.871]                       else if (inherits(cond, "condition")) {
[10:25:53.871]                         if (!is.null(pattern)) {
[10:25:53.871]                           computeRestarts <- base::computeRestarts
[10:25:53.871]                           grepl <- base::grepl
[10:25:53.871]                           restarts <- computeRestarts(cond)
[10:25:53.871]                           for (restart in restarts) {
[10:25:53.871]                             name <- restart$name
[10:25:53.871]                             if (is.null(name)) 
[10:25:53.871]                               next
[10:25:53.871]                             if (!grepl(pattern, name)) 
[10:25:53.871]                               next
[10:25:53.871]                             invokeRestart(restart)
[10:25:53.871]                             muffled <- TRUE
[10:25:53.871]                             break
[10:25:53.871]                           }
[10:25:53.871]                         }
[10:25:53.871]                       }
[10:25:53.871]                       invisible(muffled)
[10:25:53.871]                     }
[10:25:53.871]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.871]                   }
[10:25:53.871]                 }
[10:25:53.871]                 else {
[10:25:53.871]                   if (TRUE) {
[10:25:53.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.871]                     {
[10:25:53.871]                       inherits <- base::inherits
[10:25:53.871]                       invokeRestart <- base::invokeRestart
[10:25:53.871]                       is.null <- base::is.null
[10:25:53.871]                       muffled <- FALSE
[10:25:53.871]                       if (inherits(cond, "message")) {
[10:25:53.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.871]                         if (muffled) 
[10:25:53.871]                           invokeRestart("muffleMessage")
[10:25:53.871]                       }
[10:25:53.871]                       else if (inherits(cond, "warning")) {
[10:25:53.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.871]                         if (muffled) 
[10:25:53.871]                           invokeRestart("muffleWarning")
[10:25:53.871]                       }
[10:25:53.871]                       else if (inherits(cond, "condition")) {
[10:25:53.871]                         if (!is.null(pattern)) {
[10:25:53.871]                           computeRestarts <- base::computeRestarts
[10:25:53.871]                           grepl <- base::grepl
[10:25:53.871]                           restarts <- computeRestarts(cond)
[10:25:53.871]                           for (restart in restarts) {
[10:25:53.871]                             name <- restart$name
[10:25:53.871]                             if (is.null(name)) 
[10:25:53.871]                               next
[10:25:53.871]                             if (!grepl(pattern, name)) 
[10:25:53.871]                               next
[10:25:53.871]                             invokeRestart(restart)
[10:25:53.871]                             muffled <- TRUE
[10:25:53.871]                             break
[10:25:53.871]                           }
[10:25:53.871]                         }
[10:25:53.871]                       }
[10:25:53.871]                       invisible(muffled)
[10:25:53.871]                     }
[10:25:53.871]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.871]                   }
[10:25:53.871]                 }
[10:25:53.871]             }
[10:25:53.871]         }))
[10:25:53.871]     }, error = function(ex) {
[10:25:53.871]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.871]                 ...future.rng), started = ...future.startTime, 
[10:25:53.871]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.871]             version = "1.8"), class = "FutureResult")
[10:25:53.871]     }, finally = {
[10:25:53.871]         if (!identical(...future.workdir, getwd())) 
[10:25:53.871]             setwd(...future.workdir)
[10:25:53.871]         {
[10:25:53.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.871]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.871]             }
[10:25:53.871]             base::options(...future.oldOptions)
[10:25:53.871]             if (.Platform$OS.type == "windows") {
[10:25:53.871]                 old_names <- names(...future.oldEnvVars)
[10:25:53.871]                 envs <- base::Sys.getenv()
[10:25:53.871]                 names <- names(envs)
[10:25:53.871]                 common <- intersect(names, old_names)
[10:25:53.871]                 added <- setdiff(names, old_names)
[10:25:53.871]                 removed <- setdiff(old_names, names)
[10:25:53.871]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.871]                   envs[common]]
[10:25:53.871]                 NAMES <- toupper(changed)
[10:25:53.871]                 args <- list()
[10:25:53.871]                 for (kk in seq_along(NAMES)) {
[10:25:53.871]                   name <- changed[[kk]]
[10:25:53.871]                   NAME <- NAMES[[kk]]
[10:25:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.871]                     next
[10:25:53.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.871]                 }
[10:25:53.871]                 NAMES <- toupper(added)
[10:25:53.871]                 for (kk in seq_along(NAMES)) {
[10:25:53.871]                   name <- added[[kk]]
[10:25:53.871]                   NAME <- NAMES[[kk]]
[10:25:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.871]                     next
[10:25:53.871]                   args[[name]] <- ""
[10:25:53.871]                 }
[10:25:53.871]                 NAMES <- toupper(removed)
[10:25:53.871]                 for (kk in seq_along(NAMES)) {
[10:25:53.871]                   name <- removed[[kk]]
[10:25:53.871]                   NAME <- NAMES[[kk]]
[10:25:53.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.871]                     next
[10:25:53.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.871]                 }
[10:25:53.871]                 if (length(args) > 0) 
[10:25:53.871]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.871]             }
[10:25:53.871]             else {
[10:25:53.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.871]             }
[10:25:53.871]             {
[10:25:53.871]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.871]                   0L) {
[10:25:53.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.871]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.871]                   base::options(opts)
[10:25:53.871]                 }
[10:25:53.871]                 {
[10:25:53.871]                   {
[10:25:53.871]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.871]                     NULL
[10:25:53.871]                   }
[10:25:53.871]                   options(future.plan = NULL)
[10:25:53.871]                   if (is.na(NA_character_)) 
[10:25:53.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.871]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.871]                     envir = parent.frame()) 
[10:25:53.871]                   {
[10:25:53.871]                     default_workers <- missing(workers)
[10:25:53.871]                     if (is.function(workers)) 
[10:25:53.871]                       workers <- workers()
[10:25:53.871]                     workers <- structure(as.integer(workers), 
[10:25:53.871]                       class = class(workers))
[10:25:53.871]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.871]                       1L)
[10:25:53.871]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.871]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.871]                       if (default_workers) 
[10:25:53.871]                         supportsMulticore(warn = TRUE)
[10:25:53.871]                       return(sequential(..., envir = envir))
[10:25:53.871]                     }
[10:25:53.871]                     oopts <- options(mc.cores = workers)
[10:25:53.871]                     on.exit(options(oopts))
[10:25:53.871]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.871]                       envir = envir)
[10:25:53.871]                     if (!future$lazy) 
[10:25:53.871]                       future <- run(future)
[10:25:53.871]                     invisible(future)
[10:25:53.871]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.871]                 }
[10:25:53.871]             }
[10:25:53.871]         }
[10:25:53.871]     })
[10:25:53.871]     if (TRUE) {
[10:25:53.871]         base::sink(type = "output", split = FALSE)
[10:25:53.871]         if (TRUE) {
[10:25:53.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.871]         }
[10:25:53.871]         else {
[10:25:53.871]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.871]         }
[10:25:53.871]         base::close(...future.stdout)
[10:25:53.871]         ...future.stdout <- NULL
[10:25:53.871]     }
[10:25:53.871]     ...future.result$conditions <- ...future.conditions
[10:25:53.871]     ...future.result$finished <- base::Sys.time()
[10:25:53.871]     ...future.result
[10:25:53.871] }
[10:25:53.874] assign_globals() ...
[10:25:53.874] List of 1
[10:25:53.874]  $ x: num [1:5] 1 1 2 2 2
[10:25:53.874]  - attr(*, "where")=List of 1
[10:25:53.874]   ..$ x:<environment: R_EmptyEnv> 
[10:25:53.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.874]  - attr(*, "resolved")= logi FALSE
[10:25:53.874]  - attr(*, "total_size")= num 96
[10:25:53.874]  - attr(*, "already-done")= logi TRUE
[10:25:53.880] - copied ‘x’ to environment
[10:25:53.880] assign_globals() ... done
[10:25:53.880] requestCore(): workers = 2
[10:25:53.882] MulticoreFuture started
[10:25:53.883] - Launch lazy future ... done
[10:25:53.883] run() for ‘MulticoreFuture’ ... done
[10:25:53.883] result() for MulticoreFuture ...
[10:25:53.884] plan(): Setting new future strategy stack:
[10:25:53.884] List of future strategies:
[10:25:53.884] 1. sequential:
[10:25:53.884]    - args: function (..., envir = parent.frame())
[10:25:53.884]    - tweaked: FALSE
[10:25:53.884]    - call: NULL
[10:25:53.885] plan(): nbrOfWorkers() = 1
[10:25:53.888] plan(): Setting new future strategy stack:
[10:25:53.888] List of future strategies:
[10:25:53.888] 1. multicore:
[10:25:53.888]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.888]    - tweaked: FALSE
[10:25:53.888]    - call: plan(strategy)
[10:25:53.894] plan(): nbrOfWorkers() = 2
[10:25:53.895] result() for MulticoreFuture ...
[10:25:53.895] result() for MulticoreFuture ... done
[10:25:53.895] result() for MulticoreFuture ... done
[10:25:53.895] result() for MulticoreFuture ...
[10:25:53.896] result() for MulticoreFuture ... done
x
1 2 
2 3 
[10:25:53.897] getGlobalsAndPackages() ...
[10:25:53.898] Searching for globals...
[10:25:53.899] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:53.900] Searching for globals ... DONE
[10:25:53.900] Resolving globals: FALSE
[10:25:53.900] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:53.901] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:53.901] - globals: [1] ‘x’
[10:25:53.901] - packages: [1] ‘stats’
[10:25:53.901] getGlobalsAndPackages() ... DONE
[10:25:53.902] run() for ‘Future’ ...
[10:25:53.902] - state: ‘created’
[10:25:53.902] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.906] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.906]   - Field: ‘label’
[10:25:53.907]   - Field: ‘local’
[10:25:53.907]   - Field: ‘owner’
[10:25:53.907]   - Field: ‘envir’
[10:25:53.907]   - Field: ‘workers’
[10:25:53.907]   - Field: ‘packages’
[10:25:53.907]   - Field: ‘gc’
[10:25:53.907]   - Field: ‘job’
[10:25:53.907]   - Field: ‘conditions’
[10:25:53.908]   - Field: ‘expr’
[10:25:53.908]   - Field: ‘uuid’
[10:25:53.908]   - Field: ‘seed’
[10:25:53.908]   - Field: ‘version’
[10:25:53.908]   - Field: ‘result’
[10:25:53.908]   - Field: ‘asynchronous’
[10:25:53.908]   - Field: ‘calls’
[10:25:53.908]   - Field: ‘globals’
[10:25:53.908]   - Field: ‘stdout’
[10:25:53.909]   - Field: ‘earlySignal’
[10:25:53.909]   - Field: ‘lazy’
[10:25:53.909]   - Field: ‘state’
[10:25:53.909] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.909] - Launch lazy future ...
[10:25:53.909] Packages needed by the future expression (n = 1): ‘stats’
[10:25:53.910] Packages needed by future strategies (n = 0): <none>
[10:25:53.910] {
[10:25:53.910]     {
[10:25:53.910]         {
[10:25:53.910]             ...future.startTime <- base::Sys.time()
[10:25:53.910]             {
[10:25:53.910]                 {
[10:25:53.910]                   {
[10:25:53.910]                     {
[10:25:53.910]                       {
[10:25:53.910]                         base::local({
[10:25:53.910]                           has_future <- base::requireNamespace("future", 
[10:25:53.910]                             quietly = TRUE)
[10:25:53.910]                           if (has_future) {
[10:25:53.910]                             ns <- base::getNamespace("future")
[10:25:53.910]                             version <- ns[[".package"]][["version"]]
[10:25:53.910]                             if (is.null(version)) 
[10:25:53.910]                               version <- utils::packageVersion("future")
[10:25:53.910]                           }
[10:25:53.910]                           else {
[10:25:53.910]                             version <- NULL
[10:25:53.910]                           }
[10:25:53.910]                           if (!has_future || version < "1.8.0") {
[10:25:53.910]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.910]                               "", base::R.version$version.string), 
[10:25:53.910]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.910]                                 base::R.version$platform, 8 * 
[10:25:53.910]                                   base::.Machine$sizeof.pointer), 
[10:25:53.910]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.910]                                 "release", "version")], collapse = " "), 
[10:25:53.910]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.910]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.910]                               info)
[10:25:53.910]                             info <- base::paste(info, collapse = "; ")
[10:25:53.910]                             if (!has_future) {
[10:25:53.910]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.910]                                 info)
[10:25:53.910]                             }
[10:25:53.910]                             else {
[10:25:53.910]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.910]                                 info, version)
[10:25:53.910]                             }
[10:25:53.910]                             base::stop(msg)
[10:25:53.910]                           }
[10:25:53.910]                         })
[10:25:53.910]                       }
[10:25:53.910]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.910]                       base::options(mc.cores = 1L)
[10:25:53.910]                     }
[10:25:53.910]                     base::local({
[10:25:53.910]                       for (pkg in "stats") {
[10:25:53.910]                         base::loadNamespace(pkg)
[10:25:53.910]                         base::library(pkg, character.only = TRUE)
[10:25:53.910]                       }
[10:25:53.910]                     })
[10:25:53.910]                   }
[10:25:53.910]                   options(future.plan = NULL)
[10:25:53.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.910]                 }
[10:25:53.910]                 ...future.workdir <- getwd()
[10:25:53.910]             }
[10:25:53.910]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.910]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.910]         }
[10:25:53.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.910]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.910]             base::names(...future.oldOptions))
[10:25:53.910]     }
[10:25:53.910]     if (FALSE) {
[10:25:53.910]     }
[10:25:53.910]     else {
[10:25:53.910]         if (TRUE) {
[10:25:53.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.910]                 open = "w")
[10:25:53.910]         }
[10:25:53.910]         else {
[10:25:53.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.910]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.910]         }
[10:25:53.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.910]             base::sink(type = "output", split = FALSE)
[10:25:53.910]             base::close(...future.stdout)
[10:25:53.910]         }, add = TRUE)
[10:25:53.910]     }
[10:25:53.910]     ...future.frame <- base::sys.nframe()
[10:25:53.910]     ...future.conditions <- base::list()
[10:25:53.910]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.910]     if (FALSE) {
[10:25:53.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.910]     }
[10:25:53.910]     ...future.result <- base::tryCatch({
[10:25:53.910]         base::withCallingHandlers({
[10:25:53.910]             ...future.value <- base::withVisible(base::local({
[10:25:53.910]                 withCallingHandlers({
[10:25:53.910]                   {
[10:25:53.910]                     xtabs(~x)
[10:25:53.910]                   }
[10:25:53.910]                 }, immediateCondition = function(cond) {
[10:25:53.910]                   save_rds <- function (object, pathname, ...) 
[10:25:53.910]                   {
[10:25:53.910]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.910]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.910]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.910]                         fi_tmp[["mtime"]])
[10:25:53.910]                     }
[10:25:53.910]                     tryCatch({
[10:25:53.910]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.910]                     }, error = function(ex) {
[10:25:53.910]                       msg <- conditionMessage(ex)
[10:25:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.910]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.910]                         fi_tmp[["mtime"]], msg)
[10:25:53.910]                       ex$message <- msg
[10:25:53.910]                       stop(ex)
[10:25:53.910]                     })
[10:25:53.910]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.910]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.910]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.910]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.910]                       fi <- file.info(pathname)
[10:25:53.910]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.910]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.910]                         fi[["size"]], fi[["mtime"]])
[10:25:53.910]                       stop(msg)
[10:25:53.910]                     }
[10:25:53.910]                     invisible(pathname)
[10:25:53.910]                   }
[10:25:53.910]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.910]                     rootPath = tempdir()) 
[10:25:53.910]                   {
[10:25:53.910]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.910]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.910]                       tmpdir = path, fileext = ".rds")
[10:25:53.910]                     save_rds(obj, file)
[10:25:53.910]                   }
[10:25:53.910]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.910]                   {
[10:25:53.910]                     inherits <- base::inherits
[10:25:53.910]                     invokeRestart <- base::invokeRestart
[10:25:53.910]                     is.null <- base::is.null
[10:25:53.910]                     muffled <- FALSE
[10:25:53.910]                     if (inherits(cond, "message")) {
[10:25:53.910]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.910]                       if (muffled) 
[10:25:53.910]                         invokeRestart("muffleMessage")
[10:25:53.910]                     }
[10:25:53.910]                     else if (inherits(cond, "warning")) {
[10:25:53.910]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.910]                       if (muffled) 
[10:25:53.910]                         invokeRestart("muffleWarning")
[10:25:53.910]                     }
[10:25:53.910]                     else if (inherits(cond, "condition")) {
[10:25:53.910]                       if (!is.null(pattern)) {
[10:25:53.910]                         computeRestarts <- base::computeRestarts
[10:25:53.910]                         grepl <- base::grepl
[10:25:53.910]                         restarts <- computeRestarts(cond)
[10:25:53.910]                         for (restart in restarts) {
[10:25:53.910]                           name <- restart$name
[10:25:53.910]                           if (is.null(name)) 
[10:25:53.910]                             next
[10:25:53.910]                           if (!grepl(pattern, name)) 
[10:25:53.910]                             next
[10:25:53.910]                           invokeRestart(restart)
[10:25:53.910]                           muffled <- TRUE
[10:25:53.910]                           break
[10:25:53.910]                         }
[10:25:53.910]                       }
[10:25:53.910]                     }
[10:25:53.910]                     invisible(muffled)
[10:25:53.910]                   }
[10:25:53.910]                   muffleCondition(cond)
[10:25:53.910]                 })
[10:25:53.910]             }))
[10:25:53.910]             future::FutureResult(value = ...future.value$value, 
[10:25:53.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.910]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.910]                     ...future.globalenv.names))
[10:25:53.910]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.910]         }, condition = base::local({
[10:25:53.910]             c <- base::c
[10:25:53.910]             inherits <- base::inherits
[10:25:53.910]             invokeRestart <- base::invokeRestart
[10:25:53.910]             length <- base::length
[10:25:53.910]             list <- base::list
[10:25:53.910]             seq.int <- base::seq.int
[10:25:53.910]             signalCondition <- base::signalCondition
[10:25:53.910]             sys.calls <- base::sys.calls
[10:25:53.910]             `[[` <- base::`[[`
[10:25:53.910]             `+` <- base::`+`
[10:25:53.910]             `<<-` <- base::`<<-`
[10:25:53.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.910]                   3L)]
[10:25:53.910]             }
[10:25:53.910]             function(cond) {
[10:25:53.910]                 is_error <- inherits(cond, "error")
[10:25:53.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.910]                   NULL)
[10:25:53.910]                 if (is_error) {
[10:25:53.910]                   sessionInformation <- function() {
[10:25:53.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.910]                       search = base::search(), system = base::Sys.info())
[10:25:53.910]                   }
[10:25:53.910]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.910]                     cond$call), session = sessionInformation(), 
[10:25:53.910]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.910]                   signalCondition(cond)
[10:25:53.910]                 }
[10:25:53.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.910]                 "immediateCondition"))) {
[10:25:53.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.910]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.910]                   if (TRUE && !signal) {
[10:25:53.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.910]                     {
[10:25:53.910]                       inherits <- base::inherits
[10:25:53.910]                       invokeRestart <- base::invokeRestart
[10:25:53.910]                       is.null <- base::is.null
[10:25:53.910]                       muffled <- FALSE
[10:25:53.910]                       if (inherits(cond, "message")) {
[10:25:53.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.910]                         if (muffled) 
[10:25:53.910]                           invokeRestart("muffleMessage")
[10:25:53.910]                       }
[10:25:53.910]                       else if (inherits(cond, "warning")) {
[10:25:53.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.910]                         if (muffled) 
[10:25:53.910]                           invokeRestart("muffleWarning")
[10:25:53.910]                       }
[10:25:53.910]                       else if (inherits(cond, "condition")) {
[10:25:53.910]                         if (!is.null(pattern)) {
[10:25:53.910]                           computeRestarts <- base::computeRestarts
[10:25:53.910]                           grepl <- base::grepl
[10:25:53.910]                           restarts <- computeRestarts(cond)
[10:25:53.910]                           for (restart in restarts) {
[10:25:53.910]                             name <- restart$name
[10:25:53.910]                             if (is.null(name)) 
[10:25:53.910]                               next
[10:25:53.910]                             if (!grepl(pattern, name)) 
[10:25:53.910]                               next
[10:25:53.910]                             invokeRestart(restart)
[10:25:53.910]                             muffled <- TRUE
[10:25:53.910]                             break
[10:25:53.910]                           }
[10:25:53.910]                         }
[10:25:53.910]                       }
[10:25:53.910]                       invisible(muffled)
[10:25:53.910]                     }
[10:25:53.910]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.910]                   }
[10:25:53.910]                 }
[10:25:53.910]                 else {
[10:25:53.910]                   if (TRUE) {
[10:25:53.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.910]                     {
[10:25:53.910]                       inherits <- base::inherits
[10:25:53.910]                       invokeRestart <- base::invokeRestart
[10:25:53.910]                       is.null <- base::is.null
[10:25:53.910]                       muffled <- FALSE
[10:25:53.910]                       if (inherits(cond, "message")) {
[10:25:53.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.910]                         if (muffled) 
[10:25:53.910]                           invokeRestart("muffleMessage")
[10:25:53.910]                       }
[10:25:53.910]                       else if (inherits(cond, "warning")) {
[10:25:53.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.910]                         if (muffled) 
[10:25:53.910]                           invokeRestart("muffleWarning")
[10:25:53.910]                       }
[10:25:53.910]                       else if (inherits(cond, "condition")) {
[10:25:53.910]                         if (!is.null(pattern)) {
[10:25:53.910]                           computeRestarts <- base::computeRestarts
[10:25:53.910]                           grepl <- base::grepl
[10:25:53.910]                           restarts <- computeRestarts(cond)
[10:25:53.910]                           for (restart in restarts) {
[10:25:53.910]                             name <- restart$name
[10:25:53.910]                             if (is.null(name)) 
[10:25:53.910]                               next
[10:25:53.910]                             if (!grepl(pattern, name)) 
[10:25:53.910]                               next
[10:25:53.910]                             invokeRestart(restart)
[10:25:53.910]                             muffled <- TRUE
[10:25:53.910]                             break
[10:25:53.910]                           }
[10:25:53.910]                         }
[10:25:53.910]                       }
[10:25:53.910]                       invisible(muffled)
[10:25:53.910]                     }
[10:25:53.910]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.910]                   }
[10:25:53.910]                 }
[10:25:53.910]             }
[10:25:53.910]         }))
[10:25:53.910]     }, error = function(ex) {
[10:25:53.910]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.910]                 ...future.rng), started = ...future.startTime, 
[10:25:53.910]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.910]             version = "1.8"), class = "FutureResult")
[10:25:53.910]     }, finally = {
[10:25:53.910]         if (!identical(...future.workdir, getwd())) 
[10:25:53.910]             setwd(...future.workdir)
[10:25:53.910]         {
[10:25:53.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.910]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.910]             }
[10:25:53.910]             base::options(...future.oldOptions)
[10:25:53.910]             if (.Platform$OS.type == "windows") {
[10:25:53.910]                 old_names <- names(...future.oldEnvVars)
[10:25:53.910]                 envs <- base::Sys.getenv()
[10:25:53.910]                 names <- names(envs)
[10:25:53.910]                 common <- intersect(names, old_names)
[10:25:53.910]                 added <- setdiff(names, old_names)
[10:25:53.910]                 removed <- setdiff(old_names, names)
[10:25:53.910]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.910]                   envs[common]]
[10:25:53.910]                 NAMES <- toupper(changed)
[10:25:53.910]                 args <- list()
[10:25:53.910]                 for (kk in seq_along(NAMES)) {
[10:25:53.910]                   name <- changed[[kk]]
[10:25:53.910]                   NAME <- NAMES[[kk]]
[10:25:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.910]                     next
[10:25:53.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.910]                 }
[10:25:53.910]                 NAMES <- toupper(added)
[10:25:53.910]                 for (kk in seq_along(NAMES)) {
[10:25:53.910]                   name <- added[[kk]]
[10:25:53.910]                   NAME <- NAMES[[kk]]
[10:25:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.910]                     next
[10:25:53.910]                   args[[name]] <- ""
[10:25:53.910]                 }
[10:25:53.910]                 NAMES <- toupper(removed)
[10:25:53.910]                 for (kk in seq_along(NAMES)) {
[10:25:53.910]                   name <- removed[[kk]]
[10:25:53.910]                   NAME <- NAMES[[kk]]
[10:25:53.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.910]                     next
[10:25:53.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.910]                 }
[10:25:53.910]                 if (length(args) > 0) 
[10:25:53.910]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.910]             }
[10:25:53.910]             else {
[10:25:53.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.910]             }
[10:25:53.910]             {
[10:25:53.910]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.910]                   0L) {
[10:25:53.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.910]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.910]                   base::options(opts)
[10:25:53.910]                 }
[10:25:53.910]                 {
[10:25:53.910]                   {
[10:25:53.910]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.910]                     NULL
[10:25:53.910]                   }
[10:25:53.910]                   options(future.plan = NULL)
[10:25:53.910]                   if (is.na(NA_character_)) 
[10:25:53.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.910]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.910]                     envir = parent.frame()) 
[10:25:53.910]                   {
[10:25:53.910]                     default_workers <- missing(workers)
[10:25:53.910]                     if (is.function(workers)) 
[10:25:53.910]                       workers <- workers()
[10:25:53.910]                     workers <- structure(as.integer(workers), 
[10:25:53.910]                       class = class(workers))
[10:25:53.910]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.910]                       1L)
[10:25:53.910]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.910]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.910]                       if (default_workers) 
[10:25:53.910]                         supportsMulticore(warn = TRUE)
[10:25:53.910]                       return(sequential(..., envir = envir))
[10:25:53.910]                     }
[10:25:53.910]                     oopts <- options(mc.cores = workers)
[10:25:53.910]                     on.exit(options(oopts))
[10:25:53.910]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.910]                       envir = envir)
[10:25:53.910]                     if (!future$lazy) 
[10:25:53.910]                       future <- run(future)
[10:25:53.910]                     invisible(future)
[10:25:53.910]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.910]                 }
[10:25:53.910]             }
[10:25:53.910]         }
[10:25:53.910]     })
[10:25:53.910]     if (TRUE) {
[10:25:53.910]         base::sink(type = "output", split = FALSE)
[10:25:53.910]         if (TRUE) {
[10:25:53.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.910]         }
[10:25:53.910]         else {
[10:25:53.910]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.910]         }
[10:25:53.910]         base::close(...future.stdout)
[10:25:53.910]         ...future.stdout <- NULL
[10:25:53.910]     }
[10:25:53.910]     ...future.result$conditions <- ...future.conditions
[10:25:53.910]     ...future.result$finished <- base::Sys.time()
[10:25:53.910]     ...future.result
[10:25:53.910] }
[10:25:53.913] assign_globals() ...
[10:25:53.913] List of 1
[10:25:53.913]  $ x: num [1:5] 1 1 2 2 2
[10:25:53.913]  - attr(*, "where")=List of 1
[10:25:53.913]   ..$ x:<environment: R_EmptyEnv> 
[10:25:53.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:53.913]  - attr(*, "resolved")= logi FALSE
[10:25:53.913]  - attr(*, "total_size")= num 96
[10:25:53.913]  - attr(*, "already-done")= logi TRUE
[10:25:53.916] - copied ‘x’ to environment
[10:25:53.916] assign_globals() ... done
[10:25:53.917] requestCore(): workers = 2
[10:25:53.919] MulticoreFuture started
[10:25:53.919] - Launch lazy future ... done
[10:25:53.919] run() for ‘MulticoreFuture’ ... done
[10:25:53.920] result() for MulticoreFuture ...
[10:25:53.920] plan(): Setting new future strategy stack:
[10:25:53.920] List of future strategies:
[10:25:53.920] 1. sequential:
[10:25:53.920]    - args: function (..., envir = parent.frame())
[10:25:53.920]    - tweaked: FALSE
[10:25:53.920]    - call: NULL
[10:25:53.921] plan(): nbrOfWorkers() = 1
[10:25:53.924] plan(): Setting new future strategy stack:
[10:25:53.924] List of future strategies:
[10:25:53.924] 1. multicore:
[10:25:53.924]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.924]    - tweaked: FALSE
[10:25:53.924]    - call: plan(strategy)
[10:25:53.929] plan(): nbrOfWorkers() = 2
[10:25:53.930] result() for MulticoreFuture ...
[10:25:53.930] result() for MulticoreFuture ... done
[10:25:53.930] result() for MulticoreFuture ... done
[10:25:53.931] result() for MulticoreFuture ...
[10:25:53.931] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:25:53.933] getGlobalsAndPackages() ...
[10:25:53.933] Searching for globals...
[10:25:53.938] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:25:53.938] Searching for globals ... DONE
[10:25:53.938] Resolving globals: FALSE
[10:25:53.939] 
[10:25:53.939] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.939] getGlobalsAndPackages() ... DONE
[10:25:53.940] run() for ‘Future’ ...
[10:25:53.940] - state: ‘created’
[10:25:53.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.945] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.945]   - Field: ‘label’
[10:25:53.945]   - Field: ‘local’
[10:25:53.946]   - Field: ‘owner’
[10:25:53.946]   - Field: ‘envir’
[10:25:53.946]   - Field: ‘workers’
[10:25:53.946]   - Field: ‘packages’
[10:25:53.946]   - Field: ‘gc’
[10:25:53.946]   - Field: ‘job’
[10:25:53.946]   - Field: ‘conditions’
[10:25:53.947]   - Field: ‘expr’
[10:25:53.947]   - Field: ‘uuid’
[10:25:53.947]   - Field: ‘seed’
[10:25:53.947]   - Field: ‘version’
[10:25:53.947]   - Field: ‘result’
[10:25:53.947]   - Field: ‘asynchronous’
[10:25:53.947]   - Field: ‘calls’
[10:25:53.948]   - Field: ‘globals’
[10:25:53.948]   - Field: ‘stdout’
[10:25:53.948]   - Field: ‘earlySignal’
[10:25:53.948]   - Field: ‘lazy’
[10:25:53.948]   - Field: ‘state’
[10:25:53.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.948] - Launch lazy future ...
[10:25:53.949] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:53.949] Packages needed by future strategies (n = 0): <none>
[10:25:53.949] {
[10:25:53.949]     {
[10:25:53.949]         {
[10:25:53.949]             ...future.startTime <- base::Sys.time()
[10:25:53.949]             {
[10:25:53.949]                 {
[10:25:53.949]                   {
[10:25:53.949]                     {
[10:25:53.949]                       {
[10:25:53.949]                         base::local({
[10:25:53.949]                           has_future <- base::requireNamespace("future", 
[10:25:53.949]                             quietly = TRUE)
[10:25:53.949]                           if (has_future) {
[10:25:53.949]                             ns <- base::getNamespace("future")
[10:25:53.949]                             version <- ns[[".package"]][["version"]]
[10:25:53.949]                             if (is.null(version)) 
[10:25:53.949]                               version <- utils::packageVersion("future")
[10:25:53.949]                           }
[10:25:53.949]                           else {
[10:25:53.949]                             version <- NULL
[10:25:53.949]                           }
[10:25:53.949]                           if (!has_future || version < "1.8.0") {
[10:25:53.949]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:53.949]                               "", base::R.version$version.string), 
[10:25:53.949]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:53.949]                                 base::R.version$platform, 8 * 
[10:25:53.949]                                   base::.Machine$sizeof.pointer), 
[10:25:53.949]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:53.949]                                 "release", "version")], collapse = " "), 
[10:25:53.949]                               hostname = base::Sys.info()[["nodename"]])
[10:25:53.949]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:53.949]                               info)
[10:25:53.949]                             info <- base::paste(info, collapse = "; ")
[10:25:53.949]                             if (!has_future) {
[10:25:53.949]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:53.949]                                 info)
[10:25:53.949]                             }
[10:25:53.949]                             else {
[10:25:53.949]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:53.949]                                 info, version)
[10:25:53.949]                             }
[10:25:53.949]                             base::stop(msg)
[10:25:53.949]                           }
[10:25:53.949]                         })
[10:25:53.949]                       }
[10:25:53.949]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:53.949]                       base::options(mc.cores = 1L)
[10:25:53.949]                     }
[10:25:53.949]                     base::local({
[10:25:53.949]                       for (pkg in c("stats", "datasets")) {
[10:25:53.949]                         base::loadNamespace(pkg)
[10:25:53.949]                         base::library(pkg, character.only = TRUE)
[10:25:53.949]                       }
[10:25:53.949]                     })
[10:25:53.949]                   }
[10:25:53.949]                   options(future.plan = NULL)
[10:25:53.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:53.949]                 }
[10:25:53.949]                 ...future.workdir <- getwd()
[10:25:53.949]             }
[10:25:53.949]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:53.949]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:53.949]         }
[10:25:53.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:53.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:53.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:53.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:53.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:53.949]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:53.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:53.949]             base::names(...future.oldOptions))
[10:25:53.949]     }
[10:25:53.949]     if (FALSE) {
[10:25:53.949]     }
[10:25:53.949]     else {
[10:25:53.949]         if (TRUE) {
[10:25:53.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:53.949]                 open = "w")
[10:25:53.949]         }
[10:25:53.949]         else {
[10:25:53.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:53.949]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:53.949]         }
[10:25:53.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:53.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:53.949]             base::sink(type = "output", split = FALSE)
[10:25:53.949]             base::close(...future.stdout)
[10:25:53.949]         }, add = TRUE)
[10:25:53.949]     }
[10:25:53.949]     ...future.frame <- base::sys.nframe()
[10:25:53.949]     ...future.conditions <- base::list()
[10:25:53.949]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:53.949]     if (FALSE) {
[10:25:53.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:53.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:53.949]     }
[10:25:53.949]     ...future.result <- base::tryCatch({
[10:25:53.949]         base::withCallingHandlers({
[10:25:53.949]             ...future.value <- base::withVisible(base::local({
[10:25:53.949]                 withCallingHandlers({
[10:25:53.949]                   {
[10:25:53.949]                     lm(dist ~ . - 1, data = cars)
[10:25:53.949]                   }
[10:25:53.949]                 }, immediateCondition = function(cond) {
[10:25:53.949]                   save_rds <- function (object, pathname, ...) 
[10:25:53.949]                   {
[10:25:53.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:53.949]                     if (file_test("-f", pathname_tmp)) {
[10:25:53.949]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:53.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.949]                         fi_tmp[["mtime"]])
[10:25:53.949]                     }
[10:25:53.949]                     tryCatch({
[10:25:53.949]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:53.949]                     }, error = function(ex) {
[10:25:53.949]                       msg <- conditionMessage(ex)
[10:25:53.949]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:53.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.949]                         fi_tmp[["mtime"]], msg)
[10:25:53.949]                       ex$message <- msg
[10:25:53.949]                       stop(ex)
[10:25:53.949]                     })
[10:25:53.949]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:53.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:53.949]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:53.949]                       fi_tmp <- file.info(pathname_tmp)
[10:25:53.949]                       fi <- file.info(pathname)
[10:25:53.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:53.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:53.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:53.949]                         fi[["size"]], fi[["mtime"]])
[10:25:53.949]                       stop(msg)
[10:25:53.949]                     }
[10:25:53.949]                     invisible(pathname)
[10:25:53.949]                   }
[10:25:53.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:53.949]                     rootPath = tempdir()) 
[10:25:53.949]                   {
[10:25:53.949]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:53.949]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:53.949]                       tmpdir = path, fileext = ".rds")
[10:25:53.949]                     save_rds(obj, file)
[10:25:53.949]                   }
[10:25:53.949]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:53.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.949]                   {
[10:25:53.949]                     inherits <- base::inherits
[10:25:53.949]                     invokeRestart <- base::invokeRestart
[10:25:53.949]                     is.null <- base::is.null
[10:25:53.949]                     muffled <- FALSE
[10:25:53.949]                     if (inherits(cond, "message")) {
[10:25:53.949]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:53.949]                       if (muffled) 
[10:25:53.949]                         invokeRestart("muffleMessage")
[10:25:53.949]                     }
[10:25:53.949]                     else if (inherits(cond, "warning")) {
[10:25:53.949]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:53.949]                       if (muffled) 
[10:25:53.949]                         invokeRestart("muffleWarning")
[10:25:53.949]                     }
[10:25:53.949]                     else if (inherits(cond, "condition")) {
[10:25:53.949]                       if (!is.null(pattern)) {
[10:25:53.949]                         computeRestarts <- base::computeRestarts
[10:25:53.949]                         grepl <- base::grepl
[10:25:53.949]                         restarts <- computeRestarts(cond)
[10:25:53.949]                         for (restart in restarts) {
[10:25:53.949]                           name <- restart$name
[10:25:53.949]                           if (is.null(name)) 
[10:25:53.949]                             next
[10:25:53.949]                           if (!grepl(pattern, name)) 
[10:25:53.949]                             next
[10:25:53.949]                           invokeRestart(restart)
[10:25:53.949]                           muffled <- TRUE
[10:25:53.949]                           break
[10:25:53.949]                         }
[10:25:53.949]                       }
[10:25:53.949]                     }
[10:25:53.949]                     invisible(muffled)
[10:25:53.949]                   }
[10:25:53.949]                   muffleCondition(cond)
[10:25:53.949]                 })
[10:25:53.949]             }))
[10:25:53.949]             future::FutureResult(value = ...future.value$value, 
[10:25:53.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.949]                   ...future.rng), globalenv = if (FALSE) 
[10:25:53.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:53.949]                     ...future.globalenv.names))
[10:25:53.949]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:53.949]         }, condition = base::local({
[10:25:53.949]             c <- base::c
[10:25:53.949]             inherits <- base::inherits
[10:25:53.949]             invokeRestart <- base::invokeRestart
[10:25:53.949]             length <- base::length
[10:25:53.949]             list <- base::list
[10:25:53.949]             seq.int <- base::seq.int
[10:25:53.949]             signalCondition <- base::signalCondition
[10:25:53.949]             sys.calls <- base::sys.calls
[10:25:53.949]             `[[` <- base::`[[`
[10:25:53.949]             `+` <- base::`+`
[10:25:53.949]             `<<-` <- base::`<<-`
[10:25:53.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:53.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:53.949]                   3L)]
[10:25:53.949]             }
[10:25:53.949]             function(cond) {
[10:25:53.949]                 is_error <- inherits(cond, "error")
[10:25:53.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:53.949]                   NULL)
[10:25:53.949]                 if (is_error) {
[10:25:53.949]                   sessionInformation <- function() {
[10:25:53.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:53.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:53.949]                       search = base::search(), system = base::Sys.info())
[10:25:53.949]                   }
[10:25:53.949]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:53.949]                     cond$call), session = sessionInformation(), 
[10:25:53.949]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:53.949]                   signalCondition(cond)
[10:25:53.949]                 }
[10:25:53.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:53.949]                 "immediateCondition"))) {
[10:25:53.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:53.949]                   ...future.conditions[[length(...future.conditions) + 
[10:25:53.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:53.949]                   if (TRUE && !signal) {
[10:25:53.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.949]                     {
[10:25:53.949]                       inherits <- base::inherits
[10:25:53.949]                       invokeRestart <- base::invokeRestart
[10:25:53.949]                       is.null <- base::is.null
[10:25:53.949]                       muffled <- FALSE
[10:25:53.949]                       if (inherits(cond, "message")) {
[10:25:53.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.949]                         if (muffled) 
[10:25:53.949]                           invokeRestart("muffleMessage")
[10:25:53.949]                       }
[10:25:53.949]                       else if (inherits(cond, "warning")) {
[10:25:53.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.949]                         if (muffled) 
[10:25:53.949]                           invokeRestart("muffleWarning")
[10:25:53.949]                       }
[10:25:53.949]                       else if (inherits(cond, "condition")) {
[10:25:53.949]                         if (!is.null(pattern)) {
[10:25:53.949]                           computeRestarts <- base::computeRestarts
[10:25:53.949]                           grepl <- base::grepl
[10:25:53.949]                           restarts <- computeRestarts(cond)
[10:25:53.949]                           for (restart in restarts) {
[10:25:53.949]                             name <- restart$name
[10:25:53.949]                             if (is.null(name)) 
[10:25:53.949]                               next
[10:25:53.949]                             if (!grepl(pattern, name)) 
[10:25:53.949]                               next
[10:25:53.949]                             invokeRestart(restart)
[10:25:53.949]                             muffled <- TRUE
[10:25:53.949]                             break
[10:25:53.949]                           }
[10:25:53.949]                         }
[10:25:53.949]                       }
[10:25:53.949]                       invisible(muffled)
[10:25:53.949]                     }
[10:25:53.949]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.949]                   }
[10:25:53.949]                 }
[10:25:53.949]                 else {
[10:25:53.949]                   if (TRUE) {
[10:25:53.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:53.949]                     {
[10:25:53.949]                       inherits <- base::inherits
[10:25:53.949]                       invokeRestart <- base::invokeRestart
[10:25:53.949]                       is.null <- base::is.null
[10:25:53.949]                       muffled <- FALSE
[10:25:53.949]                       if (inherits(cond, "message")) {
[10:25:53.949]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:53.949]                         if (muffled) 
[10:25:53.949]                           invokeRestart("muffleMessage")
[10:25:53.949]                       }
[10:25:53.949]                       else if (inherits(cond, "warning")) {
[10:25:53.949]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:53.949]                         if (muffled) 
[10:25:53.949]                           invokeRestart("muffleWarning")
[10:25:53.949]                       }
[10:25:53.949]                       else if (inherits(cond, "condition")) {
[10:25:53.949]                         if (!is.null(pattern)) {
[10:25:53.949]                           computeRestarts <- base::computeRestarts
[10:25:53.949]                           grepl <- base::grepl
[10:25:53.949]                           restarts <- computeRestarts(cond)
[10:25:53.949]                           for (restart in restarts) {
[10:25:53.949]                             name <- restart$name
[10:25:53.949]                             if (is.null(name)) 
[10:25:53.949]                               next
[10:25:53.949]                             if (!grepl(pattern, name)) 
[10:25:53.949]                               next
[10:25:53.949]                             invokeRestart(restart)
[10:25:53.949]                             muffled <- TRUE
[10:25:53.949]                             break
[10:25:53.949]                           }
[10:25:53.949]                         }
[10:25:53.949]                       }
[10:25:53.949]                       invisible(muffled)
[10:25:53.949]                     }
[10:25:53.949]                     muffleCondition(cond, pattern = "^muffle")
[10:25:53.949]                   }
[10:25:53.949]                 }
[10:25:53.949]             }
[10:25:53.949]         }))
[10:25:53.949]     }, error = function(ex) {
[10:25:53.949]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:53.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:53.949]                 ...future.rng), started = ...future.startTime, 
[10:25:53.949]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:53.949]             version = "1.8"), class = "FutureResult")
[10:25:53.949]     }, finally = {
[10:25:53.949]         if (!identical(...future.workdir, getwd())) 
[10:25:53.949]             setwd(...future.workdir)
[10:25:53.949]         {
[10:25:53.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:53.949]                 ...future.oldOptions$nwarnings <- NULL
[10:25:53.949]             }
[10:25:53.949]             base::options(...future.oldOptions)
[10:25:53.949]             if (.Platform$OS.type == "windows") {
[10:25:53.949]                 old_names <- names(...future.oldEnvVars)
[10:25:53.949]                 envs <- base::Sys.getenv()
[10:25:53.949]                 names <- names(envs)
[10:25:53.949]                 common <- intersect(names, old_names)
[10:25:53.949]                 added <- setdiff(names, old_names)
[10:25:53.949]                 removed <- setdiff(old_names, names)
[10:25:53.949]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:53.949]                   envs[common]]
[10:25:53.949]                 NAMES <- toupper(changed)
[10:25:53.949]                 args <- list()
[10:25:53.949]                 for (kk in seq_along(NAMES)) {
[10:25:53.949]                   name <- changed[[kk]]
[10:25:53.949]                   NAME <- NAMES[[kk]]
[10:25:53.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.949]                     next
[10:25:53.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.949]                 }
[10:25:53.949]                 NAMES <- toupper(added)
[10:25:53.949]                 for (kk in seq_along(NAMES)) {
[10:25:53.949]                   name <- added[[kk]]
[10:25:53.949]                   NAME <- NAMES[[kk]]
[10:25:53.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.949]                     next
[10:25:53.949]                   args[[name]] <- ""
[10:25:53.949]                 }
[10:25:53.949]                 NAMES <- toupper(removed)
[10:25:53.949]                 for (kk in seq_along(NAMES)) {
[10:25:53.949]                   name <- removed[[kk]]
[10:25:53.949]                   NAME <- NAMES[[kk]]
[10:25:53.949]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:53.949]                     next
[10:25:53.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:53.949]                 }
[10:25:53.949]                 if (length(args) > 0) 
[10:25:53.949]                   base::do.call(base::Sys.setenv, args = args)
[10:25:53.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:53.949]             }
[10:25:53.949]             else {
[10:25:53.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:53.949]             }
[10:25:53.949]             {
[10:25:53.949]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:53.949]                   0L) {
[10:25:53.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:53.949]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:53.949]                   base::options(opts)
[10:25:53.949]                 }
[10:25:53.949]                 {
[10:25:53.949]                   {
[10:25:53.949]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:53.949]                     NULL
[10:25:53.949]                   }
[10:25:53.949]                   options(future.plan = NULL)
[10:25:53.949]                   if (is.na(NA_character_)) 
[10:25:53.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:53.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:53.949]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:53.949]                     envir = parent.frame()) 
[10:25:53.949]                   {
[10:25:53.949]                     default_workers <- missing(workers)
[10:25:53.949]                     if (is.function(workers)) 
[10:25:53.949]                       workers <- workers()
[10:25:53.949]                     workers <- structure(as.integer(workers), 
[10:25:53.949]                       class = class(workers))
[10:25:53.949]                     stop_if_not(is.finite(workers), workers >= 
[10:25:53.949]                       1L)
[10:25:53.949]                     if ((workers == 1L && !inherits(workers, 
[10:25:53.949]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:53.949]                       if (default_workers) 
[10:25:53.949]                         supportsMulticore(warn = TRUE)
[10:25:53.949]                       return(sequential(..., envir = envir))
[10:25:53.949]                     }
[10:25:53.949]                     oopts <- options(mc.cores = workers)
[10:25:53.949]                     on.exit(options(oopts))
[10:25:53.949]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:53.949]                       envir = envir)
[10:25:53.949]                     if (!future$lazy) 
[10:25:53.949]                       future <- run(future)
[10:25:53.949]                     invisible(future)
[10:25:53.949]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:53.949]                 }
[10:25:53.949]             }
[10:25:53.949]         }
[10:25:53.949]     })
[10:25:53.949]     if (TRUE) {
[10:25:53.949]         base::sink(type = "output", split = FALSE)
[10:25:53.949]         if (TRUE) {
[10:25:53.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:53.949]         }
[10:25:53.949]         else {
[10:25:53.949]             ...future.result["stdout"] <- base::list(NULL)
[10:25:53.949]         }
[10:25:53.949]         base::close(...future.stdout)
[10:25:53.949]         ...future.stdout <- NULL
[10:25:53.949]     }
[10:25:53.949]     ...future.result$conditions <- ...future.conditions
[10:25:53.949]     ...future.result$finished <- base::Sys.time()
[10:25:53.949]     ...future.result
[10:25:53.949] }
[10:25:53.952] requestCore(): workers = 2
[10:25:53.954] MulticoreFuture started
[10:25:53.954] - Launch lazy future ... done
[10:25:53.954] run() for ‘MulticoreFuture’ ... done
[10:25:53.955] result() for MulticoreFuture ...
[10:25:53.955] plan(): Setting new future strategy stack:
[10:25:53.956] List of future strategies:
[10:25:53.956] 1. sequential:
[10:25:53.956]    - args: function (..., envir = parent.frame())
[10:25:53.956]    - tweaked: FALSE
[10:25:53.956]    - call: NULL
[10:25:53.957] plan(): nbrOfWorkers() = 1
[10:25:53.960] plan(): Setting new future strategy stack:
[10:25:53.960] List of future strategies:
[10:25:53.960] 1. multicore:
[10:25:53.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:53.960]    - tweaked: FALSE
[10:25:53.960]    - call: plan(strategy)
[10:25:53.965] plan(): nbrOfWorkers() = 2
[10:25:53.967] result() for MulticoreFuture ...
[10:25:53.967] result() for MulticoreFuture ... done
[10:25:53.967] result() for MulticoreFuture ... done
[10:25:53.967] result() for MulticoreFuture ...
[10:25:53.967] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:25:53.971] getGlobalsAndPackages() ...
[10:25:53.971] Searching for globals...
[10:25:53.973] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:25:53.973] Searching for globals ... DONE
[10:25:53.973] Resolving globals: FALSE
[10:25:53.974] 
[10:25:53.974] - packages: [2] ‘stats’, ‘datasets’
[10:25:53.974] getGlobalsAndPackages() ... DONE
[10:25:53.975] run() for ‘Future’ ...
[10:25:53.975] - state: ‘created’
[10:25:53.975] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:53.979] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:53.979] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:53.979]   - Field: ‘label’
[10:25:53.979]   - Field: ‘local’
[10:25:53.980]   - Field: ‘owner’
[10:25:53.980]   - Field: ‘envir’
[10:25:53.980]   - Field: ‘workers’
[10:25:53.980]   - Field: ‘packages’
[10:25:53.980]   - Field: ‘gc’
[10:25:53.980]   - Field: ‘job’
[10:25:53.980]   - Field: ‘conditions’
[10:25:53.980]   - Field: ‘expr’
[10:25:53.980]   - Field: ‘uuid’
[10:25:53.981]   - Field: ‘seed’
[10:25:53.981]   - Field: ‘version’
[10:25:53.981]   - Field: ‘result’
[10:25:53.981]   - Field: ‘asynchronous’
[10:25:53.981]   - Field: ‘calls’
[10:25:53.981]   - Field: ‘globals’
[10:25:53.981]   - Field: ‘stdout’
[10:25:53.981]   - Field: ‘earlySignal’
[10:25:53.982]   - Field: ‘lazy’
[10:25:53.982]   - Field: ‘state’
[10:25:53.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:53.982] - Launch lazy future ...
[10:25:53.982] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:54.017] Packages needed by future strategies (n = 0): <none>
[10:25:54.018] {
[10:25:54.018]     {
[10:25:54.018]         {
[10:25:54.018]             ...future.startTime <- base::Sys.time()
[10:25:54.018]             {
[10:25:54.018]                 {
[10:25:54.018]                   {
[10:25:54.018]                     {
[10:25:54.018]                       {
[10:25:54.018]                         base::local({
[10:25:54.018]                           has_future <- base::requireNamespace("future", 
[10:25:54.018]                             quietly = TRUE)
[10:25:54.018]                           if (has_future) {
[10:25:54.018]                             ns <- base::getNamespace("future")
[10:25:54.018]                             version <- ns[[".package"]][["version"]]
[10:25:54.018]                             if (is.null(version)) 
[10:25:54.018]                               version <- utils::packageVersion("future")
[10:25:54.018]                           }
[10:25:54.018]                           else {
[10:25:54.018]                             version <- NULL
[10:25:54.018]                           }
[10:25:54.018]                           if (!has_future || version < "1.8.0") {
[10:25:54.018]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.018]                               "", base::R.version$version.string), 
[10:25:54.018]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.018]                                 base::R.version$platform, 8 * 
[10:25:54.018]                                   base::.Machine$sizeof.pointer), 
[10:25:54.018]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.018]                                 "release", "version")], collapse = " "), 
[10:25:54.018]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.018]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.018]                               info)
[10:25:54.018]                             info <- base::paste(info, collapse = "; ")
[10:25:54.018]                             if (!has_future) {
[10:25:54.018]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.018]                                 info)
[10:25:54.018]                             }
[10:25:54.018]                             else {
[10:25:54.018]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.018]                                 info, version)
[10:25:54.018]                             }
[10:25:54.018]                             base::stop(msg)
[10:25:54.018]                           }
[10:25:54.018]                         })
[10:25:54.018]                       }
[10:25:54.018]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.018]                       base::options(mc.cores = 1L)
[10:25:54.018]                     }
[10:25:54.018]                     base::local({
[10:25:54.018]                       for (pkg in c("stats", "datasets")) {
[10:25:54.018]                         base::loadNamespace(pkg)
[10:25:54.018]                         base::library(pkg, character.only = TRUE)
[10:25:54.018]                       }
[10:25:54.018]                     })
[10:25:54.018]                   }
[10:25:54.018]                   options(future.plan = NULL)
[10:25:54.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.018]                 }
[10:25:54.018]                 ...future.workdir <- getwd()
[10:25:54.018]             }
[10:25:54.018]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.018]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.018]         }
[10:25:54.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.018]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.018]             base::names(...future.oldOptions))
[10:25:54.018]     }
[10:25:54.018]     if (FALSE) {
[10:25:54.018]     }
[10:25:54.018]     else {
[10:25:54.018]         if (TRUE) {
[10:25:54.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.018]                 open = "w")
[10:25:54.018]         }
[10:25:54.018]         else {
[10:25:54.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.018]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.018]         }
[10:25:54.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.018]             base::sink(type = "output", split = FALSE)
[10:25:54.018]             base::close(...future.stdout)
[10:25:54.018]         }, add = TRUE)
[10:25:54.018]     }
[10:25:54.018]     ...future.frame <- base::sys.nframe()
[10:25:54.018]     ...future.conditions <- base::list()
[10:25:54.018]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.018]     if (FALSE) {
[10:25:54.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.018]     }
[10:25:54.018]     ...future.result <- base::tryCatch({
[10:25:54.018]         base::withCallingHandlers({
[10:25:54.018]             ...future.value <- base::withVisible(base::local({
[10:25:54.018]                 withCallingHandlers({
[10:25:54.018]                   {
[10:25:54.018]                     lm(dist ~ . + 0, data = cars)
[10:25:54.018]                   }
[10:25:54.018]                 }, immediateCondition = function(cond) {
[10:25:54.018]                   save_rds <- function (object, pathname, ...) 
[10:25:54.018]                   {
[10:25:54.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.018]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.018]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.018]                         fi_tmp[["mtime"]])
[10:25:54.018]                     }
[10:25:54.018]                     tryCatch({
[10:25:54.018]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.018]                     }, error = function(ex) {
[10:25:54.018]                       msg <- conditionMessage(ex)
[10:25:54.018]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.018]                         fi_tmp[["mtime"]], msg)
[10:25:54.018]                       ex$message <- msg
[10:25:54.018]                       stop(ex)
[10:25:54.018]                     })
[10:25:54.018]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.018]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.018]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.018]                       fi <- file.info(pathname)
[10:25:54.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.018]                         fi[["size"]], fi[["mtime"]])
[10:25:54.018]                       stop(msg)
[10:25:54.018]                     }
[10:25:54.018]                     invisible(pathname)
[10:25:54.018]                   }
[10:25:54.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.018]                     rootPath = tempdir()) 
[10:25:54.018]                   {
[10:25:54.018]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.018]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.018]                       tmpdir = path, fileext = ".rds")
[10:25:54.018]                     save_rds(obj, file)
[10:25:54.018]                   }
[10:25:54.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.018]                   {
[10:25:54.018]                     inherits <- base::inherits
[10:25:54.018]                     invokeRestart <- base::invokeRestart
[10:25:54.018]                     is.null <- base::is.null
[10:25:54.018]                     muffled <- FALSE
[10:25:54.018]                     if (inherits(cond, "message")) {
[10:25:54.018]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.018]                       if (muffled) 
[10:25:54.018]                         invokeRestart("muffleMessage")
[10:25:54.018]                     }
[10:25:54.018]                     else if (inherits(cond, "warning")) {
[10:25:54.018]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.018]                       if (muffled) 
[10:25:54.018]                         invokeRestart("muffleWarning")
[10:25:54.018]                     }
[10:25:54.018]                     else if (inherits(cond, "condition")) {
[10:25:54.018]                       if (!is.null(pattern)) {
[10:25:54.018]                         computeRestarts <- base::computeRestarts
[10:25:54.018]                         grepl <- base::grepl
[10:25:54.018]                         restarts <- computeRestarts(cond)
[10:25:54.018]                         for (restart in restarts) {
[10:25:54.018]                           name <- restart$name
[10:25:54.018]                           if (is.null(name)) 
[10:25:54.018]                             next
[10:25:54.018]                           if (!grepl(pattern, name)) 
[10:25:54.018]                             next
[10:25:54.018]                           invokeRestart(restart)
[10:25:54.018]                           muffled <- TRUE
[10:25:54.018]                           break
[10:25:54.018]                         }
[10:25:54.018]                       }
[10:25:54.018]                     }
[10:25:54.018]                     invisible(muffled)
[10:25:54.018]                   }
[10:25:54.018]                   muffleCondition(cond)
[10:25:54.018]                 })
[10:25:54.018]             }))
[10:25:54.018]             future::FutureResult(value = ...future.value$value, 
[10:25:54.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.018]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.018]                     ...future.globalenv.names))
[10:25:54.018]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.018]         }, condition = base::local({
[10:25:54.018]             c <- base::c
[10:25:54.018]             inherits <- base::inherits
[10:25:54.018]             invokeRestart <- base::invokeRestart
[10:25:54.018]             length <- base::length
[10:25:54.018]             list <- base::list
[10:25:54.018]             seq.int <- base::seq.int
[10:25:54.018]             signalCondition <- base::signalCondition
[10:25:54.018]             sys.calls <- base::sys.calls
[10:25:54.018]             `[[` <- base::`[[`
[10:25:54.018]             `+` <- base::`+`
[10:25:54.018]             `<<-` <- base::`<<-`
[10:25:54.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.018]                   3L)]
[10:25:54.018]             }
[10:25:54.018]             function(cond) {
[10:25:54.018]                 is_error <- inherits(cond, "error")
[10:25:54.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.018]                   NULL)
[10:25:54.018]                 if (is_error) {
[10:25:54.018]                   sessionInformation <- function() {
[10:25:54.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.018]                       search = base::search(), system = base::Sys.info())
[10:25:54.018]                   }
[10:25:54.018]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.018]                     cond$call), session = sessionInformation(), 
[10:25:54.018]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.018]                   signalCondition(cond)
[10:25:54.018]                 }
[10:25:54.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.018]                 "immediateCondition"))) {
[10:25:54.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.018]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.018]                   if (TRUE && !signal) {
[10:25:54.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.018]                     {
[10:25:54.018]                       inherits <- base::inherits
[10:25:54.018]                       invokeRestart <- base::invokeRestart
[10:25:54.018]                       is.null <- base::is.null
[10:25:54.018]                       muffled <- FALSE
[10:25:54.018]                       if (inherits(cond, "message")) {
[10:25:54.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.018]                         if (muffled) 
[10:25:54.018]                           invokeRestart("muffleMessage")
[10:25:54.018]                       }
[10:25:54.018]                       else if (inherits(cond, "warning")) {
[10:25:54.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.018]                         if (muffled) 
[10:25:54.018]                           invokeRestart("muffleWarning")
[10:25:54.018]                       }
[10:25:54.018]                       else if (inherits(cond, "condition")) {
[10:25:54.018]                         if (!is.null(pattern)) {
[10:25:54.018]                           computeRestarts <- base::computeRestarts
[10:25:54.018]                           grepl <- base::grepl
[10:25:54.018]                           restarts <- computeRestarts(cond)
[10:25:54.018]                           for (restart in restarts) {
[10:25:54.018]                             name <- restart$name
[10:25:54.018]                             if (is.null(name)) 
[10:25:54.018]                               next
[10:25:54.018]                             if (!grepl(pattern, name)) 
[10:25:54.018]                               next
[10:25:54.018]                             invokeRestart(restart)
[10:25:54.018]                             muffled <- TRUE
[10:25:54.018]                             break
[10:25:54.018]                           }
[10:25:54.018]                         }
[10:25:54.018]                       }
[10:25:54.018]                       invisible(muffled)
[10:25:54.018]                     }
[10:25:54.018]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.018]                   }
[10:25:54.018]                 }
[10:25:54.018]                 else {
[10:25:54.018]                   if (TRUE) {
[10:25:54.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.018]                     {
[10:25:54.018]                       inherits <- base::inherits
[10:25:54.018]                       invokeRestart <- base::invokeRestart
[10:25:54.018]                       is.null <- base::is.null
[10:25:54.018]                       muffled <- FALSE
[10:25:54.018]                       if (inherits(cond, "message")) {
[10:25:54.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.018]                         if (muffled) 
[10:25:54.018]                           invokeRestart("muffleMessage")
[10:25:54.018]                       }
[10:25:54.018]                       else if (inherits(cond, "warning")) {
[10:25:54.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.018]                         if (muffled) 
[10:25:54.018]                           invokeRestart("muffleWarning")
[10:25:54.018]                       }
[10:25:54.018]                       else if (inherits(cond, "condition")) {
[10:25:54.018]                         if (!is.null(pattern)) {
[10:25:54.018]                           computeRestarts <- base::computeRestarts
[10:25:54.018]                           grepl <- base::grepl
[10:25:54.018]                           restarts <- computeRestarts(cond)
[10:25:54.018]                           for (restart in restarts) {
[10:25:54.018]                             name <- restart$name
[10:25:54.018]                             if (is.null(name)) 
[10:25:54.018]                               next
[10:25:54.018]                             if (!grepl(pattern, name)) 
[10:25:54.018]                               next
[10:25:54.018]                             invokeRestart(restart)
[10:25:54.018]                             muffled <- TRUE
[10:25:54.018]                             break
[10:25:54.018]                           }
[10:25:54.018]                         }
[10:25:54.018]                       }
[10:25:54.018]                       invisible(muffled)
[10:25:54.018]                     }
[10:25:54.018]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.018]                   }
[10:25:54.018]                 }
[10:25:54.018]             }
[10:25:54.018]         }))
[10:25:54.018]     }, error = function(ex) {
[10:25:54.018]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.018]                 ...future.rng), started = ...future.startTime, 
[10:25:54.018]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.018]             version = "1.8"), class = "FutureResult")
[10:25:54.018]     }, finally = {
[10:25:54.018]         if (!identical(...future.workdir, getwd())) 
[10:25:54.018]             setwd(...future.workdir)
[10:25:54.018]         {
[10:25:54.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.018]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.018]             }
[10:25:54.018]             base::options(...future.oldOptions)
[10:25:54.018]             if (.Platform$OS.type == "windows") {
[10:25:54.018]                 old_names <- names(...future.oldEnvVars)
[10:25:54.018]                 envs <- base::Sys.getenv()
[10:25:54.018]                 names <- names(envs)
[10:25:54.018]                 common <- intersect(names, old_names)
[10:25:54.018]                 added <- setdiff(names, old_names)
[10:25:54.018]                 removed <- setdiff(old_names, names)
[10:25:54.018]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.018]                   envs[common]]
[10:25:54.018]                 NAMES <- toupper(changed)
[10:25:54.018]                 args <- list()
[10:25:54.018]                 for (kk in seq_along(NAMES)) {
[10:25:54.018]                   name <- changed[[kk]]
[10:25:54.018]                   NAME <- NAMES[[kk]]
[10:25:54.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.018]                     next
[10:25:54.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.018]                 }
[10:25:54.018]                 NAMES <- toupper(added)
[10:25:54.018]                 for (kk in seq_along(NAMES)) {
[10:25:54.018]                   name <- added[[kk]]
[10:25:54.018]                   NAME <- NAMES[[kk]]
[10:25:54.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.018]                     next
[10:25:54.018]                   args[[name]] <- ""
[10:25:54.018]                 }
[10:25:54.018]                 NAMES <- toupper(removed)
[10:25:54.018]                 for (kk in seq_along(NAMES)) {
[10:25:54.018]                   name <- removed[[kk]]
[10:25:54.018]                   NAME <- NAMES[[kk]]
[10:25:54.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.018]                     next
[10:25:54.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.018]                 }
[10:25:54.018]                 if (length(args) > 0) 
[10:25:54.018]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.018]             }
[10:25:54.018]             else {
[10:25:54.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.018]             }
[10:25:54.018]             {
[10:25:54.018]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.018]                   0L) {
[10:25:54.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.018]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.018]                   base::options(opts)
[10:25:54.018]                 }
[10:25:54.018]                 {
[10:25:54.018]                   {
[10:25:54.018]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.018]                     NULL
[10:25:54.018]                   }
[10:25:54.018]                   options(future.plan = NULL)
[10:25:54.018]                   if (is.na(NA_character_)) 
[10:25:54.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.018]                     envir = parent.frame()) 
[10:25:54.018]                   {
[10:25:54.018]                     default_workers <- missing(workers)
[10:25:54.018]                     if (is.function(workers)) 
[10:25:54.018]                       workers <- workers()
[10:25:54.018]                     workers <- structure(as.integer(workers), 
[10:25:54.018]                       class = class(workers))
[10:25:54.018]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.018]                       1L)
[10:25:54.018]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.018]                       if (default_workers) 
[10:25:54.018]                         supportsMulticore(warn = TRUE)
[10:25:54.018]                       return(sequential(..., envir = envir))
[10:25:54.018]                     }
[10:25:54.018]                     oopts <- options(mc.cores = workers)
[10:25:54.018]                     on.exit(options(oopts))
[10:25:54.018]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.018]                       envir = envir)
[10:25:54.018]                     if (!future$lazy) 
[10:25:54.018]                       future <- run(future)
[10:25:54.018]                     invisible(future)
[10:25:54.018]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.018]                 }
[10:25:54.018]             }
[10:25:54.018]         }
[10:25:54.018]     })
[10:25:54.018]     if (TRUE) {
[10:25:54.018]         base::sink(type = "output", split = FALSE)
[10:25:54.018]         if (TRUE) {
[10:25:54.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.018]         }
[10:25:54.018]         else {
[10:25:54.018]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.018]         }
[10:25:54.018]         base::close(...future.stdout)
[10:25:54.018]         ...future.stdout <- NULL
[10:25:54.018]     }
[10:25:54.018]     ...future.result$conditions <- ...future.conditions
[10:25:54.018]     ...future.result$finished <- base::Sys.time()
[10:25:54.018]     ...future.result
[10:25:54.018] }
[10:25:54.020] requestCore(): workers = 2
[10:25:54.023] MulticoreFuture started
[10:25:54.024] - Launch lazy future ... done
[10:25:54.024] run() for ‘MulticoreFuture’ ... done
[10:25:54.025] result() for MulticoreFuture ...
[10:25:54.025] plan(): Setting new future strategy stack:
[10:25:54.025] List of future strategies:
[10:25:54.025] 1. sequential:
[10:25:54.025]    - args: function (..., envir = parent.frame())
[10:25:54.025]    - tweaked: FALSE
[10:25:54.025]    - call: NULL
[10:25:54.026] plan(): nbrOfWorkers() = 1
[10:25:54.031] plan(): Setting new future strategy stack:
[10:25:54.031] List of future strategies:
[10:25:54.031] 1. multicore:
[10:25:54.031]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.031]    - tweaked: FALSE
[10:25:54.031]    - call: plan(strategy)
[10:25:54.036] plan(): nbrOfWorkers() = 2
[10:25:54.038] result() for MulticoreFuture ...
[10:25:54.039] result() for MulticoreFuture ... done
[10:25:54.039] result() for MulticoreFuture ... done
[10:25:54.039] result() for MulticoreFuture ...
[10:25:54.039] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:25:54.043] getGlobalsAndPackages() ...
[10:25:54.043] Searching for globals...
[10:25:54.046] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:25:54.046] Searching for globals ... DONE
[10:25:54.046] Resolving globals: FALSE
[10:25:54.047] 
[10:25:54.047] - packages: [2] ‘stats’, ‘datasets’
[10:25:54.047] getGlobalsAndPackages() ... DONE
[10:25:54.047] run() for ‘Future’ ...
[10:25:54.047] - state: ‘created’
[10:25:54.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.052] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:54.052]   - Field: ‘label’
[10:25:54.052]   - Field: ‘local’
[10:25:54.052]   - Field: ‘owner’
[10:25:54.052]   - Field: ‘envir’
[10:25:54.052]   - Field: ‘workers’
[10:25:54.053]   - Field: ‘packages’
[10:25:54.053]   - Field: ‘gc’
[10:25:54.053]   - Field: ‘job’
[10:25:54.053]   - Field: ‘conditions’
[10:25:54.053]   - Field: ‘expr’
[10:25:54.053]   - Field: ‘uuid’
[10:25:54.053]   - Field: ‘seed’
[10:25:54.053]   - Field: ‘version’
[10:25:54.053]   - Field: ‘result’
[10:25:54.054]   - Field: ‘asynchronous’
[10:25:54.054]   - Field: ‘calls’
[10:25:54.054]   - Field: ‘globals’
[10:25:54.054]   - Field: ‘stdout’
[10:25:54.054]   - Field: ‘earlySignal’
[10:25:54.054]   - Field: ‘lazy’
[10:25:54.054]   - Field: ‘state’
[10:25:54.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:54.054] - Launch lazy future ...
[10:25:54.055] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:54.055] Packages needed by future strategies (n = 0): <none>
[10:25:54.056] {
[10:25:54.056]     {
[10:25:54.056]         {
[10:25:54.056]             ...future.startTime <- base::Sys.time()
[10:25:54.056]             {
[10:25:54.056]                 {
[10:25:54.056]                   {
[10:25:54.056]                     {
[10:25:54.056]                       {
[10:25:54.056]                         base::local({
[10:25:54.056]                           has_future <- base::requireNamespace("future", 
[10:25:54.056]                             quietly = TRUE)
[10:25:54.056]                           if (has_future) {
[10:25:54.056]                             ns <- base::getNamespace("future")
[10:25:54.056]                             version <- ns[[".package"]][["version"]]
[10:25:54.056]                             if (is.null(version)) 
[10:25:54.056]                               version <- utils::packageVersion("future")
[10:25:54.056]                           }
[10:25:54.056]                           else {
[10:25:54.056]                             version <- NULL
[10:25:54.056]                           }
[10:25:54.056]                           if (!has_future || version < "1.8.0") {
[10:25:54.056]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.056]                               "", base::R.version$version.string), 
[10:25:54.056]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.056]                                 base::R.version$platform, 8 * 
[10:25:54.056]                                   base::.Machine$sizeof.pointer), 
[10:25:54.056]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.056]                                 "release", "version")], collapse = " "), 
[10:25:54.056]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.056]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.056]                               info)
[10:25:54.056]                             info <- base::paste(info, collapse = "; ")
[10:25:54.056]                             if (!has_future) {
[10:25:54.056]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.056]                                 info)
[10:25:54.056]                             }
[10:25:54.056]                             else {
[10:25:54.056]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.056]                                 info, version)
[10:25:54.056]                             }
[10:25:54.056]                             base::stop(msg)
[10:25:54.056]                           }
[10:25:54.056]                         })
[10:25:54.056]                       }
[10:25:54.056]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.056]                       base::options(mc.cores = 1L)
[10:25:54.056]                     }
[10:25:54.056]                     base::local({
[10:25:54.056]                       for (pkg in c("stats", "datasets")) {
[10:25:54.056]                         base::loadNamespace(pkg)
[10:25:54.056]                         base::library(pkg, character.only = TRUE)
[10:25:54.056]                       }
[10:25:54.056]                     })
[10:25:54.056]                   }
[10:25:54.056]                   options(future.plan = NULL)
[10:25:54.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.056]                 }
[10:25:54.056]                 ...future.workdir <- getwd()
[10:25:54.056]             }
[10:25:54.056]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.056]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.056]         }
[10:25:54.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.056]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.056]             base::names(...future.oldOptions))
[10:25:54.056]     }
[10:25:54.056]     if (FALSE) {
[10:25:54.056]     }
[10:25:54.056]     else {
[10:25:54.056]         if (TRUE) {
[10:25:54.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.056]                 open = "w")
[10:25:54.056]         }
[10:25:54.056]         else {
[10:25:54.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.056]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.056]         }
[10:25:54.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.056]             base::sink(type = "output", split = FALSE)
[10:25:54.056]             base::close(...future.stdout)
[10:25:54.056]         }, add = TRUE)
[10:25:54.056]     }
[10:25:54.056]     ...future.frame <- base::sys.nframe()
[10:25:54.056]     ...future.conditions <- base::list()
[10:25:54.056]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.056]     if (FALSE) {
[10:25:54.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.056]     }
[10:25:54.056]     ...future.result <- base::tryCatch({
[10:25:54.056]         base::withCallingHandlers({
[10:25:54.056]             ...future.value <- base::withVisible(base::local({
[10:25:54.056]                 withCallingHandlers({
[10:25:54.056]                   {
[10:25:54.056]                     lm(dist ~ speed + speed^2, data = cars)
[10:25:54.056]                   }
[10:25:54.056]                 }, immediateCondition = function(cond) {
[10:25:54.056]                   save_rds <- function (object, pathname, ...) 
[10:25:54.056]                   {
[10:25:54.056]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.056]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.056]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.056]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.056]                         fi_tmp[["mtime"]])
[10:25:54.056]                     }
[10:25:54.056]                     tryCatch({
[10:25:54.056]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.056]                     }, error = function(ex) {
[10:25:54.056]                       msg <- conditionMessage(ex)
[10:25:54.056]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.056]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.056]                         fi_tmp[["mtime"]], msg)
[10:25:54.056]                       ex$message <- msg
[10:25:54.056]                       stop(ex)
[10:25:54.056]                     })
[10:25:54.056]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.056]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.056]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.056]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.056]                       fi <- file.info(pathname)
[10:25:54.056]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.056]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.056]                         fi[["size"]], fi[["mtime"]])
[10:25:54.056]                       stop(msg)
[10:25:54.056]                     }
[10:25:54.056]                     invisible(pathname)
[10:25:54.056]                   }
[10:25:54.056]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.056]                     rootPath = tempdir()) 
[10:25:54.056]                   {
[10:25:54.056]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.056]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.056]                       tmpdir = path, fileext = ".rds")
[10:25:54.056]                     save_rds(obj, file)
[10:25:54.056]                   }
[10:25:54.056]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.056]                   {
[10:25:54.056]                     inherits <- base::inherits
[10:25:54.056]                     invokeRestart <- base::invokeRestart
[10:25:54.056]                     is.null <- base::is.null
[10:25:54.056]                     muffled <- FALSE
[10:25:54.056]                     if (inherits(cond, "message")) {
[10:25:54.056]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.056]                       if (muffled) 
[10:25:54.056]                         invokeRestart("muffleMessage")
[10:25:54.056]                     }
[10:25:54.056]                     else if (inherits(cond, "warning")) {
[10:25:54.056]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.056]                       if (muffled) 
[10:25:54.056]                         invokeRestart("muffleWarning")
[10:25:54.056]                     }
[10:25:54.056]                     else if (inherits(cond, "condition")) {
[10:25:54.056]                       if (!is.null(pattern)) {
[10:25:54.056]                         computeRestarts <- base::computeRestarts
[10:25:54.056]                         grepl <- base::grepl
[10:25:54.056]                         restarts <- computeRestarts(cond)
[10:25:54.056]                         for (restart in restarts) {
[10:25:54.056]                           name <- restart$name
[10:25:54.056]                           if (is.null(name)) 
[10:25:54.056]                             next
[10:25:54.056]                           if (!grepl(pattern, name)) 
[10:25:54.056]                             next
[10:25:54.056]                           invokeRestart(restart)
[10:25:54.056]                           muffled <- TRUE
[10:25:54.056]                           break
[10:25:54.056]                         }
[10:25:54.056]                       }
[10:25:54.056]                     }
[10:25:54.056]                     invisible(muffled)
[10:25:54.056]                   }
[10:25:54.056]                   muffleCondition(cond)
[10:25:54.056]                 })
[10:25:54.056]             }))
[10:25:54.056]             future::FutureResult(value = ...future.value$value, 
[10:25:54.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.056]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.056]                     ...future.globalenv.names))
[10:25:54.056]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.056]         }, condition = base::local({
[10:25:54.056]             c <- base::c
[10:25:54.056]             inherits <- base::inherits
[10:25:54.056]             invokeRestart <- base::invokeRestart
[10:25:54.056]             length <- base::length
[10:25:54.056]             list <- base::list
[10:25:54.056]             seq.int <- base::seq.int
[10:25:54.056]             signalCondition <- base::signalCondition
[10:25:54.056]             sys.calls <- base::sys.calls
[10:25:54.056]             `[[` <- base::`[[`
[10:25:54.056]             `+` <- base::`+`
[10:25:54.056]             `<<-` <- base::`<<-`
[10:25:54.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.056]                   3L)]
[10:25:54.056]             }
[10:25:54.056]             function(cond) {
[10:25:54.056]                 is_error <- inherits(cond, "error")
[10:25:54.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.056]                   NULL)
[10:25:54.056]                 if (is_error) {
[10:25:54.056]                   sessionInformation <- function() {
[10:25:54.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.056]                       search = base::search(), system = base::Sys.info())
[10:25:54.056]                   }
[10:25:54.056]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.056]                     cond$call), session = sessionInformation(), 
[10:25:54.056]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.056]                   signalCondition(cond)
[10:25:54.056]                 }
[10:25:54.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.056]                 "immediateCondition"))) {
[10:25:54.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.056]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.056]                   if (TRUE && !signal) {
[10:25:54.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.056]                     {
[10:25:54.056]                       inherits <- base::inherits
[10:25:54.056]                       invokeRestart <- base::invokeRestart
[10:25:54.056]                       is.null <- base::is.null
[10:25:54.056]                       muffled <- FALSE
[10:25:54.056]                       if (inherits(cond, "message")) {
[10:25:54.056]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.056]                         if (muffled) 
[10:25:54.056]                           invokeRestart("muffleMessage")
[10:25:54.056]                       }
[10:25:54.056]                       else if (inherits(cond, "warning")) {
[10:25:54.056]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.056]                         if (muffled) 
[10:25:54.056]                           invokeRestart("muffleWarning")
[10:25:54.056]                       }
[10:25:54.056]                       else if (inherits(cond, "condition")) {
[10:25:54.056]                         if (!is.null(pattern)) {
[10:25:54.056]                           computeRestarts <- base::computeRestarts
[10:25:54.056]                           grepl <- base::grepl
[10:25:54.056]                           restarts <- computeRestarts(cond)
[10:25:54.056]                           for (restart in restarts) {
[10:25:54.056]                             name <- restart$name
[10:25:54.056]                             if (is.null(name)) 
[10:25:54.056]                               next
[10:25:54.056]                             if (!grepl(pattern, name)) 
[10:25:54.056]                               next
[10:25:54.056]                             invokeRestart(restart)
[10:25:54.056]                             muffled <- TRUE
[10:25:54.056]                             break
[10:25:54.056]                           }
[10:25:54.056]                         }
[10:25:54.056]                       }
[10:25:54.056]                       invisible(muffled)
[10:25:54.056]                     }
[10:25:54.056]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.056]                   }
[10:25:54.056]                 }
[10:25:54.056]                 else {
[10:25:54.056]                   if (TRUE) {
[10:25:54.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.056]                     {
[10:25:54.056]                       inherits <- base::inherits
[10:25:54.056]                       invokeRestart <- base::invokeRestart
[10:25:54.056]                       is.null <- base::is.null
[10:25:54.056]                       muffled <- FALSE
[10:25:54.056]                       if (inherits(cond, "message")) {
[10:25:54.056]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.056]                         if (muffled) 
[10:25:54.056]                           invokeRestart("muffleMessage")
[10:25:54.056]                       }
[10:25:54.056]                       else if (inherits(cond, "warning")) {
[10:25:54.056]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.056]                         if (muffled) 
[10:25:54.056]                           invokeRestart("muffleWarning")
[10:25:54.056]                       }
[10:25:54.056]                       else if (inherits(cond, "condition")) {
[10:25:54.056]                         if (!is.null(pattern)) {
[10:25:54.056]                           computeRestarts <- base::computeRestarts
[10:25:54.056]                           grepl <- base::grepl
[10:25:54.056]                           restarts <- computeRestarts(cond)
[10:25:54.056]                           for (restart in restarts) {
[10:25:54.056]                             name <- restart$name
[10:25:54.056]                             if (is.null(name)) 
[10:25:54.056]                               next
[10:25:54.056]                             if (!grepl(pattern, name)) 
[10:25:54.056]                               next
[10:25:54.056]                             invokeRestart(restart)
[10:25:54.056]                             muffled <- TRUE
[10:25:54.056]                             break
[10:25:54.056]                           }
[10:25:54.056]                         }
[10:25:54.056]                       }
[10:25:54.056]                       invisible(muffled)
[10:25:54.056]                     }
[10:25:54.056]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.056]                   }
[10:25:54.056]                 }
[10:25:54.056]             }
[10:25:54.056]         }))
[10:25:54.056]     }, error = function(ex) {
[10:25:54.056]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.056]                 ...future.rng), started = ...future.startTime, 
[10:25:54.056]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.056]             version = "1.8"), class = "FutureResult")
[10:25:54.056]     }, finally = {
[10:25:54.056]         if (!identical(...future.workdir, getwd())) 
[10:25:54.056]             setwd(...future.workdir)
[10:25:54.056]         {
[10:25:54.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.056]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.056]             }
[10:25:54.056]             base::options(...future.oldOptions)
[10:25:54.056]             if (.Platform$OS.type == "windows") {
[10:25:54.056]                 old_names <- names(...future.oldEnvVars)
[10:25:54.056]                 envs <- base::Sys.getenv()
[10:25:54.056]                 names <- names(envs)
[10:25:54.056]                 common <- intersect(names, old_names)
[10:25:54.056]                 added <- setdiff(names, old_names)
[10:25:54.056]                 removed <- setdiff(old_names, names)
[10:25:54.056]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.056]                   envs[common]]
[10:25:54.056]                 NAMES <- toupper(changed)
[10:25:54.056]                 args <- list()
[10:25:54.056]                 for (kk in seq_along(NAMES)) {
[10:25:54.056]                   name <- changed[[kk]]
[10:25:54.056]                   NAME <- NAMES[[kk]]
[10:25:54.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.056]                     next
[10:25:54.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.056]                 }
[10:25:54.056]                 NAMES <- toupper(added)
[10:25:54.056]                 for (kk in seq_along(NAMES)) {
[10:25:54.056]                   name <- added[[kk]]
[10:25:54.056]                   NAME <- NAMES[[kk]]
[10:25:54.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.056]                     next
[10:25:54.056]                   args[[name]] <- ""
[10:25:54.056]                 }
[10:25:54.056]                 NAMES <- toupper(removed)
[10:25:54.056]                 for (kk in seq_along(NAMES)) {
[10:25:54.056]                   name <- removed[[kk]]
[10:25:54.056]                   NAME <- NAMES[[kk]]
[10:25:54.056]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.056]                     next
[10:25:54.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.056]                 }
[10:25:54.056]                 if (length(args) > 0) 
[10:25:54.056]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.056]             }
[10:25:54.056]             else {
[10:25:54.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.056]             }
[10:25:54.056]             {
[10:25:54.056]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.056]                   0L) {
[10:25:54.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.056]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.056]                   base::options(opts)
[10:25:54.056]                 }
[10:25:54.056]                 {
[10:25:54.056]                   {
[10:25:54.056]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.056]                     NULL
[10:25:54.056]                   }
[10:25:54.056]                   options(future.plan = NULL)
[10:25:54.056]                   if (is.na(NA_character_)) 
[10:25:54.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.056]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.056]                     envir = parent.frame()) 
[10:25:54.056]                   {
[10:25:54.056]                     default_workers <- missing(workers)
[10:25:54.056]                     if (is.function(workers)) 
[10:25:54.056]                       workers <- workers()
[10:25:54.056]                     workers <- structure(as.integer(workers), 
[10:25:54.056]                       class = class(workers))
[10:25:54.056]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.056]                       1L)
[10:25:54.056]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.056]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.056]                       if (default_workers) 
[10:25:54.056]                         supportsMulticore(warn = TRUE)
[10:25:54.056]                       return(sequential(..., envir = envir))
[10:25:54.056]                     }
[10:25:54.056]                     oopts <- options(mc.cores = workers)
[10:25:54.056]                     on.exit(options(oopts))
[10:25:54.056]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.056]                       envir = envir)
[10:25:54.056]                     if (!future$lazy) 
[10:25:54.056]                       future <- run(future)
[10:25:54.056]                     invisible(future)
[10:25:54.056]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.056]                 }
[10:25:54.056]             }
[10:25:54.056]         }
[10:25:54.056]     })
[10:25:54.056]     if (TRUE) {
[10:25:54.056]         base::sink(type = "output", split = FALSE)
[10:25:54.056]         if (TRUE) {
[10:25:54.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.056]         }
[10:25:54.056]         else {
[10:25:54.056]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.056]         }
[10:25:54.056]         base::close(...future.stdout)
[10:25:54.056]         ...future.stdout <- NULL
[10:25:54.056]     }
[10:25:54.056]     ...future.result$conditions <- ...future.conditions
[10:25:54.056]     ...future.result$finished <- base::Sys.time()
[10:25:54.056]     ...future.result
[10:25:54.056] }
[10:25:54.058] requestCore(): workers = 2
[10:25:54.060] MulticoreFuture started
[10:25:54.061] - Launch lazy future ... done
[10:25:54.061] run() for ‘MulticoreFuture’ ... done
[10:25:54.061] result() for MulticoreFuture ...
[10:25:54.062] plan(): Setting new future strategy stack:
[10:25:54.062] List of future strategies:
[10:25:54.062] 1. sequential:
[10:25:54.062]    - args: function (..., envir = parent.frame())
[10:25:54.062]    - tweaked: FALSE
[10:25:54.062]    - call: NULL
[10:25:54.063] plan(): nbrOfWorkers() = 1
[10:25:54.066] plan(): Setting new future strategy stack:
[10:25:54.067] List of future strategies:
[10:25:54.067] 1. multicore:
[10:25:54.067]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.067]    - tweaked: FALSE
[10:25:54.067]    - call: plan(strategy)
[10:25:54.072] plan(): nbrOfWorkers() = 2
[10:25:54.074] result() for MulticoreFuture ...
[10:25:54.074] result() for MulticoreFuture ... done
[10:25:54.074] result() for MulticoreFuture ... done
[10:25:54.075] result() for MulticoreFuture ...
[10:25:54.075] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:25:54.078] getGlobalsAndPackages() ...
[10:25:54.078] Searching for globals...
[10:25:54.081] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:25:54.081] Searching for globals ... DONE
[10:25:54.081] Resolving globals: FALSE
[10:25:54.082] 
[10:25:54.082] - packages: [2] ‘stats’, ‘datasets’
[10:25:54.082] getGlobalsAndPackages() ... DONE
[10:25:54.083] run() for ‘Future’ ...
[10:25:54.083] - state: ‘created’
[10:25:54.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.090] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:54.090]   - Field: ‘label’
[10:25:54.090]   - Field: ‘local’
[10:25:54.090]   - Field: ‘owner’
[10:25:54.090]   - Field: ‘envir’
[10:25:54.091]   - Field: ‘workers’
[10:25:54.091]   - Field: ‘packages’
[10:25:54.091]   - Field: ‘gc’
[10:25:54.091]   - Field: ‘job’
[10:25:54.091]   - Field: ‘conditions’
[10:25:54.091]   - Field: ‘expr’
[10:25:54.091]   - Field: ‘uuid’
[10:25:54.091]   - Field: ‘seed’
[10:25:54.092]   - Field: ‘version’
[10:25:54.092]   - Field: ‘result’
[10:25:54.092]   - Field: ‘asynchronous’
[10:25:54.092]   - Field: ‘calls’
[10:25:54.092]   - Field: ‘globals’
[10:25:54.092]   - Field: ‘stdout’
[10:25:54.092]   - Field: ‘earlySignal’
[10:25:54.092]   - Field: ‘lazy’
[10:25:54.092]   - Field: ‘state’
[10:25:54.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:54.093] - Launch lazy future ...
[10:25:54.093] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:54.093] Packages needed by future strategies (n = 0): <none>
[10:25:54.094] {
[10:25:54.094]     {
[10:25:54.094]         {
[10:25:54.094]             ...future.startTime <- base::Sys.time()
[10:25:54.094]             {
[10:25:54.094]                 {
[10:25:54.094]                   {
[10:25:54.094]                     {
[10:25:54.094]                       {
[10:25:54.094]                         base::local({
[10:25:54.094]                           has_future <- base::requireNamespace("future", 
[10:25:54.094]                             quietly = TRUE)
[10:25:54.094]                           if (has_future) {
[10:25:54.094]                             ns <- base::getNamespace("future")
[10:25:54.094]                             version <- ns[[".package"]][["version"]]
[10:25:54.094]                             if (is.null(version)) 
[10:25:54.094]                               version <- utils::packageVersion("future")
[10:25:54.094]                           }
[10:25:54.094]                           else {
[10:25:54.094]                             version <- NULL
[10:25:54.094]                           }
[10:25:54.094]                           if (!has_future || version < "1.8.0") {
[10:25:54.094]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.094]                               "", base::R.version$version.string), 
[10:25:54.094]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.094]                                 base::R.version$platform, 8 * 
[10:25:54.094]                                   base::.Machine$sizeof.pointer), 
[10:25:54.094]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.094]                                 "release", "version")], collapse = " "), 
[10:25:54.094]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.094]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.094]                               info)
[10:25:54.094]                             info <- base::paste(info, collapse = "; ")
[10:25:54.094]                             if (!has_future) {
[10:25:54.094]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.094]                                 info)
[10:25:54.094]                             }
[10:25:54.094]                             else {
[10:25:54.094]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.094]                                 info, version)
[10:25:54.094]                             }
[10:25:54.094]                             base::stop(msg)
[10:25:54.094]                           }
[10:25:54.094]                         })
[10:25:54.094]                       }
[10:25:54.094]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.094]                       base::options(mc.cores = 1L)
[10:25:54.094]                     }
[10:25:54.094]                     base::local({
[10:25:54.094]                       for (pkg in c("stats", "datasets")) {
[10:25:54.094]                         base::loadNamespace(pkg)
[10:25:54.094]                         base::library(pkg, character.only = TRUE)
[10:25:54.094]                       }
[10:25:54.094]                     })
[10:25:54.094]                   }
[10:25:54.094]                   options(future.plan = NULL)
[10:25:54.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.094]                 }
[10:25:54.094]                 ...future.workdir <- getwd()
[10:25:54.094]             }
[10:25:54.094]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.094]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.094]         }
[10:25:54.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.094]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.094]             base::names(...future.oldOptions))
[10:25:54.094]     }
[10:25:54.094]     if (FALSE) {
[10:25:54.094]     }
[10:25:54.094]     else {
[10:25:54.094]         if (TRUE) {
[10:25:54.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.094]                 open = "w")
[10:25:54.094]         }
[10:25:54.094]         else {
[10:25:54.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.094]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.094]         }
[10:25:54.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.094]             base::sink(type = "output", split = FALSE)
[10:25:54.094]             base::close(...future.stdout)
[10:25:54.094]         }, add = TRUE)
[10:25:54.094]     }
[10:25:54.094]     ...future.frame <- base::sys.nframe()
[10:25:54.094]     ...future.conditions <- base::list()
[10:25:54.094]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.094]     if (FALSE) {
[10:25:54.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.094]     }
[10:25:54.094]     ...future.result <- base::tryCatch({
[10:25:54.094]         base::withCallingHandlers({
[10:25:54.094]             ...future.value <- base::withVisible(base::local({
[10:25:54.094]                 withCallingHandlers({
[10:25:54.094]                   {
[10:25:54.094]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:25:54.094]                   }
[10:25:54.094]                 }, immediateCondition = function(cond) {
[10:25:54.094]                   save_rds <- function (object, pathname, ...) 
[10:25:54.094]                   {
[10:25:54.094]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.094]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.094]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.094]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.094]                         fi_tmp[["mtime"]])
[10:25:54.094]                     }
[10:25:54.094]                     tryCatch({
[10:25:54.094]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.094]                     }, error = function(ex) {
[10:25:54.094]                       msg <- conditionMessage(ex)
[10:25:54.094]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.094]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.094]                         fi_tmp[["mtime"]], msg)
[10:25:54.094]                       ex$message <- msg
[10:25:54.094]                       stop(ex)
[10:25:54.094]                     })
[10:25:54.094]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.094]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.094]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.094]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.094]                       fi <- file.info(pathname)
[10:25:54.094]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.094]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.094]                         fi[["size"]], fi[["mtime"]])
[10:25:54.094]                       stop(msg)
[10:25:54.094]                     }
[10:25:54.094]                     invisible(pathname)
[10:25:54.094]                   }
[10:25:54.094]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.094]                     rootPath = tempdir()) 
[10:25:54.094]                   {
[10:25:54.094]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.094]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.094]                       tmpdir = path, fileext = ".rds")
[10:25:54.094]                     save_rds(obj, file)
[10:25:54.094]                   }
[10:25:54.094]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.094]                   {
[10:25:54.094]                     inherits <- base::inherits
[10:25:54.094]                     invokeRestart <- base::invokeRestart
[10:25:54.094]                     is.null <- base::is.null
[10:25:54.094]                     muffled <- FALSE
[10:25:54.094]                     if (inherits(cond, "message")) {
[10:25:54.094]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.094]                       if (muffled) 
[10:25:54.094]                         invokeRestart("muffleMessage")
[10:25:54.094]                     }
[10:25:54.094]                     else if (inherits(cond, "warning")) {
[10:25:54.094]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.094]                       if (muffled) 
[10:25:54.094]                         invokeRestart("muffleWarning")
[10:25:54.094]                     }
[10:25:54.094]                     else if (inherits(cond, "condition")) {
[10:25:54.094]                       if (!is.null(pattern)) {
[10:25:54.094]                         computeRestarts <- base::computeRestarts
[10:25:54.094]                         grepl <- base::grepl
[10:25:54.094]                         restarts <- computeRestarts(cond)
[10:25:54.094]                         for (restart in restarts) {
[10:25:54.094]                           name <- restart$name
[10:25:54.094]                           if (is.null(name)) 
[10:25:54.094]                             next
[10:25:54.094]                           if (!grepl(pattern, name)) 
[10:25:54.094]                             next
[10:25:54.094]                           invokeRestart(restart)
[10:25:54.094]                           muffled <- TRUE
[10:25:54.094]                           break
[10:25:54.094]                         }
[10:25:54.094]                       }
[10:25:54.094]                     }
[10:25:54.094]                     invisible(muffled)
[10:25:54.094]                   }
[10:25:54.094]                   muffleCondition(cond)
[10:25:54.094]                 })
[10:25:54.094]             }))
[10:25:54.094]             future::FutureResult(value = ...future.value$value, 
[10:25:54.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.094]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.094]                     ...future.globalenv.names))
[10:25:54.094]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.094]         }, condition = base::local({
[10:25:54.094]             c <- base::c
[10:25:54.094]             inherits <- base::inherits
[10:25:54.094]             invokeRestart <- base::invokeRestart
[10:25:54.094]             length <- base::length
[10:25:54.094]             list <- base::list
[10:25:54.094]             seq.int <- base::seq.int
[10:25:54.094]             signalCondition <- base::signalCondition
[10:25:54.094]             sys.calls <- base::sys.calls
[10:25:54.094]             `[[` <- base::`[[`
[10:25:54.094]             `+` <- base::`+`
[10:25:54.094]             `<<-` <- base::`<<-`
[10:25:54.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.094]                   3L)]
[10:25:54.094]             }
[10:25:54.094]             function(cond) {
[10:25:54.094]                 is_error <- inherits(cond, "error")
[10:25:54.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.094]                   NULL)
[10:25:54.094]                 if (is_error) {
[10:25:54.094]                   sessionInformation <- function() {
[10:25:54.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.094]                       search = base::search(), system = base::Sys.info())
[10:25:54.094]                   }
[10:25:54.094]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.094]                     cond$call), session = sessionInformation(), 
[10:25:54.094]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.094]                   signalCondition(cond)
[10:25:54.094]                 }
[10:25:54.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.094]                 "immediateCondition"))) {
[10:25:54.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.094]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.094]                   if (TRUE && !signal) {
[10:25:54.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.094]                     {
[10:25:54.094]                       inherits <- base::inherits
[10:25:54.094]                       invokeRestart <- base::invokeRestart
[10:25:54.094]                       is.null <- base::is.null
[10:25:54.094]                       muffled <- FALSE
[10:25:54.094]                       if (inherits(cond, "message")) {
[10:25:54.094]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.094]                         if (muffled) 
[10:25:54.094]                           invokeRestart("muffleMessage")
[10:25:54.094]                       }
[10:25:54.094]                       else if (inherits(cond, "warning")) {
[10:25:54.094]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.094]                         if (muffled) 
[10:25:54.094]                           invokeRestart("muffleWarning")
[10:25:54.094]                       }
[10:25:54.094]                       else if (inherits(cond, "condition")) {
[10:25:54.094]                         if (!is.null(pattern)) {
[10:25:54.094]                           computeRestarts <- base::computeRestarts
[10:25:54.094]                           grepl <- base::grepl
[10:25:54.094]                           restarts <- computeRestarts(cond)
[10:25:54.094]                           for (restart in restarts) {
[10:25:54.094]                             name <- restart$name
[10:25:54.094]                             if (is.null(name)) 
[10:25:54.094]                               next
[10:25:54.094]                             if (!grepl(pattern, name)) 
[10:25:54.094]                               next
[10:25:54.094]                             invokeRestart(restart)
[10:25:54.094]                             muffled <- TRUE
[10:25:54.094]                             break
[10:25:54.094]                           }
[10:25:54.094]                         }
[10:25:54.094]                       }
[10:25:54.094]                       invisible(muffled)
[10:25:54.094]                     }
[10:25:54.094]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.094]                   }
[10:25:54.094]                 }
[10:25:54.094]                 else {
[10:25:54.094]                   if (TRUE) {
[10:25:54.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.094]                     {
[10:25:54.094]                       inherits <- base::inherits
[10:25:54.094]                       invokeRestart <- base::invokeRestart
[10:25:54.094]                       is.null <- base::is.null
[10:25:54.094]                       muffled <- FALSE
[10:25:54.094]                       if (inherits(cond, "message")) {
[10:25:54.094]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.094]                         if (muffled) 
[10:25:54.094]                           invokeRestart("muffleMessage")
[10:25:54.094]                       }
[10:25:54.094]                       else if (inherits(cond, "warning")) {
[10:25:54.094]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.094]                         if (muffled) 
[10:25:54.094]                           invokeRestart("muffleWarning")
[10:25:54.094]                       }
[10:25:54.094]                       else if (inherits(cond, "condition")) {
[10:25:54.094]                         if (!is.null(pattern)) {
[10:25:54.094]                           computeRestarts <- base::computeRestarts
[10:25:54.094]                           grepl <- base::grepl
[10:25:54.094]                           restarts <- computeRestarts(cond)
[10:25:54.094]                           for (restart in restarts) {
[10:25:54.094]                             name <- restart$name
[10:25:54.094]                             if (is.null(name)) 
[10:25:54.094]                               next
[10:25:54.094]                             if (!grepl(pattern, name)) 
[10:25:54.094]                               next
[10:25:54.094]                             invokeRestart(restart)
[10:25:54.094]                             muffled <- TRUE
[10:25:54.094]                             break
[10:25:54.094]                           }
[10:25:54.094]                         }
[10:25:54.094]                       }
[10:25:54.094]                       invisible(muffled)
[10:25:54.094]                     }
[10:25:54.094]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.094]                   }
[10:25:54.094]                 }
[10:25:54.094]             }
[10:25:54.094]         }))
[10:25:54.094]     }, error = function(ex) {
[10:25:54.094]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.094]                 ...future.rng), started = ...future.startTime, 
[10:25:54.094]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.094]             version = "1.8"), class = "FutureResult")
[10:25:54.094]     }, finally = {
[10:25:54.094]         if (!identical(...future.workdir, getwd())) 
[10:25:54.094]             setwd(...future.workdir)
[10:25:54.094]         {
[10:25:54.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.094]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.094]             }
[10:25:54.094]             base::options(...future.oldOptions)
[10:25:54.094]             if (.Platform$OS.type == "windows") {
[10:25:54.094]                 old_names <- names(...future.oldEnvVars)
[10:25:54.094]                 envs <- base::Sys.getenv()
[10:25:54.094]                 names <- names(envs)
[10:25:54.094]                 common <- intersect(names, old_names)
[10:25:54.094]                 added <- setdiff(names, old_names)
[10:25:54.094]                 removed <- setdiff(old_names, names)
[10:25:54.094]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.094]                   envs[common]]
[10:25:54.094]                 NAMES <- toupper(changed)
[10:25:54.094]                 args <- list()
[10:25:54.094]                 for (kk in seq_along(NAMES)) {
[10:25:54.094]                   name <- changed[[kk]]
[10:25:54.094]                   NAME <- NAMES[[kk]]
[10:25:54.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.094]                     next
[10:25:54.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.094]                 }
[10:25:54.094]                 NAMES <- toupper(added)
[10:25:54.094]                 for (kk in seq_along(NAMES)) {
[10:25:54.094]                   name <- added[[kk]]
[10:25:54.094]                   NAME <- NAMES[[kk]]
[10:25:54.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.094]                     next
[10:25:54.094]                   args[[name]] <- ""
[10:25:54.094]                 }
[10:25:54.094]                 NAMES <- toupper(removed)
[10:25:54.094]                 for (kk in seq_along(NAMES)) {
[10:25:54.094]                   name <- removed[[kk]]
[10:25:54.094]                   NAME <- NAMES[[kk]]
[10:25:54.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.094]                     next
[10:25:54.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.094]                 }
[10:25:54.094]                 if (length(args) > 0) 
[10:25:54.094]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.094]             }
[10:25:54.094]             else {
[10:25:54.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.094]             }
[10:25:54.094]             {
[10:25:54.094]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.094]                   0L) {
[10:25:54.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.094]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.094]                   base::options(opts)
[10:25:54.094]                 }
[10:25:54.094]                 {
[10:25:54.094]                   {
[10:25:54.094]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.094]                     NULL
[10:25:54.094]                   }
[10:25:54.094]                   options(future.plan = NULL)
[10:25:54.094]                   if (is.na(NA_character_)) 
[10:25:54.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.094]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.094]                     envir = parent.frame()) 
[10:25:54.094]                   {
[10:25:54.094]                     default_workers <- missing(workers)
[10:25:54.094]                     if (is.function(workers)) 
[10:25:54.094]                       workers <- workers()
[10:25:54.094]                     workers <- structure(as.integer(workers), 
[10:25:54.094]                       class = class(workers))
[10:25:54.094]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.094]                       1L)
[10:25:54.094]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.094]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.094]                       if (default_workers) 
[10:25:54.094]                         supportsMulticore(warn = TRUE)
[10:25:54.094]                       return(sequential(..., envir = envir))
[10:25:54.094]                     }
[10:25:54.094]                     oopts <- options(mc.cores = workers)
[10:25:54.094]                     on.exit(options(oopts))
[10:25:54.094]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.094]                       envir = envir)
[10:25:54.094]                     if (!future$lazy) 
[10:25:54.094]                       future <- run(future)
[10:25:54.094]                     invisible(future)
[10:25:54.094]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.094]                 }
[10:25:54.094]             }
[10:25:54.094]         }
[10:25:54.094]     })
[10:25:54.094]     if (TRUE) {
[10:25:54.094]         base::sink(type = "output", split = FALSE)
[10:25:54.094]         if (TRUE) {
[10:25:54.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.094]         }
[10:25:54.094]         else {
[10:25:54.094]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.094]         }
[10:25:54.094]         base::close(...future.stdout)
[10:25:54.094]         ...future.stdout <- NULL
[10:25:54.094]     }
[10:25:54.094]     ...future.result$conditions <- ...future.conditions
[10:25:54.094]     ...future.result$finished <- base::Sys.time()
[10:25:54.094]     ...future.result
[10:25:54.094] }
[10:25:54.096] requestCore(): workers = 2
[10:25:54.098] MulticoreFuture started
[10:25:54.099] - Launch lazy future ... done
[10:25:54.099] run() for ‘MulticoreFuture’ ... done
[10:25:54.099] result() for MulticoreFuture ...
[10:25:54.100] plan(): Setting new future strategy stack:
[10:25:54.100] List of future strategies:
[10:25:54.100] 1. sequential:
[10:25:54.100]    - args: function (..., envir = parent.frame())
[10:25:54.100]    - tweaked: FALSE
[10:25:54.100]    - call: NULL
[10:25:54.101] plan(): nbrOfWorkers() = 1
[10:25:54.105] plan(): Setting new future strategy stack:
[10:25:54.105] List of future strategies:
[10:25:54.105] 1. multicore:
[10:25:54.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.105]    - tweaked: FALSE
[10:25:54.105]    - call: plan(strategy)
[10:25:54.110] plan(): nbrOfWorkers() = 2
[10:25:54.112] result() for MulticoreFuture ...
[10:25:54.113] result() for MulticoreFuture ... done
[10:25:54.113] result() for MulticoreFuture ... done
[10:25:54.113] result() for MulticoreFuture ...
[10:25:54.113] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:25:54.117] getGlobalsAndPackages() ...
[10:25:54.117] Searching for globals...
[10:25:54.120] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:25:54.120] Searching for globals ... DONE
[10:25:54.120] Resolving globals: FALSE
[10:25:54.120] 
[10:25:54.121] - packages: [2] ‘stats’, ‘datasets’
[10:25:54.121] getGlobalsAndPackages() ... DONE
[10:25:54.121] run() for ‘Future’ ...
[10:25:54.121] - state: ‘created’
[10:25:54.121] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.125] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:54.125]   - Field: ‘label’
[10:25:54.126]   - Field: ‘local’
[10:25:54.126]   - Field: ‘owner’
[10:25:54.126]   - Field: ‘envir’
[10:25:54.126]   - Field: ‘workers’
[10:25:54.126]   - Field: ‘packages’
[10:25:54.126]   - Field: ‘gc’
[10:25:54.126]   - Field: ‘job’
[10:25:54.126]   - Field: ‘conditions’
[10:25:54.127]   - Field: ‘expr’
[10:25:54.127]   - Field: ‘uuid’
[10:25:54.127]   - Field: ‘seed’
[10:25:54.127]   - Field: ‘version’
[10:25:54.127]   - Field: ‘result’
[10:25:54.127]   - Field: ‘asynchronous’
[10:25:54.127]   - Field: ‘calls’
[10:25:54.127]   - Field: ‘globals’
[10:25:54.127]   - Field: ‘stdout’
[10:25:54.128]   - Field: ‘earlySignal’
[10:25:54.128]   - Field: ‘lazy’
[10:25:54.128]   - Field: ‘state’
[10:25:54.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:54.128] - Launch lazy future ...
[10:25:54.128] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:54.128] Packages needed by future strategies (n = 0): <none>
[10:25:54.129] {
[10:25:54.129]     {
[10:25:54.129]         {
[10:25:54.129]             ...future.startTime <- base::Sys.time()
[10:25:54.129]             {
[10:25:54.129]                 {
[10:25:54.129]                   {
[10:25:54.129]                     {
[10:25:54.129]                       {
[10:25:54.129]                         base::local({
[10:25:54.129]                           has_future <- base::requireNamespace("future", 
[10:25:54.129]                             quietly = TRUE)
[10:25:54.129]                           if (has_future) {
[10:25:54.129]                             ns <- base::getNamespace("future")
[10:25:54.129]                             version <- ns[[".package"]][["version"]]
[10:25:54.129]                             if (is.null(version)) 
[10:25:54.129]                               version <- utils::packageVersion("future")
[10:25:54.129]                           }
[10:25:54.129]                           else {
[10:25:54.129]                             version <- NULL
[10:25:54.129]                           }
[10:25:54.129]                           if (!has_future || version < "1.8.0") {
[10:25:54.129]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.129]                               "", base::R.version$version.string), 
[10:25:54.129]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.129]                                 base::R.version$platform, 8 * 
[10:25:54.129]                                   base::.Machine$sizeof.pointer), 
[10:25:54.129]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.129]                                 "release", "version")], collapse = " "), 
[10:25:54.129]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.129]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.129]                               info)
[10:25:54.129]                             info <- base::paste(info, collapse = "; ")
[10:25:54.129]                             if (!has_future) {
[10:25:54.129]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.129]                                 info)
[10:25:54.129]                             }
[10:25:54.129]                             else {
[10:25:54.129]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.129]                                 info, version)
[10:25:54.129]                             }
[10:25:54.129]                             base::stop(msg)
[10:25:54.129]                           }
[10:25:54.129]                         })
[10:25:54.129]                       }
[10:25:54.129]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.129]                       base::options(mc.cores = 1L)
[10:25:54.129]                     }
[10:25:54.129]                     base::local({
[10:25:54.129]                       for (pkg in c("stats", "datasets")) {
[10:25:54.129]                         base::loadNamespace(pkg)
[10:25:54.129]                         base::library(pkg, character.only = TRUE)
[10:25:54.129]                       }
[10:25:54.129]                     })
[10:25:54.129]                   }
[10:25:54.129]                   options(future.plan = NULL)
[10:25:54.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.129]                 }
[10:25:54.129]                 ...future.workdir <- getwd()
[10:25:54.129]             }
[10:25:54.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.129]         }
[10:25:54.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.129]             base::names(...future.oldOptions))
[10:25:54.129]     }
[10:25:54.129]     if (FALSE) {
[10:25:54.129]     }
[10:25:54.129]     else {
[10:25:54.129]         if (TRUE) {
[10:25:54.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.129]                 open = "w")
[10:25:54.129]         }
[10:25:54.129]         else {
[10:25:54.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.129]         }
[10:25:54.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.129]             base::sink(type = "output", split = FALSE)
[10:25:54.129]             base::close(...future.stdout)
[10:25:54.129]         }, add = TRUE)
[10:25:54.129]     }
[10:25:54.129]     ...future.frame <- base::sys.nframe()
[10:25:54.129]     ...future.conditions <- base::list()
[10:25:54.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.129]     if (FALSE) {
[10:25:54.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.129]     }
[10:25:54.129]     ...future.result <- base::tryCatch({
[10:25:54.129]         base::withCallingHandlers({
[10:25:54.129]             ...future.value <- base::withVisible(base::local({
[10:25:54.129]                 withCallingHandlers({
[10:25:54.129]                   {
[10:25:54.129]                     lm(dist ~ poly(speed, 2), data = cars)
[10:25:54.129]                   }
[10:25:54.129]                 }, immediateCondition = function(cond) {
[10:25:54.129]                   save_rds <- function (object, pathname, ...) 
[10:25:54.129]                   {
[10:25:54.129]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.129]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.129]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.129]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.129]                         fi_tmp[["mtime"]])
[10:25:54.129]                     }
[10:25:54.129]                     tryCatch({
[10:25:54.129]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.129]                     }, error = function(ex) {
[10:25:54.129]                       msg <- conditionMessage(ex)
[10:25:54.129]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.129]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.129]                         fi_tmp[["mtime"]], msg)
[10:25:54.129]                       ex$message <- msg
[10:25:54.129]                       stop(ex)
[10:25:54.129]                     })
[10:25:54.129]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.129]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.129]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.129]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.129]                       fi <- file.info(pathname)
[10:25:54.129]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.129]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.129]                         fi[["size"]], fi[["mtime"]])
[10:25:54.129]                       stop(msg)
[10:25:54.129]                     }
[10:25:54.129]                     invisible(pathname)
[10:25:54.129]                   }
[10:25:54.129]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.129]                     rootPath = tempdir()) 
[10:25:54.129]                   {
[10:25:54.129]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.129]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.129]                       tmpdir = path, fileext = ".rds")
[10:25:54.129]                     save_rds(obj, file)
[10:25:54.129]                   }
[10:25:54.129]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.129]                   {
[10:25:54.129]                     inherits <- base::inherits
[10:25:54.129]                     invokeRestart <- base::invokeRestart
[10:25:54.129]                     is.null <- base::is.null
[10:25:54.129]                     muffled <- FALSE
[10:25:54.129]                     if (inherits(cond, "message")) {
[10:25:54.129]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.129]                       if (muffled) 
[10:25:54.129]                         invokeRestart("muffleMessage")
[10:25:54.129]                     }
[10:25:54.129]                     else if (inherits(cond, "warning")) {
[10:25:54.129]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.129]                       if (muffled) 
[10:25:54.129]                         invokeRestart("muffleWarning")
[10:25:54.129]                     }
[10:25:54.129]                     else if (inherits(cond, "condition")) {
[10:25:54.129]                       if (!is.null(pattern)) {
[10:25:54.129]                         computeRestarts <- base::computeRestarts
[10:25:54.129]                         grepl <- base::grepl
[10:25:54.129]                         restarts <- computeRestarts(cond)
[10:25:54.129]                         for (restart in restarts) {
[10:25:54.129]                           name <- restart$name
[10:25:54.129]                           if (is.null(name)) 
[10:25:54.129]                             next
[10:25:54.129]                           if (!grepl(pattern, name)) 
[10:25:54.129]                             next
[10:25:54.129]                           invokeRestart(restart)
[10:25:54.129]                           muffled <- TRUE
[10:25:54.129]                           break
[10:25:54.129]                         }
[10:25:54.129]                       }
[10:25:54.129]                     }
[10:25:54.129]                     invisible(muffled)
[10:25:54.129]                   }
[10:25:54.129]                   muffleCondition(cond)
[10:25:54.129]                 })
[10:25:54.129]             }))
[10:25:54.129]             future::FutureResult(value = ...future.value$value, 
[10:25:54.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.129]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.129]                     ...future.globalenv.names))
[10:25:54.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.129]         }, condition = base::local({
[10:25:54.129]             c <- base::c
[10:25:54.129]             inherits <- base::inherits
[10:25:54.129]             invokeRestart <- base::invokeRestart
[10:25:54.129]             length <- base::length
[10:25:54.129]             list <- base::list
[10:25:54.129]             seq.int <- base::seq.int
[10:25:54.129]             signalCondition <- base::signalCondition
[10:25:54.129]             sys.calls <- base::sys.calls
[10:25:54.129]             `[[` <- base::`[[`
[10:25:54.129]             `+` <- base::`+`
[10:25:54.129]             `<<-` <- base::`<<-`
[10:25:54.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.129]                   3L)]
[10:25:54.129]             }
[10:25:54.129]             function(cond) {
[10:25:54.129]                 is_error <- inherits(cond, "error")
[10:25:54.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.129]                   NULL)
[10:25:54.129]                 if (is_error) {
[10:25:54.129]                   sessionInformation <- function() {
[10:25:54.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.129]                       search = base::search(), system = base::Sys.info())
[10:25:54.129]                   }
[10:25:54.129]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.129]                     cond$call), session = sessionInformation(), 
[10:25:54.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.129]                   signalCondition(cond)
[10:25:54.129]                 }
[10:25:54.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.129]                 "immediateCondition"))) {
[10:25:54.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.129]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.129]                   if (TRUE && !signal) {
[10:25:54.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.129]                     {
[10:25:54.129]                       inherits <- base::inherits
[10:25:54.129]                       invokeRestart <- base::invokeRestart
[10:25:54.129]                       is.null <- base::is.null
[10:25:54.129]                       muffled <- FALSE
[10:25:54.129]                       if (inherits(cond, "message")) {
[10:25:54.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.129]                         if (muffled) 
[10:25:54.129]                           invokeRestart("muffleMessage")
[10:25:54.129]                       }
[10:25:54.129]                       else if (inherits(cond, "warning")) {
[10:25:54.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.129]                         if (muffled) 
[10:25:54.129]                           invokeRestart("muffleWarning")
[10:25:54.129]                       }
[10:25:54.129]                       else if (inherits(cond, "condition")) {
[10:25:54.129]                         if (!is.null(pattern)) {
[10:25:54.129]                           computeRestarts <- base::computeRestarts
[10:25:54.129]                           grepl <- base::grepl
[10:25:54.129]                           restarts <- computeRestarts(cond)
[10:25:54.129]                           for (restart in restarts) {
[10:25:54.129]                             name <- restart$name
[10:25:54.129]                             if (is.null(name)) 
[10:25:54.129]                               next
[10:25:54.129]                             if (!grepl(pattern, name)) 
[10:25:54.129]                               next
[10:25:54.129]                             invokeRestart(restart)
[10:25:54.129]                             muffled <- TRUE
[10:25:54.129]                             break
[10:25:54.129]                           }
[10:25:54.129]                         }
[10:25:54.129]                       }
[10:25:54.129]                       invisible(muffled)
[10:25:54.129]                     }
[10:25:54.129]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.129]                   }
[10:25:54.129]                 }
[10:25:54.129]                 else {
[10:25:54.129]                   if (TRUE) {
[10:25:54.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.129]                     {
[10:25:54.129]                       inherits <- base::inherits
[10:25:54.129]                       invokeRestart <- base::invokeRestart
[10:25:54.129]                       is.null <- base::is.null
[10:25:54.129]                       muffled <- FALSE
[10:25:54.129]                       if (inherits(cond, "message")) {
[10:25:54.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.129]                         if (muffled) 
[10:25:54.129]                           invokeRestart("muffleMessage")
[10:25:54.129]                       }
[10:25:54.129]                       else if (inherits(cond, "warning")) {
[10:25:54.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.129]                         if (muffled) 
[10:25:54.129]                           invokeRestart("muffleWarning")
[10:25:54.129]                       }
[10:25:54.129]                       else if (inherits(cond, "condition")) {
[10:25:54.129]                         if (!is.null(pattern)) {
[10:25:54.129]                           computeRestarts <- base::computeRestarts
[10:25:54.129]                           grepl <- base::grepl
[10:25:54.129]                           restarts <- computeRestarts(cond)
[10:25:54.129]                           for (restart in restarts) {
[10:25:54.129]                             name <- restart$name
[10:25:54.129]                             if (is.null(name)) 
[10:25:54.129]                               next
[10:25:54.129]                             if (!grepl(pattern, name)) 
[10:25:54.129]                               next
[10:25:54.129]                             invokeRestart(restart)
[10:25:54.129]                             muffled <- TRUE
[10:25:54.129]                             break
[10:25:54.129]                           }
[10:25:54.129]                         }
[10:25:54.129]                       }
[10:25:54.129]                       invisible(muffled)
[10:25:54.129]                     }
[10:25:54.129]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.129]                   }
[10:25:54.129]                 }
[10:25:54.129]             }
[10:25:54.129]         }))
[10:25:54.129]     }, error = function(ex) {
[10:25:54.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.129]                 ...future.rng), started = ...future.startTime, 
[10:25:54.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.129]             version = "1.8"), class = "FutureResult")
[10:25:54.129]     }, finally = {
[10:25:54.129]         if (!identical(...future.workdir, getwd())) 
[10:25:54.129]             setwd(...future.workdir)
[10:25:54.129]         {
[10:25:54.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.129]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.129]             }
[10:25:54.129]             base::options(...future.oldOptions)
[10:25:54.129]             if (.Platform$OS.type == "windows") {
[10:25:54.129]                 old_names <- names(...future.oldEnvVars)
[10:25:54.129]                 envs <- base::Sys.getenv()
[10:25:54.129]                 names <- names(envs)
[10:25:54.129]                 common <- intersect(names, old_names)
[10:25:54.129]                 added <- setdiff(names, old_names)
[10:25:54.129]                 removed <- setdiff(old_names, names)
[10:25:54.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.129]                   envs[common]]
[10:25:54.129]                 NAMES <- toupper(changed)
[10:25:54.129]                 args <- list()
[10:25:54.129]                 for (kk in seq_along(NAMES)) {
[10:25:54.129]                   name <- changed[[kk]]
[10:25:54.129]                   NAME <- NAMES[[kk]]
[10:25:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.129]                     next
[10:25:54.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.129]                 }
[10:25:54.129]                 NAMES <- toupper(added)
[10:25:54.129]                 for (kk in seq_along(NAMES)) {
[10:25:54.129]                   name <- added[[kk]]
[10:25:54.129]                   NAME <- NAMES[[kk]]
[10:25:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.129]                     next
[10:25:54.129]                   args[[name]] <- ""
[10:25:54.129]                 }
[10:25:54.129]                 NAMES <- toupper(removed)
[10:25:54.129]                 for (kk in seq_along(NAMES)) {
[10:25:54.129]                   name <- removed[[kk]]
[10:25:54.129]                   NAME <- NAMES[[kk]]
[10:25:54.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.129]                     next
[10:25:54.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.129]                 }
[10:25:54.129]                 if (length(args) > 0) 
[10:25:54.129]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.129]             }
[10:25:54.129]             else {
[10:25:54.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.129]             }
[10:25:54.129]             {
[10:25:54.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.129]                   0L) {
[10:25:54.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.129]                   base::options(opts)
[10:25:54.129]                 }
[10:25:54.129]                 {
[10:25:54.129]                   {
[10:25:54.129]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.129]                     NULL
[10:25:54.129]                   }
[10:25:54.129]                   options(future.plan = NULL)
[10:25:54.129]                   if (is.na(NA_character_)) 
[10:25:54.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.129]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.129]                     envir = parent.frame()) 
[10:25:54.129]                   {
[10:25:54.129]                     default_workers <- missing(workers)
[10:25:54.129]                     if (is.function(workers)) 
[10:25:54.129]                       workers <- workers()
[10:25:54.129]                     workers <- structure(as.integer(workers), 
[10:25:54.129]                       class = class(workers))
[10:25:54.129]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.129]                       1L)
[10:25:54.129]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.129]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.129]                       if (default_workers) 
[10:25:54.129]                         supportsMulticore(warn = TRUE)
[10:25:54.129]                       return(sequential(..., envir = envir))
[10:25:54.129]                     }
[10:25:54.129]                     oopts <- options(mc.cores = workers)
[10:25:54.129]                     on.exit(options(oopts))
[10:25:54.129]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.129]                       envir = envir)
[10:25:54.129]                     if (!future$lazy) 
[10:25:54.129]                       future <- run(future)
[10:25:54.129]                     invisible(future)
[10:25:54.129]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.129]                 }
[10:25:54.129]             }
[10:25:54.129]         }
[10:25:54.129]     })
[10:25:54.129]     if (TRUE) {
[10:25:54.129]         base::sink(type = "output", split = FALSE)
[10:25:54.129]         if (TRUE) {
[10:25:54.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.129]         }
[10:25:54.129]         else {
[10:25:54.129]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.129]         }
[10:25:54.129]         base::close(...future.stdout)
[10:25:54.129]         ...future.stdout <- NULL
[10:25:54.129]     }
[10:25:54.129]     ...future.result$conditions <- ...future.conditions
[10:25:54.129]     ...future.result$finished <- base::Sys.time()
[10:25:54.129]     ...future.result
[10:25:54.129] }
[10:25:54.132] requestCore(): workers = 2
[10:25:54.134] MulticoreFuture started
[10:25:54.134] - Launch lazy future ... done
[10:25:54.134] run() for ‘MulticoreFuture’ ... done
[10:25:54.135] result() for MulticoreFuture ...
[10:25:54.135] plan(): Setting new future strategy stack:
[10:25:54.135] List of future strategies:
[10:25:54.135] 1. sequential:
[10:25:54.135]    - args: function (..., envir = parent.frame())
[10:25:54.135]    - tweaked: FALSE
[10:25:54.135]    - call: NULL
[10:25:54.136] plan(): nbrOfWorkers() = 1
[10:25:54.140] plan(): Setting new future strategy stack:
[10:25:54.140] List of future strategies:
[10:25:54.140] 1. multicore:
[10:25:54.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.140]    - tweaked: FALSE
[10:25:54.140]    - call: plan(strategy)
[10:25:54.145] plan(): nbrOfWorkers() = 2
[10:25:54.147] result() for MulticoreFuture ...
[10:25:54.148] result() for MulticoreFuture ... done
[10:25:54.148] result() for MulticoreFuture ... done
[10:25:54.148] result() for MulticoreFuture ...
[10:25:54.148] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:25:54.151] getGlobalsAndPackages() ...
[10:25:54.153] Searching for globals...
[10:25:54.160] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:54.160] Searching for globals ... DONE
[10:25:54.160] Resolving globals: FALSE
[10:25:54.161] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:54.162] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:54.162] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:54.162] 
[10:25:54.162] getGlobalsAndPackages() ... DONE
[10:25:54.162] run() for ‘Future’ ...
[10:25:54.163] - state: ‘created’
[10:25:54.163] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:54.167]   - Field: ‘label’
[10:25:54.167]   - Field: ‘local’
[10:25:54.167]   - Field: ‘owner’
[10:25:54.167]   - Field: ‘envir’
[10:25:54.167]   - Field: ‘workers’
[10:25:54.167]   - Field: ‘packages’
[10:25:54.167]   - Field: ‘gc’
[10:25:54.168]   - Field: ‘job’
[10:25:54.168]   - Field: ‘conditions’
[10:25:54.168]   - Field: ‘expr’
[10:25:54.168]   - Field: ‘uuid’
[10:25:54.168]   - Field: ‘seed’
[10:25:54.168]   - Field: ‘version’
[10:25:54.168]   - Field: ‘result’
[10:25:54.168]   - Field: ‘asynchronous’
[10:25:54.168]   - Field: ‘calls’
[10:25:54.168]   - Field: ‘globals’
[10:25:54.169]   - Field: ‘stdout’
[10:25:54.169]   - Field: ‘earlySignal’
[10:25:54.169]   - Field: ‘lazy’
[10:25:54.169]   - Field: ‘state’
[10:25:54.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:54.169] - Launch lazy future ...
[10:25:54.169] Packages needed by the future expression (n = 0): <none>
[10:25:54.170] Packages needed by future strategies (n = 0): <none>
[10:25:54.170] {
[10:25:54.170]     {
[10:25:54.170]         {
[10:25:54.170]             ...future.startTime <- base::Sys.time()
[10:25:54.170]             {
[10:25:54.170]                 {
[10:25:54.170]                   {
[10:25:54.170]                     {
[10:25:54.170]                       base::local({
[10:25:54.170]                         has_future <- base::requireNamespace("future", 
[10:25:54.170]                           quietly = TRUE)
[10:25:54.170]                         if (has_future) {
[10:25:54.170]                           ns <- base::getNamespace("future")
[10:25:54.170]                           version <- ns[[".package"]][["version"]]
[10:25:54.170]                           if (is.null(version)) 
[10:25:54.170]                             version <- utils::packageVersion("future")
[10:25:54.170]                         }
[10:25:54.170]                         else {
[10:25:54.170]                           version <- NULL
[10:25:54.170]                         }
[10:25:54.170]                         if (!has_future || version < "1.8.0") {
[10:25:54.170]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.170]                             "", base::R.version$version.string), 
[10:25:54.170]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:54.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:54.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.170]                               "release", "version")], collapse = " "), 
[10:25:54.170]                             hostname = base::Sys.info()[["nodename"]])
[10:25:54.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.170]                             info)
[10:25:54.170]                           info <- base::paste(info, collapse = "; ")
[10:25:54.170]                           if (!has_future) {
[10:25:54.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.170]                               info)
[10:25:54.170]                           }
[10:25:54.170]                           else {
[10:25:54.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.170]                               info, version)
[10:25:54.170]                           }
[10:25:54.170]                           base::stop(msg)
[10:25:54.170]                         }
[10:25:54.170]                       })
[10:25:54.170]                     }
[10:25:54.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.170]                     base::options(mc.cores = 1L)
[10:25:54.170]                   }
[10:25:54.170]                   options(future.plan = NULL)
[10:25:54.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.170]                 }
[10:25:54.170]                 ...future.workdir <- getwd()
[10:25:54.170]             }
[10:25:54.170]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.170]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.170]         }
[10:25:54.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.170]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.170]             base::names(...future.oldOptions))
[10:25:54.170]     }
[10:25:54.170]     if (FALSE) {
[10:25:54.170]     }
[10:25:54.170]     else {
[10:25:54.170]         if (TRUE) {
[10:25:54.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.170]                 open = "w")
[10:25:54.170]         }
[10:25:54.170]         else {
[10:25:54.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.170]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.170]         }
[10:25:54.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.170]             base::sink(type = "output", split = FALSE)
[10:25:54.170]             base::close(...future.stdout)
[10:25:54.170]         }, add = TRUE)
[10:25:54.170]     }
[10:25:54.170]     ...future.frame <- base::sys.nframe()
[10:25:54.170]     ...future.conditions <- base::list()
[10:25:54.170]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.170]     if (FALSE) {
[10:25:54.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.170]     }
[10:25:54.170]     ...future.result <- base::tryCatch({
[10:25:54.170]         base::withCallingHandlers({
[10:25:54.170]             ...future.value <- base::withVisible(base::local({
[10:25:54.170]                 withCallingHandlers({
[10:25:54.170]                   {
[10:25:54.170]                     outer_function(1L)
[10:25:54.170]                   }
[10:25:54.170]                 }, immediateCondition = function(cond) {
[10:25:54.170]                   save_rds <- function (object, pathname, ...) 
[10:25:54.170]                   {
[10:25:54.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.170]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.170]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.170]                         fi_tmp[["mtime"]])
[10:25:54.170]                     }
[10:25:54.170]                     tryCatch({
[10:25:54.170]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.170]                     }, error = function(ex) {
[10:25:54.170]                       msg <- conditionMessage(ex)
[10:25:54.170]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.170]                         fi_tmp[["mtime"]], msg)
[10:25:54.170]                       ex$message <- msg
[10:25:54.170]                       stop(ex)
[10:25:54.170]                     })
[10:25:54.170]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.170]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.170]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.170]                       fi <- file.info(pathname)
[10:25:54.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.170]                         fi[["size"]], fi[["mtime"]])
[10:25:54.170]                       stop(msg)
[10:25:54.170]                     }
[10:25:54.170]                     invisible(pathname)
[10:25:54.170]                   }
[10:25:54.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.170]                     rootPath = tempdir()) 
[10:25:54.170]                   {
[10:25:54.170]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.170]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.170]                       tmpdir = path, fileext = ".rds")
[10:25:54.170]                     save_rds(obj, file)
[10:25:54.170]                   }
[10:25:54.170]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.170]                   {
[10:25:54.170]                     inherits <- base::inherits
[10:25:54.170]                     invokeRestart <- base::invokeRestart
[10:25:54.170]                     is.null <- base::is.null
[10:25:54.170]                     muffled <- FALSE
[10:25:54.170]                     if (inherits(cond, "message")) {
[10:25:54.170]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.170]                       if (muffled) 
[10:25:54.170]                         invokeRestart("muffleMessage")
[10:25:54.170]                     }
[10:25:54.170]                     else if (inherits(cond, "warning")) {
[10:25:54.170]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.170]                       if (muffled) 
[10:25:54.170]                         invokeRestart("muffleWarning")
[10:25:54.170]                     }
[10:25:54.170]                     else if (inherits(cond, "condition")) {
[10:25:54.170]                       if (!is.null(pattern)) {
[10:25:54.170]                         computeRestarts <- base::computeRestarts
[10:25:54.170]                         grepl <- base::grepl
[10:25:54.170]                         restarts <- computeRestarts(cond)
[10:25:54.170]                         for (restart in restarts) {
[10:25:54.170]                           name <- restart$name
[10:25:54.170]                           if (is.null(name)) 
[10:25:54.170]                             next
[10:25:54.170]                           if (!grepl(pattern, name)) 
[10:25:54.170]                             next
[10:25:54.170]                           invokeRestart(restart)
[10:25:54.170]                           muffled <- TRUE
[10:25:54.170]                           break
[10:25:54.170]                         }
[10:25:54.170]                       }
[10:25:54.170]                     }
[10:25:54.170]                     invisible(muffled)
[10:25:54.170]                   }
[10:25:54.170]                   muffleCondition(cond)
[10:25:54.170]                 })
[10:25:54.170]             }))
[10:25:54.170]             future::FutureResult(value = ...future.value$value, 
[10:25:54.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.170]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.170]                     ...future.globalenv.names))
[10:25:54.170]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.170]         }, condition = base::local({
[10:25:54.170]             c <- base::c
[10:25:54.170]             inherits <- base::inherits
[10:25:54.170]             invokeRestart <- base::invokeRestart
[10:25:54.170]             length <- base::length
[10:25:54.170]             list <- base::list
[10:25:54.170]             seq.int <- base::seq.int
[10:25:54.170]             signalCondition <- base::signalCondition
[10:25:54.170]             sys.calls <- base::sys.calls
[10:25:54.170]             `[[` <- base::`[[`
[10:25:54.170]             `+` <- base::`+`
[10:25:54.170]             `<<-` <- base::`<<-`
[10:25:54.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.170]                   3L)]
[10:25:54.170]             }
[10:25:54.170]             function(cond) {
[10:25:54.170]                 is_error <- inherits(cond, "error")
[10:25:54.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.170]                   NULL)
[10:25:54.170]                 if (is_error) {
[10:25:54.170]                   sessionInformation <- function() {
[10:25:54.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.170]                       search = base::search(), system = base::Sys.info())
[10:25:54.170]                   }
[10:25:54.170]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.170]                     cond$call), session = sessionInformation(), 
[10:25:54.170]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.170]                   signalCondition(cond)
[10:25:54.170]                 }
[10:25:54.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.170]                 "immediateCondition"))) {
[10:25:54.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.170]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.170]                   if (TRUE && !signal) {
[10:25:54.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.170]                     {
[10:25:54.170]                       inherits <- base::inherits
[10:25:54.170]                       invokeRestart <- base::invokeRestart
[10:25:54.170]                       is.null <- base::is.null
[10:25:54.170]                       muffled <- FALSE
[10:25:54.170]                       if (inherits(cond, "message")) {
[10:25:54.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.170]                         if (muffled) 
[10:25:54.170]                           invokeRestart("muffleMessage")
[10:25:54.170]                       }
[10:25:54.170]                       else if (inherits(cond, "warning")) {
[10:25:54.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.170]                         if (muffled) 
[10:25:54.170]                           invokeRestart("muffleWarning")
[10:25:54.170]                       }
[10:25:54.170]                       else if (inherits(cond, "condition")) {
[10:25:54.170]                         if (!is.null(pattern)) {
[10:25:54.170]                           computeRestarts <- base::computeRestarts
[10:25:54.170]                           grepl <- base::grepl
[10:25:54.170]                           restarts <- computeRestarts(cond)
[10:25:54.170]                           for (restart in restarts) {
[10:25:54.170]                             name <- restart$name
[10:25:54.170]                             if (is.null(name)) 
[10:25:54.170]                               next
[10:25:54.170]                             if (!grepl(pattern, name)) 
[10:25:54.170]                               next
[10:25:54.170]                             invokeRestart(restart)
[10:25:54.170]                             muffled <- TRUE
[10:25:54.170]                             break
[10:25:54.170]                           }
[10:25:54.170]                         }
[10:25:54.170]                       }
[10:25:54.170]                       invisible(muffled)
[10:25:54.170]                     }
[10:25:54.170]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.170]                   }
[10:25:54.170]                 }
[10:25:54.170]                 else {
[10:25:54.170]                   if (TRUE) {
[10:25:54.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.170]                     {
[10:25:54.170]                       inherits <- base::inherits
[10:25:54.170]                       invokeRestart <- base::invokeRestart
[10:25:54.170]                       is.null <- base::is.null
[10:25:54.170]                       muffled <- FALSE
[10:25:54.170]                       if (inherits(cond, "message")) {
[10:25:54.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.170]                         if (muffled) 
[10:25:54.170]                           invokeRestart("muffleMessage")
[10:25:54.170]                       }
[10:25:54.170]                       else if (inherits(cond, "warning")) {
[10:25:54.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.170]                         if (muffled) 
[10:25:54.170]                           invokeRestart("muffleWarning")
[10:25:54.170]                       }
[10:25:54.170]                       else if (inherits(cond, "condition")) {
[10:25:54.170]                         if (!is.null(pattern)) {
[10:25:54.170]                           computeRestarts <- base::computeRestarts
[10:25:54.170]                           grepl <- base::grepl
[10:25:54.170]                           restarts <- computeRestarts(cond)
[10:25:54.170]                           for (restart in restarts) {
[10:25:54.170]                             name <- restart$name
[10:25:54.170]                             if (is.null(name)) 
[10:25:54.170]                               next
[10:25:54.170]                             if (!grepl(pattern, name)) 
[10:25:54.170]                               next
[10:25:54.170]                             invokeRestart(restart)
[10:25:54.170]                             muffled <- TRUE
[10:25:54.170]                             break
[10:25:54.170]                           }
[10:25:54.170]                         }
[10:25:54.170]                       }
[10:25:54.170]                       invisible(muffled)
[10:25:54.170]                     }
[10:25:54.170]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.170]                   }
[10:25:54.170]                 }
[10:25:54.170]             }
[10:25:54.170]         }))
[10:25:54.170]     }, error = function(ex) {
[10:25:54.170]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.170]                 ...future.rng), started = ...future.startTime, 
[10:25:54.170]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.170]             version = "1.8"), class = "FutureResult")
[10:25:54.170]     }, finally = {
[10:25:54.170]         if (!identical(...future.workdir, getwd())) 
[10:25:54.170]             setwd(...future.workdir)
[10:25:54.170]         {
[10:25:54.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.170]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.170]             }
[10:25:54.170]             base::options(...future.oldOptions)
[10:25:54.170]             if (.Platform$OS.type == "windows") {
[10:25:54.170]                 old_names <- names(...future.oldEnvVars)
[10:25:54.170]                 envs <- base::Sys.getenv()
[10:25:54.170]                 names <- names(envs)
[10:25:54.170]                 common <- intersect(names, old_names)
[10:25:54.170]                 added <- setdiff(names, old_names)
[10:25:54.170]                 removed <- setdiff(old_names, names)
[10:25:54.170]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.170]                   envs[common]]
[10:25:54.170]                 NAMES <- toupper(changed)
[10:25:54.170]                 args <- list()
[10:25:54.170]                 for (kk in seq_along(NAMES)) {
[10:25:54.170]                   name <- changed[[kk]]
[10:25:54.170]                   NAME <- NAMES[[kk]]
[10:25:54.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.170]                     next
[10:25:54.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.170]                 }
[10:25:54.170]                 NAMES <- toupper(added)
[10:25:54.170]                 for (kk in seq_along(NAMES)) {
[10:25:54.170]                   name <- added[[kk]]
[10:25:54.170]                   NAME <- NAMES[[kk]]
[10:25:54.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.170]                     next
[10:25:54.170]                   args[[name]] <- ""
[10:25:54.170]                 }
[10:25:54.170]                 NAMES <- toupper(removed)
[10:25:54.170]                 for (kk in seq_along(NAMES)) {
[10:25:54.170]                   name <- removed[[kk]]
[10:25:54.170]                   NAME <- NAMES[[kk]]
[10:25:54.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.170]                     next
[10:25:54.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.170]                 }
[10:25:54.170]                 if (length(args) > 0) 
[10:25:54.170]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.170]             }
[10:25:54.170]             else {
[10:25:54.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.170]             }
[10:25:54.170]             {
[10:25:54.170]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.170]                   0L) {
[10:25:54.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.170]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.170]                   base::options(opts)
[10:25:54.170]                 }
[10:25:54.170]                 {
[10:25:54.170]                   {
[10:25:54.170]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.170]                     NULL
[10:25:54.170]                   }
[10:25:54.170]                   options(future.plan = NULL)
[10:25:54.170]                   if (is.na(NA_character_)) 
[10:25:54.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.170]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.170]                     envir = parent.frame()) 
[10:25:54.170]                   {
[10:25:54.170]                     default_workers <- missing(workers)
[10:25:54.170]                     if (is.function(workers)) 
[10:25:54.170]                       workers <- workers()
[10:25:54.170]                     workers <- structure(as.integer(workers), 
[10:25:54.170]                       class = class(workers))
[10:25:54.170]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.170]                       1L)
[10:25:54.170]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.170]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.170]                       if (default_workers) 
[10:25:54.170]                         supportsMulticore(warn = TRUE)
[10:25:54.170]                       return(sequential(..., envir = envir))
[10:25:54.170]                     }
[10:25:54.170]                     oopts <- options(mc.cores = workers)
[10:25:54.170]                     on.exit(options(oopts))
[10:25:54.170]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.170]                       envir = envir)
[10:25:54.170]                     if (!future$lazy) 
[10:25:54.170]                       future <- run(future)
[10:25:54.170]                     invisible(future)
[10:25:54.170]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.170]                 }
[10:25:54.170]             }
[10:25:54.170]         }
[10:25:54.170]     })
[10:25:54.170]     if (TRUE) {
[10:25:54.170]         base::sink(type = "output", split = FALSE)
[10:25:54.170]         if (TRUE) {
[10:25:54.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.170]         }
[10:25:54.170]         else {
[10:25:54.170]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.170]         }
[10:25:54.170]         base::close(...future.stdout)
[10:25:54.170]         ...future.stdout <- NULL
[10:25:54.170]     }
[10:25:54.170]     ...future.result$conditions <- ...future.conditions
[10:25:54.170]     ...future.result$finished <- base::Sys.time()
[10:25:54.170]     ...future.result
[10:25:54.170] }
[10:25:54.172] assign_globals() ...
[10:25:54.173] List of 3
[10:25:54.173]  $ outer_function:function (x)  
[10:25:54.173]  $ map           :function (.x, .f, ...)  
[10:25:54.173]  $ inner_function:function (x)  
[10:25:54.173]  - attr(*, "where")=List of 3
[10:25:54.173]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:25:54.173]   ..$ map           :<environment: R_EmptyEnv> 
[10:25:54.173]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:25:54.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:54.173]  - attr(*, "resolved")= logi FALSE
[10:25:54.173]  - attr(*, "total_size")= num 7704
[10:25:54.173]  - attr(*, "already-done")= logi TRUE
[10:25:54.176] - reassign environment for ‘outer_function’
[10:25:54.176] - copied ‘outer_function’ to environment
[10:25:54.177] - reassign environment for ‘map’
[10:25:54.177] - copied ‘map’ to environment
[10:25:54.177] - reassign environment for ‘inner_function’
[10:25:54.177] - copied ‘inner_function’ to environment
[10:25:54.177] assign_globals() ... done
[10:25:54.177] requestCore(): workers = 2
[10:25:54.179] MulticoreFuture started
[10:25:54.179] - Launch lazy future ... done
[10:25:54.180] run() for ‘MulticoreFuture’ ... done
[10:25:54.180] result() for MulticoreFuture ...
[10:25:54.180] plan(): Setting new future strategy stack:
[10:25:54.180] List of future strategies:
[10:25:54.180] 1. sequential:
[10:25:54.180]    - args: function (..., envir = parent.frame())
[10:25:54.180]    - tweaked: FALSE
[10:25:54.180]    - call: NULL
[10:25:54.181] plan(): nbrOfWorkers() = 1
[10:25:54.184] plan(): Setting new future strategy stack:
[10:25:54.184] List of future strategies:
[10:25:54.184] 1. multicore:
[10:25:54.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.184]    - tweaked: FALSE
[10:25:54.184]    - call: plan(strategy)
[10:25:54.189] plan(): nbrOfWorkers() = 2
[10:25:54.190] result() for MulticoreFuture ...
[10:25:54.190] result() for MulticoreFuture ... done
[10:25:54.190] result() for MulticoreFuture ... done
[10:25:54.190] result() for MulticoreFuture ...
[10:25:54.190] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:25:54.192] getGlobalsAndPackages() ...
[10:25:54.192] Searching for globals...
[10:25:54.201] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:54.201] Searching for globals ... DONE
[10:25:54.201] Resolving globals: FALSE
[10:25:54.202] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:54.203] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:54.203] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:54.203] 
[10:25:54.203] getGlobalsAndPackages() ... DONE
[10:25:54.203] run() for ‘Future’ ...
[10:25:54.203] - state: ‘created’
[10:25:54.204] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.208] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.208] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:54.208]   - Field: ‘label’
[10:25:54.208]   - Field: ‘local’
[10:25:54.208]   - Field: ‘owner’
[10:25:54.208]   - Field: ‘envir’
[10:25:54.208]   - Field: ‘workers’
[10:25:54.208]   - Field: ‘packages’
[10:25:54.209]   - Field: ‘gc’
[10:25:54.209]   - Field: ‘job’
[10:25:54.209]   - Field: ‘conditions’
[10:25:54.209]   - Field: ‘expr’
[10:25:54.209]   - Field: ‘uuid’
[10:25:54.209]   - Field: ‘seed’
[10:25:54.209]   - Field: ‘version’
[10:25:54.209]   - Field: ‘result’
[10:25:54.210]   - Field: ‘asynchronous’
[10:25:54.210]   - Field: ‘calls’
[10:25:54.210]   - Field: ‘globals’
[10:25:54.210]   - Field: ‘stdout’
[10:25:54.210]   - Field: ‘earlySignal’
[10:25:54.210]   - Field: ‘lazy’
[10:25:54.210]   - Field: ‘state’
[10:25:54.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:54.210] - Launch lazy future ...
[10:25:54.211] Packages needed by the future expression (n = 0): <none>
[10:25:54.211] Packages needed by future strategies (n = 0): <none>
[10:25:54.211] {
[10:25:54.211]     {
[10:25:54.211]         {
[10:25:54.211]             ...future.startTime <- base::Sys.time()
[10:25:54.211]             {
[10:25:54.211]                 {
[10:25:54.211]                   {
[10:25:54.211]                     {
[10:25:54.211]                       base::local({
[10:25:54.211]                         has_future <- base::requireNamespace("future", 
[10:25:54.211]                           quietly = TRUE)
[10:25:54.211]                         if (has_future) {
[10:25:54.211]                           ns <- base::getNamespace("future")
[10:25:54.211]                           version <- ns[[".package"]][["version"]]
[10:25:54.211]                           if (is.null(version)) 
[10:25:54.211]                             version <- utils::packageVersion("future")
[10:25:54.211]                         }
[10:25:54.211]                         else {
[10:25:54.211]                           version <- NULL
[10:25:54.211]                         }
[10:25:54.211]                         if (!has_future || version < "1.8.0") {
[10:25:54.211]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.211]                             "", base::R.version$version.string), 
[10:25:54.211]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:54.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:54.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.211]                               "release", "version")], collapse = " "), 
[10:25:54.211]                             hostname = base::Sys.info()[["nodename"]])
[10:25:54.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.211]                             info)
[10:25:54.211]                           info <- base::paste(info, collapse = "; ")
[10:25:54.211]                           if (!has_future) {
[10:25:54.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.211]                               info)
[10:25:54.211]                           }
[10:25:54.211]                           else {
[10:25:54.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.211]                               info, version)
[10:25:54.211]                           }
[10:25:54.211]                           base::stop(msg)
[10:25:54.211]                         }
[10:25:54.211]                       })
[10:25:54.211]                     }
[10:25:54.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.211]                     base::options(mc.cores = 1L)
[10:25:54.211]                   }
[10:25:54.211]                   options(future.plan = NULL)
[10:25:54.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.211]                 }
[10:25:54.211]                 ...future.workdir <- getwd()
[10:25:54.211]             }
[10:25:54.211]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.211]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.211]         }
[10:25:54.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.211]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.211]             base::names(...future.oldOptions))
[10:25:54.211]     }
[10:25:54.211]     if (FALSE) {
[10:25:54.211]     }
[10:25:54.211]     else {
[10:25:54.211]         if (TRUE) {
[10:25:54.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.211]                 open = "w")
[10:25:54.211]         }
[10:25:54.211]         else {
[10:25:54.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.211]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.211]         }
[10:25:54.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.211]             base::sink(type = "output", split = FALSE)
[10:25:54.211]             base::close(...future.stdout)
[10:25:54.211]         }, add = TRUE)
[10:25:54.211]     }
[10:25:54.211]     ...future.frame <- base::sys.nframe()
[10:25:54.211]     ...future.conditions <- base::list()
[10:25:54.211]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.211]     if (FALSE) {
[10:25:54.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.211]     }
[10:25:54.211]     ...future.result <- base::tryCatch({
[10:25:54.211]         base::withCallingHandlers({
[10:25:54.211]             ...future.value <- base::withVisible(base::local({
[10:25:54.211]                 withCallingHandlers({
[10:25:54.211]                   {
[10:25:54.211]                     outer_function(1L)
[10:25:54.211]                   }
[10:25:54.211]                 }, immediateCondition = function(cond) {
[10:25:54.211]                   save_rds <- function (object, pathname, ...) 
[10:25:54.211]                   {
[10:25:54.211]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:54.211]                     if (file_test("-f", pathname_tmp)) {
[10:25:54.211]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.211]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:54.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.211]                         fi_tmp[["mtime"]])
[10:25:54.211]                     }
[10:25:54.211]                     tryCatch({
[10:25:54.211]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:54.211]                     }, error = function(ex) {
[10:25:54.211]                       msg <- conditionMessage(ex)
[10:25:54.211]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.211]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:54.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.211]                         fi_tmp[["mtime"]], msg)
[10:25:54.211]                       ex$message <- msg
[10:25:54.211]                       stop(ex)
[10:25:54.211]                     })
[10:25:54.211]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:54.211]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:54.211]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:54.211]                       fi_tmp <- file.info(pathname_tmp)
[10:25:54.211]                       fi <- file.info(pathname)
[10:25:54.211]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:54.211]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:54.211]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:54.211]                         fi[["size"]], fi[["mtime"]])
[10:25:54.211]                       stop(msg)
[10:25:54.211]                     }
[10:25:54.211]                     invisible(pathname)
[10:25:54.211]                   }
[10:25:54.211]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:54.211]                     rootPath = tempdir()) 
[10:25:54.211]                   {
[10:25:54.211]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:54.211]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:54.211]                       tmpdir = path, fileext = ".rds")
[10:25:54.211]                     save_rds(obj, file)
[10:25:54.211]                   }
[10:25:54.211]                   saveImmediateCondition(cond, path = "/tmp/RtmpYOCNox/.future/immediateConditions")
[10:25:54.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.211]                   {
[10:25:54.211]                     inherits <- base::inherits
[10:25:54.211]                     invokeRestart <- base::invokeRestart
[10:25:54.211]                     is.null <- base::is.null
[10:25:54.211]                     muffled <- FALSE
[10:25:54.211]                     if (inherits(cond, "message")) {
[10:25:54.211]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.211]                       if (muffled) 
[10:25:54.211]                         invokeRestart("muffleMessage")
[10:25:54.211]                     }
[10:25:54.211]                     else if (inherits(cond, "warning")) {
[10:25:54.211]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.211]                       if (muffled) 
[10:25:54.211]                         invokeRestart("muffleWarning")
[10:25:54.211]                     }
[10:25:54.211]                     else if (inherits(cond, "condition")) {
[10:25:54.211]                       if (!is.null(pattern)) {
[10:25:54.211]                         computeRestarts <- base::computeRestarts
[10:25:54.211]                         grepl <- base::grepl
[10:25:54.211]                         restarts <- computeRestarts(cond)
[10:25:54.211]                         for (restart in restarts) {
[10:25:54.211]                           name <- restart$name
[10:25:54.211]                           if (is.null(name)) 
[10:25:54.211]                             next
[10:25:54.211]                           if (!grepl(pattern, name)) 
[10:25:54.211]                             next
[10:25:54.211]                           invokeRestart(restart)
[10:25:54.211]                           muffled <- TRUE
[10:25:54.211]                           break
[10:25:54.211]                         }
[10:25:54.211]                       }
[10:25:54.211]                     }
[10:25:54.211]                     invisible(muffled)
[10:25:54.211]                   }
[10:25:54.211]                   muffleCondition(cond)
[10:25:54.211]                 })
[10:25:54.211]             }))
[10:25:54.211]             future::FutureResult(value = ...future.value$value, 
[10:25:54.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.211]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.211]                     ...future.globalenv.names))
[10:25:54.211]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.211]         }, condition = base::local({
[10:25:54.211]             c <- base::c
[10:25:54.211]             inherits <- base::inherits
[10:25:54.211]             invokeRestart <- base::invokeRestart
[10:25:54.211]             length <- base::length
[10:25:54.211]             list <- base::list
[10:25:54.211]             seq.int <- base::seq.int
[10:25:54.211]             signalCondition <- base::signalCondition
[10:25:54.211]             sys.calls <- base::sys.calls
[10:25:54.211]             `[[` <- base::`[[`
[10:25:54.211]             `+` <- base::`+`
[10:25:54.211]             `<<-` <- base::`<<-`
[10:25:54.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.211]                   3L)]
[10:25:54.211]             }
[10:25:54.211]             function(cond) {
[10:25:54.211]                 is_error <- inherits(cond, "error")
[10:25:54.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.211]                   NULL)
[10:25:54.211]                 if (is_error) {
[10:25:54.211]                   sessionInformation <- function() {
[10:25:54.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.211]                       search = base::search(), system = base::Sys.info())
[10:25:54.211]                   }
[10:25:54.211]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.211]                     cond$call), session = sessionInformation(), 
[10:25:54.211]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.211]                   signalCondition(cond)
[10:25:54.211]                 }
[10:25:54.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.211]                 "immediateCondition"))) {
[10:25:54.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.211]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.211]                   if (TRUE && !signal) {
[10:25:54.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.211]                     {
[10:25:54.211]                       inherits <- base::inherits
[10:25:54.211]                       invokeRestart <- base::invokeRestart
[10:25:54.211]                       is.null <- base::is.null
[10:25:54.211]                       muffled <- FALSE
[10:25:54.211]                       if (inherits(cond, "message")) {
[10:25:54.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.211]                         if (muffled) 
[10:25:54.211]                           invokeRestart("muffleMessage")
[10:25:54.211]                       }
[10:25:54.211]                       else if (inherits(cond, "warning")) {
[10:25:54.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.211]                         if (muffled) 
[10:25:54.211]                           invokeRestart("muffleWarning")
[10:25:54.211]                       }
[10:25:54.211]                       else if (inherits(cond, "condition")) {
[10:25:54.211]                         if (!is.null(pattern)) {
[10:25:54.211]                           computeRestarts <- base::computeRestarts
[10:25:54.211]                           grepl <- base::grepl
[10:25:54.211]                           restarts <- computeRestarts(cond)
[10:25:54.211]                           for (restart in restarts) {
[10:25:54.211]                             name <- restart$name
[10:25:54.211]                             if (is.null(name)) 
[10:25:54.211]                               next
[10:25:54.211]                             if (!grepl(pattern, name)) 
[10:25:54.211]                               next
[10:25:54.211]                             invokeRestart(restart)
[10:25:54.211]                             muffled <- TRUE
[10:25:54.211]                             break
[10:25:54.211]                           }
[10:25:54.211]                         }
[10:25:54.211]                       }
[10:25:54.211]                       invisible(muffled)
[10:25:54.211]                     }
[10:25:54.211]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.211]                   }
[10:25:54.211]                 }
[10:25:54.211]                 else {
[10:25:54.211]                   if (TRUE) {
[10:25:54.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.211]                     {
[10:25:54.211]                       inherits <- base::inherits
[10:25:54.211]                       invokeRestart <- base::invokeRestart
[10:25:54.211]                       is.null <- base::is.null
[10:25:54.211]                       muffled <- FALSE
[10:25:54.211]                       if (inherits(cond, "message")) {
[10:25:54.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.211]                         if (muffled) 
[10:25:54.211]                           invokeRestart("muffleMessage")
[10:25:54.211]                       }
[10:25:54.211]                       else if (inherits(cond, "warning")) {
[10:25:54.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.211]                         if (muffled) 
[10:25:54.211]                           invokeRestart("muffleWarning")
[10:25:54.211]                       }
[10:25:54.211]                       else if (inherits(cond, "condition")) {
[10:25:54.211]                         if (!is.null(pattern)) {
[10:25:54.211]                           computeRestarts <- base::computeRestarts
[10:25:54.211]                           grepl <- base::grepl
[10:25:54.211]                           restarts <- computeRestarts(cond)
[10:25:54.211]                           for (restart in restarts) {
[10:25:54.211]                             name <- restart$name
[10:25:54.211]                             if (is.null(name)) 
[10:25:54.211]                               next
[10:25:54.211]                             if (!grepl(pattern, name)) 
[10:25:54.211]                               next
[10:25:54.211]                             invokeRestart(restart)
[10:25:54.211]                             muffled <- TRUE
[10:25:54.211]                             break
[10:25:54.211]                           }
[10:25:54.211]                         }
[10:25:54.211]                       }
[10:25:54.211]                       invisible(muffled)
[10:25:54.211]                     }
[10:25:54.211]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.211]                   }
[10:25:54.211]                 }
[10:25:54.211]             }
[10:25:54.211]         }))
[10:25:54.211]     }, error = function(ex) {
[10:25:54.211]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.211]                 ...future.rng), started = ...future.startTime, 
[10:25:54.211]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.211]             version = "1.8"), class = "FutureResult")
[10:25:54.211]     }, finally = {
[10:25:54.211]         if (!identical(...future.workdir, getwd())) 
[10:25:54.211]             setwd(...future.workdir)
[10:25:54.211]         {
[10:25:54.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.211]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.211]             }
[10:25:54.211]             base::options(...future.oldOptions)
[10:25:54.211]             if (.Platform$OS.type == "windows") {
[10:25:54.211]                 old_names <- names(...future.oldEnvVars)
[10:25:54.211]                 envs <- base::Sys.getenv()
[10:25:54.211]                 names <- names(envs)
[10:25:54.211]                 common <- intersect(names, old_names)
[10:25:54.211]                 added <- setdiff(names, old_names)
[10:25:54.211]                 removed <- setdiff(old_names, names)
[10:25:54.211]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.211]                   envs[common]]
[10:25:54.211]                 NAMES <- toupper(changed)
[10:25:54.211]                 args <- list()
[10:25:54.211]                 for (kk in seq_along(NAMES)) {
[10:25:54.211]                   name <- changed[[kk]]
[10:25:54.211]                   NAME <- NAMES[[kk]]
[10:25:54.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.211]                     next
[10:25:54.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.211]                 }
[10:25:54.211]                 NAMES <- toupper(added)
[10:25:54.211]                 for (kk in seq_along(NAMES)) {
[10:25:54.211]                   name <- added[[kk]]
[10:25:54.211]                   NAME <- NAMES[[kk]]
[10:25:54.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.211]                     next
[10:25:54.211]                   args[[name]] <- ""
[10:25:54.211]                 }
[10:25:54.211]                 NAMES <- toupper(removed)
[10:25:54.211]                 for (kk in seq_along(NAMES)) {
[10:25:54.211]                   name <- removed[[kk]]
[10:25:54.211]                   NAME <- NAMES[[kk]]
[10:25:54.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.211]                     next
[10:25:54.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.211]                 }
[10:25:54.211]                 if (length(args) > 0) 
[10:25:54.211]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.211]             }
[10:25:54.211]             else {
[10:25:54.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.211]             }
[10:25:54.211]             {
[10:25:54.211]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.211]                   0L) {
[10:25:54.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.211]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.211]                   base::options(opts)
[10:25:54.211]                 }
[10:25:54.211]                 {
[10:25:54.211]                   {
[10:25:54.211]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.211]                     NULL
[10:25:54.211]                   }
[10:25:54.211]                   options(future.plan = NULL)
[10:25:54.211]                   if (is.na(NA_character_)) 
[10:25:54.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.211]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:54.211]                     envir = parent.frame()) 
[10:25:54.211]                   {
[10:25:54.211]                     default_workers <- missing(workers)
[10:25:54.211]                     if (is.function(workers)) 
[10:25:54.211]                       workers <- workers()
[10:25:54.211]                     workers <- structure(as.integer(workers), 
[10:25:54.211]                       class = class(workers))
[10:25:54.211]                     stop_if_not(is.finite(workers), workers >= 
[10:25:54.211]                       1L)
[10:25:54.211]                     if ((workers == 1L && !inherits(workers, 
[10:25:54.211]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:54.211]                       if (default_workers) 
[10:25:54.211]                         supportsMulticore(warn = TRUE)
[10:25:54.211]                       return(sequential(..., envir = envir))
[10:25:54.211]                     }
[10:25:54.211]                     oopts <- options(mc.cores = workers)
[10:25:54.211]                     on.exit(options(oopts))
[10:25:54.211]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:54.211]                       envir = envir)
[10:25:54.211]                     if (!future$lazy) 
[10:25:54.211]                       future <- run(future)
[10:25:54.211]                     invisible(future)
[10:25:54.211]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.211]                 }
[10:25:54.211]             }
[10:25:54.211]         }
[10:25:54.211]     })
[10:25:54.211]     if (TRUE) {
[10:25:54.211]         base::sink(type = "output", split = FALSE)
[10:25:54.211]         if (TRUE) {
[10:25:54.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.211]         }
[10:25:54.211]         else {
[10:25:54.211]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.211]         }
[10:25:54.211]         base::close(...future.stdout)
[10:25:54.211]         ...future.stdout <- NULL
[10:25:54.211]     }
[10:25:54.211]     ...future.result$conditions <- ...future.conditions
[10:25:54.211]     ...future.result$finished <- base::Sys.time()
[10:25:54.211]     ...future.result
[10:25:54.211] }
[10:25:54.214] assign_globals() ...
[10:25:54.214] List of 3
[10:25:54.214]  $ outer_function:function (x)  
[10:25:54.214]  $ map           :function (.x, .f, ...)  
[10:25:54.214]  $ inner_function:function (x)  
[10:25:54.214]  - attr(*, "where")=List of 3
[10:25:54.214]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:25:54.214]   ..$ map           :<environment: R_EmptyEnv> 
[10:25:54.214]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:25:54.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:54.214]  - attr(*, "resolved")= logi FALSE
[10:25:54.214]  - attr(*, "total_size")= num 7704
[10:25:54.214]  - attr(*, "already-done")= logi TRUE
[10:25:54.217] - reassign environment for ‘outer_function’
[10:25:54.218] - copied ‘outer_function’ to environment
[10:25:54.218] - reassign environment for ‘map’
[10:25:54.218] - copied ‘map’ to environment
[10:25:54.218] - reassign environment for ‘inner_function’
[10:25:54.218] - copied ‘inner_function’ to environment
[10:25:54.218] assign_globals() ... done
[10:25:54.218] requestCore(): workers = 2
[10:25:54.220] MulticoreFuture started
[10:25:54.220] - Launch lazy future ... done
[10:25:54.221] run() for ‘MulticoreFuture’ ... done
[10:25:54.221] result() for MulticoreFuture ...
[10:25:54.221] plan(): Setting new future strategy stack:
[10:25:54.221] List of future strategies:
[10:25:54.221] 1. sequential:
[10:25:54.221]    - args: function (..., envir = parent.frame())
[10:25:54.221]    - tweaked: FALSE
[10:25:54.221]    - call: NULL
[10:25:54.222] plan(): nbrOfWorkers() = 1
[10:25:54.224] plan(): Setting new future strategy stack:
[10:25:54.224] List of future strategies:
[10:25:54.224] 1. multicore:
[10:25:54.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:54.224]    - tweaked: FALSE
[10:25:54.224]    - call: plan(strategy)
[10:25:54.229] plan(): nbrOfWorkers() = 2
[10:25:54.230] result() for MulticoreFuture ...
[10:25:54.230] result() for MulticoreFuture ... done
[10:25:54.230] result() for MulticoreFuture ... done
[10:25:54.230] result() for MulticoreFuture ...
[10:25:54.231] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[10:25:54.233] plan(): Setting new future strategy stack:
[10:25:54.233] List of future strategies:
[10:25:54.233] 1. multisession:
[10:25:54.233]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:54.233]    - tweaked: FALSE
[10:25:54.233]    - call: plan(strategy)
[10:25:54.233] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:54.233] multisession:
[10:25:54.233] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:54.233] - tweaked: FALSE
[10:25:54.233] - call: plan(strategy)
[10:25:54.240] getGlobalsAndPackages() ...
[10:25:54.241] Not searching for globals
[10:25:54.241] - globals: [0] <none>
[10:25:54.241] getGlobalsAndPackages() ... DONE
[10:25:54.242] [local output] makeClusterPSOCK() ...
[10:25:54.288] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:54.289] [local output] Base port: 11943
[10:25:54.289] [local output] Getting setup options for 2 cluster nodes ...
[10:25:54.289] [local output]  - Node 1 of 2 ...
[10:25:54.290] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:54.290] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpYOCNox/worker.rank=1.parallelly.parent=84287.1493f673b058e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpYOCNox/worker.rank=1.parallelly.parent=84287.1493f673b058e.pid")'’
[10:25:54.477] - Possible to infer worker's PID: TRUE
[10:25:54.477] [local output] Rscript port: 11943

[10:25:54.477] [local output]  - Node 2 of 2 ...
[10:25:54.478] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:54.479] [local output] Rscript port: 11943

[10:25:54.479] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:54.479] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:54.480] [local output] Setting up PSOCK nodes in parallel
[10:25:54.480] List of 36
[10:25:54.480]  $ worker          : chr "localhost"
[10:25:54.480]   ..- attr(*, "localhost")= logi TRUE
[10:25:54.480]  $ master          : chr "localhost"
[10:25:54.480]  $ port            : int 11943
[10:25:54.480]  $ connectTimeout  : num 120
[10:25:54.480]  $ timeout         : num 2592000
[10:25:54.480]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:54.480]  $ homogeneous     : logi TRUE
[10:25:54.480]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:54.480]  $ rscript_envs    : NULL
[10:25:54.480]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:54.480]  $ rscript_startup : NULL
[10:25:54.480]  $ rscript_sh      : chr "sh"
[10:25:54.480]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:54.480]  $ methods         : logi TRUE
[10:25:54.480]  $ socketOptions   : chr "no-delay"
[10:25:54.480]  $ useXDR          : logi FALSE
[10:25:54.480]  $ outfile         : chr "/dev/null"
[10:25:54.480]  $ renice          : int NA
[10:25:54.480]  $ rshcmd          : NULL
[10:25:54.480]  $ user            : chr(0) 
[10:25:54.480]  $ revtunnel       : logi FALSE
[10:25:54.480]  $ rshlogfile      : NULL
[10:25:54.480]  $ rshopts         : chr(0) 
[10:25:54.480]  $ rank            : int 1
[10:25:54.480]  $ manual          : logi FALSE
[10:25:54.480]  $ dryrun          : logi FALSE
[10:25:54.480]  $ quiet           : logi FALSE
[10:25:54.480]  $ setup_strategy  : chr "parallel"
[10:25:54.480]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:54.480]  $ pidfile         : chr "/tmp/RtmpYOCNox/worker.rank=1.parallelly.parent=84287.1493f673b058e.pid"
[10:25:54.480]  $ rshcmd_label    : NULL
[10:25:54.480]  $ rsh_call        : NULL
[10:25:54.480]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:54.480]  $ localMachine    : logi TRUE
[10:25:54.480]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:54.480]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:54.480]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:54.480]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:54.480]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:54.480]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:54.480]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:54.480]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:54.480]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:54.480]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:54.480]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:54.480]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:54.480]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:54.480]  $ arguments       :List of 28
[10:25:54.480]   ..$ worker          : chr "localhost"
[10:25:54.480]   ..$ master          : NULL
[10:25:54.480]   ..$ port            : int 11943
[10:25:54.480]   ..$ connectTimeout  : num 120
[10:25:54.480]   ..$ timeout         : num 2592000
[10:25:54.480]   ..$ rscript         : NULL
[10:25:54.480]   ..$ homogeneous     : NULL
[10:25:54.480]   ..$ rscript_args    : NULL
[10:25:54.480]   ..$ rscript_envs    : NULL
[10:25:54.480]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:54.480]   ..$ rscript_startup : NULL
[10:25:54.480]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:54.480]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:54.480]   ..$ methods         : logi TRUE
[10:25:54.480]   ..$ socketOptions   : chr "no-delay"
[10:25:54.480]   ..$ useXDR          : logi FALSE
[10:25:54.480]   ..$ outfile         : chr "/dev/null"
[10:25:54.480]   ..$ renice          : int NA
[10:25:54.480]   ..$ rshcmd          : NULL
[10:25:54.480]   ..$ user            : NULL
[10:25:54.480]   ..$ revtunnel       : logi NA
[10:25:54.480]   ..$ rshlogfile      : NULL
[10:25:54.480]   ..$ rshopts         : NULL
[10:25:54.480]   ..$ rank            : int 1
[10:25:54.480]   ..$ manual          : logi FALSE
[10:25:54.480]   ..$ dryrun          : logi FALSE
[10:25:54.480]   ..$ quiet           : logi FALSE
[10:25:54.480]   ..$ setup_strategy  : chr "parallel"
[10:25:54.480]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:54.497] [local output] System call to launch all workers:
[10:25:54.497] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpYOCNox/worker.rank=1.parallelly.parent=84287.1493f673b058e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11943 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:54.497] [local output] Starting PSOCK main server
[10:25:54.502] [local output] Workers launched
[10:25:54.503] [local output] Waiting for workers to connect back
[10:25:54.503]  - [local output] 0 workers out of 2 ready
[10:25:54.748]  - [local output] 0 workers out of 2 ready
[10:25:54.749]  - [local output] 1 workers out of 2 ready
[10:25:54.749]  - [local output] 2 workers out of 2 ready
[10:25:54.749] [local output] Launching of workers completed
[10:25:54.749] [local output] Collecting session information from workers
[10:25:54.750] [local output]  - Worker #1 of 2
[10:25:54.750] [local output]  - Worker #2 of 2
[10:25:54.751] [local output] makeClusterPSOCK() ... done
[10:25:54.762] Packages needed by the future expression (n = 0): <none>
[10:25:54.762] Packages needed by future strategies (n = 0): <none>
[10:25:54.762] {
[10:25:54.762]     {
[10:25:54.762]         {
[10:25:54.762]             ...future.startTime <- base::Sys.time()
[10:25:54.762]             {
[10:25:54.762]                 {
[10:25:54.762]                   {
[10:25:54.762]                     {
[10:25:54.762]                       base::local({
[10:25:54.762]                         has_future <- base::requireNamespace("future", 
[10:25:54.762]                           quietly = TRUE)
[10:25:54.762]                         if (has_future) {
[10:25:54.762]                           ns <- base::getNamespace("future")
[10:25:54.762]                           version <- ns[[".package"]][["version"]]
[10:25:54.762]                           if (is.null(version)) 
[10:25:54.762]                             version <- utils::packageVersion("future")
[10:25:54.762]                         }
[10:25:54.762]                         else {
[10:25:54.762]                           version <- NULL
[10:25:54.762]                         }
[10:25:54.762]                         if (!has_future || version < "1.8.0") {
[10:25:54.762]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.762]                             "", base::R.version$version.string), 
[10:25:54.762]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:54.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:54.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.762]                               "release", "version")], collapse = " "), 
[10:25:54.762]                             hostname = base::Sys.info()[["nodename"]])
[10:25:54.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.762]                             info)
[10:25:54.762]                           info <- base::paste(info, collapse = "; ")
[10:25:54.762]                           if (!has_future) {
[10:25:54.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.762]                               info)
[10:25:54.762]                           }
[10:25:54.762]                           else {
[10:25:54.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.762]                               info, version)
[10:25:54.762]                           }
[10:25:54.762]                           base::stop(msg)
[10:25:54.762]                         }
[10:25:54.762]                       })
[10:25:54.762]                     }
[10:25:54.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.762]                     base::options(mc.cores = 1L)
[10:25:54.762]                   }
[10:25:54.762]                   options(future.plan = NULL)
[10:25:54.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.762]                 }
[10:25:54.762]                 ...future.workdir <- getwd()
[10:25:54.762]             }
[10:25:54.762]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.762]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.762]         }
[10:25:54.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.762]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.762]             base::names(...future.oldOptions))
[10:25:54.762]     }
[10:25:54.762]     if (FALSE) {
[10:25:54.762]     }
[10:25:54.762]     else {
[10:25:54.762]         if (TRUE) {
[10:25:54.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.762]                 open = "w")
[10:25:54.762]         }
[10:25:54.762]         else {
[10:25:54.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.762]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.762]         }
[10:25:54.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.762]             base::sink(type = "output", split = FALSE)
[10:25:54.762]             base::close(...future.stdout)
[10:25:54.762]         }, add = TRUE)
[10:25:54.762]     }
[10:25:54.762]     ...future.frame <- base::sys.nframe()
[10:25:54.762]     ...future.conditions <- base::list()
[10:25:54.762]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.762]     if (FALSE) {
[10:25:54.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.762]     }
[10:25:54.762]     ...future.result <- base::tryCatch({
[10:25:54.762]         base::withCallingHandlers({
[10:25:54.762]             ...future.value <- base::withVisible(base::local({
[10:25:54.762]                 ...future.makeSendCondition <- base::local({
[10:25:54.762]                   sendCondition <- NULL
[10:25:54.762]                   function(frame = 1L) {
[10:25:54.762]                     if (is.function(sendCondition)) 
[10:25:54.762]                       return(sendCondition)
[10:25:54.762]                     ns <- getNamespace("parallel")
[10:25:54.762]                     if (exists("sendData", mode = "function", 
[10:25:54.762]                       envir = ns)) {
[10:25:54.762]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:54.762]                         envir = ns)
[10:25:54.762]                       envir <- sys.frame(frame)
[10:25:54.762]                       master <- NULL
[10:25:54.762]                       while (!identical(envir, .GlobalEnv) && 
[10:25:54.762]                         !identical(envir, emptyenv())) {
[10:25:54.762]                         if (exists("master", mode = "list", envir = envir, 
[10:25:54.762]                           inherits = FALSE)) {
[10:25:54.762]                           master <- get("master", mode = "list", 
[10:25:54.762]                             envir = envir, inherits = FALSE)
[10:25:54.762]                           if (inherits(master, c("SOCKnode", 
[10:25:54.762]                             "SOCK0node"))) {
[10:25:54.762]                             sendCondition <<- function(cond) {
[10:25:54.762]                               data <- list(type = "VALUE", value = cond, 
[10:25:54.762]                                 success = TRUE)
[10:25:54.762]                               parallel_sendData(master, data)
[10:25:54.762]                             }
[10:25:54.762]                             return(sendCondition)
[10:25:54.762]                           }
[10:25:54.762]                         }
[10:25:54.762]                         frame <- frame + 1L
[10:25:54.762]                         envir <- sys.frame(frame)
[10:25:54.762]                       }
[10:25:54.762]                     }
[10:25:54.762]                     sendCondition <<- function(cond) NULL
[10:25:54.762]                   }
[10:25:54.762]                 })
[10:25:54.762]                 withCallingHandlers({
[10:25:54.762]                   NA
[10:25:54.762]                 }, immediateCondition = function(cond) {
[10:25:54.762]                   sendCondition <- ...future.makeSendCondition()
[10:25:54.762]                   sendCondition(cond)
[10:25:54.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.762]                   {
[10:25:54.762]                     inherits <- base::inherits
[10:25:54.762]                     invokeRestart <- base::invokeRestart
[10:25:54.762]                     is.null <- base::is.null
[10:25:54.762]                     muffled <- FALSE
[10:25:54.762]                     if (inherits(cond, "message")) {
[10:25:54.762]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.762]                       if (muffled) 
[10:25:54.762]                         invokeRestart("muffleMessage")
[10:25:54.762]                     }
[10:25:54.762]                     else if (inherits(cond, "warning")) {
[10:25:54.762]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.762]                       if (muffled) 
[10:25:54.762]                         invokeRestart("muffleWarning")
[10:25:54.762]                     }
[10:25:54.762]                     else if (inherits(cond, "condition")) {
[10:25:54.762]                       if (!is.null(pattern)) {
[10:25:54.762]                         computeRestarts <- base::computeRestarts
[10:25:54.762]                         grepl <- base::grepl
[10:25:54.762]                         restarts <- computeRestarts(cond)
[10:25:54.762]                         for (restart in restarts) {
[10:25:54.762]                           name <- restart$name
[10:25:54.762]                           if (is.null(name)) 
[10:25:54.762]                             next
[10:25:54.762]                           if (!grepl(pattern, name)) 
[10:25:54.762]                             next
[10:25:54.762]                           invokeRestart(restart)
[10:25:54.762]                           muffled <- TRUE
[10:25:54.762]                           break
[10:25:54.762]                         }
[10:25:54.762]                       }
[10:25:54.762]                     }
[10:25:54.762]                     invisible(muffled)
[10:25:54.762]                   }
[10:25:54.762]                   muffleCondition(cond)
[10:25:54.762]                 })
[10:25:54.762]             }))
[10:25:54.762]             future::FutureResult(value = ...future.value$value, 
[10:25:54.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.762]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.762]                     ...future.globalenv.names))
[10:25:54.762]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.762]         }, condition = base::local({
[10:25:54.762]             c <- base::c
[10:25:54.762]             inherits <- base::inherits
[10:25:54.762]             invokeRestart <- base::invokeRestart
[10:25:54.762]             length <- base::length
[10:25:54.762]             list <- base::list
[10:25:54.762]             seq.int <- base::seq.int
[10:25:54.762]             signalCondition <- base::signalCondition
[10:25:54.762]             sys.calls <- base::sys.calls
[10:25:54.762]             `[[` <- base::`[[`
[10:25:54.762]             `+` <- base::`+`
[10:25:54.762]             `<<-` <- base::`<<-`
[10:25:54.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.762]                   3L)]
[10:25:54.762]             }
[10:25:54.762]             function(cond) {
[10:25:54.762]                 is_error <- inherits(cond, "error")
[10:25:54.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.762]                   NULL)
[10:25:54.762]                 if (is_error) {
[10:25:54.762]                   sessionInformation <- function() {
[10:25:54.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.762]                       search = base::search(), system = base::Sys.info())
[10:25:54.762]                   }
[10:25:54.762]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.762]                     cond$call), session = sessionInformation(), 
[10:25:54.762]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.762]                   signalCondition(cond)
[10:25:54.762]                 }
[10:25:54.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.762]                 "immediateCondition"))) {
[10:25:54.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.762]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.762]                   if (TRUE && !signal) {
[10:25:54.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.762]                     {
[10:25:54.762]                       inherits <- base::inherits
[10:25:54.762]                       invokeRestart <- base::invokeRestart
[10:25:54.762]                       is.null <- base::is.null
[10:25:54.762]                       muffled <- FALSE
[10:25:54.762]                       if (inherits(cond, "message")) {
[10:25:54.762]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.762]                         if (muffled) 
[10:25:54.762]                           invokeRestart("muffleMessage")
[10:25:54.762]                       }
[10:25:54.762]                       else if (inherits(cond, "warning")) {
[10:25:54.762]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.762]                         if (muffled) 
[10:25:54.762]                           invokeRestart("muffleWarning")
[10:25:54.762]                       }
[10:25:54.762]                       else if (inherits(cond, "condition")) {
[10:25:54.762]                         if (!is.null(pattern)) {
[10:25:54.762]                           computeRestarts <- base::computeRestarts
[10:25:54.762]                           grepl <- base::grepl
[10:25:54.762]                           restarts <- computeRestarts(cond)
[10:25:54.762]                           for (restart in restarts) {
[10:25:54.762]                             name <- restart$name
[10:25:54.762]                             if (is.null(name)) 
[10:25:54.762]                               next
[10:25:54.762]                             if (!grepl(pattern, name)) 
[10:25:54.762]                               next
[10:25:54.762]                             invokeRestart(restart)
[10:25:54.762]                             muffled <- TRUE
[10:25:54.762]                             break
[10:25:54.762]                           }
[10:25:54.762]                         }
[10:25:54.762]                       }
[10:25:54.762]                       invisible(muffled)
[10:25:54.762]                     }
[10:25:54.762]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.762]                   }
[10:25:54.762]                 }
[10:25:54.762]                 else {
[10:25:54.762]                   if (TRUE) {
[10:25:54.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.762]                     {
[10:25:54.762]                       inherits <- base::inherits
[10:25:54.762]                       invokeRestart <- base::invokeRestart
[10:25:54.762]                       is.null <- base::is.null
[10:25:54.762]                       muffled <- FALSE
[10:25:54.762]                       if (inherits(cond, "message")) {
[10:25:54.762]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.762]                         if (muffled) 
[10:25:54.762]                           invokeRestart("muffleMessage")
[10:25:54.762]                       }
[10:25:54.762]                       else if (inherits(cond, "warning")) {
[10:25:54.762]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.762]                         if (muffled) 
[10:25:54.762]                           invokeRestart("muffleWarning")
[10:25:54.762]                       }
[10:25:54.762]                       else if (inherits(cond, "condition")) {
[10:25:54.762]                         if (!is.null(pattern)) {
[10:25:54.762]                           computeRestarts <- base::computeRestarts
[10:25:54.762]                           grepl <- base::grepl
[10:25:54.762]                           restarts <- computeRestarts(cond)
[10:25:54.762]                           for (restart in restarts) {
[10:25:54.762]                             name <- restart$name
[10:25:54.762]                             if (is.null(name)) 
[10:25:54.762]                               next
[10:25:54.762]                             if (!grepl(pattern, name)) 
[10:25:54.762]                               next
[10:25:54.762]                             invokeRestart(restart)
[10:25:54.762]                             muffled <- TRUE
[10:25:54.762]                             break
[10:25:54.762]                           }
[10:25:54.762]                         }
[10:25:54.762]                       }
[10:25:54.762]                       invisible(muffled)
[10:25:54.762]                     }
[10:25:54.762]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.762]                   }
[10:25:54.762]                 }
[10:25:54.762]             }
[10:25:54.762]         }))
[10:25:54.762]     }, error = function(ex) {
[10:25:54.762]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.762]                 ...future.rng), started = ...future.startTime, 
[10:25:54.762]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.762]             version = "1.8"), class = "FutureResult")
[10:25:54.762]     }, finally = {
[10:25:54.762]         if (!identical(...future.workdir, getwd())) 
[10:25:54.762]             setwd(...future.workdir)
[10:25:54.762]         {
[10:25:54.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.762]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.762]             }
[10:25:54.762]             base::options(...future.oldOptions)
[10:25:54.762]             if (.Platform$OS.type == "windows") {
[10:25:54.762]                 old_names <- names(...future.oldEnvVars)
[10:25:54.762]                 envs <- base::Sys.getenv()
[10:25:54.762]                 names <- names(envs)
[10:25:54.762]                 common <- intersect(names, old_names)
[10:25:54.762]                 added <- setdiff(names, old_names)
[10:25:54.762]                 removed <- setdiff(old_names, names)
[10:25:54.762]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.762]                   envs[common]]
[10:25:54.762]                 NAMES <- toupper(changed)
[10:25:54.762]                 args <- list()
[10:25:54.762]                 for (kk in seq_along(NAMES)) {
[10:25:54.762]                   name <- changed[[kk]]
[10:25:54.762]                   NAME <- NAMES[[kk]]
[10:25:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.762]                     next
[10:25:54.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.762]                 }
[10:25:54.762]                 NAMES <- toupper(added)
[10:25:54.762]                 for (kk in seq_along(NAMES)) {
[10:25:54.762]                   name <- added[[kk]]
[10:25:54.762]                   NAME <- NAMES[[kk]]
[10:25:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.762]                     next
[10:25:54.762]                   args[[name]] <- ""
[10:25:54.762]                 }
[10:25:54.762]                 NAMES <- toupper(removed)
[10:25:54.762]                 for (kk in seq_along(NAMES)) {
[10:25:54.762]                   name <- removed[[kk]]
[10:25:54.762]                   NAME <- NAMES[[kk]]
[10:25:54.762]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.762]                     next
[10:25:54.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.762]                 }
[10:25:54.762]                 if (length(args) > 0) 
[10:25:54.762]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.762]             }
[10:25:54.762]             else {
[10:25:54.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.762]             }
[10:25:54.762]             {
[10:25:54.762]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.762]                   0L) {
[10:25:54.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.762]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.762]                   base::options(opts)
[10:25:54.762]                 }
[10:25:54.762]                 {
[10:25:54.762]                   {
[10:25:54.762]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.762]                     NULL
[10:25:54.762]                   }
[10:25:54.762]                   options(future.plan = NULL)
[10:25:54.762]                   if (is.na(NA_character_)) 
[10:25:54.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.762]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:54.762]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:54.762]                     envir = parent.frame()) 
[10:25:54.762]                   {
[10:25:54.762]                     if (is.function(workers)) 
[10:25:54.762]                       workers <- workers()
[10:25:54.762]                     workers <- structure(as.integer(workers), 
[10:25:54.762]                       class = class(workers))
[10:25:54.762]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:54.762]                       workers >= 1)
[10:25:54.762]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:54.762]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:54.762]                     }
[10:25:54.762]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:54.762]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:54.762]                       envir = envir)
[10:25:54.762]                     if (!future$lazy) 
[10:25:54.762]                       future <- run(future)
[10:25:54.762]                     invisible(future)
[10:25:54.762]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.762]                 }
[10:25:54.762]             }
[10:25:54.762]         }
[10:25:54.762]     })
[10:25:54.762]     if (TRUE) {
[10:25:54.762]         base::sink(type = "output", split = FALSE)
[10:25:54.762]         if (TRUE) {
[10:25:54.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.762]         }
[10:25:54.762]         else {
[10:25:54.762]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.762]         }
[10:25:54.762]         base::close(...future.stdout)
[10:25:54.762]         ...future.stdout <- NULL
[10:25:54.762]     }
[10:25:54.762]     ...future.result$conditions <- ...future.conditions
[10:25:54.762]     ...future.result$finished <- base::Sys.time()
[10:25:54.762]     ...future.result
[10:25:54.762] }
[10:25:54.816] MultisessionFuture started
[10:25:54.816] result() for ClusterFuture ...
[10:25:54.817] receiveMessageFromWorker() for ClusterFuture ...
[10:25:54.817] - Validating connection of MultisessionFuture
[10:25:54.861] - received message: FutureResult
[10:25:54.861] - Received FutureResult
[10:25:54.861] - Erased future from FutureRegistry
[10:25:54.861] result() for ClusterFuture ...
[10:25:54.862] - result already collected: FutureResult
[10:25:54.862] result() for ClusterFuture ... done
[10:25:54.862] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:54.862] result() for ClusterFuture ... done
[10:25:54.862] result() for ClusterFuture ...
[10:25:54.862] - result already collected: FutureResult
[10:25:54.862] result() for ClusterFuture ... done
[10:25:54.863] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:54.866] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:25:54.867] getGlobalsAndPackages() ...
[10:25:54.867] Searching for globals...
[10:25:54.869] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:54.869] Searching for globals ... DONE
[10:25:54.869] Resolving globals: FALSE
[10:25:54.870] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:54.870] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:54.870] - globals: [2] ‘weight’, ‘group’
[10:25:54.870] - packages: [1] ‘stats’
[10:25:54.870] getGlobalsAndPackages() ... DONE
[10:25:54.871] run() for ‘Future’ ...
[10:25:54.871] - state: ‘created’
[10:25:54.871] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:54.886]   - Field: ‘node’
[10:25:54.886]   - Field: ‘label’
[10:25:54.886]   - Field: ‘local’
[10:25:54.886]   - Field: ‘owner’
[10:25:54.886]   - Field: ‘envir’
[10:25:54.886]   - Field: ‘workers’
[10:25:54.886]   - Field: ‘packages’
[10:25:54.887]   - Field: ‘gc’
[10:25:54.887]   - Field: ‘conditions’
[10:25:54.887]   - Field: ‘persistent’
[10:25:54.887]   - Field: ‘expr’
[10:25:54.887]   - Field: ‘uuid’
[10:25:54.887]   - Field: ‘seed’
[10:25:54.887]   - Field: ‘version’
[10:25:54.887]   - Field: ‘result’
[10:25:54.887]   - Field: ‘asynchronous’
[10:25:54.888]   - Field: ‘calls’
[10:25:54.888]   - Field: ‘globals’
[10:25:54.888]   - Field: ‘stdout’
[10:25:54.888]   - Field: ‘earlySignal’
[10:25:54.888]   - Field: ‘lazy’
[10:25:54.888]   - Field: ‘state’
[10:25:54.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:54.888] - Launch lazy future ...
[10:25:54.889] Packages needed by the future expression (n = 1): ‘stats’
[10:25:54.889] Packages needed by future strategies (n = 0): <none>
[10:25:54.890] {
[10:25:54.890]     {
[10:25:54.890]         {
[10:25:54.890]             ...future.startTime <- base::Sys.time()
[10:25:54.890]             {
[10:25:54.890]                 {
[10:25:54.890]                   {
[10:25:54.890]                     {
[10:25:54.890]                       {
[10:25:54.890]                         base::local({
[10:25:54.890]                           has_future <- base::requireNamespace("future", 
[10:25:54.890]                             quietly = TRUE)
[10:25:54.890]                           if (has_future) {
[10:25:54.890]                             ns <- base::getNamespace("future")
[10:25:54.890]                             version <- ns[[".package"]][["version"]]
[10:25:54.890]                             if (is.null(version)) 
[10:25:54.890]                               version <- utils::packageVersion("future")
[10:25:54.890]                           }
[10:25:54.890]                           else {
[10:25:54.890]                             version <- NULL
[10:25:54.890]                           }
[10:25:54.890]                           if (!has_future || version < "1.8.0") {
[10:25:54.890]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.890]                               "", base::R.version$version.string), 
[10:25:54.890]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.890]                                 base::R.version$platform, 8 * 
[10:25:54.890]                                   base::.Machine$sizeof.pointer), 
[10:25:54.890]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.890]                                 "release", "version")], collapse = " "), 
[10:25:54.890]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.890]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.890]                               info)
[10:25:54.890]                             info <- base::paste(info, collapse = "; ")
[10:25:54.890]                             if (!has_future) {
[10:25:54.890]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.890]                                 info)
[10:25:54.890]                             }
[10:25:54.890]                             else {
[10:25:54.890]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.890]                                 info, version)
[10:25:54.890]                             }
[10:25:54.890]                             base::stop(msg)
[10:25:54.890]                           }
[10:25:54.890]                         })
[10:25:54.890]                       }
[10:25:54.890]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.890]                       base::options(mc.cores = 1L)
[10:25:54.890]                     }
[10:25:54.890]                     base::local({
[10:25:54.890]                       for (pkg in "stats") {
[10:25:54.890]                         base::loadNamespace(pkg)
[10:25:54.890]                         base::library(pkg, character.only = TRUE)
[10:25:54.890]                       }
[10:25:54.890]                     })
[10:25:54.890]                   }
[10:25:54.890]                   options(future.plan = NULL)
[10:25:54.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.890]                 }
[10:25:54.890]                 ...future.workdir <- getwd()
[10:25:54.890]             }
[10:25:54.890]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.890]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.890]         }
[10:25:54.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.890]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.890]             base::names(...future.oldOptions))
[10:25:54.890]     }
[10:25:54.890]     if (FALSE) {
[10:25:54.890]     }
[10:25:54.890]     else {
[10:25:54.890]         if (TRUE) {
[10:25:54.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.890]                 open = "w")
[10:25:54.890]         }
[10:25:54.890]         else {
[10:25:54.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.890]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.890]         }
[10:25:54.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.890]             base::sink(type = "output", split = FALSE)
[10:25:54.890]             base::close(...future.stdout)
[10:25:54.890]         }, add = TRUE)
[10:25:54.890]     }
[10:25:54.890]     ...future.frame <- base::sys.nframe()
[10:25:54.890]     ...future.conditions <- base::list()
[10:25:54.890]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.890]     if (FALSE) {
[10:25:54.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.890]     }
[10:25:54.890]     ...future.result <- base::tryCatch({
[10:25:54.890]         base::withCallingHandlers({
[10:25:54.890]             ...future.value <- base::withVisible(base::local({
[10:25:54.890]                 ...future.makeSendCondition <- base::local({
[10:25:54.890]                   sendCondition <- NULL
[10:25:54.890]                   function(frame = 1L) {
[10:25:54.890]                     if (is.function(sendCondition)) 
[10:25:54.890]                       return(sendCondition)
[10:25:54.890]                     ns <- getNamespace("parallel")
[10:25:54.890]                     if (exists("sendData", mode = "function", 
[10:25:54.890]                       envir = ns)) {
[10:25:54.890]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:54.890]                         envir = ns)
[10:25:54.890]                       envir <- sys.frame(frame)
[10:25:54.890]                       master <- NULL
[10:25:54.890]                       while (!identical(envir, .GlobalEnv) && 
[10:25:54.890]                         !identical(envir, emptyenv())) {
[10:25:54.890]                         if (exists("master", mode = "list", envir = envir, 
[10:25:54.890]                           inherits = FALSE)) {
[10:25:54.890]                           master <- get("master", mode = "list", 
[10:25:54.890]                             envir = envir, inherits = FALSE)
[10:25:54.890]                           if (inherits(master, c("SOCKnode", 
[10:25:54.890]                             "SOCK0node"))) {
[10:25:54.890]                             sendCondition <<- function(cond) {
[10:25:54.890]                               data <- list(type = "VALUE", value = cond, 
[10:25:54.890]                                 success = TRUE)
[10:25:54.890]                               parallel_sendData(master, data)
[10:25:54.890]                             }
[10:25:54.890]                             return(sendCondition)
[10:25:54.890]                           }
[10:25:54.890]                         }
[10:25:54.890]                         frame <- frame + 1L
[10:25:54.890]                         envir <- sys.frame(frame)
[10:25:54.890]                       }
[10:25:54.890]                     }
[10:25:54.890]                     sendCondition <<- function(cond) NULL
[10:25:54.890]                   }
[10:25:54.890]                 })
[10:25:54.890]                 withCallingHandlers({
[10:25:54.890]                   {
[10:25:54.890]                     lm(weight ~ group - 1)
[10:25:54.890]                   }
[10:25:54.890]                 }, immediateCondition = function(cond) {
[10:25:54.890]                   sendCondition <- ...future.makeSendCondition()
[10:25:54.890]                   sendCondition(cond)
[10:25:54.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.890]                   {
[10:25:54.890]                     inherits <- base::inherits
[10:25:54.890]                     invokeRestart <- base::invokeRestart
[10:25:54.890]                     is.null <- base::is.null
[10:25:54.890]                     muffled <- FALSE
[10:25:54.890]                     if (inherits(cond, "message")) {
[10:25:54.890]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.890]                       if (muffled) 
[10:25:54.890]                         invokeRestart("muffleMessage")
[10:25:54.890]                     }
[10:25:54.890]                     else if (inherits(cond, "warning")) {
[10:25:54.890]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.890]                       if (muffled) 
[10:25:54.890]                         invokeRestart("muffleWarning")
[10:25:54.890]                     }
[10:25:54.890]                     else if (inherits(cond, "condition")) {
[10:25:54.890]                       if (!is.null(pattern)) {
[10:25:54.890]                         computeRestarts <- base::computeRestarts
[10:25:54.890]                         grepl <- base::grepl
[10:25:54.890]                         restarts <- computeRestarts(cond)
[10:25:54.890]                         for (restart in restarts) {
[10:25:54.890]                           name <- restart$name
[10:25:54.890]                           if (is.null(name)) 
[10:25:54.890]                             next
[10:25:54.890]                           if (!grepl(pattern, name)) 
[10:25:54.890]                             next
[10:25:54.890]                           invokeRestart(restart)
[10:25:54.890]                           muffled <- TRUE
[10:25:54.890]                           break
[10:25:54.890]                         }
[10:25:54.890]                       }
[10:25:54.890]                     }
[10:25:54.890]                     invisible(muffled)
[10:25:54.890]                   }
[10:25:54.890]                   muffleCondition(cond)
[10:25:54.890]                 })
[10:25:54.890]             }))
[10:25:54.890]             future::FutureResult(value = ...future.value$value, 
[10:25:54.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.890]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.890]                     ...future.globalenv.names))
[10:25:54.890]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.890]         }, condition = base::local({
[10:25:54.890]             c <- base::c
[10:25:54.890]             inherits <- base::inherits
[10:25:54.890]             invokeRestart <- base::invokeRestart
[10:25:54.890]             length <- base::length
[10:25:54.890]             list <- base::list
[10:25:54.890]             seq.int <- base::seq.int
[10:25:54.890]             signalCondition <- base::signalCondition
[10:25:54.890]             sys.calls <- base::sys.calls
[10:25:54.890]             `[[` <- base::`[[`
[10:25:54.890]             `+` <- base::`+`
[10:25:54.890]             `<<-` <- base::`<<-`
[10:25:54.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.890]                   3L)]
[10:25:54.890]             }
[10:25:54.890]             function(cond) {
[10:25:54.890]                 is_error <- inherits(cond, "error")
[10:25:54.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.890]                   NULL)
[10:25:54.890]                 if (is_error) {
[10:25:54.890]                   sessionInformation <- function() {
[10:25:54.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.890]                       search = base::search(), system = base::Sys.info())
[10:25:54.890]                   }
[10:25:54.890]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.890]                     cond$call), session = sessionInformation(), 
[10:25:54.890]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.890]                   signalCondition(cond)
[10:25:54.890]                 }
[10:25:54.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.890]                 "immediateCondition"))) {
[10:25:54.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.890]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.890]                   if (TRUE && !signal) {
[10:25:54.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.890]                     {
[10:25:54.890]                       inherits <- base::inherits
[10:25:54.890]                       invokeRestart <- base::invokeRestart
[10:25:54.890]                       is.null <- base::is.null
[10:25:54.890]                       muffled <- FALSE
[10:25:54.890]                       if (inherits(cond, "message")) {
[10:25:54.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.890]                         if (muffled) 
[10:25:54.890]                           invokeRestart("muffleMessage")
[10:25:54.890]                       }
[10:25:54.890]                       else if (inherits(cond, "warning")) {
[10:25:54.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.890]                         if (muffled) 
[10:25:54.890]                           invokeRestart("muffleWarning")
[10:25:54.890]                       }
[10:25:54.890]                       else if (inherits(cond, "condition")) {
[10:25:54.890]                         if (!is.null(pattern)) {
[10:25:54.890]                           computeRestarts <- base::computeRestarts
[10:25:54.890]                           grepl <- base::grepl
[10:25:54.890]                           restarts <- computeRestarts(cond)
[10:25:54.890]                           for (restart in restarts) {
[10:25:54.890]                             name <- restart$name
[10:25:54.890]                             if (is.null(name)) 
[10:25:54.890]                               next
[10:25:54.890]                             if (!grepl(pattern, name)) 
[10:25:54.890]                               next
[10:25:54.890]                             invokeRestart(restart)
[10:25:54.890]                             muffled <- TRUE
[10:25:54.890]                             break
[10:25:54.890]                           }
[10:25:54.890]                         }
[10:25:54.890]                       }
[10:25:54.890]                       invisible(muffled)
[10:25:54.890]                     }
[10:25:54.890]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.890]                   }
[10:25:54.890]                 }
[10:25:54.890]                 else {
[10:25:54.890]                   if (TRUE) {
[10:25:54.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.890]                     {
[10:25:54.890]                       inherits <- base::inherits
[10:25:54.890]                       invokeRestart <- base::invokeRestart
[10:25:54.890]                       is.null <- base::is.null
[10:25:54.890]                       muffled <- FALSE
[10:25:54.890]                       if (inherits(cond, "message")) {
[10:25:54.890]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.890]                         if (muffled) 
[10:25:54.890]                           invokeRestart("muffleMessage")
[10:25:54.890]                       }
[10:25:54.890]                       else if (inherits(cond, "warning")) {
[10:25:54.890]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.890]                         if (muffled) 
[10:25:54.890]                           invokeRestart("muffleWarning")
[10:25:54.890]                       }
[10:25:54.890]                       else if (inherits(cond, "condition")) {
[10:25:54.890]                         if (!is.null(pattern)) {
[10:25:54.890]                           computeRestarts <- base::computeRestarts
[10:25:54.890]                           grepl <- base::grepl
[10:25:54.890]                           restarts <- computeRestarts(cond)
[10:25:54.890]                           for (restart in restarts) {
[10:25:54.890]                             name <- restart$name
[10:25:54.890]                             if (is.null(name)) 
[10:25:54.890]                               next
[10:25:54.890]                             if (!grepl(pattern, name)) 
[10:25:54.890]                               next
[10:25:54.890]                             invokeRestart(restart)
[10:25:54.890]                             muffled <- TRUE
[10:25:54.890]                             break
[10:25:54.890]                           }
[10:25:54.890]                         }
[10:25:54.890]                       }
[10:25:54.890]                       invisible(muffled)
[10:25:54.890]                     }
[10:25:54.890]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.890]                   }
[10:25:54.890]                 }
[10:25:54.890]             }
[10:25:54.890]         }))
[10:25:54.890]     }, error = function(ex) {
[10:25:54.890]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.890]                 ...future.rng), started = ...future.startTime, 
[10:25:54.890]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.890]             version = "1.8"), class = "FutureResult")
[10:25:54.890]     }, finally = {
[10:25:54.890]         if (!identical(...future.workdir, getwd())) 
[10:25:54.890]             setwd(...future.workdir)
[10:25:54.890]         {
[10:25:54.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.890]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.890]             }
[10:25:54.890]             base::options(...future.oldOptions)
[10:25:54.890]             if (.Platform$OS.type == "windows") {
[10:25:54.890]                 old_names <- names(...future.oldEnvVars)
[10:25:54.890]                 envs <- base::Sys.getenv()
[10:25:54.890]                 names <- names(envs)
[10:25:54.890]                 common <- intersect(names, old_names)
[10:25:54.890]                 added <- setdiff(names, old_names)
[10:25:54.890]                 removed <- setdiff(old_names, names)
[10:25:54.890]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.890]                   envs[common]]
[10:25:54.890]                 NAMES <- toupper(changed)
[10:25:54.890]                 args <- list()
[10:25:54.890]                 for (kk in seq_along(NAMES)) {
[10:25:54.890]                   name <- changed[[kk]]
[10:25:54.890]                   NAME <- NAMES[[kk]]
[10:25:54.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.890]                     next
[10:25:54.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.890]                 }
[10:25:54.890]                 NAMES <- toupper(added)
[10:25:54.890]                 for (kk in seq_along(NAMES)) {
[10:25:54.890]                   name <- added[[kk]]
[10:25:54.890]                   NAME <- NAMES[[kk]]
[10:25:54.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.890]                     next
[10:25:54.890]                   args[[name]] <- ""
[10:25:54.890]                 }
[10:25:54.890]                 NAMES <- toupper(removed)
[10:25:54.890]                 for (kk in seq_along(NAMES)) {
[10:25:54.890]                   name <- removed[[kk]]
[10:25:54.890]                   NAME <- NAMES[[kk]]
[10:25:54.890]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.890]                     next
[10:25:54.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.890]                 }
[10:25:54.890]                 if (length(args) > 0) 
[10:25:54.890]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.890]             }
[10:25:54.890]             else {
[10:25:54.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.890]             }
[10:25:54.890]             {
[10:25:54.890]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.890]                   0L) {
[10:25:54.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.890]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.890]                   base::options(opts)
[10:25:54.890]                 }
[10:25:54.890]                 {
[10:25:54.890]                   {
[10:25:54.890]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.890]                     NULL
[10:25:54.890]                   }
[10:25:54.890]                   options(future.plan = NULL)
[10:25:54.890]                   if (is.na(NA_character_)) 
[10:25:54.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.890]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:54.890]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:54.890]                     envir = parent.frame()) 
[10:25:54.890]                   {
[10:25:54.890]                     if (is.function(workers)) 
[10:25:54.890]                       workers <- workers()
[10:25:54.890]                     workers <- structure(as.integer(workers), 
[10:25:54.890]                       class = class(workers))
[10:25:54.890]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:54.890]                       workers >= 1)
[10:25:54.890]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:54.890]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:54.890]                     }
[10:25:54.890]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:54.890]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:54.890]                       envir = envir)
[10:25:54.890]                     if (!future$lazy) 
[10:25:54.890]                       future <- run(future)
[10:25:54.890]                     invisible(future)
[10:25:54.890]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.890]                 }
[10:25:54.890]             }
[10:25:54.890]         }
[10:25:54.890]     })
[10:25:54.890]     if (TRUE) {
[10:25:54.890]         base::sink(type = "output", split = FALSE)
[10:25:54.890]         if (TRUE) {
[10:25:54.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.890]         }
[10:25:54.890]         else {
[10:25:54.890]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.890]         }
[10:25:54.890]         base::close(...future.stdout)
[10:25:54.890]         ...future.stdout <- NULL
[10:25:54.890]     }
[10:25:54.890]     ...future.result$conditions <- ...future.conditions
[10:25:54.890]     ...future.result$finished <- base::Sys.time()
[10:25:54.890]     ...future.result
[10:25:54.890] }
[10:25:54.893] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:25:54.893] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:25:54.893] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:25:54.894] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:25:54.894] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:25:54.894] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:25:54.895] MultisessionFuture started
[10:25:54.895] - Launch lazy future ... done
[10:25:54.895] run() for ‘MultisessionFuture’ ... done
[10:25:54.895] result() for ClusterFuture ...
[10:25:54.895] receiveMessageFromWorker() for ClusterFuture ...
[10:25:54.896] - Validating connection of MultisessionFuture
[10:25:54.946] - received message: FutureResult
[10:25:54.946] - Received FutureResult
[10:25:54.947] - Erased future from FutureRegistry
[10:25:54.947] result() for ClusterFuture ...
[10:25:54.947] - result already collected: FutureResult
[10:25:54.947] result() for ClusterFuture ... done
[10:25:54.947] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:54.947] result() for ClusterFuture ... done
[10:25:54.947] result() for ClusterFuture ...
[10:25:54.947] - result already collected: FutureResult
[10:25:54.948] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:54.950] getGlobalsAndPackages() ...
[10:25:54.950] Searching for globals...
[10:25:54.952] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:54.952] Searching for globals ... DONE
[10:25:54.952] Resolving globals: FALSE
[10:25:54.953] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:54.953] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:54.953] - globals: [2] ‘weight’, ‘group’
[10:25:54.954] - packages: [1] ‘stats’
[10:25:54.954] getGlobalsAndPackages() ... DONE
[10:25:54.954] run() for ‘Future’ ...
[10:25:54.954] - state: ‘created’
[10:25:54.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:54.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:54.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:54.969]   - Field: ‘node’
[10:25:54.969]   - Field: ‘label’
[10:25:54.969]   - Field: ‘local’
[10:25:54.969]   - Field: ‘owner’
[10:25:54.969]   - Field: ‘envir’
[10:25:54.970]   - Field: ‘workers’
[10:25:54.970]   - Field: ‘packages’
[10:25:54.970]   - Field: ‘gc’
[10:25:54.970]   - Field: ‘conditions’
[10:25:54.970]   - Field: ‘persistent’
[10:25:54.970]   - Field: ‘expr’
[10:25:54.970]   - Field: ‘uuid’
[10:25:54.970]   - Field: ‘seed’
[10:25:54.970]   - Field: ‘version’
[10:25:54.971]   - Field: ‘result’
[10:25:54.971]   - Field: ‘asynchronous’
[10:25:54.971]   - Field: ‘calls’
[10:25:54.971]   - Field: ‘globals’
[10:25:54.971]   - Field: ‘stdout’
[10:25:54.971]   - Field: ‘earlySignal’
[10:25:54.971]   - Field: ‘lazy’
[10:25:54.971]   - Field: ‘state’
[10:25:54.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:54.972] - Launch lazy future ...
[10:25:54.972] Packages needed by the future expression (n = 1): ‘stats’
[10:25:54.972] Packages needed by future strategies (n = 0): <none>
[10:25:54.973] {
[10:25:54.973]     {
[10:25:54.973]         {
[10:25:54.973]             ...future.startTime <- base::Sys.time()
[10:25:54.973]             {
[10:25:54.973]                 {
[10:25:54.973]                   {
[10:25:54.973]                     {
[10:25:54.973]                       {
[10:25:54.973]                         base::local({
[10:25:54.973]                           has_future <- base::requireNamespace("future", 
[10:25:54.973]                             quietly = TRUE)
[10:25:54.973]                           if (has_future) {
[10:25:54.973]                             ns <- base::getNamespace("future")
[10:25:54.973]                             version <- ns[[".package"]][["version"]]
[10:25:54.973]                             if (is.null(version)) 
[10:25:54.973]                               version <- utils::packageVersion("future")
[10:25:54.973]                           }
[10:25:54.973]                           else {
[10:25:54.973]                             version <- NULL
[10:25:54.973]                           }
[10:25:54.973]                           if (!has_future || version < "1.8.0") {
[10:25:54.973]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:54.973]                               "", base::R.version$version.string), 
[10:25:54.973]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:54.973]                                 base::R.version$platform, 8 * 
[10:25:54.973]                                   base::.Machine$sizeof.pointer), 
[10:25:54.973]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:54.973]                                 "release", "version")], collapse = " "), 
[10:25:54.973]                               hostname = base::Sys.info()[["nodename"]])
[10:25:54.973]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:54.973]                               info)
[10:25:54.973]                             info <- base::paste(info, collapse = "; ")
[10:25:54.973]                             if (!has_future) {
[10:25:54.973]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:54.973]                                 info)
[10:25:54.973]                             }
[10:25:54.973]                             else {
[10:25:54.973]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:54.973]                                 info, version)
[10:25:54.973]                             }
[10:25:54.973]                             base::stop(msg)
[10:25:54.973]                           }
[10:25:54.973]                         })
[10:25:54.973]                       }
[10:25:54.973]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:54.973]                       base::options(mc.cores = 1L)
[10:25:54.973]                     }
[10:25:54.973]                     base::local({
[10:25:54.973]                       for (pkg in "stats") {
[10:25:54.973]                         base::loadNamespace(pkg)
[10:25:54.973]                         base::library(pkg, character.only = TRUE)
[10:25:54.973]                       }
[10:25:54.973]                     })
[10:25:54.973]                   }
[10:25:54.973]                   options(future.plan = NULL)
[10:25:54.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:54.973]                 }
[10:25:54.973]                 ...future.workdir <- getwd()
[10:25:54.973]             }
[10:25:54.973]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:54.973]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:54.973]         }
[10:25:54.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:54.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:54.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:54.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:54.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:54.973]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:54.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:54.973]             base::names(...future.oldOptions))
[10:25:54.973]     }
[10:25:54.973]     if (FALSE) {
[10:25:54.973]     }
[10:25:54.973]     else {
[10:25:54.973]         if (TRUE) {
[10:25:54.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:54.973]                 open = "w")
[10:25:54.973]         }
[10:25:54.973]         else {
[10:25:54.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:54.973]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:54.973]         }
[10:25:54.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:54.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:54.973]             base::sink(type = "output", split = FALSE)
[10:25:54.973]             base::close(...future.stdout)
[10:25:54.973]         }, add = TRUE)
[10:25:54.973]     }
[10:25:54.973]     ...future.frame <- base::sys.nframe()
[10:25:54.973]     ...future.conditions <- base::list()
[10:25:54.973]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:54.973]     if (FALSE) {
[10:25:54.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:54.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:54.973]     }
[10:25:54.973]     ...future.result <- base::tryCatch({
[10:25:54.973]         base::withCallingHandlers({
[10:25:54.973]             ...future.value <- base::withVisible(base::local({
[10:25:54.973]                 ...future.makeSendCondition <- base::local({
[10:25:54.973]                   sendCondition <- NULL
[10:25:54.973]                   function(frame = 1L) {
[10:25:54.973]                     if (is.function(sendCondition)) 
[10:25:54.973]                       return(sendCondition)
[10:25:54.973]                     ns <- getNamespace("parallel")
[10:25:54.973]                     if (exists("sendData", mode = "function", 
[10:25:54.973]                       envir = ns)) {
[10:25:54.973]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:54.973]                         envir = ns)
[10:25:54.973]                       envir <- sys.frame(frame)
[10:25:54.973]                       master <- NULL
[10:25:54.973]                       while (!identical(envir, .GlobalEnv) && 
[10:25:54.973]                         !identical(envir, emptyenv())) {
[10:25:54.973]                         if (exists("master", mode = "list", envir = envir, 
[10:25:54.973]                           inherits = FALSE)) {
[10:25:54.973]                           master <- get("master", mode = "list", 
[10:25:54.973]                             envir = envir, inherits = FALSE)
[10:25:54.973]                           if (inherits(master, c("SOCKnode", 
[10:25:54.973]                             "SOCK0node"))) {
[10:25:54.973]                             sendCondition <<- function(cond) {
[10:25:54.973]                               data <- list(type = "VALUE", value = cond, 
[10:25:54.973]                                 success = TRUE)
[10:25:54.973]                               parallel_sendData(master, data)
[10:25:54.973]                             }
[10:25:54.973]                             return(sendCondition)
[10:25:54.973]                           }
[10:25:54.973]                         }
[10:25:54.973]                         frame <- frame + 1L
[10:25:54.973]                         envir <- sys.frame(frame)
[10:25:54.973]                       }
[10:25:54.973]                     }
[10:25:54.973]                     sendCondition <<- function(cond) NULL
[10:25:54.973]                   }
[10:25:54.973]                 })
[10:25:54.973]                 withCallingHandlers({
[10:25:54.973]                   {
[10:25:54.973]                     lm(weight ~ group - 1)
[10:25:54.973]                   }
[10:25:54.973]                 }, immediateCondition = function(cond) {
[10:25:54.973]                   sendCondition <- ...future.makeSendCondition()
[10:25:54.973]                   sendCondition(cond)
[10:25:54.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.973]                   {
[10:25:54.973]                     inherits <- base::inherits
[10:25:54.973]                     invokeRestart <- base::invokeRestart
[10:25:54.973]                     is.null <- base::is.null
[10:25:54.973]                     muffled <- FALSE
[10:25:54.973]                     if (inherits(cond, "message")) {
[10:25:54.973]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:54.973]                       if (muffled) 
[10:25:54.973]                         invokeRestart("muffleMessage")
[10:25:54.973]                     }
[10:25:54.973]                     else if (inherits(cond, "warning")) {
[10:25:54.973]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:54.973]                       if (muffled) 
[10:25:54.973]                         invokeRestart("muffleWarning")
[10:25:54.973]                     }
[10:25:54.973]                     else if (inherits(cond, "condition")) {
[10:25:54.973]                       if (!is.null(pattern)) {
[10:25:54.973]                         computeRestarts <- base::computeRestarts
[10:25:54.973]                         grepl <- base::grepl
[10:25:54.973]                         restarts <- computeRestarts(cond)
[10:25:54.973]                         for (restart in restarts) {
[10:25:54.973]                           name <- restart$name
[10:25:54.973]                           if (is.null(name)) 
[10:25:54.973]                             next
[10:25:54.973]                           if (!grepl(pattern, name)) 
[10:25:54.973]                             next
[10:25:54.973]                           invokeRestart(restart)
[10:25:54.973]                           muffled <- TRUE
[10:25:54.973]                           break
[10:25:54.973]                         }
[10:25:54.973]                       }
[10:25:54.973]                     }
[10:25:54.973]                     invisible(muffled)
[10:25:54.973]                   }
[10:25:54.973]                   muffleCondition(cond)
[10:25:54.973]                 })
[10:25:54.973]             }))
[10:25:54.973]             future::FutureResult(value = ...future.value$value, 
[10:25:54.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.973]                   ...future.rng), globalenv = if (FALSE) 
[10:25:54.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:54.973]                     ...future.globalenv.names))
[10:25:54.973]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:54.973]         }, condition = base::local({
[10:25:54.973]             c <- base::c
[10:25:54.973]             inherits <- base::inherits
[10:25:54.973]             invokeRestart <- base::invokeRestart
[10:25:54.973]             length <- base::length
[10:25:54.973]             list <- base::list
[10:25:54.973]             seq.int <- base::seq.int
[10:25:54.973]             signalCondition <- base::signalCondition
[10:25:54.973]             sys.calls <- base::sys.calls
[10:25:54.973]             `[[` <- base::`[[`
[10:25:54.973]             `+` <- base::`+`
[10:25:54.973]             `<<-` <- base::`<<-`
[10:25:54.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:54.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:54.973]                   3L)]
[10:25:54.973]             }
[10:25:54.973]             function(cond) {
[10:25:54.973]                 is_error <- inherits(cond, "error")
[10:25:54.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:54.973]                   NULL)
[10:25:54.973]                 if (is_error) {
[10:25:54.973]                   sessionInformation <- function() {
[10:25:54.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:54.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:54.973]                       search = base::search(), system = base::Sys.info())
[10:25:54.973]                   }
[10:25:54.973]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:54.973]                     cond$call), session = sessionInformation(), 
[10:25:54.973]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:54.973]                   signalCondition(cond)
[10:25:54.973]                 }
[10:25:54.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:54.973]                 "immediateCondition"))) {
[10:25:54.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:54.973]                   ...future.conditions[[length(...future.conditions) + 
[10:25:54.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:54.973]                   if (TRUE && !signal) {
[10:25:54.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.973]                     {
[10:25:54.973]                       inherits <- base::inherits
[10:25:54.973]                       invokeRestart <- base::invokeRestart
[10:25:54.973]                       is.null <- base::is.null
[10:25:54.973]                       muffled <- FALSE
[10:25:54.973]                       if (inherits(cond, "message")) {
[10:25:54.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.973]                         if (muffled) 
[10:25:54.973]                           invokeRestart("muffleMessage")
[10:25:54.973]                       }
[10:25:54.973]                       else if (inherits(cond, "warning")) {
[10:25:54.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.973]                         if (muffled) 
[10:25:54.973]                           invokeRestart("muffleWarning")
[10:25:54.973]                       }
[10:25:54.973]                       else if (inherits(cond, "condition")) {
[10:25:54.973]                         if (!is.null(pattern)) {
[10:25:54.973]                           computeRestarts <- base::computeRestarts
[10:25:54.973]                           grepl <- base::grepl
[10:25:54.973]                           restarts <- computeRestarts(cond)
[10:25:54.973]                           for (restart in restarts) {
[10:25:54.973]                             name <- restart$name
[10:25:54.973]                             if (is.null(name)) 
[10:25:54.973]                               next
[10:25:54.973]                             if (!grepl(pattern, name)) 
[10:25:54.973]                               next
[10:25:54.973]                             invokeRestart(restart)
[10:25:54.973]                             muffled <- TRUE
[10:25:54.973]                             break
[10:25:54.973]                           }
[10:25:54.973]                         }
[10:25:54.973]                       }
[10:25:54.973]                       invisible(muffled)
[10:25:54.973]                     }
[10:25:54.973]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.973]                   }
[10:25:54.973]                 }
[10:25:54.973]                 else {
[10:25:54.973]                   if (TRUE) {
[10:25:54.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:54.973]                     {
[10:25:54.973]                       inherits <- base::inherits
[10:25:54.973]                       invokeRestart <- base::invokeRestart
[10:25:54.973]                       is.null <- base::is.null
[10:25:54.973]                       muffled <- FALSE
[10:25:54.973]                       if (inherits(cond, "message")) {
[10:25:54.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:54.973]                         if (muffled) 
[10:25:54.973]                           invokeRestart("muffleMessage")
[10:25:54.973]                       }
[10:25:54.973]                       else if (inherits(cond, "warning")) {
[10:25:54.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:54.973]                         if (muffled) 
[10:25:54.973]                           invokeRestart("muffleWarning")
[10:25:54.973]                       }
[10:25:54.973]                       else if (inherits(cond, "condition")) {
[10:25:54.973]                         if (!is.null(pattern)) {
[10:25:54.973]                           computeRestarts <- base::computeRestarts
[10:25:54.973]                           grepl <- base::grepl
[10:25:54.973]                           restarts <- computeRestarts(cond)
[10:25:54.973]                           for (restart in restarts) {
[10:25:54.973]                             name <- restart$name
[10:25:54.973]                             if (is.null(name)) 
[10:25:54.973]                               next
[10:25:54.973]                             if (!grepl(pattern, name)) 
[10:25:54.973]                               next
[10:25:54.973]                             invokeRestart(restart)
[10:25:54.973]                             muffled <- TRUE
[10:25:54.973]                             break
[10:25:54.973]                           }
[10:25:54.973]                         }
[10:25:54.973]                       }
[10:25:54.973]                       invisible(muffled)
[10:25:54.973]                     }
[10:25:54.973]                     muffleCondition(cond, pattern = "^muffle")
[10:25:54.973]                   }
[10:25:54.973]                 }
[10:25:54.973]             }
[10:25:54.973]         }))
[10:25:54.973]     }, error = function(ex) {
[10:25:54.973]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:54.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:54.973]                 ...future.rng), started = ...future.startTime, 
[10:25:54.973]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:54.973]             version = "1.8"), class = "FutureResult")
[10:25:54.973]     }, finally = {
[10:25:54.973]         if (!identical(...future.workdir, getwd())) 
[10:25:54.973]             setwd(...future.workdir)
[10:25:54.973]         {
[10:25:54.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:54.973]                 ...future.oldOptions$nwarnings <- NULL
[10:25:54.973]             }
[10:25:54.973]             base::options(...future.oldOptions)
[10:25:54.973]             if (.Platform$OS.type == "windows") {
[10:25:54.973]                 old_names <- names(...future.oldEnvVars)
[10:25:54.973]                 envs <- base::Sys.getenv()
[10:25:54.973]                 names <- names(envs)
[10:25:54.973]                 common <- intersect(names, old_names)
[10:25:54.973]                 added <- setdiff(names, old_names)
[10:25:54.973]                 removed <- setdiff(old_names, names)
[10:25:54.973]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:54.973]                   envs[common]]
[10:25:54.973]                 NAMES <- toupper(changed)
[10:25:54.973]                 args <- list()
[10:25:54.973]                 for (kk in seq_along(NAMES)) {
[10:25:54.973]                   name <- changed[[kk]]
[10:25:54.973]                   NAME <- NAMES[[kk]]
[10:25:54.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.973]                     next
[10:25:54.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.973]                 }
[10:25:54.973]                 NAMES <- toupper(added)
[10:25:54.973]                 for (kk in seq_along(NAMES)) {
[10:25:54.973]                   name <- added[[kk]]
[10:25:54.973]                   NAME <- NAMES[[kk]]
[10:25:54.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.973]                     next
[10:25:54.973]                   args[[name]] <- ""
[10:25:54.973]                 }
[10:25:54.973]                 NAMES <- toupper(removed)
[10:25:54.973]                 for (kk in seq_along(NAMES)) {
[10:25:54.973]                   name <- removed[[kk]]
[10:25:54.973]                   NAME <- NAMES[[kk]]
[10:25:54.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:54.973]                     next
[10:25:54.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:54.973]                 }
[10:25:54.973]                 if (length(args) > 0) 
[10:25:54.973]                   base::do.call(base::Sys.setenv, args = args)
[10:25:54.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:54.973]             }
[10:25:54.973]             else {
[10:25:54.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:54.973]             }
[10:25:54.973]             {
[10:25:54.973]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:54.973]                   0L) {
[10:25:54.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:54.973]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:54.973]                   base::options(opts)
[10:25:54.973]                 }
[10:25:54.973]                 {
[10:25:54.973]                   {
[10:25:54.973]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:54.973]                     NULL
[10:25:54.973]                   }
[10:25:54.973]                   options(future.plan = NULL)
[10:25:54.973]                   if (is.na(NA_character_)) 
[10:25:54.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:54.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:54.973]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:54.973]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:54.973]                     envir = parent.frame()) 
[10:25:54.973]                   {
[10:25:54.973]                     if (is.function(workers)) 
[10:25:54.973]                       workers <- workers()
[10:25:54.973]                     workers <- structure(as.integer(workers), 
[10:25:54.973]                       class = class(workers))
[10:25:54.973]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:54.973]                       workers >= 1)
[10:25:54.973]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:54.973]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:54.973]                     }
[10:25:54.973]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:54.973]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:54.973]                       envir = envir)
[10:25:54.973]                     if (!future$lazy) 
[10:25:54.973]                       future <- run(future)
[10:25:54.973]                     invisible(future)
[10:25:54.973]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:54.973]                 }
[10:25:54.973]             }
[10:25:54.973]         }
[10:25:54.973]     })
[10:25:54.973]     if (TRUE) {
[10:25:54.973]         base::sink(type = "output", split = FALSE)
[10:25:54.973]         if (TRUE) {
[10:25:54.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:54.973]         }
[10:25:54.973]         else {
[10:25:54.973]             ...future.result["stdout"] <- base::list(NULL)
[10:25:54.973]         }
[10:25:54.973]         base::close(...future.stdout)
[10:25:54.973]         ...future.stdout <- NULL
[10:25:54.973]     }
[10:25:54.973]     ...future.result$conditions <- ...future.conditions
[10:25:54.973]     ...future.result$finished <- base::Sys.time()
[10:25:54.973]     ...future.result
[10:25:54.973] }
[10:25:54.976] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:25:54.976] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:25:54.976] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:25:54.977] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:25:54.977] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:25:54.977] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:25:54.978] MultisessionFuture started
[10:25:54.978] - Launch lazy future ... done
[10:25:54.978] run() for ‘MultisessionFuture’ ... done
[10:25:54.978] result() for ClusterFuture ...
[10:25:54.978] receiveMessageFromWorker() for ClusterFuture ...
[10:25:54.979] - Validating connection of MultisessionFuture
[10:25:55.027] - received message: FutureResult
[10:25:55.028] - Received FutureResult
[10:25:55.028] - Erased future from FutureRegistry
[10:25:55.028] result() for ClusterFuture ...
[10:25:55.028] - result already collected: FutureResult
[10:25:55.028] result() for ClusterFuture ... done
[10:25:55.028] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.028] result() for ClusterFuture ... done
[10:25:55.029] result() for ClusterFuture ...
[10:25:55.029] - result already collected: FutureResult
[10:25:55.029] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:55.031] getGlobalsAndPackages() ...
[10:25:55.031] Searching for globals...
[10:25:55.033] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:55.033] Searching for globals ... DONE
[10:25:55.034] Resolving globals: FALSE
[10:25:55.034] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:55.035] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:55.035] - globals: [2] ‘weight’, ‘group’
[10:25:55.035] - packages: [1] ‘stats’
[10:25:55.035] getGlobalsAndPackages() ... DONE
[10:25:55.035] run() for ‘Future’ ...
[10:25:55.036] - state: ‘created’
[10:25:55.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.050]   - Field: ‘node’
[10:25:55.051]   - Field: ‘label’
[10:25:55.051]   - Field: ‘local’
[10:25:55.051]   - Field: ‘owner’
[10:25:55.051]   - Field: ‘envir’
[10:25:55.051]   - Field: ‘workers’
[10:25:55.051]   - Field: ‘packages’
[10:25:55.051]   - Field: ‘gc’
[10:25:55.051]   - Field: ‘conditions’
[10:25:55.051]   - Field: ‘persistent’
[10:25:55.051]   - Field: ‘expr’
[10:25:55.052]   - Field: ‘uuid’
[10:25:55.052]   - Field: ‘seed’
[10:25:55.052]   - Field: ‘version’
[10:25:55.052]   - Field: ‘result’
[10:25:55.052]   - Field: ‘asynchronous’
[10:25:55.052]   - Field: ‘calls’
[10:25:55.052]   - Field: ‘globals’
[10:25:55.052]   - Field: ‘stdout’
[10:25:55.052]   - Field: ‘earlySignal’
[10:25:55.053]   - Field: ‘lazy’
[10:25:55.053]   - Field: ‘state’
[10:25:55.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.053] - Launch lazy future ...
[10:25:55.053] Packages needed by the future expression (n = 1): ‘stats’
[10:25:55.053] Packages needed by future strategies (n = 0): <none>
[10:25:55.054] {
[10:25:55.054]     {
[10:25:55.054]         {
[10:25:55.054]             ...future.startTime <- base::Sys.time()
[10:25:55.054]             {
[10:25:55.054]                 {
[10:25:55.054]                   {
[10:25:55.054]                     {
[10:25:55.054]                       {
[10:25:55.054]                         base::local({
[10:25:55.054]                           has_future <- base::requireNamespace("future", 
[10:25:55.054]                             quietly = TRUE)
[10:25:55.054]                           if (has_future) {
[10:25:55.054]                             ns <- base::getNamespace("future")
[10:25:55.054]                             version <- ns[[".package"]][["version"]]
[10:25:55.054]                             if (is.null(version)) 
[10:25:55.054]                               version <- utils::packageVersion("future")
[10:25:55.054]                           }
[10:25:55.054]                           else {
[10:25:55.054]                             version <- NULL
[10:25:55.054]                           }
[10:25:55.054]                           if (!has_future || version < "1.8.0") {
[10:25:55.054]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.054]                               "", base::R.version$version.string), 
[10:25:55.054]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.054]                                 base::R.version$platform, 8 * 
[10:25:55.054]                                   base::.Machine$sizeof.pointer), 
[10:25:55.054]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.054]                                 "release", "version")], collapse = " "), 
[10:25:55.054]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.054]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.054]                               info)
[10:25:55.054]                             info <- base::paste(info, collapse = "; ")
[10:25:55.054]                             if (!has_future) {
[10:25:55.054]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.054]                                 info)
[10:25:55.054]                             }
[10:25:55.054]                             else {
[10:25:55.054]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.054]                                 info, version)
[10:25:55.054]                             }
[10:25:55.054]                             base::stop(msg)
[10:25:55.054]                           }
[10:25:55.054]                         })
[10:25:55.054]                       }
[10:25:55.054]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.054]                       base::options(mc.cores = 1L)
[10:25:55.054]                     }
[10:25:55.054]                     base::local({
[10:25:55.054]                       for (pkg in "stats") {
[10:25:55.054]                         base::loadNamespace(pkg)
[10:25:55.054]                         base::library(pkg, character.only = TRUE)
[10:25:55.054]                       }
[10:25:55.054]                     })
[10:25:55.054]                   }
[10:25:55.054]                   options(future.plan = NULL)
[10:25:55.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.054]                 }
[10:25:55.054]                 ...future.workdir <- getwd()
[10:25:55.054]             }
[10:25:55.054]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.054]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.054]         }
[10:25:55.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.054]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.054]             base::names(...future.oldOptions))
[10:25:55.054]     }
[10:25:55.054]     if (FALSE) {
[10:25:55.054]     }
[10:25:55.054]     else {
[10:25:55.054]         if (TRUE) {
[10:25:55.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.054]                 open = "w")
[10:25:55.054]         }
[10:25:55.054]         else {
[10:25:55.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.054]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.054]         }
[10:25:55.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.054]             base::sink(type = "output", split = FALSE)
[10:25:55.054]             base::close(...future.stdout)
[10:25:55.054]         }, add = TRUE)
[10:25:55.054]     }
[10:25:55.054]     ...future.frame <- base::sys.nframe()
[10:25:55.054]     ...future.conditions <- base::list()
[10:25:55.054]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.054]     if (FALSE) {
[10:25:55.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.054]     }
[10:25:55.054]     ...future.result <- base::tryCatch({
[10:25:55.054]         base::withCallingHandlers({
[10:25:55.054]             ...future.value <- base::withVisible(base::local({
[10:25:55.054]                 ...future.makeSendCondition <- base::local({
[10:25:55.054]                   sendCondition <- NULL
[10:25:55.054]                   function(frame = 1L) {
[10:25:55.054]                     if (is.function(sendCondition)) 
[10:25:55.054]                       return(sendCondition)
[10:25:55.054]                     ns <- getNamespace("parallel")
[10:25:55.054]                     if (exists("sendData", mode = "function", 
[10:25:55.054]                       envir = ns)) {
[10:25:55.054]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.054]                         envir = ns)
[10:25:55.054]                       envir <- sys.frame(frame)
[10:25:55.054]                       master <- NULL
[10:25:55.054]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.054]                         !identical(envir, emptyenv())) {
[10:25:55.054]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.054]                           inherits = FALSE)) {
[10:25:55.054]                           master <- get("master", mode = "list", 
[10:25:55.054]                             envir = envir, inherits = FALSE)
[10:25:55.054]                           if (inherits(master, c("SOCKnode", 
[10:25:55.054]                             "SOCK0node"))) {
[10:25:55.054]                             sendCondition <<- function(cond) {
[10:25:55.054]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.054]                                 success = TRUE)
[10:25:55.054]                               parallel_sendData(master, data)
[10:25:55.054]                             }
[10:25:55.054]                             return(sendCondition)
[10:25:55.054]                           }
[10:25:55.054]                         }
[10:25:55.054]                         frame <- frame + 1L
[10:25:55.054]                         envir <- sys.frame(frame)
[10:25:55.054]                       }
[10:25:55.054]                     }
[10:25:55.054]                     sendCondition <<- function(cond) NULL
[10:25:55.054]                   }
[10:25:55.054]                 })
[10:25:55.054]                 withCallingHandlers({
[10:25:55.054]                   {
[10:25:55.054]                     lm(weight ~ group - 1)
[10:25:55.054]                   }
[10:25:55.054]                 }, immediateCondition = function(cond) {
[10:25:55.054]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.054]                   sendCondition(cond)
[10:25:55.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.054]                   {
[10:25:55.054]                     inherits <- base::inherits
[10:25:55.054]                     invokeRestart <- base::invokeRestart
[10:25:55.054]                     is.null <- base::is.null
[10:25:55.054]                     muffled <- FALSE
[10:25:55.054]                     if (inherits(cond, "message")) {
[10:25:55.054]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.054]                       if (muffled) 
[10:25:55.054]                         invokeRestart("muffleMessage")
[10:25:55.054]                     }
[10:25:55.054]                     else if (inherits(cond, "warning")) {
[10:25:55.054]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.054]                       if (muffled) 
[10:25:55.054]                         invokeRestart("muffleWarning")
[10:25:55.054]                     }
[10:25:55.054]                     else if (inherits(cond, "condition")) {
[10:25:55.054]                       if (!is.null(pattern)) {
[10:25:55.054]                         computeRestarts <- base::computeRestarts
[10:25:55.054]                         grepl <- base::grepl
[10:25:55.054]                         restarts <- computeRestarts(cond)
[10:25:55.054]                         for (restart in restarts) {
[10:25:55.054]                           name <- restart$name
[10:25:55.054]                           if (is.null(name)) 
[10:25:55.054]                             next
[10:25:55.054]                           if (!grepl(pattern, name)) 
[10:25:55.054]                             next
[10:25:55.054]                           invokeRestart(restart)
[10:25:55.054]                           muffled <- TRUE
[10:25:55.054]                           break
[10:25:55.054]                         }
[10:25:55.054]                       }
[10:25:55.054]                     }
[10:25:55.054]                     invisible(muffled)
[10:25:55.054]                   }
[10:25:55.054]                   muffleCondition(cond)
[10:25:55.054]                 })
[10:25:55.054]             }))
[10:25:55.054]             future::FutureResult(value = ...future.value$value, 
[10:25:55.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.054]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.054]                     ...future.globalenv.names))
[10:25:55.054]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.054]         }, condition = base::local({
[10:25:55.054]             c <- base::c
[10:25:55.054]             inherits <- base::inherits
[10:25:55.054]             invokeRestart <- base::invokeRestart
[10:25:55.054]             length <- base::length
[10:25:55.054]             list <- base::list
[10:25:55.054]             seq.int <- base::seq.int
[10:25:55.054]             signalCondition <- base::signalCondition
[10:25:55.054]             sys.calls <- base::sys.calls
[10:25:55.054]             `[[` <- base::`[[`
[10:25:55.054]             `+` <- base::`+`
[10:25:55.054]             `<<-` <- base::`<<-`
[10:25:55.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.054]                   3L)]
[10:25:55.054]             }
[10:25:55.054]             function(cond) {
[10:25:55.054]                 is_error <- inherits(cond, "error")
[10:25:55.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.054]                   NULL)
[10:25:55.054]                 if (is_error) {
[10:25:55.054]                   sessionInformation <- function() {
[10:25:55.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.054]                       search = base::search(), system = base::Sys.info())
[10:25:55.054]                   }
[10:25:55.054]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.054]                     cond$call), session = sessionInformation(), 
[10:25:55.054]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.054]                   signalCondition(cond)
[10:25:55.054]                 }
[10:25:55.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.054]                 "immediateCondition"))) {
[10:25:55.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.054]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.054]                   if (TRUE && !signal) {
[10:25:55.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.054]                     {
[10:25:55.054]                       inherits <- base::inherits
[10:25:55.054]                       invokeRestart <- base::invokeRestart
[10:25:55.054]                       is.null <- base::is.null
[10:25:55.054]                       muffled <- FALSE
[10:25:55.054]                       if (inherits(cond, "message")) {
[10:25:55.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.054]                         if (muffled) 
[10:25:55.054]                           invokeRestart("muffleMessage")
[10:25:55.054]                       }
[10:25:55.054]                       else if (inherits(cond, "warning")) {
[10:25:55.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.054]                         if (muffled) 
[10:25:55.054]                           invokeRestart("muffleWarning")
[10:25:55.054]                       }
[10:25:55.054]                       else if (inherits(cond, "condition")) {
[10:25:55.054]                         if (!is.null(pattern)) {
[10:25:55.054]                           computeRestarts <- base::computeRestarts
[10:25:55.054]                           grepl <- base::grepl
[10:25:55.054]                           restarts <- computeRestarts(cond)
[10:25:55.054]                           for (restart in restarts) {
[10:25:55.054]                             name <- restart$name
[10:25:55.054]                             if (is.null(name)) 
[10:25:55.054]                               next
[10:25:55.054]                             if (!grepl(pattern, name)) 
[10:25:55.054]                               next
[10:25:55.054]                             invokeRestart(restart)
[10:25:55.054]                             muffled <- TRUE
[10:25:55.054]                             break
[10:25:55.054]                           }
[10:25:55.054]                         }
[10:25:55.054]                       }
[10:25:55.054]                       invisible(muffled)
[10:25:55.054]                     }
[10:25:55.054]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.054]                   }
[10:25:55.054]                 }
[10:25:55.054]                 else {
[10:25:55.054]                   if (TRUE) {
[10:25:55.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.054]                     {
[10:25:55.054]                       inherits <- base::inherits
[10:25:55.054]                       invokeRestart <- base::invokeRestart
[10:25:55.054]                       is.null <- base::is.null
[10:25:55.054]                       muffled <- FALSE
[10:25:55.054]                       if (inherits(cond, "message")) {
[10:25:55.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.054]                         if (muffled) 
[10:25:55.054]                           invokeRestart("muffleMessage")
[10:25:55.054]                       }
[10:25:55.054]                       else if (inherits(cond, "warning")) {
[10:25:55.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.054]                         if (muffled) 
[10:25:55.054]                           invokeRestart("muffleWarning")
[10:25:55.054]                       }
[10:25:55.054]                       else if (inherits(cond, "condition")) {
[10:25:55.054]                         if (!is.null(pattern)) {
[10:25:55.054]                           computeRestarts <- base::computeRestarts
[10:25:55.054]                           grepl <- base::grepl
[10:25:55.054]                           restarts <- computeRestarts(cond)
[10:25:55.054]                           for (restart in restarts) {
[10:25:55.054]                             name <- restart$name
[10:25:55.054]                             if (is.null(name)) 
[10:25:55.054]                               next
[10:25:55.054]                             if (!grepl(pattern, name)) 
[10:25:55.054]                               next
[10:25:55.054]                             invokeRestart(restart)
[10:25:55.054]                             muffled <- TRUE
[10:25:55.054]                             break
[10:25:55.054]                           }
[10:25:55.054]                         }
[10:25:55.054]                       }
[10:25:55.054]                       invisible(muffled)
[10:25:55.054]                     }
[10:25:55.054]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.054]                   }
[10:25:55.054]                 }
[10:25:55.054]             }
[10:25:55.054]         }))
[10:25:55.054]     }, error = function(ex) {
[10:25:55.054]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.054]                 ...future.rng), started = ...future.startTime, 
[10:25:55.054]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.054]             version = "1.8"), class = "FutureResult")
[10:25:55.054]     }, finally = {
[10:25:55.054]         if (!identical(...future.workdir, getwd())) 
[10:25:55.054]             setwd(...future.workdir)
[10:25:55.054]         {
[10:25:55.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.054]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.054]             }
[10:25:55.054]             base::options(...future.oldOptions)
[10:25:55.054]             if (.Platform$OS.type == "windows") {
[10:25:55.054]                 old_names <- names(...future.oldEnvVars)
[10:25:55.054]                 envs <- base::Sys.getenv()
[10:25:55.054]                 names <- names(envs)
[10:25:55.054]                 common <- intersect(names, old_names)
[10:25:55.054]                 added <- setdiff(names, old_names)
[10:25:55.054]                 removed <- setdiff(old_names, names)
[10:25:55.054]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.054]                   envs[common]]
[10:25:55.054]                 NAMES <- toupper(changed)
[10:25:55.054]                 args <- list()
[10:25:55.054]                 for (kk in seq_along(NAMES)) {
[10:25:55.054]                   name <- changed[[kk]]
[10:25:55.054]                   NAME <- NAMES[[kk]]
[10:25:55.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.054]                     next
[10:25:55.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.054]                 }
[10:25:55.054]                 NAMES <- toupper(added)
[10:25:55.054]                 for (kk in seq_along(NAMES)) {
[10:25:55.054]                   name <- added[[kk]]
[10:25:55.054]                   NAME <- NAMES[[kk]]
[10:25:55.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.054]                     next
[10:25:55.054]                   args[[name]] <- ""
[10:25:55.054]                 }
[10:25:55.054]                 NAMES <- toupper(removed)
[10:25:55.054]                 for (kk in seq_along(NAMES)) {
[10:25:55.054]                   name <- removed[[kk]]
[10:25:55.054]                   NAME <- NAMES[[kk]]
[10:25:55.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.054]                     next
[10:25:55.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.054]                 }
[10:25:55.054]                 if (length(args) > 0) 
[10:25:55.054]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.054]             }
[10:25:55.054]             else {
[10:25:55.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.054]             }
[10:25:55.054]             {
[10:25:55.054]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.054]                   0L) {
[10:25:55.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.054]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.054]                   base::options(opts)
[10:25:55.054]                 }
[10:25:55.054]                 {
[10:25:55.054]                   {
[10:25:55.054]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.054]                     NULL
[10:25:55.054]                   }
[10:25:55.054]                   options(future.plan = NULL)
[10:25:55.054]                   if (is.na(NA_character_)) 
[10:25:55.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.054]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.054]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.054]                     envir = parent.frame()) 
[10:25:55.054]                   {
[10:25:55.054]                     if (is.function(workers)) 
[10:25:55.054]                       workers <- workers()
[10:25:55.054]                     workers <- structure(as.integer(workers), 
[10:25:55.054]                       class = class(workers))
[10:25:55.054]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.054]                       workers >= 1)
[10:25:55.054]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.054]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.054]                     }
[10:25:55.054]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.054]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.054]                       envir = envir)
[10:25:55.054]                     if (!future$lazy) 
[10:25:55.054]                       future <- run(future)
[10:25:55.054]                     invisible(future)
[10:25:55.054]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.054]                 }
[10:25:55.054]             }
[10:25:55.054]         }
[10:25:55.054]     })
[10:25:55.054]     if (TRUE) {
[10:25:55.054]         base::sink(type = "output", split = FALSE)
[10:25:55.054]         if (TRUE) {
[10:25:55.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.054]         }
[10:25:55.054]         else {
[10:25:55.054]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.054]         }
[10:25:55.054]         base::close(...future.stdout)
[10:25:55.054]         ...future.stdout <- NULL
[10:25:55.054]     }
[10:25:55.054]     ...future.result$conditions <- ...future.conditions
[10:25:55.054]     ...future.result$finished <- base::Sys.time()
[10:25:55.054]     ...future.result
[10:25:55.054] }
[10:25:55.057] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:25:55.057] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:25:55.058] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:25:55.058] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:25:55.060] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:25:55.061] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:25:55.061] MultisessionFuture started
[10:25:55.061] - Launch lazy future ... done
[10:25:55.061] run() for ‘MultisessionFuture’ ... done
[10:25:55.062] result() for ClusterFuture ...
[10:25:55.062] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.062] - Validating connection of MultisessionFuture
[10:25:55.112] - received message: FutureResult
[10:25:55.112] - Received FutureResult
[10:25:55.112] - Erased future from FutureRegistry
[10:25:55.112] result() for ClusterFuture ...
[10:25:55.112] - result already collected: FutureResult
[10:25:55.112] result() for ClusterFuture ... done
[10:25:55.112] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.113] result() for ClusterFuture ... done
[10:25:55.113] result() for ClusterFuture ...
[10:25:55.113] - result already collected: FutureResult
[10:25:55.113] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:55.115] getGlobalsAndPackages() ...
[10:25:55.115] Searching for globals...
[10:25:55.116] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:55.116] Searching for globals ... DONE
[10:25:55.117] Resolving globals: FALSE
[10:25:55.117] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:55.117] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:55.118] - globals: [2] ‘weight’, ‘group’
[10:25:55.118] - packages: [1] ‘stats’
[10:25:55.118] getGlobalsAndPackages() ... DONE
[10:25:55.118] run() for ‘Future’ ...
[10:25:55.118] - state: ‘created’
[10:25:55.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.132]   - Field: ‘node’
[10:25:55.132]   - Field: ‘label’
[10:25:55.132]   - Field: ‘local’
[10:25:55.133]   - Field: ‘owner’
[10:25:55.133]   - Field: ‘envir’
[10:25:55.133]   - Field: ‘workers’
[10:25:55.133]   - Field: ‘packages’
[10:25:55.133]   - Field: ‘gc’
[10:25:55.133]   - Field: ‘conditions’
[10:25:55.133]   - Field: ‘persistent’
[10:25:55.133]   - Field: ‘expr’
[10:25:55.133]   - Field: ‘uuid’
[10:25:55.133]   - Field: ‘seed’
[10:25:55.133]   - Field: ‘version’
[10:25:55.134]   - Field: ‘result’
[10:25:55.134]   - Field: ‘asynchronous’
[10:25:55.134]   - Field: ‘calls’
[10:25:55.134]   - Field: ‘globals’
[10:25:55.134]   - Field: ‘stdout’
[10:25:55.134]   - Field: ‘earlySignal’
[10:25:55.134]   - Field: ‘lazy’
[10:25:55.134]   - Field: ‘state’
[10:25:55.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.134] - Launch lazy future ...
[10:25:55.135] Packages needed by the future expression (n = 1): ‘stats’
[10:25:55.135] Packages needed by future strategies (n = 0): <none>
[10:25:55.135] {
[10:25:55.135]     {
[10:25:55.135]         {
[10:25:55.135]             ...future.startTime <- base::Sys.time()
[10:25:55.135]             {
[10:25:55.135]                 {
[10:25:55.135]                   {
[10:25:55.135]                     {
[10:25:55.135]                       {
[10:25:55.135]                         base::local({
[10:25:55.135]                           has_future <- base::requireNamespace("future", 
[10:25:55.135]                             quietly = TRUE)
[10:25:55.135]                           if (has_future) {
[10:25:55.135]                             ns <- base::getNamespace("future")
[10:25:55.135]                             version <- ns[[".package"]][["version"]]
[10:25:55.135]                             if (is.null(version)) 
[10:25:55.135]                               version <- utils::packageVersion("future")
[10:25:55.135]                           }
[10:25:55.135]                           else {
[10:25:55.135]                             version <- NULL
[10:25:55.135]                           }
[10:25:55.135]                           if (!has_future || version < "1.8.0") {
[10:25:55.135]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.135]                               "", base::R.version$version.string), 
[10:25:55.135]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.135]                                 base::R.version$platform, 8 * 
[10:25:55.135]                                   base::.Machine$sizeof.pointer), 
[10:25:55.135]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.135]                                 "release", "version")], collapse = " "), 
[10:25:55.135]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.135]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.135]                               info)
[10:25:55.135]                             info <- base::paste(info, collapse = "; ")
[10:25:55.135]                             if (!has_future) {
[10:25:55.135]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.135]                                 info)
[10:25:55.135]                             }
[10:25:55.135]                             else {
[10:25:55.135]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.135]                                 info, version)
[10:25:55.135]                             }
[10:25:55.135]                             base::stop(msg)
[10:25:55.135]                           }
[10:25:55.135]                         })
[10:25:55.135]                       }
[10:25:55.135]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.135]                       base::options(mc.cores = 1L)
[10:25:55.135]                     }
[10:25:55.135]                     base::local({
[10:25:55.135]                       for (pkg in "stats") {
[10:25:55.135]                         base::loadNamespace(pkg)
[10:25:55.135]                         base::library(pkg, character.only = TRUE)
[10:25:55.135]                       }
[10:25:55.135]                     })
[10:25:55.135]                   }
[10:25:55.135]                   options(future.plan = NULL)
[10:25:55.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.135]                 }
[10:25:55.135]                 ...future.workdir <- getwd()
[10:25:55.135]             }
[10:25:55.135]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.135]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.135]         }
[10:25:55.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.135]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.135]             base::names(...future.oldOptions))
[10:25:55.135]     }
[10:25:55.135]     if (FALSE) {
[10:25:55.135]     }
[10:25:55.135]     else {
[10:25:55.135]         if (TRUE) {
[10:25:55.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.135]                 open = "w")
[10:25:55.135]         }
[10:25:55.135]         else {
[10:25:55.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.135]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.135]         }
[10:25:55.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.135]             base::sink(type = "output", split = FALSE)
[10:25:55.135]             base::close(...future.stdout)
[10:25:55.135]         }, add = TRUE)
[10:25:55.135]     }
[10:25:55.135]     ...future.frame <- base::sys.nframe()
[10:25:55.135]     ...future.conditions <- base::list()
[10:25:55.135]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.135]     if (FALSE) {
[10:25:55.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.135]     }
[10:25:55.135]     ...future.result <- base::tryCatch({
[10:25:55.135]         base::withCallingHandlers({
[10:25:55.135]             ...future.value <- base::withVisible(base::local({
[10:25:55.135]                 ...future.makeSendCondition <- base::local({
[10:25:55.135]                   sendCondition <- NULL
[10:25:55.135]                   function(frame = 1L) {
[10:25:55.135]                     if (is.function(sendCondition)) 
[10:25:55.135]                       return(sendCondition)
[10:25:55.135]                     ns <- getNamespace("parallel")
[10:25:55.135]                     if (exists("sendData", mode = "function", 
[10:25:55.135]                       envir = ns)) {
[10:25:55.135]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.135]                         envir = ns)
[10:25:55.135]                       envir <- sys.frame(frame)
[10:25:55.135]                       master <- NULL
[10:25:55.135]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.135]                         !identical(envir, emptyenv())) {
[10:25:55.135]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.135]                           inherits = FALSE)) {
[10:25:55.135]                           master <- get("master", mode = "list", 
[10:25:55.135]                             envir = envir, inherits = FALSE)
[10:25:55.135]                           if (inherits(master, c("SOCKnode", 
[10:25:55.135]                             "SOCK0node"))) {
[10:25:55.135]                             sendCondition <<- function(cond) {
[10:25:55.135]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.135]                                 success = TRUE)
[10:25:55.135]                               parallel_sendData(master, data)
[10:25:55.135]                             }
[10:25:55.135]                             return(sendCondition)
[10:25:55.135]                           }
[10:25:55.135]                         }
[10:25:55.135]                         frame <- frame + 1L
[10:25:55.135]                         envir <- sys.frame(frame)
[10:25:55.135]                       }
[10:25:55.135]                     }
[10:25:55.135]                     sendCondition <<- function(cond) NULL
[10:25:55.135]                   }
[10:25:55.135]                 })
[10:25:55.135]                 withCallingHandlers({
[10:25:55.135]                   {
[10:25:55.135]                     lm(weight ~ group - 1)
[10:25:55.135]                   }
[10:25:55.135]                 }, immediateCondition = function(cond) {
[10:25:55.135]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.135]                   sendCondition(cond)
[10:25:55.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.135]                   {
[10:25:55.135]                     inherits <- base::inherits
[10:25:55.135]                     invokeRestart <- base::invokeRestart
[10:25:55.135]                     is.null <- base::is.null
[10:25:55.135]                     muffled <- FALSE
[10:25:55.135]                     if (inherits(cond, "message")) {
[10:25:55.135]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.135]                       if (muffled) 
[10:25:55.135]                         invokeRestart("muffleMessage")
[10:25:55.135]                     }
[10:25:55.135]                     else if (inherits(cond, "warning")) {
[10:25:55.135]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.135]                       if (muffled) 
[10:25:55.135]                         invokeRestart("muffleWarning")
[10:25:55.135]                     }
[10:25:55.135]                     else if (inherits(cond, "condition")) {
[10:25:55.135]                       if (!is.null(pattern)) {
[10:25:55.135]                         computeRestarts <- base::computeRestarts
[10:25:55.135]                         grepl <- base::grepl
[10:25:55.135]                         restarts <- computeRestarts(cond)
[10:25:55.135]                         for (restart in restarts) {
[10:25:55.135]                           name <- restart$name
[10:25:55.135]                           if (is.null(name)) 
[10:25:55.135]                             next
[10:25:55.135]                           if (!grepl(pattern, name)) 
[10:25:55.135]                             next
[10:25:55.135]                           invokeRestart(restart)
[10:25:55.135]                           muffled <- TRUE
[10:25:55.135]                           break
[10:25:55.135]                         }
[10:25:55.135]                       }
[10:25:55.135]                     }
[10:25:55.135]                     invisible(muffled)
[10:25:55.135]                   }
[10:25:55.135]                   muffleCondition(cond)
[10:25:55.135]                 })
[10:25:55.135]             }))
[10:25:55.135]             future::FutureResult(value = ...future.value$value, 
[10:25:55.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.135]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.135]                     ...future.globalenv.names))
[10:25:55.135]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.135]         }, condition = base::local({
[10:25:55.135]             c <- base::c
[10:25:55.135]             inherits <- base::inherits
[10:25:55.135]             invokeRestart <- base::invokeRestart
[10:25:55.135]             length <- base::length
[10:25:55.135]             list <- base::list
[10:25:55.135]             seq.int <- base::seq.int
[10:25:55.135]             signalCondition <- base::signalCondition
[10:25:55.135]             sys.calls <- base::sys.calls
[10:25:55.135]             `[[` <- base::`[[`
[10:25:55.135]             `+` <- base::`+`
[10:25:55.135]             `<<-` <- base::`<<-`
[10:25:55.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.135]                   3L)]
[10:25:55.135]             }
[10:25:55.135]             function(cond) {
[10:25:55.135]                 is_error <- inherits(cond, "error")
[10:25:55.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.135]                   NULL)
[10:25:55.135]                 if (is_error) {
[10:25:55.135]                   sessionInformation <- function() {
[10:25:55.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.135]                       search = base::search(), system = base::Sys.info())
[10:25:55.135]                   }
[10:25:55.135]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.135]                     cond$call), session = sessionInformation(), 
[10:25:55.135]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.135]                   signalCondition(cond)
[10:25:55.135]                 }
[10:25:55.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.135]                 "immediateCondition"))) {
[10:25:55.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.135]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.135]                   if (TRUE && !signal) {
[10:25:55.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.135]                     {
[10:25:55.135]                       inherits <- base::inherits
[10:25:55.135]                       invokeRestart <- base::invokeRestart
[10:25:55.135]                       is.null <- base::is.null
[10:25:55.135]                       muffled <- FALSE
[10:25:55.135]                       if (inherits(cond, "message")) {
[10:25:55.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.135]                         if (muffled) 
[10:25:55.135]                           invokeRestart("muffleMessage")
[10:25:55.135]                       }
[10:25:55.135]                       else if (inherits(cond, "warning")) {
[10:25:55.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.135]                         if (muffled) 
[10:25:55.135]                           invokeRestart("muffleWarning")
[10:25:55.135]                       }
[10:25:55.135]                       else if (inherits(cond, "condition")) {
[10:25:55.135]                         if (!is.null(pattern)) {
[10:25:55.135]                           computeRestarts <- base::computeRestarts
[10:25:55.135]                           grepl <- base::grepl
[10:25:55.135]                           restarts <- computeRestarts(cond)
[10:25:55.135]                           for (restart in restarts) {
[10:25:55.135]                             name <- restart$name
[10:25:55.135]                             if (is.null(name)) 
[10:25:55.135]                               next
[10:25:55.135]                             if (!grepl(pattern, name)) 
[10:25:55.135]                               next
[10:25:55.135]                             invokeRestart(restart)
[10:25:55.135]                             muffled <- TRUE
[10:25:55.135]                             break
[10:25:55.135]                           }
[10:25:55.135]                         }
[10:25:55.135]                       }
[10:25:55.135]                       invisible(muffled)
[10:25:55.135]                     }
[10:25:55.135]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.135]                   }
[10:25:55.135]                 }
[10:25:55.135]                 else {
[10:25:55.135]                   if (TRUE) {
[10:25:55.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.135]                     {
[10:25:55.135]                       inherits <- base::inherits
[10:25:55.135]                       invokeRestart <- base::invokeRestart
[10:25:55.135]                       is.null <- base::is.null
[10:25:55.135]                       muffled <- FALSE
[10:25:55.135]                       if (inherits(cond, "message")) {
[10:25:55.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.135]                         if (muffled) 
[10:25:55.135]                           invokeRestart("muffleMessage")
[10:25:55.135]                       }
[10:25:55.135]                       else if (inherits(cond, "warning")) {
[10:25:55.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.135]                         if (muffled) 
[10:25:55.135]                           invokeRestart("muffleWarning")
[10:25:55.135]                       }
[10:25:55.135]                       else if (inherits(cond, "condition")) {
[10:25:55.135]                         if (!is.null(pattern)) {
[10:25:55.135]                           computeRestarts <- base::computeRestarts
[10:25:55.135]                           grepl <- base::grepl
[10:25:55.135]                           restarts <- computeRestarts(cond)
[10:25:55.135]                           for (restart in restarts) {
[10:25:55.135]                             name <- restart$name
[10:25:55.135]                             if (is.null(name)) 
[10:25:55.135]                               next
[10:25:55.135]                             if (!grepl(pattern, name)) 
[10:25:55.135]                               next
[10:25:55.135]                             invokeRestart(restart)
[10:25:55.135]                             muffled <- TRUE
[10:25:55.135]                             break
[10:25:55.135]                           }
[10:25:55.135]                         }
[10:25:55.135]                       }
[10:25:55.135]                       invisible(muffled)
[10:25:55.135]                     }
[10:25:55.135]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.135]                   }
[10:25:55.135]                 }
[10:25:55.135]             }
[10:25:55.135]         }))
[10:25:55.135]     }, error = function(ex) {
[10:25:55.135]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.135]                 ...future.rng), started = ...future.startTime, 
[10:25:55.135]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.135]             version = "1.8"), class = "FutureResult")
[10:25:55.135]     }, finally = {
[10:25:55.135]         if (!identical(...future.workdir, getwd())) 
[10:25:55.135]             setwd(...future.workdir)
[10:25:55.135]         {
[10:25:55.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.135]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.135]             }
[10:25:55.135]             base::options(...future.oldOptions)
[10:25:55.135]             if (.Platform$OS.type == "windows") {
[10:25:55.135]                 old_names <- names(...future.oldEnvVars)
[10:25:55.135]                 envs <- base::Sys.getenv()
[10:25:55.135]                 names <- names(envs)
[10:25:55.135]                 common <- intersect(names, old_names)
[10:25:55.135]                 added <- setdiff(names, old_names)
[10:25:55.135]                 removed <- setdiff(old_names, names)
[10:25:55.135]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.135]                   envs[common]]
[10:25:55.135]                 NAMES <- toupper(changed)
[10:25:55.135]                 args <- list()
[10:25:55.135]                 for (kk in seq_along(NAMES)) {
[10:25:55.135]                   name <- changed[[kk]]
[10:25:55.135]                   NAME <- NAMES[[kk]]
[10:25:55.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.135]                     next
[10:25:55.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.135]                 }
[10:25:55.135]                 NAMES <- toupper(added)
[10:25:55.135]                 for (kk in seq_along(NAMES)) {
[10:25:55.135]                   name <- added[[kk]]
[10:25:55.135]                   NAME <- NAMES[[kk]]
[10:25:55.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.135]                     next
[10:25:55.135]                   args[[name]] <- ""
[10:25:55.135]                 }
[10:25:55.135]                 NAMES <- toupper(removed)
[10:25:55.135]                 for (kk in seq_along(NAMES)) {
[10:25:55.135]                   name <- removed[[kk]]
[10:25:55.135]                   NAME <- NAMES[[kk]]
[10:25:55.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.135]                     next
[10:25:55.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.135]                 }
[10:25:55.135]                 if (length(args) > 0) 
[10:25:55.135]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.135]             }
[10:25:55.135]             else {
[10:25:55.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.135]             }
[10:25:55.135]             {
[10:25:55.135]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.135]                   0L) {
[10:25:55.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.135]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.135]                   base::options(opts)
[10:25:55.135]                 }
[10:25:55.135]                 {
[10:25:55.135]                   {
[10:25:55.135]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.135]                     NULL
[10:25:55.135]                   }
[10:25:55.135]                   options(future.plan = NULL)
[10:25:55.135]                   if (is.na(NA_character_)) 
[10:25:55.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.135]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.135]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.135]                     envir = parent.frame()) 
[10:25:55.135]                   {
[10:25:55.135]                     if (is.function(workers)) 
[10:25:55.135]                       workers <- workers()
[10:25:55.135]                     workers <- structure(as.integer(workers), 
[10:25:55.135]                       class = class(workers))
[10:25:55.135]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.135]                       workers >= 1)
[10:25:55.135]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.135]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.135]                     }
[10:25:55.135]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.135]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.135]                       envir = envir)
[10:25:55.135]                     if (!future$lazy) 
[10:25:55.135]                       future <- run(future)
[10:25:55.135]                     invisible(future)
[10:25:55.135]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.135]                 }
[10:25:55.135]             }
[10:25:55.135]         }
[10:25:55.135]     })
[10:25:55.135]     if (TRUE) {
[10:25:55.135]         base::sink(type = "output", split = FALSE)
[10:25:55.135]         if (TRUE) {
[10:25:55.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.135]         }
[10:25:55.135]         else {
[10:25:55.135]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.135]         }
[10:25:55.135]         base::close(...future.stdout)
[10:25:55.135]         ...future.stdout <- NULL
[10:25:55.135]     }
[10:25:55.135]     ...future.result$conditions <- ...future.conditions
[10:25:55.135]     ...future.result$finished <- base::Sys.time()
[10:25:55.135]     ...future.result
[10:25:55.135] }
[10:25:55.138] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:25:55.138] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:25:55.139] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:25:55.139] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:25:55.139] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:25:55.139] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:25:55.140] MultisessionFuture started
[10:25:55.140] - Launch lazy future ... done
[10:25:55.140] run() for ‘MultisessionFuture’ ... done
[10:25:55.140] result() for ClusterFuture ...
[10:25:55.140] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.140] - Validating connection of MultisessionFuture
[10:25:55.187] - received message: FutureResult
[10:25:55.187] - Received FutureResult
[10:25:55.187] - Erased future from FutureRegistry
[10:25:55.188] result() for ClusterFuture ...
[10:25:55.188] - result already collected: FutureResult
[10:25:55.188] result() for ClusterFuture ... done
[10:25:55.188] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.188] result() for ClusterFuture ... done
[10:25:55.188] result() for ClusterFuture ...
[10:25:55.188] - result already collected: FutureResult
[10:25:55.188] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:25:55.190] getGlobalsAndPackages() ...
[10:25:55.190] Searching for globals...
[10:25:55.191] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:25:55.192] Searching for globals ... DONE
[10:25:55.192] Resolving globals: FALSE
[10:25:55.192] The total size of the 2 globals is 896 bytes (896 bytes)
[10:25:55.192] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 896 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (688 bytes of class ‘numeric’) and ‘weight’ (208 bytes of class ‘numeric’)
[10:25:55.193] - globals: [2] ‘weight’, ‘group’
[10:25:55.193] - packages: [1] ‘stats’
[10:25:55.193] getGlobalsAndPackages() ... DONE
[10:25:55.193] run() for ‘Future’ ...
[10:25:55.193] - state: ‘created’
[10:25:55.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.209]   - Field: ‘node’
[10:25:55.209]   - Field: ‘label’
[10:25:55.209]   - Field: ‘local’
[10:25:55.210]   - Field: ‘owner’
[10:25:55.210]   - Field: ‘envir’
[10:25:55.210]   - Field: ‘workers’
[10:25:55.210]   - Field: ‘packages’
[10:25:55.210]   - Field: ‘gc’
[10:25:55.210]   - Field: ‘conditions’
[10:25:55.210]   - Field: ‘persistent’
[10:25:55.210]   - Field: ‘expr’
[10:25:55.210]   - Field: ‘uuid’
[10:25:55.210]   - Field: ‘seed’
[10:25:55.210]   - Field: ‘version’
[10:25:55.211]   - Field: ‘result’
[10:25:55.211]   - Field: ‘asynchronous’
[10:25:55.211]   - Field: ‘calls’
[10:25:55.211]   - Field: ‘globals’
[10:25:55.211]   - Field: ‘stdout’
[10:25:55.211]   - Field: ‘earlySignal’
[10:25:55.211]   - Field: ‘lazy’
[10:25:55.211]   - Field: ‘state’
[10:25:55.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.211] - Launch lazy future ...
[10:25:55.212] Packages needed by the future expression (n = 1): ‘stats’
[10:25:55.212] Packages needed by future strategies (n = 0): <none>
[10:25:55.212] {
[10:25:55.212]     {
[10:25:55.212]         {
[10:25:55.212]             ...future.startTime <- base::Sys.time()
[10:25:55.212]             {
[10:25:55.212]                 {
[10:25:55.212]                   {
[10:25:55.212]                     {
[10:25:55.212]                       {
[10:25:55.212]                         base::local({
[10:25:55.212]                           has_future <- base::requireNamespace("future", 
[10:25:55.212]                             quietly = TRUE)
[10:25:55.212]                           if (has_future) {
[10:25:55.212]                             ns <- base::getNamespace("future")
[10:25:55.212]                             version <- ns[[".package"]][["version"]]
[10:25:55.212]                             if (is.null(version)) 
[10:25:55.212]                               version <- utils::packageVersion("future")
[10:25:55.212]                           }
[10:25:55.212]                           else {
[10:25:55.212]                             version <- NULL
[10:25:55.212]                           }
[10:25:55.212]                           if (!has_future || version < "1.8.0") {
[10:25:55.212]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.212]                               "", base::R.version$version.string), 
[10:25:55.212]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.212]                                 base::R.version$platform, 8 * 
[10:25:55.212]                                   base::.Machine$sizeof.pointer), 
[10:25:55.212]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.212]                                 "release", "version")], collapse = " "), 
[10:25:55.212]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.212]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.212]                               info)
[10:25:55.212]                             info <- base::paste(info, collapse = "; ")
[10:25:55.212]                             if (!has_future) {
[10:25:55.212]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.212]                                 info)
[10:25:55.212]                             }
[10:25:55.212]                             else {
[10:25:55.212]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.212]                                 info, version)
[10:25:55.212]                             }
[10:25:55.212]                             base::stop(msg)
[10:25:55.212]                           }
[10:25:55.212]                         })
[10:25:55.212]                       }
[10:25:55.212]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.212]                       base::options(mc.cores = 1L)
[10:25:55.212]                     }
[10:25:55.212]                     base::local({
[10:25:55.212]                       for (pkg in "stats") {
[10:25:55.212]                         base::loadNamespace(pkg)
[10:25:55.212]                         base::library(pkg, character.only = TRUE)
[10:25:55.212]                       }
[10:25:55.212]                     })
[10:25:55.212]                   }
[10:25:55.212]                   options(future.plan = NULL)
[10:25:55.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.212]                 }
[10:25:55.212]                 ...future.workdir <- getwd()
[10:25:55.212]             }
[10:25:55.212]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.212]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.212]         }
[10:25:55.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.212]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.212]             base::names(...future.oldOptions))
[10:25:55.212]     }
[10:25:55.212]     if (FALSE) {
[10:25:55.212]     }
[10:25:55.212]     else {
[10:25:55.212]         if (TRUE) {
[10:25:55.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.212]                 open = "w")
[10:25:55.212]         }
[10:25:55.212]         else {
[10:25:55.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.212]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.212]         }
[10:25:55.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.212]             base::sink(type = "output", split = FALSE)
[10:25:55.212]             base::close(...future.stdout)
[10:25:55.212]         }, add = TRUE)
[10:25:55.212]     }
[10:25:55.212]     ...future.frame <- base::sys.nframe()
[10:25:55.212]     ...future.conditions <- base::list()
[10:25:55.212]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.212]     if (FALSE) {
[10:25:55.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.212]     }
[10:25:55.212]     ...future.result <- base::tryCatch({
[10:25:55.212]         base::withCallingHandlers({
[10:25:55.212]             ...future.value <- base::withVisible(base::local({
[10:25:55.212]                 ...future.makeSendCondition <- base::local({
[10:25:55.212]                   sendCondition <- NULL
[10:25:55.212]                   function(frame = 1L) {
[10:25:55.212]                     if (is.function(sendCondition)) 
[10:25:55.212]                       return(sendCondition)
[10:25:55.212]                     ns <- getNamespace("parallel")
[10:25:55.212]                     if (exists("sendData", mode = "function", 
[10:25:55.212]                       envir = ns)) {
[10:25:55.212]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.212]                         envir = ns)
[10:25:55.212]                       envir <- sys.frame(frame)
[10:25:55.212]                       master <- NULL
[10:25:55.212]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.212]                         !identical(envir, emptyenv())) {
[10:25:55.212]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.212]                           inherits = FALSE)) {
[10:25:55.212]                           master <- get("master", mode = "list", 
[10:25:55.212]                             envir = envir, inherits = FALSE)
[10:25:55.212]                           if (inherits(master, c("SOCKnode", 
[10:25:55.212]                             "SOCK0node"))) {
[10:25:55.212]                             sendCondition <<- function(cond) {
[10:25:55.212]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.212]                                 success = TRUE)
[10:25:55.212]                               parallel_sendData(master, data)
[10:25:55.212]                             }
[10:25:55.212]                             return(sendCondition)
[10:25:55.212]                           }
[10:25:55.212]                         }
[10:25:55.212]                         frame <- frame + 1L
[10:25:55.212]                         envir <- sys.frame(frame)
[10:25:55.212]                       }
[10:25:55.212]                     }
[10:25:55.212]                     sendCondition <<- function(cond) NULL
[10:25:55.212]                   }
[10:25:55.212]                 })
[10:25:55.212]                 withCallingHandlers({
[10:25:55.212]                   {
[10:25:55.212]                     lm(weight ~ group - 1)
[10:25:55.212]                   }
[10:25:55.212]                 }, immediateCondition = function(cond) {
[10:25:55.212]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.212]                   sendCondition(cond)
[10:25:55.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.212]                   {
[10:25:55.212]                     inherits <- base::inherits
[10:25:55.212]                     invokeRestart <- base::invokeRestart
[10:25:55.212]                     is.null <- base::is.null
[10:25:55.212]                     muffled <- FALSE
[10:25:55.212]                     if (inherits(cond, "message")) {
[10:25:55.212]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.212]                       if (muffled) 
[10:25:55.212]                         invokeRestart("muffleMessage")
[10:25:55.212]                     }
[10:25:55.212]                     else if (inherits(cond, "warning")) {
[10:25:55.212]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.212]                       if (muffled) 
[10:25:55.212]                         invokeRestart("muffleWarning")
[10:25:55.212]                     }
[10:25:55.212]                     else if (inherits(cond, "condition")) {
[10:25:55.212]                       if (!is.null(pattern)) {
[10:25:55.212]                         computeRestarts <- base::computeRestarts
[10:25:55.212]                         grepl <- base::grepl
[10:25:55.212]                         restarts <- computeRestarts(cond)
[10:25:55.212]                         for (restart in restarts) {
[10:25:55.212]                           name <- restart$name
[10:25:55.212]                           if (is.null(name)) 
[10:25:55.212]                             next
[10:25:55.212]                           if (!grepl(pattern, name)) 
[10:25:55.212]                             next
[10:25:55.212]                           invokeRestart(restart)
[10:25:55.212]                           muffled <- TRUE
[10:25:55.212]                           break
[10:25:55.212]                         }
[10:25:55.212]                       }
[10:25:55.212]                     }
[10:25:55.212]                     invisible(muffled)
[10:25:55.212]                   }
[10:25:55.212]                   muffleCondition(cond)
[10:25:55.212]                 })
[10:25:55.212]             }))
[10:25:55.212]             future::FutureResult(value = ...future.value$value, 
[10:25:55.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.212]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.212]                     ...future.globalenv.names))
[10:25:55.212]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.212]         }, condition = base::local({
[10:25:55.212]             c <- base::c
[10:25:55.212]             inherits <- base::inherits
[10:25:55.212]             invokeRestart <- base::invokeRestart
[10:25:55.212]             length <- base::length
[10:25:55.212]             list <- base::list
[10:25:55.212]             seq.int <- base::seq.int
[10:25:55.212]             signalCondition <- base::signalCondition
[10:25:55.212]             sys.calls <- base::sys.calls
[10:25:55.212]             `[[` <- base::`[[`
[10:25:55.212]             `+` <- base::`+`
[10:25:55.212]             `<<-` <- base::`<<-`
[10:25:55.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.212]                   3L)]
[10:25:55.212]             }
[10:25:55.212]             function(cond) {
[10:25:55.212]                 is_error <- inherits(cond, "error")
[10:25:55.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.212]                   NULL)
[10:25:55.212]                 if (is_error) {
[10:25:55.212]                   sessionInformation <- function() {
[10:25:55.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.212]                       search = base::search(), system = base::Sys.info())
[10:25:55.212]                   }
[10:25:55.212]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.212]                     cond$call), session = sessionInformation(), 
[10:25:55.212]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.212]                   signalCondition(cond)
[10:25:55.212]                 }
[10:25:55.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.212]                 "immediateCondition"))) {
[10:25:55.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.212]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.212]                   if (TRUE && !signal) {
[10:25:55.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.212]                     {
[10:25:55.212]                       inherits <- base::inherits
[10:25:55.212]                       invokeRestart <- base::invokeRestart
[10:25:55.212]                       is.null <- base::is.null
[10:25:55.212]                       muffled <- FALSE
[10:25:55.212]                       if (inherits(cond, "message")) {
[10:25:55.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.212]                         if (muffled) 
[10:25:55.212]                           invokeRestart("muffleMessage")
[10:25:55.212]                       }
[10:25:55.212]                       else if (inherits(cond, "warning")) {
[10:25:55.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.212]                         if (muffled) 
[10:25:55.212]                           invokeRestart("muffleWarning")
[10:25:55.212]                       }
[10:25:55.212]                       else if (inherits(cond, "condition")) {
[10:25:55.212]                         if (!is.null(pattern)) {
[10:25:55.212]                           computeRestarts <- base::computeRestarts
[10:25:55.212]                           grepl <- base::grepl
[10:25:55.212]                           restarts <- computeRestarts(cond)
[10:25:55.212]                           for (restart in restarts) {
[10:25:55.212]                             name <- restart$name
[10:25:55.212]                             if (is.null(name)) 
[10:25:55.212]                               next
[10:25:55.212]                             if (!grepl(pattern, name)) 
[10:25:55.212]                               next
[10:25:55.212]                             invokeRestart(restart)
[10:25:55.212]                             muffled <- TRUE
[10:25:55.212]                             break
[10:25:55.212]                           }
[10:25:55.212]                         }
[10:25:55.212]                       }
[10:25:55.212]                       invisible(muffled)
[10:25:55.212]                     }
[10:25:55.212]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.212]                   }
[10:25:55.212]                 }
[10:25:55.212]                 else {
[10:25:55.212]                   if (TRUE) {
[10:25:55.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.212]                     {
[10:25:55.212]                       inherits <- base::inherits
[10:25:55.212]                       invokeRestart <- base::invokeRestart
[10:25:55.212]                       is.null <- base::is.null
[10:25:55.212]                       muffled <- FALSE
[10:25:55.212]                       if (inherits(cond, "message")) {
[10:25:55.212]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.212]                         if (muffled) 
[10:25:55.212]                           invokeRestart("muffleMessage")
[10:25:55.212]                       }
[10:25:55.212]                       else if (inherits(cond, "warning")) {
[10:25:55.212]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.212]                         if (muffled) 
[10:25:55.212]                           invokeRestart("muffleWarning")
[10:25:55.212]                       }
[10:25:55.212]                       else if (inherits(cond, "condition")) {
[10:25:55.212]                         if (!is.null(pattern)) {
[10:25:55.212]                           computeRestarts <- base::computeRestarts
[10:25:55.212]                           grepl <- base::grepl
[10:25:55.212]                           restarts <- computeRestarts(cond)
[10:25:55.212]                           for (restart in restarts) {
[10:25:55.212]                             name <- restart$name
[10:25:55.212]                             if (is.null(name)) 
[10:25:55.212]                               next
[10:25:55.212]                             if (!grepl(pattern, name)) 
[10:25:55.212]                               next
[10:25:55.212]                             invokeRestart(restart)
[10:25:55.212]                             muffled <- TRUE
[10:25:55.212]                             break
[10:25:55.212]                           }
[10:25:55.212]                         }
[10:25:55.212]                       }
[10:25:55.212]                       invisible(muffled)
[10:25:55.212]                     }
[10:25:55.212]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.212]                   }
[10:25:55.212]                 }
[10:25:55.212]             }
[10:25:55.212]         }))
[10:25:55.212]     }, error = function(ex) {
[10:25:55.212]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.212]                 ...future.rng), started = ...future.startTime, 
[10:25:55.212]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.212]             version = "1.8"), class = "FutureResult")
[10:25:55.212]     }, finally = {
[10:25:55.212]         if (!identical(...future.workdir, getwd())) 
[10:25:55.212]             setwd(...future.workdir)
[10:25:55.212]         {
[10:25:55.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.212]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.212]             }
[10:25:55.212]             base::options(...future.oldOptions)
[10:25:55.212]             if (.Platform$OS.type == "windows") {
[10:25:55.212]                 old_names <- names(...future.oldEnvVars)
[10:25:55.212]                 envs <- base::Sys.getenv()
[10:25:55.212]                 names <- names(envs)
[10:25:55.212]                 common <- intersect(names, old_names)
[10:25:55.212]                 added <- setdiff(names, old_names)
[10:25:55.212]                 removed <- setdiff(old_names, names)
[10:25:55.212]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.212]                   envs[common]]
[10:25:55.212]                 NAMES <- toupper(changed)
[10:25:55.212]                 args <- list()
[10:25:55.212]                 for (kk in seq_along(NAMES)) {
[10:25:55.212]                   name <- changed[[kk]]
[10:25:55.212]                   NAME <- NAMES[[kk]]
[10:25:55.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.212]                     next
[10:25:55.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.212]                 }
[10:25:55.212]                 NAMES <- toupper(added)
[10:25:55.212]                 for (kk in seq_along(NAMES)) {
[10:25:55.212]                   name <- added[[kk]]
[10:25:55.212]                   NAME <- NAMES[[kk]]
[10:25:55.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.212]                     next
[10:25:55.212]                   args[[name]] <- ""
[10:25:55.212]                 }
[10:25:55.212]                 NAMES <- toupper(removed)
[10:25:55.212]                 for (kk in seq_along(NAMES)) {
[10:25:55.212]                   name <- removed[[kk]]
[10:25:55.212]                   NAME <- NAMES[[kk]]
[10:25:55.212]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.212]                     next
[10:25:55.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.212]                 }
[10:25:55.212]                 if (length(args) > 0) 
[10:25:55.212]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.212]             }
[10:25:55.212]             else {
[10:25:55.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.212]             }
[10:25:55.212]             {
[10:25:55.212]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.212]                   0L) {
[10:25:55.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.212]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.212]                   base::options(opts)
[10:25:55.212]                 }
[10:25:55.212]                 {
[10:25:55.212]                   {
[10:25:55.212]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.212]                     NULL
[10:25:55.212]                   }
[10:25:55.212]                   options(future.plan = NULL)
[10:25:55.212]                   if (is.na(NA_character_)) 
[10:25:55.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.212]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.212]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.212]                     envir = parent.frame()) 
[10:25:55.212]                   {
[10:25:55.212]                     if (is.function(workers)) 
[10:25:55.212]                       workers <- workers()
[10:25:55.212]                     workers <- structure(as.integer(workers), 
[10:25:55.212]                       class = class(workers))
[10:25:55.212]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.212]                       workers >= 1)
[10:25:55.212]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.212]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.212]                     }
[10:25:55.212]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.212]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.212]                       envir = envir)
[10:25:55.212]                     if (!future$lazy) 
[10:25:55.212]                       future <- run(future)
[10:25:55.212]                     invisible(future)
[10:25:55.212]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.212]                 }
[10:25:55.212]             }
[10:25:55.212]         }
[10:25:55.212]     })
[10:25:55.212]     if (TRUE) {
[10:25:55.212]         base::sink(type = "output", split = FALSE)
[10:25:55.212]         if (TRUE) {
[10:25:55.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.212]         }
[10:25:55.212]         else {
[10:25:55.212]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.212]         }
[10:25:55.212]         base::close(...future.stdout)
[10:25:55.212]         ...future.stdout <- NULL
[10:25:55.212]     }
[10:25:55.212]     ...future.result$conditions <- ...future.conditions
[10:25:55.212]     ...future.result$finished <- base::Sys.time()
[10:25:55.212]     ...future.result
[10:25:55.212] }
[10:25:55.215] Exporting 2 global objects (896 bytes) to cluster node #1 ...
[10:25:55.215] Exporting ‘weight’ (208 bytes) to cluster node #1 ...
[10:25:55.215] Exporting ‘weight’ (208 bytes) to cluster node #1 ... DONE
[10:25:55.216] Exporting ‘group’ (688 bytes) to cluster node #1 ...
[10:25:55.216] Exporting ‘group’ (688 bytes) to cluster node #1 ... DONE
[10:25:55.216] Exporting 2 global objects (896 bytes) to cluster node #1 ... DONE
[10:25:55.217] MultisessionFuture started
[10:25:55.217] - Launch lazy future ... done
[10:25:55.217] run() for ‘MultisessionFuture’ ... done
[10:25:55.217] result() for ClusterFuture ...
[10:25:55.217] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.217] - Validating connection of MultisessionFuture
[10:25:55.263] - received message: FutureResult
[10:25:55.263] - Received FutureResult
[10:25:55.263] - Erased future from FutureRegistry
[10:25:55.263] result() for ClusterFuture ...
[10:25:55.263] - result already collected: FutureResult
[10:25:55.263] result() for ClusterFuture ... done
[10:25:55.264] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.264] result() for ClusterFuture ... done
[10:25:55.264] result() for ClusterFuture ...
[10:25:55.264] - result already collected: FutureResult
[10:25:55.264] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:25:55.266] getGlobalsAndPackages() ...
[10:25:55.266] Searching for globals...
[10:25:55.267] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:55.267] Searching for globals ... DONE
[10:25:55.267] Resolving globals: FALSE
[10:25:55.267] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:55.268] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:55.268] - globals: [1] ‘x’
[10:25:55.268] - packages: [1] ‘stats’
[10:25:55.268] getGlobalsAndPackages() ... DONE
[10:25:55.268] run() for ‘Future’ ...
[10:25:55.268] - state: ‘created’
[10:25:55.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.282]   - Field: ‘node’
[10:25:55.283]   - Field: ‘label’
[10:25:55.283]   - Field: ‘local’
[10:25:55.283]   - Field: ‘owner’
[10:25:55.283]   - Field: ‘envir’
[10:25:55.283]   - Field: ‘workers’
[10:25:55.283]   - Field: ‘packages’
[10:25:55.283]   - Field: ‘gc’
[10:25:55.283]   - Field: ‘conditions’
[10:25:55.283]   - Field: ‘persistent’
[10:25:55.283]   - Field: ‘expr’
[10:25:55.283]   - Field: ‘uuid’
[10:25:55.284]   - Field: ‘seed’
[10:25:55.284]   - Field: ‘version’
[10:25:55.284]   - Field: ‘result’
[10:25:55.284]   - Field: ‘asynchronous’
[10:25:55.284]   - Field: ‘calls’
[10:25:55.284]   - Field: ‘globals’
[10:25:55.284]   - Field: ‘stdout’
[10:25:55.284]   - Field: ‘earlySignal’
[10:25:55.284]   - Field: ‘lazy’
[10:25:55.284]   - Field: ‘state’
[10:25:55.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.285] - Launch lazy future ...
[10:25:55.285] Packages needed by the future expression (n = 1): ‘stats’
[10:25:55.285] Packages needed by future strategies (n = 0): <none>
[10:25:55.285] {
[10:25:55.285]     {
[10:25:55.285]         {
[10:25:55.285]             ...future.startTime <- base::Sys.time()
[10:25:55.285]             {
[10:25:55.285]                 {
[10:25:55.285]                   {
[10:25:55.285]                     {
[10:25:55.285]                       {
[10:25:55.285]                         base::local({
[10:25:55.285]                           has_future <- base::requireNamespace("future", 
[10:25:55.285]                             quietly = TRUE)
[10:25:55.285]                           if (has_future) {
[10:25:55.285]                             ns <- base::getNamespace("future")
[10:25:55.285]                             version <- ns[[".package"]][["version"]]
[10:25:55.285]                             if (is.null(version)) 
[10:25:55.285]                               version <- utils::packageVersion("future")
[10:25:55.285]                           }
[10:25:55.285]                           else {
[10:25:55.285]                             version <- NULL
[10:25:55.285]                           }
[10:25:55.285]                           if (!has_future || version < "1.8.0") {
[10:25:55.285]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.285]                               "", base::R.version$version.string), 
[10:25:55.285]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.285]                                 base::R.version$platform, 8 * 
[10:25:55.285]                                   base::.Machine$sizeof.pointer), 
[10:25:55.285]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.285]                                 "release", "version")], collapse = " "), 
[10:25:55.285]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.285]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.285]                               info)
[10:25:55.285]                             info <- base::paste(info, collapse = "; ")
[10:25:55.285]                             if (!has_future) {
[10:25:55.285]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.285]                                 info)
[10:25:55.285]                             }
[10:25:55.285]                             else {
[10:25:55.285]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.285]                                 info, version)
[10:25:55.285]                             }
[10:25:55.285]                             base::stop(msg)
[10:25:55.285]                           }
[10:25:55.285]                         })
[10:25:55.285]                       }
[10:25:55.285]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.285]                       base::options(mc.cores = 1L)
[10:25:55.285]                     }
[10:25:55.285]                     base::local({
[10:25:55.285]                       for (pkg in "stats") {
[10:25:55.285]                         base::loadNamespace(pkg)
[10:25:55.285]                         base::library(pkg, character.only = TRUE)
[10:25:55.285]                       }
[10:25:55.285]                     })
[10:25:55.285]                   }
[10:25:55.285]                   options(future.plan = NULL)
[10:25:55.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.285]                 }
[10:25:55.285]                 ...future.workdir <- getwd()
[10:25:55.285]             }
[10:25:55.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.285]         }
[10:25:55.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.285]             base::names(...future.oldOptions))
[10:25:55.285]     }
[10:25:55.285]     if (FALSE) {
[10:25:55.285]     }
[10:25:55.285]     else {
[10:25:55.285]         if (TRUE) {
[10:25:55.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.285]                 open = "w")
[10:25:55.285]         }
[10:25:55.285]         else {
[10:25:55.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.285]         }
[10:25:55.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.285]             base::sink(type = "output", split = FALSE)
[10:25:55.285]             base::close(...future.stdout)
[10:25:55.285]         }, add = TRUE)
[10:25:55.285]     }
[10:25:55.285]     ...future.frame <- base::sys.nframe()
[10:25:55.285]     ...future.conditions <- base::list()
[10:25:55.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.285]     if (FALSE) {
[10:25:55.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.285]     }
[10:25:55.285]     ...future.result <- base::tryCatch({
[10:25:55.285]         base::withCallingHandlers({
[10:25:55.285]             ...future.value <- base::withVisible(base::local({
[10:25:55.285]                 ...future.makeSendCondition <- base::local({
[10:25:55.285]                   sendCondition <- NULL
[10:25:55.285]                   function(frame = 1L) {
[10:25:55.285]                     if (is.function(sendCondition)) 
[10:25:55.285]                       return(sendCondition)
[10:25:55.285]                     ns <- getNamespace("parallel")
[10:25:55.285]                     if (exists("sendData", mode = "function", 
[10:25:55.285]                       envir = ns)) {
[10:25:55.285]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.285]                         envir = ns)
[10:25:55.285]                       envir <- sys.frame(frame)
[10:25:55.285]                       master <- NULL
[10:25:55.285]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.285]                         !identical(envir, emptyenv())) {
[10:25:55.285]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.285]                           inherits = FALSE)) {
[10:25:55.285]                           master <- get("master", mode = "list", 
[10:25:55.285]                             envir = envir, inherits = FALSE)
[10:25:55.285]                           if (inherits(master, c("SOCKnode", 
[10:25:55.285]                             "SOCK0node"))) {
[10:25:55.285]                             sendCondition <<- function(cond) {
[10:25:55.285]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.285]                                 success = TRUE)
[10:25:55.285]                               parallel_sendData(master, data)
[10:25:55.285]                             }
[10:25:55.285]                             return(sendCondition)
[10:25:55.285]                           }
[10:25:55.285]                         }
[10:25:55.285]                         frame <- frame + 1L
[10:25:55.285]                         envir <- sys.frame(frame)
[10:25:55.285]                       }
[10:25:55.285]                     }
[10:25:55.285]                     sendCondition <<- function(cond) NULL
[10:25:55.285]                   }
[10:25:55.285]                 })
[10:25:55.285]                 withCallingHandlers({
[10:25:55.285]                   {
[10:25:55.285]                     xtabs(~x)
[10:25:55.285]                   }
[10:25:55.285]                 }, immediateCondition = function(cond) {
[10:25:55.285]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.285]                   sendCondition(cond)
[10:25:55.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.285]                   {
[10:25:55.285]                     inherits <- base::inherits
[10:25:55.285]                     invokeRestart <- base::invokeRestart
[10:25:55.285]                     is.null <- base::is.null
[10:25:55.285]                     muffled <- FALSE
[10:25:55.285]                     if (inherits(cond, "message")) {
[10:25:55.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.285]                       if (muffled) 
[10:25:55.285]                         invokeRestart("muffleMessage")
[10:25:55.285]                     }
[10:25:55.285]                     else if (inherits(cond, "warning")) {
[10:25:55.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.285]                       if (muffled) 
[10:25:55.285]                         invokeRestart("muffleWarning")
[10:25:55.285]                     }
[10:25:55.285]                     else if (inherits(cond, "condition")) {
[10:25:55.285]                       if (!is.null(pattern)) {
[10:25:55.285]                         computeRestarts <- base::computeRestarts
[10:25:55.285]                         grepl <- base::grepl
[10:25:55.285]                         restarts <- computeRestarts(cond)
[10:25:55.285]                         for (restart in restarts) {
[10:25:55.285]                           name <- restart$name
[10:25:55.285]                           if (is.null(name)) 
[10:25:55.285]                             next
[10:25:55.285]                           if (!grepl(pattern, name)) 
[10:25:55.285]                             next
[10:25:55.285]                           invokeRestart(restart)
[10:25:55.285]                           muffled <- TRUE
[10:25:55.285]                           break
[10:25:55.285]                         }
[10:25:55.285]                       }
[10:25:55.285]                     }
[10:25:55.285]                     invisible(muffled)
[10:25:55.285]                   }
[10:25:55.285]                   muffleCondition(cond)
[10:25:55.285]                 })
[10:25:55.285]             }))
[10:25:55.285]             future::FutureResult(value = ...future.value$value, 
[10:25:55.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.285]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.285]                     ...future.globalenv.names))
[10:25:55.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.285]         }, condition = base::local({
[10:25:55.285]             c <- base::c
[10:25:55.285]             inherits <- base::inherits
[10:25:55.285]             invokeRestart <- base::invokeRestart
[10:25:55.285]             length <- base::length
[10:25:55.285]             list <- base::list
[10:25:55.285]             seq.int <- base::seq.int
[10:25:55.285]             signalCondition <- base::signalCondition
[10:25:55.285]             sys.calls <- base::sys.calls
[10:25:55.285]             `[[` <- base::`[[`
[10:25:55.285]             `+` <- base::`+`
[10:25:55.285]             `<<-` <- base::`<<-`
[10:25:55.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.285]                   3L)]
[10:25:55.285]             }
[10:25:55.285]             function(cond) {
[10:25:55.285]                 is_error <- inherits(cond, "error")
[10:25:55.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.285]                   NULL)
[10:25:55.285]                 if (is_error) {
[10:25:55.285]                   sessionInformation <- function() {
[10:25:55.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.285]                       search = base::search(), system = base::Sys.info())
[10:25:55.285]                   }
[10:25:55.285]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.285]                     cond$call), session = sessionInformation(), 
[10:25:55.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.285]                   signalCondition(cond)
[10:25:55.285]                 }
[10:25:55.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.285]                 "immediateCondition"))) {
[10:25:55.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.285]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.285]                   if (TRUE && !signal) {
[10:25:55.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.285]                     {
[10:25:55.285]                       inherits <- base::inherits
[10:25:55.285]                       invokeRestart <- base::invokeRestart
[10:25:55.285]                       is.null <- base::is.null
[10:25:55.285]                       muffled <- FALSE
[10:25:55.285]                       if (inherits(cond, "message")) {
[10:25:55.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.285]                         if (muffled) 
[10:25:55.285]                           invokeRestart("muffleMessage")
[10:25:55.285]                       }
[10:25:55.285]                       else if (inherits(cond, "warning")) {
[10:25:55.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.285]                         if (muffled) 
[10:25:55.285]                           invokeRestart("muffleWarning")
[10:25:55.285]                       }
[10:25:55.285]                       else if (inherits(cond, "condition")) {
[10:25:55.285]                         if (!is.null(pattern)) {
[10:25:55.285]                           computeRestarts <- base::computeRestarts
[10:25:55.285]                           grepl <- base::grepl
[10:25:55.285]                           restarts <- computeRestarts(cond)
[10:25:55.285]                           for (restart in restarts) {
[10:25:55.285]                             name <- restart$name
[10:25:55.285]                             if (is.null(name)) 
[10:25:55.285]                               next
[10:25:55.285]                             if (!grepl(pattern, name)) 
[10:25:55.285]                               next
[10:25:55.285]                             invokeRestart(restart)
[10:25:55.285]                             muffled <- TRUE
[10:25:55.285]                             break
[10:25:55.285]                           }
[10:25:55.285]                         }
[10:25:55.285]                       }
[10:25:55.285]                       invisible(muffled)
[10:25:55.285]                     }
[10:25:55.285]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.285]                   }
[10:25:55.285]                 }
[10:25:55.285]                 else {
[10:25:55.285]                   if (TRUE) {
[10:25:55.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.285]                     {
[10:25:55.285]                       inherits <- base::inherits
[10:25:55.285]                       invokeRestart <- base::invokeRestart
[10:25:55.285]                       is.null <- base::is.null
[10:25:55.285]                       muffled <- FALSE
[10:25:55.285]                       if (inherits(cond, "message")) {
[10:25:55.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.285]                         if (muffled) 
[10:25:55.285]                           invokeRestart("muffleMessage")
[10:25:55.285]                       }
[10:25:55.285]                       else if (inherits(cond, "warning")) {
[10:25:55.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.285]                         if (muffled) 
[10:25:55.285]                           invokeRestart("muffleWarning")
[10:25:55.285]                       }
[10:25:55.285]                       else if (inherits(cond, "condition")) {
[10:25:55.285]                         if (!is.null(pattern)) {
[10:25:55.285]                           computeRestarts <- base::computeRestarts
[10:25:55.285]                           grepl <- base::grepl
[10:25:55.285]                           restarts <- computeRestarts(cond)
[10:25:55.285]                           for (restart in restarts) {
[10:25:55.285]                             name <- restart$name
[10:25:55.285]                             if (is.null(name)) 
[10:25:55.285]                               next
[10:25:55.285]                             if (!grepl(pattern, name)) 
[10:25:55.285]                               next
[10:25:55.285]                             invokeRestart(restart)
[10:25:55.285]                             muffled <- TRUE
[10:25:55.285]                             break
[10:25:55.285]                           }
[10:25:55.285]                         }
[10:25:55.285]                       }
[10:25:55.285]                       invisible(muffled)
[10:25:55.285]                     }
[10:25:55.285]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.285]                   }
[10:25:55.285]                 }
[10:25:55.285]             }
[10:25:55.285]         }))
[10:25:55.285]     }, error = function(ex) {
[10:25:55.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.285]                 ...future.rng), started = ...future.startTime, 
[10:25:55.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.285]             version = "1.8"), class = "FutureResult")
[10:25:55.285]     }, finally = {
[10:25:55.285]         if (!identical(...future.workdir, getwd())) 
[10:25:55.285]             setwd(...future.workdir)
[10:25:55.285]         {
[10:25:55.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.285]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.285]             }
[10:25:55.285]             base::options(...future.oldOptions)
[10:25:55.285]             if (.Platform$OS.type == "windows") {
[10:25:55.285]                 old_names <- names(...future.oldEnvVars)
[10:25:55.285]                 envs <- base::Sys.getenv()
[10:25:55.285]                 names <- names(envs)
[10:25:55.285]                 common <- intersect(names, old_names)
[10:25:55.285]                 added <- setdiff(names, old_names)
[10:25:55.285]                 removed <- setdiff(old_names, names)
[10:25:55.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.285]                   envs[common]]
[10:25:55.285]                 NAMES <- toupper(changed)
[10:25:55.285]                 args <- list()
[10:25:55.285]                 for (kk in seq_along(NAMES)) {
[10:25:55.285]                   name <- changed[[kk]]
[10:25:55.285]                   NAME <- NAMES[[kk]]
[10:25:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.285]                     next
[10:25:55.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.285]                 }
[10:25:55.285]                 NAMES <- toupper(added)
[10:25:55.285]                 for (kk in seq_along(NAMES)) {
[10:25:55.285]                   name <- added[[kk]]
[10:25:55.285]                   NAME <- NAMES[[kk]]
[10:25:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.285]                     next
[10:25:55.285]                   args[[name]] <- ""
[10:25:55.285]                 }
[10:25:55.285]                 NAMES <- toupper(removed)
[10:25:55.285]                 for (kk in seq_along(NAMES)) {
[10:25:55.285]                   name <- removed[[kk]]
[10:25:55.285]                   NAME <- NAMES[[kk]]
[10:25:55.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.285]                     next
[10:25:55.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.285]                 }
[10:25:55.285]                 if (length(args) > 0) 
[10:25:55.285]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.285]             }
[10:25:55.285]             else {
[10:25:55.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.285]             }
[10:25:55.285]             {
[10:25:55.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.285]                   0L) {
[10:25:55.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.285]                   base::options(opts)
[10:25:55.285]                 }
[10:25:55.285]                 {
[10:25:55.285]                   {
[10:25:55.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.285]                     NULL
[10:25:55.285]                   }
[10:25:55.285]                   options(future.plan = NULL)
[10:25:55.285]                   if (is.na(NA_character_)) 
[10:25:55.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.285]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.285]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.285]                     envir = parent.frame()) 
[10:25:55.285]                   {
[10:25:55.285]                     if (is.function(workers)) 
[10:25:55.285]                       workers <- workers()
[10:25:55.285]                     workers <- structure(as.integer(workers), 
[10:25:55.285]                       class = class(workers))
[10:25:55.285]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.285]                       workers >= 1)
[10:25:55.285]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.285]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.285]                     }
[10:25:55.285]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.285]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.285]                       envir = envir)
[10:25:55.285]                     if (!future$lazy) 
[10:25:55.285]                       future <- run(future)
[10:25:55.285]                     invisible(future)
[10:25:55.285]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.285]                 }
[10:25:55.285]             }
[10:25:55.285]         }
[10:25:55.285]     })
[10:25:55.285]     if (TRUE) {
[10:25:55.285]         base::sink(type = "output", split = FALSE)
[10:25:55.285]         if (TRUE) {
[10:25:55.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.285]         }
[10:25:55.285]         else {
[10:25:55.285]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.285]         }
[10:25:55.285]         base::close(...future.stdout)
[10:25:55.285]         ...future.stdout <- NULL
[10:25:55.285]     }
[10:25:55.285]     ...future.result$conditions <- ...future.conditions
[10:25:55.285]     ...future.result$finished <- base::Sys.time()
[10:25:55.285]     ...future.result
[10:25:55.285] }
[10:25:55.288] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[10:25:55.288] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[10:25:55.289] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[10:25:55.289] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[10:25:55.289] MultisessionFuture started
[10:25:55.289] - Launch lazy future ... done
[10:25:55.290] run() for ‘MultisessionFuture’ ... done
[10:25:55.290] result() for ClusterFuture ...
[10:25:55.290] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.290] - Validating connection of MultisessionFuture
[10:25:55.335] - received message: FutureResult
[10:25:55.335] - Received FutureResult
[10:25:55.335] - Erased future from FutureRegistry
[10:25:55.336] result() for ClusterFuture ...
[10:25:55.336] - result already collected: FutureResult
[10:25:55.336] result() for ClusterFuture ... done
[10:25:55.336] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.336] result() for ClusterFuture ... done
[10:25:55.336] result() for ClusterFuture ...
[10:25:55.336] - result already collected: FutureResult
[10:25:55.336] result() for ClusterFuture ... done
x
1 2 
2 3 
[10:25:55.337] getGlobalsAndPackages() ...
[10:25:55.337] Searching for globals...
[10:25:55.338] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:25:55.338] Searching for globals ... DONE
[10:25:55.338] Resolving globals: FALSE
[10:25:55.339] The total size of the 1 globals is 96 bytes (96 bytes)
[10:25:55.339] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 96 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (96 bytes of class ‘numeric’)
[10:25:55.339] - globals: [1] ‘x’
[10:25:55.339] - packages: [1] ‘stats’
[10:25:55.339] getGlobalsAndPackages() ... DONE
[10:25:55.340] run() for ‘Future’ ...
[10:25:55.340] - state: ‘created’
[10:25:55.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.354]   - Field: ‘node’
[10:25:55.354]   - Field: ‘label’
[10:25:55.354]   - Field: ‘local’
[10:25:55.354]   - Field: ‘owner’
[10:25:55.354]   - Field: ‘envir’
[10:25:55.354]   - Field: ‘workers’
[10:25:55.354]   - Field: ‘packages’
[10:25:55.354]   - Field: ‘gc’
[10:25:55.354]   - Field: ‘conditions’
[10:25:55.355]   - Field: ‘persistent’
[10:25:55.355]   - Field: ‘expr’
[10:25:55.355]   - Field: ‘uuid’
[10:25:55.355]   - Field: ‘seed’
[10:25:55.355]   - Field: ‘version’
[10:25:55.355]   - Field: ‘result’
[10:25:55.355]   - Field: ‘asynchronous’
[10:25:55.355]   - Field: ‘calls’
[10:25:55.355]   - Field: ‘globals’
[10:25:55.355]   - Field: ‘stdout’
[10:25:55.355]   - Field: ‘earlySignal’
[10:25:55.355]   - Field: ‘lazy’
[10:25:55.356]   - Field: ‘state’
[10:25:55.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.356] - Launch lazy future ...
[10:25:55.356] Packages needed by the future expression (n = 1): ‘stats’
[10:25:55.356] Packages needed by future strategies (n = 0): <none>
[10:25:55.357] {
[10:25:55.357]     {
[10:25:55.357]         {
[10:25:55.357]             ...future.startTime <- base::Sys.time()
[10:25:55.357]             {
[10:25:55.357]                 {
[10:25:55.357]                   {
[10:25:55.357]                     {
[10:25:55.357]                       {
[10:25:55.357]                         base::local({
[10:25:55.357]                           has_future <- base::requireNamespace("future", 
[10:25:55.357]                             quietly = TRUE)
[10:25:55.357]                           if (has_future) {
[10:25:55.357]                             ns <- base::getNamespace("future")
[10:25:55.357]                             version <- ns[[".package"]][["version"]]
[10:25:55.357]                             if (is.null(version)) 
[10:25:55.357]                               version <- utils::packageVersion("future")
[10:25:55.357]                           }
[10:25:55.357]                           else {
[10:25:55.357]                             version <- NULL
[10:25:55.357]                           }
[10:25:55.357]                           if (!has_future || version < "1.8.0") {
[10:25:55.357]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.357]                               "", base::R.version$version.string), 
[10:25:55.357]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.357]                                 base::R.version$platform, 8 * 
[10:25:55.357]                                   base::.Machine$sizeof.pointer), 
[10:25:55.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.357]                                 "release", "version")], collapse = " "), 
[10:25:55.357]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.357]                               info)
[10:25:55.357]                             info <- base::paste(info, collapse = "; ")
[10:25:55.357]                             if (!has_future) {
[10:25:55.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.357]                                 info)
[10:25:55.357]                             }
[10:25:55.357]                             else {
[10:25:55.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.357]                                 info, version)
[10:25:55.357]                             }
[10:25:55.357]                             base::stop(msg)
[10:25:55.357]                           }
[10:25:55.357]                         })
[10:25:55.357]                       }
[10:25:55.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.357]                       base::options(mc.cores = 1L)
[10:25:55.357]                     }
[10:25:55.357]                     base::local({
[10:25:55.357]                       for (pkg in "stats") {
[10:25:55.357]                         base::loadNamespace(pkg)
[10:25:55.357]                         base::library(pkg, character.only = TRUE)
[10:25:55.357]                       }
[10:25:55.357]                     })
[10:25:55.357]                   }
[10:25:55.357]                   options(future.plan = NULL)
[10:25:55.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.357]                 }
[10:25:55.357]                 ...future.workdir <- getwd()
[10:25:55.357]             }
[10:25:55.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.357]         }
[10:25:55.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.357]             base::names(...future.oldOptions))
[10:25:55.357]     }
[10:25:55.357]     if (FALSE) {
[10:25:55.357]     }
[10:25:55.357]     else {
[10:25:55.357]         if (TRUE) {
[10:25:55.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.357]                 open = "w")
[10:25:55.357]         }
[10:25:55.357]         else {
[10:25:55.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.357]         }
[10:25:55.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.357]             base::sink(type = "output", split = FALSE)
[10:25:55.357]             base::close(...future.stdout)
[10:25:55.357]         }, add = TRUE)
[10:25:55.357]     }
[10:25:55.357]     ...future.frame <- base::sys.nframe()
[10:25:55.357]     ...future.conditions <- base::list()
[10:25:55.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.357]     if (FALSE) {
[10:25:55.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.357]     }
[10:25:55.357]     ...future.result <- base::tryCatch({
[10:25:55.357]         base::withCallingHandlers({
[10:25:55.357]             ...future.value <- base::withVisible(base::local({
[10:25:55.357]                 ...future.makeSendCondition <- base::local({
[10:25:55.357]                   sendCondition <- NULL
[10:25:55.357]                   function(frame = 1L) {
[10:25:55.357]                     if (is.function(sendCondition)) 
[10:25:55.357]                       return(sendCondition)
[10:25:55.357]                     ns <- getNamespace("parallel")
[10:25:55.357]                     if (exists("sendData", mode = "function", 
[10:25:55.357]                       envir = ns)) {
[10:25:55.357]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.357]                         envir = ns)
[10:25:55.357]                       envir <- sys.frame(frame)
[10:25:55.357]                       master <- NULL
[10:25:55.357]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.357]                         !identical(envir, emptyenv())) {
[10:25:55.357]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.357]                           inherits = FALSE)) {
[10:25:55.357]                           master <- get("master", mode = "list", 
[10:25:55.357]                             envir = envir, inherits = FALSE)
[10:25:55.357]                           if (inherits(master, c("SOCKnode", 
[10:25:55.357]                             "SOCK0node"))) {
[10:25:55.357]                             sendCondition <<- function(cond) {
[10:25:55.357]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.357]                                 success = TRUE)
[10:25:55.357]                               parallel_sendData(master, data)
[10:25:55.357]                             }
[10:25:55.357]                             return(sendCondition)
[10:25:55.357]                           }
[10:25:55.357]                         }
[10:25:55.357]                         frame <- frame + 1L
[10:25:55.357]                         envir <- sys.frame(frame)
[10:25:55.357]                       }
[10:25:55.357]                     }
[10:25:55.357]                     sendCondition <<- function(cond) NULL
[10:25:55.357]                   }
[10:25:55.357]                 })
[10:25:55.357]                 withCallingHandlers({
[10:25:55.357]                   {
[10:25:55.357]                     xtabs(~x)
[10:25:55.357]                   }
[10:25:55.357]                 }, immediateCondition = function(cond) {
[10:25:55.357]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.357]                   sendCondition(cond)
[10:25:55.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.357]                   {
[10:25:55.357]                     inherits <- base::inherits
[10:25:55.357]                     invokeRestart <- base::invokeRestart
[10:25:55.357]                     is.null <- base::is.null
[10:25:55.357]                     muffled <- FALSE
[10:25:55.357]                     if (inherits(cond, "message")) {
[10:25:55.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.357]                       if (muffled) 
[10:25:55.357]                         invokeRestart("muffleMessage")
[10:25:55.357]                     }
[10:25:55.357]                     else if (inherits(cond, "warning")) {
[10:25:55.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.357]                       if (muffled) 
[10:25:55.357]                         invokeRestart("muffleWarning")
[10:25:55.357]                     }
[10:25:55.357]                     else if (inherits(cond, "condition")) {
[10:25:55.357]                       if (!is.null(pattern)) {
[10:25:55.357]                         computeRestarts <- base::computeRestarts
[10:25:55.357]                         grepl <- base::grepl
[10:25:55.357]                         restarts <- computeRestarts(cond)
[10:25:55.357]                         for (restart in restarts) {
[10:25:55.357]                           name <- restart$name
[10:25:55.357]                           if (is.null(name)) 
[10:25:55.357]                             next
[10:25:55.357]                           if (!grepl(pattern, name)) 
[10:25:55.357]                             next
[10:25:55.357]                           invokeRestart(restart)
[10:25:55.357]                           muffled <- TRUE
[10:25:55.357]                           break
[10:25:55.357]                         }
[10:25:55.357]                       }
[10:25:55.357]                     }
[10:25:55.357]                     invisible(muffled)
[10:25:55.357]                   }
[10:25:55.357]                   muffleCondition(cond)
[10:25:55.357]                 })
[10:25:55.357]             }))
[10:25:55.357]             future::FutureResult(value = ...future.value$value, 
[10:25:55.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.357]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.357]                     ...future.globalenv.names))
[10:25:55.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.357]         }, condition = base::local({
[10:25:55.357]             c <- base::c
[10:25:55.357]             inherits <- base::inherits
[10:25:55.357]             invokeRestart <- base::invokeRestart
[10:25:55.357]             length <- base::length
[10:25:55.357]             list <- base::list
[10:25:55.357]             seq.int <- base::seq.int
[10:25:55.357]             signalCondition <- base::signalCondition
[10:25:55.357]             sys.calls <- base::sys.calls
[10:25:55.357]             `[[` <- base::`[[`
[10:25:55.357]             `+` <- base::`+`
[10:25:55.357]             `<<-` <- base::`<<-`
[10:25:55.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.357]                   3L)]
[10:25:55.357]             }
[10:25:55.357]             function(cond) {
[10:25:55.357]                 is_error <- inherits(cond, "error")
[10:25:55.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.357]                   NULL)
[10:25:55.357]                 if (is_error) {
[10:25:55.357]                   sessionInformation <- function() {
[10:25:55.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.357]                       search = base::search(), system = base::Sys.info())
[10:25:55.357]                   }
[10:25:55.357]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.357]                     cond$call), session = sessionInformation(), 
[10:25:55.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.357]                   signalCondition(cond)
[10:25:55.357]                 }
[10:25:55.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.357]                 "immediateCondition"))) {
[10:25:55.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.357]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.357]                   if (TRUE && !signal) {
[10:25:55.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.357]                     {
[10:25:55.357]                       inherits <- base::inherits
[10:25:55.357]                       invokeRestart <- base::invokeRestart
[10:25:55.357]                       is.null <- base::is.null
[10:25:55.357]                       muffled <- FALSE
[10:25:55.357]                       if (inherits(cond, "message")) {
[10:25:55.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.357]                         if (muffled) 
[10:25:55.357]                           invokeRestart("muffleMessage")
[10:25:55.357]                       }
[10:25:55.357]                       else if (inherits(cond, "warning")) {
[10:25:55.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.357]                         if (muffled) 
[10:25:55.357]                           invokeRestart("muffleWarning")
[10:25:55.357]                       }
[10:25:55.357]                       else if (inherits(cond, "condition")) {
[10:25:55.357]                         if (!is.null(pattern)) {
[10:25:55.357]                           computeRestarts <- base::computeRestarts
[10:25:55.357]                           grepl <- base::grepl
[10:25:55.357]                           restarts <- computeRestarts(cond)
[10:25:55.357]                           for (restart in restarts) {
[10:25:55.357]                             name <- restart$name
[10:25:55.357]                             if (is.null(name)) 
[10:25:55.357]                               next
[10:25:55.357]                             if (!grepl(pattern, name)) 
[10:25:55.357]                               next
[10:25:55.357]                             invokeRestart(restart)
[10:25:55.357]                             muffled <- TRUE
[10:25:55.357]                             break
[10:25:55.357]                           }
[10:25:55.357]                         }
[10:25:55.357]                       }
[10:25:55.357]                       invisible(muffled)
[10:25:55.357]                     }
[10:25:55.357]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.357]                   }
[10:25:55.357]                 }
[10:25:55.357]                 else {
[10:25:55.357]                   if (TRUE) {
[10:25:55.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.357]                     {
[10:25:55.357]                       inherits <- base::inherits
[10:25:55.357]                       invokeRestart <- base::invokeRestart
[10:25:55.357]                       is.null <- base::is.null
[10:25:55.357]                       muffled <- FALSE
[10:25:55.357]                       if (inherits(cond, "message")) {
[10:25:55.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.357]                         if (muffled) 
[10:25:55.357]                           invokeRestart("muffleMessage")
[10:25:55.357]                       }
[10:25:55.357]                       else if (inherits(cond, "warning")) {
[10:25:55.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.357]                         if (muffled) 
[10:25:55.357]                           invokeRestart("muffleWarning")
[10:25:55.357]                       }
[10:25:55.357]                       else if (inherits(cond, "condition")) {
[10:25:55.357]                         if (!is.null(pattern)) {
[10:25:55.357]                           computeRestarts <- base::computeRestarts
[10:25:55.357]                           grepl <- base::grepl
[10:25:55.357]                           restarts <- computeRestarts(cond)
[10:25:55.357]                           for (restart in restarts) {
[10:25:55.357]                             name <- restart$name
[10:25:55.357]                             if (is.null(name)) 
[10:25:55.357]                               next
[10:25:55.357]                             if (!grepl(pattern, name)) 
[10:25:55.357]                               next
[10:25:55.357]                             invokeRestart(restart)
[10:25:55.357]                             muffled <- TRUE
[10:25:55.357]                             break
[10:25:55.357]                           }
[10:25:55.357]                         }
[10:25:55.357]                       }
[10:25:55.357]                       invisible(muffled)
[10:25:55.357]                     }
[10:25:55.357]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.357]                   }
[10:25:55.357]                 }
[10:25:55.357]             }
[10:25:55.357]         }))
[10:25:55.357]     }, error = function(ex) {
[10:25:55.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.357]                 ...future.rng), started = ...future.startTime, 
[10:25:55.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.357]             version = "1.8"), class = "FutureResult")
[10:25:55.357]     }, finally = {
[10:25:55.357]         if (!identical(...future.workdir, getwd())) 
[10:25:55.357]             setwd(...future.workdir)
[10:25:55.357]         {
[10:25:55.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.357]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.357]             }
[10:25:55.357]             base::options(...future.oldOptions)
[10:25:55.357]             if (.Platform$OS.type == "windows") {
[10:25:55.357]                 old_names <- names(...future.oldEnvVars)
[10:25:55.357]                 envs <- base::Sys.getenv()
[10:25:55.357]                 names <- names(envs)
[10:25:55.357]                 common <- intersect(names, old_names)
[10:25:55.357]                 added <- setdiff(names, old_names)
[10:25:55.357]                 removed <- setdiff(old_names, names)
[10:25:55.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.357]                   envs[common]]
[10:25:55.357]                 NAMES <- toupper(changed)
[10:25:55.357]                 args <- list()
[10:25:55.357]                 for (kk in seq_along(NAMES)) {
[10:25:55.357]                   name <- changed[[kk]]
[10:25:55.357]                   NAME <- NAMES[[kk]]
[10:25:55.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.357]                     next
[10:25:55.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.357]                 }
[10:25:55.357]                 NAMES <- toupper(added)
[10:25:55.357]                 for (kk in seq_along(NAMES)) {
[10:25:55.357]                   name <- added[[kk]]
[10:25:55.357]                   NAME <- NAMES[[kk]]
[10:25:55.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.357]                     next
[10:25:55.357]                   args[[name]] <- ""
[10:25:55.357]                 }
[10:25:55.357]                 NAMES <- toupper(removed)
[10:25:55.357]                 for (kk in seq_along(NAMES)) {
[10:25:55.357]                   name <- removed[[kk]]
[10:25:55.357]                   NAME <- NAMES[[kk]]
[10:25:55.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.357]                     next
[10:25:55.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.357]                 }
[10:25:55.357]                 if (length(args) > 0) 
[10:25:55.357]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.357]             }
[10:25:55.357]             else {
[10:25:55.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.357]             }
[10:25:55.357]             {
[10:25:55.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.357]                   0L) {
[10:25:55.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.357]                   base::options(opts)
[10:25:55.357]                 }
[10:25:55.357]                 {
[10:25:55.357]                   {
[10:25:55.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.357]                     NULL
[10:25:55.357]                   }
[10:25:55.357]                   options(future.plan = NULL)
[10:25:55.357]                   if (is.na(NA_character_)) 
[10:25:55.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.357]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.357]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.357]                     envir = parent.frame()) 
[10:25:55.357]                   {
[10:25:55.357]                     if (is.function(workers)) 
[10:25:55.357]                       workers <- workers()
[10:25:55.357]                     workers <- structure(as.integer(workers), 
[10:25:55.357]                       class = class(workers))
[10:25:55.357]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.357]                       workers >= 1)
[10:25:55.357]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.357]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.357]                     }
[10:25:55.357]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.357]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.357]                       envir = envir)
[10:25:55.357]                     if (!future$lazy) 
[10:25:55.357]                       future <- run(future)
[10:25:55.357]                     invisible(future)
[10:25:55.357]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.357]                 }
[10:25:55.357]             }
[10:25:55.357]         }
[10:25:55.357]     })
[10:25:55.357]     if (TRUE) {
[10:25:55.357]         base::sink(type = "output", split = FALSE)
[10:25:55.357]         if (TRUE) {
[10:25:55.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.357]         }
[10:25:55.357]         else {
[10:25:55.357]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.357]         }
[10:25:55.357]         base::close(...future.stdout)
[10:25:55.357]         ...future.stdout <- NULL
[10:25:55.357]     }
[10:25:55.357]     ...future.result$conditions <- ...future.conditions
[10:25:55.357]     ...future.result$finished <- base::Sys.time()
[10:25:55.357]     ...future.result
[10:25:55.357] }
[10:25:55.359] Exporting 1 global objects (96 bytes) to cluster node #1 ...
[10:25:55.359] Exporting ‘x’ (96 bytes) to cluster node #1 ...
[10:25:55.360] Exporting ‘x’ (96 bytes) to cluster node #1 ... DONE
[10:25:55.360] Exporting 1 global objects (96 bytes) to cluster node #1 ... DONE
[10:25:55.360] MultisessionFuture started
[10:25:55.360] - Launch lazy future ... done
[10:25:55.361] run() for ‘MultisessionFuture’ ... done
[10:25:55.361] result() for ClusterFuture ...
[10:25:55.361] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.361] - Validating connection of MultisessionFuture
[10:25:55.406] - received message: FutureResult
[10:25:55.407] - Received FutureResult
[10:25:55.407] - Erased future from FutureRegistry
[10:25:55.407] result() for ClusterFuture ...
[10:25:55.407] - result already collected: FutureResult
[10:25:55.407] result() for ClusterFuture ... done
[10:25:55.407] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.407] result() for ClusterFuture ... done
[10:25:55.407] result() for ClusterFuture ...
[10:25:55.407] - result already collected: FutureResult
[10:25:55.407] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:25:55.409] getGlobalsAndPackages() ...
[10:25:55.409] Searching for globals...
[10:25:55.410] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:25:55.411] Searching for globals ... DONE
[10:25:55.411] Resolving globals: FALSE
[10:25:55.411] 
[10:25:55.411] - packages: [2] ‘stats’, ‘datasets’
[10:25:55.411] getGlobalsAndPackages() ... DONE
[10:25:55.412] run() for ‘Future’ ...
[10:25:55.412] - state: ‘created’
[10:25:55.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.426]   - Field: ‘node’
[10:25:55.426]   - Field: ‘label’
[10:25:55.426]   - Field: ‘local’
[10:25:55.426]   - Field: ‘owner’
[10:25:55.426]   - Field: ‘envir’
[10:25:55.426]   - Field: ‘workers’
[10:25:55.426]   - Field: ‘packages’
[10:25:55.426]   - Field: ‘gc’
[10:25:55.427]   - Field: ‘conditions’
[10:25:55.427]   - Field: ‘persistent’
[10:25:55.427]   - Field: ‘expr’
[10:25:55.427]   - Field: ‘uuid’
[10:25:55.427]   - Field: ‘seed’
[10:25:55.427]   - Field: ‘version’
[10:25:55.427]   - Field: ‘result’
[10:25:55.427]   - Field: ‘asynchronous’
[10:25:55.427]   - Field: ‘calls’
[10:25:55.427]   - Field: ‘globals’
[10:25:55.427]   - Field: ‘stdout’
[10:25:55.427]   - Field: ‘earlySignal’
[10:25:55.428]   - Field: ‘lazy’
[10:25:55.428]   - Field: ‘state’
[10:25:55.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.428] - Launch lazy future ...
[10:25:55.428] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:55.428] Packages needed by future strategies (n = 0): <none>
[10:25:55.429] {
[10:25:55.429]     {
[10:25:55.429]         {
[10:25:55.429]             ...future.startTime <- base::Sys.time()
[10:25:55.429]             {
[10:25:55.429]                 {
[10:25:55.429]                   {
[10:25:55.429]                     {
[10:25:55.429]                       {
[10:25:55.429]                         base::local({
[10:25:55.429]                           has_future <- base::requireNamespace("future", 
[10:25:55.429]                             quietly = TRUE)
[10:25:55.429]                           if (has_future) {
[10:25:55.429]                             ns <- base::getNamespace("future")
[10:25:55.429]                             version <- ns[[".package"]][["version"]]
[10:25:55.429]                             if (is.null(version)) 
[10:25:55.429]                               version <- utils::packageVersion("future")
[10:25:55.429]                           }
[10:25:55.429]                           else {
[10:25:55.429]                             version <- NULL
[10:25:55.429]                           }
[10:25:55.429]                           if (!has_future || version < "1.8.0") {
[10:25:55.429]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.429]                               "", base::R.version$version.string), 
[10:25:55.429]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.429]                                 base::R.version$platform, 8 * 
[10:25:55.429]                                   base::.Machine$sizeof.pointer), 
[10:25:55.429]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.429]                                 "release", "version")], collapse = " "), 
[10:25:55.429]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.429]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.429]                               info)
[10:25:55.429]                             info <- base::paste(info, collapse = "; ")
[10:25:55.429]                             if (!has_future) {
[10:25:55.429]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.429]                                 info)
[10:25:55.429]                             }
[10:25:55.429]                             else {
[10:25:55.429]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.429]                                 info, version)
[10:25:55.429]                             }
[10:25:55.429]                             base::stop(msg)
[10:25:55.429]                           }
[10:25:55.429]                         })
[10:25:55.429]                       }
[10:25:55.429]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.429]                       base::options(mc.cores = 1L)
[10:25:55.429]                     }
[10:25:55.429]                     base::local({
[10:25:55.429]                       for (pkg in c("stats", "datasets")) {
[10:25:55.429]                         base::loadNamespace(pkg)
[10:25:55.429]                         base::library(pkg, character.only = TRUE)
[10:25:55.429]                       }
[10:25:55.429]                     })
[10:25:55.429]                   }
[10:25:55.429]                   options(future.plan = NULL)
[10:25:55.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.429]                 }
[10:25:55.429]                 ...future.workdir <- getwd()
[10:25:55.429]             }
[10:25:55.429]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.429]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.429]         }
[10:25:55.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.429]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.429]             base::names(...future.oldOptions))
[10:25:55.429]     }
[10:25:55.429]     if (FALSE) {
[10:25:55.429]     }
[10:25:55.429]     else {
[10:25:55.429]         if (TRUE) {
[10:25:55.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.429]                 open = "w")
[10:25:55.429]         }
[10:25:55.429]         else {
[10:25:55.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.429]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.429]         }
[10:25:55.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.429]             base::sink(type = "output", split = FALSE)
[10:25:55.429]             base::close(...future.stdout)
[10:25:55.429]         }, add = TRUE)
[10:25:55.429]     }
[10:25:55.429]     ...future.frame <- base::sys.nframe()
[10:25:55.429]     ...future.conditions <- base::list()
[10:25:55.429]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.429]     if (FALSE) {
[10:25:55.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.429]     }
[10:25:55.429]     ...future.result <- base::tryCatch({
[10:25:55.429]         base::withCallingHandlers({
[10:25:55.429]             ...future.value <- base::withVisible(base::local({
[10:25:55.429]                 ...future.makeSendCondition <- base::local({
[10:25:55.429]                   sendCondition <- NULL
[10:25:55.429]                   function(frame = 1L) {
[10:25:55.429]                     if (is.function(sendCondition)) 
[10:25:55.429]                       return(sendCondition)
[10:25:55.429]                     ns <- getNamespace("parallel")
[10:25:55.429]                     if (exists("sendData", mode = "function", 
[10:25:55.429]                       envir = ns)) {
[10:25:55.429]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.429]                         envir = ns)
[10:25:55.429]                       envir <- sys.frame(frame)
[10:25:55.429]                       master <- NULL
[10:25:55.429]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.429]                         !identical(envir, emptyenv())) {
[10:25:55.429]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.429]                           inherits = FALSE)) {
[10:25:55.429]                           master <- get("master", mode = "list", 
[10:25:55.429]                             envir = envir, inherits = FALSE)
[10:25:55.429]                           if (inherits(master, c("SOCKnode", 
[10:25:55.429]                             "SOCK0node"))) {
[10:25:55.429]                             sendCondition <<- function(cond) {
[10:25:55.429]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.429]                                 success = TRUE)
[10:25:55.429]                               parallel_sendData(master, data)
[10:25:55.429]                             }
[10:25:55.429]                             return(sendCondition)
[10:25:55.429]                           }
[10:25:55.429]                         }
[10:25:55.429]                         frame <- frame + 1L
[10:25:55.429]                         envir <- sys.frame(frame)
[10:25:55.429]                       }
[10:25:55.429]                     }
[10:25:55.429]                     sendCondition <<- function(cond) NULL
[10:25:55.429]                   }
[10:25:55.429]                 })
[10:25:55.429]                 withCallingHandlers({
[10:25:55.429]                   {
[10:25:55.429]                     lm(dist ~ . - 1, data = cars)
[10:25:55.429]                   }
[10:25:55.429]                 }, immediateCondition = function(cond) {
[10:25:55.429]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.429]                   sendCondition(cond)
[10:25:55.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.429]                   {
[10:25:55.429]                     inherits <- base::inherits
[10:25:55.429]                     invokeRestart <- base::invokeRestart
[10:25:55.429]                     is.null <- base::is.null
[10:25:55.429]                     muffled <- FALSE
[10:25:55.429]                     if (inherits(cond, "message")) {
[10:25:55.429]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.429]                       if (muffled) 
[10:25:55.429]                         invokeRestart("muffleMessage")
[10:25:55.429]                     }
[10:25:55.429]                     else if (inherits(cond, "warning")) {
[10:25:55.429]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.429]                       if (muffled) 
[10:25:55.429]                         invokeRestart("muffleWarning")
[10:25:55.429]                     }
[10:25:55.429]                     else if (inherits(cond, "condition")) {
[10:25:55.429]                       if (!is.null(pattern)) {
[10:25:55.429]                         computeRestarts <- base::computeRestarts
[10:25:55.429]                         grepl <- base::grepl
[10:25:55.429]                         restarts <- computeRestarts(cond)
[10:25:55.429]                         for (restart in restarts) {
[10:25:55.429]                           name <- restart$name
[10:25:55.429]                           if (is.null(name)) 
[10:25:55.429]                             next
[10:25:55.429]                           if (!grepl(pattern, name)) 
[10:25:55.429]                             next
[10:25:55.429]                           invokeRestart(restart)
[10:25:55.429]                           muffled <- TRUE
[10:25:55.429]                           break
[10:25:55.429]                         }
[10:25:55.429]                       }
[10:25:55.429]                     }
[10:25:55.429]                     invisible(muffled)
[10:25:55.429]                   }
[10:25:55.429]                   muffleCondition(cond)
[10:25:55.429]                 })
[10:25:55.429]             }))
[10:25:55.429]             future::FutureResult(value = ...future.value$value, 
[10:25:55.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.429]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.429]                     ...future.globalenv.names))
[10:25:55.429]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.429]         }, condition = base::local({
[10:25:55.429]             c <- base::c
[10:25:55.429]             inherits <- base::inherits
[10:25:55.429]             invokeRestart <- base::invokeRestart
[10:25:55.429]             length <- base::length
[10:25:55.429]             list <- base::list
[10:25:55.429]             seq.int <- base::seq.int
[10:25:55.429]             signalCondition <- base::signalCondition
[10:25:55.429]             sys.calls <- base::sys.calls
[10:25:55.429]             `[[` <- base::`[[`
[10:25:55.429]             `+` <- base::`+`
[10:25:55.429]             `<<-` <- base::`<<-`
[10:25:55.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.429]                   3L)]
[10:25:55.429]             }
[10:25:55.429]             function(cond) {
[10:25:55.429]                 is_error <- inherits(cond, "error")
[10:25:55.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.429]                   NULL)
[10:25:55.429]                 if (is_error) {
[10:25:55.429]                   sessionInformation <- function() {
[10:25:55.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.429]                       search = base::search(), system = base::Sys.info())
[10:25:55.429]                   }
[10:25:55.429]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.429]                     cond$call), session = sessionInformation(), 
[10:25:55.429]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.429]                   signalCondition(cond)
[10:25:55.429]                 }
[10:25:55.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.429]                 "immediateCondition"))) {
[10:25:55.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.429]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.429]                   if (TRUE && !signal) {
[10:25:55.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.429]                     {
[10:25:55.429]                       inherits <- base::inherits
[10:25:55.429]                       invokeRestart <- base::invokeRestart
[10:25:55.429]                       is.null <- base::is.null
[10:25:55.429]                       muffled <- FALSE
[10:25:55.429]                       if (inherits(cond, "message")) {
[10:25:55.429]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.429]                         if (muffled) 
[10:25:55.429]                           invokeRestart("muffleMessage")
[10:25:55.429]                       }
[10:25:55.429]                       else if (inherits(cond, "warning")) {
[10:25:55.429]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.429]                         if (muffled) 
[10:25:55.429]                           invokeRestart("muffleWarning")
[10:25:55.429]                       }
[10:25:55.429]                       else if (inherits(cond, "condition")) {
[10:25:55.429]                         if (!is.null(pattern)) {
[10:25:55.429]                           computeRestarts <- base::computeRestarts
[10:25:55.429]                           grepl <- base::grepl
[10:25:55.429]                           restarts <- computeRestarts(cond)
[10:25:55.429]                           for (restart in restarts) {
[10:25:55.429]                             name <- restart$name
[10:25:55.429]                             if (is.null(name)) 
[10:25:55.429]                               next
[10:25:55.429]                             if (!grepl(pattern, name)) 
[10:25:55.429]                               next
[10:25:55.429]                             invokeRestart(restart)
[10:25:55.429]                             muffled <- TRUE
[10:25:55.429]                             break
[10:25:55.429]                           }
[10:25:55.429]                         }
[10:25:55.429]                       }
[10:25:55.429]                       invisible(muffled)
[10:25:55.429]                     }
[10:25:55.429]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.429]                   }
[10:25:55.429]                 }
[10:25:55.429]                 else {
[10:25:55.429]                   if (TRUE) {
[10:25:55.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.429]                     {
[10:25:55.429]                       inherits <- base::inherits
[10:25:55.429]                       invokeRestart <- base::invokeRestart
[10:25:55.429]                       is.null <- base::is.null
[10:25:55.429]                       muffled <- FALSE
[10:25:55.429]                       if (inherits(cond, "message")) {
[10:25:55.429]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.429]                         if (muffled) 
[10:25:55.429]                           invokeRestart("muffleMessage")
[10:25:55.429]                       }
[10:25:55.429]                       else if (inherits(cond, "warning")) {
[10:25:55.429]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.429]                         if (muffled) 
[10:25:55.429]                           invokeRestart("muffleWarning")
[10:25:55.429]                       }
[10:25:55.429]                       else if (inherits(cond, "condition")) {
[10:25:55.429]                         if (!is.null(pattern)) {
[10:25:55.429]                           computeRestarts <- base::computeRestarts
[10:25:55.429]                           grepl <- base::grepl
[10:25:55.429]                           restarts <- computeRestarts(cond)
[10:25:55.429]                           for (restart in restarts) {
[10:25:55.429]                             name <- restart$name
[10:25:55.429]                             if (is.null(name)) 
[10:25:55.429]                               next
[10:25:55.429]                             if (!grepl(pattern, name)) 
[10:25:55.429]                               next
[10:25:55.429]                             invokeRestart(restart)
[10:25:55.429]                             muffled <- TRUE
[10:25:55.429]                             break
[10:25:55.429]                           }
[10:25:55.429]                         }
[10:25:55.429]                       }
[10:25:55.429]                       invisible(muffled)
[10:25:55.429]                     }
[10:25:55.429]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.429]                   }
[10:25:55.429]                 }
[10:25:55.429]             }
[10:25:55.429]         }))
[10:25:55.429]     }, error = function(ex) {
[10:25:55.429]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.429]                 ...future.rng), started = ...future.startTime, 
[10:25:55.429]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.429]             version = "1.8"), class = "FutureResult")
[10:25:55.429]     }, finally = {
[10:25:55.429]         if (!identical(...future.workdir, getwd())) 
[10:25:55.429]             setwd(...future.workdir)
[10:25:55.429]         {
[10:25:55.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.429]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.429]             }
[10:25:55.429]             base::options(...future.oldOptions)
[10:25:55.429]             if (.Platform$OS.type == "windows") {
[10:25:55.429]                 old_names <- names(...future.oldEnvVars)
[10:25:55.429]                 envs <- base::Sys.getenv()
[10:25:55.429]                 names <- names(envs)
[10:25:55.429]                 common <- intersect(names, old_names)
[10:25:55.429]                 added <- setdiff(names, old_names)
[10:25:55.429]                 removed <- setdiff(old_names, names)
[10:25:55.429]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.429]                   envs[common]]
[10:25:55.429]                 NAMES <- toupper(changed)
[10:25:55.429]                 args <- list()
[10:25:55.429]                 for (kk in seq_along(NAMES)) {
[10:25:55.429]                   name <- changed[[kk]]
[10:25:55.429]                   NAME <- NAMES[[kk]]
[10:25:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.429]                     next
[10:25:55.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.429]                 }
[10:25:55.429]                 NAMES <- toupper(added)
[10:25:55.429]                 for (kk in seq_along(NAMES)) {
[10:25:55.429]                   name <- added[[kk]]
[10:25:55.429]                   NAME <- NAMES[[kk]]
[10:25:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.429]                     next
[10:25:55.429]                   args[[name]] <- ""
[10:25:55.429]                 }
[10:25:55.429]                 NAMES <- toupper(removed)
[10:25:55.429]                 for (kk in seq_along(NAMES)) {
[10:25:55.429]                   name <- removed[[kk]]
[10:25:55.429]                   NAME <- NAMES[[kk]]
[10:25:55.429]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.429]                     next
[10:25:55.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.429]                 }
[10:25:55.429]                 if (length(args) > 0) 
[10:25:55.429]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.429]             }
[10:25:55.429]             else {
[10:25:55.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.429]             }
[10:25:55.429]             {
[10:25:55.429]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.429]                   0L) {
[10:25:55.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.429]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.429]                   base::options(opts)
[10:25:55.429]                 }
[10:25:55.429]                 {
[10:25:55.429]                   {
[10:25:55.429]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.429]                     NULL
[10:25:55.429]                   }
[10:25:55.429]                   options(future.plan = NULL)
[10:25:55.429]                   if (is.na(NA_character_)) 
[10:25:55.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.429]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.429]                     envir = parent.frame()) 
[10:25:55.429]                   {
[10:25:55.429]                     if (is.function(workers)) 
[10:25:55.429]                       workers <- workers()
[10:25:55.429]                     workers <- structure(as.integer(workers), 
[10:25:55.429]                       class = class(workers))
[10:25:55.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.429]                       workers >= 1)
[10:25:55.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.429]                     }
[10:25:55.429]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.429]                       envir = envir)
[10:25:55.429]                     if (!future$lazy) 
[10:25:55.429]                       future <- run(future)
[10:25:55.429]                     invisible(future)
[10:25:55.429]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.429]                 }
[10:25:55.429]             }
[10:25:55.429]         }
[10:25:55.429]     })
[10:25:55.429]     if (TRUE) {
[10:25:55.429]         base::sink(type = "output", split = FALSE)
[10:25:55.429]         if (TRUE) {
[10:25:55.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.429]         }
[10:25:55.429]         else {
[10:25:55.429]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.429]         }
[10:25:55.429]         base::close(...future.stdout)
[10:25:55.429]         ...future.stdout <- NULL
[10:25:55.429]     }
[10:25:55.429]     ...future.result$conditions <- ...future.conditions
[10:25:55.429]     ...future.result$finished <- base::Sys.time()
[10:25:55.429]     ...future.result
[10:25:55.429] }
[10:25:55.432] MultisessionFuture started
[10:25:55.432] - Launch lazy future ... done
[10:25:55.432] run() for ‘MultisessionFuture’ ... done
[10:25:55.432] result() for ClusterFuture ...
[10:25:55.432] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.433] - Validating connection of MultisessionFuture
[10:25:55.479] - received message: FutureResult
[10:25:55.479] - Received FutureResult
[10:25:55.479] - Erased future from FutureRegistry
[10:25:55.479] result() for ClusterFuture ...
[10:25:55.480] - result already collected: FutureResult
[10:25:55.480] result() for ClusterFuture ... done
[10:25:55.480] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.480] result() for ClusterFuture ... done
[10:25:55.480] result() for ClusterFuture ...
[10:25:55.480] - result already collected: FutureResult
[10:25:55.480] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:25:55.484] getGlobalsAndPackages() ...
[10:25:55.484] Searching for globals...
[10:25:55.486] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:25:55.486] Searching for globals ... DONE
[10:25:55.486] Resolving globals: FALSE
[10:25:55.487] 
[10:25:55.487] - packages: [2] ‘stats’, ‘datasets’
[10:25:55.487] getGlobalsAndPackages() ... DONE
[10:25:55.487] run() for ‘Future’ ...
[10:25:55.487] - state: ‘created’
[10:25:55.487] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.501] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.502]   - Field: ‘node’
[10:25:55.502]   - Field: ‘label’
[10:25:55.502]   - Field: ‘local’
[10:25:55.502]   - Field: ‘owner’
[10:25:55.502]   - Field: ‘envir’
[10:25:55.502]   - Field: ‘workers’
[10:25:55.502]   - Field: ‘packages’
[10:25:55.502]   - Field: ‘gc’
[10:25:55.502]   - Field: ‘conditions’
[10:25:55.502]   - Field: ‘persistent’
[10:25:55.503]   - Field: ‘expr’
[10:25:55.503]   - Field: ‘uuid’
[10:25:55.503]   - Field: ‘seed’
[10:25:55.503]   - Field: ‘version’
[10:25:55.503]   - Field: ‘result’
[10:25:55.503]   - Field: ‘asynchronous’
[10:25:55.503]   - Field: ‘calls’
[10:25:55.503]   - Field: ‘globals’
[10:25:55.503]   - Field: ‘stdout’
[10:25:55.503]   - Field: ‘earlySignal’
[10:25:55.503]   - Field: ‘lazy’
[10:25:55.503]   - Field: ‘state’
[10:25:55.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.504] - Launch lazy future ...
[10:25:55.504] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:55.504] Packages needed by future strategies (n = 0): <none>
[10:25:55.505] {
[10:25:55.505]     {
[10:25:55.505]         {
[10:25:55.505]             ...future.startTime <- base::Sys.time()
[10:25:55.505]             {
[10:25:55.505]                 {
[10:25:55.505]                   {
[10:25:55.505]                     {
[10:25:55.505]                       {
[10:25:55.505]                         base::local({
[10:25:55.505]                           has_future <- base::requireNamespace("future", 
[10:25:55.505]                             quietly = TRUE)
[10:25:55.505]                           if (has_future) {
[10:25:55.505]                             ns <- base::getNamespace("future")
[10:25:55.505]                             version <- ns[[".package"]][["version"]]
[10:25:55.505]                             if (is.null(version)) 
[10:25:55.505]                               version <- utils::packageVersion("future")
[10:25:55.505]                           }
[10:25:55.505]                           else {
[10:25:55.505]                             version <- NULL
[10:25:55.505]                           }
[10:25:55.505]                           if (!has_future || version < "1.8.0") {
[10:25:55.505]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.505]                               "", base::R.version$version.string), 
[10:25:55.505]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.505]                                 base::R.version$platform, 8 * 
[10:25:55.505]                                   base::.Machine$sizeof.pointer), 
[10:25:55.505]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.505]                                 "release", "version")], collapse = " "), 
[10:25:55.505]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.505]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.505]                               info)
[10:25:55.505]                             info <- base::paste(info, collapse = "; ")
[10:25:55.505]                             if (!has_future) {
[10:25:55.505]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.505]                                 info)
[10:25:55.505]                             }
[10:25:55.505]                             else {
[10:25:55.505]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.505]                                 info, version)
[10:25:55.505]                             }
[10:25:55.505]                             base::stop(msg)
[10:25:55.505]                           }
[10:25:55.505]                         })
[10:25:55.505]                       }
[10:25:55.505]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.505]                       base::options(mc.cores = 1L)
[10:25:55.505]                     }
[10:25:55.505]                     base::local({
[10:25:55.505]                       for (pkg in c("stats", "datasets")) {
[10:25:55.505]                         base::loadNamespace(pkg)
[10:25:55.505]                         base::library(pkg, character.only = TRUE)
[10:25:55.505]                       }
[10:25:55.505]                     })
[10:25:55.505]                   }
[10:25:55.505]                   options(future.plan = NULL)
[10:25:55.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.505]                 }
[10:25:55.505]                 ...future.workdir <- getwd()
[10:25:55.505]             }
[10:25:55.505]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.505]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.505]         }
[10:25:55.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.505]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.505]             base::names(...future.oldOptions))
[10:25:55.505]     }
[10:25:55.505]     if (FALSE) {
[10:25:55.505]     }
[10:25:55.505]     else {
[10:25:55.505]         if (TRUE) {
[10:25:55.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.505]                 open = "w")
[10:25:55.505]         }
[10:25:55.505]         else {
[10:25:55.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.505]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.505]         }
[10:25:55.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.505]             base::sink(type = "output", split = FALSE)
[10:25:55.505]             base::close(...future.stdout)
[10:25:55.505]         }, add = TRUE)
[10:25:55.505]     }
[10:25:55.505]     ...future.frame <- base::sys.nframe()
[10:25:55.505]     ...future.conditions <- base::list()
[10:25:55.505]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.505]     if (FALSE) {
[10:25:55.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.505]     }
[10:25:55.505]     ...future.result <- base::tryCatch({
[10:25:55.505]         base::withCallingHandlers({
[10:25:55.505]             ...future.value <- base::withVisible(base::local({
[10:25:55.505]                 ...future.makeSendCondition <- base::local({
[10:25:55.505]                   sendCondition <- NULL
[10:25:55.505]                   function(frame = 1L) {
[10:25:55.505]                     if (is.function(sendCondition)) 
[10:25:55.505]                       return(sendCondition)
[10:25:55.505]                     ns <- getNamespace("parallel")
[10:25:55.505]                     if (exists("sendData", mode = "function", 
[10:25:55.505]                       envir = ns)) {
[10:25:55.505]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.505]                         envir = ns)
[10:25:55.505]                       envir <- sys.frame(frame)
[10:25:55.505]                       master <- NULL
[10:25:55.505]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.505]                         !identical(envir, emptyenv())) {
[10:25:55.505]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.505]                           inherits = FALSE)) {
[10:25:55.505]                           master <- get("master", mode = "list", 
[10:25:55.505]                             envir = envir, inherits = FALSE)
[10:25:55.505]                           if (inherits(master, c("SOCKnode", 
[10:25:55.505]                             "SOCK0node"))) {
[10:25:55.505]                             sendCondition <<- function(cond) {
[10:25:55.505]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.505]                                 success = TRUE)
[10:25:55.505]                               parallel_sendData(master, data)
[10:25:55.505]                             }
[10:25:55.505]                             return(sendCondition)
[10:25:55.505]                           }
[10:25:55.505]                         }
[10:25:55.505]                         frame <- frame + 1L
[10:25:55.505]                         envir <- sys.frame(frame)
[10:25:55.505]                       }
[10:25:55.505]                     }
[10:25:55.505]                     sendCondition <<- function(cond) NULL
[10:25:55.505]                   }
[10:25:55.505]                 })
[10:25:55.505]                 withCallingHandlers({
[10:25:55.505]                   {
[10:25:55.505]                     lm(dist ~ . + 0, data = cars)
[10:25:55.505]                   }
[10:25:55.505]                 }, immediateCondition = function(cond) {
[10:25:55.505]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.505]                   sendCondition(cond)
[10:25:55.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.505]                   {
[10:25:55.505]                     inherits <- base::inherits
[10:25:55.505]                     invokeRestart <- base::invokeRestart
[10:25:55.505]                     is.null <- base::is.null
[10:25:55.505]                     muffled <- FALSE
[10:25:55.505]                     if (inherits(cond, "message")) {
[10:25:55.505]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.505]                       if (muffled) 
[10:25:55.505]                         invokeRestart("muffleMessage")
[10:25:55.505]                     }
[10:25:55.505]                     else if (inherits(cond, "warning")) {
[10:25:55.505]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.505]                       if (muffled) 
[10:25:55.505]                         invokeRestart("muffleWarning")
[10:25:55.505]                     }
[10:25:55.505]                     else if (inherits(cond, "condition")) {
[10:25:55.505]                       if (!is.null(pattern)) {
[10:25:55.505]                         computeRestarts <- base::computeRestarts
[10:25:55.505]                         grepl <- base::grepl
[10:25:55.505]                         restarts <- computeRestarts(cond)
[10:25:55.505]                         for (restart in restarts) {
[10:25:55.505]                           name <- restart$name
[10:25:55.505]                           if (is.null(name)) 
[10:25:55.505]                             next
[10:25:55.505]                           if (!grepl(pattern, name)) 
[10:25:55.505]                             next
[10:25:55.505]                           invokeRestart(restart)
[10:25:55.505]                           muffled <- TRUE
[10:25:55.505]                           break
[10:25:55.505]                         }
[10:25:55.505]                       }
[10:25:55.505]                     }
[10:25:55.505]                     invisible(muffled)
[10:25:55.505]                   }
[10:25:55.505]                   muffleCondition(cond)
[10:25:55.505]                 })
[10:25:55.505]             }))
[10:25:55.505]             future::FutureResult(value = ...future.value$value, 
[10:25:55.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.505]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.505]                     ...future.globalenv.names))
[10:25:55.505]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.505]         }, condition = base::local({
[10:25:55.505]             c <- base::c
[10:25:55.505]             inherits <- base::inherits
[10:25:55.505]             invokeRestart <- base::invokeRestart
[10:25:55.505]             length <- base::length
[10:25:55.505]             list <- base::list
[10:25:55.505]             seq.int <- base::seq.int
[10:25:55.505]             signalCondition <- base::signalCondition
[10:25:55.505]             sys.calls <- base::sys.calls
[10:25:55.505]             `[[` <- base::`[[`
[10:25:55.505]             `+` <- base::`+`
[10:25:55.505]             `<<-` <- base::`<<-`
[10:25:55.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.505]                   3L)]
[10:25:55.505]             }
[10:25:55.505]             function(cond) {
[10:25:55.505]                 is_error <- inherits(cond, "error")
[10:25:55.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.505]                   NULL)
[10:25:55.505]                 if (is_error) {
[10:25:55.505]                   sessionInformation <- function() {
[10:25:55.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.505]                       search = base::search(), system = base::Sys.info())
[10:25:55.505]                   }
[10:25:55.505]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.505]                     cond$call), session = sessionInformation(), 
[10:25:55.505]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.505]                   signalCondition(cond)
[10:25:55.505]                 }
[10:25:55.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.505]                 "immediateCondition"))) {
[10:25:55.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.505]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.505]                   if (TRUE && !signal) {
[10:25:55.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.505]                     {
[10:25:55.505]                       inherits <- base::inherits
[10:25:55.505]                       invokeRestart <- base::invokeRestart
[10:25:55.505]                       is.null <- base::is.null
[10:25:55.505]                       muffled <- FALSE
[10:25:55.505]                       if (inherits(cond, "message")) {
[10:25:55.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.505]                         if (muffled) 
[10:25:55.505]                           invokeRestart("muffleMessage")
[10:25:55.505]                       }
[10:25:55.505]                       else if (inherits(cond, "warning")) {
[10:25:55.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.505]                         if (muffled) 
[10:25:55.505]                           invokeRestart("muffleWarning")
[10:25:55.505]                       }
[10:25:55.505]                       else if (inherits(cond, "condition")) {
[10:25:55.505]                         if (!is.null(pattern)) {
[10:25:55.505]                           computeRestarts <- base::computeRestarts
[10:25:55.505]                           grepl <- base::grepl
[10:25:55.505]                           restarts <- computeRestarts(cond)
[10:25:55.505]                           for (restart in restarts) {
[10:25:55.505]                             name <- restart$name
[10:25:55.505]                             if (is.null(name)) 
[10:25:55.505]                               next
[10:25:55.505]                             if (!grepl(pattern, name)) 
[10:25:55.505]                               next
[10:25:55.505]                             invokeRestart(restart)
[10:25:55.505]                             muffled <- TRUE
[10:25:55.505]                             break
[10:25:55.505]                           }
[10:25:55.505]                         }
[10:25:55.505]                       }
[10:25:55.505]                       invisible(muffled)
[10:25:55.505]                     }
[10:25:55.505]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.505]                   }
[10:25:55.505]                 }
[10:25:55.505]                 else {
[10:25:55.505]                   if (TRUE) {
[10:25:55.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.505]                     {
[10:25:55.505]                       inherits <- base::inherits
[10:25:55.505]                       invokeRestart <- base::invokeRestart
[10:25:55.505]                       is.null <- base::is.null
[10:25:55.505]                       muffled <- FALSE
[10:25:55.505]                       if (inherits(cond, "message")) {
[10:25:55.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.505]                         if (muffled) 
[10:25:55.505]                           invokeRestart("muffleMessage")
[10:25:55.505]                       }
[10:25:55.505]                       else if (inherits(cond, "warning")) {
[10:25:55.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.505]                         if (muffled) 
[10:25:55.505]                           invokeRestart("muffleWarning")
[10:25:55.505]                       }
[10:25:55.505]                       else if (inherits(cond, "condition")) {
[10:25:55.505]                         if (!is.null(pattern)) {
[10:25:55.505]                           computeRestarts <- base::computeRestarts
[10:25:55.505]                           grepl <- base::grepl
[10:25:55.505]                           restarts <- computeRestarts(cond)
[10:25:55.505]                           for (restart in restarts) {
[10:25:55.505]                             name <- restart$name
[10:25:55.505]                             if (is.null(name)) 
[10:25:55.505]                               next
[10:25:55.505]                             if (!grepl(pattern, name)) 
[10:25:55.505]                               next
[10:25:55.505]                             invokeRestart(restart)
[10:25:55.505]                             muffled <- TRUE
[10:25:55.505]                             break
[10:25:55.505]                           }
[10:25:55.505]                         }
[10:25:55.505]                       }
[10:25:55.505]                       invisible(muffled)
[10:25:55.505]                     }
[10:25:55.505]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.505]                   }
[10:25:55.505]                 }
[10:25:55.505]             }
[10:25:55.505]         }))
[10:25:55.505]     }, error = function(ex) {
[10:25:55.505]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.505]                 ...future.rng), started = ...future.startTime, 
[10:25:55.505]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.505]             version = "1.8"), class = "FutureResult")
[10:25:55.505]     }, finally = {
[10:25:55.505]         if (!identical(...future.workdir, getwd())) 
[10:25:55.505]             setwd(...future.workdir)
[10:25:55.505]         {
[10:25:55.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.505]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.505]             }
[10:25:55.505]             base::options(...future.oldOptions)
[10:25:55.505]             if (.Platform$OS.type == "windows") {
[10:25:55.505]                 old_names <- names(...future.oldEnvVars)
[10:25:55.505]                 envs <- base::Sys.getenv()
[10:25:55.505]                 names <- names(envs)
[10:25:55.505]                 common <- intersect(names, old_names)
[10:25:55.505]                 added <- setdiff(names, old_names)
[10:25:55.505]                 removed <- setdiff(old_names, names)
[10:25:55.505]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.505]                   envs[common]]
[10:25:55.505]                 NAMES <- toupper(changed)
[10:25:55.505]                 args <- list()
[10:25:55.505]                 for (kk in seq_along(NAMES)) {
[10:25:55.505]                   name <- changed[[kk]]
[10:25:55.505]                   NAME <- NAMES[[kk]]
[10:25:55.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.505]                     next
[10:25:55.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.505]                 }
[10:25:55.505]                 NAMES <- toupper(added)
[10:25:55.505]                 for (kk in seq_along(NAMES)) {
[10:25:55.505]                   name <- added[[kk]]
[10:25:55.505]                   NAME <- NAMES[[kk]]
[10:25:55.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.505]                     next
[10:25:55.505]                   args[[name]] <- ""
[10:25:55.505]                 }
[10:25:55.505]                 NAMES <- toupper(removed)
[10:25:55.505]                 for (kk in seq_along(NAMES)) {
[10:25:55.505]                   name <- removed[[kk]]
[10:25:55.505]                   NAME <- NAMES[[kk]]
[10:25:55.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.505]                     next
[10:25:55.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.505]                 }
[10:25:55.505]                 if (length(args) > 0) 
[10:25:55.505]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.505]             }
[10:25:55.505]             else {
[10:25:55.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.505]             }
[10:25:55.505]             {
[10:25:55.505]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.505]                   0L) {
[10:25:55.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.505]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.505]                   base::options(opts)
[10:25:55.505]                 }
[10:25:55.505]                 {
[10:25:55.505]                   {
[10:25:55.505]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.505]                     NULL
[10:25:55.505]                   }
[10:25:55.505]                   options(future.plan = NULL)
[10:25:55.505]                   if (is.na(NA_character_)) 
[10:25:55.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.505]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.505]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.505]                     envir = parent.frame()) 
[10:25:55.505]                   {
[10:25:55.505]                     if (is.function(workers)) 
[10:25:55.505]                       workers <- workers()
[10:25:55.505]                     workers <- structure(as.integer(workers), 
[10:25:55.505]                       class = class(workers))
[10:25:55.505]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.505]                       workers >= 1)
[10:25:55.505]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.505]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.505]                     }
[10:25:55.505]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.505]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.505]                       envir = envir)
[10:25:55.505]                     if (!future$lazy) 
[10:25:55.505]                       future <- run(future)
[10:25:55.505]                     invisible(future)
[10:25:55.505]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.505]                 }
[10:25:55.505]             }
[10:25:55.505]         }
[10:25:55.505]     })
[10:25:55.505]     if (TRUE) {
[10:25:55.505]         base::sink(type = "output", split = FALSE)
[10:25:55.505]         if (TRUE) {
[10:25:55.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.505]         }
[10:25:55.505]         else {
[10:25:55.505]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.505]         }
[10:25:55.505]         base::close(...future.stdout)
[10:25:55.505]         ...future.stdout <- NULL
[10:25:55.505]     }
[10:25:55.505]     ...future.result$conditions <- ...future.conditions
[10:25:55.505]     ...future.result$finished <- base::Sys.time()
[10:25:55.505]     ...future.result
[10:25:55.505] }
[10:25:55.508] MultisessionFuture started
[10:25:55.508] - Launch lazy future ... done
[10:25:55.508] run() for ‘MultisessionFuture’ ... done
[10:25:55.508] result() for ClusterFuture ...
[10:25:55.508] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.508] - Validating connection of MultisessionFuture
[10:25:55.555] - received message: FutureResult
[10:25:55.555] - Received FutureResult
[10:25:55.555] - Erased future from FutureRegistry
[10:25:55.555] result() for ClusterFuture ...
[10:25:55.555] - result already collected: FutureResult
[10:25:55.556] result() for ClusterFuture ... done
[10:25:55.556] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.556] result() for ClusterFuture ... done
[10:25:55.556] result() for ClusterFuture ...
[10:25:55.556] - result already collected: FutureResult
[10:25:55.556] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:25:55.558] getGlobalsAndPackages() ...
[10:25:55.558] Searching for globals...
[10:25:55.560] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:25:55.560] Searching for globals ... DONE
[10:25:55.560] Resolving globals: FALSE
[10:25:55.561] 
[10:25:55.561] - packages: [2] ‘stats’, ‘datasets’
[10:25:55.561] getGlobalsAndPackages() ... DONE
[10:25:55.561] run() for ‘Future’ ...
[10:25:55.561] - state: ‘created’
[10:25:55.562] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.575] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.576]   - Field: ‘node’
[10:25:55.576]   - Field: ‘label’
[10:25:55.576]   - Field: ‘local’
[10:25:55.576]   - Field: ‘owner’
[10:25:55.576]   - Field: ‘envir’
[10:25:55.576]   - Field: ‘workers’
[10:25:55.576]   - Field: ‘packages’
[10:25:55.576]   - Field: ‘gc’
[10:25:55.576]   - Field: ‘conditions’
[10:25:55.576]   - Field: ‘persistent’
[10:25:55.577]   - Field: ‘expr’
[10:25:55.577]   - Field: ‘uuid’
[10:25:55.577]   - Field: ‘seed’
[10:25:55.577]   - Field: ‘version’
[10:25:55.577]   - Field: ‘result’
[10:25:55.577]   - Field: ‘asynchronous’
[10:25:55.577]   - Field: ‘calls’
[10:25:55.577]   - Field: ‘globals’
[10:25:55.577]   - Field: ‘stdout’
[10:25:55.577]   - Field: ‘earlySignal’
[10:25:55.578]   - Field: ‘lazy’
[10:25:55.578]   - Field: ‘state’
[10:25:55.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.578] - Launch lazy future ...
[10:25:55.578] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:55.578] Packages needed by future strategies (n = 0): <none>
[10:25:55.579] {
[10:25:55.579]     {
[10:25:55.579]         {
[10:25:55.579]             ...future.startTime <- base::Sys.time()
[10:25:55.579]             {
[10:25:55.579]                 {
[10:25:55.579]                   {
[10:25:55.579]                     {
[10:25:55.579]                       {
[10:25:55.579]                         base::local({
[10:25:55.579]                           has_future <- base::requireNamespace("future", 
[10:25:55.579]                             quietly = TRUE)
[10:25:55.579]                           if (has_future) {
[10:25:55.579]                             ns <- base::getNamespace("future")
[10:25:55.579]                             version <- ns[[".package"]][["version"]]
[10:25:55.579]                             if (is.null(version)) 
[10:25:55.579]                               version <- utils::packageVersion("future")
[10:25:55.579]                           }
[10:25:55.579]                           else {
[10:25:55.579]                             version <- NULL
[10:25:55.579]                           }
[10:25:55.579]                           if (!has_future || version < "1.8.0") {
[10:25:55.579]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.579]                               "", base::R.version$version.string), 
[10:25:55.579]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.579]                                 base::R.version$platform, 8 * 
[10:25:55.579]                                   base::.Machine$sizeof.pointer), 
[10:25:55.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.579]                                 "release", "version")], collapse = " "), 
[10:25:55.579]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.579]                               info)
[10:25:55.579]                             info <- base::paste(info, collapse = "; ")
[10:25:55.579]                             if (!has_future) {
[10:25:55.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.579]                                 info)
[10:25:55.579]                             }
[10:25:55.579]                             else {
[10:25:55.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.579]                                 info, version)
[10:25:55.579]                             }
[10:25:55.579]                             base::stop(msg)
[10:25:55.579]                           }
[10:25:55.579]                         })
[10:25:55.579]                       }
[10:25:55.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.579]                       base::options(mc.cores = 1L)
[10:25:55.579]                     }
[10:25:55.579]                     base::local({
[10:25:55.579]                       for (pkg in c("stats", "datasets")) {
[10:25:55.579]                         base::loadNamespace(pkg)
[10:25:55.579]                         base::library(pkg, character.only = TRUE)
[10:25:55.579]                       }
[10:25:55.579]                     })
[10:25:55.579]                   }
[10:25:55.579]                   options(future.plan = NULL)
[10:25:55.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.579]                 }
[10:25:55.579]                 ...future.workdir <- getwd()
[10:25:55.579]             }
[10:25:55.579]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.579]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.579]         }
[10:25:55.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.579]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.579]             base::names(...future.oldOptions))
[10:25:55.579]     }
[10:25:55.579]     if (FALSE) {
[10:25:55.579]     }
[10:25:55.579]     else {
[10:25:55.579]         if (TRUE) {
[10:25:55.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.579]                 open = "w")
[10:25:55.579]         }
[10:25:55.579]         else {
[10:25:55.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.579]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.579]         }
[10:25:55.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.579]             base::sink(type = "output", split = FALSE)
[10:25:55.579]             base::close(...future.stdout)
[10:25:55.579]         }, add = TRUE)
[10:25:55.579]     }
[10:25:55.579]     ...future.frame <- base::sys.nframe()
[10:25:55.579]     ...future.conditions <- base::list()
[10:25:55.579]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.579]     if (FALSE) {
[10:25:55.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.579]     }
[10:25:55.579]     ...future.result <- base::tryCatch({
[10:25:55.579]         base::withCallingHandlers({
[10:25:55.579]             ...future.value <- base::withVisible(base::local({
[10:25:55.579]                 ...future.makeSendCondition <- base::local({
[10:25:55.579]                   sendCondition <- NULL
[10:25:55.579]                   function(frame = 1L) {
[10:25:55.579]                     if (is.function(sendCondition)) 
[10:25:55.579]                       return(sendCondition)
[10:25:55.579]                     ns <- getNamespace("parallel")
[10:25:55.579]                     if (exists("sendData", mode = "function", 
[10:25:55.579]                       envir = ns)) {
[10:25:55.579]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.579]                         envir = ns)
[10:25:55.579]                       envir <- sys.frame(frame)
[10:25:55.579]                       master <- NULL
[10:25:55.579]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.579]                         !identical(envir, emptyenv())) {
[10:25:55.579]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.579]                           inherits = FALSE)) {
[10:25:55.579]                           master <- get("master", mode = "list", 
[10:25:55.579]                             envir = envir, inherits = FALSE)
[10:25:55.579]                           if (inherits(master, c("SOCKnode", 
[10:25:55.579]                             "SOCK0node"))) {
[10:25:55.579]                             sendCondition <<- function(cond) {
[10:25:55.579]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.579]                                 success = TRUE)
[10:25:55.579]                               parallel_sendData(master, data)
[10:25:55.579]                             }
[10:25:55.579]                             return(sendCondition)
[10:25:55.579]                           }
[10:25:55.579]                         }
[10:25:55.579]                         frame <- frame + 1L
[10:25:55.579]                         envir <- sys.frame(frame)
[10:25:55.579]                       }
[10:25:55.579]                     }
[10:25:55.579]                     sendCondition <<- function(cond) NULL
[10:25:55.579]                   }
[10:25:55.579]                 })
[10:25:55.579]                 withCallingHandlers({
[10:25:55.579]                   {
[10:25:55.579]                     lm(dist ~ speed + speed^2, data = cars)
[10:25:55.579]                   }
[10:25:55.579]                 }, immediateCondition = function(cond) {
[10:25:55.579]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.579]                   sendCondition(cond)
[10:25:55.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.579]                   {
[10:25:55.579]                     inherits <- base::inherits
[10:25:55.579]                     invokeRestart <- base::invokeRestart
[10:25:55.579]                     is.null <- base::is.null
[10:25:55.579]                     muffled <- FALSE
[10:25:55.579]                     if (inherits(cond, "message")) {
[10:25:55.579]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.579]                       if (muffled) 
[10:25:55.579]                         invokeRestart("muffleMessage")
[10:25:55.579]                     }
[10:25:55.579]                     else if (inherits(cond, "warning")) {
[10:25:55.579]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.579]                       if (muffled) 
[10:25:55.579]                         invokeRestart("muffleWarning")
[10:25:55.579]                     }
[10:25:55.579]                     else if (inherits(cond, "condition")) {
[10:25:55.579]                       if (!is.null(pattern)) {
[10:25:55.579]                         computeRestarts <- base::computeRestarts
[10:25:55.579]                         grepl <- base::grepl
[10:25:55.579]                         restarts <- computeRestarts(cond)
[10:25:55.579]                         for (restart in restarts) {
[10:25:55.579]                           name <- restart$name
[10:25:55.579]                           if (is.null(name)) 
[10:25:55.579]                             next
[10:25:55.579]                           if (!grepl(pattern, name)) 
[10:25:55.579]                             next
[10:25:55.579]                           invokeRestart(restart)
[10:25:55.579]                           muffled <- TRUE
[10:25:55.579]                           break
[10:25:55.579]                         }
[10:25:55.579]                       }
[10:25:55.579]                     }
[10:25:55.579]                     invisible(muffled)
[10:25:55.579]                   }
[10:25:55.579]                   muffleCondition(cond)
[10:25:55.579]                 })
[10:25:55.579]             }))
[10:25:55.579]             future::FutureResult(value = ...future.value$value, 
[10:25:55.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.579]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.579]                     ...future.globalenv.names))
[10:25:55.579]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.579]         }, condition = base::local({
[10:25:55.579]             c <- base::c
[10:25:55.579]             inherits <- base::inherits
[10:25:55.579]             invokeRestart <- base::invokeRestart
[10:25:55.579]             length <- base::length
[10:25:55.579]             list <- base::list
[10:25:55.579]             seq.int <- base::seq.int
[10:25:55.579]             signalCondition <- base::signalCondition
[10:25:55.579]             sys.calls <- base::sys.calls
[10:25:55.579]             `[[` <- base::`[[`
[10:25:55.579]             `+` <- base::`+`
[10:25:55.579]             `<<-` <- base::`<<-`
[10:25:55.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.579]                   3L)]
[10:25:55.579]             }
[10:25:55.579]             function(cond) {
[10:25:55.579]                 is_error <- inherits(cond, "error")
[10:25:55.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.579]                   NULL)
[10:25:55.579]                 if (is_error) {
[10:25:55.579]                   sessionInformation <- function() {
[10:25:55.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.579]                       search = base::search(), system = base::Sys.info())
[10:25:55.579]                   }
[10:25:55.579]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.579]                     cond$call), session = sessionInformation(), 
[10:25:55.579]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.579]                   signalCondition(cond)
[10:25:55.579]                 }
[10:25:55.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.579]                 "immediateCondition"))) {
[10:25:55.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.579]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.579]                   if (TRUE && !signal) {
[10:25:55.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.579]                     {
[10:25:55.579]                       inherits <- base::inherits
[10:25:55.579]                       invokeRestart <- base::invokeRestart
[10:25:55.579]                       is.null <- base::is.null
[10:25:55.579]                       muffled <- FALSE
[10:25:55.579]                       if (inherits(cond, "message")) {
[10:25:55.579]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.579]                         if (muffled) 
[10:25:55.579]                           invokeRestart("muffleMessage")
[10:25:55.579]                       }
[10:25:55.579]                       else if (inherits(cond, "warning")) {
[10:25:55.579]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.579]                         if (muffled) 
[10:25:55.579]                           invokeRestart("muffleWarning")
[10:25:55.579]                       }
[10:25:55.579]                       else if (inherits(cond, "condition")) {
[10:25:55.579]                         if (!is.null(pattern)) {
[10:25:55.579]                           computeRestarts <- base::computeRestarts
[10:25:55.579]                           grepl <- base::grepl
[10:25:55.579]                           restarts <- computeRestarts(cond)
[10:25:55.579]                           for (restart in restarts) {
[10:25:55.579]                             name <- restart$name
[10:25:55.579]                             if (is.null(name)) 
[10:25:55.579]                               next
[10:25:55.579]                             if (!grepl(pattern, name)) 
[10:25:55.579]                               next
[10:25:55.579]                             invokeRestart(restart)
[10:25:55.579]                             muffled <- TRUE
[10:25:55.579]                             break
[10:25:55.579]                           }
[10:25:55.579]                         }
[10:25:55.579]                       }
[10:25:55.579]                       invisible(muffled)
[10:25:55.579]                     }
[10:25:55.579]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.579]                   }
[10:25:55.579]                 }
[10:25:55.579]                 else {
[10:25:55.579]                   if (TRUE) {
[10:25:55.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.579]                     {
[10:25:55.579]                       inherits <- base::inherits
[10:25:55.579]                       invokeRestart <- base::invokeRestart
[10:25:55.579]                       is.null <- base::is.null
[10:25:55.579]                       muffled <- FALSE
[10:25:55.579]                       if (inherits(cond, "message")) {
[10:25:55.579]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.579]                         if (muffled) 
[10:25:55.579]                           invokeRestart("muffleMessage")
[10:25:55.579]                       }
[10:25:55.579]                       else if (inherits(cond, "warning")) {
[10:25:55.579]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.579]                         if (muffled) 
[10:25:55.579]                           invokeRestart("muffleWarning")
[10:25:55.579]                       }
[10:25:55.579]                       else if (inherits(cond, "condition")) {
[10:25:55.579]                         if (!is.null(pattern)) {
[10:25:55.579]                           computeRestarts <- base::computeRestarts
[10:25:55.579]                           grepl <- base::grepl
[10:25:55.579]                           restarts <- computeRestarts(cond)
[10:25:55.579]                           for (restart in restarts) {
[10:25:55.579]                             name <- restart$name
[10:25:55.579]                             if (is.null(name)) 
[10:25:55.579]                               next
[10:25:55.579]                             if (!grepl(pattern, name)) 
[10:25:55.579]                               next
[10:25:55.579]                             invokeRestart(restart)
[10:25:55.579]                             muffled <- TRUE
[10:25:55.579]                             break
[10:25:55.579]                           }
[10:25:55.579]                         }
[10:25:55.579]                       }
[10:25:55.579]                       invisible(muffled)
[10:25:55.579]                     }
[10:25:55.579]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.579]                   }
[10:25:55.579]                 }
[10:25:55.579]             }
[10:25:55.579]         }))
[10:25:55.579]     }, error = function(ex) {
[10:25:55.579]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.579]                 ...future.rng), started = ...future.startTime, 
[10:25:55.579]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.579]             version = "1.8"), class = "FutureResult")
[10:25:55.579]     }, finally = {
[10:25:55.579]         if (!identical(...future.workdir, getwd())) 
[10:25:55.579]             setwd(...future.workdir)
[10:25:55.579]         {
[10:25:55.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.579]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.579]             }
[10:25:55.579]             base::options(...future.oldOptions)
[10:25:55.579]             if (.Platform$OS.type == "windows") {
[10:25:55.579]                 old_names <- names(...future.oldEnvVars)
[10:25:55.579]                 envs <- base::Sys.getenv()
[10:25:55.579]                 names <- names(envs)
[10:25:55.579]                 common <- intersect(names, old_names)
[10:25:55.579]                 added <- setdiff(names, old_names)
[10:25:55.579]                 removed <- setdiff(old_names, names)
[10:25:55.579]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.579]                   envs[common]]
[10:25:55.579]                 NAMES <- toupper(changed)
[10:25:55.579]                 args <- list()
[10:25:55.579]                 for (kk in seq_along(NAMES)) {
[10:25:55.579]                   name <- changed[[kk]]
[10:25:55.579]                   NAME <- NAMES[[kk]]
[10:25:55.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.579]                     next
[10:25:55.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.579]                 }
[10:25:55.579]                 NAMES <- toupper(added)
[10:25:55.579]                 for (kk in seq_along(NAMES)) {
[10:25:55.579]                   name <- added[[kk]]
[10:25:55.579]                   NAME <- NAMES[[kk]]
[10:25:55.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.579]                     next
[10:25:55.579]                   args[[name]] <- ""
[10:25:55.579]                 }
[10:25:55.579]                 NAMES <- toupper(removed)
[10:25:55.579]                 for (kk in seq_along(NAMES)) {
[10:25:55.579]                   name <- removed[[kk]]
[10:25:55.579]                   NAME <- NAMES[[kk]]
[10:25:55.579]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.579]                     next
[10:25:55.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.579]                 }
[10:25:55.579]                 if (length(args) > 0) 
[10:25:55.579]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.579]             }
[10:25:55.579]             else {
[10:25:55.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.579]             }
[10:25:55.579]             {
[10:25:55.579]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.579]                   0L) {
[10:25:55.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.579]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.579]                   base::options(opts)
[10:25:55.579]                 }
[10:25:55.579]                 {
[10:25:55.579]                   {
[10:25:55.579]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.579]                     NULL
[10:25:55.579]                   }
[10:25:55.579]                   options(future.plan = NULL)
[10:25:55.579]                   if (is.na(NA_character_)) 
[10:25:55.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.579]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.579]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.579]                     envir = parent.frame()) 
[10:25:55.579]                   {
[10:25:55.579]                     if (is.function(workers)) 
[10:25:55.579]                       workers <- workers()
[10:25:55.579]                     workers <- structure(as.integer(workers), 
[10:25:55.579]                       class = class(workers))
[10:25:55.579]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.579]                       workers >= 1)
[10:25:55.579]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.579]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.579]                     }
[10:25:55.579]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.579]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.579]                       envir = envir)
[10:25:55.579]                     if (!future$lazy) 
[10:25:55.579]                       future <- run(future)
[10:25:55.579]                     invisible(future)
[10:25:55.579]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.579]                 }
[10:25:55.579]             }
[10:25:55.579]         }
[10:25:55.579]     })
[10:25:55.579]     if (TRUE) {
[10:25:55.579]         base::sink(type = "output", split = FALSE)
[10:25:55.579]         if (TRUE) {
[10:25:55.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.579]         }
[10:25:55.579]         else {
[10:25:55.579]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.579]         }
[10:25:55.579]         base::close(...future.stdout)
[10:25:55.579]         ...future.stdout <- NULL
[10:25:55.579]     }
[10:25:55.579]     ...future.result$conditions <- ...future.conditions
[10:25:55.579]     ...future.result$finished <- base::Sys.time()
[10:25:55.579]     ...future.result
[10:25:55.579] }
[10:25:55.582] MultisessionFuture started
[10:25:55.582] - Launch lazy future ... done
[10:25:55.582] run() for ‘MultisessionFuture’ ... done
[10:25:55.582] result() for ClusterFuture ...
[10:25:55.582] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.582] - Validating connection of MultisessionFuture
[10:25:55.631] - received message: FutureResult
[10:25:55.631] - Received FutureResult
[10:25:55.631] - Erased future from FutureRegistry
[10:25:55.631] result() for ClusterFuture ...
[10:25:55.631] - result already collected: FutureResult
[10:25:55.632] result() for ClusterFuture ... done
[10:25:55.632] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.632] result() for ClusterFuture ... done
[10:25:55.632] result() for ClusterFuture ...
[10:25:55.632] - result already collected: FutureResult
[10:25:55.632] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:25:55.635] getGlobalsAndPackages() ...
[10:25:55.635] Searching for globals...
[10:25:55.637] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:25:55.637] Searching for globals ... DONE
[10:25:55.637] Resolving globals: FALSE
[10:25:55.637] 
[10:25:55.637] - packages: [2] ‘stats’, ‘datasets’
[10:25:55.638] getGlobalsAndPackages() ... DONE
[10:25:55.638] run() for ‘Future’ ...
[10:25:55.638] - state: ‘created’
[10:25:55.638] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.651] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.652]   - Field: ‘node’
[10:25:55.652]   - Field: ‘label’
[10:25:55.652]   - Field: ‘local’
[10:25:55.652]   - Field: ‘owner’
[10:25:55.652]   - Field: ‘envir’
[10:25:55.652]   - Field: ‘workers’
[10:25:55.652]   - Field: ‘packages’
[10:25:55.652]   - Field: ‘gc’
[10:25:55.652]   - Field: ‘conditions’
[10:25:55.652]   - Field: ‘persistent’
[10:25:55.653]   - Field: ‘expr’
[10:25:55.653]   - Field: ‘uuid’
[10:25:55.653]   - Field: ‘seed’
[10:25:55.653]   - Field: ‘version’
[10:25:55.653]   - Field: ‘result’
[10:25:55.653]   - Field: ‘asynchronous’
[10:25:55.653]   - Field: ‘calls’
[10:25:55.653]   - Field: ‘globals’
[10:25:55.653]   - Field: ‘stdout’
[10:25:55.653]   - Field: ‘earlySignal’
[10:25:55.654]   - Field: ‘lazy’
[10:25:55.654]   - Field: ‘state’
[10:25:55.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.654] - Launch lazy future ...
[10:25:55.654] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:55.654] Packages needed by future strategies (n = 0): <none>
[10:25:55.655] {
[10:25:55.655]     {
[10:25:55.655]         {
[10:25:55.655]             ...future.startTime <- base::Sys.time()
[10:25:55.655]             {
[10:25:55.655]                 {
[10:25:55.655]                   {
[10:25:55.655]                     {
[10:25:55.655]                       {
[10:25:55.655]                         base::local({
[10:25:55.655]                           has_future <- base::requireNamespace("future", 
[10:25:55.655]                             quietly = TRUE)
[10:25:55.655]                           if (has_future) {
[10:25:55.655]                             ns <- base::getNamespace("future")
[10:25:55.655]                             version <- ns[[".package"]][["version"]]
[10:25:55.655]                             if (is.null(version)) 
[10:25:55.655]                               version <- utils::packageVersion("future")
[10:25:55.655]                           }
[10:25:55.655]                           else {
[10:25:55.655]                             version <- NULL
[10:25:55.655]                           }
[10:25:55.655]                           if (!has_future || version < "1.8.0") {
[10:25:55.655]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.655]                               "", base::R.version$version.string), 
[10:25:55.655]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.655]                                 base::R.version$platform, 8 * 
[10:25:55.655]                                   base::.Machine$sizeof.pointer), 
[10:25:55.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.655]                                 "release", "version")], collapse = " "), 
[10:25:55.655]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.655]                               info)
[10:25:55.655]                             info <- base::paste(info, collapse = "; ")
[10:25:55.655]                             if (!has_future) {
[10:25:55.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.655]                                 info)
[10:25:55.655]                             }
[10:25:55.655]                             else {
[10:25:55.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.655]                                 info, version)
[10:25:55.655]                             }
[10:25:55.655]                             base::stop(msg)
[10:25:55.655]                           }
[10:25:55.655]                         })
[10:25:55.655]                       }
[10:25:55.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.655]                       base::options(mc.cores = 1L)
[10:25:55.655]                     }
[10:25:55.655]                     base::local({
[10:25:55.655]                       for (pkg in c("stats", "datasets")) {
[10:25:55.655]                         base::loadNamespace(pkg)
[10:25:55.655]                         base::library(pkg, character.only = TRUE)
[10:25:55.655]                       }
[10:25:55.655]                     })
[10:25:55.655]                   }
[10:25:55.655]                   options(future.plan = NULL)
[10:25:55.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.655]                 }
[10:25:55.655]                 ...future.workdir <- getwd()
[10:25:55.655]             }
[10:25:55.655]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.655]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.655]         }
[10:25:55.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.655]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.655]             base::names(...future.oldOptions))
[10:25:55.655]     }
[10:25:55.655]     if (FALSE) {
[10:25:55.655]     }
[10:25:55.655]     else {
[10:25:55.655]         if (TRUE) {
[10:25:55.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.655]                 open = "w")
[10:25:55.655]         }
[10:25:55.655]         else {
[10:25:55.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.655]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.655]         }
[10:25:55.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.655]             base::sink(type = "output", split = FALSE)
[10:25:55.655]             base::close(...future.stdout)
[10:25:55.655]         }, add = TRUE)
[10:25:55.655]     }
[10:25:55.655]     ...future.frame <- base::sys.nframe()
[10:25:55.655]     ...future.conditions <- base::list()
[10:25:55.655]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.655]     if (FALSE) {
[10:25:55.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.655]     }
[10:25:55.655]     ...future.result <- base::tryCatch({
[10:25:55.655]         base::withCallingHandlers({
[10:25:55.655]             ...future.value <- base::withVisible(base::local({
[10:25:55.655]                 ...future.makeSendCondition <- base::local({
[10:25:55.655]                   sendCondition <- NULL
[10:25:55.655]                   function(frame = 1L) {
[10:25:55.655]                     if (is.function(sendCondition)) 
[10:25:55.655]                       return(sendCondition)
[10:25:55.655]                     ns <- getNamespace("parallel")
[10:25:55.655]                     if (exists("sendData", mode = "function", 
[10:25:55.655]                       envir = ns)) {
[10:25:55.655]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.655]                         envir = ns)
[10:25:55.655]                       envir <- sys.frame(frame)
[10:25:55.655]                       master <- NULL
[10:25:55.655]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.655]                         !identical(envir, emptyenv())) {
[10:25:55.655]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.655]                           inherits = FALSE)) {
[10:25:55.655]                           master <- get("master", mode = "list", 
[10:25:55.655]                             envir = envir, inherits = FALSE)
[10:25:55.655]                           if (inherits(master, c("SOCKnode", 
[10:25:55.655]                             "SOCK0node"))) {
[10:25:55.655]                             sendCondition <<- function(cond) {
[10:25:55.655]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.655]                                 success = TRUE)
[10:25:55.655]                               parallel_sendData(master, data)
[10:25:55.655]                             }
[10:25:55.655]                             return(sendCondition)
[10:25:55.655]                           }
[10:25:55.655]                         }
[10:25:55.655]                         frame <- frame + 1L
[10:25:55.655]                         envir <- sys.frame(frame)
[10:25:55.655]                       }
[10:25:55.655]                     }
[10:25:55.655]                     sendCondition <<- function(cond) NULL
[10:25:55.655]                   }
[10:25:55.655]                 })
[10:25:55.655]                 withCallingHandlers({
[10:25:55.655]                   {
[10:25:55.655]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:25:55.655]                   }
[10:25:55.655]                 }, immediateCondition = function(cond) {
[10:25:55.655]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.655]                   sendCondition(cond)
[10:25:55.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.655]                   {
[10:25:55.655]                     inherits <- base::inherits
[10:25:55.655]                     invokeRestart <- base::invokeRestart
[10:25:55.655]                     is.null <- base::is.null
[10:25:55.655]                     muffled <- FALSE
[10:25:55.655]                     if (inherits(cond, "message")) {
[10:25:55.655]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.655]                       if (muffled) 
[10:25:55.655]                         invokeRestart("muffleMessage")
[10:25:55.655]                     }
[10:25:55.655]                     else if (inherits(cond, "warning")) {
[10:25:55.655]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.655]                       if (muffled) 
[10:25:55.655]                         invokeRestart("muffleWarning")
[10:25:55.655]                     }
[10:25:55.655]                     else if (inherits(cond, "condition")) {
[10:25:55.655]                       if (!is.null(pattern)) {
[10:25:55.655]                         computeRestarts <- base::computeRestarts
[10:25:55.655]                         grepl <- base::grepl
[10:25:55.655]                         restarts <- computeRestarts(cond)
[10:25:55.655]                         for (restart in restarts) {
[10:25:55.655]                           name <- restart$name
[10:25:55.655]                           if (is.null(name)) 
[10:25:55.655]                             next
[10:25:55.655]                           if (!grepl(pattern, name)) 
[10:25:55.655]                             next
[10:25:55.655]                           invokeRestart(restart)
[10:25:55.655]                           muffled <- TRUE
[10:25:55.655]                           break
[10:25:55.655]                         }
[10:25:55.655]                       }
[10:25:55.655]                     }
[10:25:55.655]                     invisible(muffled)
[10:25:55.655]                   }
[10:25:55.655]                   muffleCondition(cond)
[10:25:55.655]                 })
[10:25:55.655]             }))
[10:25:55.655]             future::FutureResult(value = ...future.value$value, 
[10:25:55.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.655]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.655]                     ...future.globalenv.names))
[10:25:55.655]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.655]         }, condition = base::local({
[10:25:55.655]             c <- base::c
[10:25:55.655]             inherits <- base::inherits
[10:25:55.655]             invokeRestart <- base::invokeRestart
[10:25:55.655]             length <- base::length
[10:25:55.655]             list <- base::list
[10:25:55.655]             seq.int <- base::seq.int
[10:25:55.655]             signalCondition <- base::signalCondition
[10:25:55.655]             sys.calls <- base::sys.calls
[10:25:55.655]             `[[` <- base::`[[`
[10:25:55.655]             `+` <- base::`+`
[10:25:55.655]             `<<-` <- base::`<<-`
[10:25:55.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.655]                   3L)]
[10:25:55.655]             }
[10:25:55.655]             function(cond) {
[10:25:55.655]                 is_error <- inherits(cond, "error")
[10:25:55.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.655]                   NULL)
[10:25:55.655]                 if (is_error) {
[10:25:55.655]                   sessionInformation <- function() {
[10:25:55.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.655]                       search = base::search(), system = base::Sys.info())
[10:25:55.655]                   }
[10:25:55.655]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.655]                     cond$call), session = sessionInformation(), 
[10:25:55.655]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.655]                   signalCondition(cond)
[10:25:55.655]                 }
[10:25:55.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.655]                 "immediateCondition"))) {
[10:25:55.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.655]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.655]                   if (TRUE && !signal) {
[10:25:55.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.655]                     {
[10:25:55.655]                       inherits <- base::inherits
[10:25:55.655]                       invokeRestart <- base::invokeRestart
[10:25:55.655]                       is.null <- base::is.null
[10:25:55.655]                       muffled <- FALSE
[10:25:55.655]                       if (inherits(cond, "message")) {
[10:25:55.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.655]                         if (muffled) 
[10:25:55.655]                           invokeRestart("muffleMessage")
[10:25:55.655]                       }
[10:25:55.655]                       else if (inherits(cond, "warning")) {
[10:25:55.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.655]                         if (muffled) 
[10:25:55.655]                           invokeRestart("muffleWarning")
[10:25:55.655]                       }
[10:25:55.655]                       else if (inherits(cond, "condition")) {
[10:25:55.655]                         if (!is.null(pattern)) {
[10:25:55.655]                           computeRestarts <- base::computeRestarts
[10:25:55.655]                           grepl <- base::grepl
[10:25:55.655]                           restarts <- computeRestarts(cond)
[10:25:55.655]                           for (restart in restarts) {
[10:25:55.655]                             name <- restart$name
[10:25:55.655]                             if (is.null(name)) 
[10:25:55.655]                               next
[10:25:55.655]                             if (!grepl(pattern, name)) 
[10:25:55.655]                               next
[10:25:55.655]                             invokeRestart(restart)
[10:25:55.655]                             muffled <- TRUE
[10:25:55.655]                             break
[10:25:55.655]                           }
[10:25:55.655]                         }
[10:25:55.655]                       }
[10:25:55.655]                       invisible(muffled)
[10:25:55.655]                     }
[10:25:55.655]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.655]                   }
[10:25:55.655]                 }
[10:25:55.655]                 else {
[10:25:55.655]                   if (TRUE) {
[10:25:55.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.655]                     {
[10:25:55.655]                       inherits <- base::inherits
[10:25:55.655]                       invokeRestart <- base::invokeRestart
[10:25:55.655]                       is.null <- base::is.null
[10:25:55.655]                       muffled <- FALSE
[10:25:55.655]                       if (inherits(cond, "message")) {
[10:25:55.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.655]                         if (muffled) 
[10:25:55.655]                           invokeRestart("muffleMessage")
[10:25:55.655]                       }
[10:25:55.655]                       else if (inherits(cond, "warning")) {
[10:25:55.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.655]                         if (muffled) 
[10:25:55.655]                           invokeRestart("muffleWarning")
[10:25:55.655]                       }
[10:25:55.655]                       else if (inherits(cond, "condition")) {
[10:25:55.655]                         if (!is.null(pattern)) {
[10:25:55.655]                           computeRestarts <- base::computeRestarts
[10:25:55.655]                           grepl <- base::grepl
[10:25:55.655]                           restarts <- computeRestarts(cond)
[10:25:55.655]                           for (restart in restarts) {
[10:25:55.655]                             name <- restart$name
[10:25:55.655]                             if (is.null(name)) 
[10:25:55.655]                               next
[10:25:55.655]                             if (!grepl(pattern, name)) 
[10:25:55.655]                               next
[10:25:55.655]                             invokeRestart(restart)
[10:25:55.655]                             muffled <- TRUE
[10:25:55.655]                             break
[10:25:55.655]                           }
[10:25:55.655]                         }
[10:25:55.655]                       }
[10:25:55.655]                       invisible(muffled)
[10:25:55.655]                     }
[10:25:55.655]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.655]                   }
[10:25:55.655]                 }
[10:25:55.655]             }
[10:25:55.655]         }))
[10:25:55.655]     }, error = function(ex) {
[10:25:55.655]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.655]                 ...future.rng), started = ...future.startTime, 
[10:25:55.655]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.655]             version = "1.8"), class = "FutureResult")
[10:25:55.655]     }, finally = {
[10:25:55.655]         if (!identical(...future.workdir, getwd())) 
[10:25:55.655]             setwd(...future.workdir)
[10:25:55.655]         {
[10:25:55.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.655]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.655]             }
[10:25:55.655]             base::options(...future.oldOptions)
[10:25:55.655]             if (.Platform$OS.type == "windows") {
[10:25:55.655]                 old_names <- names(...future.oldEnvVars)
[10:25:55.655]                 envs <- base::Sys.getenv()
[10:25:55.655]                 names <- names(envs)
[10:25:55.655]                 common <- intersect(names, old_names)
[10:25:55.655]                 added <- setdiff(names, old_names)
[10:25:55.655]                 removed <- setdiff(old_names, names)
[10:25:55.655]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.655]                   envs[common]]
[10:25:55.655]                 NAMES <- toupper(changed)
[10:25:55.655]                 args <- list()
[10:25:55.655]                 for (kk in seq_along(NAMES)) {
[10:25:55.655]                   name <- changed[[kk]]
[10:25:55.655]                   NAME <- NAMES[[kk]]
[10:25:55.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.655]                     next
[10:25:55.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.655]                 }
[10:25:55.655]                 NAMES <- toupper(added)
[10:25:55.655]                 for (kk in seq_along(NAMES)) {
[10:25:55.655]                   name <- added[[kk]]
[10:25:55.655]                   NAME <- NAMES[[kk]]
[10:25:55.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.655]                     next
[10:25:55.655]                   args[[name]] <- ""
[10:25:55.655]                 }
[10:25:55.655]                 NAMES <- toupper(removed)
[10:25:55.655]                 for (kk in seq_along(NAMES)) {
[10:25:55.655]                   name <- removed[[kk]]
[10:25:55.655]                   NAME <- NAMES[[kk]]
[10:25:55.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.655]                     next
[10:25:55.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.655]                 }
[10:25:55.655]                 if (length(args) > 0) 
[10:25:55.655]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.655]             }
[10:25:55.655]             else {
[10:25:55.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.655]             }
[10:25:55.655]             {
[10:25:55.655]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.655]                   0L) {
[10:25:55.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.655]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.655]                   base::options(opts)
[10:25:55.655]                 }
[10:25:55.655]                 {
[10:25:55.655]                   {
[10:25:55.655]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.655]                     NULL
[10:25:55.655]                   }
[10:25:55.655]                   options(future.plan = NULL)
[10:25:55.655]                   if (is.na(NA_character_)) 
[10:25:55.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.655]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.655]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.655]                     envir = parent.frame()) 
[10:25:55.655]                   {
[10:25:55.655]                     if (is.function(workers)) 
[10:25:55.655]                       workers <- workers()
[10:25:55.655]                     workers <- structure(as.integer(workers), 
[10:25:55.655]                       class = class(workers))
[10:25:55.655]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.655]                       workers >= 1)
[10:25:55.655]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.655]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.655]                     }
[10:25:55.655]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.655]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.655]                       envir = envir)
[10:25:55.655]                     if (!future$lazy) 
[10:25:55.655]                       future <- run(future)
[10:25:55.655]                     invisible(future)
[10:25:55.655]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.655]                 }
[10:25:55.655]             }
[10:25:55.655]         }
[10:25:55.655]     })
[10:25:55.655]     if (TRUE) {
[10:25:55.655]         base::sink(type = "output", split = FALSE)
[10:25:55.655]         if (TRUE) {
[10:25:55.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.655]         }
[10:25:55.655]         else {
[10:25:55.655]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.655]         }
[10:25:55.655]         base::close(...future.stdout)
[10:25:55.655]         ...future.stdout <- NULL
[10:25:55.655]     }
[10:25:55.655]     ...future.result$conditions <- ...future.conditions
[10:25:55.655]     ...future.result$finished <- base::Sys.time()
[10:25:55.655]     ...future.result
[10:25:55.655] }
[10:25:55.658] MultisessionFuture started
[10:25:55.658] - Launch lazy future ... done
[10:25:55.658] run() for ‘MultisessionFuture’ ... done
[10:25:55.658] result() for ClusterFuture ...
[10:25:55.658] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.658] - Validating connection of MultisessionFuture
[10:25:55.709] - received message: FutureResult
[10:25:55.709] - Received FutureResult
[10:25:55.709] - Erased future from FutureRegistry
[10:25:55.709] result() for ClusterFuture ...
[10:25:55.709] - result already collected: FutureResult
[10:25:55.710] result() for ClusterFuture ... done
[10:25:55.710] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.710] result() for ClusterFuture ... done
[10:25:55.710] result() for ClusterFuture ...
[10:25:55.710] - result already collected: FutureResult
[10:25:55.710] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:25:55.713] getGlobalsAndPackages() ...
[10:25:55.713] Searching for globals...
[10:25:55.714] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:25:55.715] Searching for globals ... DONE
[10:25:55.715] Resolving globals: FALSE
[10:25:55.715] 
[10:25:55.715] - packages: [2] ‘stats’, ‘datasets’
[10:25:55.715] getGlobalsAndPackages() ... DONE
[10:25:55.716] run() for ‘Future’ ...
[10:25:55.716] - state: ‘created’
[10:25:55.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.729] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.730]   - Field: ‘node’
[10:25:55.730]   - Field: ‘label’
[10:25:55.730]   - Field: ‘local’
[10:25:55.730]   - Field: ‘owner’
[10:25:55.730]   - Field: ‘envir’
[10:25:55.730]   - Field: ‘workers’
[10:25:55.730]   - Field: ‘packages’
[10:25:55.730]   - Field: ‘gc’
[10:25:55.730]   - Field: ‘conditions’
[10:25:55.731]   - Field: ‘persistent’
[10:25:55.731]   - Field: ‘expr’
[10:25:55.731]   - Field: ‘uuid’
[10:25:55.731]   - Field: ‘seed’
[10:25:55.731]   - Field: ‘version’
[10:25:55.731]   - Field: ‘result’
[10:25:55.731]   - Field: ‘asynchronous’
[10:25:55.731]   - Field: ‘calls’
[10:25:55.731]   - Field: ‘globals’
[10:25:55.731]   - Field: ‘stdout’
[10:25:55.731]   - Field: ‘earlySignal’
[10:25:55.732]   - Field: ‘lazy’
[10:25:55.732]   - Field: ‘state’
[10:25:55.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.732] - Launch lazy future ...
[10:25:55.732] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:25:55.732] Packages needed by future strategies (n = 0): <none>
[10:25:55.733] {
[10:25:55.733]     {
[10:25:55.733]         {
[10:25:55.733]             ...future.startTime <- base::Sys.time()
[10:25:55.733]             {
[10:25:55.733]                 {
[10:25:55.733]                   {
[10:25:55.733]                     {
[10:25:55.733]                       {
[10:25:55.733]                         base::local({
[10:25:55.733]                           has_future <- base::requireNamespace("future", 
[10:25:55.733]                             quietly = TRUE)
[10:25:55.733]                           if (has_future) {
[10:25:55.733]                             ns <- base::getNamespace("future")
[10:25:55.733]                             version <- ns[[".package"]][["version"]]
[10:25:55.733]                             if (is.null(version)) 
[10:25:55.733]                               version <- utils::packageVersion("future")
[10:25:55.733]                           }
[10:25:55.733]                           else {
[10:25:55.733]                             version <- NULL
[10:25:55.733]                           }
[10:25:55.733]                           if (!has_future || version < "1.8.0") {
[10:25:55.733]                             info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.733]                               "", base::R.version$version.string), 
[10:25:55.733]                               platform = base::sprintf("%s (%s-bit)", 
[10:25:55.733]                                 base::R.version$platform, 8 * 
[10:25:55.733]                                   base::.Machine$sizeof.pointer), 
[10:25:55.733]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.733]                                 "release", "version")], collapse = " "), 
[10:25:55.733]                               hostname = base::Sys.info()[["nodename"]])
[10:25:55.733]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.733]                               info)
[10:25:55.733]                             info <- base::paste(info, collapse = "; ")
[10:25:55.733]                             if (!has_future) {
[10:25:55.733]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.733]                                 info)
[10:25:55.733]                             }
[10:25:55.733]                             else {
[10:25:55.733]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.733]                                 info, version)
[10:25:55.733]                             }
[10:25:55.733]                             base::stop(msg)
[10:25:55.733]                           }
[10:25:55.733]                         })
[10:25:55.733]                       }
[10:25:55.733]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.733]                       base::options(mc.cores = 1L)
[10:25:55.733]                     }
[10:25:55.733]                     base::local({
[10:25:55.733]                       for (pkg in c("stats", "datasets")) {
[10:25:55.733]                         base::loadNamespace(pkg)
[10:25:55.733]                         base::library(pkg, character.only = TRUE)
[10:25:55.733]                       }
[10:25:55.733]                     })
[10:25:55.733]                   }
[10:25:55.733]                   options(future.plan = NULL)
[10:25:55.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.733]                 }
[10:25:55.733]                 ...future.workdir <- getwd()
[10:25:55.733]             }
[10:25:55.733]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.733]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.733]         }
[10:25:55.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.733]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.733]             base::names(...future.oldOptions))
[10:25:55.733]     }
[10:25:55.733]     if (FALSE) {
[10:25:55.733]     }
[10:25:55.733]     else {
[10:25:55.733]         if (TRUE) {
[10:25:55.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.733]                 open = "w")
[10:25:55.733]         }
[10:25:55.733]         else {
[10:25:55.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.733]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.733]         }
[10:25:55.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.733]             base::sink(type = "output", split = FALSE)
[10:25:55.733]             base::close(...future.stdout)
[10:25:55.733]         }, add = TRUE)
[10:25:55.733]     }
[10:25:55.733]     ...future.frame <- base::sys.nframe()
[10:25:55.733]     ...future.conditions <- base::list()
[10:25:55.733]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.733]     if (FALSE) {
[10:25:55.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.733]     }
[10:25:55.733]     ...future.result <- base::tryCatch({
[10:25:55.733]         base::withCallingHandlers({
[10:25:55.733]             ...future.value <- base::withVisible(base::local({
[10:25:55.733]                 ...future.makeSendCondition <- base::local({
[10:25:55.733]                   sendCondition <- NULL
[10:25:55.733]                   function(frame = 1L) {
[10:25:55.733]                     if (is.function(sendCondition)) 
[10:25:55.733]                       return(sendCondition)
[10:25:55.733]                     ns <- getNamespace("parallel")
[10:25:55.733]                     if (exists("sendData", mode = "function", 
[10:25:55.733]                       envir = ns)) {
[10:25:55.733]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.733]                         envir = ns)
[10:25:55.733]                       envir <- sys.frame(frame)
[10:25:55.733]                       master <- NULL
[10:25:55.733]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.733]                         !identical(envir, emptyenv())) {
[10:25:55.733]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.733]                           inherits = FALSE)) {
[10:25:55.733]                           master <- get("master", mode = "list", 
[10:25:55.733]                             envir = envir, inherits = FALSE)
[10:25:55.733]                           if (inherits(master, c("SOCKnode", 
[10:25:55.733]                             "SOCK0node"))) {
[10:25:55.733]                             sendCondition <<- function(cond) {
[10:25:55.733]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.733]                                 success = TRUE)
[10:25:55.733]                               parallel_sendData(master, data)
[10:25:55.733]                             }
[10:25:55.733]                             return(sendCondition)
[10:25:55.733]                           }
[10:25:55.733]                         }
[10:25:55.733]                         frame <- frame + 1L
[10:25:55.733]                         envir <- sys.frame(frame)
[10:25:55.733]                       }
[10:25:55.733]                     }
[10:25:55.733]                     sendCondition <<- function(cond) NULL
[10:25:55.733]                   }
[10:25:55.733]                 })
[10:25:55.733]                 withCallingHandlers({
[10:25:55.733]                   {
[10:25:55.733]                     lm(dist ~ poly(speed, 2), data = cars)
[10:25:55.733]                   }
[10:25:55.733]                 }, immediateCondition = function(cond) {
[10:25:55.733]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.733]                   sendCondition(cond)
[10:25:55.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.733]                   {
[10:25:55.733]                     inherits <- base::inherits
[10:25:55.733]                     invokeRestart <- base::invokeRestart
[10:25:55.733]                     is.null <- base::is.null
[10:25:55.733]                     muffled <- FALSE
[10:25:55.733]                     if (inherits(cond, "message")) {
[10:25:55.733]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.733]                       if (muffled) 
[10:25:55.733]                         invokeRestart("muffleMessage")
[10:25:55.733]                     }
[10:25:55.733]                     else if (inherits(cond, "warning")) {
[10:25:55.733]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.733]                       if (muffled) 
[10:25:55.733]                         invokeRestart("muffleWarning")
[10:25:55.733]                     }
[10:25:55.733]                     else if (inherits(cond, "condition")) {
[10:25:55.733]                       if (!is.null(pattern)) {
[10:25:55.733]                         computeRestarts <- base::computeRestarts
[10:25:55.733]                         grepl <- base::grepl
[10:25:55.733]                         restarts <- computeRestarts(cond)
[10:25:55.733]                         for (restart in restarts) {
[10:25:55.733]                           name <- restart$name
[10:25:55.733]                           if (is.null(name)) 
[10:25:55.733]                             next
[10:25:55.733]                           if (!grepl(pattern, name)) 
[10:25:55.733]                             next
[10:25:55.733]                           invokeRestart(restart)
[10:25:55.733]                           muffled <- TRUE
[10:25:55.733]                           break
[10:25:55.733]                         }
[10:25:55.733]                       }
[10:25:55.733]                     }
[10:25:55.733]                     invisible(muffled)
[10:25:55.733]                   }
[10:25:55.733]                   muffleCondition(cond)
[10:25:55.733]                 })
[10:25:55.733]             }))
[10:25:55.733]             future::FutureResult(value = ...future.value$value, 
[10:25:55.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.733]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.733]                     ...future.globalenv.names))
[10:25:55.733]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.733]         }, condition = base::local({
[10:25:55.733]             c <- base::c
[10:25:55.733]             inherits <- base::inherits
[10:25:55.733]             invokeRestart <- base::invokeRestart
[10:25:55.733]             length <- base::length
[10:25:55.733]             list <- base::list
[10:25:55.733]             seq.int <- base::seq.int
[10:25:55.733]             signalCondition <- base::signalCondition
[10:25:55.733]             sys.calls <- base::sys.calls
[10:25:55.733]             `[[` <- base::`[[`
[10:25:55.733]             `+` <- base::`+`
[10:25:55.733]             `<<-` <- base::`<<-`
[10:25:55.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.733]                   3L)]
[10:25:55.733]             }
[10:25:55.733]             function(cond) {
[10:25:55.733]                 is_error <- inherits(cond, "error")
[10:25:55.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.733]                   NULL)
[10:25:55.733]                 if (is_error) {
[10:25:55.733]                   sessionInformation <- function() {
[10:25:55.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.733]                       search = base::search(), system = base::Sys.info())
[10:25:55.733]                   }
[10:25:55.733]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.733]                     cond$call), session = sessionInformation(), 
[10:25:55.733]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.733]                   signalCondition(cond)
[10:25:55.733]                 }
[10:25:55.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.733]                 "immediateCondition"))) {
[10:25:55.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.733]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.733]                   if (TRUE && !signal) {
[10:25:55.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.733]                     {
[10:25:55.733]                       inherits <- base::inherits
[10:25:55.733]                       invokeRestart <- base::invokeRestart
[10:25:55.733]                       is.null <- base::is.null
[10:25:55.733]                       muffled <- FALSE
[10:25:55.733]                       if (inherits(cond, "message")) {
[10:25:55.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.733]                         if (muffled) 
[10:25:55.733]                           invokeRestart("muffleMessage")
[10:25:55.733]                       }
[10:25:55.733]                       else if (inherits(cond, "warning")) {
[10:25:55.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.733]                         if (muffled) 
[10:25:55.733]                           invokeRestart("muffleWarning")
[10:25:55.733]                       }
[10:25:55.733]                       else if (inherits(cond, "condition")) {
[10:25:55.733]                         if (!is.null(pattern)) {
[10:25:55.733]                           computeRestarts <- base::computeRestarts
[10:25:55.733]                           grepl <- base::grepl
[10:25:55.733]                           restarts <- computeRestarts(cond)
[10:25:55.733]                           for (restart in restarts) {
[10:25:55.733]                             name <- restart$name
[10:25:55.733]                             if (is.null(name)) 
[10:25:55.733]                               next
[10:25:55.733]                             if (!grepl(pattern, name)) 
[10:25:55.733]                               next
[10:25:55.733]                             invokeRestart(restart)
[10:25:55.733]                             muffled <- TRUE
[10:25:55.733]                             break
[10:25:55.733]                           }
[10:25:55.733]                         }
[10:25:55.733]                       }
[10:25:55.733]                       invisible(muffled)
[10:25:55.733]                     }
[10:25:55.733]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.733]                   }
[10:25:55.733]                 }
[10:25:55.733]                 else {
[10:25:55.733]                   if (TRUE) {
[10:25:55.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.733]                     {
[10:25:55.733]                       inherits <- base::inherits
[10:25:55.733]                       invokeRestart <- base::invokeRestart
[10:25:55.733]                       is.null <- base::is.null
[10:25:55.733]                       muffled <- FALSE
[10:25:55.733]                       if (inherits(cond, "message")) {
[10:25:55.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.733]                         if (muffled) 
[10:25:55.733]                           invokeRestart("muffleMessage")
[10:25:55.733]                       }
[10:25:55.733]                       else if (inherits(cond, "warning")) {
[10:25:55.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.733]                         if (muffled) 
[10:25:55.733]                           invokeRestart("muffleWarning")
[10:25:55.733]                       }
[10:25:55.733]                       else if (inherits(cond, "condition")) {
[10:25:55.733]                         if (!is.null(pattern)) {
[10:25:55.733]                           computeRestarts <- base::computeRestarts
[10:25:55.733]                           grepl <- base::grepl
[10:25:55.733]                           restarts <- computeRestarts(cond)
[10:25:55.733]                           for (restart in restarts) {
[10:25:55.733]                             name <- restart$name
[10:25:55.733]                             if (is.null(name)) 
[10:25:55.733]                               next
[10:25:55.733]                             if (!grepl(pattern, name)) 
[10:25:55.733]                               next
[10:25:55.733]                             invokeRestart(restart)
[10:25:55.733]                             muffled <- TRUE
[10:25:55.733]                             break
[10:25:55.733]                           }
[10:25:55.733]                         }
[10:25:55.733]                       }
[10:25:55.733]                       invisible(muffled)
[10:25:55.733]                     }
[10:25:55.733]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.733]                   }
[10:25:55.733]                 }
[10:25:55.733]             }
[10:25:55.733]         }))
[10:25:55.733]     }, error = function(ex) {
[10:25:55.733]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.733]                 ...future.rng), started = ...future.startTime, 
[10:25:55.733]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.733]             version = "1.8"), class = "FutureResult")
[10:25:55.733]     }, finally = {
[10:25:55.733]         if (!identical(...future.workdir, getwd())) 
[10:25:55.733]             setwd(...future.workdir)
[10:25:55.733]         {
[10:25:55.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.733]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.733]             }
[10:25:55.733]             base::options(...future.oldOptions)
[10:25:55.733]             if (.Platform$OS.type == "windows") {
[10:25:55.733]                 old_names <- names(...future.oldEnvVars)
[10:25:55.733]                 envs <- base::Sys.getenv()
[10:25:55.733]                 names <- names(envs)
[10:25:55.733]                 common <- intersect(names, old_names)
[10:25:55.733]                 added <- setdiff(names, old_names)
[10:25:55.733]                 removed <- setdiff(old_names, names)
[10:25:55.733]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.733]                   envs[common]]
[10:25:55.733]                 NAMES <- toupper(changed)
[10:25:55.733]                 args <- list()
[10:25:55.733]                 for (kk in seq_along(NAMES)) {
[10:25:55.733]                   name <- changed[[kk]]
[10:25:55.733]                   NAME <- NAMES[[kk]]
[10:25:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.733]                     next
[10:25:55.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.733]                 }
[10:25:55.733]                 NAMES <- toupper(added)
[10:25:55.733]                 for (kk in seq_along(NAMES)) {
[10:25:55.733]                   name <- added[[kk]]
[10:25:55.733]                   NAME <- NAMES[[kk]]
[10:25:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.733]                     next
[10:25:55.733]                   args[[name]] <- ""
[10:25:55.733]                 }
[10:25:55.733]                 NAMES <- toupper(removed)
[10:25:55.733]                 for (kk in seq_along(NAMES)) {
[10:25:55.733]                   name <- removed[[kk]]
[10:25:55.733]                   NAME <- NAMES[[kk]]
[10:25:55.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.733]                     next
[10:25:55.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.733]                 }
[10:25:55.733]                 if (length(args) > 0) 
[10:25:55.733]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.733]             }
[10:25:55.733]             else {
[10:25:55.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.733]             }
[10:25:55.733]             {
[10:25:55.733]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.733]                   0L) {
[10:25:55.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.733]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.733]                   base::options(opts)
[10:25:55.733]                 }
[10:25:55.733]                 {
[10:25:55.733]                   {
[10:25:55.733]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.733]                     NULL
[10:25:55.733]                   }
[10:25:55.733]                   options(future.plan = NULL)
[10:25:55.733]                   if (is.na(NA_character_)) 
[10:25:55.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.733]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.733]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.733]                     envir = parent.frame()) 
[10:25:55.733]                   {
[10:25:55.733]                     if (is.function(workers)) 
[10:25:55.733]                       workers <- workers()
[10:25:55.733]                     workers <- structure(as.integer(workers), 
[10:25:55.733]                       class = class(workers))
[10:25:55.733]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.733]                       workers >= 1)
[10:25:55.733]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.733]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.733]                     }
[10:25:55.733]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.733]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.733]                       envir = envir)
[10:25:55.733]                     if (!future$lazy) 
[10:25:55.733]                       future <- run(future)
[10:25:55.733]                     invisible(future)
[10:25:55.733]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.733]                 }
[10:25:55.733]             }
[10:25:55.733]         }
[10:25:55.733]     })
[10:25:55.733]     if (TRUE) {
[10:25:55.733]         base::sink(type = "output", split = FALSE)
[10:25:55.733]         if (TRUE) {
[10:25:55.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.733]         }
[10:25:55.733]         else {
[10:25:55.733]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.733]         }
[10:25:55.733]         base::close(...future.stdout)
[10:25:55.733]         ...future.stdout <- NULL
[10:25:55.733]     }
[10:25:55.733]     ...future.result$conditions <- ...future.conditions
[10:25:55.733]     ...future.result$finished <- base::Sys.time()
[10:25:55.733]     ...future.result
[10:25:55.733] }
[10:25:55.736] MultisessionFuture started
[10:25:55.736] - Launch lazy future ... done
[10:25:55.736] run() for ‘MultisessionFuture’ ... done
[10:25:55.736] result() for ClusterFuture ...
[10:25:55.736] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.736] - Validating connection of MultisessionFuture
[10:25:55.784] - received message: FutureResult
[10:25:55.784] - Received FutureResult
[10:25:55.784] - Erased future from FutureRegistry
[10:25:55.784] result() for ClusterFuture ...
[10:25:55.784] - result already collected: FutureResult
[10:25:55.784] result() for ClusterFuture ... done
[10:25:55.785] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.785] result() for ClusterFuture ... done
[10:25:55.785] result() for ClusterFuture ...
[10:25:55.785] - result already collected: FutureResult
[10:25:55.785] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:25:55.787] getGlobalsAndPackages() ...
[10:25:55.787] Searching for globals...
[10:25:55.791] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:55.791] Searching for globals ... DONE
[10:25:55.791] Resolving globals: FALSE
[10:25:55.792] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:55.792] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:55.792] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:55.792] 
[10:25:55.792] getGlobalsAndPackages() ... DONE
[10:25:55.793] run() for ‘Future’ ...
[10:25:55.793] - state: ‘created’
[10:25:55.793] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.806] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.807]   - Field: ‘node’
[10:25:55.807]   - Field: ‘label’
[10:25:55.807]   - Field: ‘local’
[10:25:55.807]   - Field: ‘owner’
[10:25:55.807]   - Field: ‘envir’
[10:25:55.807]   - Field: ‘workers’
[10:25:55.807]   - Field: ‘packages’
[10:25:55.807]   - Field: ‘gc’
[10:25:55.807]   - Field: ‘conditions’
[10:25:55.809]   - Field: ‘persistent’
[10:25:55.810]   - Field: ‘expr’
[10:25:55.810]   - Field: ‘uuid’
[10:25:55.810]   - Field: ‘seed’
[10:25:55.810]   - Field: ‘version’
[10:25:55.810]   - Field: ‘result’
[10:25:55.810]   - Field: ‘asynchronous’
[10:25:55.810]   - Field: ‘calls’
[10:25:55.810]   - Field: ‘globals’
[10:25:55.810]   - Field: ‘stdout’
[10:25:55.810]   - Field: ‘earlySignal’
[10:25:55.810]   - Field: ‘lazy’
[10:25:55.811]   - Field: ‘state’
[10:25:55.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.811] - Launch lazy future ...
[10:25:55.811] Packages needed by the future expression (n = 0): <none>
[10:25:55.811] Packages needed by future strategies (n = 0): <none>
[10:25:55.811] {
[10:25:55.811]     {
[10:25:55.811]         {
[10:25:55.811]             ...future.startTime <- base::Sys.time()
[10:25:55.811]             {
[10:25:55.811]                 {
[10:25:55.811]                   {
[10:25:55.811]                     {
[10:25:55.811]                       base::local({
[10:25:55.811]                         has_future <- base::requireNamespace("future", 
[10:25:55.811]                           quietly = TRUE)
[10:25:55.811]                         if (has_future) {
[10:25:55.811]                           ns <- base::getNamespace("future")
[10:25:55.811]                           version <- ns[[".package"]][["version"]]
[10:25:55.811]                           if (is.null(version)) 
[10:25:55.811]                             version <- utils::packageVersion("future")
[10:25:55.811]                         }
[10:25:55.811]                         else {
[10:25:55.811]                           version <- NULL
[10:25:55.811]                         }
[10:25:55.811]                         if (!has_future || version < "1.8.0") {
[10:25:55.811]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.811]                             "", base::R.version$version.string), 
[10:25:55.811]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:55.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:55.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.811]                               "release", "version")], collapse = " "), 
[10:25:55.811]                             hostname = base::Sys.info()[["nodename"]])
[10:25:55.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.811]                             info)
[10:25:55.811]                           info <- base::paste(info, collapse = "; ")
[10:25:55.811]                           if (!has_future) {
[10:25:55.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.811]                               info)
[10:25:55.811]                           }
[10:25:55.811]                           else {
[10:25:55.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.811]                               info, version)
[10:25:55.811]                           }
[10:25:55.811]                           base::stop(msg)
[10:25:55.811]                         }
[10:25:55.811]                       })
[10:25:55.811]                     }
[10:25:55.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.811]                     base::options(mc.cores = 1L)
[10:25:55.811]                   }
[10:25:55.811]                   options(future.plan = NULL)
[10:25:55.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.811]                 }
[10:25:55.811]                 ...future.workdir <- getwd()
[10:25:55.811]             }
[10:25:55.811]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.811]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.811]         }
[10:25:55.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.811]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.811]             base::names(...future.oldOptions))
[10:25:55.811]     }
[10:25:55.811]     if (FALSE) {
[10:25:55.811]     }
[10:25:55.811]     else {
[10:25:55.811]         if (TRUE) {
[10:25:55.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.811]                 open = "w")
[10:25:55.811]         }
[10:25:55.811]         else {
[10:25:55.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.811]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.811]         }
[10:25:55.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.811]             base::sink(type = "output", split = FALSE)
[10:25:55.811]             base::close(...future.stdout)
[10:25:55.811]         }, add = TRUE)
[10:25:55.811]     }
[10:25:55.811]     ...future.frame <- base::sys.nframe()
[10:25:55.811]     ...future.conditions <- base::list()
[10:25:55.811]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.811]     if (FALSE) {
[10:25:55.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.811]     }
[10:25:55.811]     ...future.result <- base::tryCatch({
[10:25:55.811]         base::withCallingHandlers({
[10:25:55.811]             ...future.value <- base::withVisible(base::local({
[10:25:55.811]                 ...future.makeSendCondition <- base::local({
[10:25:55.811]                   sendCondition <- NULL
[10:25:55.811]                   function(frame = 1L) {
[10:25:55.811]                     if (is.function(sendCondition)) 
[10:25:55.811]                       return(sendCondition)
[10:25:55.811]                     ns <- getNamespace("parallel")
[10:25:55.811]                     if (exists("sendData", mode = "function", 
[10:25:55.811]                       envir = ns)) {
[10:25:55.811]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.811]                         envir = ns)
[10:25:55.811]                       envir <- sys.frame(frame)
[10:25:55.811]                       master <- NULL
[10:25:55.811]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.811]                         !identical(envir, emptyenv())) {
[10:25:55.811]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.811]                           inherits = FALSE)) {
[10:25:55.811]                           master <- get("master", mode = "list", 
[10:25:55.811]                             envir = envir, inherits = FALSE)
[10:25:55.811]                           if (inherits(master, c("SOCKnode", 
[10:25:55.811]                             "SOCK0node"))) {
[10:25:55.811]                             sendCondition <<- function(cond) {
[10:25:55.811]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.811]                                 success = TRUE)
[10:25:55.811]                               parallel_sendData(master, data)
[10:25:55.811]                             }
[10:25:55.811]                             return(sendCondition)
[10:25:55.811]                           }
[10:25:55.811]                         }
[10:25:55.811]                         frame <- frame + 1L
[10:25:55.811]                         envir <- sys.frame(frame)
[10:25:55.811]                       }
[10:25:55.811]                     }
[10:25:55.811]                     sendCondition <<- function(cond) NULL
[10:25:55.811]                   }
[10:25:55.811]                 })
[10:25:55.811]                 withCallingHandlers({
[10:25:55.811]                   {
[10:25:55.811]                     outer_function(1L)
[10:25:55.811]                   }
[10:25:55.811]                 }, immediateCondition = function(cond) {
[10:25:55.811]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.811]                   sendCondition(cond)
[10:25:55.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.811]                   {
[10:25:55.811]                     inherits <- base::inherits
[10:25:55.811]                     invokeRestart <- base::invokeRestart
[10:25:55.811]                     is.null <- base::is.null
[10:25:55.811]                     muffled <- FALSE
[10:25:55.811]                     if (inherits(cond, "message")) {
[10:25:55.811]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.811]                       if (muffled) 
[10:25:55.811]                         invokeRestart("muffleMessage")
[10:25:55.811]                     }
[10:25:55.811]                     else if (inherits(cond, "warning")) {
[10:25:55.811]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.811]                       if (muffled) 
[10:25:55.811]                         invokeRestart("muffleWarning")
[10:25:55.811]                     }
[10:25:55.811]                     else if (inherits(cond, "condition")) {
[10:25:55.811]                       if (!is.null(pattern)) {
[10:25:55.811]                         computeRestarts <- base::computeRestarts
[10:25:55.811]                         grepl <- base::grepl
[10:25:55.811]                         restarts <- computeRestarts(cond)
[10:25:55.811]                         for (restart in restarts) {
[10:25:55.811]                           name <- restart$name
[10:25:55.811]                           if (is.null(name)) 
[10:25:55.811]                             next
[10:25:55.811]                           if (!grepl(pattern, name)) 
[10:25:55.811]                             next
[10:25:55.811]                           invokeRestart(restart)
[10:25:55.811]                           muffled <- TRUE
[10:25:55.811]                           break
[10:25:55.811]                         }
[10:25:55.811]                       }
[10:25:55.811]                     }
[10:25:55.811]                     invisible(muffled)
[10:25:55.811]                   }
[10:25:55.811]                   muffleCondition(cond)
[10:25:55.811]                 })
[10:25:55.811]             }))
[10:25:55.811]             future::FutureResult(value = ...future.value$value, 
[10:25:55.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.811]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.811]                     ...future.globalenv.names))
[10:25:55.811]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.811]         }, condition = base::local({
[10:25:55.811]             c <- base::c
[10:25:55.811]             inherits <- base::inherits
[10:25:55.811]             invokeRestart <- base::invokeRestart
[10:25:55.811]             length <- base::length
[10:25:55.811]             list <- base::list
[10:25:55.811]             seq.int <- base::seq.int
[10:25:55.811]             signalCondition <- base::signalCondition
[10:25:55.811]             sys.calls <- base::sys.calls
[10:25:55.811]             `[[` <- base::`[[`
[10:25:55.811]             `+` <- base::`+`
[10:25:55.811]             `<<-` <- base::`<<-`
[10:25:55.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.811]                   3L)]
[10:25:55.811]             }
[10:25:55.811]             function(cond) {
[10:25:55.811]                 is_error <- inherits(cond, "error")
[10:25:55.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.811]                   NULL)
[10:25:55.811]                 if (is_error) {
[10:25:55.811]                   sessionInformation <- function() {
[10:25:55.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.811]                       search = base::search(), system = base::Sys.info())
[10:25:55.811]                   }
[10:25:55.811]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.811]                     cond$call), session = sessionInformation(), 
[10:25:55.811]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.811]                   signalCondition(cond)
[10:25:55.811]                 }
[10:25:55.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.811]                 "immediateCondition"))) {
[10:25:55.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.811]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.811]                   if (TRUE && !signal) {
[10:25:55.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.811]                     {
[10:25:55.811]                       inherits <- base::inherits
[10:25:55.811]                       invokeRestart <- base::invokeRestart
[10:25:55.811]                       is.null <- base::is.null
[10:25:55.811]                       muffled <- FALSE
[10:25:55.811]                       if (inherits(cond, "message")) {
[10:25:55.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.811]                         if (muffled) 
[10:25:55.811]                           invokeRestart("muffleMessage")
[10:25:55.811]                       }
[10:25:55.811]                       else if (inherits(cond, "warning")) {
[10:25:55.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.811]                         if (muffled) 
[10:25:55.811]                           invokeRestart("muffleWarning")
[10:25:55.811]                       }
[10:25:55.811]                       else if (inherits(cond, "condition")) {
[10:25:55.811]                         if (!is.null(pattern)) {
[10:25:55.811]                           computeRestarts <- base::computeRestarts
[10:25:55.811]                           grepl <- base::grepl
[10:25:55.811]                           restarts <- computeRestarts(cond)
[10:25:55.811]                           for (restart in restarts) {
[10:25:55.811]                             name <- restart$name
[10:25:55.811]                             if (is.null(name)) 
[10:25:55.811]                               next
[10:25:55.811]                             if (!grepl(pattern, name)) 
[10:25:55.811]                               next
[10:25:55.811]                             invokeRestart(restart)
[10:25:55.811]                             muffled <- TRUE
[10:25:55.811]                             break
[10:25:55.811]                           }
[10:25:55.811]                         }
[10:25:55.811]                       }
[10:25:55.811]                       invisible(muffled)
[10:25:55.811]                     }
[10:25:55.811]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.811]                   }
[10:25:55.811]                 }
[10:25:55.811]                 else {
[10:25:55.811]                   if (TRUE) {
[10:25:55.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.811]                     {
[10:25:55.811]                       inherits <- base::inherits
[10:25:55.811]                       invokeRestart <- base::invokeRestart
[10:25:55.811]                       is.null <- base::is.null
[10:25:55.811]                       muffled <- FALSE
[10:25:55.811]                       if (inherits(cond, "message")) {
[10:25:55.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.811]                         if (muffled) 
[10:25:55.811]                           invokeRestart("muffleMessage")
[10:25:55.811]                       }
[10:25:55.811]                       else if (inherits(cond, "warning")) {
[10:25:55.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.811]                         if (muffled) 
[10:25:55.811]                           invokeRestart("muffleWarning")
[10:25:55.811]                       }
[10:25:55.811]                       else if (inherits(cond, "condition")) {
[10:25:55.811]                         if (!is.null(pattern)) {
[10:25:55.811]                           computeRestarts <- base::computeRestarts
[10:25:55.811]                           grepl <- base::grepl
[10:25:55.811]                           restarts <- computeRestarts(cond)
[10:25:55.811]                           for (restart in restarts) {
[10:25:55.811]                             name <- restart$name
[10:25:55.811]                             if (is.null(name)) 
[10:25:55.811]                               next
[10:25:55.811]                             if (!grepl(pattern, name)) 
[10:25:55.811]                               next
[10:25:55.811]                             invokeRestart(restart)
[10:25:55.811]                             muffled <- TRUE
[10:25:55.811]                             break
[10:25:55.811]                           }
[10:25:55.811]                         }
[10:25:55.811]                       }
[10:25:55.811]                       invisible(muffled)
[10:25:55.811]                     }
[10:25:55.811]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.811]                   }
[10:25:55.811]                 }
[10:25:55.811]             }
[10:25:55.811]         }))
[10:25:55.811]     }, error = function(ex) {
[10:25:55.811]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.811]                 ...future.rng), started = ...future.startTime, 
[10:25:55.811]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.811]             version = "1.8"), class = "FutureResult")
[10:25:55.811]     }, finally = {
[10:25:55.811]         if (!identical(...future.workdir, getwd())) 
[10:25:55.811]             setwd(...future.workdir)
[10:25:55.811]         {
[10:25:55.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.811]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.811]             }
[10:25:55.811]             base::options(...future.oldOptions)
[10:25:55.811]             if (.Platform$OS.type == "windows") {
[10:25:55.811]                 old_names <- names(...future.oldEnvVars)
[10:25:55.811]                 envs <- base::Sys.getenv()
[10:25:55.811]                 names <- names(envs)
[10:25:55.811]                 common <- intersect(names, old_names)
[10:25:55.811]                 added <- setdiff(names, old_names)
[10:25:55.811]                 removed <- setdiff(old_names, names)
[10:25:55.811]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.811]                   envs[common]]
[10:25:55.811]                 NAMES <- toupper(changed)
[10:25:55.811]                 args <- list()
[10:25:55.811]                 for (kk in seq_along(NAMES)) {
[10:25:55.811]                   name <- changed[[kk]]
[10:25:55.811]                   NAME <- NAMES[[kk]]
[10:25:55.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.811]                     next
[10:25:55.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.811]                 }
[10:25:55.811]                 NAMES <- toupper(added)
[10:25:55.811]                 for (kk in seq_along(NAMES)) {
[10:25:55.811]                   name <- added[[kk]]
[10:25:55.811]                   NAME <- NAMES[[kk]]
[10:25:55.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.811]                     next
[10:25:55.811]                   args[[name]] <- ""
[10:25:55.811]                 }
[10:25:55.811]                 NAMES <- toupper(removed)
[10:25:55.811]                 for (kk in seq_along(NAMES)) {
[10:25:55.811]                   name <- removed[[kk]]
[10:25:55.811]                   NAME <- NAMES[[kk]]
[10:25:55.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.811]                     next
[10:25:55.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.811]                 }
[10:25:55.811]                 if (length(args) > 0) 
[10:25:55.811]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.811]             }
[10:25:55.811]             else {
[10:25:55.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.811]             }
[10:25:55.811]             {
[10:25:55.811]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.811]                   0L) {
[10:25:55.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.811]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.811]                   base::options(opts)
[10:25:55.811]                 }
[10:25:55.811]                 {
[10:25:55.811]                   {
[10:25:55.811]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.811]                     NULL
[10:25:55.811]                   }
[10:25:55.811]                   options(future.plan = NULL)
[10:25:55.811]                   if (is.na(NA_character_)) 
[10:25:55.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.811]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.811]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.811]                     envir = parent.frame()) 
[10:25:55.811]                   {
[10:25:55.811]                     if (is.function(workers)) 
[10:25:55.811]                       workers <- workers()
[10:25:55.811]                     workers <- structure(as.integer(workers), 
[10:25:55.811]                       class = class(workers))
[10:25:55.811]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.811]                       workers >= 1)
[10:25:55.811]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.811]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.811]                     }
[10:25:55.811]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.811]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.811]                       envir = envir)
[10:25:55.811]                     if (!future$lazy) 
[10:25:55.811]                       future <- run(future)
[10:25:55.811]                     invisible(future)
[10:25:55.811]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.811]                 }
[10:25:55.811]             }
[10:25:55.811]         }
[10:25:55.811]     })
[10:25:55.811]     if (TRUE) {
[10:25:55.811]         base::sink(type = "output", split = FALSE)
[10:25:55.811]         if (TRUE) {
[10:25:55.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.811]         }
[10:25:55.811]         else {
[10:25:55.811]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.811]         }
[10:25:55.811]         base::close(...future.stdout)
[10:25:55.811]         ...future.stdout <- NULL
[10:25:55.811]     }
[10:25:55.811]     ...future.result$conditions <- ...future.conditions
[10:25:55.811]     ...future.result$finished <- base::Sys.time()
[10:25:55.811]     ...future.result
[10:25:55.811] }
[10:25:55.814] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[10:25:55.814] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[10:25:55.814] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[10:25:55.815] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[10:25:55.815] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[10:25:55.815] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[10:25:55.815] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[10:25:55.815] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[10:25:55.816] MultisessionFuture started
[10:25:55.816] - Launch lazy future ... done
[10:25:55.816] run() for ‘MultisessionFuture’ ... done
[10:25:55.816] result() for ClusterFuture ...
[10:25:55.816] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.816] - Validating connection of MultisessionFuture
[10:25:55.866] - received message: FutureResult
[10:25:55.866] - Received FutureResult
[10:25:55.867] - Erased future from FutureRegistry
[10:25:55.867] result() for ClusterFuture ...
[10:25:55.867] - result already collected: FutureResult
[10:25:55.867] result() for ClusterFuture ... done
[10:25:55.867] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.867] result() for ClusterFuture ... done
[10:25:55.867] result() for ClusterFuture ...
[10:25:55.867] - result already collected: FutureResult
[10:25:55.867] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:25:55.869] getGlobalsAndPackages() ...
[10:25:55.869] Searching for globals...
[10:25:55.873] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:25:55.873] Searching for globals ... DONE
[10:25:55.873] Resolving globals: FALSE
[10:25:55.874] The total size of the 3 globals is 7.52 KiB (7704 bytes)
[10:25:55.874] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 7.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (4.43 KiB of class ‘function’), ‘inner_function’ (1.78 KiB of class ‘function’) and ‘outer_function’ (1.31 KiB of class ‘function’)
[10:25:55.874] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:25:55.874] 
[10:25:55.874] getGlobalsAndPackages() ... DONE
[10:25:55.874] run() for ‘Future’ ...
[10:25:55.875] - state: ‘created’
[10:25:55.875] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:55.888] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:55.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:55.888]   - Field: ‘node’
[10:25:55.888]   - Field: ‘label’
[10:25:55.889]   - Field: ‘local’
[10:25:55.889]   - Field: ‘owner’
[10:25:55.889]   - Field: ‘envir’
[10:25:55.889]   - Field: ‘workers’
[10:25:55.889]   - Field: ‘packages’
[10:25:55.889]   - Field: ‘gc’
[10:25:55.889]   - Field: ‘conditions’
[10:25:55.889]   - Field: ‘persistent’
[10:25:55.889]   - Field: ‘expr’
[10:25:55.889]   - Field: ‘uuid’
[10:25:55.889]   - Field: ‘seed’
[10:25:55.890]   - Field: ‘version’
[10:25:55.890]   - Field: ‘result’
[10:25:55.890]   - Field: ‘asynchronous’
[10:25:55.890]   - Field: ‘calls’
[10:25:55.890]   - Field: ‘globals’
[10:25:55.890]   - Field: ‘stdout’
[10:25:55.890]   - Field: ‘earlySignal’
[10:25:55.890]   - Field: ‘lazy’
[10:25:55.890]   - Field: ‘state’
[10:25:55.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:55.890] - Launch lazy future ...
[10:25:55.891] Packages needed by the future expression (n = 0): <none>
[10:25:55.891] Packages needed by future strategies (n = 0): <none>
[10:25:55.891] {
[10:25:55.891]     {
[10:25:55.891]         {
[10:25:55.891]             ...future.startTime <- base::Sys.time()
[10:25:55.891]             {
[10:25:55.891]                 {
[10:25:55.891]                   {
[10:25:55.891]                     {
[10:25:55.891]                       base::local({
[10:25:55.891]                         has_future <- base::requireNamespace("future", 
[10:25:55.891]                           quietly = TRUE)
[10:25:55.891]                         if (has_future) {
[10:25:55.891]                           ns <- base::getNamespace("future")
[10:25:55.891]                           version <- ns[[".package"]][["version"]]
[10:25:55.891]                           if (is.null(version)) 
[10:25:55.891]                             version <- utils::packageVersion("future")
[10:25:55.891]                         }
[10:25:55.891]                         else {
[10:25:55.891]                           version <- NULL
[10:25:55.891]                         }
[10:25:55.891]                         if (!has_future || version < "1.8.0") {
[10:25:55.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:55.891]                             "", base::R.version$version.string), 
[10:25:55.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:55.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:55.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:55.891]                               "release", "version")], collapse = " "), 
[10:25:55.891]                             hostname = base::Sys.info()[["nodename"]])
[10:25:55.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:55.891]                             info)
[10:25:55.891]                           info <- base::paste(info, collapse = "; ")
[10:25:55.891]                           if (!has_future) {
[10:25:55.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:55.891]                               info)
[10:25:55.891]                           }
[10:25:55.891]                           else {
[10:25:55.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:55.891]                               info, version)
[10:25:55.891]                           }
[10:25:55.891]                           base::stop(msg)
[10:25:55.891]                         }
[10:25:55.891]                       })
[10:25:55.891]                     }
[10:25:55.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:55.891]                     base::options(mc.cores = 1L)
[10:25:55.891]                   }
[10:25:55.891]                   options(future.plan = NULL)
[10:25:55.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:55.891]                 }
[10:25:55.891]                 ...future.workdir <- getwd()
[10:25:55.891]             }
[10:25:55.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:55.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:55.891]         }
[10:25:55.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:55.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:55.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:55.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:55.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:55.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:55.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:55.891]             base::names(...future.oldOptions))
[10:25:55.891]     }
[10:25:55.891]     if (FALSE) {
[10:25:55.891]     }
[10:25:55.891]     else {
[10:25:55.891]         if (TRUE) {
[10:25:55.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:55.891]                 open = "w")
[10:25:55.891]         }
[10:25:55.891]         else {
[10:25:55.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:55.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:55.891]         }
[10:25:55.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:55.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:55.891]             base::sink(type = "output", split = FALSE)
[10:25:55.891]             base::close(...future.stdout)
[10:25:55.891]         }, add = TRUE)
[10:25:55.891]     }
[10:25:55.891]     ...future.frame <- base::sys.nframe()
[10:25:55.891]     ...future.conditions <- base::list()
[10:25:55.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:55.891]     if (FALSE) {
[10:25:55.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:55.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:55.891]     }
[10:25:55.891]     ...future.result <- base::tryCatch({
[10:25:55.891]         base::withCallingHandlers({
[10:25:55.891]             ...future.value <- base::withVisible(base::local({
[10:25:55.891]                 ...future.makeSendCondition <- base::local({
[10:25:55.891]                   sendCondition <- NULL
[10:25:55.891]                   function(frame = 1L) {
[10:25:55.891]                     if (is.function(sendCondition)) 
[10:25:55.891]                       return(sendCondition)
[10:25:55.891]                     ns <- getNamespace("parallel")
[10:25:55.891]                     if (exists("sendData", mode = "function", 
[10:25:55.891]                       envir = ns)) {
[10:25:55.891]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:55.891]                         envir = ns)
[10:25:55.891]                       envir <- sys.frame(frame)
[10:25:55.891]                       master <- NULL
[10:25:55.891]                       while (!identical(envir, .GlobalEnv) && 
[10:25:55.891]                         !identical(envir, emptyenv())) {
[10:25:55.891]                         if (exists("master", mode = "list", envir = envir, 
[10:25:55.891]                           inherits = FALSE)) {
[10:25:55.891]                           master <- get("master", mode = "list", 
[10:25:55.891]                             envir = envir, inherits = FALSE)
[10:25:55.891]                           if (inherits(master, c("SOCKnode", 
[10:25:55.891]                             "SOCK0node"))) {
[10:25:55.891]                             sendCondition <<- function(cond) {
[10:25:55.891]                               data <- list(type = "VALUE", value = cond, 
[10:25:55.891]                                 success = TRUE)
[10:25:55.891]                               parallel_sendData(master, data)
[10:25:55.891]                             }
[10:25:55.891]                             return(sendCondition)
[10:25:55.891]                           }
[10:25:55.891]                         }
[10:25:55.891]                         frame <- frame + 1L
[10:25:55.891]                         envir <- sys.frame(frame)
[10:25:55.891]                       }
[10:25:55.891]                     }
[10:25:55.891]                     sendCondition <<- function(cond) NULL
[10:25:55.891]                   }
[10:25:55.891]                 })
[10:25:55.891]                 withCallingHandlers({
[10:25:55.891]                   {
[10:25:55.891]                     outer_function(1L)
[10:25:55.891]                   }
[10:25:55.891]                 }, immediateCondition = function(cond) {
[10:25:55.891]                   sendCondition <- ...future.makeSendCondition()
[10:25:55.891]                   sendCondition(cond)
[10:25:55.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.891]                   {
[10:25:55.891]                     inherits <- base::inherits
[10:25:55.891]                     invokeRestart <- base::invokeRestart
[10:25:55.891]                     is.null <- base::is.null
[10:25:55.891]                     muffled <- FALSE
[10:25:55.891]                     if (inherits(cond, "message")) {
[10:25:55.891]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:55.891]                       if (muffled) 
[10:25:55.891]                         invokeRestart("muffleMessage")
[10:25:55.891]                     }
[10:25:55.891]                     else if (inherits(cond, "warning")) {
[10:25:55.891]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:55.891]                       if (muffled) 
[10:25:55.891]                         invokeRestart("muffleWarning")
[10:25:55.891]                     }
[10:25:55.891]                     else if (inherits(cond, "condition")) {
[10:25:55.891]                       if (!is.null(pattern)) {
[10:25:55.891]                         computeRestarts <- base::computeRestarts
[10:25:55.891]                         grepl <- base::grepl
[10:25:55.891]                         restarts <- computeRestarts(cond)
[10:25:55.891]                         for (restart in restarts) {
[10:25:55.891]                           name <- restart$name
[10:25:55.891]                           if (is.null(name)) 
[10:25:55.891]                             next
[10:25:55.891]                           if (!grepl(pattern, name)) 
[10:25:55.891]                             next
[10:25:55.891]                           invokeRestart(restart)
[10:25:55.891]                           muffled <- TRUE
[10:25:55.891]                           break
[10:25:55.891]                         }
[10:25:55.891]                       }
[10:25:55.891]                     }
[10:25:55.891]                     invisible(muffled)
[10:25:55.891]                   }
[10:25:55.891]                   muffleCondition(cond)
[10:25:55.891]                 })
[10:25:55.891]             }))
[10:25:55.891]             future::FutureResult(value = ...future.value$value, 
[10:25:55.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.891]                   ...future.rng), globalenv = if (FALSE) 
[10:25:55.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:55.891]                     ...future.globalenv.names))
[10:25:55.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:55.891]         }, condition = base::local({
[10:25:55.891]             c <- base::c
[10:25:55.891]             inherits <- base::inherits
[10:25:55.891]             invokeRestart <- base::invokeRestart
[10:25:55.891]             length <- base::length
[10:25:55.891]             list <- base::list
[10:25:55.891]             seq.int <- base::seq.int
[10:25:55.891]             signalCondition <- base::signalCondition
[10:25:55.891]             sys.calls <- base::sys.calls
[10:25:55.891]             `[[` <- base::`[[`
[10:25:55.891]             `+` <- base::`+`
[10:25:55.891]             `<<-` <- base::`<<-`
[10:25:55.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:55.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:55.891]                   3L)]
[10:25:55.891]             }
[10:25:55.891]             function(cond) {
[10:25:55.891]                 is_error <- inherits(cond, "error")
[10:25:55.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:55.891]                   NULL)
[10:25:55.891]                 if (is_error) {
[10:25:55.891]                   sessionInformation <- function() {
[10:25:55.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:55.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:55.891]                       search = base::search(), system = base::Sys.info())
[10:25:55.891]                   }
[10:25:55.891]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:55.891]                     cond$call), session = sessionInformation(), 
[10:25:55.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:55.891]                   signalCondition(cond)
[10:25:55.891]                 }
[10:25:55.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:55.891]                 "immediateCondition"))) {
[10:25:55.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:55.891]                   ...future.conditions[[length(...future.conditions) + 
[10:25:55.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:55.891]                   if (TRUE && !signal) {
[10:25:55.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.891]                     {
[10:25:55.891]                       inherits <- base::inherits
[10:25:55.891]                       invokeRestart <- base::invokeRestart
[10:25:55.891]                       is.null <- base::is.null
[10:25:55.891]                       muffled <- FALSE
[10:25:55.891]                       if (inherits(cond, "message")) {
[10:25:55.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.891]                         if (muffled) 
[10:25:55.891]                           invokeRestart("muffleMessage")
[10:25:55.891]                       }
[10:25:55.891]                       else if (inherits(cond, "warning")) {
[10:25:55.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.891]                         if (muffled) 
[10:25:55.891]                           invokeRestart("muffleWarning")
[10:25:55.891]                       }
[10:25:55.891]                       else if (inherits(cond, "condition")) {
[10:25:55.891]                         if (!is.null(pattern)) {
[10:25:55.891]                           computeRestarts <- base::computeRestarts
[10:25:55.891]                           grepl <- base::grepl
[10:25:55.891]                           restarts <- computeRestarts(cond)
[10:25:55.891]                           for (restart in restarts) {
[10:25:55.891]                             name <- restart$name
[10:25:55.891]                             if (is.null(name)) 
[10:25:55.891]                               next
[10:25:55.891]                             if (!grepl(pattern, name)) 
[10:25:55.891]                               next
[10:25:55.891]                             invokeRestart(restart)
[10:25:55.891]                             muffled <- TRUE
[10:25:55.891]                             break
[10:25:55.891]                           }
[10:25:55.891]                         }
[10:25:55.891]                       }
[10:25:55.891]                       invisible(muffled)
[10:25:55.891]                     }
[10:25:55.891]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.891]                   }
[10:25:55.891]                 }
[10:25:55.891]                 else {
[10:25:55.891]                   if (TRUE) {
[10:25:55.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:55.891]                     {
[10:25:55.891]                       inherits <- base::inherits
[10:25:55.891]                       invokeRestart <- base::invokeRestart
[10:25:55.891]                       is.null <- base::is.null
[10:25:55.891]                       muffled <- FALSE
[10:25:55.891]                       if (inherits(cond, "message")) {
[10:25:55.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:55.891]                         if (muffled) 
[10:25:55.891]                           invokeRestart("muffleMessage")
[10:25:55.891]                       }
[10:25:55.891]                       else if (inherits(cond, "warning")) {
[10:25:55.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:55.891]                         if (muffled) 
[10:25:55.891]                           invokeRestart("muffleWarning")
[10:25:55.891]                       }
[10:25:55.891]                       else if (inherits(cond, "condition")) {
[10:25:55.891]                         if (!is.null(pattern)) {
[10:25:55.891]                           computeRestarts <- base::computeRestarts
[10:25:55.891]                           grepl <- base::grepl
[10:25:55.891]                           restarts <- computeRestarts(cond)
[10:25:55.891]                           for (restart in restarts) {
[10:25:55.891]                             name <- restart$name
[10:25:55.891]                             if (is.null(name)) 
[10:25:55.891]                               next
[10:25:55.891]                             if (!grepl(pattern, name)) 
[10:25:55.891]                               next
[10:25:55.891]                             invokeRestart(restart)
[10:25:55.891]                             muffled <- TRUE
[10:25:55.891]                             break
[10:25:55.891]                           }
[10:25:55.891]                         }
[10:25:55.891]                       }
[10:25:55.891]                       invisible(muffled)
[10:25:55.891]                     }
[10:25:55.891]                     muffleCondition(cond, pattern = "^muffle")
[10:25:55.891]                   }
[10:25:55.891]                 }
[10:25:55.891]             }
[10:25:55.891]         }))
[10:25:55.891]     }, error = function(ex) {
[10:25:55.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:55.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:55.891]                 ...future.rng), started = ...future.startTime, 
[10:25:55.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:55.891]             version = "1.8"), class = "FutureResult")
[10:25:55.891]     }, finally = {
[10:25:55.891]         if (!identical(...future.workdir, getwd())) 
[10:25:55.891]             setwd(...future.workdir)
[10:25:55.891]         {
[10:25:55.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:55.891]                 ...future.oldOptions$nwarnings <- NULL
[10:25:55.891]             }
[10:25:55.891]             base::options(...future.oldOptions)
[10:25:55.891]             if (.Platform$OS.type == "windows") {
[10:25:55.891]                 old_names <- names(...future.oldEnvVars)
[10:25:55.891]                 envs <- base::Sys.getenv()
[10:25:55.891]                 names <- names(envs)
[10:25:55.891]                 common <- intersect(names, old_names)
[10:25:55.891]                 added <- setdiff(names, old_names)
[10:25:55.891]                 removed <- setdiff(old_names, names)
[10:25:55.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:55.891]                   envs[common]]
[10:25:55.891]                 NAMES <- toupper(changed)
[10:25:55.891]                 args <- list()
[10:25:55.891]                 for (kk in seq_along(NAMES)) {
[10:25:55.891]                   name <- changed[[kk]]
[10:25:55.891]                   NAME <- NAMES[[kk]]
[10:25:55.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.891]                     next
[10:25:55.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.891]                 }
[10:25:55.891]                 NAMES <- toupper(added)
[10:25:55.891]                 for (kk in seq_along(NAMES)) {
[10:25:55.891]                   name <- added[[kk]]
[10:25:55.891]                   NAME <- NAMES[[kk]]
[10:25:55.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.891]                     next
[10:25:55.891]                   args[[name]] <- ""
[10:25:55.891]                 }
[10:25:55.891]                 NAMES <- toupper(removed)
[10:25:55.891]                 for (kk in seq_along(NAMES)) {
[10:25:55.891]                   name <- removed[[kk]]
[10:25:55.891]                   NAME <- NAMES[[kk]]
[10:25:55.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:55.891]                     next
[10:25:55.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:55.891]                 }
[10:25:55.891]                 if (length(args) > 0) 
[10:25:55.891]                   base::do.call(base::Sys.setenv, args = args)
[10:25:55.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:55.891]             }
[10:25:55.891]             else {
[10:25:55.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:55.891]             }
[10:25:55.891]             {
[10:25:55.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:55.891]                   0L) {
[10:25:55.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:55.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:55.891]                   base::options(opts)
[10:25:55.891]                 }
[10:25:55.891]                 {
[10:25:55.891]                   {
[10:25:55.891]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:55.891]                     NULL
[10:25:55.891]                   }
[10:25:55.891]                   options(future.plan = NULL)
[10:25:55.891]                   if (is.na(NA_character_)) 
[10:25:55.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:55.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:55.891]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:55.891]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:55.891]                     envir = parent.frame()) 
[10:25:55.891]                   {
[10:25:55.891]                     if (is.function(workers)) 
[10:25:55.891]                       workers <- workers()
[10:25:55.891]                     workers <- structure(as.integer(workers), 
[10:25:55.891]                       class = class(workers))
[10:25:55.891]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:55.891]                       workers >= 1)
[10:25:55.891]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:55.891]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:55.891]                     }
[10:25:55.891]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:55.891]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:55.891]                       envir = envir)
[10:25:55.891]                     if (!future$lazy) 
[10:25:55.891]                       future <- run(future)
[10:25:55.891]                     invisible(future)
[10:25:55.891]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:55.891]                 }
[10:25:55.891]             }
[10:25:55.891]         }
[10:25:55.891]     })
[10:25:55.891]     if (TRUE) {
[10:25:55.891]         base::sink(type = "output", split = FALSE)
[10:25:55.891]         if (TRUE) {
[10:25:55.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:55.891]         }
[10:25:55.891]         else {
[10:25:55.891]             ...future.result["stdout"] <- base::list(NULL)
[10:25:55.891]         }
[10:25:55.891]         base::close(...future.stdout)
[10:25:55.891]         ...future.stdout <- NULL
[10:25:55.891]     }
[10:25:55.891]     ...future.result$conditions <- ...future.conditions
[10:25:55.891]     ...future.result$finished <- base::Sys.time()
[10:25:55.891]     ...future.result
[10:25:55.891] }
[10:25:55.894] Exporting 3 global objects (7.52 KiB) to cluster node #1 ...
[10:25:55.894] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ...
[10:25:55.894] Exporting ‘outer_function’ (1.31 KiB) to cluster node #1 ... DONE
[10:25:55.895] Exporting ‘map’ (4.43 KiB) to cluster node #1 ...
[10:25:55.895] Exporting ‘map’ (4.43 KiB) to cluster node #1 ... DONE
[10:25:55.895] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ...
[10:25:55.895] Exporting ‘inner_function’ (1.78 KiB) to cluster node #1 ... DONE
[10:25:55.895] Exporting 3 global objects (7.52 KiB) to cluster node #1 ... DONE
[10:25:55.896] MultisessionFuture started
[10:25:55.896] - Launch lazy future ... done
[10:25:55.896] run() for ‘MultisessionFuture’ ... done
[10:25:55.896] result() for ClusterFuture ...
[10:25:55.896] receiveMessageFromWorker() for ClusterFuture ...
[10:25:55.896] - Validating connection of MultisessionFuture
[10:25:55.942] - received message: FutureResult
[10:25:55.942] - Received FutureResult
[10:25:55.942] - Erased future from FutureRegistry
[10:25:55.942] result() for ClusterFuture ...
[10:25:55.943] - result already collected: FutureResult
[10:25:55.943] result() for ClusterFuture ... done
[10:25:55.943] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:55.943] result() for ClusterFuture ... done
[10:25:55.943] result() for ClusterFuture ...
[10:25:55.943] - result already collected: FutureResult
[10:25:55.943] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[10:25:55.945] plan(): Setting new future strategy stack:
[10:25:55.945] List of future strategies:
[10:25:55.945] 1. FutureStrategy:
[10:25:55.945]    - args: function (..., envir = parent.frame())
[10:25:55.945]    - tweaked: FALSE
[10:25:55.945]    - call: future::plan(oplan)
[10:25:55.946] plan(): nbrOfWorkers() = 1
> 
