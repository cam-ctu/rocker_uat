
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:22:57.485] plan(): Setting new future strategy stack:
[13:22:57.486] List of future strategies:
[13:22:57.486] 1. sequential:
[13:22:57.486]    - args: function (..., envir = parent.frame())
[13:22:57.486]    - tweaked: FALSE
[13:22:57.486]    - call: future::plan("sequential")
[13:22:57.501] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[13:22:57.513] getGlobalsAndPackages() ...
[13:22:57.513] Searching for globals...
[13:22:57.520] - globals found: [2] ‘{’, ‘cat’
[13:22:57.520] Searching for globals ... DONE
[13:22:57.520] Resolving globals: FALSE
[13:22:57.521] 
[13:22:57.521] 
[13:22:57.521] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[13:22:57.522] run() for ‘Future’ ...
[13:22:57.522] - state: ‘created’
[13:22:57.522] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.523]   - Field: ‘label’
[13:22:57.523]   - Field: ‘local’
[13:22:57.523]   - Field: ‘owner’
[13:22:57.523]   - Field: ‘envir’
[13:22:57.523]   - Field: ‘packages’
[13:22:57.523]   - Field: ‘gc’
[13:22:57.523]   - Field: ‘conditions’
[13:22:57.523]   - Field: ‘expr’
[13:22:57.524]   - Field: ‘uuid’
[13:22:57.524]   - Field: ‘seed’
[13:22:57.524]   - Field: ‘version’
[13:22:57.524]   - Field: ‘result’
[13:22:57.524]   - Field: ‘asynchronous’
[13:22:57.524]   - Field: ‘calls’
[13:22:57.524]   - Field: ‘globals’
[13:22:57.524]   - Field: ‘stdout’
[13:22:57.524]   - Field: ‘earlySignal’
[13:22:57.524]   - Field: ‘lazy’
[13:22:57.525]   - Field: ‘state’
[13:22:57.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.525] - Launch lazy future ...
[13:22:57.526] Packages needed by the future expression (n = 0): <none>
[13:22:57.526] Packages needed by future strategies (n = 0): <none>
[13:22:57.526] {
[13:22:57.526]     {
[13:22:57.526]         {
[13:22:57.526]             ...future.startTime <- base::Sys.time()
[13:22:57.526]             {
[13:22:57.526]                 {
[13:22:57.526]                   {
[13:22:57.526]                     base::local({
[13:22:57.526]                       has_future <- base::requireNamespace("future", 
[13:22:57.526]                         quietly = TRUE)
[13:22:57.526]                       if (has_future) {
[13:22:57.526]                         ns <- base::getNamespace("future")
[13:22:57.526]                         version <- ns[[".package"]][["version"]]
[13:22:57.526]                         if (is.null(version)) 
[13:22:57.526]                           version <- utils::packageVersion("future")
[13:22:57.526]                       }
[13:22:57.526]                       else {
[13:22:57.526]                         version <- NULL
[13:22:57.526]                       }
[13:22:57.526]                       if (!has_future || version < "1.8.0") {
[13:22:57.526]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.526]                           "", base::R.version$version.string), 
[13:22:57.526]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.526]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.526]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.526]                             "release", "version")], collapse = " "), 
[13:22:57.526]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.526]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.526]                           info)
[13:22:57.526]                         info <- base::paste(info, collapse = "; ")
[13:22:57.526]                         if (!has_future) {
[13:22:57.526]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.526]                             info)
[13:22:57.526]                         }
[13:22:57.526]                         else {
[13:22:57.526]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.526]                             info, version)
[13:22:57.526]                         }
[13:22:57.526]                         base::stop(msg)
[13:22:57.526]                       }
[13:22:57.526]                     })
[13:22:57.526]                   }
[13:22:57.526]                   options(future.plan = NULL)
[13:22:57.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.526]                 }
[13:22:57.526]                 ...future.workdir <- getwd()
[13:22:57.526]             }
[13:22:57.526]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.526]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.526]         }
[13:22:57.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.526]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.526]             base::names(...future.oldOptions))
[13:22:57.526]     }
[13:22:57.526]     if (FALSE) {
[13:22:57.526]     }
[13:22:57.526]     else {
[13:22:57.526]         if (TRUE) {
[13:22:57.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.526]                 open = "w")
[13:22:57.526]         }
[13:22:57.526]         else {
[13:22:57.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.526]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.526]         }
[13:22:57.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.526]             base::sink(type = "output", split = FALSE)
[13:22:57.526]             base::close(...future.stdout)
[13:22:57.526]         }, add = TRUE)
[13:22:57.526]     }
[13:22:57.526]     ...future.frame <- base::sys.nframe()
[13:22:57.526]     ...future.conditions <- base::list()
[13:22:57.526]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.526]     if (FALSE) {
[13:22:57.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.526]     }
[13:22:57.526]     ...future.result <- base::tryCatch({
[13:22:57.526]         base::withCallingHandlers({
[13:22:57.526]             ...future.value <- base::withVisible(base::local({
[13:22:57.526]                 cat("Future assignment evaluated\n")
[13:22:57.526]                 2
[13:22:57.526]             }))
[13:22:57.526]             future::FutureResult(value = ...future.value$value, 
[13:22:57.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.526]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.526]                     ...future.globalenv.names))
[13:22:57.526]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.526]         }, condition = base::local({
[13:22:57.526]             c <- base::c
[13:22:57.526]             inherits <- base::inherits
[13:22:57.526]             invokeRestart <- base::invokeRestart
[13:22:57.526]             length <- base::length
[13:22:57.526]             list <- base::list
[13:22:57.526]             seq.int <- base::seq.int
[13:22:57.526]             signalCondition <- base::signalCondition
[13:22:57.526]             sys.calls <- base::sys.calls
[13:22:57.526]             `[[` <- base::`[[`
[13:22:57.526]             `+` <- base::`+`
[13:22:57.526]             `<<-` <- base::`<<-`
[13:22:57.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.526]                   3L)]
[13:22:57.526]             }
[13:22:57.526]             function(cond) {
[13:22:57.526]                 is_error <- inherits(cond, "error")
[13:22:57.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.526]                   NULL)
[13:22:57.526]                 if (is_error) {
[13:22:57.526]                   sessionInformation <- function() {
[13:22:57.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.526]                       search = base::search(), system = base::Sys.info())
[13:22:57.526]                   }
[13:22:57.526]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.526]                     cond$call), session = sessionInformation(), 
[13:22:57.526]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.526]                   signalCondition(cond)
[13:22:57.526]                 }
[13:22:57.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.526]                 "immediateCondition"))) {
[13:22:57.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.526]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.526]                   if (TRUE && !signal) {
[13:22:57.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.526]                     {
[13:22:57.526]                       inherits <- base::inherits
[13:22:57.526]                       invokeRestart <- base::invokeRestart
[13:22:57.526]                       is.null <- base::is.null
[13:22:57.526]                       muffled <- FALSE
[13:22:57.526]                       if (inherits(cond, "message")) {
[13:22:57.526]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.526]                         if (muffled) 
[13:22:57.526]                           invokeRestart("muffleMessage")
[13:22:57.526]                       }
[13:22:57.526]                       else if (inherits(cond, "warning")) {
[13:22:57.526]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.526]                         if (muffled) 
[13:22:57.526]                           invokeRestart("muffleWarning")
[13:22:57.526]                       }
[13:22:57.526]                       else if (inherits(cond, "condition")) {
[13:22:57.526]                         if (!is.null(pattern)) {
[13:22:57.526]                           computeRestarts <- base::computeRestarts
[13:22:57.526]                           grepl <- base::grepl
[13:22:57.526]                           restarts <- computeRestarts(cond)
[13:22:57.526]                           for (restart in restarts) {
[13:22:57.526]                             name <- restart$name
[13:22:57.526]                             if (is.null(name)) 
[13:22:57.526]                               next
[13:22:57.526]                             if (!grepl(pattern, name)) 
[13:22:57.526]                               next
[13:22:57.526]                             invokeRestart(restart)
[13:22:57.526]                             muffled <- TRUE
[13:22:57.526]                             break
[13:22:57.526]                           }
[13:22:57.526]                         }
[13:22:57.526]                       }
[13:22:57.526]                       invisible(muffled)
[13:22:57.526]                     }
[13:22:57.526]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.526]                   }
[13:22:57.526]                 }
[13:22:57.526]                 else {
[13:22:57.526]                   if (TRUE) {
[13:22:57.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.526]                     {
[13:22:57.526]                       inherits <- base::inherits
[13:22:57.526]                       invokeRestart <- base::invokeRestart
[13:22:57.526]                       is.null <- base::is.null
[13:22:57.526]                       muffled <- FALSE
[13:22:57.526]                       if (inherits(cond, "message")) {
[13:22:57.526]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.526]                         if (muffled) 
[13:22:57.526]                           invokeRestart("muffleMessage")
[13:22:57.526]                       }
[13:22:57.526]                       else if (inherits(cond, "warning")) {
[13:22:57.526]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.526]                         if (muffled) 
[13:22:57.526]                           invokeRestart("muffleWarning")
[13:22:57.526]                       }
[13:22:57.526]                       else if (inherits(cond, "condition")) {
[13:22:57.526]                         if (!is.null(pattern)) {
[13:22:57.526]                           computeRestarts <- base::computeRestarts
[13:22:57.526]                           grepl <- base::grepl
[13:22:57.526]                           restarts <- computeRestarts(cond)
[13:22:57.526]                           for (restart in restarts) {
[13:22:57.526]                             name <- restart$name
[13:22:57.526]                             if (is.null(name)) 
[13:22:57.526]                               next
[13:22:57.526]                             if (!grepl(pattern, name)) 
[13:22:57.526]                               next
[13:22:57.526]                             invokeRestart(restart)
[13:22:57.526]                             muffled <- TRUE
[13:22:57.526]                             break
[13:22:57.526]                           }
[13:22:57.526]                         }
[13:22:57.526]                       }
[13:22:57.526]                       invisible(muffled)
[13:22:57.526]                     }
[13:22:57.526]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.526]                   }
[13:22:57.526]                 }
[13:22:57.526]             }
[13:22:57.526]         }))
[13:22:57.526]     }, error = function(ex) {
[13:22:57.526]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.526]                 ...future.rng), started = ...future.startTime, 
[13:22:57.526]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.526]             version = "1.8"), class = "FutureResult")
[13:22:57.526]     }, finally = {
[13:22:57.526]         if (!identical(...future.workdir, getwd())) 
[13:22:57.526]             setwd(...future.workdir)
[13:22:57.526]         {
[13:22:57.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.526]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.526]             }
[13:22:57.526]             base::options(...future.oldOptions)
[13:22:57.526]             if (.Platform$OS.type == "windows") {
[13:22:57.526]                 old_names <- names(...future.oldEnvVars)
[13:22:57.526]                 envs <- base::Sys.getenv()
[13:22:57.526]                 names <- names(envs)
[13:22:57.526]                 common <- intersect(names, old_names)
[13:22:57.526]                 added <- setdiff(names, old_names)
[13:22:57.526]                 removed <- setdiff(old_names, names)
[13:22:57.526]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.526]                   envs[common]]
[13:22:57.526]                 NAMES <- toupper(changed)
[13:22:57.526]                 args <- list()
[13:22:57.526]                 for (kk in seq_along(NAMES)) {
[13:22:57.526]                   name <- changed[[kk]]
[13:22:57.526]                   NAME <- NAMES[[kk]]
[13:22:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.526]                     next
[13:22:57.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.526]                 }
[13:22:57.526]                 NAMES <- toupper(added)
[13:22:57.526]                 for (kk in seq_along(NAMES)) {
[13:22:57.526]                   name <- added[[kk]]
[13:22:57.526]                   NAME <- NAMES[[kk]]
[13:22:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.526]                     next
[13:22:57.526]                   args[[name]] <- ""
[13:22:57.526]                 }
[13:22:57.526]                 NAMES <- toupper(removed)
[13:22:57.526]                 for (kk in seq_along(NAMES)) {
[13:22:57.526]                   name <- removed[[kk]]
[13:22:57.526]                   NAME <- NAMES[[kk]]
[13:22:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.526]                     next
[13:22:57.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.526]                 }
[13:22:57.526]                 if (length(args) > 0) 
[13:22:57.526]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.526]             }
[13:22:57.526]             else {
[13:22:57.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.526]             }
[13:22:57.526]             {
[13:22:57.526]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.526]                   0L) {
[13:22:57.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.526]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.526]                   base::options(opts)
[13:22:57.526]                 }
[13:22:57.526]                 {
[13:22:57.526]                   {
[13:22:57.526]                     NULL
[13:22:57.526]                     RNGkind("Mersenne-Twister")
[13:22:57.526]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.526]                       inherits = FALSE)
[13:22:57.526]                   }
[13:22:57.526]                   options(future.plan = NULL)
[13:22:57.526]                   if (is.na(NA_character_)) 
[13:22:57.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.526]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.526]                   {
[13:22:57.526]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.526]                     if (!future$lazy) 
[13:22:57.526]                       future <- run(future)
[13:22:57.526]                     invisible(future)
[13:22:57.526]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.526]                 }
[13:22:57.526]             }
[13:22:57.526]         }
[13:22:57.526]     })
[13:22:57.526]     if (TRUE) {
[13:22:57.526]         base::sink(type = "output", split = FALSE)
[13:22:57.526]         if (TRUE) {
[13:22:57.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.526]         }
[13:22:57.526]         else {
[13:22:57.526]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.526]         }
[13:22:57.526]         base::close(...future.stdout)
[13:22:57.526]         ...future.stdout <- NULL
[13:22:57.526]     }
[13:22:57.526]     ...future.result$conditions <- ...future.conditions
[13:22:57.526]     ...future.result$finished <- base::Sys.time()
[13:22:57.526]     ...future.result
[13:22:57.526] }
[13:22:57.529] plan(): Setting new future strategy stack:
[13:22:57.529] List of future strategies:
[13:22:57.529] 1. sequential:
[13:22:57.529]    - args: function (..., envir = parent.frame())
[13:22:57.529]    - tweaked: FALSE
[13:22:57.529]    - call: NULL
[13:22:57.529] plan(): nbrOfWorkers() = 1
[13:22:57.530] plan(): Setting new future strategy stack:
[13:22:57.530] List of future strategies:
[13:22:57.530] 1. sequential:
[13:22:57.530]    - args: function (..., envir = parent.frame())
[13:22:57.530]    - tweaked: FALSE
[13:22:57.530]    - call: future::plan("sequential")
[13:22:57.531] plan(): nbrOfWorkers() = 1
[13:22:57.531] SequentialFuture started (and completed)
[13:22:57.531] - Launch lazy future ... done
[13:22:57.532] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[13:22:57.559] plan(): Setting new future strategy stack:
[13:22:57.559] List of future strategies:
[13:22:57.559] 1. sequential:
[13:22:57.559]    - args: function (..., envir = parent.frame())
[13:22:57.559]    - tweaked: FALSE
[13:22:57.559]    - call: plan(strategy)
[13:22:57.572] plan(): nbrOfWorkers() = 1
[13:22:57.572] getGlobalsAndPackages() ...
[13:22:57.572] Searching for globals...
[13:22:57.573] - globals found: [1] ‘{’
[13:22:57.573] Searching for globals ... DONE
[13:22:57.573] Resolving globals: FALSE
[13:22:57.573] 
[13:22:57.573] 
[13:22:57.574] getGlobalsAndPackages() ... DONE
[13:22:57.574] run() for ‘Future’ ...
[13:22:57.574] - state: ‘created’
[13:22:57.574] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.574] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.574] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.575]   - Field: ‘label’
[13:22:57.575]   - Field: ‘local’
[13:22:57.575]   - Field: ‘owner’
[13:22:57.575]   - Field: ‘envir’
[13:22:57.575]   - Field: ‘packages’
[13:22:57.575]   - Field: ‘gc’
[13:22:57.575]   - Field: ‘conditions’
[13:22:57.575]   - Field: ‘expr’
[13:22:57.575]   - Field: ‘uuid’
[13:22:57.575]   - Field: ‘seed’
[13:22:57.576]   - Field: ‘version’
[13:22:57.576]   - Field: ‘result’
[13:22:57.576]   - Field: ‘asynchronous’
[13:22:57.576]   - Field: ‘calls’
[13:22:57.576]   - Field: ‘globals’
[13:22:57.576]   - Field: ‘stdout’
[13:22:57.576]   - Field: ‘earlySignal’
[13:22:57.576]   - Field: ‘lazy’
[13:22:57.576]   - Field: ‘state’
[13:22:57.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.577] - Launch lazy future ...
[13:22:57.577] Packages needed by the future expression (n = 0): <none>
[13:22:57.577] Packages needed by future strategies (n = 0): <none>
[13:22:57.577] {
[13:22:57.577]     {
[13:22:57.577]         {
[13:22:57.577]             ...future.startTime <- base::Sys.time()
[13:22:57.577]             {
[13:22:57.577]                 {
[13:22:57.577]                   {
[13:22:57.577]                     base::local({
[13:22:57.577]                       has_future <- base::requireNamespace("future", 
[13:22:57.577]                         quietly = TRUE)
[13:22:57.577]                       if (has_future) {
[13:22:57.577]                         ns <- base::getNamespace("future")
[13:22:57.577]                         version <- ns[[".package"]][["version"]]
[13:22:57.577]                         if (is.null(version)) 
[13:22:57.577]                           version <- utils::packageVersion("future")
[13:22:57.577]                       }
[13:22:57.577]                       else {
[13:22:57.577]                         version <- NULL
[13:22:57.577]                       }
[13:22:57.577]                       if (!has_future || version < "1.8.0") {
[13:22:57.577]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.577]                           "", base::R.version$version.string), 
[13:22:57.577]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.577]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.577]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.577]                             "release", "version")], collapse = " "), 
[13:22:57.577]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.577]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.577]                           info)
[13:22:57.577]                         info <- base::paste(info, collapse = "; ")
[13:22:57.577]                         if (!has_future) {
[13:22:57.577]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.577]                             info)
[13:22:57.577]                         }
[13:22:57.577]                         else {
[13:22:57.577]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.577]                             info, version)
[13:22:57.577]                         }
[13:22:57.577]                         base::stop(msg)
[13:22:57.577]                       }
[13:22:57.577]                     })
[13:22:57.577]                   }
[13:22:57.577]                   options(future.plan = NULL)
[13:22:57.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.577]                 }
[13:22:57.577]                 ...future.workdir <- getwd()
[13:22:57.577]             }
[13:22:57.577]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.577]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.577]         }
[13:22:57.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.577]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.577]             base::names(...future.oldOptions))
[13:22:57.577]     }
[13:22:57.577]     if (FALSE) {
[13:22:57.577]     }
[13:22:57.577]     else {
[13:22:57.577]         if (TRUE) {
[13:22:57.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.577]                 open = "w")
[13:22:57.577]         }
[13:22:57.577]         else {
[13:22:57.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.577]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.577]         }
[13:22:57.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.577]             base::sink(type = "output", split = FALSE)
[13:22:57.577]             base::close(...future.stdout)
[13:22:57.577]         }, add = TRUE)
[13:22:57.577]     }
[13:22:57.577]     ...future.frame <- base::sys.nframe()
[13:22:57.577]     ...future.conditions <- base::list()
[13:22:57.577]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.577]     if (FALSE) {
[13:22:57.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.577]     }
[13:22:57.577]     ...future.result <- base::tryCatch({
[13:22:57.577]         base::withCallingHandlers({
[13:22:57.577]             ...future.value <- base::withVisible(base::local({
[13:22:57.577]                 2
[13:22:57.577]             }))
[13:22:57.577]             future::FutureResult(value = ...future.value$value, 
[13:22:57.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.577]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.577]                     ...future.globalenv.names))
[13:22:57.577]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.577]         }, condition = base::local({
[13:22:57.577]             c <- base::c
[13:22:57.577]             inherits <- base::inherits
[13:22:57.577]             invokeRestart <- base::invokeRestart
[13:22:57.577]             length <- base::length
[13:22:57.577]             list <- base::list
[13:22:57.577]             seq.int <- base::seq.int
[13:22:57.577]             signalCondition <- base::signalCondition
[13:22:57.577]             sys.calls <- base::sys.calls
[13:22:57.577]             `[[` <- base::`[[`
[13:22:57.577]             `+` <- base::`+`
[13:22:57.577]             `<<-` <- base::`<<-`
[13:22:57.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.577]                   3L)]
[13:22:57.577]             }
[13:22:57.577]             function(cond) {
[13:22:57.577]                 is_error <- inherits(cond, "error")
[13:22:57.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.577]                   NULL)
[13:22:57.577]                 if (is_error) {
[13:22:57.577]                   sessionInformation <- function() {
[13:22:57.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.577]                       search = base::search(), system = base::Sys.info())
[13:22:57.577]                   }
[13:22:57.577]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.577]                     cond$call), session = sessionInformation(), 
[13:22:57.577]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.577]                   signalCondition(cond)
[13:22:57.577]                 }
[13:22:57.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.577]                 "immediateCondition"))) {
[13:22:57.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.577]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.577]                   if (TRUE && !signal) {
[13:22:57.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.577]                     {
[13:22:57.577]                       inherits <- base::inherits
[13:22:57.577]                       invokeRestart <- base::invokeRestart
[13:22:57.577]                       is.null <- base::is.null
[13:22:57.577]                       muffled <- FALSE
[13:22:57.577]                       if (inherits(cond, "message")) {
[13:22:57.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.577]                         if (muffled) 
[13:22:57.577]                           invokeRestart("muffleMessage")
[13:22:57.577]                       }
[13:22:57.577]                       else if (inherits(cond, "warning")) {
[13:22:57.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.577]                         if (muffled) 
[13:22:57.577]                           invokeRestart("muffleWarning")
[13:22:57.577]                       }
[13:22:57.577]                       else if (inherits(cond, "condition")) {
[13:22:57.577]                         if (!is.null(pattern)) {
[13:22:57.577]                           computeRestarts <- base::computeRestarts
[13:22:57.577]                           grepl <- base::grepl
[13:22:57.577]                           restarts <- computeRestarts(cond)
[13:22:57.577]                           for (restart in restarts) {
[13:22:57.577]                             name <- restart$name
[13:22:57.577]                             if (is.null(name)) 
[13:22:57.577]                               next
[13:22:57.577]                             if (!grepl(pattern, name)) 
[13:22:57.577]                               next
[13:22:57.577]                             invokeRestart(restart)
[13:22:57.577]                             muffled <- TRUE
[13:22:57.577]                             break
[13:22:57.577]                           }
[13:22:57.577]                         }
[13:22:57.577]                       }
[13:22:57.577]                       invisible(muffled)
[13:22:57.577]                     }
[13:22:57.577]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.577]                   }
[13:22:57.577]                 }
[13:22:57.577]                 else {
[13:22:57.577]                   if (TRUE) {
[13:22:57.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.577]                     {
[13:22:57.577]                       inherits <- base::inherits
[13:22:57.577]                       invokeRestart <- base::invokeRestart
[13:22:57.577]                       is.null <- base::is.null
[13:22:57.577]                       muffled <- FALSE
[13:22:57.577]                       if (inherits(cond, "message")) {
[13:22:57.577]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.577]                         if (muffled) 
[13:22:57.577]                           invokeRestart("muffleMessage")
[13:22:57.577]                       }
[13:22:57.577]                       else if (inherits(cond, "warning")) {
[13:22:57.577]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.577]                         if (muffled) 
[13:22:57.577]                           invokeRestart("muffleWarning")
[13:22:57.577]                       }
[13:22:57.577]                       else if (inherits(cond, "condition")) {
[13:22:57.577]                         if (!is.null(pattern)) {
[13:22:57.577]                           computeRestarts <- base::computeRestarts
[13:22:57.577]                           grepl <- base::grepl
[13:22:57.577]                           restarts <- computeRestarts(cond)
[13:22:57.577]                           for (restart in restarts) {
[13:22:57.577]                             name <- restart$name
[13:22:57.577]                             if (is.null(name)) 
[13:22:57.577]                               next
[13:22:57.577]                             if (!grepl(pattern, name)) 
[13:22:57.577]                               next
[13:22:57.577]                             invokeRestart(restart)
[13:22:57.577]                             muffled <- TRUE
[13:22:57.577]                             break
[13:22:57.577]                           }
[13:22:57.577]                         }
[13:22:57.577]                       }
[13:22:57.577]                       invisible(muffled)
[13:22:57.577]                     }
[13:22:57.577]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.577]                   }
[13:22:57.577]                 }
[13:22:57.577]             }
[13:22:57.577]         }))
[13:22:57.577]     }, error = function(ex) {
[13:22:57.577]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.577]                 ...future.rng), started = ...future.startTime, 
[13:22:57.577]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.577]             version = "1.8"), class = "FutureResult")
[13:22:57.577]     }, finally = {
[13:22:57.577]         if (!identical(...future.workdir, getwd())) 
[13:22:57.577]             setwd(...future.workdir)
[13:22:57.577]         {
[13:22:57.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.577]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.577]             }
[13:22:57.577]             base::options(...future.oldOptions)
[13:22:57.577]             if (.Platform$OS.type == "windows") {
[13:22:57.577]                 old_names <- names(...future.oldEnvVars)
[13:22:57.577]                 envs <- base::Sys.getenv()
[13:22:57.577]                 names <- names(envs)
[13:22:57.577]                 common <- intersect(names, old_names)
[13:22:57.577]                 added <- setdiff(names, old_names)
[13:22:57.577]                 removed <- setdiff(old_names, names)
[13:22:57.577]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.577]                   envs[common]]
[13:22:57.577]                 NAMES <- toupper(changed)
[13:22:57.577]                 args <- list()
[13:22:57.577]                 for (kk in seq_along(NAMES)) {
[13:22:57.577]                   name <- changed[[kk]]
[13:22:57.577]                   NAME <- NAMES[[kk]]
[13:22:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.577]                     next
[13:22:57.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.577]                 }
[13:22:57.577]                 NAMES <- toupper(added)
[13:22:57.577]                 for (kk in seq_along(NAMES)) {
[13:22:57.577]                   name <- added[[kk]]
[13:22:57.577]                   NAME <- NAMES[[kk]]
[13:22:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.577]                     next
[13:22:57.577]                   args[[name]] <- ""
[13:22:57.577]                 }
[13:22:57.577]                 NAMES <- toupper(removed)
[13:22:57.577]                 for (kk in seq_along(NAMES)) {
[13:22:57.577]                   name <- removed[[kk]]
[13:22:57.577]                   NAME <- NAMES[[kk]]
[13:22:57.577]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.577]                     next
[13:22:57.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.577]                 }
[13:22:57.577]                 if (length(args) > 0) 
[13:22:57.577]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.577]             }
[13:22:57.577]             else {
[13:22:57.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.577]             }
[13:22:57.577]             {
[13:22:57.577]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.577]                   0L) {
[13:22:57.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.577]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.577]                   base::options(opts)
[13:22:57.577]                 }
[13:22:57.577]                 {
[13:22:57.577]                   {
[13:22:57.577]                     NULL
[13:22:57.577]                     RNGkind("Mersenne-Twister")
[13:22:57.577]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.577]                       inherits = FALSE)
[13:22:57.577]                   }
[13:22:57.577]                   options(future.plan = NULL)
[13:22:57.577]                   if (is.na(NA_character_)) 
[13:22:57.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.577]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.577]                   {
[13:22:57.577]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.577]                     if (!future$lazy) 
[13:22:57.577]                       future <- run(future)
[13:22:57.577]                     invisible(future)
[13:22:57.577]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.577]                 }
[13:22:57.577]             }
[13:22:57.577]         }
[13:22:57.577]     })
[13:22:57.577]     if (TRUE) {
[13:22:57.577]         base::sink(type = "output", split = FALSE)
[13:22:57.577]         if (TRUE) {
[13:22:57.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.577]         }
[13:22:57.577]         else {
[13:22:57.577]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.577]         }
[13:22:57.577]         base::close(...future.stdout)
[13:22:57.577]         ...future.stdout <- NULL
[13:22:57.577]     }
[13:22:57.577]     ...future.result$conditions <- ...future.conditions
[13:22:57.577]     ...future.result$finished <- base::Sys.time()
[13:22:57.577]     ...future.result
[13:22:57.577] }
[13:22:57.579] plan(): Setting new future strategy stack:
[13:22:57.579] List of future strategies:
[13:22:57.579] 1. sequential:
[13:22:57.579]    - args: function (..., envir = parent.frame())
[13:22:57.579]    - tweaked: FALSE
[13:22:57.579]    - call: NULL
[13:22:57.580] plan(): nbrOfWorkers() = 1
[13:22:57.581] plan(): Setting new future strategy stack:
[13:22:57.581] List of future strategies:
[13:22:57.581] 1. sequential:
[13:22:57.581]    - args: function (..., envir = parent.frame())
[13:22:57.581]    - tweaked: FALSE
[13:22:57.581]    - call: plan(strategy)
[13:22:57.581] plan(): nbrOfWorkers() = 1
[13:22:57.581] SequentialFuture started (and completed)
[13:22:57.581] - Launch lazy future ... done
[13:22:57.581] run() for ‘SequentialFuture’ ... done
[13:22:57.582] getGlobalsAndPackages() ...
[13:22:57.582] Searching for globals...
[13:22:57.582] - globals found: [1] ‘{’
[13:22:57.582] Searching for globals ... DONE
[13:22:57.583] Resolving globals: FALSE
[13:22:57.583] 
[13:22:57.583] 
[13:22:57.583] getGlobalsAndPackages() ... DONE
[13:22:57.583] run() for ‘Future’ ...
[13:22:57.583] - state: ‘created’
[13:22:57.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.584] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.584]   - Field: ‘label’
[13:22:57.584]   - Field: ‘local’
[13:22:57.584]   - Field: ‘owner’
[13:22:57.584]   - Field: ‘envir’
[13:22:57.584]   - Field: ‘packages’
[13:22:57.584]   - Field: ‘gc’
[13:22:57.585]   - Field: ‘conditions’
[13:22:57.585]   - Field: ‘expr’
[13:22:57.585]   - Field: ‘uuid’
[13:22:57.585]   - Field: ‘seed’
[13:22:57.585]   - Field: ‘version’
[13:22:57.585]   - Field: ‘result’
[13:22:57.585]   - Field: ‘asynchronous’
[13:22:57.585]   - Field: ‘calls’
[13:22:57.585]   - Field: ‘globals’
[13:22:57.585]   - Field: ‘stdout’
[13:22:57.586]   - Field: ‘earlySignal’
[13:22:57.586]   - Field: ‘lazy’
[13:22:57.586]   - Field: ‘state’
[13:22:57.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.586] - Launch lazy future ...
[13:22:57.586] Packages needed by the future expression (n = 0): <none>
[13:22:57.586] Packages needed by future strategies (n = 0): <none>
[13:22:57.587] {
[13:22:57.587]     {
[13:22:57.587]         {
[13:22:57.587]             ...future.startTime <- base::Sys.time()
[13:22:57.587]             {
[13:22:57.587]                 {
[13:22:57.587]                   {
[13:22:57.587]                     base::local({
[13:22:57.587]                       has_future <- base::requireNamespace("future", 
[13:22:57.587]                         quietly = TRUE)
[13:22:57.587]                       if (has_future) {
[13:22:57.587]                         ns <- base::getNamespace("future")
[13:22:57.587]                         version <- ns[[".package"]][["version"]]
[13:22:57.587]                         if (is.null(version)) 
[13:22:57.587]                           version <- utils::packageVersion("future")
[13:22:57.587]                       }
[13:22:57.587]                       else {
[13:22:57.587]                         version <- NULL
[13:22:57.587]                       }
[13:22:57.587]                       if (!has_future || version < "1.8.0") {
[13:22:57.587]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.587]                           "", base::R.version$version.string), 
[13:22:57.587]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.587]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.587]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.587]                             "release", "version")], collapse = " "), 
[13:22:57.587]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.587]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.587]                           info)
[13:22:57.587]                         info <- base::paste(info, collapse = "; ")
[13:22:57.587]                         if (!has_future) {
[13:22:57.587]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.587]                             info)
[13:22:57.587]                         }
[13:22:57.587]                         else {
[13:22:57.587]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.587]                             info, version)
[13:22:57.587]                         }
[13:22:57.587]                         base::stop(msg)
[13:22:57.587]                       }
[13:22:57.587]                     })
[13:22:57.587]                   }
[13:22:57.587]                   options(future.plan = NULL)
[13:22:57.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.587]                 }
[13:22:57.587]                 ...future.workdir <- getwd()
[13:22:57.587]             }
[13:22:57.587]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.587]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.587]         }
[13:22:57.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.587]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.587]             base::names(...future.oldOptions))
[13:22:57.587]     }
[13:22:57.587]     if (FALSE) {
[13:22:57.587]     }
[13:22:57.587]     else {
[13:22:57.587]         if (TRUE) {
[13:22:57.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.587]                 open = "w")
[13:22:57.587]         }
[13:22:57.587]         else {
[13:22:57.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.587]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.587]         }
[13:22:57.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.587]             base::sink(type = "output", split = FALSE)
[13:22:57.587]             base::close(...future.stdout)
[13:22:57.587]         }, add = TRUE)
[13:22:57.587]     }
[13:22:57.587]     ...future.frame <- base::sys.nframe()
[13:22:57.587]     ...future.conditions <- base::list()
[13:22:57.587]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.587]     if (FALSE) {
[13:22:57.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.587]     }
[13:22:57.587]     ...future.result <- base::tryCatch({
[13:22:57.587]         base::withCallingHandlers({
[13:22:57.587]             ...future.value <- base::withVisible(base::local({
[13:22:57.587]                 4
[13:22:57.587]             }))
[13:22:57.587]             future::FutureResult(value = ...future.value$value, 
[13:22:57.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.587]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.587]                     ...future.globalenv.names))
[13:22:57.587]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.587]         }, condition = base::local({
[13:22:57.587]             c <- base::c
[13:22:57.587]             inherits <- base::inherits
[13:22:57.587]             invokeRestart <- base::invokeRestart
[13:22:57.587]             length <- base::length
[13:22:57.587]             list <- base::list
[13:22:57.587]             seq.int <- base::seq.int
[13:22:57.587]             signalCondition <- base::signalCondition
[13:22:57.587]             sys.calls <- base::sys.calls
[13:22:57.587]             `[[` <- base::`[[`
[13:22:57.587]             `+` <- base::`+`
[13:22:57.587]             `<<-` <- base::`<<-`
[13:22:57.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.587]                   3L)]
[13:22:57.587]             }
[13:22:57.587]             function(cond) {
[13:22:57.587]                 is_error <- inherits(cond, "error")
[13:22:57.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.587]                   NULL)
[13:22:57.587]                 if (is_error) {
[13:22:57.587]                   sessionInformation <- function() {
[13:22:57.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.587]                       search = base::search(), system = base::Sys.info())
[13:22:57.587]                   }
[13:22:57.587]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.587]                     cond$call), session = sessionInformation(), 
[13:22:57.587]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.587]                   signalCondition(cond)
[13:22:57.587]                 }
[13:22:57.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.587]                 "immediateCondition"))) {
[13:22:57.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.587]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.587]                   if (TRUE && !signal) {
[13:22:57.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.587]                     {
[13:22:57.587]                       inherits <- base::inherits
[13:22:57.587]                       invokeRestart <- base::invokeRestart
[13:22:57.587]                       is.null <- base::is.null
[13:22:57.587]                       muffled <- FALSE
[13:22:57.587]                       if (inherits(cond, "message")) {
[13:22:57.587]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.587]                         if (muffled) 
[13:22:57.587]                           invokeRestart("muffleMessage")
[13:22:57.587]                       }
[13:22:57.587]                       else if (inherits(cond, "warning")) {
[13:22:57.587]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.587]                         if (muffled) 
[13:22:57.587]                           invokeRestart("muffleWarning")
[13:22:57.587]                       }
[13:22:57.587]                       else if (inherits(cond, "condition")) {
[13:22:57.587]                         if (!is.null(pattern)) {
[13:22:57.587]                           computeRestarts <- base::computeRestarts
[13:22:57.587]                           grepl <- base::grepl
[13:22:57.587]                           restarts <- computeRestarts(cond)
[13:22:57.587]                           for (restart in restarts) {
[13:22:57.587]                             name <- restart$name
[13:22:57.587]                             if (is.null(name)) 
[13:22:57.587]                               next
[13:22:57.587]                             if (!grepl(pattern, name)) 
[13:22:57.587]                               next
[13:22:57.587]                             invokeRestart(restart)
[13:22:57.587]                             muffled <- TRUE
[13:22:57.587]                             break
[13:22:57.587]                           }
[13:22:57.587]                         }
[13:22:57.587]                       }
[13:22:57.587]                       invisible(muffled)
[13:22:57.587]                     }
[13:22:57.587]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.587]                   }
[13:22:57.587]                 }
[13:22:57.587]                 else {
[13:22:57.587]                   if (TRUE) {
[13:22:57.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.587]                     {
[13:22:57.587]                       inherits <- base::inherits
[13:22:57.587]                       invokeRestart <- base::invokeRestart
[13:22:57.587]                       is.null <- base::is.null
[13:22:57.587]                       muffled <- FALSE
[13:22:57.587]                       if (inherits(cond, "message")) {
[13:22:57.587]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.587]                         if (muffled) 
[13:22:57.587]                           invokeRestart("muffleMessage")
[13:22:57.587]                       }
[13:22:57.587]                       else if (inherits(cond, "warning")) {
[13:22:57.587]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.587]                         if (muffled) 
[13:22:57.587]                           invokeRestart("muffleWarning")
[13:22:57.587]                       }
[13:22:57.587]                       else if (inherits(cond, "condition")) {
[13:22:57.587]                         if (!is.null(pattern)) {
[13:22:57.587]                           computeRestarts <- base::computeRestarts
[13:22:57.587]                           grepl <- base::grepl
[13:22:57.587]                           restarts <- computeRestarts(cond)
[13:22:57.587]                           for (restart in restarts) {
[13:22:57.587]                             name <- restart$name
[13:22:57.587]                             if (is.null(name)) 
[13:22:57.587]                               next
[13:22:57.587]                             if (!grepl(pattern, name)) 
[13:22:57.587]                               next
[13:22:57.587]                             invokeRestart(restart)
[13:22:57.587]                             muffled <- TRUE
[13:22:57.587]                             break
[13:22:57.587]                           }
[13:22:57.587]                         }
[13:22:57.587]                       }
[13:22:57.587]                       invisible(muffled)
[13:22:57.587]                     }
[13:22:57.587]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.587]                   }
[13:22:57.587]                 }
[13:22:57.587]             }
[13:22:57.587]         }))
[13:22:57.587]     }, error = function(ex) {
[13:22:57.587]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.587]                 ...future.rng), started = ...future.startTime, 
[13:22:57.587]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.587]             version = "1.8"), class = "FutureResult")
[13:22:57.587]     }, finally = {
[13:22:57.587]         if (!identical(...future.workdir, getwd())) 
[13:22:57.587]             setwd(...future.workdir)
[13:22:57.587]         {
[13:22:57.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.587]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.587]             }
[13:22:57.587]             base::options(...future.oldOptions)
[13:22:57.587]             if (.Platform$OS.type == "windows") {
[13:22:57.587]                 old_names <- names(...future.oldEnvVars)
[13:22:57.587]                 envs <- base::Sys.getenv()
[13:22:57.587]                 names <- names(envs)
[13:22:57.587]                 common <- intersect(names, old_names)
[13:22:57.587]                 added <- setdiff(names, old_names)
[13:22:57.587]                 removed <- setdiff(old_names, names)
[13:22:57.587]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.587]                   envs[common]]
[13:22:57.587]                 NAMES <- toupper(changed)
[13:22:57.587]                 args <- list()
[13:22:57.587]                 for (kk in seq_along(NAMES)) {
[13:22:57.587]                   name <- changed[[kk]]
[13:22:57.587]                   NAME <- NAMES[[kk]]
[13:22:57.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.587]                     next
[13:22:57.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.587]                 }
[13:22:57.587]                 NAMES <- toupper(added)
[13:22:57.587]                 for (kk in seq_along(NAMES)) {
[13:22:57.587]                   name <- added[[kk]]
[13:22:57.587]                   NAME <- NAMES[[kk]]
[13:22:57.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.587]                     next
[13:22:57.587]                   args[[name]] <- ""
[13:22:57.587]                 }
[13:22:57.587]                 NAMES <- toupper(removed)
[13:22:57.587]                 for (kk in seq_along(NAMES)) {
[13:22:57.587]                   name <- removed[[kk]]
[13:22:57.587]                   NAME <- NAMES[[kk]]
[13:22:57.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.587]                     next
[13:22:57.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.587]                 }
[13:22:57.587]                 if (length(args) > 0) 
[13:22:57.587]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.587]             }
[13:22:57.587]             else {
[13:22:57.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.587]             }
[13:22:57.587]             {
[13:22:57.587]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.587]                   0L) {
[13:22:57.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.587]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.587]                   base::options(opts)
[13:22:57.587]                 }
[13:22:57.587]                 {
[13:22:57.587]                   {
[13:22:57.587]                     NULL
[13:22:57.587]                     RNGkind("Mersenne-Twister")
[13:22:57.587]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.587]                       inherits = FALSE)
[13:22:57.587]                   }
[13:22:57.587]                   options(future.plan = NULL)
[13:22:57.587]                   if (is.na(NA_character_)) 
[13:22:57.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.587]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.587]                   {
[13:22:57.587]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.587]                     if (!future$lazy) 
[13:22:57.587]                       future <- run(future)
[13:22:57.587]                     invisible(future)
[13:22:57.587]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.587]                 }
[13:22:57.587]             }
[13:22:57.587]         }
[13:22:57.587]     })
[13:22:57.587]     if (TRUE) {
[13:22:57.587]         base::sink(type = "output", split = FALSE)
[13:22:57.587]         if (TRUE) {
[13:22:57.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.587]         }
[13:22:57.587]         else {
[13:22:57.587]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.587]         }
[13:22:57.587]         base::close(...future.stdout)
[13:22:57.587]         ...future.stdout <- NULL
[13:22:57.587]     }
[13:22:57.587]     ...future.result$conditions <- ...future.conditions
[13:22:57.587]     ...future.result$finished <- base::Sys.time()
[13:22:57.587]     ...future.result
[13:22:57.587] }
[13:22:57.588] plan(): Setting new future strategy stack:
[13:22:57.589] List of future strategies:
[13:22:57.589] 1. sequential:
[13:22:57.589]    - args: function (..., envir = parent.frame())
[13:22:57.589]    - tweaked: FALSE
[13:22:57.589]    - call: NULL
[13:22:57.589] plan(): nbrOfWorkers() = 1
[13:22:57.590] plan(): Setting new future strategy stack:
[13:22:57.590] List of future strategies:
[13:22:57.590] 1. sequential:
[13:22:57.590]    - args: function (..., envir = parent.frame())
[13:22:57.590]    - tweaked: FALSE
[13:22:57.590]    - call: plan(strategy)
[13:22:57.590] plan(): nbrOfWorkers() = 1
[13:22:57.590] SequentialFuture started (and completed)
[13:22:57.590] - Launch lazy future ... done
[13:22:57.591] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[13:22:57.591] getGlobalsAndPackages() ...
[13:22:57.591] Searching for globals...
[13:22:57.592] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.592] Searching for globals ... DONE
[13:22:57.592] Resolving globals: FALSE
[13:22:57.593] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.593] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.594] - globals: [1] ‘a’
[13:22:57.594] 
[13:22:57.594] getGlobalsAndPackages() ... DONE
[13:22:57.594] run() for ‘Future’ ...
[13:22:57.594] - state: ‘created’
[13:22:57.594] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.595]   - Field: ‘label’
[13:22:57.595]   - Field: ‘local’
[13:22:57.595]   - Field: ‘owner’
[13:22:57.595]   - Field: ‘envir’
[13:22:57.595]   - Field: ‘packages’
[13:22:57.595]   - Field: ‘gc’
[13:22:57.595]   - Field: ‘conditions’
[13:22:57.595]   - Field: ‘expr’
[13:22:57.596]   - Field: ‘uuid’
[13:22:57.596]   - Field: ‘seed’
[13:22:57.596]   - Field: ‘version’
[13:22:57.596]   - Field: ‘result’
[13:22:57.596]   - Field: ‘asynchronous’
[13:22:57.596]   - Field: ‘calls’
[13:22:57.596]   - Field: ‘globals’
[13:22:57.596]   - Field: ‘stdout’
[13:22:57.596]   - Field: ‘earlySignal’
[13:22:57.596]   - Field: ‘lazy’
[13:22:57.597]   - Field: ‘state’
[13:22:57.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.597] - Launch lazy future ...
[13:22:57.597] Packages needed by the future expression (n = 0): <none>
[13:22:57.597] Packages needed by future strategies (n = 0): <none>
[13:22:57.597] {
[13:22:57.597]     {
[13:22:57.597]         {
[13:22:57.597]             ...future.startTime <- base::Sys.time()
[13:22:57.597]             {
[13:22:57.597]                 {
[13:22:57.597]                   {
[13:22:57.597]                     base::local({
[13:22:57.597]                       has_future <- base::requireNamespace("future", 
[13:22:57.597]                         quietly = TRUE)
[13:22:57.597]                       if (has_future) {
[13:22:57.597]                         ns <- base::getNamespace("future")
[13:22:57.597]                         version <- ns[[".package"]][["version"]]
[13:22:57.597]                         if (is.null(version)) 
[13:22:57.597]                           version <- utils::packageVersion("future")
[13:22:57.597]                       }
[13:22:57.597]                       else {
[13:22:57.597]                         version <- NULL
[13:22:57.597]                       }
[13:22:57.597]                       if (!has_future || version < "1.8.0") {
[13:22:57.597]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.597]                           "", base::R.version$version.string), 
[13:22:57.597]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.597]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.597]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.597]                             "release", "version")], collapse = " "), 
[13:22:57.597]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.597]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.597]                           info)
[13:22:57.597]                         info <- base::paste(info, collapse = "; ")
[13:22:57.597]                         if (!has_future) {
[13:22:57.597]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.597]                             info)
[13:22:57.597]                         }
[13:22:57.597]                         else {
[13:22:57.597]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.597]                             info, version)
[13:22:57.597]                         }
[13:22:57.597]                         base::stop(msg)
[13:22:57.597]                       }
[13:22:57.597]                     })
[13:22:57.597]                   }
[13:22:57.597]                   options(future.plan = NULL)
[13:22:57.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.597]                 }
[13:22:57.597]                 ...future.workdir <- getwd()
[13:22:57.597]             }
[13:22:57.597]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.597]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.597]         }
[13:22:57.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.597]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.597]             base::names(...future.oldOptions))
[13:22:57.597]     }
[13:22:57.597]     if (FALSE) {
[13:22:57.597]     }
[13:22:57.597]     else {
[13:22:57.597]         if (TRUE) {
[13:22:57.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.597]                 open = "w")
[13:22:57.597]         }
[13:22:57.597]         else {
[13:22:57.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.597]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.597]         }
[13:22:57.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.597]             base::sink(type = "output", split = FALSE)
[13:22:57.597]             base::close(...future.stdout)
[13:22:57.597]         }, add = TRUE)
[13:22:57.597]     }
[13:22:57.597]     ...future.frame <- base::sys.nframe()
[13:22:57.597]     ...future.conditions <- base::list()
[13:22:57.597]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.597]     if (FALSE) {
[13:22:57.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.597]     }
[13:22:57.597]     ...future.result <- base::tryCatch({
[13:22:57.597]         base::withCallingHandlers({
[13:22:57.597]             ...future.value <- base::withVisible(base::local({
[13:22:57.597]                 2 * a
[13:22:57.597]             }))
[13:22:57.597]             future::FutureResult(value = ...future.value$value, 
[13:22:57.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.597]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.597]                     ...future.globalenv.names))
[13:22:57.597]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.597]         }, condition = base::local({
[13:22:57.597]             c <- base::c
[13:22:57.597]             inherits <- base::inherits
[13:22:57.597]             invokeRestart <- base::invokeRestart
[13:22:57.597]             length <- base::length
[13:22:57.597]             list <- base::list
[13:22:57.597]             seq.int <- base::seq.int
[13:22:57.597]             signalCondition <- base::signalCondition
[13:22:57.597]             sys.calls <- base::sys.calls
[13:22:57.597]             `[[` <- base::`[[`
[13:22:57.597]             `+` <- base::`+`
[13:22:57.597]             `<<-` <- base::`<<-`
[13:22:57.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.597]                   3L)]
[13:22:57.597]             }
[13:22:57.597]             function(cond) {
[13:22:57.597]                 is_error <- inherits(cond, "error")
[13:22:57.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.597]                   NULL)
[13:22:57.597]                 if (is_error) {
[13:22:57.597]                   sessionInformation <- function() {
[13:22:57.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.597]                       search = base::search(), system = base::Sys.info())
[13:22:57.597]                   }
[13:22:57.597]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.597]                     cond$call), session = sessionInformation(), 
[13:22:57.597]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.597]                   signalCondition(cond)
[13:22:57.597]                 }
[13:22:57.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.597]                 "immediateCondition"))) {
[13:22:57.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.597]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.597]                   if (TRUE && !signal) {
[13:22:57.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.597]                     {
[13:22:57.597]                       inherits <- base::inherits
[13:22:57.597]                       invokeRestart <- base::invokeRestart
[13:22:57.597]                       is.null <- base::is.null
[13:22:57.597]                       muffled <- FALSE
[13:22:57.597]                       if (inherits(cond, "message")) {
[13:22:57.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.597]                         if (muffled) 
[13:22:57.597]                           invokeRestart("muffleMessage")
[13:22:57.597]                       }
[13:22:57.597]                       else if (inherits(cond, "warning")) {
[13:22:57.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.597]                         if (muffled) 
[13:22:57.597]                           invokeRestart("muffleWarning")
[13:22:57.597]                       }
[13:22:57.597]                       else if (inherits(cond, "condition")) {
[13:22:57.597]                         if (!is.null(pattern)) {
[13:22:57.597]                           computeRestarts <- base::computeRestarts
[13:22:57.597]                           grepl <- base::grepl
[13:22:57.597]                           restarts <- computeRestarts(cond)
[13:22:57.597]                           for (restart in restarts) {
[13:22:57.597]                             name <- restart$name
[13:22:57.597]                             if (is.null(name)) 
[13:22:57.597]                               next
[13:22:57.597]                             if (!grepl(pattern, name)) 
[13:22:57.597]                               next
[13:22:57.597]                             invokeRestart(restart)
[13:22:57.597]                             muffled <- TRUE
[13:22:57.597]                             break
[13:22:57.597]                           }
[13:22:57.597]                         }
[13:22:57.597]                       }
[13:22:57.597]                       invisible(muffled)
[13:22:57.597]                     }
[13:22:57.597]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.597]                   }
[13:22:57.597]                 }
[13:22:57.597]                 else {
[13:22:57.597]                   if (TRUE) {
[13:22:57.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.597]                     {
[13:22:57.597]                       inherits <- base::inherits
[13:22:57.597]                       invokeRestart <- base::invokeRestart
[13:22:57.597]                       is.null <- base::is.null
[13:22:57.597]                       muffled <- FALSE
[13:22:57.597]                       if (inherits(cond, "message")) {
[13:22:57.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.597]                         if (muffled) 
[13:22:57.597]                           invokeRestart("muffleMessage")
[13:22:57.597]                       }
[13:22:57.597]                       else if (inherits(cond, "warning")) {
[13:22:57.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.597]                         if (muffled) 
[13:22:57.597]                           invokeRestart("muffleWarning")
[13:22:57.597]                       }
[13:22:57.597]                       else if (inherits(cond, "condition")) {
[13:22:57.597]                         if (!is.null(pattern)) {
[13:22:57.597]                           computeRestarts <- base::computeRestarts
[13:22:57.597]                           grepl <- base::grepl
[13:22:57.597]                           restarts <- computeRestarts(cond)
[13:22:57.597]                           for (restart in restarts) {
[13:22:57.597]                             name <- restart$name
[13:22:57.597]                             if (is.null(name)) 
[13:22:57.597]                               next
[13:22:57.597]                             if (!grepl(pattern, name)) 
[13:22:57.597]                               next
[13:22:57.597]                             invokeRestart(restart)
[13:22:57.597]                             muffled <- TRUE
[13:22:57.597]                             break
[13:22:57.597]                           }
[13:22:57.597]                         }
[13:22:57.597]                       }
[13:22:57.597]                       invisible(muffled)
[13:22:57.597]                     }
[13:22:57.597]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.597]                   }
[13:22:57.597]                 }
[13:22:57.597]             }
[13:22:57.597]         }))
[13:22:57.597]     }, error = function(ex) {
[13:22:57.597]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.597]                 ...future.rng), started = ...future.startTime, 
[13:22:57.597]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.597]             version = "1.8"), class = "FutureResult")
[13:22:57.597]     }, finally = {
[13:22:57.597]         if (!identical(...future.workdir, getwd())) 
[13:22:57.597]             setwd(...future.workdir)
[13:22:57.597]         {
[13:22:57.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.597]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.597]             }
[13:22:57.597]             base::options(...future.oldOptions)
[13:22:57.597]             if (.Platform$OS.type == "windows") {
[13:22:57.597]                 old_names <- names(...future.oldEnvVars)
[13:22:57.597]                 envs <- base::Sys.getenv()
[13:22:57.597]                 names <- names(envs)
[13:22:57.597]                 common <- intersect(names, old_names)
[13:22:57.597]                 added <- setdiff(names, old_names)
[13:22:57.597]                 removed <- setdiff(old_names, names)
[13:22:57.597]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.597]                   envs[common]]
[13:22:57.597]                 NAMES <- toupper(changed)
[13:22:57.597]                 args <- list()
[13:22:57.597]                 for (kk in seq_along(NAMES)) {
[13:22:57.597]                   name <- changed[[kk]]
[13:22:57.597]                   NAME <- NAMES[[kk]]
[13:22:57.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.597]                     next
[13:22:57.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.597]                 }
[13:22:57.597]                 NAMES <- toupper(added)
[13:22:57.597]                 for (kk in seq_along(NAMES)) {
[13:22:57.597]                   name <- added[[kk]]
[13:22:57.597]                   NAME <- NAMES[[kk]]
[13:22:57.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.597]                     next
[13:22:57.597]                   args[[name]] <- ""
[13:22:57.597]                 }
[13:22:57.597]                 NAMES <- toupper(removed)
[13:22:57.597]                 for (kk in seq_along(NAMES)) {
[13:22:57.597]                   name <- removed[[kk]]
[13:22:57.597]                   NAME <- NAMES[[kk]]
[13:22:57.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.597]                     next
[13:22:57.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.597]                 }
[13:22:57.597]                 if (length(args) > 0) 
[13:22:57.597]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.597]             }
[13:22:57.597]             else {
[13:22:57.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.597]             }
[13:22:57.597]             {
[13:22:57.597]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.597]                   0L) {
[13:22:57.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.597]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.597]                   base::options(opts)
[13:22:57.597]                 }
[13:22:57.597]                 {
[13:22:57.597]                   {
[13:22:57.597]                     NULL
[13:22:57.597]                     RNGkind("Mersenne-Twister")
[13:22:57.597]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.597]                       inherits = FALSE)
[13:22:57.597]                   }
[13:22:57.597]                   options(future.plan = NULL)
[13:22:57.597]                   if (is.na(NA_character_)) 
[13:22:57.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.597]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.597]                   {
[13:22:57.597]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.597]                     if (!future$lazy) 
[13:22:57.597]                       future <- run(future)
[13:22:57.597]                     invisible(future)
[13:22:57.597]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.597]                 }
[13:22:57.597]             }
[13:22:57.597]         }
[13:22:57.597]     })
[13:22:57.597]     if (TRUE) {
[13:22:57.597]         base::sink(type = "output", split = FALSE)
[13:22:57.597]         if (TRUE) {
[13:22:57.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.597]         }
[13:22:57.597]         else {
[13:22:57.597]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.597]         }
[13:22:57.597]         base::close(...future.stdout)
[13:22:57.597]         ...future.stdout <- NULL
[13:22:57.597]     }
[13:22:57.597]     ...future.result$conditions <- ...future.conditions
[13:22:57.597]     ...future.result$finished <- base::Sys.time()
[13:22:57.597]     ...future.result
[13:22:57.597] }
[13:22:57.599] assign_globals() ...
[13:22:57.599] List of 1
[13:22:57.599]  $ a: num 1
[13:22:57.599]  - attr(*, "where")=List of 1
[13:22:57.599]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.599]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.599]  - attr(*, "resolved")= logi FALSE
[13:22:57.599]  - attr(*, "total_size")= num 56
[13:22:57.599]  - attr(*, "already-done")= logi TRUE
[13:22:57.607] - copied ‘a’ to environment
[13:22:57.607] assign_globals() ... done
[13:22:57.607] plan(): Setting new future strategy stack:
[13:22:57.607] List of future strategies:
[13:22:57.607] 1. sequential:
[13:22:57.607]    - args: function (..., envir = parent.frame())
[13:22:57.607]    - tweaked: FALSE
[13:22:57.607]    - call: NULL
[13:22:57.607] plan(): nbrOfWorkers() = 1
[13:22:57.608] plan(): Setting new future strategy stack:
[13:22:57.608] List of future strategies:
[13:22:57.608] 1. sequential:
[13:22:57.608]    - args: function (..., envir = parent.frame())
[13:22:57.608]    - tweaked: FALSE
[13:22:57.608]    - call: plan(strategy)
[13:22:57.609] plan(): nbrOfWorkers() = 1
[13:22:57.609] SequentialFuture started (and completed)
[13:22:57.609] - Launch lazy future ... done
[13:22:57.609] run() for ‘SequentialFuture’ ... done
[13:22:57.609] getGlobalsAndPackages() ...
[13:22:57.610] Searching for globals...
[13:22:57.610] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.611] Searching for globals ... DONE
[13:22:57.611] Resolving globals: FALSE
[13:22:57.611] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.611] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.612] - globals: [1] ‘a’
[13:22:57.612] 
[13:22:57.612] getGlobalsAndPackages() ... DONE
[13:22:57.612] run() for ‘Future’ ...
[13:22:57.612] - state: ‘created’
[13:22:57.612] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.613] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.613] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.613]   - Field: ‘label’
[13:22:57.613]   - Field: ‘local’
[13:22:57.613]   - Field: ‘owner’
[13:22:57.613]   - Field: ‘envir’
[13:22:57.613]   - Field: ‘packages’
[13:22:57.613]   - Field: ‘gc’
[13:22:57.614]   - Field: ‘conditions’
[13:22:57.614]   - Field: ‘expr’
[13:22:57.614]   - Field: ‘uuid’
[13:22:57.614]   - Field: ‘seed’
[13:22:57.614]   - Field: ‘version’
[13:22:57.614]   - Field: ‘result’
[13:22:57.614]   - Field: ‘asynchronous’
[13:22:57.614]   - Field: ‘calls’
[13:22:57.614]   - Field: ‘globals’
[13:22:57.614]   - Field: ‘stdout’
[13:22:57.614]   - Field: ‘earlySignal’
[13:22:57.615]   - Field: ‘lazy’
[13:22:57.615]   - Field: ‘state’
[13:22:57.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.615] - Launch lazy future ...
[13:22:57.615] Packages needed by the future expression (n = 0): <none>
[13:22:57.615] Packages needed by future strategies (n = 0): <none>
[13:22:57.616] {
[13:22:57.616]     {
[13:22:57.616]         {
[13:22:57.616]             ...future.startTime <- base::Sys.time()
[13:22:57.616]             {
[13:22:57.616]                 {
[13:22:57.616]                   {
[13:22:57.616]                     base::local({
[13:22:57.616]                       has_future <- base::requireNamespace("future", 
[13:22:57.616]                         quietly = TRUE)
[13:22:57.616]                       if (has_future) {
[13:22:57.616]                         ns <- base::getNamespace("future")
[13:22:57.616]                         version <- ns[[".package"]][["version"]]
[13:22:57.616]                         if (is.null(version)) 
[13:22:57.616]                           version <- utils::packageVersion("future")
[13:22:57.616]                       }
[13:22:57.616]                       else {
[13:22:57.616]                         version <- NULL
[13:22:57.616]                       }
[13:22:57.616]                       if (!has_future || version < "1.8.0") {
[13:22:57.616]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.616]                           "", base::R.version$version.string), 
[13:22:57.616]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.616]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.616]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.616]                             "release", "version")], collapse = " "), 
[13:22:57.616]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.616]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.616]                           info)
[13:22:57.616]                         info <- base::paste(info, collapse = "; ")
[13:22:57.616]                         if (!has_future) {
[13:22:57.616]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.616]                             info)
[13:22:57.616]                         }
[13:22:57.616]                         else {
[13:22:57.616]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.616]                             info, version)
[13:22:57.616]                         }
[13:22:57.616]                         base::stop(msg)
[13:22:57.616]                       }
[13:22:57.616]                     })
[13:22:57.616]                   }
[13:22:57.616]                   options(future.plan = NULL)
[13:22:57.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.616]                 }
[13:22:57.616]                 ...future.workdir <- getwd()
[13:22:57.616]             }
[13:22:57.616]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.616]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.616]         }
[13:22:57.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.616]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.616]             base::names(...future.oldOptions))
[13:22:57.616]     }
[13:22:57.616]     if (FALSE) {
[13:22:57.616]     }
[13:22:57.616]     else {
[13:22:57.616]         if (TRUE) {
[13:22:57.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.616]                 open = "w")
[13:22:57.616]         }
[13:22:57.616]         else {
[13:22:57.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.616]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.616]         }
[13:22:57.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.616]             base::sink(type = "output", split = FALSE)
[13:22:57.616]             base::close(...future.stdout)
[13:22:57.616]         }, add = TRUE)
[13:22:57.616]     }
[13:22:57.616]     ...future.frame <- base::sys.nframe()
[13:22:57.616]     ...future.conditions <- base::list()
[13:22:57.616]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.616]     if (FALSE) {
[13:22:57.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.616]     }
[13:22:57.616]     ...future.result <- base::tryCatch({
[13:22:57.616]         base::withCallingHandlers({
[13:22:57.616]             ...future.value <- base::withVisible(base::local({
[13:22:57.616]                 2 * a
[13:22:57.616]             }))
[13:22:57.616]             future::FutureResult(value = ...future.value$value, 
[13:22:57.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.616]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.616]                     ...future.globalenv.names))
[13:22:57.616]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.616]         }, condition = base::local({
[13:22:57.616]             c <- base::c
[13:22:57.616]             inherits <- base::inherits
[13:22:57.616]             invokeRestart <- base::invokeRestart
[13:22:57.616]             length <- base::length
[13:22:57.616]             list <- base::list
[13:22:57.616]             seq.int <- base::seq.int
[13:22:57.616]             signalCondition <- base::signalCondition
[13:22:57.616]             sys.calls <- base::sys.calls
[13:22:57.616]             `[[` <- base::`[[`
[13:22:57.616]             `+` <- base::`+`
[13:22:57.616]             `<<-` <- base::`<<-`
[13:22:57.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.616]                   3L)]
[13:22:57.616]             }
[13:22:57.616]             function(cond) {
[13:22:57.616]                 is_error <- inherits(cond, "error")
[13:22:57.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.616]                   NULL)
[13:22:57.616]                 if (is_error) {
[13:22:57.616]                   sessionInformation <- function() {
[13:22:57.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.616]                       search = base::search(), system = base::Sys.info())
[13:22:57.616]                   }
[13:22:57.616]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.616]                     cond$call), session = sessionInformation(), 
[13:22:57.616]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.616]                   signalCondition(cond)
[13:22:57.616]                 }
[13:22:57.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.616]                 "immediateCondition"))) {
[13:22:57.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.616]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.616]                   if (TRUE && !signal) {
[13:22:57.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.616]                     {
[13:22:57.616]                       inherits <- base::inherits
[13:22:57.616]                       invokeRestart <- base::invokeRestart
[13:22:57.616]                       is.null <- base::is.null
[13:22:57.616]                       muffled <- FALSE
[13:22:57.616]                       if (inherits(cond, "message")) {
[13:22:57.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.616]                         if (muffled) 
[13:22:57.616]                           invokeRestart("muffleMessage")
[13:22:57.616]                       }
[13:22:57.616]                       else if (inherits(cond, "warning")) {
[13:22:57.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.616]                         if (muffled) 
[13:22:57.616]                           invokeRestart("muffleWarning")
[13:22:57.616]                       }
[13:22:57.616]                       else if (inherits(cond, "condition")) {
[13:22:57.616]                         if (!is.null(pattern)) {
[13:22:57.616]                           computeRestarts <- base::computeRestarts
[13:22:57.616]                           grepl <- base::grepl
[13:22:57.616]                           restarts <- computeRestarts(cond)
[13:22:57.616]                           for (restart in restarts) {
[13:22:57.616]                             name <- restart$name
[13:22:57.616]                             if (is.null(name)) 
[13:22:57.616]                               next
[13:22:57.616]                             if (!grepl(pattern, name)) 
[13:22:57.616]                               next
[13:22:57.616]                             invokeRestart(restart)
[13:22:57.616]                             muffled <- TRUE
[13:22:57.616]                             break
[13:22:57.616]                           }
[13:22:57.616]                         }
[13:22:57.616]                       }
[13:22:57.616]                       invisible(muffled)
[13:22:57.616]                     }
[13:22:57.616]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.616]                   }
[13:22:57.616]                 }
[13:22:57.616]                 else {
[13:22:57.616]                   if (TRUE) {
[13:22:57.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.616]                     {
[13:22:57.616]                       inherits <- base::inherits
[13:22:57.616]                       invokeRestart <- base::invokeRestart
[13:22:57.616]                       is.null <- base::is.null
[13:22:57.616]                       muffled <- FALSE
[13:22:57.616]                       if (inherits(cond, "message")) {
[13:22:57.616]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.616]                         if (muffled) 
[13:22:57.616]                           invokeRestart("muffleMessage")
[13:22:57.616]                       }
[13:22:57.616]                       else if (inherits(cond, "warning")) {
[13:22:57.616]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.616]                         if (muffled) 
[13:22:57.616]                           invokeRestart("muffleWarning")
[13:22:57.616]                       }
[13:22:57.616]                       else if (inherits(cond, "condition")) {
[13:22:57.616]                         if (!is.null(pattern)) {
[13:22:57.616]                           computeRestarts <- base::computeRestarts
[13:22:57.616]                           grepl <- base::grepl
[13:22:57.616]                           restarts <- computeRestarts(cond)
[13:22:57.616]                           for (restart in restarts) {
[13:22:57.616]                             name <- restart$name
[13:22:57.616]                             if (is.null(name)) 
[13:22:57.616]                               next
[13:22:57.616]                             if (!grepl(pattern, name)) 
[13:22:57.616]                               next
[13:22:57.616]                             invokeRestart(restart)
[13:22:57.616]                             muffled <- TRUE
[13:22:57.616]                             break
[13:22:57.616]                           }
[13:22:57.616]                         }
[13:22:57.616]                       }
[13:22:57.616]                       invisible(muffled)
[13:22:57.616]                     }
[13:22:57.616]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.616]                   }
[13:22:57.616]                 }
[13:22:57.616]             }
[13:22:57.616]         }))
[13:22:57.616]     }, error = function(ex) {
[13:22:57.616]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.616]                 ...future.rng), started = ...future.startTime, 
[13:22:57.616]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.616]             version = "1.8"), class = "FutureResult")
[13:22:57.616]     }, finally = {
[13:22:57.616]         if (!identical(...future.workdir, getwd())) 
[13:22:57.616]             setwd(...future.workdir)
[13:22:57.616]         {
[13:22:57.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.616]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.616]             }
[13:22:57.616]             base::options(...future.oldOptions)
[13:22:57.616]             if (.Platform$OS.type == "windows") {
[13:22:57.616]                 old_names <- names(...future.oldEnvVars)
[13:22:57.616]                 envs <- base::Sys.getenv()
[13:22:57.616]                 names <- names(envs)
[13:22:57.616]                 common <- intersect(names, old_names)
[13:22:57.616]                 added <- setdiff(names, old_names)
[13:22:57.616]                 removed <- setdiff(old_names, names)
[13:22:57.616]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.616]                   envs[common]]
[13:22:57.616]                 NAMES <- toupper(changed)
[13:22:57.616]                 args <- list()
[13:22:57.616]                 for (kk in seq_along(NAMES)) {
[13:22:57.616]                   name <- changed[[kk]]
[13:22:57.616]                   NAME <- NAMES[[kk]]
[13:22:57.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.616]                     next
[13:22:57.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.616]                 }
[13:22:57.616]                 NAMES <- toupper(added)
[13:22:57.616]                 for (kk in seq_along(NAMES)) {
[13:22:57.616]                   name <- added[[kk]]
[13:22:57.616]                   NAME <- NAMES[[kk]]
[13:22:57.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.616]                     next
[13:22:57.616]                   args[[name]] <- ""
[13:22:57.616]                 }
[13:22:57.616]                 NAMES <- toupper(removed)
[13:22:57.616]                 for (kk in seq_along(NAMES)) {
[13:22:57.616]                   name <- removed[[kk]]
[13:22:57.616]                   NAME <- NAMES[[kk]]
[13:22:57.616]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.616]                     next
[13:22:57.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.616]                 }
[13:22:57.616]                 if (length(args) > 0) 
[13:22:57.616]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.616]             }
[13:22:57.616]             else {
[13:22:57.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.616]             }
[13:22:57.616]             {
[13:22:57.616]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.616]                   0L) {
[13:22:57.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.616]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.616]                   base::options(opts)
[13:22:57.616]                 }
[13:22:57.616]                 {
[13:22:57.616]                   {
[13:22:57.616]                     NULL
[13:22:57.616]                     RNGkind("Mersenne-Twister")
[13:22:57.616]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.616]                       inherits = FALSE)
[13:22:57.616]                   }
[13:22:57.616]                   options(future.plan = NULL)
[13:22:57.616]                   if (is.na(NA_character_)) 
[13:22:57.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.616]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.616]                   {
[13:22:57.616]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.616]                     if (!future$lazy) 
[13:22:57.616]                       future <- run(future)
[13:22:57.616]                     invisible(future)
[13:22:57.616]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.616]                 }
[13:22:57.616]             }
[13:22:57.616]         }
[13:22:57.616]     })
[13:22:57.616]     if (TRUE) {
[13:22:57.616]         base::sink(type = "output", split = FALSE)
[13:22:57.616]         if (TRUE) {
[13:22:57.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.616]         }
[13:22:57.616]         else {
[13:22:57.616]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.616]         }
[13:22:57.616]         base::close(...future.stdout)
[13:22:57.616]         ...future.stdout <- NULL
[13:22:57.616]     }
[13:22:57.616]     ...future.result$conditions <- ...future.conditions
[13:22:57.616]     ...future.result$finished <- base::Sys.time()
[13:22:57.616]     ...future.result
[13:22:57.616] }
[13:22:57.617] assign_globals() ...
[13:22:57.617] List of 1
[13:22:57.617]  $ a: num 1
[13:22:57.617]  - attr(*, "where")=List of 1
[13:22:57.617]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.617]  - attr(*, "resolved")= logi FALSE
[13:22:57.617]  - attr(*, "total_size")= num 56
[13:22:57.617]  - attr(*, "already-done")= logi TRUE
[13:22:57.620] - copied ‘a’ to environment
[13:22:57.620] assign_globals() ... done
[13:22:57.621] plan(): Setting new future strategy stack:
[13:22:57.621] List of future strategies:
[13:22:57.621] 1. sequential:
[13:22:57.621]    - args: function (..., envir = parent.frame())
[13:22:57.621]    - tweaked: FALSE
[13:22:57.621]    - call: NULL
[13:22:57.621] plan(): nbrOfWorkers() = 1
[13:22:57.622] plan(): Setting new future strategy stack:
[13:22:57.622] List of future strategies:
[13:22:57.622] 1. sequential:
[13:22:57.622]    - args: function (..., envir = parent.frame())
[13:22:57.622]    - tweaked: FALSE
[13:22:57.622]    - call: plan(strategy)
[13:22:57.622] plan(): nbrOfWorkers() = 1
[13:22:57.622] SequentialFuture started (and completed)
[13:22:57.623] - Launch lazy future ... done
[13:22:57.623] run() for ‘SequentialFuture’ ... done
[13:22:57.623] getGlobalsAndPackages() ...
[13:22:57.623] Searching for globals...
[13:22:57.624] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.624] Searching for globals ... DONE
[13:22:57.624] Resolving globals: FALSE
[13:22:57.625] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.625] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.625] - globals: [1] ‘a’
[13:22:57.625] 
[13:22:57.625] getGlobalsAndPackages() ... DONE
[13:22:57.626] run() for ‘Future’ ...
[13:22:57.626] - state: ‘created’
[13:22:57.626] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.626] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.626]   - Field: ‘label’
[13:22:57.626]   - Field: ‘local’
[13:22:57.627]   - Field: ‘owner’
[13:22:57.627]   - Field: ‘envir’
[13:22:57.627]   - Field: ‘packages’
[13:22:57.627]   - Field: ‘gc’
[13:22:57.627]   - Field: ‘conditions’
[13:22:57.627]   - Field: ‘expr’
[13:22:57.627]   - Field: ‘uuid’
[13:22:57.627]   - Field: ‘seed’
[13:22:57.627]   - Field: ‘version’
[13:22:57.627]   - Field: ‘result’
[13:22:57.627]   - Field: ‘asynchronous’
[13:22:57.628]   - Field: ‘calls’
[13:22:57.628]   - Field: ‘globals’
[13:22:57.628]   - Field: ‘stdout’
[13:22:57.628]   - Field: ‘earlySignal’
[13:22:57.628]   - Field: ‘lazy’
[13:22:57.628]   - Field: ‘state’
[13:22:57.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.628] - Launch lazy future ...
[13:22:57.628] Packages needed by the future expression (n = 0): <none>
[13:22:57.629] Packages needed by future strategies (n = 0): <none>
[13:22:57.629] {
[13:22:57.629]     {
[13:22:57.629]         {
[13:22:57.629]             ...future.startTime <- base::Sys.time()
[13:22:57.629]             {
[13:22:57.629]                 {
[13:22:57.629]                   {
[13:22:57.629]                     base::local({
[13:22:57.629]                       has_future <- base::requireNamespace("future", 
[13:22:57.629]                         quietly = TRUE)
[13:22:57.629]                       if (has_future) {
[13:22:57.629]                         ns <- base::getNamespace("future")
[13:22:57.629]                         version <- ns[[".package"]][["version"]]
[13:22:57.629]                         if (is.null(version)) 
[13:22:57.629]                           version <- utils::packageVersion("future")
[13:22:57.629]                       }
[13:22:57.629]                       else {
[13:22:57.629]                         version <- NULL
[13:22:57.629]                       }
[13:22:57.629]                       if (!has_future || version < "1.8.0") {
[13:22:57.629]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.629]                           "", base::R.version$version.string), 
[13:22:57.629]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.629]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.629]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.629]                             "release", "version")], collapse = " "), 
[13:22:57.629]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.629]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.629]                           info)
[13:22:57.629]                         info <- base::paste(info, collapse = "; ")
[13:22:57.629]                         if (!has_future) {
[13:22:57.629]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.629]                             info)
[13:22:57.629]                         }
[13:22:57.629]                         else {
[13:22:57.629]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.629]                             info, version)
[13:22:57.629]                         }
[13:22:57.629]                         base::stop(msg)
[13:22:57.629]                       }
[13:22:57.629]                     })
[13:22:57.629]                   }
[13:22:57.629]                   options(future.plan = NULL)
[13:22:57.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.629]                 }
[13:22:57.629]                 ...future.workdir <- getwd()
[13:22:57.629]             }
[13:22:57.629]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.629]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.629]         }
[13:22:57.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.629]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.629]             base::names(...future.oldOptions))
[13:22:57.629]     }
[13:22:57.629]     if (FALSE) {
[13:22:57.629]     }
[13:22:57.629]     else {
[13:22:57.629]         if (TRUE) {
[13:22:57.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.629]                 open = "w")
[13:22:57.629]         }
[13:22:57.629]         else {
[13:22:57.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.629]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.629]         }
[13:22:57.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.629]             base::sink(type = "output", split = FALSE)
[13:22:57.629]             base::close(...future.stdout)
[13:22:57.629]         }, add = TRUE)
[13:22:57.629]     }
[13:22:57.629]     ...future.frame <- base::sys.nframe()
[13:22:57.629]     ...future.conditions <- base::list()
[13:22:57.629]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.629]     if (FALSE) {
[13:22:57.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.629]     }
[13:22:57.629]     ...future.result <- base::tryCatch({
[13:22:57.629]         base::withCallingHandlers({
[13:22:57.629]             ...future.value <- base::withVisible(base::local({
[13:22:57.629]                 2 * a
[13:22:57.629]             }))
[13:22:57.629]             future::FutureResult(value = ...future.value$value, 
[13:22:57.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.629]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.629]                     ...future.globalenv.names))
[13:22:57.629]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.629]         }, condition = base::local({
[13:22:57.629]             c <- base::c
[13:22:57.629]             inherits <- base::inherits
[13:22:57.629]             invokeRestart <- base::invokeRestart
[13:22:57.629]             length <- base::length
[13:22:57.629]             list <- base::list
[13:22:57.629]             seq.int <- base::seq.int
[13:22:57.629]             signalCondition <- base::signalCondition
[13:22:57.629]             sys.calls <- base::sys.calls
[13:22:57.629]             `[[` <- base::`[[`
[13:22:57.629]             `+` <- base::`+`
[13:22:57.629]             `<<-` <- base::`<<-`
[13:22:57.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.629]                   3L)]
[13:22:57.629]             }
[13:22:57.629]             function(cond) {
[13:22:57.629]                 is_error <- inherits(cond, "error")
[13:22:57.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.629]                   NULL)
[13:22:57.629]                 if (is_error) {
[13:22:57.629]                   sessionInformation <- function() {
[13:22:57.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.629]                       search = base::search(), system = base::Sys.info())
[13:22:57.629]                   }
[13:22:57.629]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.629]                     cond$call), session = sessionInformation(), 
[13:22:57.629]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.629]                   signalCondition(cond)
[13:22:57.629]                 }
[13:22:57.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.629]                 "immediateCondition"))) {
[13:22:57.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.629]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.629]                   if (TRUE && !signal) {
[13:22:57.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.629]                     {
[13:22:57.629]                       inherits <- base::inherits
[13:22:57.629]                       invokeRestart <- base::invokeRestart
[13:22:57.629]                       is.null <- base::is.null
[13:22:57.629]                       muffled <- FALSE
[13:22:57.629]                       if (inherits(cond, "message")) {
[13:22:57.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.629]                         if (muffled) 
[13:22:57.629]                           invokeRestart("muffleMessage")
[13:22:57.629]                       }
[13:22:57.629]                       else if (inherits(cond, "warning")) {
[13:22:57.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.629]                         if (muffled) 
[13:22:57.629]                           invokeRestart("muffleWarning")
[13:22:57.629]                       }
[13:22:57.629]                       else if (inherits(cond, "condition")) {
[13:22:57.629]                         if (!is.null(pattern)) {
[13:22:57.629]                           computeRestarts <- base::computeRestarts
[13:22:57.629]                           grepl <- base::grepl
[13:22:57.629]                           restarts <- computeRestarts(cond)
[13:22:57.629]                           for (restart in restarts) {
[13:22:57.629]                             name <- restart$name
[13:22:57.629]                             if (is.null(name)) 
[13:22:57.629]                               next
[13:22:57.629]                             if (!grepl(pattern, name)) 
[13:22:57.629]                               next
[13:22:57.629]                             invokeRestart(restart)
[13:22:57.629]                             muffled <- TRUE
[13:22:57.629]                             break
[13:22:57.629]                           }
[13:22:57.629]                         }
[13:22:57.629]                       }
[13:22:57.629]                       invisible(muffled)
[13:22:57.629]                     }
[13:22:57.629]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.629]                   }
[13:22:57.629]                 }
[13:22:57.629]                 else {
[13:22:57.629]                   if (TRUE) {
[13:22:57.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.629]                     {
[13:22:57.629]                       inherits <- base::inherits
[13:22:57.629]                       invokeRestart <- base::invokeRestart
[13:22:57.629]                       is.null <- base::is.null
[13:22:57.629]                       muffled <- FALSE
[13:22:57.629]                       if (inherits(cond, "message")) {
[13:22:57.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.629]                         if (muffled) 
[13:22:57.629]                           invokeRestart("muffleMessage")
[13:22:57.629]                       }
[13:22:57.629]                       else if (inherits(cond, "warning")) {
[13:22:57.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.629]                         if (muffled) 
[13:22:57.629]                           invokeRestart("muffleWarning")
[13:22:57.629]                       }
[13:22:57.629]                       else if (inherits(cond, "condition")) {
[13:22:57.629]                         if (!is.null(pattern)) {
[13:22:57.629]                           computeRestarts <- base::computeRestarts
[13:22:57.629]                           grepl <- base::grepl
[13:22:57.629]                           restarts <- computeRestarts(cond)
[13:22:57.629]                           for (restart in restarts) {
[13:22:57.629]                             name <- restart$name
[13:22:57.629]                             if (is.null(name)) 
[13:22:57.629]                               next
[13:22:57.629]                             if (!grepl(pattern, name)) 
[13:22:57.629]                               next
[13:22:57.629]                             invokeRestart(restart)
[13:22:57.629]                             muffled <- TRUE
[13:22:57.629]                             break
[13:22:57.629]                           }
[13:22:57.629]                         }
[13:22:57.629]                       }
[13:22:57.629]                       invisible(muffled)
[13:22:57.629]                     }
[13:22:57.629]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.629]                   }
[13:22:57.629]                 }
[13:22:57.629]             }
[13:22:57.629]         }))
[13:22:57.629]     }, error = function(ex) {
[13:22:57.629]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.629]                 ...future.rng), started = ...future.startTime, 
[13:22:57.629]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.629]             version = "1.8"), class = "FutureResult")
[13:22:57.629]     }, finally = {
[13:22:57.629]         if (!identical(...future.workdir, getwd())) 
[13:22:57.629]             setwd(...future.workdir)
[13:22:57.629]         {
[13:22:57.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.629]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.629]             }
[13:22:57.629]             base::options(...future.oldOptions)
[13:22:57.629]             if (.Platform$OS.type == "windows") {
[13:22:57.629]                 old_names <- names(...future.oldEnvVars)
[13:22:57.629]                 envs <- base::Sys.getenv()
[13:22:57.629]                 names <- names(envs)
[13:22:57.629]                 common <- intersect(names, old_names)
[13:22:57.629]                 added <- setdiff(names, old_names)
[13:22:57.629]                 removed <- setdiff(old_names, names)
[13:22:57.629]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.629]                   envs[common]]
[13:22:57.629]                 NAMES <- toupper(changed)
[13:22:57.629]                 args <- list()
[13:22:57.629]                 for (kk in seq_along(NAMES)) {
[13:22:57.629]                   name <- changed[[kk]]
[13:22:57.629]                   NAME <- NAMES[[kk]]
[13:22:57.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.629]                     next
[13:22:57.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.629]                 }
[13:22:57.629]                 NAMES <- toupper(added)
[13:22:57.629]                 for (kk in seq_along(NAMES)) {
[13:22:57.629]                   name <- added[[kk]]
[13:22:57.629]                   NAME <- NAMES[[kk]]
[13:22:57.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.629]                     next
[13:22:57.629]                   args[[name]] <- ""
[13:22:57.629]                 }
[13:22:57.629]                 NAMES <- toupper(removed)
[13:22:57.629]                 for (kk in seq_along(NAMES)) {
[13:22:57.629]                   name <- removed[[kk]]
[13:22:57.629]                   NAME <- NAMES[[kk]]
[13:22:57.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.629]                     next
[13:22:57.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.629]                 }
[13:22:57.629]                 if (length(args) > 0) 
[13:22:57.629]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.629]             }
[13:22:57.629]             else {
[13:22:57.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.629]             }
[13:22:57.629]             {
[13:22:57.629]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.629]                   0L) {
[13:22:57.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.629]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.629]                   base::options(opts)
[13:22:57.629]                 }
[13:22:57.629]                 {
[13:22:57.629]                   {
[13:22:57.629]                     NULL
[13:22:57.629]                     RNGkind("Mersenne-Twister")
[13:22:57.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.629]                       inherits = FALSE)
[13:22:57.629]                   }
[13:22:57.629]                   options(future.plan = NULL)
[13:22:57.629]                   if (is.na(NA_character_)) 
[13:22:57.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.629]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.629]                   {
[13:22:57.629]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.629]                     if (!future$lazy) 
[13:22:57.629]                       future <- run(future)
[13:22:57.629]                     invisible(future)
[13:22:57.629]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.629]                 }
[13:22:57.629]             }
[13:22:57.629]         }
[13:22:57.629]     })
[13:22:57.629]     if (TRUE) {
[13:22:57.629]         base::sink(type = "output", split = FALSE)
[13:22:57.629]         if (TRUE) {
[13:22:57.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.629]         }
[13:22:57.629]         else {
[13:22:57.629]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.629]         }
[13:22:57.629]         base::close(...future.stdout)
[13:22:57.629]         ...future.stdout <- NULL
[13:22:57.629]     }
[13:22:57.629]     ...future.result$conditions <- ...future.conditions
[13:22:57.629]     ...future.result$finished <- base::Sys.time()
[13:22:57.629]     ...future.result
[13:22:57.629] }
[13:22:57.631] assign_globals() ...
[13:22:57.631] List of 1
[13:22:57.631]  $ a: num 1
[13:22:57.631]  - attr(*, "where")=List of 1
[13:22:57.631]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.631]  - attr(*, "resolved")= logi FALSE
[13:22:57.631]  - attr(*, "total_size")= num 56
[13:22:57.631]  - attr(*, "already-done")= logi TRUE
[13:22:57.634] - copied ‘a’ to environment
[13:22:57.634] assign_globals() ... done
[13:22:57.634] plan(): Setting new future strategy stack:
[13:22:57.634] List of future strategies:
[13:22:57.634] 1. sequential:
[13:22:57.634]    - args: function (..., envir = parent.frame())
[13:22:57.634]    - tweaked: FALSE
[13:22:57.634]    - call: NULL
[13:22:57.634] plan(): nbrOfWorkers() = 1
[13:22:57.635] plan(): Setting new future strategy stack:
[13:22:57.635] List of future strategies:
[13:22:57.635] 1. sequential:
[13:22:57.635]    - args: function (..., envir = parent.frame())
[13:22:57.635]    - tweaked: FALSE
[13:22:57.635]    - call: plan(strategy)
[13:22:57.636] plan(): nbrOfWorkers() = 1
[13:22:57.636] SequentialFuture started (and completed)
[13:22:57.638] - Launch lazy future ... done
[13:22:57.638] run() for ‘SequentialFuture’ ... done
[13:22:57.638] getGlobalsAndPackages() ...
[13:22:57.638] Searching for globals...
[13:22:57.639] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.640] Searching for globals ... DONE
[13:22:57.640] Resolving globals: FALSE
[13:22:57.640] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.640] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.641] - globals: [1] ‘a’
[13:22:57.641] 
[13:22:57.641] getGlobalsAndPackages() ... DONE
[13:22:57.641] run() for ‘Future’ ...
[13:22:57.641] - state: ‘created’
[13:22:57.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.642] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.642] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.642]   - Field: ‘label’
[13:22:57.642]   - Field: ‘local’
[13:22:57.642]   - Field: ‘owner’
[13:22:57.642]   - Field: ‘envir’
[13:22:57.642]   - Field: ‘packages’
[13:22:57.642]   - Field: ‘gc’
[13:22:57.642]   - Field: ‘conditions’
[13:22:57.643]   - Field: ‘expr’
[13:22:57.643]   - Field: ‘uuid’
[13:22:57.643]   - Field: ‘seed’
[13:22:57.643]   - Field: ‘version’
[13:22:57.643]   - Field: ‘result’
[13:22:57.643]   - Field: ‘asynchronous’
[13:22:57.643]   - Field: ‘calls’
[13:22:57.643]   - Field: ‘globals’
[13:22:57.643]   - Field: ‘stdout’
[13:22:57.643]   - Field: ‘earlySignal’
[13:22:57.644]   - Field: ‘lazy’
[13:22:57.644]   - Field: ‘state’
[13:22:57.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.644] - Launch lazy future ...
[13:22:57.644] Packages needed by the future expression (n = 0): <none>
[13:22:57.644] Packages needed by future strategies (n = 0): <none>
[13:22:57.645] {
[13:22:57.645]     {
[13:22:57.645]         {
[13:22:57.645]             ...future.startTime <- base::Sys.time()
[13:22:57.645]             {
[13:22:57.645]                 {
[13:22:57.645]                   {
[13:22:57.645]                     base::local({
[13:22:57.645]                       has_future <- base::requireNamespace("future", 
[13:22:57.645]                         quietly = TRUE)
[13:22:57.645]                       if (has_future) {
[13:22:57.645]                         ns <- base::getNamespace("future")
[13:22:57.645]                         version <- ns[[".package"]][["version"]]
[13:22:57.645]                         if (is.null(version)) 
[13:22:57.645]                           version <- utils::packageVersion("future")
[13:22:57.645]                       }
[13:22:57.645]                       else {
[13:22:57.645]                         version <- NULL
[13:22:57.645]                       }
[13:22:57.645]                       if (!has_future || version < "1.8.0") {
[13:22:57.645]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.645]                           "", base::R.version$version.string), 
[13:22:57.645]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.645]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.645]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.645]                             "release", "version")], collapse = " "), 
[13:22:57.645]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.645]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.645]                           info)
[13:22:57.645]                         info <- base::paste(info, collapse = "; ")
[13:22:57.645]                         if (!has_future) {
[13:22:57.645]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.645]                             info)
[13:22:57.645]                         }
[13:22:57.645]                         else {
[13:22:57.645]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.645]                             info, version)
[13:22:57.645]                         }
[13:22:57.645]                         base::stop(msg)
[13:22:57.645]                       }
[13:22:57.645]                     })
[13:22:57.645]                   }
[13:22:57.645]                   options(future.plan = NULL)
[13:22:57.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.645]                 }
[13:22:57.645]                 ...future.workdir <- getwd()
[13:22:57.645]             }
[13:22:57.645]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.645]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.645]         }
[13:22:57.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.645]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.645]             base::names(...future.oldOptions))
[13:22:57.645]     }
[13:22:57.645]     if (FALSE) {
[13:22:57.645]     }
[13:22:57.645]     else {
[13:22:57.645]         if (TRUE) {
[13:22:57.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.645]                 open = "w")
[13:22:57.645]         }
[13:22:57.645]         else {
[13:22:57.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.645]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.645]         }
[13:22:57.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.645]             base::sink(type = "output", split = FALSE)
[13:22:57.645]             base::close(...future.stdout)
[13:22:57.645]         }, add = TRUE)
[13:22:57.645]     }
[13:22:57.645]     ...future.frame <- base::sys.nframe()
[13:22:57.645]     ...future.conditions <- base::list()
[13:22:57.645]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.645]     if (FALSE) {
[13:22:57.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.645]     }
[13:22:57.645]     ...future.result <- base::tryCatch({
[13:22:57.645]         base::withCallingHandlers({
[13:22:57.645]             ...future.value <- base::withVisible(base::local({
[13:22:57.645]                 2 * a
[13:22:57.645]             }))
[13:22:57.645]             future::FutureResult(value = ...future.value$value, 
[13:22:57.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.645]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.645]                     ...future.globalenv.names))
[13:22:57.645]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.645]         }, condition = base::local({
[13:22:57.645]             c <- base::c
[13:22:57.645]             inherits <- base::inherits
[13:22:57.645]             invokeRestart <- base::invokeRestart
[13:22:57.645]             length <- base::length
[13:22:57.645]             list <- base::list
[13:22:57.645]             seq.int <- base::seq.int
[13:22:57.645]             signalCondition <- base::signalCondition
[13:22:57.645]             sys.calls <- base::sys.calls
[13:22:57.645]             `[[` <- base::`[[`
[13:22:57.645]             `+` <- base::`+`
[13:22:57.645]             `<<-` <- base::`<<-`
[13:22:57.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.645]                   3L)]
[13:22:57.645]             }
[13:22:57.645]             function(cond) {
[13:22:57.645]                 is_error <- inherits(cond, "error")
[13:22:57.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.645]                   NULL)
[13:22:57.645]                 if (is_error) {
[13:22:57.645]                   sessionInformation <- function() {
[13:22:57.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.645]                       search = base::search(), system = base::Sys.info())
[13:22:57.645]                   }
[13:22:57.645]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.645]                     cond$call), session = sessionInformation(), 
[13:22:57.645]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.645]                   signalCondition(cond)
[13:22:57.645]                 }
[13:22:57.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.645]                 "immediateCondition"))) {
[13:22:57.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.645]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.645]                   if (TRUE && !signal) {
[13:22:57.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.645]                     {
[13:22:57.645]                       inherits <- base::inherits
[13:22:57.645]                       invokeRestart <- base::invokeRestart
[13:22:57.645]                       is.null <- base::is.null
[13:22:57.645]                       muffled <- FALSE
[13:22:57.645]                       if (inherits(cond, "message")) {
[13:22:57.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.645]                         if (muffled) 
[13:22:57.645]                           invokeRestart("muffleMessage")
[13:22:57.645]                       }
[13:22:57.645]                       else if (inherits(cond, "warning")) {
[13:22:57.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.645]                         if (muffled) 
[13:22:57.645]                           invokeRestart("muffleWarning")
[13:22:57.645]                       }
[13:22:57.645]                       else if (inherits(cond, "condition")) {
[13:22:57.645]                         if (!is.null(pattern)) {
[13:22:57.645]                           computeRestarts <- base::computeRestarts
[13:22:57.645]                           grepl <- base::grepl
[13:22:57.645]                           restarts <- computeRestarts(cond)
[13:22:57.645]                           for (restart in restarts) {
[13:22:57.645]                             name <- restart$name
[13:22:57.645]                             if (is.null(name)) 
[13:22:57.645]                               next
[13:22:57.645]                             if (!grepl(pattern, name)) 
[13:22:57.645]                               next
[13:22:57.645]                             invokeRestart(restart)
[13:22:57.645]                             muffled <- TRUE
[13:22:57.645]                             break
[13:22:57.645]                           }
[13:22:57.645]                         }
[13:22:57.645]                       }
[13:22:57.645]                       invisible(muffled)
[13:22:57.645]                     }
[13:22:57.645]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.645]                   }
[13:22:57.645]                 }
[13:22:57.645]                 else {
[13:22:57.645]                   if (TRUE) {
[13:22:57.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.645]                     {
[13:22:57.645]                       inherits <- base::inherits
[13:22:57.645]                       invokeRestart <- base::invokeRestart
[13:22:57.645]                       is.null <- base::is.null
[13:22:57.645]                       muffled <- FALSE
[13:22:57.645]                       if (inherits(cond, "message")) {
[13:22:57.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.645]                         if (muffled) 
[13:22:57.645]                           invokeRestart("muffleMessage")
[13:22:57.645]                       }
[13:22:57.645]                       else if (inherits(cond, "warning")) {
[13:22:57.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.645]                         if (muffled) 
[13:22:57.645]                           invokeRestart("muffleWarning")
[13:22:57.645]                       }
[13:22:57.645]                       else if (inherits(cond, "condition")) {
[13:22:57.645]                         if (!is.null(pattern)) {
[13:22:57.645]                           computeRestarts <- base::computeRestarts
[13:22:57.645]                           grepl <- base::grepl
[13:22:57.645]                           restarts <- computeRestarts(cond)
[13:22:57.645]                           for (restart in restarts) {
[13:22:57.645]                             name <- restart$name
[13:22:57.645]                             if (is.null(name)) 
[13:22:57.645]                               next
[13:22:57.645]                             if (!grepl(pattern, name)) 
[13:22:57.645]                               next
[13:22:57.645]                             invokeRestart(restart)
[13:22:57.645]                             muffled <- TRUE
[13:22:57.645]                             break
[13:22:57.645]                           }
[13:22:57.645]                         }
[13:22:57.645]                       }
[13:22:57.645]                       invisible(muffled)
[13:22:57.645]                     }
[13:22:57.645]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.645]                   }
[13:22:57.645]                 }
[13:22:57.645]             }
[13:22:57.645]         }))
[13:22:57.645]     }, error = function(ex) {
[13:22:57.645]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.645]                 ...future.rng), started = ...future.startTime, 
[13:22:57.645]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.645]             version = "1.8"), class = "FutureResult")
[13:22:57.645]     }, finally = {
[13:22:57.645]         if (!identical(...future.workdir, getwd())) 
[13:22:57.645]             setwd(...future.workdir)
[13:22:57.645]         {
[13:22:57.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.645]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.645]             }
[13:22:57.645]             base::options(...future.oldOptions)
[13:22:57.645]             if (.Platform$OS.type == "windows") {
[13:22:57.645]                 old_names <- names(...future.oldEnvVars)
[13:22:57.645]                 envs <- base::Sys.getenv()
[13:22:57.645]                 names <- names(envs)
[13:22:57.645]                 common <- intersect(names, old_names)
[13:22:57.645]                 added <- setdiff(names, old_names)
[13:22:57.645]                 removed <- setdiff(old_names, names)
[13:22:57.645]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.645]                   envs[common]]
[13:22:57.645]                 NAMES <- toupper(changed)
[13:22:57.645]                 args <- list()
[13:22:57.645]                 for (kk in seq_along(NAMES)) {
[13:22:57.645]                   name <- changed[[kk]]
[13:22:57.645]                   NAME <- NAMES[[kk]]
[13:22:57.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.645]                     next
[13:22:57.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.645]                 }
[13:22:57.645]                 NAMES <- toupper(added)
[13:22:57.645]                 for (kk in seq_along(NAMES)) {
[13:22:57.645]                   name <- added[[kk]]
[13:22:57.645]                   NAME <- NAMES[[kk]]
[13:22:57.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.645]                     next
[13:22:57.645]                   args[[name]] <- ""
[13:22:57.645]                 }
[13:22:57.645]                 NAMES <- toupper(removed)
[13:22:57.645]                 for (kk in seq_along(NAMES)) {
[13:22:57.645]                   name <- removed[[kk]]
[13:22:57.645]                   NAME <- NAMES[[kk]]
[13:22:57.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.645]                     next
[13:22:57.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.645]                 }
[13:22:57.645]                 if (length(args) > 0) 
[13:22:57.645]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.645]             }
[13:22:57.645]             else {
[13:22:57.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.645]             }
[13:22:57.645]             {
[13:22:57.645]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.645]                   0L) {
[13:22:57.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.645]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.645]                   base::options(opts)
[13:22:57.645]                 }
[13:22:57.645]                 {
[13:22:57.645]                   {
[13:22:57.645]                     NULL
[13:22:57.645]                     RNGkind("Mersenne-Twister")
[13:22:57.645]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.645]                       inherits = FALSE)
[13:22:57.645]                   }
[13:22:57.645]                   options(future.plan = NULL)
[13:22:57.645]                   if (is.na(NA_character_)) 
[13:22:57.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.645]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.645]                   {
[13:22:57.645]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.645]                     if (!future$lazy) 
[13:22:57.645]                       future <- run(future)
[13:22:57.645]                     invisible(future)
[13:22:57.645]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.645]                 }
[13:22:57.645]             }
[13:22:57.645]         }
[13:22:57.645]     })
[13:22:57.645]     if (TRUE) {
[13:22:57.645]         base::sink(type = "output", split = FALSE)
[13:22:57.645]         if (TRUE) {
[13:22:57.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.645]         }
[13:22:57.645]         else {
[13:22:57.645]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.645]         }
[13:22:57.645]         base::close(...future.stdout)
[13:22:57.645]         ...future.stdout <- NULL
[13:22:57.645]     }
[13:22:57.645]     ...future.result$conditions <- ...future.conditions
[13:22:57.645]     ...future.result$finished <- base::Sys.time()
[13:22:57.645]     ...future.result
[13:22:57.645] }
[13:22:57.646] assign_globals() ...
[13:22:57.647] List of 1
[13:22:57.647]  $ a: num 1
[13:22:57.647]  - attr(*, "where")=List of 1
[13:22:57.647]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.647]  - attr(*, "resolved")= logi FALSE
[13:22:57.647]  - attr(*, "total_size")= num 56
[13:22:57.647]  - attr(*, "already-done")= logi TRUE
[13:22:57.649] - copied ‘a’ to environment
[13:22:57.649] assign_globals() ... done
[13:22:57.650] plan(): Setting new future strategy stack:
[13:22:57.650] List of future strategies:
[13:22:57.650] 1. sequential:
[13:22:57.650]    - args: function (..., envir = parent.frame())
[13:22:57.650]    - tweaked: FALSE
[13:22:57.650]    - call: NULL
[13:22:57.650] plan(): nbrOfWorkers() = 1
[13:22:57.651] plan(): Setting new future strategy stack:
[13:22:57.651] List of future strategies:
[13:22:57.651] 1. sequential:
[13:22:57.651]    - args: function (..., envir = parent.frame())
[13:22:57.651]    - tweaked: FALSE
[13:22:57.651]    - call: plan(strategy)
[13:22:57.651] plan(): nbrOfWorkers() = 1
[13:22:57.652] SequentialFuture started (and completed)
[13:22:57.652] - Launch lazy future ... done
[13:22:57.652] run() for ‘SequentialFuture’ ... done
[13:22:57.652] getGlobalsAndPackages() ...
[13:22:57.652] Searching for globals...
[13:22:57.653] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.653] Searching for globals ... DONE
[13:22:57.653] Resolving globals: FALSE
[13:22:57.654] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.654] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.654] - globals: [1] ‘a’
[13:22:57.654] 
[13:22:57.654] getGlobalsAndPackages() ... DONE
[13:22:57.655] run() for ‘Future’ ...
[13:22:57.655] - state: ‘created’
[13:22:57.655] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:22:57.655] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:22:57.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:22:57.655]   - Field: ‘label’
[13:22:57.656]   - Field: ‘local’
[13:22:57.656]   - Field: ‘owner’
[13:22:57.656]   - Field: ‘envir’
[13:22:57.656]   - Field: ‘packages’
[13:22:57.656]   - Field: ‘gc’
[13:22:57.656]   - Field: ‘conditions’
[13:22:57.656]   - Field: ‘expr’
[13:22:57.656]   - Field: ‘uuid’
[13:22:57.656]   - Field: ‘seed’
[13:22:57.656]   - Field: ‘version’
[13:22:57.656]   - Field: ‘result’
[13:22:57.657]   - Field: ‘asynchronous’
[13:22:57.657]   - Field: ‘calls’
[13:22:57.657]   - Field: ‘globals’
[13:22:57.657]   - Field: ‘stdout’
[13:22:57.657]   - Field: ‘earlySignal’
[13:22:57.657]   - Field: ‘lazy’
[13:22:57.657]   - Field: ‘state’
[13:22:57.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:22:57.657] - Launch lazy future ...
[13:22:57.658] Packages needed by the future expression (n = 0): <none>
[13:22:57.658] Packages needed by future strategies (n = 0): <none>
[13:22:57.658] {
[13:22:57.658]     {
[13:22:57.658]         {
[13:22:57.658]             ...future.startTime <- base::Sys.time()
[13:22:57.658]             {
[13:22:57.658]                 {
[13:22:57.658]                   {
[13:22:57.658]                     base::local({
[13:22:57.658]                       has_future <- base::requireNamespace("future", 
[13:22:57.658]                         quietly = TRUE)
[13:22:57.658]                       if (has_future) {
[13:22:57.658]                         ns <- base::getNamespace("future")
[13:22:57.658]                         version <- ns[[".package"]][["version"]]
[13:22:57.658]                         if (is.null(version)) 
[13:22:57.658]                           version <- utils::packageVersion("future")
[13:22:57.658]                       }
[13:22:57.658]                       else {
[13:22:57.658]                         version <- NULL
[13:22:57.658]                       }
[13:22:57.658]                       if (!has_future || version < "1.8.0") {
[13:22:57.658]                         info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.658]                           "", base::R.version$version.string), 
[13:22:57.658]                           platform = base::sprintf("%s (%s-bit)", 
[13:22:57.658]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.658]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.658]                             "release", "version")], collapse = " "), 
[13:22:57.658]                           hostname = base::Sys.info()[["nodename"]])
[13:22:57.658]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.658]                           info)
[13:22:57.658]                         info <- base::paste(info, collapse = "; ")
[13:22:57.658]                         if (!has_future) {
[13:22:57.658]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.658]                             info)
[13:22:57.658]                         }
[13:22:57.658]                         else {
[13:22:57.658]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.658]                             info, version)
[13:22:57.658]                         }
[13:22:57.658]                         base::stop(msg)
[13:22:57.658]                       }
[13:22:57.658]                     })
[13:22:57.658]                   }
[13:22:57.658]                   options(future.plan = NULL)
[13:22:57.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.658]                 }
[13:22:57.658]                 ...future.workdir <- getwd()
[13:22:57.658]             }
[13:22:57.658]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.658]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.658]         }
[13:22:57.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.658]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.658]             base::names(...future.oldOptions))
[13:22:57.658]     }
[13:22:57.658]     if (FALSE) {
[13:22:57.658]     }
[13:22:57.658]     else {
[13:22:57.658]         if (TRUE) {
[13:22:57.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.658]                 open = "w")
[13:22:57.658]         }
[13:22:57.658]         else {
[13:22:57.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.658]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.658]         }
[13:22:57.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.658]             base::sink(type = "output", split = FALSE)
[13:22:57.658]             base::close(...future.stdout)
[13:22:57.658]         }, add = TRUE)
[13:22:57.658]     }
[13:22:57.658]     ...future.frame <- base::sys.nframe()
[13:22:57.658]     ...future.conditions <- base::list()
[13:22:57.658]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.658]     if (FALSE) {
[13:22:57.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.658]     }
[13:22:57.658]     ...future.result <- base::tryCatch({
[13:22:57.658]         base::withCallingHandlers({
[13:22:57.658]             ...future.value <- base::withVisible(base::local({
[13:22:57.658]                 2 * a
[13:22:57.658]             }))
[13:22:57.658]             future::FutureResult(value = ...future.value$value, 
[13:22:57.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.658]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.658]                     ...future.globalenv.names))
[13:22:57.658]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.658]         }, condition = base::local({
[13:22:57.658]             c <- base::c
[13:22:57.658]             inherits <- base::inherits
[13:22:57.658]             invokeRestart <- base::invokeRestart
[13:22:57.658]             length <- base::length
[13:22:57.658]             list <- base::list
[13:22:57.658]             seq.int <- base::seq.int
[13:22:57.658]             signalCondition <- base::signalCondition
[13:22:57.658]             sys.calls <- base::sys.calls
[13:22:57.658]             `[[` <- base::`[[`
[13:22:57.658]             `+` <- base::`+`
[13:22:57.658]             `<<-` <- base::`<<-`
[13:22:57.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.658]                   3L)]
[13:22:57.658]             }
[13:22:57.658]             function(cond) {
[13:22:57.658]                 is_error <- inherits(cond, "error")
[13:22:57.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.658]                   NULL)
[13:22:57.658]                 if (is_error) {
[13:22:57.658]                   sessionInformation <- function() {
[13:22:57.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.658]                       search = base::search(), system = base::Sys.info())
[13:22:57.658]                   }
[13:22:57.658]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.658]                     cond$call), session = sessionInformation(), 
[13:22:57.658]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.658]                   signalCondition(cond)
[13:22:57.658]                 }
[13:22:57.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.658]                 "immediateCondition"))) {
[13:22:57.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.658]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.658]                   if (TRUE && !signal) {
[13:22:57.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.658]                     {
[13:22:57.658]                       inherits <- base::inherits
[13:22:57.658]                       invokeRestart <- base::invokeRestart
[13:22:57.658]                       is.null <- base::is.null
[13:22:57.658]                       muffled <- FALSE
[13:22:57.658]                       if (inherits(cond, "message")) {
[13:22:57.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.658]                         if (muffled) 
[13:22:57.658]                           invokeRestart("muffleMessage")
[13:22:57.658]                       }
[13:22:57.658]                       else if (inherits(cond, "warning")) {
[13:22:57.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.658]                         if (muffled) 
[13:22:57.658]                           invokeRestart("muffleWarning")
[13:22:57.658]                       }
[13:22:57.658]                       else if (inherits(cond, "condition")) {
[13:22:57.658]                         if (!is.null(pattern)) {
[13:22:57.658]                           computeRestarts <- base::computeRestarts
[13:22:57.658]                           grepl <- base::grepl
[13:22:57.658]                           restarts <- computeRestarts(cond)
[13:22:57.658]                           for (restart in restarts) {
[13:22:57.658]                             name <- restart$name
[13:22:57.658]                             if (is.null(name)) 
[13:22:57.658]                               next
[13:22:57.658]                             if (!grepl(pattern, name)) 
[13:22:57.658]                               next
[13:22:57.658]                             invokeRestart(restart)
[13:22:57.658]                             muffled <- TRUE
[13:22:57.658]                             break
[13:22:57.658]                           }
[13:22:57.658]                         }
[13:22:57.658]                       }
[13:22:57.658]                       invisible(muffled)
[13:22:57.658]                     }
[13:22:57.658]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.658]                   }
[13:22:57.658]                 }
[13:22:57.658]                 else {
[13:22:57.658]                   if (TRUE) {
[13:22:57.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.658]                     {
[13:22:57.658]                       inherits <- base::inherits
[13:22:57.658]                       invokeRestart <- base::invokeRestart
[13:22:57.658]                       is.null <- base::is.null
[13:22:57.658]                       muffled <- FALSE
[13:22:57.658]                       if (inherits(cond, "message")) {
[13:22:57.658]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.658]                         if (muffled) 
[13:22:57.658]                           invokeRestart("muffleMessage")
[13:22:57.658]                       }
[13:22:57.658]                       else if (inherits(cond, "warning")) {
[13:22:57.658]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.658]                         if (muffled) 
[13:22:57.658]                           invokeRestart("muffleWarning")
[13:22:57.658]                       }
[13:22:57.658]                       else if (inherits(cond, "condition")) {
[13:22:57.658]                         if (!is.null(pattern)) {
[13:22:57.658]                           computeRestarts <- base::computeRestarts
[13:22:57.658]                           grepl <- base::grepl
[13:22:57.658]                           restarts <- computeRestarts(cond)
[13:22:57.658]                           for (restart in restarts) {
[13:22:57.658]                             name <- restart$name
[13:22:57.658]                             if (is.null(name)) 
[13:22:57.658]                               next
[13:22:57.658]                             if (!grepl(pattern, name)) 
[13:22:57.658]                               next
[13:22:57.658]                             invokeRestart(restart)
[13:22:57.658]                             muffled <- TRUE
[13:22:57.658]                             break
[13:22:57.658]                           }
[13:22:57.658]                         }
[13:22:57.658]                       }
[13:22:57.658]                       invisible(muffled)
[13:22:57.658]                     }
[13:22:57.658]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.658]                   }
[13:22:57.658]                 }
[13:22:57.658]             }
[13:22:57.658]         }))
[13:22:57.658]     }, error = function(ex) {
[13:22:57.658]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.658]                 ...future.rng), started = ...future.startTime, 
[13:22:57.658]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.658]             version = "1.8"), class = "FutureResult")
[13:22:57.658]     }, finally = {
[13:22:57.658]         if (!identical(...future.workdir, getwd())) 
[13:22:57.658]             setwd(...future.workdir)
[13:22:57.658]         {
[13:22:57.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.658]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.658]             }
[13:22:57.658]             base::options(...future.oldOptions)
[13:22:57.658]             if (.Platform$OS.type == "windows") {
[13:22:57.658]                 old_names <- names(...future.oldEnvVars)
[13:22:57.658]                 envs <- base::Sys.getenv()
[13:22:57.658]                 names <- names(envs)
[13:22:57.658]                 common <- intersect(names, old_names)
[13:22:57.658]                 added <- setdiff(names, old_names)
[13:22:57.658]                 removed <- setdiff(old_names, names)
[13:22:57.658]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.658]                   envs[common]]
[13:22:57.658]                 NAMES <- toupper(changed)
[13:22:57.658]                 args <- list()
[13:22:57.658]                 for (kk in seq_along(NAMES)) {
[13:22:57.658]                   name <- changed[[kk]]
[13:22:57.658]                   NAME <- NAMES[[kk]]
[13:22:57.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.658]                     next
[13:22:57.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.658]                 }
[13:22:57.658]                 NAMES <- toupper(added)
[13:22:57.658]                 for (kk in seq_along(NAMES)) {
[13:22:57.658]                   name <- added[[kk]]
[13:22:57.658]                   NAME <- NAMES[[kk]]
[13:22:57.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.658]                     next
[13:22:57.658]                   args[[name]] <- ""
[13:22:57.658]                 }
[13:22:57.658]                 NAMES <- toupper(removed)
[13:22:57.658]                 for (kk in seq_along(NAMES)) {
[13:22:57.658]                   name <- removed[[kk]]
[13:22:57.658]                   NAME <- NAMES[[kk]]
[13:22:57.658]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.658]                     next
[13:22:57.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.658]                 }
[13:22:57.658]                 if (length(args) > 0) 
[13:22:57.658]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.658]             }
[13:22:57.658]             else {
[13:22:57.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.658]             }
[13:22:57.658]             {
[13:22:57.658]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.658]                   0L) {
[13:22:57.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.658]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.658]                   base::options(opts)
[13:22:57.658]                 }
[13:22:57.658]                 {
[13:22:57.658]                   {
[13:22:57.658]                     NULL
[13:22:57.658]                     RNGkind("Mersenne-Twister")
[13:22:57.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:22:57.658]                       inherits = FALSE)
[13:22:57.658]                   }
[13:22:57.658]                   options(future.plan = NULL)
[13:22:57.658]                   if (is.na(NA_character_)) 
[13:22:57.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.658]                   future::plan(list(function (..., envir = parent.frame()) 
[13:22:57.658]                   {
[13:22:57.658]                     future <- SequentialFuture(..., envir = envir)
[13:22:57.658]                     if (!future$lazy) 
[13:22:57.658]                       future <- run(future)
[13:22:57.658]                     invisible(future)
[13:22:57.658]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.658]                 }
[13:22:57.658]             }
[13:22:57.658]         }
[13:22:57.658]     })
[13:22:57.658]     if (TRUE) {
[13:22:57.658]         base::sink(type = "output", split = FALSE)
[13:22:57.658]         if (TRUE) {
[13:22:57.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.658]         }
[13:22:57.658]         else {
[13:22:57.658]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.658]         }
[13:22:57.658]         base::close(...future.stdout)
[13:22:57.658]         ...future.stdout <- NULL
[13:22:57.658]     }
[13:22:57.658]     ...future.result$conditions <- ...future.conditions
[13:22:57.658]     ...future.result$finished <- base::Sys.time()
[13:22:57.658]     ...future.result
[13:22:57.658] }
[13:22:57.660] assign_globals() ...
[13:22:57.660] List of 1
[13:22:57.660]  $ a: num 1
[13:22:57.660]  - attr(*, "where")=List of 1
[13:22:57.660]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.660]  - attr(*, "resolved")= logi FALSE
[13:22:57.660]  - attr(*, "total_size")= num 56
[13:22:57.660]  - attr(*, "already-done")= logi TRUE
[13:22:57.662] - copied ‘a’ to environment
[13:22:57.663] assign_globals() ... done
[13:22:57.663] plan(): Setting new future strategy stack:
[13:22:57.663] List of future strategies:
[13:22:57.663] 1. sequential:
[13:22:57.663]    - args: function (..., envir = parent.frame())
[13:22:57.663]    - tweaked: FALSE
[13:22:57.663]    - call: NULL
[13:22:57.663] plan(): nbrOfWorkers() = 1
[13:22:57.664] plan(): Setting new future strategy stack:
[13:22:57.664] List of future strategies:
[13:22:57.664] 1. sequential:
[13:22:57.664]    - args: function (..., envir = parent.frame())
[13:22:57.664]    - tweaked: FALSE
[13:22:57.664]    - call: plan(strategy)
[13:22:57.665] plan(): nbrOfWorkers() = 1
[13:22:57.665] SequentialFuture started (and completed)
[13:22:57.665] - Launch lazy future ... done
[13:22:57.665] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[13:22:57.672] plan(): Setting new future strategy stack:
[13:22:57.672] List of future strategies:
[13:22:57.672] 1. multicore:
[13:22:57.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.672]    - tweaked: FALSE
[13:22:57.672]    - call: plan(strategy)
[13:22:57.676] plan(): nbrOfWorkers() = 2
[13:22:57.677] getGlobalsAndPackages() ...
[13:22:57.677] Searching for globals...
[13:22:57.677] - globals found: [1] ‘{’
[13:22:57.678] Searching for globals ... DONE
[13:22:57.678] Resolving globals: FALSE
[13:22:57.678] 
[13:22:57.678] 
[13:22:57.678] getGlobalsAndPackages() ... DONE
[13:22:57.678] run() for ‘Future’ ...
[13:22:57.679] - state: ‘created’
[13:22:57.679] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.683]   - Field: ‘label’
[13:22:57.683]   - Field: ‘local’
[13:22:57.683]   - Field: ‘owner’
[13:22:57.683]   - Field: ‘envir’
[13:22:57.683]   - Field: ‘workers’
[13:22:57.683]   - Field: ‘packages’
[13:22:57.683]   - Field: ‘gc’
[13:22:57.683]   - Field: ‘job’
[13:22:57.683]   - Field: ‘conditions’
[13:22:57.683]   - Field: ‘expr’
[13:22:57.684]   - Field: ‘uuid’
[13:22:57.684]   - Field: ‘seed’
[13:22:57.684]   - Field: ‘version’
[13:22:57.684]   - Field: ‘result’
[13:22:57.684]   - Field: ‘asynchronous’
[13:22:57.684]   - Field: ‘calls’
[13:22:57.684]   - Field: ‘globals’
[13:22:57.684]   - Field: ‘stdout’
[13:22:57.684]   - Field: ‘earlySignal’
[13:22:57.684]   - Field: ‘lazy’
[13:22:57.685]   - Field: ‘state’
[13:22:57.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.685] - Launch lazy future ...
[13:22:57.686] Packages needed by the future expression (n = 0): <none>
[13:22:57.686] Packages needed by future strategies (n = 0): <none>
[13:22:57.686] {
[13:22:57.686]     {
[13:22:57.686]         {
[13:22:57.686]             ...future.startTime <- base::Sys.time()
[13:22:57.686]             {
[13:22:57.686]                 {
[13:22:57.686]                   {
[13:22:57.686]                     {
[13:22:57.686]                       base::local({
[13:22:57.686]                         has_future <- base::requireNamespace("future", 
[13:22:57.686]                           quietly = TRUE)
[13:22:57.686]                         if (has_future) {
[13:22:57.686]                           ns <- base::getNamespace("future")
[13:22:57.686]                           version <- ns[[".package"]][["version"]]
[13:22:57.686]                           if (is.null(version)) 
[13:22:57.686]                             version <- utils::packageVersion("future")
[13:22:57.686]                         }
[13:22:57.686]                         else {
[13:22:57.686]                           version <- NULL
[13:22:57.686]                         }
[13:22:57.686]                         if (!has_future || version < "1.8.0") {
[13:22:57.686]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.686]                             "", base::R.version$version.string), 
[13:22:57.686]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.686]                               "release", "version")], collapse = " "), 
[13:22:57.686]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.686]                             info)
[13:22:57.686]                           info <- base::paste(info, collapse = "; ")
[13:22:57.686]                           if (!has_future) {
[13:22:57.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.686]                               info)
[13:22:57.686]                           }
[13:22:57.686]                           else {
[13:22:57.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.686]                               info, version)
[13:22:57.686]                           }
[13:22:57.686]                           base::stop(msg)
[13:22:57.686]                         }
[13:22:57.686]                       })
[13:22:57.686]                     }
[13:22:57.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.686]                     base::options(mc.cores = 1L)
[13:22:57.686]                   }
[13:22:57.686]                   options(future.plan = NULL)
[13:22:57.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.686]                 }
[13:22:57.686]                 ...future.workdir <- getwd()
[13:22:57.686]             }
[13:22:57.686]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.686]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.686]         }
[13:22:57.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.686]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.686]             base::names(...future.oldOptions))
[13:22:57.686]     }
[13:22:57.686]     if (FALSE) {
[13:22:57.686]     }
[13:22:57.686]     else {
[13:22:57.686]         if (TRUE) {
[13:22:57.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.686]                 open = "w")
[13:22:57.686]         }
[13:22:57.686]         else {
[13:22:57.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.686]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.686]         }
[13:22:57.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.686]             base::sink(type = "output", split = FALSE)
[13:22:57.686]             base::close(...future.stdout)
[13:22:57.686]         }, add = TRUE)
[13:22:57.686]     }
[13:22:57.686]     ...future.frame <- base::sys.nframe()
[13:22:57.686]     ...future.conditions <- base::list()
[13:22:57.686]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.686]     if (FALSE) {
[13:22:57.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.686]     }
[13:22:57.686]     ...future.result <- base::tryCatch({
[13:22:57.686]         base::withCallingHandlers({
[13:22:57.686]             ...future.value <- base::withVisible(base::local({
[13:22:57.686]                 withCallingHandlers({
[13:22:57.686]                   {
[13:22:57.686]                     2
[13:22:57.686]                   }
[13:22:57.686]                 }, immediateCondition = function(cond) {
[13:22:57.686]                   save_rds <- function (object, pathname, ...) 
[13:22:57.686]                   {
[13:22:57.686]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.686]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.686]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.686]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.686]                         fi_tmp[["mtime"]])
[13:22:57.686]                     }
[13:22:57.686]                     tryCatch({
[13:22:57.686]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.686]                     }, error = function(ex) {
[13:22:57.686]                       msg <- conditionMessage(ex)
[13:22:57.686]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.686]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.686]                         fi_tmp[["mtime"]], msg)
[13:22:57.686]                       ex$message <- msg
[13:22:57.686]                       stop(ex)
[13:22:57.686]                     })
[13:22:57.686]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.686]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.686]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.686]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.686]                       fi <- file.info(pathname)
[13:22:57.686]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.686]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.686]                         fi[["size"]], fi[["mtime"]])
[13:22:57.686]                       stop(msg)
[13:22:57.686]                     }
[13:22:57.686]                     invisible(pathname)
[13:22:57.686]                   }
[13:22:57.686]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.686]                     rootPath = tempdir()) 
[13:22:57.686]                   {
[13:22:57.686]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.686]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.686]                       tmpdir = path, fileext = ".rds")
[13:22:57.686]                     save_rds(obj, file)
[13:22:57.686]                   }
[13:22:57.686]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.686]                   {
[13:22:57.686]                     inherits <- base::inherits
[13:22:57.686]                     invokeRestart <- base::invokeRestart
[13:22:57.686]                     is.null <- base::is.null
[13:22:57.686]                     muffled <- FALSE
[13:22:57.686]                     if (inherits(cond, "message")) {
[13:22:57.686]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.686]                       if (muffled) 
[13:22:57.686]                         invokeRestart("muffleMessage")
[13:22:57.686]                     }
[13:22:57.686]                     else if (inherits(cond, "warning")) {
[13:22:57.686]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.686]                       if (muffled) 
[13:22:57.686]                         invokeRestart("muffleWarning")
[13:22:57.686]                     }
[13:22:57.686]                     else if (inherits(cond, "condition")) {
[13:22:57.686]                       if (!is.null(pattern)) {
[13:22:57.686]                         computeRestarts <- base::computeRestarts
[13:22:57.686]                         grepl <- base::grepl
[13:22:57.686]                         restarts <- computeRestarts(cond)
[13:22:57.686]                         for (restart in restarts) {
[13:22:57.686]                           name <- restart$name
[13:22:57.686]                           if (is.null(name)) 
[13:22:57.686]                             next
[13:22:57.686]                           if (!grepl(pattern, name)) 
[13:22:57.686]                             next
[13:22:57.686]                           invokeRestart(restart)
[13:22:57.686]                           muffled <- TRUE
[13:22:57.686]                           break
[13:22:57.686]                         }
[13:22:57.686]                       }
[13:22:57.686]                     }
[13:22:57.686]                     invisible(muffled)
[13:22:57.686]                   }
[13:22:57.686]                   muffleCondition(cond)
[13:22:57.686]                 })
[13:22:57.686]             }))
[13:22:57.686]             future::FutureResult(value = ...future.value$value, 
[13:22:57.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.686]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.686]                     ...future.globalenv.names))
[13:22:57.686]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.686]         }, condition = base::local({
[13:22:57.686]             c <- base::c
[13:22:57.686]             inherits <- base::inherits
[13:22:57.686]             invokeRestart <- base::invokeRestart
[13:22:57.686]             length <- base::length
[13:22:57.686]             list <- base::list
[13:22:57.686]             seq.int <- base::seq.int
[13:22:57.686]             signalCondition <- base::signalCondition
[13:22:57.686]             sys.calls <- base::sys.calls
[13:22:57.686]             `[[` <- base::`[[`
[13:22:57.686]             `+` <- base::`+`
[13:22:57.686]             `<<-` <- base::`<<-`
[13:22:57.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.686]                   3L)]
[13:22:57.686]             }
[13:22:57.686]             function(cond) {
[13:22:57.686]                 is_error <- inherits(cond, "error")
[13:22:57.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.686]                   NULL)
[13:22:57.686]                 if (is_error) {
[13:22:57.686]                   sessionInformation <- function() {
[13:22:57.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.686]                       search = base::search(), system = base::Sys.info())
[13:22:57.686]                   }
[13:22:57.686]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.686]                     cond$call), session = sessionInformation(), 
[13:22:57.686]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.686]                   signalCondition(cond)
[13:22:57.686]                 }
[13:22:57.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.686]                 "immediateCondition"))) {
[13:22:57.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.686]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.686]                   if (TRUE && !signal) {
[13:22:57.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.686]                     {
[13:22:57.686]                       inherits <- base::inherits
[13:22:57.686]                       invokeRestart <- base::invokeRestart
[13:22:57.686]                       is.null <- base::is.null
[13:22:57.686]                       muffled <- FALSE
[13:22:57.686]                       if (inherits(cond, "message")) {
[13:22:57.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.686]                         if (muffled) 
[13:22:57.686]                           invokeRestart("muffleMessage")
[13:22:57.686]                       }
[13:22:57.686]                       else if (inherits(cond, "warning")) {
[13:22:57.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.686]                         if (muffled) 
[13:22:57.686]                           invokeRestart("muffleWarning")
[13:22:57.686]                       }
[13:22:57.686]                       else if (inherits(cond, "condition")) {
[13:22:57.686]                         if (!is.null(pattern)) {
[13:22:57.686]                           computeRestarts <- base::computeRestarts
[13:22:57.686]                           grepl <- base::grepl
[13:22:57.686]                           restarts <- computeRestarts(cond)
[13:22:57.686]                           for (restart in restarts) {
[13:22:57.686]                             name <- restart$name
[13:22:57.686]                             if (is.null(name)) 
[13:22:57.686]                               next
[13:22:57.686]                             if (!grepl(pattern, name)) 
[13:22:57.686]                               next
[13:22:57.686]                             invokeRestart(restart)
[13:22:57.686]                             muffled <- TRUE
[13:22:57.686]                             break
[13:22:57.686]                           }
[13:22:57.686]                         }
[13:22:57.686]                       }
[13:22:57.686]                       invisible(muffled)
[13:22:57.686]                     }
[13:22:57.686]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.686]                   }
[13:22:57.686]                 }
[13:22:57.686]                 else {
[13:22:57.686]                   if (TRUE) {
[13:22:57.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.686]                     {
[13:22:57.686]                       inherits <- base::inherits
[13:22:57.686]                       invokeRestart <- base::invokeRestart
[13:22:57.686]                       is.null <- base::is.null
[13:22:57.686]                       muffled <- FALSE
[13:22:57.686]                       if (inherits(cond, "message")) {
[13:22:57.686]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.686]                         if (muffled) 
[13:22:57.686]                           invokeRestart("muffleMessage")
[13:22:57.686]                       }
[13:22:57.686]                       else if (inherits(cond, "warning")) {
[13:22:57.686]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.686]                         if (muffled) 
[13:22:57.686]                           invokeRestart("muffleWarning")
[13:22:57.686]                       }
[13:22:57.686]                       else if (inherits(cond, "condition")) {
[13:22:57.686]                         if (!is.null(pattern)) {
[13:22:57.686]                           computeRestarts <- base::computeRestarts
[13:22:57.686]                           grepl <- base::grepl
[13:22:57.686]                           restarts <- computeRestarts(cond)
[13:22:57.686]                           for (restart in restarts) {
[13:22:57.686]                             name <- restart$name
[13:22:57.686]                             if (is.null(name)) 
[13:22:57.686]                               next
[13:22:57.686]                             if (!grepl(pattern, name)) 
[13:22:57.686]                               next
[13:22:57.686]                             invokeRestart(restart)
[13:22:57.686]                             muffled <- TRUE
[13:22:57.686]                             break
[13:22:57.686]                           }
[13:22:57.686]                         }
[13:22:57.686]                       }
[13:22:57.686]                       invisible(muffled)
[13:22:57.686]                     }
[13:22:57.686]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.686]                   }
[13:22:57.686]                 }
[13:22:57.686]             }
[13:22:57.686]         }))
[13:22:57.686]     }, error = function(ex) {
[13:22:57.686]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.686]                 ...future.rng), started = ...future.startTime, 
[13:22:57.686]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.686]             version = "1.8"), class = "FutureResult")
[13:22:57.686]     }, finally = {
[13:22:57.686]         if (!identical(...future.workdir, getwd())) 
[13:22:57.686]             setwd(...future.workdir)
[13:22:57.686]         {
[13:22:57.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.686]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.686]             }
[13:22:57.686]             base::options(...future.oldOptions)
[13:22:57.686]             if (.Platform$OS.type == "windows") {
[13:22:57.686]                 old_names <- names(...future.oldEnvVars)
[13:22:57.686]                 envs <- base::Sys.getenv()
[13:22:57.686]                 names <- names(envs)
[13:22:57.686]                 common <- intersect(names, old_names)
[13:22:57.686]                 added <- setdiff(names, old_names)
[13:22:57.686]                 removed <- setdiff(old_names, names)
[13:22:57.686]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.686]                   envs[common]]
[13:22:57.686]                 NAMES <- toupper(changed)
[13:22:57.686]                 args <- list()
[13:22:57.686]                 for (kk in seq_along(NAMES)) {
[13:22:57.686]                   name <- changed[[kk]]
[13:22:57.686]                   NAME <- NAMES[[kk]]
[13:22:57.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.686]                     next
[13:22:57.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.686]                 }
[13:22:57.686]                 NAMES <- toupper(added)
[13:22:57.686]                 for (kk in seq_along(NAMES)) {
[13:22:57.686]                   name <- added[[kk]]
[13:22:57.686]                   NAME <- NAMES[[kk]]
[13:22:57.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.686]                     next
[13:22:57.686]                   args[[name]] <- ""
[13:22:57.686]                 }
[13:22:57.686]                 NAMES <- toupper(removed)
[13:22:57.686]                 for (kk in seq_along(NAMES)) {
[13:22:57.686]                   name <- removed[[kk]]
[13:22:57.686]                   NAME <- NAMES[[kk]]
[13:22:57.686]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.686]                     next
[13:22:57.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.686]                 }
[13:22:57.686]                 if (length(args) > 0) 
[13:22:57.686]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.686]             }
[13:22:57.686]             else {
[13:22:57.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.686]             }
[13:22:57.686]             {
[13:22:57.686]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.686]                   0L) {
[13:22:57.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.686]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.686]                   base::options(opts)
[13:22:57.686]                 }
[13:22:57.686]                 {
[13:22:57.686]                   {
[13:22:57.686]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.686]                     NULL
[13:22:57.686]                   }
[13:22:57.686]                   options(future.plan = NULL)
[13:22:57.686]                   if (is.na(NA_character_)) 
[13:22:57.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.686]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.686]                     envir = parent.frame()) 
[13:22:57.686]                   {
[13:22:57.686]                     default_workers <- missing(workers)
[13:22:57.686]                     if (is.function(workers)) 
[13:22:57.686]                       workers <- workers()
[13:22:57.686]                     workers <- structure(as.integer(workers), 
[13:22:57.686]                       class = class(workers))
[13:22:57.686]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.686]                       1L)
[13:22:57.686]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.686]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.686]                       if (default_workers) 
[13:22:57.686]                         supportsMulticore(warn = TRUE)
[13:22:57.686]                       return(sequential(..., envir = envir))
[13:22:57.686]                     }
[13:22:57.686]                     oopts <- options(mc.cores = workers)
[13:22:57.686]                     on.exit(options(oopts))
[13:22:57.686]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.686]                       envir = envir)
[13:22:57.686]                     if (!future$lazy) 
[13:22:57.686]                       future <- run(future)
[13:22:57.686]                     invisible(future)
[13:22:57.686]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.686]                 }
[13:22:57.686]             }
[13:22:57.686]         }
[13:22:57.686]     })
[13:22:57.686]     if (TRUE) {
[13:22:57.686]         base::sink(type = "output", split = FALSE)
[13:22:57.686]         if (TRUE) {
[13:22:57.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.686]         }
[13:22:57.686]         else {
[13:22:57.686]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.686]         }
[13:22:57.686]         base::close(...future.stdout)
[13:22:57.686]         ...future.stdout <- NULL
[13:22:57.686]     }
[13:22:57.686]     ...future.result$conditions <- ...future.conditions
[13:22:57.686]     ...future.result$finished <- base::Sys.time()
[13:22:57.686]     ...future.result
[13:22:57.686] }
[13:22:57.689] requestCore(): workers = 2
[13:22:57.692] MulticoreFuture started
[13:22:57.692] - Launch lazy future ... done
[13:22:57.693] run() for ‘MulticoreFuture’ ... done
[13:22:57.693] plan(): Setting new future strategy stack:
[13:22:57.693] getGlobalsAndPackages() ...
[13:22:57.693] Searching for globals...
[13:22:57.693] List of future strategies:
[13:22:57.693] 1. sequential:
[13:22:57.693]    - args: function (..., envir = parent.frame())
[13:22:57.693]    - tweaked: FALSE
[13:22:57.693]    - call: NULL
[13:22:57.694] plan(): nbrOfWorkers() = 1
[13:22:57.695] - globals found: [1] ‘{’
[13:22:57.695] Searching for globals ... DONE
[13:22:57.695] Resolving globals: FALSE
[13:22:57.695] 
[13:22:57.696] 
[13:22:57.696] getGlobalsAndPackages() ... DONE
[13:22:57.696] plan(): Setting new future strategy stack:
[13:22:57.696] run() for ‘Future’ ...
[13:22:57.696] - state: ‘created’
[13:22:57.696] List of future strategies:
[13:22:57.696] 1. multicore:
[13:22:57.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.696]    - tweaked: FALSE
[13:22:57.696]    - call: plan(strategy)
[13:22:57.697] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.701] plan(): nbrOfWorkers() = 2
[13:22:57.701] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.702]   - Field: ‘label’
[13:22:57.702]   - Field: ‘local’
[13:22:57.702]   - Field: ‘owner’
[13:22:57.702]   - Field: ‘envir’
[13:22:57.702]   - Field: ‘workers’
[13:22:57.702]   - Field: ‘packages’
[13:22:57.703]   - Field: ‘gc’
[13:22:57.703]   - Field: ‘job’
[13:22:57.703]   - Field: ‘conditions’
[13:22:57.703]   - Field: ‘expr’
[13:22:57.703]   - Field: ‘uuid’
[13:22:57.703]   - Field: ‘seed’
[13:22:57.703]   - Field: ‘version’
[13:22:57.704]   - Field: ‘result’
[13:22:57.704]   - Field: ‘asynchronous’
[13:22:57.704]   - Field: ‘calls’
[13:22:57.704]   - Field: ‘globals’
[13:22:57.704]   - Field: ‘stdout’
[13:22:57.704]   - Field: ‘earlySignal’
[13:22:57.704]   - Field: ‘lazy’
[13:22:57.705]   - Field: ‘state’
[13:22:57.705] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.705] - Launch lazy future ...
[13:22:57.705] Packages needed by the future expression (n = 0): <none>
[13:22:57.706] Packages needed by future strategies (n = 0): <none>
[13:22:57.706] {
[13:22:57.706]     {
[13:22:57.706]         {
[13:22:57.706]             ...future.startTime <- base::Sys.time()
[13:22:57.706]             {
[13:22:57.706]                 {
[13:22:57.706]                   {
[13:22:57.706]                     {
[13:22:57.706]                       base::local({
[13:22:57.706]                         has_future <- base::requireNamespace("future", 
[13:22:57.706]                           quietly = TRUE)
[13:22:57.706]                         if (has_future) {
[13:22:57.706]                           ns <- base::getNamespace("future")
[13:22:57.706]                           version <- ns[[".package"]][["version"]]
[13:22:57.706]                           if (is.null(version)) 
[13:22:57.706]                             version <- utils::packageVersion("future")
[13:22:57.706]                         }
[13:22:57.706]                         else {
[13:22:57.706]                           version <- NULL
[13:22:57.706]                         }
[13:22:57.706]                         if (!has_future || version < "1.8.0") {
[13:22:57.706]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.706]                             "", base::R.version$version.string), 
[13:22:57.706]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.706]                               "release", "version")], collapse = " "), 
[13:22:57.706]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.706]                             info)
[13:22:57.706]                           info <- base::paste(info, collapse = "; ")
[13:22:57.706]                           if (!has_future) {
[13:22:57.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.706]                               info)
[13:22:57.706]                           }
[13:22:57.706]                           else {
[13:22:57.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.706]                               info, version)
[13:22:57.706]                           }
[13:22:57.706]                           base::stop(msg)
[13:22:57.706]                         }
[13:22:57.706]                       })
[13:22:57.706]                     }
[13:22:57.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.706]                     base::options(mc.cores = 1L)
[13:22:57.706]                   }
[13:22:57.706]                   options(future.plan = NULL)
[13:22:57.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.706]                 }
[13:22:57.706]                 ...future.workdir <- getwd()
[13:22:57.706]             }
[13:22:57.706]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.706]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.706]         }
[13:22:57.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.706]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.706]             base::names(...future.oldOptions))
[13:22:57.706]     }
[13:22:57.706]     if (FALSE) {
[13:22:57.706]     }
[13:22:57.706]     else {
[13:22:57.706]         if (TRUE) {
[13:22:57.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.706]                 open = "w")
[13:22:57.706]         }
[13:22:57.706]         else {
[13:22:57.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.706]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.706]         }
[13:22:57.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.706]             base::sink(type = "output", split = FALSE)
[13:22:57.706]             base::close(...future.stdout)
[13:22:57.706]         }, add = TRUE)
[13:22:57.706]     }
[13:22:57.706]     ...future.frame <- base::sys.nframe()
[13:22:57.706]     ...future.conditions <- base::list()
[13:22:57.706]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.706]     if (FALSE) {
[13:22:57.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.706]     }
[13:22:57.706]     ...future.result <- base::tryCatch({
[13:22:57.706]         base::withCallingHandlers({
[13:22:57.706]             ...future.value <- base::withVisible(base::local({
[13:22:57.706]                 withCallingHandlers({
[13:22:57.706]                   {
[13:22:57.706]                     4
[13:22:57.706]                   }
[13:22:57.706]                 }, immediateCondition = function(cond) {
[13:22:57.706]                   save_rds <- function (object, pathname, ...) 
[13:22:57.706]                   {
[13:22:57.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.706]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.706]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.706]                         fi_tmp[["mtime"]])
[13:22:57.706]                     }
[13:22:57.706]                     tryCatch({
[13:22:57.706]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.706]                     }, error = function(ex) {
[13:22:57.706]                       msg <- conditionMessage(ex)
[13:22:57.706]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.706]                         fi_tmp[["mtime"]], msg)
[13:22:57.706]                       ex$message <- msg
[13:22:57.706]                       stop(ex)
[13:22:57.706]                     })
[13:22:57.706]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.706]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.706]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.706]                       fi <- file.info(pathname)
[13:22:57.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.706]                         fi[["size"]], fi[["mtime"]])
[13:22:57.706]                       stop(msg)
[13:22:57.706]                     }
[13:22:57.706]                     invisible(pathname)
[13:22:57.706]                   }
[13:22:57.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.706]                     rootPath = tempdir()) 
[13:22:57.706]                   {
[13:22:57.706]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.706]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.706]                       tmpdir = path, fileext = ".rds")
[13:22:57.706]                     save_rds(obj, file)
[13:22:57.706]                   }
[13:22:57.706]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.706]                   {
[13:22:57.706]                     inherits <- base::inherits
[13:22:57.706]                     invokeRestart <- base::invokeRestart
[13:22:57.706]                     is.null <- base::is.null
[13:22:57.706]                     muffled <- FALSE
[13:22:57.706]                     if (inherits(cond, "message")) {
[13:22:57.706]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.706]                       if (muffled) 
[13:22:57.706]                         invokeRestart("muffleMessage")
[13:22:57.706]                     }
[13:22:57.706]                     else if (inherits(cond, "warning")) {
[13:22:57.706]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.706]                       if (muffled) 
[13:22:57.706]                         invokeRestart("muffleWarning")
[13:22:57.706]                     }
[13:22:57.706]                     else if (inherits(cond, "condition")) {
[13:22:57.706]                       if (!is.null(pattern)) {
[13:22:57.706]                         computeRestarts <- base::computeRestarts
[13:22:57.706]                         grepl <- base::grepl
[13:22:57.706]                         restarts <- computeRestarts(cond)
[13:22:57.706]                         for (restart in restarts) {
[13:22:57.706]                           name <- restart$name
[13:22:57.706]                           if (is.null(name)) 
[13:22:57.706]                             next
[13:22:57.706]                           if (!grepl(pattern, name)) 
[13:22:57.706]                             next
[13:22:57.706]                           invokeRestart(restart)
[13:22:57.706]                           muffled <- TRUE
[13:22:57.706]                           break
[13:22:57.706]                         }
[13:22:57.706]                       }
[13:22:57.706]                     }
[13:22:57.706]                     invisible(muffled)
[13:22:57.706]                   }
[13:22:57.706]                   muffleCondition(cond)
[13:22:57.706]                 })
[13:22:57.706]             }))
[13:22:57.706]             future::FutureResult(value = ...future.value$value, 
[13:22:57.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.706]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.706]                     ...future.globalenv.names))
[13:22:57.706]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.706]         }, condition = base::local({
[13:22:57.706]             c <- base::c
[13:22:57.706]             inherits <- base::inherits
[13:22:57.706]             invokeRestart <- base::invokeRestart
[13:22:57.706]             length <- base::length
[13:22:57.706]             list <- base::list
[13:22:57.706]             seq.int <- base::seq.int
[13:22:57.706]             signalCondition <- base::signalCondition
[13:22:57.706]             sys.calls <- base::sys.calls
[13:22:57.706]             `[[` <- base::`[[`
[13:22:57.706]             `+` <- base::`+`
[13:22:57.706]             `<<-` <- base::`<<-`
[13:22:57.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.706]                   3L)]
[13:22:57.706]             }
[13:22:57.706]             function(cond) {
[13:22:57.706]                 is_error <- inherits(cond, "error")
[13:22:57.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.706]                   NULL)
[13:22:57.706]                 if (is_error) {
[13:22:57.706]                   sessionInformation <- function() {
[13:22:57.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.706]                       search = base::search(), system = base::Sys.info())
[13:22:57.706]                   }
[13:22:57.706]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.706]                     cond$call), session = sessionInformation(), 
[13:22:57.706]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.706]                   signalCondition(cond)
[13:22:57.706]                 }
[13:22:57.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.706]                 "immediateCondition"))) {
[13:22:57.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.706]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.706]                   if (TRUE && !signal) {
[13:22:57.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.706]                     {
[13:22:57.706]                       inherits <- base::inherits
[13:22:57.706]                       invokeRestart <- base::invokeRestart
[13:22:57.706]                       is.null <- base::is.null
[13:22:57.706]                       muffled <- FALSE
[13:22:57.706]                       if (inherits(cond, "message")) {
[13:22:57.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.706]                         if (muffled) 
[13:22:57.706]                           invokeRestart("muffleMessage")
[13:22:57.706]                       }
[13:22:57.706]                       else if (inherits(cond, "warning")) {
[13:22:57.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.706]                         if (muffled) 
[13:22:57.706]                           invokeRestart("muffleWarning")
[13:22:57.706]                       }
[13:22:57.706]                       else if (inherits(cond, "condition")) {
[13:22:57.706]                         if (!is.null(pattern)) {
[13:22:57.706]                           computeRestarts <- base::computeRestarts
[13:22:57.706]                           grepl <- base::grepl
[13:22:57.706]                           restarts <- computeRestarts(cond)
[13:22:57.706]                           for (restart in restarts) {
[13:22:57.706]                             name <- restart$name
[13:22:57.706]                             if (is.null(name)) 
[13:22:57.706]                               next
[13:22:57.706]                             if (!grepl(pattern, name)) 
[13:22:57.706]                               next
[13:22:57.706]                             invokeRestart(restart)
[13:22:57.706]                             muffled <- TRUE
[13:22:57.706]                             break
[13:22:57.706]                           }
[13:22:57.706]                         }
[13:22:57.706]                       }
[13:22:57.706]                       invisible(muffled)
[13:22:57.706]                     }
[13:22:57.706]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.706]                   }
[13:22:57.706]                 }
[13:22:57.706]                 else {
[13:22:57.706]                   if (TRUE) {
[13:22:57.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.706]                     {
[13:22:57.706]                       inherits <- base::inherits
[13:22:57.706]                       invokeRestart <- base::invokeRestart
[13:22:57.706]                       is.null <- base::is.null
[13:22:57.706]                       muffled <- FALSE
[13:22:57.706]                       if (inherits(cond, "message")) {
[13:22:57.706]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.706]                         if (muffled) 
[13:22:57.706]                           invokeRestart("muffleMessage")
[13:22:57.706]                       }
[13:22:57.706]                       else if (inherits(cond, "warning")) {
[13:22:57.706]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.706]                         if (muffled) 
[13:22:57.706]                           invokeRestart("muffleWarning")
[13:22:57.706]                       }
[13:22:57.706]                       else if (inherits(cond, "condition")) {
[13:22:57.706]                         if (!is.null(pattern)) {
[13:22:57.706]                           computeRestarts <- base::computeRestarts
[13:22:57.706]                           grepl <- base::grepl
[13:22:57.706]                           restarts <- computeRestarts(cond)
[13:22:57.706]                           for (restart in restarts) {
[13:22:57.706]                             name <- restart$name
[13:22:57.706]                             if (is.null(name)) 
[13:22:57.706]                               next
[13:22:57.706]                             if (!grepl(pattern, name)) 
[13:22:57.706]                               next
[13:22:57.706]                             invokeRestart(restart)
[13:22:57.706]                             muffled <- TRUE
[13:22:57.706]                             break
[13:22:57.706]                           }
[13:22:57.706]                         }
[13:22:57.706]                       }
[13:22:57.706]                       invisible(muffled)
[13:22:57.706]                     }
[13:22:57.706]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.706]                   }
[13:22:57.706]                 }
[13:22:57.706]             }
[13:22:57.706]         }))
[13:22:57.706]     }, error = function(ex) {
[13:22:57.706]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.706]                 ...future.rng), started = ...future.startTime, 
[13:22:57.706]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.706]             version = "1.8"), class = "FutureResult")
[13:22:57.706]     }, finally = {
[13:22:57.706]         if (!identical(...future.workdir, getwd())) 
[13:22:57.706]             setwd(...future.workdir)
[13:22:57.706]         {
[13:22:57.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.706]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.706]             }
[13:22:57.706]             base::options(...future.oldOptions)
[13:22:57.706]             if (.Platform$OS.type == "windows") {
[13:22:57.706]                 old_names <- names(...future.oldEnvVars)
[13:22:57.706]                 envs <- base::Sys.getenv()
[13:22:57.706]                 names <- names(envs)
[13:22:57.706]                 common <- intersect(names, old_names)
[13:22:57.706]                 added <- setdiff(names, old_names)
[13:22:57.706]                 removed <- setdiff(old_names, names)
[13:22:57.706]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.706]                   envs[common]]
[13:22:57.706]                 NAMES <- toupper(changed)
[13:22:57.706]                 args <- list()
[13:22:57.706]                 for (kk in seq_along(NAMES)) {
[13:22:57.706]                   name <- changed[[kk]]
[13:22:57.706]                   NAME <- NAMES[[kk]]
[13:22:57.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.706]                     next
[13:22:57.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.706]                 }
[13:22:57.706]                 NAMES <- toupper(added)
[13:22:57.706]                 for (kk in seq_along(NAMES)) {
[13:22:57.706]                   name <- added[[kk]]
[13:22:57.706]                   NAME <- NAMES[[kk]]
[13:22:57.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.706]                     next
[13:22:57.706]                   args[[name]] <- ""
[13:22:57.706]                 }
[13:22:57.706]                 NAMES <- toupper(removed)
[13:22:57.706]                 for (kk in seq_along(NAMES)) {
[13:22:57.706]                   name <- removed[[kk]]
[13:22:57.706]                   NAME <- NAMES[[kk]]
[13:22:57.706]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.706]                     next
[13:22:57.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.706]                 }
[13:22:57.706]                 if (length(args) > 0) 
[13:22:57.706]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.706]             }
[13:22:57.706]             else {
[13:22:57.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.706]             }
[13:22:57.706]             {
[13:22:57.706]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.706]                   0L) {
[13:22:57.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.706]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.706]                   base::options(opts)
[13:22:57.706]                 }
[13:22:57.706]                 {
[13:22:57.706]                   {
[13:22:57.706]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.706]                     NULL
[13:22:57.706]                   }
[13:22:57.706]                   options(future.plan = NULL)
[13:22:57.706]                   if (is.na(NA_character_)) 
[13:22:57.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.706]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.706]                     envir = parent.frame()) 
[13:22:57.706]                   {
[13:22:57.706]                     default_workers <- missing(workers)
[13:22:57.706]                     if (is.function(workers)) 
[13:22:57.706]                       workers <- workers()
[13:22:57.706]                     workers <- structure(as.integer(workers), 
[13:22:57.706]                       class = class(workers))
[13:22:57.706]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.706]                       1L)
[13:22:57.706]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.706]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.706]                       if (default_workers) 
[13:22:57.706]                         supportsMulticore(warn = TRUE)
[13:22:57.706]                       return(sequential(..., envir = envir))
[13:22:57.706]                     }
[13:22:57.706]                     oopts <- options(mc.cores = workers)
[13:22:57.706]                     on.exit(options(oopts))
[13:22:57.706]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.706]                       envir = envir)
[13:22:57.706]                     if (!future$lazy) 
[13:22:57.706]                       future <- run(future)
[13:22:57.706]                     invisible(future)
[13:22:57.706]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.706]                 }
[13:22:57.706]             }
[13:22:57.706]         }
[13:22:57.706]     })
[13:22:57.706]     if (TRUE) {
[13:22:57.706]         base::sink(type = "output", split = FALSE)
[13:22:57.706]         if (TRUE) {
[13:22:57.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.706]         }
[13:22:57.706]         else {
[13:22:57.706]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.706]         }
[13:22:57.706]         base::close(...future.stdout)
[13:22:57.706]         ...future.stdout <- NULL
[13:22:57.706]     }
[13:22:57.706]     ...future.result$conditions <- ...future.conditions
[13:22:57.706]     ...future.result$finished <- base::Sys.time()
[13:22:57.706]     ...future.result
[13:22:57.706] }
[13:22:57.710] requestCore(): workers = 2
[13:22:57.716] MulticoreFuture started
[13:22:57.717] - Launch lazy future ... done
[13:22:57.717] run() for ‘MulticoreFuture’ ... done
[13:22:57.717] plan(): Setting new future strategy stack:
[13:22:57.718] result() for MulticoreFuture ...
[13:22:57.718] List of future strategies:
[13:22:57.718] 1. sequential:
[13:22:57.718]    - args: function (..., envir = parent.frame())
[13:22:57.718]    - tweaked: FALSE
[13:22:57.718]    - call: NULL
[13:22:57.719] plan(): nbrOfWorkers() = 1
[13:22:57.720] result() for MulticoreFuture ...
[13:22:57.721] result() for MulticoreFuture ... done
[13:22:57.721] result() for MulticoreFuture ... done
[13:22:57.721] plan(): Setting new future strategy stack:
[13:22:57.721] result() for MulticoreFuture ...
[13:22:57.721] result() for MulticoreFuture ... done
u$a = 2
[13:22:57.721] result() for MulticoreFuture ...
[13:22:57.721] List of future strategies:
[13:22:57.721] 1. multicore:
[13:22:57.721]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.721]    - tweaked: FALSE
[13:22:57.721]    - call: plan(strategy)
[13:22:57.732] plan(): nbrOfWorkers() = 2
[13:22:57.733] result() for MulticoreFuture ...
[13:22:57.733] result() for MulticoreFuture ... done
[13:22:57.737] result() for MulticoreFuture ... done
[13:22:57.737] result() for MulticoreFuture ...
[13:22:57.737] result() for MulticoreFuture ... done
v$a = 4
[13:22:57.737] getGlobalsAndPackages() ...
[13:22:57.737] Searching for globals...
[13:22:57.739] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.739] Searching for globals ... DONE
[13:22:57.739] Resolving globals: FALSE
[13:22:57.740] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.740] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.741] - globals: [1] ‘a’
[13:22:57.741] 
[13:22:57.741] getGlobalsAndPackages() ... DONE
[13:22:57.741] run() for ‘Future’ ...
[13:22:57.741] - state: ‘created’
[13:22:57.742] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.746]   - Field: ‘label’
[13:22:57.746]   - Field: ‘local’
[13:22:57.746]   - Field: ‘owner’
[13:22:57.747]   - Field: ‘envir’
[13:22:57.747]   - Field: ‘workers’
[13:22:57.747]   - Field: ‘packages’
[13:22:57.747]   - Field: ‘gc’
[13:22:57.747]   - Field: ‘job’
[13:22:57.747]   - Field: ‘conditions’
[13:22:57.747]   - Field: ‘expr’
[13:22:57.747]   - Field: ‘uuid’
[13:22:57.748]   - Field: ‘seed’
[13:22:57.748]   - Field: ‘version’
[13:22:57.748]   - Field: ‘result’
[13:22:57.748]   - Field: ‘asynchronous’
[13:22:57.748]   - Field: ‘calls’
[13:22:57.748]   - Field: ‘globals’
[13:22:57.748]   - Field: ‘stdout’
[13:22:57.748]   - Field: ‘earlySignal’
[13:22:57.749]   - Field: ‘lazy’
[13:22:57.749]   - Field: ‘state’
[13:22:57.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.749] - Launch lazy future ...
[13:22:57.749] Packages needed by the future expression (n = 0): <none>
[13:22:57.749] Packages needed by future strategies (n = 0): <none>
[13:22:57.750] {
[13:22:57.750]     {
[13:22:57.750]         {
[13:22:57.750]             ...future.startTime <- base::Sys.time()
[13:22:57.750]             {
[13:22:57.750]                 {
[13:22:57.750]                   {
[13:22:57.750]                     {
[13:22:57.750]                       base::local({
[13:22:57.750]                         has_future <- base::requireNamespace("future", 
[13:22:57.750]                           quietly = TRUE)
[13:22:57.750]                         if (has_future) {
[13:22:57.750]                           ns <- base::getNamespace("future")
[13:22:57.750]                           version <- ns[[".package"]][["version"]]
[13:22:57.750]                           if (is.null(version)) 
[13:22:57.750]                             version <- utils::packageVersion("future")
[13:22:57.750]                         }
[13:22:57.750]                         else {
[13:22:57.750]                           version <- NULL
[13:22:57.750]                         }
[13:22:57.750]                         if (!has_future || version < "1.8.0") {
[13:22:57.750]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.750]                             "", base::R.version$version.string), 
[13:22:57.750]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.750]                               "release", "version")], collapse = " "), 
[13:22:57.750]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.750]                             info)
[13:22:57.750]                           info <- base::paste(info, collapse = "; ")
[13:22:57.750]                           if (!has_future) {
[13:22:57.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.750]                               info)
[13:22:57.750]                           }
[13:22:57.750]                           else {
[13:22:57.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.750]                               info, version)
[13:22:57.750]                           }
[13:22:57.750]                           base::stop(msg)
[13:22:57.750]                         }
[13:22:57.750]                       })
[13:22:57.750]                     }
[13:22:57.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.750]                     base::options(mc.cores = 1L)
[13:22:57.750]                   }
[13:22:57.750]                   options(future.plan = NULL)
[13:22:57.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.750]                 }
[13:22:57.750]                 ...future.workdir <- getwd()
[13:22:57.750]             }
[13:22:57.750]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.750]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.750]         }
[13:22:57.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.750]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.750]             base::names(...future.oldOptions))
[13:22:57.750]     }
[13:22:57.750]     if (FALSE) {
[13:22:57.750]     }
[13:22:57.750]     else {
[13:22:57.750]         if (TRUE) {
[13:22:57.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.750]                 open = "w")
[13:22:57.750]         }
[13:22:57.750]         else {
[13:22:57.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.750]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.750]         }
[13:22:57.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.750]             base::sink(type = "output", split = FALSE)
[13:22:57.750]             base::close(...future.stdout)
[13:22:57.750]         }, add = TRUE)
[13:22:57.750]     }
[13:22:57.750]     ...future.frame <- base::sys.nframe()
[13:22:57.750]     ...future.conditions <- base::list()
[13:22:57.750]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.750]     if (FALSE) {
[13:22:57.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.750]     }
[13:22:57.750]     ...future.result <- base::tryCatch({
[13:22:57.750]         base::withCallingHandlers({
[13:22:57.750]             ...future.value <- base::withVisible(base::local({
[13:22:57.750]                 withCallingHandlers({
[13:22:57.750]                   {
[13:22:57.750]                     2 * a
[13:22:57.750]                   }
[13:22:57.750]                 }, immediateCondition = function(cond) {
[13:22:57.750]                   save_rds <- function (object, pathname, ...) 
[13:22:57.750]                   {
[13:22:57.750]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.750]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.750]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.750]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.750]                         fi_tmp[["mtime"]])
[13:22:57.750]                     }
[13:22:57.750]                     tryCatch({
[13:22:57.750]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.750]                     }, error = function(ex) {
[13:22:57.750]                       msg <- conditionMessage(ex)
[13:22:57.750]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.750]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.750]                         fi_tmp[["mtime"]], msg)
[13:22:57.750]                       ex$message <- msg
[13:22:57.750]                       stop(ex)
[13:22:57.750]                     })
[13:22:57.750]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.750]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.750]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.750]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.750]                       fi <- file.info(pathname)
[13:22:57.750]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.750]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.750]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.750]                         fi[["size"]], fi[["mtime"]])
[13:22:57.750]                       stop(msg)
[13:22:57.750]                     }
[13:22:57.750]                     invisible(pathname)
[13:22:57.750]                   }
[13:22:57.750]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.750]                     rootPath = tempdir()) 
[13:22:57.750]                   {
[13:22:57.750]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.750]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.750]                       tmpdir = path, fileext = ".rds")
[13:22:57.750]                     save_rds(obj, file)
[13:22:57.750]                   }
[13:22:57.750]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.750]                   {
[13:22:57.750]                     inherits <- base::inherits
[13:22:57.750]                     invokeRestart <- base::invokeRestart
[13:22:57.750]                     is.null <- base::is.null
[13:22:57.750]                     muffled <- FALSE
[13:22:57.750]                     if (inherits(cond, "message")) {
[13:22:57.750]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.750]                       if (muffled) 
[13:22:57.750]                         invokeRestart("muffleMessage")
[13:22:57.750]                     }
[13:22:57.750]                     else if (inherits(cond, "warning")) {
[13:22:57.750]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.750]                       if (muffled) 
[13:22:57.750]                         invokeRestart("muffleWarning")
[13:22:57.750]                     }
[13:22:57.750]                     else if (inherits(cond, "condition")) {
[13:22:57.750]                       if (!is.null(pattern)) {
[13:22:57.750]                         computeRestarts <- base::computeRestarts
[13:22:57.750]                         grepl <- base::grepl
[13:22:57.750]                         restarts <- computeRestarts(cond)
[13:22:57.750]                         for (restart in restarts) {
[13:22:57.750]                           name <- restart$name
[13:22:57.750]                           if (is.null(name)) 
[13:22:57.750]                             next
[13:22:57.750]                           if (!grepl(pattern, name)) 
[13:22:57.750]                             next
[13:22:57.750]                           invokeRestart(restart)
[13:22:57.750]                           muffled <- TRUE
[13:22:57.750]                           break
[13:22:57.750]                         }
[13:22:57.750]                       }
[13:22:57.750]                     }
[13:22:57.750]                     invisible(muffled)
[13:22:57.750]                   }
[13:22:57.750]                   muffleCondition(cond)
[13:22:57.750]                 })
[13:22:57.750]             }))
[13:22:57.750]             future::FutureResult(value = ...future.value$value, 
[13:22:57.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.750]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.750]                     ...future.globalenv.names))
[13:22:57.750]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.750]         }, condition = base::local({
[13:22:57.750]             c <- base::c
[13:22:57.750]             inherits <- base::inherits
[13:22:57.750]             invokeRestart <- base::invokeRestart
[13:22:57.750]             length <- base::length
[13:22:57.750]             list <- base::list
[13:22:57.750]             seq.int <- base::seq.int
[13:22:57.750]             signalCondition <- base::signalCondition
[13:22:57.750]             sys.calls <- base::sys.calls
[13:22:57.750]             `[[` <- base::`[[`
[13:22:57.750]             `+` <- base::`+`
[13:22:57.750]             `<<-` <- base::`<<-`
[13:22:57.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.750]                   3L)]
[13:22:57.750]             }
[13:22:57.750]             function(cond) {
[13:22:57.750]                 is_error <- inherits(cond, "error")
[13:22:57.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.750]                   NULL)
[13:22:57.750]                 if (is_error) {
[13:22:57.750]                   sessionInformation <- function() {
[13:22:57.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.750]                       search = base::search(), system = base::Sys.info())
[13:22:57.750]                   }
[13:22:57.750]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.750]                     cond$call), session = sessionInformation(), 
[13:22:57.750]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.750]                   signalCondition(cond)
[13:22:57.750]                 }
[13:22:57.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.750]                 "immediateCondition"))) {
[13:22:57.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.750]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.750]                   if (TRUE && !signal) {
[13:22:57.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.750]                     {
[13:22:57.750]                       inherits <- base::inherits
[13:22:57.750]                       invokeRestart <- base::invokeRestart
[13:22:57.750]                       is.null <- base::is.null
[13:22:57.750]                       muffled <- FALSE
[13:22:57.750]                       if (inherits(cond, "message")) {
[13:22:57.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.750]                         if (muffled) 
[13:22:57.750]                           invokeRestart("muffleMessage")
[13:22:57.750]                       }
[13:22:57.750]                       else if (inherits(cond, "warning")) {
[13:22:57.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.750]                         if (muffled) 
[13:22:57.750]                           invokeRestart("muffleWarning")
[13:22:57.750]                       }
[13:22:57.750]                       else if (inherits(cond, "condition")) {
[13:22:57.750]                         if (!is.null(pattern)) {
[13:22:57.750]                           computeRestarts <- base::computeRestarts
[13:22:57.750]                           grepl <- base::grepl
[13:22:57.750]                           restarts <- computeRestarts(cond)
[13:22:57.750]                           for (restart in restarts) {
[13:22:57.750]                             name <- restart$name
[13:22:57.750]                             if (is.null(name)) 
[13:22:57.750]                               next
[13:22:57.750]                             if (!grepl(pattern, name)) 
[13:22:57.750]                               next
[13:22:57.750]                             invokeRestart(restart)
[13:22:57.750]                             muffled <- TRUE
[13:22:57.750]                             break
[13:22:57.750]                           }
[13:22:57.750]                         }
[13:22:57.750]                       }
[13:22:57.750]                       invisible(muffled)
[13:22:57.750]                     }
[13:22:57.750]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.750]                   }
[13:22:57.750]                 }
[13:22:57.750]                 else {
[13:22:57.750]                   if (TRUE) {
[13:22:57.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.750]                     {
[13:22:57.750]                       inherits <- base::inherits
[13:22:57.750]                       invokeRestart <- base::invokeRestart
[13:22:57.750]                       is.null <- base::is.null
[13:22:57.750]                       muffled <- FALSE
[13:22:57.750]                       if (inherits(cond, "message")) {
[13:22:57.750]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.750]                         if (muffled) 
[13:22:57.750]                           invokeRestart("muffleMessage")
[13:22:57.750]                       }
[13:22:57.750]                       else if (inherits(cond, "warning")) {
[13:22:57.750]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.750]                         if (muffled) 
[13:22:57.750]                           invokeRestart("muffleWarning")
[13:22:57.750]                       }
[13:22:57.750]                       else if (inherits(cond, "condition")) {
[13:22:57.750]                         if (!is.null(pattern)) {
[13:22:57.750]                           computeRestarts <- base::computeRestarts
[13:22:57.750]                           grepl <- base::grepl
[13:22:57.750]                           restarts <- computeRestarts(cond)
[13:22:57.750]                           for (restart in restarts) {
[13:22:57.750]                             name <- restart$name
[13:22:57.750]                             if (is.null(name)) 
[13:22:57.750]                               next
[13:22:57.750]                             if (!grepl(pattern, name)) 
[13:22:57.750]                               next
[13:22:57.750]                             invokeRestart(restart)
[13:22:57.750]                             muffled <- TRUE
[13:22:57.750]                             break
[13:22:57.750]                           }
[13:22:57.750]                         }
[13:22:57.750]                       }
[13:22:57.750]                       invisible(muffled)
[13:22:57.750]                     }
[13:22:57.750]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.750]                   }
[13:22:57.750]                 }
[13:22:57.750]             }
[13:22:57.750]         }))
[13:22:57.750]     }, error = function(ex) {
[13:22:57.750]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.750]                 ...future.rng), started = ...future.startTime, 
[13:22:57.750]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.750]             version = "1.8"), class = "FutureResult")
[13:22:57.750]     }, finally = {
[13:22:57.750]         if (!identical(...future.workdir, getwd())) 
[13:22:57.750]             setwd(...future.workdir)
[13:22:57.750]         {
[13:22:57.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.750]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.750]             }
[13:22:57.750]             base::options(...future.oldOptions)
[13:22:57.750]             if (.Platform$OS.type == "windows") {
[13:22:57.750]                 old_names <- names(...future.oldEnvVars)
[13:22:57.750]                 envs <- base::Sys.getenv()
[13:22:57.750]                 names <- names(envs)
[13:22:57.750]                 common <- intersect(names, old_names)
[13:22:57.750]                 added <- setdiff(names, old_names)
[13:22:57.750]                 removed <- setdiff(old_names, names)
[13:22:57.750]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.750]                   envs[common]]
[13:22:57.750]                 NAMES <- toupper(changed)
[13:22:57.750]                 args <- list()
[13:22:57.750]                 for (kk in seq_along(NAMES)) {
[13:22:57.750]                   name <- changed[[kk]]
[13:22:57.750]                   NAME <- NAMES[[kk]]
[13:22:57.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.750]                     next
[13:22:57.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.750]                 }
[13:22:57.750]                 NAMES <- toupper(added)
[13:22:57.750]                 for (kk in seq_along(NAMES)) {
[13:22:57.750]                   name <- added[[kk]]
[13:22:57.750]                   NAME <- NAMES[[kk]]
[13:22:57.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.750]                     next
[13:22:57.750]                   args[[name]] <- ""
[13:22:57.750]                 }
[13:22:57.750]                 NAMES <- toupper(removed)
[13:22:57.750]                 for (kk in seq_along(NAMES)) {
[13:22:57.750]                   name <- removed[[kk]]
[13:22:57.750]                   NAME <- NAMES[[kk]]
[13:22:57.750]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.750]                     next
[13:22:57.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.750]                 }
[13:22:57.750]                 if (length(args) > 0) 
[13:22:57.750]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.750]             }
[13:22:57.750]             else {
[13:22:57.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.750]             }
[13:22:57.750]             {
[13:22:57.750]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.750]                   0L) {
[13:22:57.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.750]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.750]                   base::options(opts)
[13:22:57.750]                 }
[13:22:57.750]                 {
[13:22:57.750]                   {
[13:22:57.750]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.750]                     NULL
[13:22:57.750]                   }
[13:22:57.750]                   options(future.plan = NULL)
[13:22:57.750]                   if (is.na(NA_character_)) 
[13:22:57.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.750]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.750]                     envir = parent.frame()) 
[13:22:57.750]                   {
[13:22:57.750]                     default_workers <- missing(workers)
[13:22:57.750]                     if (is.function(workers)) 
[13:22:57.750]                       workers <- workers()
[13:22:57.750]                     workers <- structure(as.integer(workers), 
[13:22:57.750]                       class = class(workers))
[13:22:57.750]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.750]                       1L)
[13:22:57.750]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.750]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.750]                       if (default_workers) 
[13:22:57.750]                         supportsMulticore(warn = TRUE)
[13:22:57.750]                       return(sequential(..., envir = envir))
[13:22:57.750]                     }
[13:22:57.750]                     oopts <- options(mc.cores = workers)
[13:22:57.750]                     on.exit(options(oopts))
[13:22:57.750]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.750]                       envir = envir)
[13:22:57.750]                     if (!future$lazy) 
[13:22:57.750]                       future <- run(future)
[13:22:57.750]                     invisible(future)
[13:22:57.750]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.750]                 }
[13:22:57.750]             }
[13:22:57.750]         }
[13:22:57.750]     })
[13:22:57.750]     if (TRUE) {
[13:22:57.750]         base::sink(type = "output", split = FALSE)
[13:22:57.750]         if (TRUE) {
[13:22:57.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.750]         }
[13:22:57.750]         else {
[13:22:57.750]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.750]         }
[13:22:57.750]         base::close(...future.stdout)
[13:22:57.750]         ...future.stdout <- NULL
[13:22:57.750]     }
[13:22:57.750]     ...future.result$conditions <- ...future.conditions
[13:22:57.750]     ...future.result$finished <- base::Sys.time()
[13:22:57.750]     ...future.result
[13:22:57.750] }
[13:22:57.752] assign_globals() ...
[13:22:57.753] List of 1
[13:22:57.753]  $ a: num 1
[13:22:57.753]  - attr(*, "where")=List of 1
[13:22:57.753]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.753]  - attr(*, "resolved")= logi FALSE
[13:22:57.753]  - attr(*, "total_size")= num 56
[13:22:57.753]  - attr(*, "already-done")= logi TRUE
[13:22:57.756] - copied ‘a’ to environment
[13:22:57.756] assign_globals() ... done
[13:22:57.756] requestCore(): workers = 2
[13:22:57.758] MulticoreFuture started
[13:22:57.759] - Launch lazy future ... done
[13:22:57.759] run() for ‘MulticoreFuture’ ... done
[13:22:57.759] result() for MulticoreFuture ...
[13:22:57.760] plan(): Setting new future strategy stack:
[13:22:57.760] List of future strategies:
[13:22:57.760] 1. sequential:
[13:22:57.760]    - args: function (..., envir = parent.frame())
[13:22:57.760]    - tweaked: FALSE
[13:22:57.760]    - call: NULL
[13:22:57.761] plan(): nbrOfWorkers() = 1
[13:22:57.763] plan(): Setting new future strategy stack:
[13:22:57.763] List of future strategies:
[13:22:57.763] 1. multicore:
[13:22:57.763]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.763]    - tweaked: FALSE
[13:22:57.763]    - call: plan(strategy)
[13:22:57.768] plan(): nbrOfWorkers() = 2
[13:22:57.769] result() for MulticoreFuture ...
[13:22:57.769] result() for MulticoreFuture ... done
[13:22:57.770] result() for MulticoreFuture ... done
[13:22:57.770] result() for MulticoreFuture ...
[13:22:57.770] result() for MulticoreFuture ... done
[13:22:57.770] getGlobalsAndPackages() ...
[13:22:57.770] Searching for globals...
[13:22:57.772] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.772] Searching for globals ... DONE
[13:22:57.772] Resolving globals: FALSE
[13:22:57.773] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.773] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.773] - globals: [1] ‘a’
[13:22:57.773] 
[13:22:57.774] getGlobalsAndPackages() ... DONE
[13:22:57.774] run() for ‘Future’ ...
[13:22:57.774] - state: ‘created’
[13:22:57.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.779] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.779]   - Field: ‘label’
[13:22:57.779]   - Field: ‘local’
[13:22:57.779]   - Field: ‘owner’
[13:22:57.779]   - Field: ‘envir’
[13:22:57.779]   - Field: ‘workers’
[13:22:57.780]   - Field: ‘packages’
[13:22:57.780]   - Field: ‘gc’
[13:22:57.780]   - Field: ‘job’
[13:22:57.780]   - Field: ‘conditions’
[13:22:57.780]   - Field: ‘expr’
[13:22:57.780]   - Field: ‘uuid’
[13:22:57.780]   - Field: ‘seed’
[13:22:57.780]   - Field: ‘version’
[13:22:57.781]   - Field: ‘result’
[13:22:57.781]   - Field: ‘asynchronous’
[13:22:57.781]   - Field: ‘calls’
[13:22:57.781]   - Field: ‘globals’
[13:22:57.781]   - Field: ‘stdout’
[13:22:57.781]   - Field: ‘earlySignal’
[13:22:57.781]   - Field: ‘lazy’
[13:22:57.781]   - Field: ‘state’
[13:22:57.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.782] - Launch lazy future ...
[13:22:57.782] Packages needed by the future expression (n = 0): <none>
[13:22:57.782] Packages needed by future strategies (n = 0): <none>
[13:22:57.783] {
[13:22:57.783]     {
[13:22:57.783]         {
[13:22:57.783]             ...future.startTime <- base::Sys.time()
[13:22:57.783]             {
[13:22:57.783]                 {
[13:22:57.783]                   {
[13:22:57.783]                     {
[13:22:57.783]                       base::local({
[13:22:57.783]                         has_future <- base::requireNamespace("future", 
[13:22:57.783]                           quietly = TRUE)
[13:22:57.783]                         if (has_future) {
[13:22:57.783]                           ns <- base::getNamespace("future")
[13:22:57.783]                           version <- ns[[".package"]][["version"]]
[13:22:57.783]                           if (is.null(version)) 
[13:22:57.783]                             version <- utils::packageVersion("future")
[13:22:57.783]                         }
[13:22:57.783]                         else {
[13:22:57.783]                           version <- NULL
[13:22:57.783]                         }
[13:22:57.783]                         if (!has_future || version < "1.8.0") {
[13:22:57.783]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.783]                             "", base::R.version$version.string), 
[13:22:57.783]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.783]                               "release", "version")], collapse = " "), 
[13:22:57.783]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.783]                             info)
[13:22:57.783]                           info <- base::paste(info, collapse = "; ")
[13:22:57.783]                           if (!has_future) {
[13:22:57.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.783]                               info)
[13:22:57.783]                           }
[13:22:57.783]                           else {
[13:22:57.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.783]                               info, version)
[13:22:57.783]                           }
[13:22:57.783]                           base::stop(msg)
[13:22:57.783]                         }
[13:22:57.783]                       })
[13:22:57.783]                     }
[13:22:57.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.783]                     base::options(mc.cores = 1L)
[13:22:57.783]                   }
[13:22:57.783]                   options(future.plan = NULL)
[13:22:57.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.783]                 }
[13:22:57.783]                 ...future.workdir <- getwd()
[13:22:57.783]             }
[13:22:57.783]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.783]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.783]         }
[13:22:57.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.783]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.783]             base::names(...future.oldOptions))
[13:22:57.783]     }
[13:22:57.783]     if (FALSE) {
[13:22:57.783]     }
[13:22:57.783]     else {
[13:22:57.783]         if (TRUE) {
[13:22:57.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.783]                 open = "w")
[13:22:57.783]         }
[13:22:57.783]         else {
[13:22:57.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.783]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.783]         }
[13:22:57.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.783]             base::sink(type = "output", split = FALSE)
[13:22:57.783]             base::close(...future.stdout)
[13:22:57.783]         }, add = TRUE)
[13:22:57.783]     }
[13:22:57.783]     ...future.frame <- base::sys.nframe()
[13:22:57.783]     ...future.conditions <- base::list()
[13:22:57.783]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.783]     if (FALSE) {
[13:22:57.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.783]     }
[13:22:57.783]     ...future.result <- base::tryCatch({
[13:22:57.783]         base::withCallingHandlers({
[13:22:57.783]             ...future.value <- base::withVisible(base::local({
[13:22:57.783]                 withCallingHandlers({
[13:22:57.783]                   {
[13:22:57.783]                     2 * a
[13:22:57.783]                   }
[13:22:57.783]                 }, immediateCondition = function(cond) {
[13:22:57.783]                   save_rds <- function (object, pathname, ...) 
[13:22:57.783]                   {
[13:22:57.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.783]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.783]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.783]                         fi_tmp[["mtime"]])
[13:22:57.783]                     }
[13:22:57.783]                     tryCatch({
[13:22:57.783]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.783]                     }, error = function(ex) {
[13:22:57.783]                       msg <- conditionMessage(ex)
[13:22:57.783]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.783]                         fi_tmp[["mtime"]], msg)
[13:22:57.783]                       ex$message <- msg
[13:22:57.783]                       stop(ex)
[13:22:57.783]                     })
[13:22:57.783]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.783]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.783]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.783]                       fi <- file.info(pathname)
[13:22:57.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.783]                         fi[["size"]], fi[["mtime"]])
[13:22:57.783]                       stop(msg)
[13:22:57.783]                     }
[13:22:57.783]                     invisible(pathname)
[13:22:57.783]                   }
[13:22:57.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.783]                     rootPath = tempdir()) 
[13:22:57.783]                   {
[13:22:57.783]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.783]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.783]                       tmpdir = path, fileext = ".rds")
[13:22:57.783]                     save_rds(obj, file)
[13:22:57.783]                   }
[13:22:57.783]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.783]                   {
[13:22:57.783]                     inherits <- base::inherits
[13:22:57.783]                     invokeRestart <- base::invokeRestart
[13:22:57.783]                     is.null <- base::is.null
[13:22:57.783]                     muffled <- FALSE
[13:22:57.783]                     if (inherits(cond, "message")) {
[13:22:57.783]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.783]                       if (muffled) 
[13:22:57.783]                         invokeRestart("muffleMessage")
[13:22:57.783]                     }
[13:22:57.783]                     else if (inherits(cond, "warning")) {
[13:22:57.783]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.783]                       if (muffled) 
[13:22:57.783]                         invokeRestart("muffleWarning")
[13:22:57.783]                     }
[13:22:57.783]                     else if (inherits(cond, "condition")) {
[13:22:57.783]                       if (!is.null(pattern)) {
[13:22:57.783]                         computeRestarts <- base::computeRestarts
[13:22:57.783]                         grepl <- base::grepl
[13:22:57.783]                         restarts <- computeRestarts(cond)
[13:22:57.783]                         for (restart in restarts) {
[13:22:57.783]                           name <- restart$name
[13:22:57.783]                           if (is.null(name)) 
[13:22:57.783]                             next
[13:22:57.783]                           if (!grepl(pattern, name)) 
[13:22:57.783]                             next
[13:22:57.783]                           invokeRestart(restart)
[13:22:57.783]                           muffled <- TRUE
[13:22:57.783]                           break
[13:22:57.783]                         }
[13:22:57.783]                       }
[13:22:57.783]                     }
[13:22:57.783]                     invisible(muffled)
[13:22:57.783]                   }
[13:22:57.783]                   muffleCondition(cond)
[13:22:57.783]                 })
[13:22:57.783]             }))
[13:22:57.783]             future::FutureResult(value = ...future.value$value, 
[13:22:57.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.783]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.783]                     ...future.globalenv.names))
[13:22:57.783]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.783]         }, condition = base::local({
[13:22:57.783]             c <- base::c
[13:22:57.783]             inherits <- base::inherits
[13:22:57.783]             invokeRestart <- base::invokeRestart
[13:22:57.783]             length <- base::length
[13:22:57.783]             list <- base::list
[13:22:57.783]             seq.int <- base::seq.int
[13:22:57.783]             signalCondition <- base::signalCondition
[13:22:57.783]             sys.calls <- base::sys.calls
[13:22:57.783]             `[[` <- base::`[[`
[13:22:57.783]             `+` <- base::`+`
[13:22:57.783]             `<<-` <- base::`<<-`
[13:22:57.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.783]                   3L)]
[13:22:57.783]             }
[13:22:57.783]             function(cond) {
[13:22:57.783]                 is_error <- inherits(cond, "error")
[13:22:57.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.783]                   NULL)
[13:22:57.783]                 if (is_error) {
[13:22:57.783]                   sessionInformation <- function() {
[13:22:57.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.783]                       search = base::search(), system = base::Sys.info())
[13:22:57.783]                   }
[13:22:57.783]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.783]                     cond$call), session = sessionInformation(), 
[13:22:57.783]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.783]                   signalCondition(cond)
[13:22:57.783]                 }
[13:22:57.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.783]                 "immediateCondition"))) {
[13:22:57.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.783]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.783]                   if (TRUE && !signal) {
[13:22:57.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.783]                     {
[13:22:57.783]                       inherits <- base::inherits
[13:22:57.783]                       invokeRestart <- base::invokeRestart
[13:22:57.783]                       is.null <- base::is.null
[13:22:57.783]                       muffled <- FALSE
[13:22:57.783]                       if (inherits(cond, "message")) {
[13:22:57.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.783]                         if (muffled) 
[13:22:57.783]                           invokeRestart("muffleMessage")
[13:22:57.783]                       }
[13:22:57.783]                       else if (inherits(cond, "warning")) {
[13:22:57.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.783]                         if (muffled) 
[13:22:57.783]                           invokeRestart("muffleWarning")
[13:22:57.783]                       }
[13:22:57.783]                       else if (inherits(cond, "condition")) {
[13:22:57.783]                         if (!is.null(pattern)) {
[13:22:57.783]                           computeRestarts <- base::computeRestarts
[13:22:57.783]                           grepl <- base::grepl
[13:22:57.783]                           restarts <- computeRestarts(cond)
[13:22:57.783]                           for (restart in restarts) {
[13:22:57.783]                             name <- restart$name
[13:22:57.783]                             if (is.null(name)) 
[13:22:57.783]                               next
[13:22:57.783]                             if (!grepl(pattern, name)) 
[13:22:57.783]                               next
[13:22:57.783]                             invokeRestart(restart)
[13:22:57.783]                             muffled <- TRUE
[13:22:57.783]                             break
[13:22:57.783]                           }
[13:22:57.783]                         }
[13:22:57.783]                       }
[13:22:57.783]                       invisible(muffled)
[13:22:57.783]                     }
[13:22:57.783]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.783]                   }
[13:22:57.783]                 }
[13:22:57.783]                 else {
[13:22:57.783]                   if (TRUE) {
[13:22:57.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.783]                     {
[13:22:57.783]                       inherits <- base::inherits
[13:22:57.783]                       invokeRestart <- base::invokeRestart
[13:22:57.783]                       is.null <- base::is.null
[13:22:57.783]                       muffled <- FALSE
[13:22:57.783]                       if (inherits(cond, "message")) {
[13:22:57.783]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.783]                         if (muffled) 
[13:22:57.783]                           invokeRestart("muffleMessage")
[13:22:57.783]                       }
[13:22:57.783]                       else if (inherits(cond, "warning")) {
[13:22:57.783]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.783]                         if (muffled) 
[13:22:57.783]                           invokeRestart("muffleWarning")
[13:22:57.783]                       }
[13:22:57.783]                       else if (inherits(cond, "condition")) {
[13:22:57.783]                         if (!is.null(pattern)) {
[13:22:57.783]                           computeRestarts <- base::computeRestarts
[13:22:57.783]                           grepl <- base::grepl
[13:22:57.783]                           restarts <- computeRestarts(cond)
[13:22:57.783]                           for (restart in restarts) {
[13:22:57.783]                             name <- restart$name
[13:22:57.783]                             if (is.null(name)) 
[13:22:57.783]                               next
[13:22:57.783]                             if (!grepl(pattern, name)) 
[13:22:57.783]                               next
[13:22:57.783]                             invokeRestart(restart)
[13:22:57.783]                             muffled <- TRUE
[13:22:57.783]                             break
[13:22:57.783]                           }
[13:22:57.783]                         }
[13:22:57.783]                       }
[13:22:57.783]                       invisible(muffled)
[13:22:57.783]                     }
[13:22:57.783]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.783]                   }
[13:22:57.783]                 }
[13:22:57.783]             }
[13:22:57.783]         }))
[13:22:57.783]     }, error = function(ex) {
[13:22:57.783]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.783]                 ...future.rng), started = ...future.startTime, 
[13:22:57.783]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.783]             version = "1.8"), class = "FutureResult")
[13:22:57.783]     }, finally = {
[13:22:57.783]         if (!identical(...future.workdir, getwd())) 
[13:22:57.783]             setwd(...future.workdir)
[13:22:57.783]         {
[13:22:57.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.783]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.783]             }
[13:22:57.783]             base::options(...future.oldOptions)
[13:22:57.783]             if (.Platform$OS.type == "windows") {
[13:22:57.783]                 old_names <- names(...future.oldEnvVars)
[13:22:57.783]                 envs <- base::Sys.getenv()
[13:22:57.783]                 names <- names(envs)
[13:22:57.783]                 common <- intersect(names, old_names)
[13:22:57.783]                 added <- setdiff(names, old_names)
[13:22:57.783]                 removed <- setdiff(old_names, names)
[13:22:57.783]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.783]                   envs[common]]
[13:22:57.783]                 NAMES <- toupper(changed)
[13:22:57.783]                 args <- list()
[13:22:57.783]                 for (kk in seq_along(NAMES)) {
[13:22:57.783]                   name <- changed[[kk]]
[13:22:57.783]                   NAME <- NAMES[[kk]]
[13:22:57.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.783]                     next
[13:22:57.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.783]                 }
[13:22:57.783]                 NAMES <- toupper(added)
[13:22:57.783]                 for (kk in seq_along(NAMES)) {
[13:22:57.783]                   name <- added[[kk]]
[13:22:57.783]                   NAME <- NAMES[[kk]]
[13:22:57.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.783]                     next
[13:22:57.783]                   args[[name]] <- ""
[13:22:57.783]                 }
[13:22:57.783]                 NAMES <- toupper(removed)
[13:22:57.783]                 for (kk in seq_along(NAMES)) {
[13:22:57.783]                   name <- removed[[kk]]
[13:22:57.783]                   NAME <- NAMES[[kk]]
[13:22:57.783]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.783]                     next
[13:22:57.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.783]                 }
[13:22:57.783]                 if (length(args) > 0) 
[13:22:57.783]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.783]             }
[13:22:57.783]             else {
[13:22:57.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.783]             }
[13:22:57.783]             {
[13:22:57.783]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.783]                   0L) {
[13:22:57.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.783]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.783]                   base::options(opts)
[13:22:57.783]                 }
[13:22:57.783]                 {
[13:22:57.783]                   {
[13:22:57.783]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.783]                     NULL
[13:22:57.783]                   }
[13:22:57.783]                   options(future.plan = NULL)
[13:22:57.783]                   if (is.na(NA_character_)) 
[13:22:57.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.783]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.783]                     envir = parent.frame()) 
[13:22:57.783]                   {
[13:22:57.783]                     default_workers <- missing(workers)
[13:22:57.783]                     if (is.function(workers)) 
[13:22:57.783]                       workers <- workers()
[13:22:57.783]                     workers <- structure(as.integer(workers), 
[13:22:57.783]                       class = class(workers))
[13:22:57.783]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.783]                       1L)
[13:22:57.783]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.783]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.783]                       if (default_workers) 
[13:22:57.783]                         supportsMulticore(warn = TRUE)
[13:22:57.783]                       return(sequential(..., envir = envir))
[13:22:57.783]                     }
[13:22:57.783]                     oopts <- options(mc.cores = workers)
[13:22:57.783]                     on.exit(options(oopts))
[13:22:57.783]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.783]                       envir = envir)
[13:22:57.783]                     if (!future$lazy) 
[13:22:57.783]                       future <- run(future)
[13:22:57.783]                     invisible(future)
[13:22:57.783]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.783]                 }
[13:22:57.783]             }
[13:22:57.783]         }
[13:22:57.783]     })
[13:22:57.783]     if (TRUE) {
[13:22:57.783]         base::sink(type = "output", split = FALSE)
[13:22:57.783]         if (TRUE) {
[13:22:57.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.783]         }
[13:22:57.783]         else {
[13:22:57.783]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.783]         }
[13:22:57.783]         base::close(...future.stdout)
[13:22:57.783]         ...future.stdout <- NULL
[13:22:57.783]     }
[13:22:57.783]     ...future.result$conditions <- ...future.conditions
[13:22:57.783]     ...future.result$finished <- base::Sys.time()
[13:22:57.783]     ...future.result
[13:22:57.783] }
[13:22:57.786] assign_globals() ...
[13:22:57.786] List of 1
[13:22:57.786]  $ a: num 1
[13:22:57.786]  - attr(*, "where")=List of 1
[13:22:57.786]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.786]  - attr(*, "resolved")= logi FALSE
[13:22:57.786]  - attr(*, "total_size")= num 56
[13:22:57.786]  - attr(*, "already-done")= logi TRUE
[13:22:57.790] - copied ‘a’ to environment
[13:22:57.790] assign_globals() ... done
[13:22:57.790] requestCore(): workers = 2
[13:22:57.793] MulticoreFuture started
[13:22:57.793] - Launch lazy future ... done
[13:22:57.793] run() for ‘MulticoreFuture’ ... done
[13:22:57.794] result() for MulticoreFuture ...
[13:22:57.794] plan(): Setting new future strategy stack:
[13:22:57.794] List of future strategies:
[13:22:57.794] 1. sequential:
[13:22:57.794]    - args: function (..., envir = parent.frame())
[13:22:57.794]    - tweaked: FALSE
[13:22:57.794]    - call: NULL
[13:22:57.795] plan(): nbrOfWorkers() = 1
[13:22:57.797] plan(): Setting new future strategy stack:
[13:22:57.797] List of future strategies:
[13:22:57.797] 1. multicore:
[13:22:57.797]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.797]    - tweaked: FALSE
[13:22:57.797]    - call: plan(strategy)
[13:22:57.808] plan(): nbrOfWorkers() = 2
[13:22:57.809] result() for MulticoreFuture ...
[13:22:57.809] result() for MulticoreFuture ... done
[13:22:57.809] result() for MulticoreFuture ... done
[13:22:57.810] result() for MulticoreFuture ...
[13:22:57.810] result() for MulticoreFuture ... done
[13:22:57.810] getGlobalsAndPackages() ...
[13:22:57.810] Searching for globals...
[13:22:57.815] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.815] Searching for globals ... DONE
[13:22:57.816] Resolving globals: FALSE
[13:22:57.816] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.817] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.817] - globals: [1] ‘a’
[13:22:57.817] 
[13:22:57.817] getGlobalsAndPackages() ... DONE
[13:22:57.818] run() for ‘Future’ ...
[13:22:57.818] - state: ‘created’
[13:22:57.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.822] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.823]   - Field: ‘label’
[13:22:57.823]   - Field: ‘local’
[13:22:57.823]   - Field: ‘owner’
[13:22:57.823]   - Field: ‘envir’
[13:22:57.823]   - Field: ‘workers’
[13:22:57.823]   - Field: ‘packages’
[13:22:57.823]   - Field: ‘gc’
[13:22:57.824]   - Field: ‘job’
[13:22:57.824]   - Field: ‘conditions’
[13:22:57.824]   - Field: ‘expr’
[13:22:57.824]   - Field: ‘uuid’
[13:22:57.824]   - Field: ‘seed’
[13:22:57.824]   - Field: ‘version’
[13:22:57.824]   - Field: ‘result’
[13:22:57.825]   - Field: ‘asynchronous’
[13:22:57.825]   - Field: ‘calls’
[13:22:57.825]   - Field: ‘globals’
[13:22:57.825]   - Field: ‘stdout’
[13:22:57.825]   - Field: ‘earlySignal’
[13:22:57.825]   - Field: ‘lazy’
[13:22:57.825]   - Field: ‘state’
[13:22:57.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.825] - Launch lazy future ...
[13:22:57.826] Packages needed by the future expression (n = 0): <none>
[13:22:57.826] Packages needed by future strategies (n = 0): <none>
[13:22:57.827] {
[13:22:57.827]     {
[13:22:57.827]         {
[13:22:57.827]             ...future.startTime <- base::Sys.time()
[13:22:57.827]             {
[13:22:57.827]                 {
[13:22:57.827]                   {
[13:22:57.827]                     {
[13:22:57.827]                       base::local({
[13:22:57.827]                         has_future <- base::requireNamespace("future", 
[13:22:57.827]                           quietly = TRUE)
[13:22:57.827]                         if (has_future) {
[13:22:57.827]                           ns <- base::getNamespace("future")
[13:22:57.827]                           version <- ns[[".package"]][["version"]]
[13:22:57.827]                           if (is.null(version)) 
[13:22:57.827]                             version <- utils::packageVersion("future")
[13:22:57.827]                         }
[13:22:57.827]                         else {
[13:22:57.827]                           version <- NULL
[13:22:57.827]                         }
[13:22:57.827]                         if (!has_future || version < "1.8.0") {
[13:22:57.827]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.827]                             "", base::R.version$version.string), 
[13:22:57.827]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.827]                               "release", "version")], collapse = " "), 
[13:22:57.827]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.827]                             info)
[13:22:57.827]                           info <- base::paste(info, collapse = "; ")
[13:22:57.827]                           if (!has_future) {
[13:22:57.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.827]                               info)
[13:22:57.827]                           }
[13:22:57.827]                           else {
[13:22:57.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.827]                               info, version)
[13:22:57.827]                           }
[13:22:57.827]                           base::stop(msg)
[13:22:57.827]                         }
[13:22:57.827]                       })
[13:22:57.827]                     }
[13:22:57.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.827]                     base::options(mc.cores = 1L)
[13:22:57.827]                   }
[13:22:57.827]                   options(future.plan = NULL)
[13:22:57.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.827]                 }
[13:22:57.827]                 ...future.workdir <- getwd()
[13:22:57.827]             }
[13:22:57.827]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.827]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.827]         }
[13:22:57.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.827]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.827]             base::names(...future.oldOptions))
[13:22:57.827]     }
[13:22:57.827]     if (FALSE) {
[13:22:57.827]     }
[13:22:57.827]     else {
[13:22:57.827]         if (TRUE) {
[13:22:57.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.827]                 open = "w")
[13:22:57.827]         }
[13:22:57.827]         else {
[13:22:57.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.827]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.827]         }
[13:22:57.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.827]             base::sink(type = "output", split = FALSE)
[13:22:57.827]             base::close(...future.stdout)
[13:22:57.827]         }, add = TRUE)
[13:22:57.827]     }
[13:22:57.827]     ...future.frame <- base::sys.nframe()
[13:22:57.827]     ...future.conditions <- base::list()
[13:22:57.827]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.827]     if (FALSE) {
[13:22:57.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.827]     }
[13:22:57.827]     ...future.result <- base::tryCatch({
[13:22:57.827]         base::withCallingHandlers({
[13:22:57.827]             ...future.value <- base::withVisible(base::local({
[13:22:57.827]                 withCallingHandlers({
[13:22:57.827]                   {
[13:22:57.827]                     2 * a
[13:22:57.827]                   }
[13:22:57.827]                 }, immediateCondition = function(cond) {
[13:22:57.827]                   save_rds <- function (object, pathname, ...) 
[13:22:57.827]                   {
[13:22:57.827]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.827]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.827]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.827]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.827]                         fi_tmp[["mtime"]])
[13:22:57.827]                     }
[13:22:57.827]                     tryCatch({
[13:22:57.827]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.827]                     }, error = function(ex) {
[13:22:57.827]                       msg <- conditionMessage(ex)
[13:22:57.827]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.827]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.827]                         fi_tmp[["mtime"]], msg)
[13:22:57.827]                       ex$message <- msg
[13:22:57.827]                       stop(ex)
[13:22:57.827]                     })
[13:22:57.827]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.827]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.827]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.827]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.827]                       fi <- file.info(pathname)
[13:22:57.827]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.827]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.827]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.827]                         fi[["size"]], fi[["mtime"]])
[13:22:57.827]                       stop(msg)
[13:22:57.827]                     }
[13:22:57.827]                     invisible(pathname)
[13:22:57.827]                   }
[13:22:57.827]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.827]                     rootPath = tempdir()) 
[13:22:57.827]                   {
[13:22:57.827]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.827]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.827]                       tmpdir = path, fileext = ".rds")
[13:22:57.827]                     save_rds(obj, file)
[13:22:57.827]                   }
[13:22:57.827]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.827]                   {
[13:22:57.827]                     inherits <- base::inherits
[13:22:57.827]                     invokeRestart <- base::invokeRestart
[13:22:57.827]                     is.null <- base::is.null
[13:22:57.827]                     muffled <- FALSE
[13:22:57.827]                     if (inherits(cond, "message")) {
[13:22:57.827]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.827]                       if (muffled) 
[13:22:57.827]                         invokeRestart("muffleMessage")
[13:22:57.827]                     }
[13:22:57.827]                     else if (inherits(cond, "warning")) {
[13:22:57.827]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.827]                       if (muffled) 
[13:22:57.827]                         invokeRestart("muffleWarning")
[13:22:57.827]                     }
[13:22:57.827]                     else if (inherits(cond, "condition")) {
[13:22:57.827]                       if (!is.null(pattern)) {
[13:22:57.827]                         computeRestarts <- base::computeRestarts
[13:22:57.827]                         grepl <- base::grepl
[13:22:57.827]                         restarts <- computeRestarts(cond)
[13:22:57.827]                         for (restart in restarts) {
[13:22:57.827]                           name <- restart$name
[13:22:57.827]                           if (is.null(name)) 
[13:22:57.827]                             next
[13:22:57.827]                           if (!grepl(pattern, name)) 
[13:22:57.827]                             next
[13:22:57.827]                           invokeRestart(restart)
[13:22:57.827]                           muffled <- TRUE
[13:22:57.827]                           break
[13:22:57.827]                         }
[13:22:57.827]                       }
[13:22:57.827]                     }
[13:22:57.827]                     invisible(muffled)
[13:22:57.827]                   }
[13:22:57.827]                   muffleCondition(cond)
[13:22:57.827]                 })
[13:22:57.827]             }))
[13:22:57.827]             future::FutureResult(value = ...future.value$value, 
[13:22:57.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.827]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.827]                     ...future.globalenv.names))
[13:22:57.827]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.827]         }, condition = base::local({
[13:22:57.827]             c <- base::c
[13:22:57.827]             inherits <- base::inherits
[13:22:57.827]             invokeRestart <- base::invokeRestart
[13:22:57.827]             length <- base::length
[13:22:57.827]             list <- base::list
[13:22:57.827]             seq.int <- base::seq.int
[13:22:57.827]             signalCondition <- base::signalCondition
[13:22:57.827]             sys.calls <- base::sys.calls
[13:22:57.827]             `[[` <- base::`[[`
[13:22:57.827]             `+` <- base::`+`
[13:22:57.827]             `<<-` <- base::`<<-`
[13:22:57.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.827]                   3L)]
[13:22:57.827]             }
[13:22:57.827]             function(cond) {
[13:22:57.827]                 is_error <- inherits(cond, "error")
[13:22:57.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.827]                   NULL)
[13:22:57.827]                 if (is_error) {
[13:22:57.827]                   sessionInformation <- function() {
[13:22:57.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.827]                       search = base::search(), system = base::Sys.info())
[13:22:57.827]                   }
[13:22:57.827]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.827]                     cond$call), session = sessionInformation(), 
[13:22:57.827]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.827]                   signalCondition(cond)
[13:22:57.827]                 }
[13:22:57.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.827]                 "immediateCondition"))) {
[13:22:57.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.827]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.827]                   if (TRUE && !signal) {
[13:22:57.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.827]                     {
[13:22:57.827]                       inherits <- base::inherits
[13:22:57.827]                       invokeRestart <- base::invokeRestart
[13:22:57.827]                       is.null <- base::is.null
[13:22:57.827]                       muffled <- FALSE
[13:22:57.827]                       if (inherits(cond, "message")) {
[13:22:57.827]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.827]                         if (muffled) 
[13:22:57.827]                           invokeRestart("muffleMessage")
[13:22:57.827]                       }
[13:22:57.827]                       else if (inherits(cond, "warning")) {
[13:22:57.827]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.827]                         if (muffled) 
[13:22:57.827]                           invokeRestart("muffleWarning")
[13:22:57.827]                       }
[13:22:57.827]                       else if (inherits(cond, "condition")) {
[13:22:57.827]                         if (!is.null(pattern)) {
[13:22:57.827]                           computeRestarts <- base::computeRestarts
[13:22:57.827]                           grepl <- base::grepl
[13:22:57.827]                           restarts <- computeRestarts(cond)
[13:22:57.827]                           for (restart in restarts) {
[13:22:57.827]                             name <- restart$name
[13:22:57.827]                             if (is.null(name)) 
[13:22:57.827]                               next
[13:22:57.827]                             if (!grepl(pattern, name)) 
[13:22:57.827]                               next
[13:22:57.827]                             invokeRestart(restart)
[13:22:57.827]                             muffled <- TRUE
[13:22:57.827]                             break
[13:22:57.827]                           }
[13:22:57.827]                         }
[13:22:57.827]                       }
[13:22:57.827]                       invisible(muffled)
[13:22:57.827]                     }
[13:22:57.827]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.827]                   }
[13:22:57.827]                 }
[13:22:57.827]                 else {
[13:22:57.827]                   if (TRUE) {
[13:22:57.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.827]                     {
[13:22:57.827]                       inherits <- base::inherits
[13:22:57.827]                       invokeRestart <- base::invokeRestart
[13:22:57.827]                       is.null <- base::is.null
[13:22:57.827]                       muffled <- FALSE
[13:22:57.827]                       if (inherits(cond, "message")) {
[13:22:57.827]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.827]                         if (muffled) 
[13:22:57.827]                           invokeRestart("muffleMessage")
[13:22:57.827]                       }
[13:22:57.827]                       else if (inherits(cond, "warning")) {
[13:22:57.827]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.827]                         if (muffled) 
[13:22:57.827]                           invokeRestart("muffleWarning")
[13:22:57.827]                       }
[13:22:57.827]                       else if (inherits(cond, "condition")) {
[13:22:57.827]                         if (!is.null(pattern)) {
[13:22:57.827]                           computeRestarts <- base::computeRestarts
[13:22:57.827]                           grepl <- base::grepl
[13:22:57.827]                           restarts <- computeRestarts(cond)
[13:22:57.827]                           for (restart in restarts) {
[13:22:57.827]                             name <- restart$name
[13:22:57.827]                             if (is.null(name)) 
[13:22:57.827]                               next
[13:22:57.827]                             if (!grepl(pattern, name)) 
[13:22:57.827]                               next
[13:22:57.827]                             invokeRestart(restart)
[13:22:57.827]                             muffled <- TRUE
[13:22:57.827]                             break
[13:22:57.827]                           }
[13:22:57.827]                         }
[13:22:57.827]                       }
[13:22:57.827]                       invisible(muffled)
[13:22:57.827]                     }
[13:22:57.827]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.827]                   }
[13:22:57.827]                 }
[13:22:57.827]             }
[13:22:57.827]         }))
[13:22:57.827]     }, error = function(ex) {
[13:22:57.827]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.827]                 ...future.rng), started = ...future.startTime, 
[13:22:57.827]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.827]             version = "1.8"), class = "FutureResult")
[13:22:57.827]     }, finally = {
[13:22:57.827]         if (!identical(...future.workdir, getwd())) 
[13:22:57.827]             setwd(...future.workdir)
[13:22:57.827]         {
[13:22:57.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.827]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.827]             }
[13:22:57.827]             base::options(...future.oldOptions)
[13:22:57.827]             if (.Platform$OS.type == "windows") {
[13:22:57.827]                 old_names <- names(...future.oldEnvVars)
[13:22:57.827]                 envs <- base::Sys.getenv()
[13:22:57.827]                 names <- names(envs)
[13:22:57.827]                 common <- intersect(names, old_names)
[13:22:57.827]                 added <- setdiff(names, old_names)
[13:22:57.827]                 removed <- setdiff(old_names, names)
[13:22:57.827]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.827]                   envs[common]]
[13:22:57.827]                 NAMES <- toupper(changed)
[13:22:57.827]                 args <- list()
[13:22:57.827]                 for (kk in seq_along(NAMES)) {
[13:22:57.827]                   name <- changed[[kk]]
[13:22:57.827]                   NAME <- NAMES[[kk]]
[13:22:57.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.827]                     next
[13:22:57.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.827]                 }
[13:22:57.827]                 NAMES <- toupper(added)
[13:22:57.827]                 for (kk in seq_along(NAMES)) {
[13:22:57.827]                   name <- added[[kk]]
[13:22:57.827]                   NAME <- NAMES[[kk]]
[13:22:57.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.827]                     next
[13:22:57.827]                   args[[name]] <- ""
[13:22:57.827]                 }
[13:22:57.827]                 NAMES <- toupper(removed)
[13:22:57.827]                 for (kk in seq_along(NAMES)) {
[13:22:57.827]                   name <- removed[[kk]]
[13:22:57.827]                   NAME <- NAMES[[kk]]
[13:22:57.827]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.827]                     next
[13:22:57.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.827]                 }
[13:22:57.827]                 if (length(args) > 0) 
[13:22:57.827]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.827]             }
[13:22:57.827]             else {
[13:22:57.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.827]             }
[13:22:57.827]             {
[13:22:57.827]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.827]                   0L) {
[13:22:57.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.827]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.827]                   base::options(opts)
[13:22:57.827]                 }
[13:22:57.827]                 {
[13:22:57.827]                   {
[13:22:57.827]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.827]                     NULL
[13:22:57.827]                   }
[13:22:57.827]                   options(future.plan = NULL)
[13:22:57.827]                   if (is.na(NA_character_)) 
[13:22:57.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.827]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.827]                     envir = parent.frame()) 
[13:22:57.827]                   {
[13:22:57.827]                     default_workers <- missing(workers)
[13:22:57.827]                     if (is.function(workers)) 
[13:22:57.827]                       workers <- workers()
[13:22:57.827]                     workers <- structure(as.integer(workers), 
[13:22:57.827]                       class = class(workers))
[13:22:57.827]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.827]                       1L)
[13:22:57.827]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.827]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.827]                       if (default_workers) 
[13:22:57.827]                         supportsMulticore(warn = TRUE)
[13:22:57.827]                       return(sequential(..., envir = envir))
[13:22:57.827]                     }
[13:22:57.827]                     oopts <- options(mc.cores = workers)
[13:22:57.827]                     on.exit(options(oopts))
[13:22:57.827]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.827]                       envir = envir)
[13:22:57.827]                     if (!future$lazy) 
[13:22:57.827]                       future <- run(future)
[13:22:57.827]                     invisible(future)
[13:22:57.827]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.827]                 }
[13:22:57.827]             }
[13:22:57.827]         }
[13:22:57.827]     })
[13:22:57.827]     if (TRUE) {
[13:22:57.827]         base::sink(type = "output", split = FALSE)
[13:22:57.827]         if (TRUE) {
[13:22:57.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.827]         }
[13:22:57.827]         else {
[13:22:57.827]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.827]         }
[13:22:57.827]         base::close(...future.stdout)
[13:22:57.827]         ...future.stdout <- NULL
[13:22:57.827]     }
[13:22:57.827]     ...future.result$conditions <- ...future.conditions
[13:22:57.827]     ...future.result$finished <- base::Sys.time()
[13:22:57.827]     ...future.result
[13:22:57.827] }
[13:22:57.829] assign_globals() ...
[13:22:57.829] List of 1
[13:22:57.829]  $ a: num 1
[13:22:57.829]  - attr(*, "where")=List of 1
[13:22:57.829]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.829]  - attr(*, "resolved")= logi FALSE
[13:22:57.829]  - attr(*, "total_size")= num 56
[13:22:57.829]  - attr(*, "already-done")= logi TRUE
[13:22:57.833] - copied ‘a’ to environment
[13:22:57.833] assign_globals() ... done
[13:22:57.833] requestCore(): workers = 2
[13:22:57.835] MulticoreFuture started
[13:22:57.836] - Launch lazy future ... done
[13:22:57.836] run() for ‘MulticoreFuture’ ... done
[13:22:57.836] result() for MulticoreFuture ...
[13:22:57.836] plan(): Setting new future strategy stack:
[13:22:57.837] List of future strategies:
[13:22:57.837] 1. sequential:
[13:22:57.837]    - args: function (..., envir = parent.frame())
[13:22:57.837]    - tweaked: FALSE
[13:22:57.837]    - call: NULL
[13:22:57.837] plan(): nbrOfWorkers() = 1
[13:22:57.839] plan(): Setting new future strategy stack:
[13:22:57.840] List of future strategies:
[13:22:57.840] 1. multicore:
[13:22:57.840]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.840]    - tweaked: FALSE
[13:22:57.840]    - call: plan(strategy)
[13:22:57.845] plan(): nbrOfWorkers() = 2
[13:22:57.846] result() for MulticoreFuture ...
[13:22:57.846] result() for MulticoreFuture ... done
[13:22:57.846] result() for MulticoreFuture ... done
[13:22:57.847] result() for MulticoreFuture ...
[13:22:57.847] result() for MulticoreFuture ... done
[13:22:57.847] getGlobalsAndPackages() ...
[13:22:57.847] Searching for globals...
[13:22:57.849] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.849] Searching for globals ... DONE
[13:22:57.849] Resolving globals: FALSE
[13:22:57.850] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.851] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.851] - globals: [1] ‘a’
[13:22:57.851] 
[13:22:57.851] getGlobalsAndPackages() ... DONE
[13:22:57.851] run() for ‘Future’ ...
[13:22:57.852] - state: ‘created’
[13:22:57.852] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.856] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.856] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.856]   - Field: ‘label’
[13:22:57.857]   - Field: ‘local’
[13:22:57.857]   - Field: ‘owner’
[13:22:57.857]   - Field: ‘envir’
[13:22:57.857]   - Field: ‘workers’
[13:22:57.857]   - Field: ‘packages’
[13:22:57.857]   - Field: ‘gc’
[13:22:57.857]   - Field: ‘job’
[13:22:57.857]   - Field: ‘conditions’
[13:22:57.858]   - Field: ‘expr’
[13:22:57.858]   - Field: ‘uuid’
[13:22:57.858]   - Field: ‘seed’
[13:22:57.858]   - Field: ‘version’
[13:22:57.858]   - Field: ‘result’
[13:22:57.858]   - Field: ‘asynchronous’
[13:22:57.858]   - Field: ‘calls’
[13:22:57.858]   - Field: ‘globals’
[13:22:57.858]   - Field: ‘stdout’
[13:22:57.859]   - Field: ‘earlySignal’
[13:22:57.859]   - Field: ‘lazy’
[13:22:57.859]   - Field: ‘state’
[13:22:57.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.859] - Launch lazy future ...
[13:22:57.859] Packages needed by the future expression (n = 0): <none>
[13:22:57.860] Packages needed by future strategies (n = 0): <none>
[13:22:57.860] {
[13:22:57.860]     {
[13:22:57.860]         {
[13:22:57.860]             ...future.startTime <- base::Sys.time()
[13:22:57.860]             {
[13:22:57.860]                 {
[13:22:57.860]                   {
[13:22:57.860]                     {
[13:22:57.860]                       base::local({
[13:22:57.860]                         has_future <- base::requireNamespace("future", 
[13:22:57.860]                           quietly = TRUE)
[13:22:57.860]                         if (has_future) {
[13:22:57.860]                           ns <- base::getNamespace("future")
[13:22:57.860]                           version <- ns[[".package"]][["version"]]
[13:22:57.860]                           if (is.null(version)) 
[13:22:57.860]                             version <- utils::packageVersion("future")
[13:22:57.860]                         }
[13:22:57.860]                         else {
[13:22:57.860]                           version <- NULL
[13:22:57.860]                         }
[13:22:57.860]                         if (!has_future || version < "1.8.0") {
[13:22:57.860]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.860]                             "", base::R.version$version.string), 
[13:22:57.860]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.860]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.860]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.860]                               "release", "version")], collapse = " "), 
[13:22:57.860]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.860]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.860]                             info)
[13:22:57.860]                           info <- base::paste(info, collapse = "; ")
[13:22:57.860]                           if (!has_future) {
[13:22:57.860]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.860]                               info)
[13:22:57.860]                           }
[13:22:57.860]                           else {
[13:22:57.860]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.860]                               info, version)
[13:22:57.860]                           }
[13:22:57.860]                           base::stop(msg)
[13:22:57.860]                         }
[13:22:57.860]                       })
[13:22:57.860]                     }
[13:22:57.860]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.860]                     base::options(mc.cores = 1L)
[13:22:57.860]                   }
[13:22:57.860]                   options(future.plan = NULL)
[13:22:57.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.860]                 }
[13:22:57.860]                 ...future.workdir <- getwd()
[13:22:57.860]             }
[13:22:57.860]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.860]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.860]         }
[13:22:57.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.860]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.860]             base::names(...future.oldOptions))
[13:22:57.860]     }
[13:22:57.860]     if (FALSE) {
[13:22:57.860]     }
[13:22:57.860]     else {
[13:22:57.860]         if (TRUE) {
[13:22:57.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.860]                 open = "w")
[13:22:57.860]         }
[13:22:57.860]         else {
[13:22:57.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.860]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.860]         }
[13:22:57.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.860]             base::sink(type = "output", split = FALSE)
[13:22:57.860]             base::close(...future.stdout)
[13:22:57.860]         }, add = TRUE)
[13:22:57.860]     }
[13:22:57.860]     ...future.frame <- base::sys.nframe()
[13:22:57.860]     ...future.conditions <- base::list()
[13:22:57.860]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.860]     if (FALSE) {
[13:22:57.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.860]     }
[13:22:57.860]     ...future.result <- base::tryCatch({
[13:22:57.860]         base::withCallingHandlers({
[13:22:57.860]             ...future.value <- base::withVisible(base::local({
[13:22:57.860]                 withCallingHandlers({
[13:22:57.860]                   {
[13:22:57.860]                     2 * a
[13:22:57.860]                   }
[13:22:57.860]                 }, immediateCondition = function(cond) {
[13:22:57.860]                   save_rds <- function (object, pathname, ...) 
[13:22:57.860]                   {
[13:22:57.860]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.860]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.860]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.860]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.860]                         fi_tmp[["mtime"]])
[13:22:57.860]                     }
[13:22:57.860]                     tryCatch({
[13:22:57.860]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.860]                     }, error = function(ex) {
[13:22:57.860]                       msg <- conditionMessage(ex)
[13:22:57.860]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.860]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.860]                         fi_tmp[["mtime"]], msg)
[13:22:57.860]                       ex$message <- msg
[13:22:57.860]                       stop(ex)
[13:22:57.860]                     })
[13:22:57.860]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.860]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.860]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.860]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.860]                       fi <- file.info(pathname)
[13:22:57.860]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.860]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.860]                         fi[["size"]], fi[["mtime"]])
[13:22:57.860]                       stop(msg)
[13:22:57.860]                     }
[13:22:57.860]                     invisible(pathname)
[13:22:57.860]                   }
[13:22:57.860]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.860]                     rootPath = tempdir()) 
[13:22:57.860]                   {
[13:22:57.860]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.860]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.860]                       tmpdir = path, fileext = ".rds")
[13:22:57.860]                     save_rds(obj, file)
[13:22:57.860]                   }
[13:22:57.860]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.860]                   {
[13:22:57.860]                     inherits <- base::inherits
[13:22:57.860]                     invokeRestart <- base::invokeRestart
[13:22:57.860]                     is.null <- base::is.null
[13:22:57.860]                     muffled <- FALSE
[13:22:57.860]                     if (inherits(cond, "message")) {
[13:22:57.860]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.860]                       if (muffled) 
[13:22:57.860]                         invokeRestart("muffleMessage")
[13:22:57.860]                     }
[13:22:57.860]                     else if (inherits(cond, "warning")) {
[13:22:57.860]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.860]                       if (muffled) 
[13:22:57.860]                         invokeRestart("muffleWarning")
[13:22:57.860]                     }
[13:22:57.860]                     else if (inherits(cond, "condition")) {
[13:22:57.860]                       if (!is.null(pattern)) {
[13:22:57.860]                         computeRestarts <- base::computeRestarts
[13:22:57.860]                         grepl <- base::grepl
[13:22:57.860]                         restarts <- computeRestarts(cond)
[13:22:57.860]                         for (restart in restarts) {
[13:22:57.860]                           name <- restart$name
[13:22:57.860]                           if (is.null(name)) 
[13:22:57.860]                             next
[13:22:57.860]                           if (!grepl(pattern, name)) 
[13:22:57.860]                             next
[13:22:57.860]                           invokeRestart(restart)
[13:22:57.860]                           muffled <- TRUE
[13:22:57.860]                           break
[13:22:57.860]                         }
[13:22:57.860]                       }
[13:22:57.860]                     }
[13:22:57.860]                     invisible(muffled)
[13:22:57.860]                   }
[13:22:57.860]                   muffleCondition(cond)
[13:22:57.860]                 })
[13:22:57.860]             }))
[13:22:57.860]             future::FutureResult(value = ...future.value$value, 
[13:22:57.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.860]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.860]                     ...future.globalenv.names))
[13:22:57.860]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.860]         }, condition = base::local({
[13:22:57.860]             c <- base::c
[13:22:57.860]             inherits <- base::inherits
[13:22:57.860]             invokeRestart <- base::invokeRestart
[13:22:57.860]             length <- base::length
[13:22:57.860]             list <- base::list
[13:22:57.860]             seq.int <- base::seq.int
[13:22:57.860]             signalCondition <- base::signalCondition
[13:22:57.860]             sys.calls <- base::sys.calls
[13:22:57.860]             `[[` <- base::`[[`
[13:22:57.860]             `+` <- base::`+`
[13:22:57.860]             `<<-` <- base::`<<-`
[13:22:57.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.860]                   3L)]
[13:22:57.860]             }
[13:22:57.860]             function(cond) {
[13:22:57.860]                 is_error <- inherits(cond, "error")
[13:22:57.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.860]                   NULL)
[13:22:57.860]                 if (is_error) {
[13:22:57.860]                   sessionInformation <- function() {
[13:22:57.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.860]                       search = base::search(), system = base::Sys.info())
[13:22:57.860]                   }
[13:22:57.860]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.860]                     cond$call), session = sessionInformation(), 
[13:22:57.860]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.860]                   signalCondition(cond)
[13:22:57.860]                 }
[13:22:57.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.860]                 "immediateCondition"))) {
[13:22:57.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.860]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.860]                   if (TRUE && !signal) {
[13:22:57.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.860]                     {
[13:22:57.860]                       inherits <- base::inherits
[13:22:57.860]                       invokeRestart <- base::invokeRestart
[13:22:57.860]                       is.null <- base::is.null
[13:22:57.860]                       muffled <- FALSE
[13:22:57.860]                       if (inherits(cond, "message")) {
[13:22:57.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.860]                         if (muffled) 
[13:22:57.860]                           invokeRestart("muffleMessage")
[13:22:57.860]                       }
[13:22:57.860]                       else if (inherits(cond, "warning")) {
[13:22:57.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.860]                         if (muffled) 
[13:22:57.860]                           invokeRestart("muffleWarning")
[13:22:57.860]                       }
[13:22:57.860]                       else if (inherits(cond, "condition")) {
[13:22:57.860]                         if (!is.null(pattern)) {
[13:22:57.860]                           computeRestarts <- base::computeRestarts
[13:22:57.860]                           grepl <- base::grepl
[13:22:57.860]                           restarts <- computeRestarts(cond)
[13:22:57.860]                           for (restart in restarts) {
[13:22:57.860]                             name <- restart$name
[13:22:57.860]                             if (is.null(name)) 
[13:22:57.860]                               next
[13:22:57.860]                             if (!grepl(pattern, name)) 
[13:22:57.860]                               next
[13:22:57.860]                             invokeRestart(restart)
[13:22:57.860]                             muffled <- TRUE
[13:22:57.860]                             break
[13:22:57.860]                           }
[13:22:57.860]                         }
[13:22:57.860]                       }
[13:22:57.860]                       invisible(muffled)
[13:22:57.860]                     }
[13:22:57.860]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.860]                   }
[13:22:57.860]                 }
[13:22:57.860]                 else {
[13:22:57.860]                   if (TRUE) {
[13:22:57.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.860]                     {
[13:22:57.860]                       inherits <- base::inherits
[13:22:57.860]                       invokeRestart <- base::invokeRestart
[13:22:57.860]                       is.null <- base::is.null
[13:22:57.860]                       muffled <- FALSE
[13:22:57.860]                       if (inherits(cond, "message")) {
[13:22:57.860]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.860]                         if (muffled) 
[13:22:57.860]                           invokeRestart("muffleMessage")
[13:22:57.860]                       }
[13:22:57.860]                       else if (inherits(cond, "warning")) {
[13:22:57.860]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.860]                         if (muffled) 
[13:22:57.860]                           invokeRestart("muffleWarning")
[13:22:57.860]                       }
[13:22:57.860]                       else if (inherits(cond, "condition")) {
[13:22:57.860]                         if (!is.null(pattern)) {
[13:22:57.860]                           computeRestarts <- base::computeRestarts
[13:22:57.860]                           grepl <- base::grepl
[13:22:57.860]                           restarts <- computeRestarts(cond)
[13:22:57.860]                           for (restart in restarts) {
[13:22:57.860]                             name <- restart$name
[13:22:57.860]                             if (is.null(name)) 
[13:22:57.860]                               next
[13:22:57.860]                             if (!grepl(pattern, name)) 
[13:22:57.860]                               next
[13:22:57.860]                             invokeRestart(restart)
[13:22:57.860]                             muffled <- TRUE
[13:22:57.860]                             break
[13:22:57.860]                           }
[13:22:57.860]                         }
[13:22:57.860]                       }
[13:22:57.860]                       invisible(muffled)
[13:22:57.860]                     }
[13:22:57.860]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.860]                   }
[13:22:57.860]                 }
[13:22:57.860]             }
[13:22:57.860]         }))
[13:22:57.860]     }, error = function(ex) {
[13:22:57.860]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.860]                 ...future.rng), started = ...future.startTime, 
[13:22:57.860]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.860]             version = "1.8"), class = "FutureResult")
[13:22:57.860]     }, finally = {
[13:22:57.860]         if (!identical(...future.workdir, getwd())) 
[13:22:57.860]             setwd(...future.workdir)
[13:22:57.860]         {
[13:22:57.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.860]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.860]             }
[13:22:57.860]             base::options(...future.oldOptions)
[13:22:57.860]             if (.Platform$OS.type == "windows") {
[13:22:57.860]                 old_names <- names(...future.oldEnvVars)
[13:22:57.860]                 envs <- base::Sys.getenv()
[13:22:57.860]                 names <- names(envs)
[13:22:57.860]                 common <- intersect(names, old_names)
[13:22:57.860]                 added <- setdiff(names, old_names)
[13:22:57.860]                 removed <- setdiff(old_names, names)
[13:22:57.860]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.860]                   envs[common]]
[13:22:57.860]                 NAMES <- toupper(changed)
[13:22:57.860]                 args <- list()
[13:22:57.860]                 for (kk in seq_along(NAMES)) {
[13:22:57.860]                   name <- changed[[kk]]
[13:22:57.860]                   NAME <- NAMES[[kk]]
[13:22:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.860]                     next
[13:22:57.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.860]                 }
[13:22:57.860]                 NAMES <- toupper(added)
[13:22:57.860]                 for (kk in seq_along(NAMES)) {
[13:22:57.860]                   name <- added[[kk]]
[13:22:57.860]                   NAME <- NAMES[[kk]]
[13:22:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.860]                     next
[13:22:57.860]                   args[[name]] <- ""
[13:22:57.860]                 }
[13:22:57.860]                 NAMES <- toupper(removed)
[13:22:57.860]                 for (kk in seq_along(NAMES)) {
[13:22:57.860]                   name <- removed[[kk]]
[13:22:57.860]                   NAME <- NAMES[[kk]]
[13:22:57.860]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.860]                     next
[13:22:57.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.860]                 }
[13:22:57.860]                 if (length(args) > 0) 
[13:22:57.860]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.860]             }
[13:22:57.860]             else {
[13:22:57.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.860]             }
[13:22:57.860]             {
[13:22:57.860]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.860]                   0L) {
[13:22:57.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.860]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.860]                   base::options(opts)
[13:22:57.860]                 }
[13:22:57.860]                 {
[13:22:57.860]                   {
[13:22:57.860]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.860]                     NULL
[13:22:57.860]                   }
[13:22:57.860]                   options(future.plan = NULL)
[13:22:57.860]                   if (is.na(NA_character_)) 
[13:22:57.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.860]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.860]                     envir = parent.frame()) 
[13:22:57.860]                   {
[13:22:57.860]                     default_workers <- missing(workers)
[13:22:57.860]                     if (is.function(workers)) 
[13:22:57.860]                       workers <- workers()
[13:22:57.860]                     workers <- structure(as.integer(workers), 
[13:22:57.860]                       class = class(workers))
[13:22:57.860]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.860]                       1L)
[13:22:57.860]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.860]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.860]                       if (default_workers) 
[13:22:57.860]                         supportsMulticore(warn = TRUE)
[13:22:57.860]                       return(sequential(..., envir = envir))
[13:22:57.860]                     }
[13:22:57.860]                     oopts <- options(mc.cores = workers)
[13:22:57.860]                     on.exit(options(oopts))
[13:22:57.860]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.860]                       envir = envir)
[13:22:57.860]                     if (!future$lazy) 
[13:22:57.860]                       future <- run(future)
[13:22:57.860]                     invisible(future)
[13:22:57.860]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.860]                 }
[13:22:57.860]             }
[13:22:57.860]         }
[13:22:57.860]     })
[13:22:57.860]     if (TRUE) {
[13:22:57.860]         base::sink(type = "output", split = FALSE)
[13:22:57.860]         if (TRUE) {
[13:22:57.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.860]         }
[13:22:57.860]         else {
[13:22:57.860]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.860]         }
[13:22:57.860]         base::close(...future.stdout)
[13:22:57.860]         ...future.stdout <- NULL
[13:22:57.860]     }
[13:22:57.860]     ...future.result$conditions <- ...future.conditions
[13:22:57.860]     ...future.result$finished <- base::Sys.time()
[13:22:57.860]     ...future.result
[13:22:57.860] }
[13:22:57.863] assign_globals() ...
[13:22:57.863] List of 1
[13:22:57.863]  $ a: num 1
[13:22:57.863]  - attr(*, "where")=List of 1
[13:22:57.863]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.863]  - attr(*, "resolved")= logi FALSE
[13:22:57.863]  - attr(*, "total_size")= num 56
[13:22:57.863]  - attr(*, "already-done")= logi TRUE
[13:22:57.866] - copied ‘a’ to environment
[13:22:57.866] assign_globals() ... done
[13:22:57.867] requestCore(): workers = 2
[13:22:57.869] MulticoreFuture started
[13:22:57.869] - Launch lazy future ... done
[13:22:57.869] run() for ‘MulticoreFuture’ ... done
[13:22:57.870] result() for MulticoreFuture ...
[13:22:57.870] plan(): Setting new future strategy stack:
[13:22:57.870] List of future strategies:
[13:22:57.870] 1. sequential:
[13:22:57.870]    - args: function (..., envir = parent.frame())
[13:22:57.870]    - tweaked: FALSE
[13:22:57.870]    - call: NULL
[13:22:57.871] plan(): nbrOfWorkers() = 1
[13:22:57.873] plan(): Setting new future strategy stack:
[13:22:57.873] List of future strategies:
[13:22:57.873] 1. multicore:
[13:22:57.873]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.873]    - tweaked: FALSE
[13:22:57.873]    - call: plan(strategy)
[13:22:57.884] plan(): nbrOfWorkers() = 2
[13:22:57.885] result() for MulticoreFuture ...
[13:22:57.885] result() for MulticoreFuture ... done
[13:22:57.885] result() for MulticoreFuture ... done
[13:22:57.885] result() for MulticoreFuture ...
[13:22:57.885] result() for MulticoreFuture ... done
[13:22:57.886] getGlobalsAndPackages() ...
[13:22:57.886] Searching for globals...
[13:22:57.890] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:57.890] Searching for globals ... DONE
[13:22:57.890] Resolving globals: FALSE
[13:22:57.891] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:57.892] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:57.892] - globals: [1] ‘a’
[13:22:57.892] 
[13:22:57.892] getGlobalsAndPackages() ... DONE
[13:22:57.893] run() for ‘Future’ ...
[13:22:57.893] - state: ‘created’
[13:22:57.893] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:22:57.897] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:57.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:22:57.898]   - Field: ‘label’
[13:22:57.898]   - Field: ‘local’
[13:22:57.898]   - Field: ‘owner’
[13:22:57.898]   - Field: ‘envir’
[13:22:57.898]   - Field: ‘workers’
[13:22:57.898]   - Field: ‘packages’
[13:22:57.898]   - Field: ‘gc’
[13:22:57.899]   - Field: ‘job’
[13:22:57.899]   - Field: ‘conditions’
[13:22:57.899]   - Field: ‘expr’
[13:22:57.899]   - Field: ‘uuid’
[13:22:57.899]   - Field: ‘seed’
[13:22:57.899]   - Field: ‘version’
[13:22:57.899]   - Field: ‘result’
[13:22:57.899]   - Field: ‘asynchronous’
[13:22:57.899]   - Field: ‘calls’
[13:22:57.900]   - Field: ‘globals’
[13:22:57.900]   - Field: ‘stdout’
[13:22:57.900]   - Field: ‘earlySignal’
[13:22:57.900]   - Field: ‘lazy’
[13:22:57.900]   - Field: ‘state’
[13:22:57.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:22:57.900] - Launch lazy future ...
[13:22:57.901] Packages needed by the future expression (n = 0): <none>
[13:22:57.901] Packages needed by future strategies (n = 0): <none>
[13:22:57.901] {
[13:22:57.901]     {
[13:22:57.901]         {
[13:22:57.901]             ...future.startTime <- base::Sys.time()
[13:22:57.901]             {
[13:22:57.901]                 {
[13:22:57.901]                   {
[13:22:57.901]                     {
[13:22:57.901]                       base::local({
[13:22:57.901]                         has_future <- base::requireNamespace("future", 
[13:22:57.901]                           quietly = TRUE)
[13:22:57.901]                         if (has_future) {
[13:22:57.901]                           ns <- base::getNamespace("future")
[13:22:57.901]                           version <- ns[[".package"]][["version"]]
[13:22:57.901]                           if (is.null(version)) 
[13:22:57.901]                             version <- utils::packageVersion("future")
[13:22:57.901]                         }
[13:22:57.901]                         else {
[13:22:57.901]                           version <- NULL
[13:22:57.901]                         }
[13:22:57.901]                         if (!has_future || version < "1.8.0") {
[13:22:57.901]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:57.901]                             "", base::R.version$version.string), 
[13:22:57.901]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:57.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:57.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:57.901]                               "release", "version")], collapse = " "), 
[13:22:57.901]                             hostname = base::Sys.info()[["nodename"]])
[13:22:57.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:57.901]                             info)
[13:22:57.901]                           info <- base::paste(info, collapse = "; ")
[13:22:57.901]                           if (!has_future) {
[13:22:57.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:57.901]                               info)
[13:22:57.901]                           }
[13:22:57.901]                           else {
[13:22:57.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:57.901]                               info, version)
[13:22:57.901]                           }
[13:22:57.901]                           base::stop(msg)
[13:22:57.901]                         }
[13:22:57.901]                       })
[13:22:57.901]                     }
[13:22:57.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:57.901]                     base::options(mc.cores = 1L)
[13:22:57.901]                   }
[13:22:57.901]                   options(future.plan = NULL)
[13:22:57.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:57.901]                 }
[13:22:57.901]                 ...future.workdir <- getwd()
[13:22:57.901]             }
[13:22:57.901]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:57.901]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:57.901]         }
[13:22:57.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:57.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:57.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:57.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:57.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:57.901]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:57.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:57.901]             base::names(...future.oldOptions))
[13:22:57.901]     }
[13:22:57.901]     if (FALSE) {
[13:22:57.901]     }
[13:22:57.901]     else {
[13:22:57.901]         if (TRUE) {
[13:22:57.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:57.901]                 open = "w")
[13:22:57.901]         }
[13:22:57.901]         else {
[13:22:57.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:57.901]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:57.901]         }
[13:22:57.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:57.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:57.901]             base::sink(type = "output", split = FALSE)
[13:22:57.901]             base::close(...future.stdout)
[13:22:57.901]         }, add = TRUE)
[13:22:57.901]     }
[13:22:57.901]     ...future.frame <- base::sys.nframe()
[13:22:57.901]     ...future.conditions <- base::list()
[13:22:57.901]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:57.901]     if (FALSE) {
[13:22:57.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:57.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:57.901]     }
[13:22:57.901]     ...future.result <- base::tryCatch({
[13:22:57.901]         base::withCallingHandlers({
[13:22:57.901]             ...future.value <- base::withVisible(base::local({
[13:22:57.901]                 withCallingHandlers({
[13:22:57.901]                   {
[13:22:57.901]                     2 * a
[13:22:57.901]                   }
[13:22:57.901]                 }, immediateCondition = function(cond) {
[13:22:57.901]                   save_rds <- function (object, pathname, ...) 
[13:22:57.901]                   {
[13:22:57.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:22:57.901]                     if (file_test("-f", pathname_tmp)) {
[13:22:57.901]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:22:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.901]                         fi_tmp[["mtime"]])
[13:22:57.901]                     }
[13:22:57.901]                     tryCatch({
[13:22:57.901]                       saveRDS(object, file = pathname_tmp, ...)
[13:22:57.901]                     }, error = function(ex) {
[13:22:57.901]                       msg <- conditionMessage(ex)
[13:22:57.901]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:22:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.901]                         fi_tmp[["mtime"]], msg)
[13:22:57.901]                       ex$message <- msg
[13:22:57.901]                       stop(ex)
[13:22:57.901]                     })
[13:22:57.901]                     stopifnot(file_test("-f", pathname_tmp))
[13:22:57.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:22:57.901]                     if (!res || file_test("-f", pathname_tmp)) {
[13:22:57.901]                       fi_tmp <- file.info(pathname_tmp)
[13:22:57.901]                       fi <- file.info(pathname)
[13:22:57.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:22:57.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:22:57.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:22:57.901]                         fi[["size"]], fi[["mtime"]])
[13:22:57.901]                       stop(msg)
[13:22:57.901]                     }
[13:22:57.901]                     invisible(pathname)
[13:22:57.901]                   }
[13:22:57.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:22:57.901]                     rootPath = tempdir()) 
[13:22:57.901]                   {
[13:22:57.901]                     obj <- list(time = Sys.time(), condition = cond)
[13:22:57.901]                     file <- tempfile(pattern = class(cond)[1], 
[13:22:57.901]                       tmpdir = path, fileext = ".rds")
[13:22:57.901]                     save_rds(obj, file)
[13:22:57.901]                   }
[13:22:57.901]                   saveImmediateCondition(cond, path = "/tmp/RtmpaR7NqK/.future/immediateConditions")
[13:22:57.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.901]                   {
[13:22:57.901]                     inherits <- base::inherits
[13:22:57.901]                     invokeRestart <- base::invokeRestart
[13:22:57.901]                     is.null <- base::is.null
[13:22:57.901]                     muffled <- FALSE
[13:22:57.901]                     if (inherits(cond, "message")) {
[13:22:57.901]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:57.901]                       if (muffled) 
[13:22:57.901]                         invokeRestart("muffleMessage")
[13:22:57.901]                     }
[13:22:57.901]                     else if (inherits(cond, "warning")) {
[13:22:57.901]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:57.901]                       if (muffled) 
[13:22:57.901]                         invokeRestart("muffleWarning")
[13:22:57.901]                     }
[13:22:57.901]                     else if (inherits(cond, "condition")) {
[13:22:57.901]                       if (!is.null(pattern)) {
[13:22:57.901]                         computeRestarts <- base::computeRestarts
[13:22:57.901]                         grepl <- base::grepl
[13:22:57.901]                         restarts <- computeRestarts(cond)
[13:22:57.901]                         for (restart in restarts) {
[13:22:57.901]                           name <- restart$name
[13:22:57.901]                           if (is.null(name)) 
[13:22:57.901]                             next
[13:22:57.901]                           if (!grepl(pattern, name)) 
[13:22:57.901]                             next
[13:22:57.901]                           invokeRestart(restart)
[13:22:57.901]                           muffled <- TRUE
[13:22:57.901]                           break
[13:22:57.901]                         }
[13:22:57.901]                       }
[13:22:57.901]                     }
[13:22:57.901]                     invisible(muffled)
[13:22:57.901]                   }
[13:22:57.901]                   muffleCondition(cond)
[13:22:57.901]                 })
[13:22:57.901]             }))
[13:22:57.901]             future::FutureResult(value = ...future.value$value, 
[13:22:57.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.901]                   ...future.rng), globalenv = if (FALSE) 
[13:22:57.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:57.901]                     ...future.globalenv.names))
[13:22:57.901]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:57.901]         }, condition = base::local({
[13:22:57.901]             c <- base::c
[13:22:57.901]             inherits <- base::inherits
[13:22:57.901]             invokeRestart <- base::invokeRestart
[13:22:57.901]             length <- base::length
[13:22:57.901]             list <- base::list
[13:22:57.901]             seq.int <- base::seq.int
[13:22:57.901]             signalCondition <- base::signalCondition
[13:22:57.901]             sys.calls <- base::sys.calls
[13:22:57.901]             `[[` <- base::`[[`
[13:22:57.901]             `+` <- base::`+`
[13:22:57.901]             `<<-` <- base::`<<-`
[13:22:57.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:57.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:57.901]                   3L)]
[13:22:57.901]             }
[13:22:57.901]             function(cond) {
[13:22:57.901]                 is_error <- inherits(cond, "error")
[13:22:57.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:57.901]                   NULL)
[13:22:57.901]                 if (is_error) {
[13:22:57.901]                   sessionInformation <- function() {
[13:22:57.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:57.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:57.901]                       search = base::search(), system = base::Sys.info())
[13:22:57.901]                   }
[13:22:57.901]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:57.901]                     cond$call), session = sessionInformation(), 
[13:22:57.901]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:57.901]                   signalCondition(cond)
[13:22:57.901]                 }
[13:22:57.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:57.901]                 "immediateCondition"))) {
[13:22:57.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:57.901]                   ...future.conditions[[length(...future.conditions) + 
[13:22:57.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:57.901]                   if (TRUE && !signal) {
[13:22:57.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.901]                     {
[13:22:57.901]                       inherits <- base::inherits
[13:22:57.901]                       invokeRestart <- base::invokeRestart
[13:22:57.901]                       is.null <- base::is.null
[13:22:57.901]                       muffled <- FALSE
[13:22:57.901]                       if (inherits(cond, "message")) {
[13:22:57.901]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.901]                         if (muffled) 
[13:22:57.901]                           invokeRestart("muffleMessage")
[13:22:57.901]                       }
[13:22:57.901]                       else if (inherits(cond, "warning")) {
[13:22:57.901]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.901]                         if (muffled) 
[13:22:57.901]                           invokeRestart("muffleWarning")
[13:22:57.901]                       }
[13:22:57.901]                       else if (inherits(cond, "condition")) {
[13:22:57.901]                         if (!is.null(pattern)) {
[13:22:57.901]                           computeRestarts <- base::computeRestarts
[13:22:57.901]                           grepl <- base::grepl
[13:22:57.901]                           restarts <- computeRestarts(cond)
[13:22:57.901]                           for (restart in restarts) {
[13:22:57.901]                             name <- restart$name
[13:22:57.901]                             if (is.null(name)) 
[13:22:57.901]                               next
[13:22:57.901]                             if (!grepl(pattern, name)) 
[13:22:57.901]                               next
[13:22:57.901]                             invokeRestart(restart)
[13:22:57.901]                             muffled <- TRUE
[13:22:57.901]                             break
[13:22:57.901]                           }
[13:22:57.901]                         }
[13:22:57.901]                       }
[13:22:57.901]                       invisible(muffled)
[13:22:57.901]                     }
[13:22:57.901]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.901]                   }
[13:22:57.901]                 }
[13:22:57.901]                 else {
[13:22:57.901]                   if (TRUE) {
[13:22:57.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:57.901]                     {
[13:22:57.901]                       inherits <- base::inherits
[13:22:57.901]                       invokeRestart <- base::invokeRestart
[13:22:57.901]                       is.null <- base::is.null
[13:22:57.901]                       muffled <- FALSE
[13:22:57.901]                       if (inherits(cond, "message")) {
[13:22:57.901]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:57.901]                         if (muffled) 
[13:22:57.901]                           invokeRestart("muffleMessage")
[13:22:57.901]                       }
[13:22:57.901]                       else if (inherits(cond, "warning")) {
[13:22:57.901]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:57.901]                         if (muffled) 
[13:22:57.901]                           invokeRestart("muffleWarning")
[13:22:57.901]                       }
[13:22:57.901]                       else if (inherits(cond, "condition")) {
[13:22:57.901]                         if (!is.null(pattern)) {
[13:22:57.901]                           computeRestarts <- base::computeRestarts
[13:22:57.901]                           grepl <- base::grepl
[13:22:57.901]                           restarts <- computeRestarts(cond)
[13:22:57.901]                           for (restart in restarts) {
[13:22:57.901]                             name <- restart$name
[13:22:57.901]                             if (is.null(name)) 
[13:22:57.901]                               next
[13:22:57.901]                             if (!grepl(pattern, name)) 
[13:22:57.901]                               next
[13:22:57.901]                             invokeRestart(restart)
[13:22:57.901]                             muffled <- TRUE
[13:22:57.901]                             break
[13:22:57.901]                           }
[13:22:57.901]                         }
[13:22:57.901]                       }
[13:22:57.901]                       invisible(muffled)
[13:22:57.901]                     }
[13:22:57.901]                     muffleCondition(cond, pattern = "^muffle")
[13:22:57.901]                   }
[13:22:57.901]                 }
[13:22:57.901]             }
[13:22:57.901]         }))
[13:22:57.901]     }, error = function(ex) {
[13:22:57.901]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:57.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:57.901]                 ...future.rng), started = ...future.startTime, 
[13:22:57.901]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:57.901]             version = "1.8"), class = "FutureResult")
[13:22:57.901]     }, finally = {
[13:22:57.901]         if (!identical(...future.workdir, getwd())) 
[13:22:57.901]             setwd(...future.workdir)
[13:22:57.901]         {
[13:22:57.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:57.901]                 ...future.oldOptions$nwarnings <- NULL
[13:22:57.901]             }
[13:22:57.901]             base::options(...future.oldOptions)
[13:22:57.901]             if (.Platform$OS.type == "windows") {
[13:22:57.901]                 old_names <- names(...future.oldEnvVars)
[13:22:57.901]                 envs <- base::Sys.getenv()
[13:22:57.901]                 names <- names(envs)
[13:22:57.901]                 common <- intersect(names, old_names)
[13:22:57.901]                 added <- setdiff(names, old_names)
[13:22:57.901]                 removed <- setdiff(old_names, names)
[13:22:57.901]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:57.901]                   envs[common]]
[13:22:57.901]                 NAMES <- toupper(changed)
[13:22:57.901]                 args <- list()
[13:22:57.901]                 for (kk in seq_along(NAMES)) {
[13:22:57.901]                   name <- changed[[kk]]
[13:22:57.901]                   NAME <- NAMES[[kk]]
[13:22:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.901]                     next
[13:22:57.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.901]                 }
[13:22:57.901]                 NAMES <- toupper(added)
[13:22:57.901]                 for (kk in seq_along(NAMES)) {
[13:22:57.901]                   name <- added[[kk]]
[13:22:57.901]                   NAME <- NAMES[[kk]]
[13:22:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.901]                     next
[13:22:57.901]                   args[[name]] <- ""
[13:22:57.901]                 }
[13:22:57.901]                 NAMES <- toupper(removed)
[13:22:57.901]                 for (kk in seq_along(NAMES)) {
[13:22:57.901]                   name <- removed[[kk]]
[13:22:57.901]                   NAME <- NAMES[[kk]]
[13:22:57.901]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:57.901]                     next
[13:22:57.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:57.901]                 }
[13:22:57.901]                 if (length(args) > 0) 
[13:22:57.901]                   base::do.call(base::Sys.setenv, args = args)
[13:22:57.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:57.901]             }
[13:22:57.901]             else {
[13:22:57.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:57.901]             }
[13:22:57.901]             {
[13:22:57.901]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:57.901]                   0L) {
[13:22:57.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:57.901]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:57.901]                   base::options(opts)
[13:22:57.901]                 }
[13:22:57.901]                 {
[13:22:57.901]                   {
[13:22:57.901]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:57.901]                     NULL
[13:22:57.901]                   }
[13:22:57.901]                   options(future.plan = NULL)
[13:22:57.901]                   if (is.na(NA_character_)) 
[13:22:57.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:57.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:57.901]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:22:57.901]                     envir = parent.frame()) 
[13:22:57.901]                   {
[13:22:57.901]                     default_workers <- missing(workers)
[13:22:57.901]                     if (is.function(workers)) 
[13:22:57.901]                       workers <- workers()
[13:22:57.901]                     workers <- structure(as.integer(workers), 
[13:22:57.901]                       class = class(workers))
[13:22:57.901]                     stop_if_not(is.finite(workers), workers >= 
[13:22:57.901]                       1L)
[13:22:57.901]                     if ((workers == 1L && !inherits(workers, 
[13:22:57.901]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:22:57.901]                       if (default_workers) 
[13:22:57.901]                         supportsMulticore(warn = TRUE)
[13:22:57.901]                       return(sequential(..., envir = envir))
[13:22:57.901]                     }
[13:22:57.901]                     oopts <- options(mc.cores = workers)
[13:22:57.901]                     on.exit(options(oopts))
[13:22:57.901]                     future <- MulticoreFuture(..., workers = workers, 
[13:22:57.901]                       envir = envir)
[13:22:57.901]                     if (!future$lazy) 
[13:22:57.901]                       future <- run(future)
[13:22:57.901]                     invisible(future)
[13:22:57.901]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:57.901]                 }
[13:22:57.901]             }
[13:22:57.901]         }
[13:22:57.901]     })
[13:22:57.901]     if (TRUE) {
[13:22:57.901]         base::sink(type = "output", split = FALSE)
[13:22:57.901]         if (TRUE) {
[13:22:57.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:57.901]         }
[13:22:57.901]         else {
[13:22:57.901]             ...future.result["stdout"] <- base::list(NULL)
[13:22:57.901]         }
[13:22:57.901]         base::close(...future.stdout)
[13:22:57.901]         ...future.stdout <- NULL
[13:22:57.901]     }
[13:22:57.901]     ...future.result$conditions <- ...future.conditions
[13:22:57.901]     ...future.result$finished <- base::Sys.time()
[13:22:57.901]     ...future.result
[13:22:57.901] }
[13:22:57.904] assign_globals() ...
[13:22:57.904] List of 1
[13:22:57.904]  $ a: num 1
[13:22:57.904]  - attr(*, "where")=List of 1
[13:22:57.904]   ..$ a:<environment: R_EmptyEnv> 
[13:22:57.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:22:57.904]  - attr(*, "resolved")= logi FALSE
[13:22:57.904]  - attr(*, "total_size")= num 56
[13:22:57.904]  - attr(*, "already-done")= logi TRUE
[13:22:57.907] - copied ‘a’ to environment
[13:22:57.907] assign_globals() ... done
[13:22:57.908] requestCore(): workers = 2
[13:22:57.910] MulticoreFuture started
[13:22:57.910] - Launch lazy future ... done
[13:22:57.910] run() for ‘MulticoreFuture’ ... done
[13:22:57.911] result() for MulticoreFuture ...
[13:22:57.911] plan(): Setting new future strategy stack:
[13:22:57.911] List of future strategies:
[13:22:57.911] 1. sequential:
[13:22:57.911]    - args: function (..., envir = parent.frame())
[13:22:57.911]    - tweaked: FALSE
[13:22:57.911]    - call: NULL
[13:22:57.912] plan(): nbrOfWorkers() = 1
[13:22:57.914] plan(): Setting new future strategy stack:
[13:22:57.914] List of future strategies:
[13:22:57.914] 1. multicore:
[13:22:57.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:22:57.914]    - tweaked: FALSE
[13:22:57.914]    - call: plan(strategy)
[13:22:57.920] plan(): nbrOfWorkers() = 2
[13:22:57.921] result() for MulticoreFuture ...
[13:22:57.921] result() for MulticoreFuture ... done
[13:22:57.921] result() for MulticoreFuture ... done
[13:22:57.921] result() for MulticoreFuture ...
[13:22:57.921] result() for MulticoreFuture ... done
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[13:22:57.922] plan(): Setting new future strategy stack:
[13:22:57.922] List of future strategies:
[13:22:57.922] 1. multisession:
[13:22:57.922]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:57.922]    - tweaked: FALSE
[13:22:57.922]    - call: plan(strategy)
[13:22:57.923] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:22:57.923] multisession:
[13:22:57.923] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:22:57.923] - tweaked: FALSE
[13:22:57.923] - call: plan(strategy)
[13:22:57.930] getGlobalsAndPackages() ...
[13:22:57.930] Not searching for globals
[13:22:57.931] - globals: [0] <none>
[13:22:57.931] getGlobalsAndPackages() ... DONE
[13:22:57.932] [local output] makeClusterPSOCK() ...
[13:22:57.980] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:22:57.981] [local output] Base port: 11594
[13:22:57.981] [local output] Getting setup options for 2 cluster nodes ...
[13:22:57.982] [local output]  - Node 1 of 2 ...
[13:22:57.982] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:57.983] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpaR7NqK/worker.rank=1.parallelly.parent=83645.146bd7bc25971.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpaR7NqK/worker.rank=1.parallelly.parent=83645.146bd7bc25971.pid")'’
[13:22:58.178] - Possible to infer worker's PID: TRUE
[13:22:58.178] [local output] Rscript port: 11594

[13:22:58.178] [local output]  - Node 2 of 2 ...
[13:22:58.179] [local output] localMachine=TRUE => revtunnel=FALSE

[13:22:58.179] [local output] Rscript port: 11594

[13:22:58.180] [local output] Getting setup options for 2 cluster nodes ... done
[13:22:58.180] [local output]  - Parallel setup requested for some PSOCK nodes
[13:22:58.180] [local output] Setting up PSOCK nodes in parallel
[13:22:58.180] List of 36
[13:22:58.180]  $ worker          : chr "localhost"
[13:22:58.180]   ..- attr(*, "localhost")= logi TRUE
[13:22:58.180]  $ master          : chr "localhost"
[13:22:58.180]  $ port            : int 11594
[13:22:58.180]  $ connectTimeout  : num 120
[13:22:58.180]  $ timeout         : num 2592000
[13:22:58.180]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:22:58.180]  $ homogeneous     : logi TRUE
[13:22:58.180]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:22:58.180]  $ rscript_envs    : NULL
[13:22:58.180]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:58.180]  $ rscript_startup : NULL
[13:22:58.180]  $ rscript_sh      : chr "sh"
[13:22:58.180]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:58.180]  $ methods         : logi TRUE
[13:22:58.180]  $ socketOptions   : chr "no-delay"
[13:22:58.180]  $ useXDR          : logi FALSE
[13:22:58.180]  $ outfile         : chr "/dev/null"
[13:22:58.180]  $ renice          : int NA
[13:22:58.180]  $ rshcmd          : NULL
[13:22:58.180]  $ user            : chr(0) 
[13:22:58.180]  $ revtunnel       : logi FALSE
[13:22:58.180]  $ rshlogfile      : NULL
[13:22:58.180]  $ rshopts         : chr(0) 
[13:22:58.180]  $ rank            : int 1
[13:22:58.180]  $ manual          : logi FALSE
[13:22:58.180]  $ dryrun          : logi FALSE
[13:22:58.180]  $ quiet           : logi FALSE
[13:22:58.180]  $ setup_strategy  : chr "parallel"
[13:22:58.180]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:58.180]  $ pidfile         : chr "/tmp/RtmpaR7NqK/worker.rank=1.parallelly.parent=83645.146bd7bc25971.pid"
[13:22:58.180]  $ rshcmd_label    : NULL
[13:22:58.180]  $ rsh_call        : NULL
[13:22:58.180]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:22:58.180]  $ localMachine    : logi TRUE
[13:22:58.180]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:22:58.180]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:22:58.180]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:22:58.180]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:22:58.180]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:22:58.180]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:22:58.180]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:22:58.180]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:22:58.180]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:22:58.180]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:22:58.180]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:22:58.180]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:22:58.180]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:22:58.180]  $ arguments       :List of 28
[13:22:58.180]   ..$ worker          : chr "localhost"
[13:22:58.180]   ..$ master          : NULL
[13:22:58.180]   ..$ port            : int 11594
[13:22:58.180]   ..$ connectTimeout  : num 120
[13:22:58.180]   ..$ timeout         : num 2592000
[13:22:58.180]   ..$ rscript         : NULL
[13:22:58.180]   ..$ homogeneous     : NULL
[13:22:58.180]   ..$ rscript_args    : NULL
[13:22:58.180]   ..$ rscript_envs    : NULL
[13:22:58.180]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:22:58.180]   ..$ rscript_startup : NULL
[13:22:58.180]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:22:58.180]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:22:58.180]   ..$ methods         : logi TRUE
[13:22:58.180]   ..$ socketOptions   : chr "no-delay"
[13:22:58.180]   ..$ useXDR          : logi FALSE
[13:22:58.180]   ..$ outfile         : chr "/dev/null"
[13:22:58.180]   ..$ renice          : int NA
[13:22:58.180]   ..$ rshcmd          : NULL
[13:22:58.180]   ..$ user            : NULL
[13:22:58.180]   ..$ revtunnel       : logi NA
[13:22:58.180]   ..$ rshlogfile      : NULL
[13:22:58.180]   ..$ rshopts         : NULL
[13:22:58.180]   ..$ rank            : int 1
[13:22:58.180]   ..$ manual          : logi FALSE
[13:22:58.180]   ..$ dryrun          : logi FALSE
[13:22:58.180]   ..$ quiet           : logi FALSE
[13:22:58.180]   ..$ setup_strategy  : chr "parallel"
[13:22:58.180]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:22:58.198] [local output] System call to launch all workers:
[13:22:58.198] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpaR7NqK/worker.rank=1.parallelly.parent=83645.146bd7bc25971.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11594 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:22:58.198] [local output] Starting PSOCK main server
[13:22:58.204] [local output] Workers launched
[13:22:58.204] [local output] Waiting for workers to connect back
[13:22:58.204]  - [local output] 0 workers out of 2 ready
[13:22:58.468]  - [local output] 0 workers out of 2 ready
[13:22:58.469]  - [local output] 1 workers out of 2 ready
[13:22:58.477]  - [local output] 1 workers out of 2 ready
[13:22:58.478]  - [local output] 2 workers out of 2 ready
[13:22:58.478] [local output] Launching of workers completed
[13:22:58.478] [local output] Collecting session information from workers
[13:22:58.479] [local output]  - Worker #1 of 2
[13:22:58.479] [local output]  - Worker #2 of 2
[13:22:58.480] [local output] makeClusterPSOCK() ... done
[13:22:58.491] Packages needed by the future expression (n = 0): <none>
[13:22:58.492] Packages needed by future strategies (n = 0): <none>
[13:22:58.492] {
[13:22:58.492]     {
[13:22:58.492]         {
[13:22:58.492]             ...future.startTime <- base::Sys.time()
[13:22:58.492]             {
[13:22:58.492]                 {
[13:22:58.492]                   {
[13:22:58.492]                     {
[13:22:58.492]                       base::local({
[13:22:58.492]                         has_future <- base::requireNamespace("future", 
[13:22:58.492]                           quietly = TRUE)
[13:22:58.492]                         if (has_future) {
[13:22:58.492]                           ns <- base::getNamespace("future")
[13:22:58.492]                           version <- ns[[".package"]][["version"]]
[13:22:58.492]                           if (is.null(version)) 
[13:22:58.492]                             version <- utils::packageVersion("future")
[13:22:58.492]                         }
[13:22:58.492]                         else {
[13:22:58.492]                           version <- NULL
[13:22:58.492]                         }
[13:22:58.492]                         if (!has_future || version < "1.8.0") {
[13:22:58.492]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.492]                             "", base::R.version$version.string), 
[13:22:58.492]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.492]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.492]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.492]                               "release", "version")], collapse = " "), 
[13:22:58.492]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.492]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.492]                             info)
[13:22:58.492]                           info <- base::paste(info, collapse = "; ")
[13:22:58.492]                           if (!has_future) {
[13:22:58.492]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.492]                               info)
[13:22:58.492]                           }
[13:22:58.492]                           else {
[13:22:58.492]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.492]                               info, version)
[13:22:58.492]                           }
[13:22:58.492]                           base::stop(msg)
[13:22:58.492]                         }
[13:22:58.492]                       })
[13:22:58.492]                     }
[13:22:58.492]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.492]                     base::options(mc.cores = 1L)
[13:22:58.492]                   }
[13:22:58.492]                   options(future.plan = NULL)
[13:22:58.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.492]                 }
[13:22:58.492]                 ...future.workdir <- getwd()
[13:22:58.492]             }
[13:22:58.492]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.492]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.492]         }
[13:22:58.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.492]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.492]             base::names(...future.oldOptions))
[13:22:58.492]     }
[13:22:58.492]     if (FALSE) {
[13:22:58.492]     }
[13:22:58.492]     else {
[13:22:58.492]         if (TRUE) {
[13:22:58.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.492]                 open = "w")
[13:22:58.492]         }
[13:22:58.492]         else {
[13:22:58.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.492]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.492]         }
[13:22:58.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.492]             base::sink(type = "output", split = FALSE)
[13:22:58.492]             base::close(...future.stdout)
[13:22:58.492]         }, add = TRUE)
[13:22:58.492]     }
[13:22:58.492]     ...future.frame <- base::sys.nframe()
[13:22:58.492]     ...future.conditions <- base::list()
[13:22:58.492]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.492]     if (FALSE) {
[13:22:58.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.492]     }
[13:22:58.492]     ...future.result <- base::tryCatch({
[13:22:58.492]         base::withCallingHandlers({
[13:22:58.492]             ...future.value <- base::withVisible(base::local({
[13:22:58.492]                 ...future.makeSendCondition <- base::local({
[13:22:58.492]                   sendCondition <- NULL
[13:22:58.492]                   function(frame = 1L) {
[13:22:58.492]                     if (is.function(sendCondition)) 
[13:22:58.492]                       return(sendCondition)
[13:22:58.492]                     ns <- getNamespace("parallel")
[13:22:58.492]                     if (exists("sendData", mode = "function", 
[13:22:58.492]                       envir = ns)) {
[13:22:58.492]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.492]                         envir = ns)
[13:22:58.492]                       envir <- sys.frame(frame)
[13:22:58.492]                       master <- NULL
[13:22:58.492]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.492]                         !identical(envir, emptyenv())) {
[13:22:58.492]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.492]                           inherits = FALSE)) {
[13:22:58.492]                           master <- get("master", mode = "list", 
[13:22:58.492]                             envir = envir, inherits = FALSE)
[13:22:58.492]                           if (inherits(master, c("SOCKnode", 
[13:22:58.492]                             "SOCK0node"))) {
[13:22:58.492]                             sendCondition <<- function(cond) {
[13:22:58.492]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.492]                                 success = TRUE)
[13:22:58.492]                               parallel_sendData(master, data)
[13:22:58.492]                             }
[13:22:58.492]                             return(sendCondition)
[13:22:58.492]                           }
[13:22:58.492]                         }
[13:22:58.492]                         frame <- frame + 1L
[13:22:58.492]                         envir <- sys.frame(frame)
[13:22:58.492]                       }
[13:22:58.492]                     }
[13:22:58.492]                     sendCondition <<- function(cond) NULL
[13:22:58.492]                   }
[13:22:58.492]                 })
[13:22:58.492]                 withCallingHandlers({
[13:22:58.492]                   NA
[13:22:58.492]                 }, immediateCondition = function(cond) {
[13:22:58.492]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.492]                   sendCondition(cond)
[13:22:58.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.492]                   {
[13:22:58.492]                     inherits <- base::inherits
[13:22:58.492]                     invokeRestart <- base::invokeRestart
[13:22:58.492]                     is.null <- base::is.null
[13:22:58.492]                     muffled <- FALSE
[13:22:58.492]                     if (inherits(cond, "message")) {
[13:22:58.492]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.492]                       if (muffled) 
[13:22:58.492]                         invokeRestart("muffleMessage")
[13:22:58.492]                     }
[13:22:58.492]                     else if (inherits(cond, "warning")) {
[13:22:58.492]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.492]                       if (muffled) 
[13:22:58.492]                         invokeRestart("muffleWarning")
[13:22:58.492]                     }
[13:22:58.492]                     else if (inherits(cond, "condition")) {
[13:22:58.492]                       if (!is.null(pattern)) {
[13:22:58.492]                         computeRestarts <- base::computeRestarts
[13:22:58.492]                         grepl <- base::grepl
[13:22:58.492]                         restarts <- computeRestarts(cond)
[13:22:58.492]                         for (restart in restarts) {
[13:22:58.492]                           name <- restart$name
[13:22:58.492]                           if (is.null(name)) 
[13:22:58.492]                             next
[13:22:58.492]                           if (!grepl(pattern, name)) 
[13:22:58.492]                             next
[13:22:58.492]                           invokeRestart(restart)
[13:22:58.492]                           muffled <- TRUE
[13:22:58.492]                           break
[13:22:58.492]                         }
[13:22:58.492]                       }
[13:22:58.492]                     }
[13:22:58.492]                     invisible(muffled)
[13:22:58.492]                   }
[13:22:58.492]                   muffleCondition(cond)
[13:22:58.492]                 })
[13:22:58.492]             }))
[13:22:58.492]             future::FutureResult(value = ...future.value$value, 
[13:22:58.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.492]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.492]                     ...future.globalenv.names))
[13:22:58.492]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.492]         }, condition = base::local({
[13:22:58.492]             c <- base::c
[13:22:58.492]             inherits <- base::inherits
[13:22:58.492]             invokeRestart <- base::invokeRestart
[13:22:58.492]             length <- base::length
[13:22:58.492]             list <- base::list
[13:22:58.492]             seq.int <- base::seq.int
[13:22:58.492]             signalCondition <- base::signalCondition
[13:22:58.492]             sys.calls <- base::sys.calls
[13:22:58.492]             `[[` <- base::`[[`
[13:22:58.492]             `+` <- base::`+`
[13:22:58.492]             `<<-` <- base::`<<-`
[13:22:58.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.492]                   3L)]
[13:22:58.492]             }
[13:22:58.492]             function(cond) {
[13:22:58.492]                 is_error <- inherits(cond, "error")
[13:22:58.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.492]                   NULL)
[13:22:58.492]                 if (is_error) {
[13:22:58.492]                   sessionInformation <- function() {
[13:22:58.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.492]                       search = base::search(), system = base::Sys.info())
[13:22:58.492]                   }
[13:22:58.492]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.492]                     cond$call), session = sessionInformation(), 
[13:22:58.492]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.492]                   signalCondition(cond)
[13:22:58.492]                 }
[13:22:58.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.492]                 "immediateCondition"))) {
[13:22:58.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.492]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.492]                   if (TRUE && !signal) {
[13:22:58.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.492]                     {
[13:22:58.492]                       inherits <- base::inherits
[13:22:58.492]                       invokeRestart <- base::invokeRestart
[13:22:58.492]                       is.null <- base::is.null
[13:22:58.492]                       muffled <- FALSE
[13:22:58.492]                       if (inherits(cond, "message")) {
[13:22:58.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.492]                         if (muffled) 
[13:22:58.492]                           invokeRestart("muffleMessage")
[13:22:58.492]                       }
[13:22:58.492]                       else if (inherits(cond, "warning")) {
[13:22:58.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.492]                         if (muffled) 
[13:22:58.492]                           invokeRestart("muffleWarning")
[13:22:58.492]                       }
[13:22:58.492]                       else if (inherits(cond, "condition")) {
[13:22:58.492]                         if (!is.null(pattern)) {
[13:22:58.492]                           computeRestarts <- base::computeRestarts
[13:22:58.492]                           grepl <- base::grepl
[13:22:58.492]                           restarts <- computeRestarts(cond)
[13:22:58.492]                           for (restart in restarts) {
[13:22:58.492]                             name <- restart$name
[13:22:58.492]                             if (is.null(name)) 
[13:22:58.492]                               next
[13:22:58.492]                             if (!grepl(pattern, name)) 
[13:22:58.492]                               next
[13:22:58.492]                             invokeRestart(restart)
[13:22:58.492]                             muffled <- TRUE
[13:22:58.492]                             break
[13:22:58.492]                           }
[13:22:58.492]                         }
[13:22:58.492]                       }
[13:22:58.492]                       invisible(muffled)
[13:22:58.492]                     }
[13:22:58.492]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.492]                   }
[13:22:58.492]                 }
[13:22:58.492]                 else {
[13:22:58.492]                   if (TRUE) {
[13:22:58.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.492]                     {
[13:22:58.492]                       inherits <- base::inherits
[13:22:58.492]                       invokeRestart <- base::invokeRestart
[13:22:58.492]                       is.null <- base::is.null
[13:22:58.492]                       muffled <- FALSE
[13:22:58.492]                       if (inherits(cond, "message")) {
[13:22:58.492]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.492]                         if (muffled) 
[13:22:58.492]                           invokeRestart("muffleMessage")
[13:22:58.492]                       }
[13:22:58.492]                       else if (inherits(cond, "warning")) {
[13:22:58.492]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.492]                         if (muffled) 
[13:22:58.492]                           invokeRestart("muffleWarning")
[13:22:58.492]                       }
[13:22:58.492]                       else if (inherits(cond, "condition")) {
[13:22:58.492]                         if (!is.null(pattern)) {
[13:22:58.492]                           computeRestarts <- base::computeRestarts
[13:22:58.492]                           grepl <- base::grepl
[13:22:58.492]                           restarts <- computeRestarts(cond)
[13:22:58.492]                           for (restart in restarts) {
[13:22:58.492]                             name <- restart$name
[13:22:58.492]                             if (is.null(name)) 
[13:22:58.492]                               next
[13:22:58.492]                             if (!grepl(pattern, name)) 
[13:22:58.492]                               next
[13:22:58.492]                             invokeRestart(restart)
[13:22:58.492]                             muffled <- TRUE
[13:22:58.492]                             break
[13:22:58.492]                           }
[13:22:58.492]                         }
[13:22:58.492]                       }
[13:22:58.492]                       invisible(muffled)
[13:22:58.492]                     }
[13:22:58.492]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.492]                   }
[13:22:58.492]                 }
[13:22:58.492]             }
[13:22:58.492]         }))
[13:22:58.492]     }, error = function(ex) {
[13:22:58.492]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.492]                 ...future.rng), started = ...future.startTime, 
[13:22:58.492]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.492]             version = "1.8"), class = "FutureResult")
[13:22:58.492]     }, finally = {
[13:22:58.492]         if (!identical(...future.workdir, getwd())) 
[13:22:58.492]             setwd(...future.workdir)
[13:22:58.492]         {
[13:22:58.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.492]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.492]             }
[13:22:58.492]             base::options(...future.oldOptions)
[13:22:58.492]             if (.Platform$OS.type == "windows") {
[13:22:58.492]                 old_names <- names(...future.oldEnvVars)
[13:22:58.492]                 envs <- base::Sys.getenv()
[13:22:58.492]                 names <- names(envs)
[13:22:58.492]                 common <- intersect(names, old_names)
[13:22:58.492]                 added <- setdiff(names, old_names)
[13:22:58.492]                 removed <- setdiff(old_names, names)
[13:22:58.492]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.492]                   envs[common]]
[13:22:58.492]                 NAMES <- toupper(changed)
[13:22:58.492]                 args <- list()
[13:22:58.492]                 for (kk in seq_along(NAMES)) {
[13:22:58.492]                   name <- changed[[kk]]
[13:22:58.492]                   NAME <- NAMES[[kk]]
[13:22:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.492]                     next
[13:22:58.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.492]                 }
[13:22:58.492]                 NAMES <- toupper(added)
[13:22:58.492]                 for (kk in seq_along(NAMES)) {
[13:22:58.492]                   name <- added[[kk]]
[13:22:58.492]                   NAME <- NAMES[[kk]]
[13:22:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.492]                     next
[13:22:58.492]                   args[[name]] <- ""
[13:22:58.492]                 }
[13:22:58.492]                 NAMES <- toupper(removed)
[13:22:58.492]                 for (kk in seq_along(NAMES)) {
[13:22:58.492]                   name <- removed[[kk]]
[13:22:58.492]                   NAME <- NAMES[[kk]]
[13:22:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.492]                     next
[13:22:58.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.492]                 }
[13:22:58.492]                 if (length(args) > 0) 
[13:22:58.492]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.492]             }
[13:22:58.492]             else {
[13:22:58.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.492]             }
[13:22:58.492]             {
[13:22:58.492]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.492]                   0L) {
[13:22:58.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.492]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.492]                   base::options(opts)
[13:22:58.492]                 }
[13:22:58.492]                 {
[13:22:58.492]                   {
[13:22:58.492]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.492]                     NULL
[13:22:58.492]                   }
[13:22:58.492]                   options(future.plan = NULL)
[13:22:58.492]                   if (is.na(NA_character_)) 
[13:22:58.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.492]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.492]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.492]                     envir = parent.frame()) 
[13:22:58.492]                   {
[13:22:58.492]                     if (is.function(workers)) 
[13:22:58.492]                       workers <- workers()
[13:22:58.492]                     workers <- structure(as.integer(workers), 
[13:22:58.492]                       class = class(workers))
[13:22:58.492]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.492]                       workers >= 1)
[13:22:58.492]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.492]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.492]                     }
[13:22:58.492]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.492]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.492]                       envir = envir)
[13:22:58.492]                     if (!future$lazy) 
[13:22:58.492]                       future <- run(future)
[13:22:58.492]                     invisible(future)
[13:22:58.492]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.492]                 }
[13:22:58.492]             }
[13:22:58.492]         }
[13:22:58.492]     })
[13:22:58.492]     if (TRUE) {
[13:22:58.492]         base::sink(type = "output", split = FALSE)
[13:22:58.492]         if (TRUE) {
[13:22:58.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.492]         }
[13:22:58.492]         else {
[13:22:58.492]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.492]         }
[13:22:58.492]         base::close(...future.stdout)
[13:22:58.492]         ...future.stdout <- NULL
[13:22:58.492]     }
[13:22:58.492]     ...future.result$conditions <- ...future.conditions
[13:22:58.492]     ...future.result$finished <- base::Sys.time()
[13:22:58.492]     ...future.result
[13:22:58.492] }
[13:22:58.548] MultisessionFuture started
[13:22:58.548] result() for ClusterFuture ...
[13:22:58.549] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.549] - Validating connection of MultisessionFuture
[13:22:58.594] - received message: FutureResult
[13:22:58.595] - Received FutureResult
[13:22:58.595] - Erased future from FutureRegistry
[13:22:58.595] result() for ClusterFuture ...
[13:22:58.595] - result already collected: FutureResult
[13:22:58.595] result() for ClusterFuture ... done
[13:22:58.595] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.595] result() for ClusterFuture ... done
[13:22:58.596] result() for ClusterFuture ...
[13:22:58.596] - result already collected: FutureResult
[13:22:58.596] result() for ClusterFuture ... done
[13:22:58.596] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:22:58.600] plan(): nbrOfWorkers() = 2
[13:22:58.600] getGlobalsAndPackages() ...
[13:22:58.600] Searching for globals...
[13:22:58.601] - globals found: [1] ‘{’
[13:22:58.601] Searching for globals ... DONE
[13:22:58.601] Resolving globals: FALSE
[13:22:58.602] 
[13:22:58.602] 
[13:22:58.602] getGlobalsAndPackages() ... DONE
[13:22:58.602] run() for ‘Future’ ...
[13:22:58.602] - state: ‘created’
[13:22:58.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.618]   - Field: ‘node’
[13:22:58.618]   - Field: ‘label’
[13:22:58.618]   - Field: ‘local’
[13:22:58.618]   - Field: ‘owner’
[13:22:58.618]   - Field: ‘envir’
[13:22:58.618]   - Field: ‘workers’
[13:22:58.618]   - Field: ‘packages’
[13:22:58.618]   - Field: ‘gc’
[13:22:58.618]   - Field: ‘conditions’
[13:22:58.618]   - Field: ‘persistent’
[13:22:58.619]   - Field: ‘expr’
[13:22:58.619]   - Field: ‘uuid’
[13:22:58.619]   - Field: ‘seed’
[13:22:58.619]   - Field: ‘version’
[13:22:58.619]   - Field: ‘result’
[13:22:58.619]   - Field: ‘asynchronous’
[13:22:58.619]   - Field: ‘calls’
[13:22:58.619]   - Field: ‘globals’
[13:22:58.620]   - Field: ‘stdout’
[13:22:58.620]   - Field: ‘earlySignal’
[13:22:58.620]   - Field: ‘lazy’
[13:22:58.620]   - Field: ‘state’
[13:22:58.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.620] - Launch lazy future ...
[13:22:58.621] Packages needed by the future expression (n = 0): <none>
[13:22:58.621] Packages needed by future strategies (n = 0): <none>
[13:22:58.621] {
[13:22:58.621]     {
[13:22:58.621]         {
[13:22:58.621]             ...future.startTime <- base::Sys.time()
[13:22:58.621]             {
[13:22:58.621]                 {
[13:22:58.621]                   {
[13:22:58.621]                     {
[13:22:58.621]                       base::local({
[13:22:58.621]                         has_future <- base::requireNamespace("future", 
[13:22:58.621]                           quietly = TRUE)
[13:22:58.621]                         if (has_future) {
[13:22:58.621]                           ns <- base::getNamespace("future")
[13:22:58.621]                           version <- ns[[".package"]][["version"]]
[13:22:58.621]                           if (is.null(version)) 
[13:22:58.621]                             version <- utils::packageVersion("future")
[13:22:58.621]                         }
[13:22:58.621]                         else {
[13:22:58.621]                           version <- NULL
[13:22:58.621]                         }
[13:22:58.621]                         if (!has_future || version < "1.8.0") {
[13:22:58.621]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.621]                             "", base::R.version$version.string), 
[13:22:58.621]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.621]                               "release", "version")], collapse = " "), 
[13:22:58.621]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.621]                             info)
[13:22:58.621]                           info <- base::paste(info, collapse = "; ")
[13:22:58.621]                           if (!has_future) {
[13:22:58.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.621]                               info)
[13:22:58.621]                           }
[13:22:58.621]                           else {
[13:22:58.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.621]                               info, version)
[13:22:58.621]                           }
[13:22:58.621]                           base::stop(msg)
[13:22:58.621]                         }
[13:22:58.621]                       })
[13:22:58.621]                     }
[13:22:58.621]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.621]                     base::options(mc.cores = 1L)
[13:22:58.621]                   }
[13:22:58.621]                   options(future.plan = NULL)
[13:22:58.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.621]                 }
[13:22:58.621]                 ...future.workdir <- getwd()
[13:22:58.621]             }
[13:22:58.621]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.621]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.621]         }
[13:22:58.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.621]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.621]             base::names(...future.oldOptions))
[13:22:58.621]     }
[13:22:58.621]     if (FALSE) {
[13:22:58.621]     }
[13:22:58.621]     else {
[13:22:58.621]         if (TRUE) {
[13:22:58.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.621]                 open = "w")
[13:22:58.621]         }
[13:22:58.621]         else {
[13:22:58.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.621]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.621]         }
[13:22:58.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.621]             base::sink(type = "output", split = FALSE)
[13:22:58.621]             base::close(...future.stdout)
[13:22:58.621]         }, add = TRUE)
[13:22:58.621]     }
[13:22:58.621]     ...future.frame <- base::sys.nframe()
[13:22:58.621]     ...future.conditions <- base::list()
[13:22:58.621]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.621]     if (FALSE) {
[13:22:58.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.621]     }
[13:22:58.621]     ...future.result <- base::tryCatch({
[13:22:58.621]         base::withCallingHandlers({
[13:22:58.621]             ...future.value <- base::withVisible(base::local({
[13:22:58.621]                 ...future.makeSendCondition <- base::local({
[13:22:58.621]                   sendCondition <- NULL
[13:22:58.621]                   function(frame = 1L) {
[13:22:58.621]                     if (is.function(sendCondition)) 
[13:22:58.621]                       return(sendCondition)
[13:22:58.621]                     ns <- getNamespace("parallel")
[13:22:58.621]                     if (exists("sendData", mode = "function", 
[13:22:58.621]                       envir = ns)) {
[13:22:58.621]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.621]                         envir = ns)
[13:22:58.621]                       envir <- sys.frame(frame)
[13:22:58.621]                       master <- NULL
[13:22:58.621]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.621]                         !identical(envir, emptyenv())) {
[13:22:58.621]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.621]                           inherits = FALSE)) {
[13:22:58.621]                           master <- get("master", mode = "list", 
[13:22:58.621]                             envir = envir, inherits = FALSE)
[13:22:58.621]                           if (inherits(master, c("SOCKnode", 
[13:22:58.621]                             "SOCK0node"))) {
[13:22:58.621]                             sendCondition <<- function(cond) {
[13:22:58.621]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.621]                                 success = TRUE)
[13:22:58.621]                               parallel_sendData(master, data)
[13:22:58.621]                             }
[13:22:58.621]                             return(sendCondition)
[13:22:58.621]                           }
[13:22:58.621]                         }
[13:22:58.621]                         frame <- frame + 1L
[13:22:58.621]                         envir <- sys.frame(frame)
[13:22:58.621]                       }
[13:22:58.621]                     }
[13:22:58.621]                     sendCondition <<- function(cond) NULL
[13:22:58.621]                   }
[13:22:58.621]                 })
[13:22:58.621]                 withCallingHandlers({
[13:22:58.621]                   {
[13:22:58.621]                     2
[13:22:58.621]                   }
[13:22:58.621]                 }, immediateCondition = function(cond) {
[13:22:58.621]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.621]                   sendCondition(cond)
[13:22:58.621]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.621]                   {
[13:22:58.621]                     inherits <- base::inherits
[13:22:58.621]                     invokeRestart <- base::invokeRestart
[13:22:58.621]                     is.null <- base::is.null
[13:22:58.621]                     muffled <- FALSE
[13:22:58.621]                     if (inherits(cond, "message")) {
[13:22:58.621]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.621]                       if (muffled) 
[13:22:58.621]                         invokeRestart("muffleMessage")
[13:22:58.621]                     }
[13:22:58.621]                     else if (inherits(cond, "warning")) {
[13:22:58.621]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.621]                       if (muffled) 
[13:22:58.621]                         invokeRestart("muffleWarning")
[13:22:58.621]                     }
[13:22:58.621]                     else if (inherits(cond, "condition")) {
[13:22:58.621]                       if (!is.null(pattern)) {
[13:22:58.621]                         computeRestarts <- base::computeRestarts
[13:22:58.621]                         grepl <- base::grepl
[13:22:58.621]                         restarts <- computeRestarts(cond)
[13:22:58.621]                         for (restart in restarts) {
[13:22:58.621]                           name <- restart$name
[13:22:58.621]                           if (is.null(name)) 
[13:22:58.621]                             next
[13:22:58.621]                           if (!grepl(pattern, name)) 
[13:22:58.621]                             next
[13:22:58.621]                           invokeRestart(restart)
[13:22:58.621]                           muffled <- TRUE
[13:22:58.621]                           break
[13:22:58.621]                         }
[13:22:58.621]                       }
[13:22:58.621]                     }
[13:22:58.621]                     invisible(muffled)
[13:22:58.621]                   }
[13:22:58.621]                   muffleCondition(cond)
[13:22:58.621]                 })
[13:22:58.621]             }))
[13:22:58.621]             future::FutureResult(value = ...future.value$value, 
[13:22:58.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.621]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.621]                     ...future.globalenv.names))
[13:22:58.621]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.621]         }, condition = base::local({
[13:22:58.621]             c <- base::c
[13:22:58.621]             inherits <- base::inherits
[13:22:58.621]             invokeRestart <- base::invokeRestart
[13:22:58.621]             length <- base::length
[13:22:58.621]             list <- base::list
[13:22:58.621]             seq.int <- base::seq.int
[13:22:58.621]             signalCondition <- base::signalCondition
[13:22:58.621]             sys.calls <- base::sys.calls
[13:22:58.621]             `[[` <- base::`[[`
[13:22:58.621]             `+` <- base::`+`
[13:22:58.621]             `<<-` <- base::`<<-`
[13:22:58.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.621]                   3L)]
[13:22:58.621]             }
[13:22:58.621]             function(cond) {
[13:22:58.621]                 is_error <- inherits(cond, "error")
[13:22:58.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.621]                   NULL)
[13:22:58.621]                 if (is_error) {
[13:22:58.621]                   sessionInformation <- function() {
[13:22:58.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.621]                       search = base::search(), system = base::Sys.info())
[13:22:58.621]                   }
[13:22:58.621]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.621]                     cond$call), session = sessionInformation(), 
[13:22:58.621]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.621]                   signalCondition(cond)
[13:22:58.621]                 }
[13:22:58.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.621]                 "immediateCondition"))) {
[13:22:58.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.621]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.621]                   if (TRUE && !signal) {
[13:22:58.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.621]                     {
[13:22:58.621]                       inherits <- base::inherits
[13:22:58.621]                       invokeRestart <- base::invokeRestart
[13:22:58.621]                       is.null <- base::is.null
[13:22:58.621]                       muffled <- FALSE
[13:22:58.621]                       if (inherits(cond, "message")) {
[13:22:58.621]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.621]                         if (muffled) 
[13:22:58.621]                           invokeRestart("muffleMessage")
[13:22:58.621]                       }
[13:22:58.621]                       else if (inherits(cond, "warning")) {
[13:22:58.621]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.621]                         if (muffled) 
[13:22:58.621]                           invokeRestart("muffleWarning")
[13:22:58.621]                       }
[13:22:58.621]                       else if (inherits(cond, "condition")) {
[13:22:58.621]                         if (!is.null(pattern)) {
[13:22:58.621]                           computeRestarts <- base::computeRestarts
[13:22:58.621]                           grepl <- base::grepl
[13:22:58.621]                           restarts <- computeRestarts(cond)
[13:22:58.621]                           for (restart in restarts) {
[13:22:58.621]                             name <- restart$name
[13:22:58.621]                             if (is.null(name)) 
[13:22:58.621]                               next
[13:22:58.621]                             if (!grepl(pattern, name)) 
[13:22:58.621]                               next
[13:22:58.621]                             invokeRestart(restart)
[13:22:58.621]                             muffled <- TRUE
[13:22:58.621]                             break
[13:22:58.621]                           }
[13:22:58.621]                         }
[13:22:58.621]                       }
[13:22:58.621]                       invisible(muffled)
[13:22:58.621]                     }
[13:22:58.621]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.621]                   }
[13:22:58.621]                 }
[13:22:58.621]                 else {
[13:22:58.621]                   if (TRUE) {
[13:22:58.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.621]                     {
[13:22:58.621]                       inherits <- base::inherits
[13:22:58.621]                       invokeRestart <- base::invokeRestart
[13:22:58.621]                       is.null <- base::is.null
[13:22:58.621]                       muffled <- FALSE
[13:22:58.621]                       if (inherits(cond, "message")) {
[13:22:58.621]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.621]                         if (muffled) 
[13:22:58.621]                           invokeRestart("muffleMessage")
[13:22:58.621]                       }
[13:22:58.621]                       else if (inherits(cond, "warning")) {
[13:22:58.621]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.621]                         if (muffled) 
[13:22:58.621]                           invokeRestart("muffleWarning")
[13:22:58.621]                       }
[13:22:58.621]                       else if (inherits(cond, "condition")) {
[13:22:58.621]                         if (!is.null(pattern)) {
[13:22:58.621]                           computeRestarts <- base::computeRestarts
[13:22:58.621]                           grepl <- base::grepl
[13:22:58.621]                           restarts <- computeRestarts(cond)
[13:22:58.621]                           for (restart in restarts) {
[13:22:58.621]                             name <- restart$name
[13:22:58.621]                             if (is.null(name)) 
[13:22:58.621]                               next
[13:22:58.621]                             if (!grepl(pattern, name)) 
[13:22:58.621]                               next
[13:22:58.621]                             invokeRestart(restart)
[13:22:58.621]                             muffled <- TRUE
[13:22:58.621]                             break
[13:22:58.621]                           }
[13:22:58.621]                         }
[13:22:58.621]                       }
[13:22:58.621]                       invisible(muffled)
[13:22:58.621]                     }
[13:22:58.621]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.621]                   }
[13:22:58.621]                 }
[13:22:58.621]             }
[13:22:58.621]         }))
[13:22:58.621]     }, error = function(ex) {
[13:22:58.621]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.621]                 ...future.rng), started = ...future.startTime, 
[13:22:58.621]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.621]             version = "1.8"), class = "FutureResult")
[13:22:58.621]     }, finally = {
[13:22:58.621]         if (!identical(...future.workdir, getwd())) 
[13:22:58.621]             setwd(...future.workdir)
[13:22:58.621]         {
[13:22:58.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.621]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.621]             }
[13:22:58.621]             base::options(...future.oldOptions)
[13:22:58.621]             if (.Platform$OS.type == "windows") {
[13:22:58.621]                 old_names <- names(...future.oldEnvVars)
[13:22:58.621]                 envs <- base::Sys.getenv()
[13:22:58.621]                 names <- names(envs)
[13:22:58.621]                 common <- intersect(names, old_names)
[13:22:58.621]                 added <- setdiff(names, old_names)
[13:22:58.621]                 removed <- setdiff(old_names, names)
[13:22:58.621]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.621]                   envs[common]]
[13:22:58.621]                 NAMES <- toupper(changed)
[13:22:58.621]                 args <- list()
[13:22:58.621]                 for (kk in seq_along(NAMES)) {
[13:22:58.621]                   name <- changed[[kk]]
[13:22:58.621]                   NAME <- NAMES[[kk]]
[13:22:58.621]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.621]                     next
[13:22:58.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.621]                 }
[13:22:58.621]                 NAMES <- toupper(added)
[13:22:58.621]                 for (kk in seq_along(NAMES)) {
[13:22:58.621]                   name <- added[[kk]]
[13:22:58.621]                   NAME <- NAMES[[kk]]
[13:22:58.621]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.621]                     next
[13:22:58.621]                   args[[name]] <- ""
[13:22:58.621]                 }
[13:22:58.621]                 NAMES <- toupper(removed)
[13:22:58.621]                 for (kk in seq_along(NAMES)) {
[13:22:58.621]                   name <- removed[[kk]]
[13:22:58.621]                   NAME <- NAMES[[kk]]
[13:22:58.621]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.621]                     next
[13:22:58.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.621]                 }
[13:22:58.621]                 if (length(args) > 0) 
[13:22:58.621]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.621]             }
[13:22:58.621]             else {
[13:22:58.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.621]             }
[13:22:58.621]             {
[13:22:58.621]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.621]                   0L) {
[13:22:58.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.621]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.621]                   base::options(opts)
[13:22:58.621]                 }
[13:22:58.621]                 {
[13:22:58.621]                   {
[13:22:58.621]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.621]                     NULL
[13:22:58.621]                   }
[13:22:58.621]                   options(future.plan = NULL)
[13:22:58.621]                   if (is.na(NA_character_)) 
[13:22:58.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.621]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.621]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.621]                     envir = parent.frame()) 
[13:22:58.621]                   {
[13:22:58.621]                     if (is.function(workers)) 
[13:22:58.621]                       workers <- workers()
[13:22:58.621]                     workers <- structure(as.integer(workers), 
[13:22:58.621]                       class = class(workers))
[13:22:58.621]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.621]                       workers >= 1)
[13:22:58.621]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.621]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.621]                     }
[13:22:58.621]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.621]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.621]                       envir = envir)
[13:22:58.621]                     if (!future$lazy) 
[13:22:58.621]                       future <- run(future)
[13:22:58.621]                     invisible(future)
[13:22:58.621]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.621]                 }
[13:22:58.621]             }
[13:22:58.621]         }
[13:22:58.621]     })
[13:22:58.621]     if (TRUE) {
[13:22:58.621]         base::sink(type = "output", split = FALSE)
[13:22:58.621]         if (TRUE) {
[13:22:58.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.621]         }
[13:22:58.621]         else {
[13:22:58.621]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.621]         }
[13:22:58.621]         base::close(...future.stdout)
[13:22:58.621]         ...future.stdout <- NULL
[13:22:58.621]     }
[13:22:58.621]     ...future.result$conditions <- ...future.conditions
[13:22:58.621]     ...future.result$finished <- base::Sys.time()
[13:22:58.621]     ...future.result
[13:22:58.621] }
[13:22:58.625] MultisessionFuture started
[13:22:58.625] - Launch lazy future ... done
[13:22:58.625] run() for ‘MultisessionFuture’ ... done
[13:22:58.626] getGlobalsAndPackages() ...
[13:22:58.626] Searching for globals...
[13:22:58.627] - globals found: [1] ‘{’
[13:22:58.627] Searching for globals ... DONE
[13:22:58.627] Resolving globals: FALSE
[13:22:58.627] 
[13:22:58.627] 
[13:22:58.627] getGlobalsAndPackages() ... DONE
[13:22:58.628] run() for ‘Future’ ...
[13:22:58.628] - state: ‘created’
[13:22:58.628] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.643] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.643]   - Field: ‘node’
[13:22:58.643]   - Field: ‘label’
[13:22:58.643]   - Field: ‘local’
[13:22:58.644]   - Field: ‘owner’
[13:22:58.644]   - Field: ‘envir’
[13:22:58.644]   - Field: ‘workers’
[13:22:58.644]   - Field: ‘packages’
[13:22:58.644]   - Field: ‘gc’
[13:22:58.644]   - Field: ‘conditions’
[13:22:58.644]   - Field: ‘persistent’
[13:22:58.644]   - Field: ‘expr’
[13:22:58.644]   - Field: ‘uuid’
[13:22:58.645]   - Field: ‘seed’
[13:22:58.645]   - Field: ‘version’
[13:22:58.645]   - Field: ‘result’
[13:22:58.645]   - Field: ‘asynchronous’
[13:22:58.645]   - Field: ‘calls’
[13:22:58.645]   - Field: ‘globals’
[13:22:58.645]   - Field: ‘stdout’
[13:22:58.645]   - Field: ‘earlySignal’
[13:22:58.646]   - Field: ‘lazy’
[13:22:58.646]   - Field: ‘state’
[13:22:58.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.646] - Launch lazy future ...
[13:22:58.646] Packages needed by the future expression (n = 0): <none>
[13:22:58.646] Packages needed by future strategies (n = 0): <none>
[13:22:58.647] {
[13:22:58.647]     {
[13:22:58.647]         {
[13:22:58.647]             ...future.startTime <- base::Sys.time()
[13:22:58.647]             {
[13:22:58.647]                 {
[13:22:58.647]                   {
[13:22:58.647]                     {
[13:22:58.647]                       base::local({
[13:22:58.647]                         has_future <- base::requireNamespace("future", 
[13:22:58.647]                           quietly = TRUE)
[13:22:58.647]                         if (has_future) {
[13:22:58.647]                           ns <- base::getNamespace("future")
[13:22:58.647]                           version <- ns[[".package"]][["version"]]
[13:22:58.647]                           if (is.null(version)) 
[13:22:58.647]                             version <- utils::packageVersion("future")
[13:22:58.647]                         }
[13:22:58.647]                         else {
[13:22:58.647]                           version <- NULL
[13:22:58.647]                         }
[13:22:58.647]                         if (!has_future || version < "1.8.0") {
[13:22:58.647]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.647]                             "", base::R.version$version.string), 
[13:22:58.647]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.647]                               "release", "version")], collapse = " "), 
[13:22:58.647]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.647]                             info)
[13:22:58.647]                           info <- base::paste(info, collapse = "; ")
[13:22:58.647]                           if (!has_future) {
[13:22:58.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.647]                               info)
[13:22:58.647]                           }
[13:22:58.647]                           else {
[13:22:58.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.647]                               info, version)
[13:22:58.647]                           }
[13:22:58.647]                           base::stop(msg)
[13:22:58.647]                         }
[13:22:58.647]                       })
[13:22:58.647]                     }
[13:22:58.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.647]                     base::options(mc.cores = 1L)
[13:22:58.647]                   }
[13:22:58.647]                   options(future.plan = NULL)
[13:22:58.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.647]                 }
[13:22:58.647]                 ...future.workdir <- getwd()
[13:22:58.647]             }
[13:22:58.647]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.647]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.647]         }
[13:22:58.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.647]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.647]             base::names(...future.oldOptions))
[13:22:58.647]     }
[13:22:58.647]     if (FALSE) {
[13:22:58.647]     }
[13:22:58.647]     else {
[13:22:58.647]         if (TRUE) {
[13:22:58.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.647]                 open = "w")
[13:22:58.647]         }
[13:22:58.647]         else {
[13:22:58.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.647]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.647]         }
[13:22:58.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.647]             base::sink(type = "output", split = FALSE)
[13:22:58.647]             base::close(...future.stdout)
[13:22:58.647]         }, add = TRUE)
[13:22:58.647]     }
[13:22:58.647]     ...future.frame <- base::sys.nframe()
[13:22:58.647]     ...future.conditions <- base::list()
[13:22:58.647]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.647]     if (FALSE) {
[13:22:58.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.647]     }
[13:22:58.647]     ...future.result <- base::tryCatch({
[13:22:58.647]         base::withCallingHandlers({
[13:22:58.647]             ...future.value <- base::withVisible(base::local({
[13:22:58.647]                 ...future.makeSendCondition <- base::local({
[13:22:58.647]                   sendCondition <- NULL
[13:22:58.647]                   function(frame = 1L) {
[13:22:58.647]                     if (is.function(sendCondition)) 
[13:22:58.647]                       return(sendCondition)
[13:22:58.647]                     ns <- getNamespace("parallel")
[13:22:58.647]                     if (exists("sendData", mode = "function", 
[13:22:58.647]                       envir = ns)) {
[13:22:58.647]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.647]                         envir = ns)
[13:22:58.647]                       envir <- sys.frame(frame)
[13:22:58.647]                       master <- NULL
[13:22:58.647]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.647]                         !identical(envir, emptyenv())) {
[13:22:58.647]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.647]                           inherits = FALSE)) {
[13:22:58.647]                           master <- get("master", mode = "list", 
[13:22:58.647]                             envir = envir, inherits = FALSE)
[13:22:58.647]                           if (inherits(master, c("SOCKnode", 
[13:22:58.647]                             "SOCK0node"))) {
[13:22:58.647]                             sendCondition <<- function(cond) {
[13:22:58.647]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.647]                                 success = TRUE)
[13:22:58.647]                               parallel_sendData(master, data)
[13:22:58.647]                             }
[13:22:58.647]                             return(sendCondition)
[13:22:58.647]                           }
[13:22:58.647]                         }
[13:22:58.647]                         frame <- frame + 1L
[13:22:58.647]                         envir <- sys.frame(frame)
[13:22:58.647]                       }
[13:22:58.647]                     }
[13:22:58.647]                     sendCondition <<- function(cond) NULL
[13:22:58.647]                   }
[13:22:58.647]                 })
[13:22:58.647]                 withCallingHandlers({
[13:22:58.647]                   {
[13:22:58.647]                     4
[13:22:58.647]                   }
[13:22:58.647]                 }, immediateCondition = function(cond) {
[13:22:58.647]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.647]                   sendCondition(cond)
[13:22:58.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.647]                   {
[13:22:58.647]                     inherits <- base::inherits
[13:22:58.647]                     invokeRestart <- base::invokeRestart
[13:22:58.647]                     is.null <- base::is.null
[13:22:58.647]                     muffled <- FALSE
[13:22:58.647]                     if (inherits(cond, "message")) {
[13:22:58.647]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.647]                       if (muffled) 
[13:22:58.647]                         invokeRestart("muffleMessage")
[13:22:58.647]                     }
[13:22:58.647]                     else if (inherits(cond, "warning")) {
[13:22:58.647]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.647]                       if (muffled) 
[13:22:58.647]                         invokeRestart("muffleWarning")
[13:22:58.647]                     }
[13:22:58.647]                     else if (inherits(cond, "condition")) {
[13:22:58.647]                       if (!is.null(pattern)) {
[13:22:58.647]                         computeRestarts <- base::computeRestarts
[13:22:58.647]                         grepl <- base::grepl
[13:22:58.647]                         restarts <- computeRestarts(cond)
[13:22:58.647]                         for (restart in restarts) {
[13:22:58.647]                           name <- restart$name
[13:22:58.647]                           if (is.null(name)) 
[13:22:58.647]                             next
[13:22:58.647]                           if (!grepl(pattern, name)) 
[13:22:58.647]                             next
[13:22:58.647]                           invokeRestart(restart)
[13:22:58.647]                           muffled <- TRUE
[13:22:58.647]                           break
[13:22:58.647]                         }
[13:22:58.647]                       }
[13:22:58.647]                     }
[13:22:58.647]                     invisible(muffled)
[13:22:58.647]                   }
[13:22:58.647]                   muffleCondition(cond)
[13:22:58.647]                 })
[13:22:58.647]             }))
[13:22:58.647]             future::FutureResult(value = ...future.value$value, 
[13:22:58.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.647]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.647]                     ...future.globalenv.names))
[13:22:58.647]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.647]         }, condition = base::local({
[13:22:58.647]             c <- base::c
[13:22:58.647]             inherits <- base::inherits
[13:22:58.647]             invokeRestart <- base::invokeRestart
[13:22:58.647]             length <- base::length
[13:22:58.647]             list <- base::list
[13:22:58.647]             seq.int <- base::seq.int
[13:22:58.647]             signalCondition <- base::signalCondition
[13:22:58.647]             sys.calls <- base::sys.calls
[13:22:58.647]             `[[` <- base::`[[`
[13:22:58.647]             `+` <- base::`+`
[13:22:58.647]             `<<-` <- base::`<<-`
[13:22:58.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.647]                   3L)]
[13:22:58.647]             }
[13:22:58.647]             function(cond) {
[13:22:58.647]                 is_error <- inherits(cond, "error")
[13:22:58.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.647]                   NULL)
[13:22:58.647]                 if (is_error) {
[13:22:58.647]                   sessionInformation <- function() {
[13:22:58.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.647]                       search = base::search(), system = base::Sys.info())
[13:22:58.647]                   }
[13:22:58.647]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.647]                     cond$call), session = sessionInformation(), 
[13:22:58.647]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.647]                   signalCondition(cond)
[13:22:58.647]                 }
[13:22:58.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.647]                 "immediateCondition"))) {
[13:22:58.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.647]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.647]                   if (TRUE && !signal) {
[13:22:58.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.647]                     {
[13:22:58.647]                       inherits <- base::inherits
[13:22:58.647]                       invokeRestart <- base::invokeRestart
[13:22:58.647]                       is.null <- base::is.null
[13:22:58.647]                       muffled <- FALSE
[13:22:58.647]                       if (inherits(cond, "message")) {
[13:22:58.647]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.647]                         if (muffled) 
[13:22:58.647]                           invokeRestart("muffleMessage")
[13:22:58.647]                       }
[13:22:58.647]                       else if (inherits(cond, "warning")) {
[13:22:58.647]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.647]                         if (muffled) 
[13:22:58.647]                           invokeRestart("muffleWarning")
[13:22:58.647]                       }
[13:22:58.647]                       else if (inherits(cond, "condition")) {
[13:22:58.647]                         if (!is.null(pattern)) {
[13:22:58.647]                           computeRestarts <- base::computeRestarts
[13:22:58.647]                           grepl <- base::grepl
[13:22:58.647]                           restarts <- computeRestarts(cond)
[13:22:58.647]                           for (restart in restarts) {
[13:22:58.647]                             name <- restart$name
[13:22:58.647]                             if (is.null(name)) 
[13:22:58.647]                               next
[13:22:58.647]                             if (!grepl(pattern, name)) 
[13:22:58.647]                               next
[13:22:58.647]                             invokeRestart(restart)
[13:22:58.647]                             muffled <- TRUE
[13:22:58.647]                             break
[13:22:58.647]                           }
[13:22:58.647]                         }
[13:22:58.647]                       }
[13:22:58.647]                       invisible(muffled)
[13:22:58.647]                     }
[13:22:58.647]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.647]                   }
[13:22:58.647]                 }
[13:22:58.647]                 else {
[13:22:58.647]                   if (TRUE) {
[13:22:58.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.647]                     {
[13:22:58.647]                       inherits <- base::inherits
[13:22:58.647]                       invokeRestart <- base::invokeRestart
[13:22:58.647]                       is.null <- base::is.null
[13:22:58.647]                       muffled <- FALSE
[13:22:58.647]                       if (inherits(cond, "message")) {
[13:22:58.647]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.647]                         if (muffled) 
[13:22:58.647]                           invokeRestart("muffleMessage")
[13:22:58.647]                       }
[13:22:58.647]                       else if (inherits(cond, "warning")) {
[13:22:58.647]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.647]                         if (muffled) 
[13:22:58.647]                           invokeRestart("muffleWarning")
[13:22:58.647]                       }
[13:22:58.647]                       else if (inherits(cond, "condition")) {
[13:22:58.647]                         if (!is.null(pattern)) {
[13:22:58.647]                           computeRestarts <- base::computeRestarts
[13:22:58.647]                           grepl <- base::grepl
[13:22:58.647]                           restarts <- computeRestarts(cond)
[13:22:58.647]                           for (restart in restarts) {
[13:22:58.647]                             name <- restart$name
[13:22:58.647]                             if (is.null(name)) 
[13:22:58.647]                               next
[13:22:58.647]                             if (!grepl(pattern, name)) 
[13:22:58.647]                               next
[13:22:58.647]                             invokeRestart(restart)
[13:22:58.647]                             muffled <- TRUE
[13:22:58.647]                             break
[13:22:58.647]                           }
[13:22:58.647]                         }
[13:22:58.647]                       }
[13:22:58.647]                       invisible(muffled)
[13:22:58.647]                     }
[13:22:58.647]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.647]                   }
[13:22:58.647]                 }
[13:22:58.647]             }
[13:22:58.647]         }))
[13:22:58.647]     }, error = function(ex) {
[13:22:58.647]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.647]                 ...future.rng), started = ...future.startTime, 
[13:22:58.647]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.647]             version = "1.8"), class = "FutureResult")
[13:22:58.647]     }, finally = {
[13:22:58.647]         if (!identical(...future.workdir, getwd())) 
[13:22:58.647]             setwd(...future.workdir)
[13:22:58.647]         {
[13:22:58.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.647]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.647]             }
[13:22:58.647]             base::options(...future.oldOptions)
[13:22:58.647]             if (.Platform$OS.type == "windows") {
[13:22:58.647]                 old_names <- names(...future.oldEnvVars)
[13:22:58.647]                 envs <- base::Sys.getenv()
[13:22:58.647]                 names <- names(envs)
[13:22:58.647]                 common <- intersect(names, old_names)
[13:22:58.647]                 added <- setdiff(names, old_names)
[13:22:58.647]                 removed <- setdiff(old_names, names)
[13:22:58.647]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.647]                   envs[common]]
[13:22:58.647]                 NAMES <- toupper(changed)
[13:22:58.647]                 args <- list()
[13:22:58.647]                 for (kk in seq_along(NAMES)) {
[13:22:58.647]                   name <- changed[[kk]]
[13:22:58.647]                   NAME <- NAMES[[kk]]
[13:22:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.647]                     next
[13:22:58.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.647]                 }
[13:22:58.647]                 NAMES <- toupper(added)
[13:22:58.647]                 for (kk in seq_along(NAMES)) {
[13:22:58.647]                   name <- added[[kk]]
[13:22:58.647]                   NAME <- NAMES[[kk]]
[13:22:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.647]                     next
[13:22:58.647]                   args[[name]] <- ""
[13:22:58.647]                 }
[13:22:58.647]                 NAMES <- toupper(removed)
[13:22:58.647]                 for (kk in seq_along(NAMES)) {
[13:22:58.647]                   name <- removed[[kk]]
[13:22:58.647]                   NAME <- NAMES[[kk]]
[13:22:58.647]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.647]                     next
[13:22:58.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.647]                 }
[13:22:58.647]                 if (length(args) > 0) 
[13:22:58.647]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.647]             }
[13:22:58.647]             else {
[13:22:58.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.647]             }
[13:22:58.647]             {
[13:22:58.647]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.647]                   0L) {
[13:22:58.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.647]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.647]                   base::options(opts)
[13:22:58.647]                 }
[13:22:58.647]                 {
[13:22:58.647]                   {
[13:22:58.647]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.647]                     NULL
[13:22:58.647]                   }
[13:22:58.647]                   options(future.plan = NULL)
[13:22:58.647]                   if (is.na(NA_character_)) 
[13:22:58.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.647]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.647]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.647]                     envir = parent.frame()) 
[13:22:58.647]                   {
[13:22:58.647]                     if (is.function(workers)) 
[13:22:58.647]                       workers <- workers()
[13:22:58.647]                     workers <- structure(as.integer(workers), 
[13:22:58.647]                       class = class(workers))
[13:22:58.647]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.647]                       workers >= 1)
[13:22:58.647]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.647]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.647]                     }
[13:22:58.647]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.647]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.647]                       envir = envir)
[13:22:58.647]                     if (!future$lazy) 
[13:22:58.647]                       future <- run(future)
[13:22:58.647]                     invisible(future)
[13:22:58.647]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.647]                 }
[13:22:58.647]             }
[13:22:58.647]         }
[13:22:58.647]     })
[13:22:58.647]     if (TRUE) {
[13:22:58.647]         base::sink(type = "output", split = FALSE)
[13:22:58.647]         if (TRUE) {
[13:22:58.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.647]         }
[13:22:58.647]         else {
[13:22:58.647]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.647]         }
[13:22:58.647]         base::close(...future.stdout)
[13:22:58.647]         ...future.stdout <- NULL
[13:22:58.647]     }
[13:22:58.647]     ...future.result$conditions <- ...future.conditions
[13:22:58.647]     ...future.result$finished <- base::Sys.time()
[13:22:58.647]     ...future.result
[13:22:58.647] }
[13:22:58.705] MultisessionFuture started
[13:22:58.705] - Launch lazy future ... done
[13:22:58.705] run() for ‘MultisessionFuture’ ... done
[13:22:58.706] result() for ClusterFuture ...
[13:22:58.706] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.706] - Validating connection of MultisessionFuture
[13:22:58.706] - received message: FutureResult
[13:22:58.707] - Received FutureResult
[13:22:58.707] - Erased future from FutureRegistry
[13:22:58.707] result() for ClusterFuture ...
[13:22:58.707] - result already collected: FutureResult
[13:22:58.707] result() for ClusterFuture ... done
[13:22:58.708] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.708] result() for ClusterFuture ... done
[13:22:58.708] result() for ClusterFuture ...
[13:22:58.708] - result already collected: FutureResult
[13:22:58.708] result() for ClusterFuture ... done
u$a = 2
[13:22:58.709] result() for ClusterFuture ...
[13:22:58.709] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.709] - Validating connection of MultisessionFuture
[13:22:58.755] - received message: FutureResult
[13:22:58.755] - Received FutureResult
[13:22:58.755] - Erased future from FutureRegistry
[13:22:58.755] result() for ClusterFuture ...
[13:22:58.755] - result already collected: FutureResult
[13:22:58.755] result() for ClusterFuture ... done
[13:22:58.756] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.756] result() for ClusterFuture ... done
[13:22:58.756] result() for ClusterFuture ...
[13:22:58.756] - result already collected: FutureResult
[13:22:58.756] result() for ClusterFuture ... done
v$a = 4
[13:22:58.756] getGlobalsAndPackages() ...
[13:22:58.756] Searching for globals...
[13:22:58.758] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:58.758] Searching for globals ... DONE
[13:22:58.758] Resolving globals: FALSE
[13:22:58.758] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:58.759] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:58.759] - globals: [1] ‘a’
[13:22:58.759] 
[13:22:58.759] getGlobalsAndPackages() ... DONE
[13:22:58.760] run() for ‘Future’ ...
[13:22:58.760] - state: ‘created’
[13:22:58.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.775]   - Field: ‘node’
[13:22:58.775]   - Field: ‘label’
[13:22:58.775]   - Field: ‘local’
[13:22:58.775]   - Field: ‘owner’
[13:22:58.775]   - Field: ‘envir’
[13:22:58.776]   - Field: ‘workers’
[13:22:58.776]   - Field: ‘packages’
[13:22:58.776]   - Field: ‘gc’
[13:22:58.776]   - Field: ‘conditions’
[13:22:58.776]   - Field: ‘persistent’
[13:22:58.776]   - Field: ‘expr’
[13:22:58.776]   - Field: ‘uuid’
[13:22:58.776]   - Field: ‘seed’
[13:22:58.777]   - Field: ‘version’
[13:22:58.777]   - Field: ‘result’
[13:22:58.777]   - Field: ‘asynchronous’
[13:22:58.777]   - Field: ‘calls’
[13:22:58.777]   - Field: ‘globals’
[13:22:58.777]   - Field: ‘stdout’
[13:22:58.777]   - Field: ‘earlySignal’
[13:22:58.777]   - Field: ‘lazy’
[13:22:58.778]   - Field: ‘state’
[13:22:58.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.778] - Launch lazy future ...
[13:22:58.778] Packages needed by the future expression (n = 0): <none>
[13:22:58.778] Packages needed by future strategies (n = 0): <none>
[13:22:58.779] {
[13:22:58.779]     {
[13:22:58.779]         {
[13:22:58.779]             ...future.startTime <- base::Sys.time()
[13:22:58.779]             {
[13:22:58.779]                 {
[13:22:58.779]                   {
[13:22:58.779]                     {
[13:22:58.779]                       base::local({
[13:22:58.779]                         has_future <- base::requireNamespace("future", 
[13:22:58.779]                           quietly = TRUE)
[13:22:58.779]                         if (has_future) {
[13:22:58.779]                           ns <- base::getNamespace("future")
[13:22:58.779]                           version <- ns[[".package"]][["version"]]
[13:22:58.779]                           if (is.null(version)) 
[13:22:58.779]                             version <- utils::packageVersion("future")
[13:22:58.779]                         }
[13:22:58.779]                         else {
[13:22:58.779]                           version <- NULL
[13:22:58.779]                         }
[13:22:58.779]                         if (!has_future || version < "1.8.0") {
[13:22:58.779]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.779]                             "", base::R.version$version.string), 
[13:22:58.779]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.779]                               "release", "version")], collapse = " "), 
[13:22:58.779]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.779]                             info)
[13:22:58.779]                           info <- base::paste(info, collapse = "; ")
[13:22:58.779]                           if (!has_future) {
[13:22:58.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.779]                               info)
[13:22:58.779]                           }
[13:22:58.779]                           else {
[13:22:58.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.779]                               info, version)
[13:22:58.779]                           }
[13:22:58.779]                           base::stop(msg)
[13:22:58.779]                         }
[13:22:58.779]                       })
[13:22:58.779]                     }
[13:22:58.779]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.779]                     base::options(mc.cores = 1L)
[13:22:58.779]                   }
[13:22:58.779]                   options(future.plan = NULL)
[13:22:58.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.779]                 }
[13:22:58.779]                 ...future.workdir <- getwd()
[13:22:58.779]             }
[13:22:58.779]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.779]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.779]         }
[13:22:58.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.779]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.779]             base::names(...future.oldOptions))
[13:22:58.779]     }
[13:22:58.779]     if (FALSE) {
[13:22:58.779]     }
[13:22:58.779]     else {
[13:22:58.779]         if (TRUE) {
[13:22:58.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.779]                 open = "w")
[13:22:58.779]         }
[13:22:58.779]         else {
[13:22:58.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.779]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.779]         }
[13:22:58.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.779]             base::sink(type = "output", split = FALSE)
[13:22:58.779]             base::close(...future.stdout)
[13:22:58.779]         }, add = TRUE)
[13:22:58.779]     }
[13:22:58.779]     ...future.frame <- base::sys.nframe()
[13:22:58.779]     ...future.conditions <- base::list()
[13:22:58.779]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.779]     if (FALSE) {
[13:22:58.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.779]     }
[13:22:58.779]     ...future.result <- base::tryCatch({
[13:22:58.779]         base::withCallingHandlers({
[13:22:58.779]             ...future.value <- base::withVisible(base::local({
[13:22:58.779]                 ...future.makeSendCondition <- base::local({
[13:22:58.779]                   sendCondition <- NULL
[13:22:58.779]                   function(frame = 1L) {
[13:22:58.779]                     if (is.function(sendCondition)) 
[13:22:58.779]                       return(sendCondition)
[13:22:58.779]                     ns <- getNamespace("parallel")
[13:22:58.779]                     if (exists("sendData", mode = "function", 
[13:22:58.779]                       envir = ns)) {
[13:22:58.779]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.779]                         envir = ns)
[13:22:58.779]                       envir <- sys.frame(frame)
[13:22:58.779]                       master <- NULL
[13:22:58.779]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.779]                         !identical(envir, emptyenv())) {
[13:22:58.779]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.779]                           inherits = FALSE)) {
[13:22:58.779]                           master <- get("master", mode = "list", 
[13:22:58.779]                             envir = envir, inherits = FALSE)
[13:22:58.779]                           if (inherits(master, c("SOCKnode", 
[13:22:58.779]                             "SOCK0node"))) {
[13:22:58.779]                             sendCondition <<- function(cond) {
[13:22:58.779]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.779]                                 success = TRUE)
[13:22:58.779]                               parallel_sendData(master, data)
[13:22:58.779]                             }
[13:22:58.779]                             return(sendCondition)
[13:22:58.779]                           }
[13:22:58.779]                         }
[13:22:58.779]                         frame <- frame + 1L
[13:22:58.779]                         envir <- sys.frame(frame)
[13:22:58.779]                       }
[13:22:58.779]                     }
[13:22:58.779]                     sendCondition <<- function(cond) NULL
[13:22:58.779]                   }
[13:22:58.779]                 })
[13:22:58.779]                 withCallingHandlers({
[13:22:58.779]                   {
[13:22:58.779]                     2 * a
[13:22:58.779]                   }
[13:22:58.779]                 }, immediateCondition = function(cond) {
[13:22:58.779]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.779]                   sendCondition(cond)
[13:22:58.779]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.779]                   {
[13:22:58.779]                     inherits <- base::inherits
[13:22:58.779]                     invokeRestart <- base::invokeRestart
[13:22:58.779]                     is.null <- base::is.null
[13:22:58.779]                     muffled <- FALSE
[13:22:58.779]                     if (inherits(cond, "message")) {
[13:22:58.779]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.779]                       if (muffled) 
[13:22:58.779]                         invokeRestart("muffleMessage")
[13:22:58.779]                     }
[13:22:58.779]                     else if (inherits(cond, "warning")) {
[13:22:58.779]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.779]                       if (muffled) 
[13:22:58.779]                         invokeRestart("muffleWarning")
[13:22:58.779]                     }
[13:22:58.779]                     else if (inherits(cond, "condition")) {
[13:22:58.779]                       if (!is.null(pattern)) {
[13:22:58.779]                         computeRestarts <- base::computeRestarts
[13:22:58.779]                         grepl <- base::grepl
[13:22:58.779]                         restarts <- computeRestarts(cond)
[13:22:58.779]                         for (restart in restarts) {
[13:22:58.779]                           name <- restart$name
[13:22:58.779]                           if (is.null(name)) 
[13:22:58.779]                             next
[13:22:58.779]                           if (!grepl(pattern, name)) 
[13:22:58.779]                             next
[13:22:58.779]                           invokeRestart(restart)
[13:22:58.779]                           muffled <- TRUE
[13:22:58.779]                           break
[13:22:58.779]                         }
[13:22:58.779]                       }
[13:22:58.779]                     }
[13:22:58.779]                     invisible(muffled)
[13:22:58.779]                   }
[13:22:58.779]                   muffleCondition(cond)
[13:22:58.779]                 })
[13:22:58.779]             }))
[13:22:58.779]             future::FutureResult(value = ...future.value$value, 
[13:22:58.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.779]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.779]                     ...future.globalenv.names))
[13:22:58.779]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.779]         }, condition = base::local({
[13:22:58.779]             c <- base::c
[13:22:58.779]             inherits <- base::inherits
[13:22:58.779]             invokeRestart <- base::invokeRestart
[13:22:58.779]             length <- base::length
[13:22:58.779]             list <- base::list
[13:22:58.779]             seq.int <- base::seq.int
[13:22:58.779]             signalCondition <- base::signalCondition
[13:22:58.779]             sys.calls <- base::sys.calls
[13:22:58.779]             `[[` <- base::`[[`
[13:22:58.779]             `+` <- base::`+`
[13:22:58.779]             `<<-` <- base::`<<-`
[13:22:58.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.779]                   3L)]
[13:22:58.779]             }
[13:22:58.779]             function(cond) {
[13:22:58.779]                 is_error <- inherits(cond, "error")
[13:22:58.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.779]                   NULL)
[13:22:58.779]                 if (is_error) {
[13:22:58.779]                   sessionInformation <- function() {
[13:22:58.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.779]                       search = base::search(), system = base::Sys.info())
[13:22:58.779]                   }
[13:22:58.779]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.779]                     cond$call), session = sessionInformation(), 
[13:22:58.779]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.779]                   signalCondition(cond)
[13:22:58.779]                 }
[13:22:58.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.779]                 "immediateCondition"))) {
[13:22:58.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.779]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.779]                   if (TRUE && !signal) {
[13:22:58.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.779]                     {
[13:22:58.779]                       inherits <- base::inherits
[13:22:58.779]                       invokeRestart <- base::invokeRestart
[13:22:58.779]                       is.null <- base::is.null
[13:22:58.779]                       muffled <- FALSE
[13:22:58.779]                       if (inherits(cond, "message")) {
[13:22:58.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.779]                         if (muffled) 
[13:22:58.779]                           invokeRestart("muffleMessage")
[13:22:58.779]                       }
[13:22:58.779]                       else if (inherits(cond, "warning")) {
[13:22:58.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.779]                         if (muffled) 
[13:22:58.779]                           invokeRestart("muffleWarning")
[13:22:58.779]                       }
[13:22:58.779]                       else if (inherits(cond, "condition")) {
[13:22:58.779]                         if (!is.null(pattern)) {
[13:22:58.779]                           computeRestarts <- base::computeRestarts
[13:22:58.779]                           grepl <- base::grepl
[13:22:58.779]                           restarts <- computeRestarts(cond)
[13:22:58.779]                           for (restart in restarts) {
[13:22:58.779]                             name <- restart$name
[13:22:58.779]                             if (is.null(name)) 
[13:22:58.779]                               next
[13:22:58.779]                             if (!grepl(pattern, name)) 
[13:22:58.779]                               next
[13:22:58.779]                             invokeRestart(restart)
[13:22:58.779]                             muffled <- TRUE
[13:22:58.779]                             break
[13:22:58.779]                           }
[13:22:58.779]                         }
[13:22:58.779]                       }
[13:22:58.779]                       invisible(muffled)
[13:22:58.779]                     }
[13:22:58.779]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.779]                   }
[13:22:58.779]                 }
[13:22:58.779]                 else {
[13:22:58.779]                   if (TRUE) {
[13:22:58.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.779]                     {
[13:22:58.779]                       inherits <- base::inherits
[13:22:58.779]                       invokeRestart <- base::invokeRestart
[13:22:58.779]                       is.null <- base::is.null
[13:22:58.779]                       muffled <- FALSE
[13:22:58.779]                       if (inherits(cond, "message")) {
[13:22:58.779]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.779]                         if (muffled) 
[13:22:58.779]                           invokeRestart("muffleMessage")
[13:22:58.779]                       }
[13:22:58.779]                       else if (inherits(cond, "warning")) {
[13:22:58.779]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.779]                         if (muffled) 
[13:22:58.779]                           invokeRestart("muffleWarning")
[13:22:58.779]                       }
[13:22:58.779]                       else if (inherits(cond, "condition")) {
[13:22:58.779]                         if (!is.null(pattern)) {
[13:22:58.779]                           computeRestarts <- base::computeRestarts
[13:22:58.779]                           grepl <- base::grepl
[13:22:58.779]                           restarts <- computeRestarts(cond)
[13:22:58.779]                           for (restart in restarts) {
[13:22:58.779]                             name <- restart$name
[13:22:58.779]                             if (is.null(name)) 
[13:22:58.779]                               next
[13:22:58.779]                             if (!grepl(pattern, name)) 
[13:22:58.779]                               next
[13:22:58.779]                             invokeRestart(restart)
[13:22:58.779]                             muffled <- TRUE
[13:22:58.779]                             break
[13:22:58.779]                           }
[13:22:58.779]                         }
[13:22:58.779]                       }
[13:22:58.779]                       invisible(muffled)
[13:22:58.779]                     }
[13:22:58.779]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.779]                   }
[13:22:58.779]                 }
[13:22:58.779]             }
[13:22:58.779]         }))
[13:22:58.779]     }, error = function(ex) {
[13:22:58.779]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.779]                 ...future.rng), started = ...future.startTime, 
[13:22:58.779]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.779]             version = "1.8"), class = "FutureResult")
[13:22:58.779]     }, finally = {
[13:22:58.779]         if (!identical(...future.workdir, getwd())) 
[13:22:58.779]             setwd(...future.workdir)
[13:22:58.779]         {
[13:22:58.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.779]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.779]             }
[13:22:58.779]             base::options(...future.oldOptions)
[13:22:58.779]             if (.Platform$OS.type == "windows") {
[13:22:58.779]                 old_names <- names(...future.oldEnvVars)
[13:22:58.779]                 envs <- base::Sys.getenv()
[13:22:58.779]                 names <- names(envs)
[13:22:58.779]                 common <- intersect(names, old_names)
[13:22:58.779]                 added <- setdiff(names, old_names)
[13:22:58.779]                 removed <- setdiff(old_names, names)
[13:22:58.779]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.779]                   envs[common]]
[13:22:58.779]                 NAMES <- toupper(changed)
[13:22:58.779]                 args <- list()
[13:22:58.779]                 for (kk in seq_along(NAMES)) {
[13:22:58.779]                   name <- changed[[kk]]
[13:22:58.779]                   NAME <- NAMES[[kk]]
[13:22:58.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.779]                     next
[13:22:58.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.779]                 }
[13:22:58.779]                 NAMES <- toupper(added)
[13:22:58.779]                 for (kk in seq_along(NAMES)) {
[13:22:58.779]                   name <- added[[kk]]
[13:22:58.779]                   NAME <- NAMES[[kk]]
[13:22:58.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.779]                     next
[13:22:58.779]                   args[[name]] <- ""
[13:22:58.779]                 }
[13:22:58.779]                 NAMES <- toupper(removed)
[13:22:58.779]                 for (kk in seq_along(NAMES)) {
[13:22:58.779]                   name <- removed[[kk]]
[13:22:58.779]                   NAME <- NAMES[[kk]]
[13:22:58.779]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.779]                     next
[13:22:58.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.779]                 }
[13:22:58.779]                 if (length(args) > 0) 
[13:22:58.779]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.779]             }
[13:22:58.779]             else {
[13:22:58.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.779]             }
[13:22:58.779]             {
[13:22:58.779]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.779]                   0L) {
[13:22:58.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.779]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.779]                   base::options(opts)
[13:22:58.779]                 }
[13:22:58.779]                 {
[13:22:58.779]                   {
[13:22:58.779]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.779]                     NULL
[13:22:58.779]                   }
[13:22:58.779]                   options(future.plan = NULL)
[13:22:58.779]                   if (is.na(NA_character_)) 
[13:22:58.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.779]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.779]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.779]                     envir = parent.frame()) 
[13:22:58.779]                   {
[13:22:58.779]                     if (is.function(workers)) 
[13:22:58.779]                       workers <- workers()
[13:22:58.779]                     workers <- structure(as.integer(workers), 
[13:22:58.779]                       class = class(workers))
[13:22:58.779]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.779]                       workers >= 1)
[13:22:58.779]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.779]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.779]                     }
[13:22:58.779]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.779]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.779]                       envir = envir)
[13:22:58.779]                     if (!future$lazy) 
[13:22:58.779]                       future <- run(future)
[13:22:58.779]                     invisible(future)
[13:22:58.779]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.779]                 }
[13:22:58.779]             }
[13:22:58.779]         }
[13:22:58.779]     })
[13:22:58.779]     if (TRUE) {
[13:22:58.779]         base::sink(type = "output", split = FALSE)
[13:22:58.779]         if (TRUE) {
[13:22:58.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.779]         }
[13:22:58.779]         else {
[13:22:58.779]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.779]         }
[13:22:58.779]         base::close(...future.stdout)
[13:22:58.779]         ...future.stdout <- NULL
[13:22:58.779]     }
[13:22:58.779]     ...future.result$conditions <- ...future.conditions
[13:22:58.779]     ...future.result$finished <- base::Sys.time()
[13:22:58.779]     ...future.result
[13:22:58.779] }
[13:22:58.782] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:58.782] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:58.783] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:58.783] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:58.783] MultisessionFuture started
[13:22:58.784] - Launch lazy future ... done
[13:22:58.784] run() for ‘MultisessionFuture’ ... done
[13:22:58.784] result() for ClusterFuture ...
[13:22:58.784] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.784] - Validating connection of MultisessionFuture
[13:22:58.829] - received message: FutureResult
[13:22:58.829] - Received FutureResult
[13:22:58.829] - Erased future from FutureRegistry
[13:22:58.830] result() for ClusterFuture ...
[13:22:58.830] - result already collected: FutureResult
[13:22:58.830] result() for ClusterFuture ... done
[13:22:58.830] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.830] result() for ClusterFuture ... done
[13:22:58.830] result() for ClusterFuture ...
[13:22:58.830] - result already collected: FutureResult
[13:22:58.830] result() for ClusterFuture ... done
[13:22:58.831] getGlobalsAndPackages() ...
[13:22:58.831] Searching for globals...
[13:22:58.832] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:58.832] Searching for globals ... DONE
[13:22:58.832] Resolving globals: FALSE
[13:22:58.833] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:58.833] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:58.833] - globals: [1] ‘a’
[13:22:58.833] 
[13:22:58.834] getGlobalsAndPackages() ... DONE
[13:22:58.834] run() for ‘Future’ ...
[13:22:58.834] - state: ‘created’
[13:22:58.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.851]   - Field: ‘node’
[13:22:58.851]   - Field: ‘label’
[13:22:58.851]   - Field: ‘local’
[13:22:58.851]   - Field: ‘owner’
[13:22:58.851]   - Field: ‘envir’
[13:22:58.851]   - Field: ‘workers’
[13:22:58.851]   - Field: ‘packages’
[13:22:58.851]   - Field: ‘gc’
[13:22:58.851]   - Field: ‘conditions’
[13:22:58.851]   - Field: ‘persistent’
[13:22:58.852]   - Field: ‘expr’
[13:22:58.852]   - Field: ‘uuid’
[13:22:58.852]   - Field: ‘seed’
[13:22:58.852]   - Field: ‘version’
[13:22:58.852]   - Field: ‘result’
[13:22:58.852]   - Field: ‘asynchronous’
[13:22:58.852]   - Field: ‘calls’
[13:22:58.852]   - Field: ‘globals’
[13:22:58.852]   - Field: ‘stdout’
[13:22:58.852]   - Field: ‘earlySignal’
[13:22:58.853]   - Field: ‘lazy’
[13:22:58.853]   - Field: ‘state’
[13:22:58.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.853] - Launch lazy future ...
[13:22:58.853] Packages needed by the future expression (n = 0): <none>
[13:22:58.853] Packages needed by future strategies (n = 0): <none>
[13:22:58.854] {
[13:22:58.854]     {
[13:22:58.854]         {
[13:22:58.854]             ...future.startTime <- base::Sys.time()
[13:22:58.854]             {
[13:22:58.854]                 {
[13:22:58.854]                   {
[13:22:58.854]                     {
[13:22:58.854]                       base::local({
[13:22:58.854]                         has_future <- base::requireNamespace("future", 
[13:22:58.854]                           quietly = TRUE)
[13:22:58.854]                         if (has_future) {
[13:22:58.854]                           ns <- base::getNamespace("future")
[13:22:58.854]                           version <- ns[[".package"]][["version"]]
[13:22:58.854]                           if (is.null(version)) 
[13:22:58.854]                             version <- utils::packageVersion("future")
[13:22:58.854]                         }
[13:22:58.854]                         else {
[13:22:58.854]                           version <- NULL
[13:22:58.854]                         }
[13:22:58.854]                         if (!has_future || version < "1.8.0") {
[13:22:58.854]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.854]                             "", base::R.version$version.string), 
[13:22:58.854]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.854]                               "release", "version")], collapse = " "), 
[13:22:58.854]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.854]                             info)
[13:22:58.854]                           info <- base::paste(info, collapse = "; ")
[13:22:58.854]                           if (!has_future) {
[13:22:58.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.854]                               info)
[13:22:58.854]                           }
[13:22:58.854]                           else {
[13:22:58.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.854]                               info, version)
[13:22:58.854]                           }
[13:22:58.854]                           base::stop(msg)
[13:22:58.854]                         }
[13:22:58.854]                       })
[13:22:58.854]                     }
[13:22:58.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.854]                     base::options(mc.cores = 1L)
[13:22:58.854]                   }
[13:22:58.854]                   options(future.plan = NULL)
[13:22:58.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.854]                 }
[13:22:58.854]                 ...future.workdir <- getwd()
[13:22:58.854]             }
[13:22:58.854]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.854]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.854]         }
[13:22:58.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.854]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.854]             base::names(...future.oldOptions))
[13:22:58.854]     }
[13:22:58.854]     if (FALSE) {
[13:22:58.854]     }
[13:22:58.854]     else {
[13:22:58.854]         if (TRUE) {
[13:22:58.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.854]                 open = "w")
[13:22:58.854]         }
[13:22:58.854]         else {
[13:22:58.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.854]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.854]         }
[13:22:58.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.854]             base::sink(type = "output", split = FALSE)
[13:22:58.854]             base::close(...future.stdout)
[13:22:58.854]         }, add = TRUE)
[13:22:58.854]     }
[13:22:58.854]     ...future.frame <- base::sys.nframe()
[13:22:58.854]     ...future.conditions <- base::list()
[13:22:58.854]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.854]     if (FALSE) {
[13:22:58.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.854]     }
[13:22:58.854]     ...future.result <- base::tryCatch({
[13:22:58.854]         base::withCallingHandlers({
[13:22:58.854]             ...future.value <- base::withVisible(base::local({
[13:22:58.854]                 ...future.makeSendCondition <- base::local({
[13:22:58.854]                   sendCondition <- NULL
[13:22:58.854]                   function(frame = 1L) {
[13:22:58.854]                     if (is.function(sendCondition)) 
[13:22:58.854]                       return(sendCondition)
[13:22:58.854]                     ns <- getNamespace("parallel")
[13:22:58.854]                     if (exists("sendData", mode = "function", 
[13:22:58.854]                       envir = ns)) {
[13:22:58.854]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.854]                         envir = ns)
[13:22:58.854]                       envir <- sys.frame(frame)
[13:22:58.854]                       master <- NULL
[13:22:58.854]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.854]                         !identical(envir, emptyenv())) {
[13:22:58.854]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.854]                           inherits = FALSE)) {
[13:22:58.854]                           master <- get("master", mode = "list", 
[13:22:58.854]                             envir = envir, inherits = FALSE)
[13:22:58.854]                           if (inherits(master, c("SOCKnode", 
[13:22:58.854]                             "SOCK0node"))) {
[13:22:58.854]                             sendCondition <<- function(cond) {
[13:22:58.854]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.854]                                 success = TRUE)
[13:22:58.854]                               parallel_sendData(master, data)
[13:22:58.854]                             }
[13:22:58.854]                             return(sendCondition)
[13:22:58.854]                           }
[13:22:58.854]                         }
[13:22:58.854]                         frame <- frame + 1L
[13:22:58.854]                         envir <- sys.frame(frame)
[13:22:58.854]                       }
[13:22:58.854]                     }
[13:22:58.854]                     sendCondition <<- function(cond) NULL
[13:22:58.854]                   }
[13:22:58.854]                 })
[13:22:58.854]                 withCallingHandlers({
[13:22:58.854]                   {
[13:22:58.854]                     2 * a
[13:22:58.854]                   }
[13:22:58.854]                 }, immediateCondition = function(cond) {
[13:22:58.854]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.854]                   sendCondition(cond)
[13:22:58.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.854]                   {
[13:22:58.854]                     inherits <- base::inherits
[13:22:58.854]                     invokeRestart <- base::invokeRestart
[13:22:58.854]                     is.null <- base::is.null
[13:22:58.854]                     muffled <- FALSE
[13:22:58.854]                     if (inherits(cond, "message")) {
[13:22:58.854]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.854]                       if (muffled) 
[13:22:58.854]                         invokeRestart("muffleMessage")
[13:22:58.854]                     }
[13:22:58.854]                     else if (inherits(cond, "warning")) {
[13:22:58.854]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.854]                       if (muffled) 
[13:22:58.854]                         invokeRestart("muffleWarning")
[13:22:58.854]                     }
[13:22:58.854]                     else if (inherits(cond, "condition")) {
[13:22:58.854]                       if (!is.null(pattern)) {
[13:22:58.854]                         computeRestarts <- base::computeRestarts
[13:22:58.854]                         grepl <- base::grepl
[13:22:58.854]                         restarts <- computeRestarts(cond)
[13:22:58.854]                         for (restart in restarts) {
[13:22:58.854]                           name <- restart$name
[13:22:58.854]                           if (is.null(name)) 
[13:22:58.854]                             next
[13:22:58.854]                           if (!grepl(pattern, name)) 
[13:22:58.854]                             next
[13:22:58.854]                           invokeRestart(restart)
[13:22:58.854]                           muffled <- TRUE
[13:22:58.854]                           break
[13:22:58.854]                         }
[13:22:58.854]                       }
[13:22:58.854]                     }
[13:22:58.854]                     invisible(muffled)
[13:22:58.854]                   }
[13:22:58.854]                   muffleCondition(cond)
[13:22:58.854]                 })
[13:22:58.854]             }))
[13:22:58.854]             future::FutureResult(value = ...future.value$value, 
[13:22:58.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.854]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.854]                     ...future.globalenv.names))
[13:22:58.854]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.854]         }, condition = base::local({
[13:22:58.854]             c <- base::c
[13:22:58.854]             inherits <- base::inherits
[13:22:58.854]             invokeRestart <- base::invokeRestart
[13:22:58.854]             length <- base::length
[13:22:58.854]             list <- base::list
[13:22:58.854]             seq.int <- base::seq.int
[13:22:58.854]             signalCondition <- base::signalCondition
[13:22:58.854]             sys.calls <- base::sys.calls
[13:22:58.854]             `[[` <- base::`[[`
[13:22:58.854]             `+` <- base::`+`
[13:22:58.854]             `<<-` <- base::`<<-`
[13:22:58.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.854]                   3L)]
[13:22:58.854]             }
[13:22:58.854]             function(cond) {
[13:22:58.854]                 is_error <- inherits(cond, "error")
[13:22:58.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.854]                   NULL)
[13:22:58.854]                 if (is_error) {
[13:22:58.854]                   sessionInformation <- function() {
[13:22:58.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.854]                       search = base::search(), system = base::Sys.info())
[13:22:58.854]                   }
[13:22:58.854]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.854]                     cond$call), session = sessionInformation(), 
[13:22:58.854]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.854]                   signalCondition(cond)
[13:22:58.854]                 }
[13:22:58.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.854]                 "immediateCondition"))) {
[13:22:58.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.854]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.854]                   if (TRUE && !signal) {
[13:22:58.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.854]                     {
[13:22:58.854]                       inherits <- base::inherits
[13:22:58.854]                       invokeRestart <- base::invokeRestart
[13:22:58.854]                       is.null <- base::is.null
[13:22:58.854]                       muffled <- FALSE
[13:22:58.854]                       if (inherits(cond, "message")) {
[13:22:58.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.854]                         if (muffled) 
[13:22:58.854]                           invokeRestart("muffleMessage")
[13:22:58.854]                       }
[13:22:58.854]                       else if (inherits(cond, "warning")) {
[13:22:58.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.854]                         if (muffled) 
[13:22:58.854]                           invokeRestart("muffleWarning")
[13:22:58.854]                       }
[13:22:58.854]                       else if (inherits(cond, "condition")) {
[13:22:58.854]                         if (!is.null(pattern)) {
[13:22:58.854]                           computeRestarts <- base::computeRestarts
[13:22:58.854]                           grepl <- base::grepl
[13:22:58.854]                           restarts <- computeRestarts(cond)
[13:22:58.854]                           for (restart in restarts) {
[13:22:58.854]                             name <- restart$name
[13:22:58.854]                             if (is.null(name)) 
[13:22:58.854]                               next
[13:22:58.854]                             if (!grepl(pattern, name)) 
[13:22:58.854]                               next
[13:22:58.854]                             invokeRestart(restart)
[13:22:58.854]                             muffled <- TRUE
[13:22:58.854]                             break
[13:22:58.854]                           }
[13:22:58.854]                         }
[13:22:58.854]                       }
[13:22:58.854]                       invisible(muffled)
[13:22:58.854]                     }
[13:22:58.854]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.854]                   }
[13:22:58.854]                 }
[13:22:58.854]                 else {
[13:22:58.854]                   if (TRUE) {
[13:22:58.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.854]                     {
[13:22:58.854]                       inherits <- base::inherits
[13:22:58.854]                       invokeRestart <- base::invokeRestart
[13:22:58.854]                       is.null <- base::is.null
[13:22:58.854]                       muffled <- FALSE
[13:22:58.854]                       if (inherits(cond, "message")) {
[13:22:58.854]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.854]                         if (muffled) 
[13:22:58.854]                           invokeRestart("muffleMessage")
[13:22:58.854]                       }
[13:22:58.854]                       else if (inherits(cond, "warning")) {
[13:22:58.854]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.854]                         if (muffled) 
[13:22:58.854]                           invokeRestart("muffleWarning")
[13:22:58.854]                       }
[13:22:58.854]                       else if (inherits(cond, "condition")) {
[13:22:58.854]                         if (!is.null(pattern)) {
[13:22:58.854]                           computeRestarts <- base::computeRestarts
[13:22:58.854]                           grepl <- base::grepl
[13:22:58.854]                           restarts <- computeRestarts(cond)
[13:22:58.854]                           for (restart in restarts) {
[13:22:58.854]                             name <- restart$name
[13:22:58.854]                             if (is.null(name)) 
[13:22:58.854]                               next
[13:22:58.854]                             if (!grepl(pattern, name)) 
[13:22:58.854]                               next
[13:22:58.854]                             invokeRestart(restart)
[13:22:58.854]                             muffled <- TRUE
[13:22:58.854]                             break
[13:22:58.854]                           }
[13:22:58.854]                         }
[13:22:58.854]                       }
[13:22:58.854]                       invisible(muffled)
[13:22:58.854]                     }
[13:22:58.854]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.854]                   }
[13:22:58.854]                 }
[13:22:58.854]             }
[13:22:58.854]         }))
[13:22:58.854]     }, error = function(ex) {
[13:22:58.854]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.854]                 ...future.rng), started = ...future.startTime, 
[13:22:58.854]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.854]             version = "1.8"), class = "FutureResult")
[13:22:58.854]     }, finally = {
[13:22:58.854]         if (!identical(...future.workdir, getwd())) 
[13:22:58.854]             setwd(...future.workdir)
[13:22:58.854]         {
[13:22:58.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.854]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.854]             }
[13:22:58.854]             base::options(...future.oldOptions)
[13:22:58.854]             if (.Platform$OS.type == "windows") {
[13:22:58.854]                 old_names <- names(...future.oldEnvVars)
[13:22:58.854]                 envs <- base::Sys.getenv()
[13:22:58.854]                 names <- names(envs)
[13:22:58.854]                 common <- intersect(names, old_names)
[13:22:58.854]                 added <- setdiff(names, old_names)
[13:22:58.854]                 removed <- setdiff(old_names, names)
[13:22:58.854]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.854]                   envs[common]]
[13:22:58.854]                 NAMES <- toupper(changed)
[13:22:58.854]                 args <- list()
[13:22:58.854]                 for (kk in seq_along(NAMES)) {
[13:22:58.854]                   name <- changed[[kk]]
[13:22:58.854]                   NAME <- NAMES[[kk]]
[13:22:58.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.854]                     next
[13:22:58.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.854]                 }
[13:22:58.854]                 NAMES <- toupper(added)
[13:22:58.854]                 for (kk in seq_along(NAMES)) {
[13:22:58.854]                   name <- added[[kk]]
[13:22:58.854]                   NAME <- NAMES[[kk]]
[13:22:58.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.854]                     next
[13:22:58.854]                   args[[name]] <- ""
[13:22:58.854]                 }
[13:22:58.854]                 NAMES <- toupper(removed)
[13:22:58.854]                 for (kk in seq_along(NAMES)) {
[13:22:58.854]                   name <- removed[[kk]]
[13:22:58.854]                   NAME <- NAMES[[kk]]
[13:22:58.854]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.854]                     next
[13:22:58.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.854]                 }
[13:22:58.854]                 if (length(args) > 0) 
[13:22:58.854]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.854]             }
[13:22:58.854]             else {
[13:22:58.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.854]             }
[13:22:58.854]             {
[13:22:58.854]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.854]                   0L) {
[13:22:58.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.854]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.854]                   base::options(opts)
[13:22:58.854]                 }
[13:22:58.854]                 {
[13:22:58.854]                   {
[13:22:58.854]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.854]                     NULL
[13:22:58.854]                   }
[13:22:58.854]                   options(future.plan = NULL)
[13:22:58.854]                   if (is.na(NA_character_)) 
[13:22:58.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.854]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.854]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.854]                     envir = parent.frame()) 
[13:22:58.854]                   {
[13:22:58.854]                     if (is.function(workers)) 
[13:22:58.854]                       workers <- workers()
[13:22:58.854]                     workers <- structure(as.integer(workers), 
[13:22:58.854]                       class = class(workers))
[13:22:58.854]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.854]                       workers >= 1)
[13:22:58.854]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.854]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.854]                     }
[13:22:58.854]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.854]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.854]                       envir = envir)
[13:22:58.854]                     if (!future$lazy) 
[13:22:58.854]                       future <- run(future)
[13:22:58.854]                     invisible(future)
[13:22:58.854]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.854]                 }
[13:22:58.854]             }
[13:22:58.854]         }
[13:22:58.854]     })
[13:22:58.854]     if (TRUE) {
[13:22:58.854]         base::sink(type = "output", split = FALSE)
[13:22:58.854]         if (TRUE) {
[13:22:58.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.854]         }
[13:22:58.854]         else {
[13:22:58.854]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.854]         }
[13:22:58.854]         base::close(...future.stdout)
[13:22:58.854]         ...future.stdout <- NULL
[13:22:58.854]     }
[13:22:58.854]     ...future.result$conditions <- ...future.conditions
[13:22:58.854]     ...future.result$finished <- base::Sys.time()
[13:22:58.854]     ...future.result
[13:22:58.854] }
[13:22:58.857] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:58.857] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:58.857] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:58.857] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:58.858] MultisessionFuture started
[13:22:58.858] - Launch lazy future ... done
[13:22:58.858] run() for ‘MultisessionFuture’ ... done
[13:22:58.858] result() for ClusterFuture ...
[13:22:58.858] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.858] - Validating connection of MultisessionFuture
[13:22:58.905] - received message: FutureResult
[13:22:58.905] - Received FutureResult
[13:22:58.905] - Erased future from FutureRegistry
[13:22:58.906] result() for ClusterFuture ...
[13:22:58.906] - result already collected: FutureResult
[13:22:58.906] result() for ClusterFuture ... done
[13:22:58.906] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.906] result() for ClusterFuture ... done
[13:22:58.906] result() for ClusterFuture ...
[13:22:58.906] - result already collected: FutureResult
[13:22:58.906] result() for ClusterFuture ... done
[13:22:58.907] getGlobalsAndPackages() ...
[13:22:58.907] Searching for globals...
[13:22:58.908] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:58.908] Searching for globals ... DONE
[13:22:58.908] Resolving globals: FALSE
[13:22:58.908] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:58.909] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:58.909] - globals: [1] ‘a’
[13:22:58.909] 
[13:22:58.909] getGlobalsAndPackages() ... DONE
[13:22:58.909] run() for ‘Future’ ...
[13:22:58.909] - state: ‘created’
[13:22:58.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.924]   - Field: ‘node’
[13:22:58.924]   - Field: ‘label’
[13:22:58.924]   - Field: ‘local’
[13:22:58.924]   - Field: ‘owner’
[13:22:58.924]   - Field: ‘envir’
[13:22:58.924]   - Field: ‘workers’
[13:22:58.925]   - Field: ‘packages’
[13:22:58.925]   - Field: ‘gc’
[13:22:58.925]   - Field: ‘conditions’
[13:22:58.925]   - Field: ‘persistent’
[13:22:58.925]   - Field: ‘expr’
[13:22:58.925]   - Field: ‘uuid’
[13:22:58.925]   - Field: ‘seed’
[13:22:58.925]   - Field: ‘version’
[13:22:58.925]   - Field: ‘result’
[13:22:58.925]   - Field: ‘asynchronous’
[13:22:58.925]   - Field: ‘calls’
[13:22:58.926]   - Field: ‘globals’
[13:22:58.926]   - Field: ‘stdout’
[13:22:58.926]   - Field: ‘earlySignal’
[13:22:58.926]   - Field: ‘lazy’
[13:22:58.926]   - Field: ‘state’
[13:22:58.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.926] - Launch lazy future ...
[13:22:58.926] Packages needed by the future expression (n = 0): <none>
[13:22:58.927] Packages needed by future strategies (n = 0): <none>
[13:22:58.927] {
[13:22:58.927]     {
[13:22:58.927]         {
[13:22:58.927]             ...future.startTime <- base::Sys.time()
[13:22:58.927]             {
[13:22:58.927]                 {
[13:22:58.927]                   {
[13:22:58.927]                     {
[13:22:58.927]                       base::local({
[13:22:58.927]                         has_future <- base::requireNamespace("future", 
[13:22:58.927]                           quietly = TRUE)
[13:22:58.927]                         if (has_future) {
[13:22:58.927]                           ns <- base::getNamespace("future")
[13:22:58.927]                           version <- ns[[".package"]][["version"]]
[13:22:58.927]                           if (is.null(version)) 
[13:22:58.927]                             version <- utils::packageVersion("future")
[13:22:58.927]                         }
[13:22:58.927]                         else {
[13:22:58.927]                           version <- NULL
[13:22:58.927]                         }
[13:22:58.927]                         if (!has_future || version < "1.8.0") {
[13:22:58.927]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.927]                             "", base::R.version$version.string), 
[13:22:58.927]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.927]                               "release", "version")], collapse = " "), 
[13:22:58.927]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.927]                             info)
[13:22:58.927]                           info <- base::paste(info, collapse = "; ")
[13:22:58.927]                           if (!has_future) {
[13:22:58.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.927]                               info)
[13:22:58.927]                           }
[13:22:58.927]                           else {
[13:22:58.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.927]                               info, version)
[13:22:58.927]                           }
[13:22:58.927]                           base::stop(msg)
[13:22:58.927]                         }
[13:22:58.927]                       })
[13:22:58.927]                     }
[13:22:58.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.927]                     base::options(mc.cores = 1L)
[13:22:58.927]                   }
[13:22:58.927]                   options(future.plan = NULL)
[13:22:58.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.927]                 }
[13:22:58.927]                 ...future.workdir <- getwd()
[13:22:58.927]             }
[13:22:58.927]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.927]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.927]         }
[13:22:58.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.927]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.927]             base::names(...future.oldOptions))
[13:22:58.927]     }
[13:22:58.927]     if (FALSE) {
[13:22:58.927]     }
[13:22:58.927]     else {
[13:22:58.927]         if (TRUE) {
[13:22:58.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.927]                 open = "w")
[13:22:58.927]         }
[13:22:58.927]         else {
[13:22:58.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.927]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.927]         }
[13:22:58.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.927]             base::sink(type = "output", split = FALSE)
[13:22:58.927]             base::close(...future.stdout)
[13:22:58.927]         }, add = TRUE)
[13:22:58.927]     }
[13:22:58.927]     ...future.frame <- base::sys.nframe()
[13:22:58.927]     ...future.conditions <- base::list()
[13:22:58.927]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.927]     if (FALSE) {
[13:22:58.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.927]     }
[13:22:58.927]     ...future.result <- base::tryCatch({
[13:22:58.927]         base::withCallingHandlers({
[13:22:58.927]             ...future.value <- base::withVisible(base::local({
[13:22:58.927]                 ...future.makeSendCondition <- base::local({
[13:22:58.927]                   sendCondition <- NULL
[13:22:58.927]                   function(frame = 1L) {
[13:22:58.927]                     if (is.function(sendCondition)) 
[13:22:58.927]                       return(sendCondition)
[13:22:58.927]                     ns <- getNamespace("parallel")
[13:22:58.927]                     if (exists("sendData", mode = "function", 
[13:22:58.927]                       envir = ns)) {
[13:22:58.927]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.927]                         envir = ns)
[13:22:58.927]                       envir <- sys.frame(frame)
[13:22:58.927]                       master <- NULL
[13:22:58.927]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.927]                         !identical(envir, emptyenv())) {
[13:22:58.927]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.927]                           inherits = FALSE)) {
[13:22:58.927]                           master <- get("master", mode = "list", 
[13:22:58.927]                             envir = envir, inherits = FALSE)
[13:22:58.927]                           if (inherits(master, c("SOCKnode", 
[13:22:58.927]                             "SOCK0node"))) {
[13:22:58.927]                             sendCondition <<- function(cond) {
[13:22:58.927]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.927]                                 success = TRUE)
[13:22:58.927]                               parallel_sendData(master, data)
[13:22:58.927]                             }
[13:22:58.927]                             return(sendCondition)
[13:22:58.927]                           }
[13:22:58.927]                         }
[13:22:58.927]                         frame <- frame + 1L
[13:22:58.927]                         envir <- sys.frame(frame)
[13:22:58.927]                       }
[13:22:58.927]                     }
[13:22:58.927]                     sendCondition <<- function(cond) NULL
[13:22:58.927]                   }
[13:22:58.927]                 })
[13:22:58.927]                 withCallingHandlers({
[13:22:58.927]                   {
[13:22:58.927]                     2 * a
[13:22:58.927]                   }
[13:22:58.927]                 }, immediateCondition = function(cond) {
[13:22:58.927]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.927]                   sendCondition(cond)
[13:22:58.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.927]                   {
[13:22:58.927]                     inherits <- base::inherits
[13:22:58.927]                     invokeRestart <- base::invokeRestart
[13:22:58.927]                     is.null <- base::is.null
[13:22:58.927]                     muffled <- FALSE
[13:22:58.927]                     if (inherits(cond, "message")) {
[13:22:58.927]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.927]                       if (muffled) 
[13:22:58.927]                         invokeRestart("muffleMessage")
[13:22:58.927]                     }
[13:22:58.927]                     else if (inherits(cond, "warning")) {
[13:22:58.927]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.927]                       if (muffled) 
[13:22:58.927]                         invokeRestart("muffleWarning")
[13:22:58.927]                     }
[13:22:58.927]                     else if (inherits(cond, "condition")) {
[13:22:58.927]                       if (!is.null(pattern)) {
[13:22:58.927]                         computeRestarts <- base::computeRestarts
[13:22:58.927]                         grepl <- base::grepl
[13:22:58.927]                         restarts <- computeRestarts(cond)
[13:22:58.927]                         for (restart in restarts) {
[13:22:58.927]                           name <- restart$name
[13:22:58.927]                           if (is.null(name)) 
[13:22:58.927]                             next
[13:22:58.927]                           if (!grepl(pattern, name)) 
[13:22:58.927]                             next
[13:22:58.927]                           invokeRestart(restart)
[13:22:58.927]                           muffled <- TRUE
[13:22:58.927]                           break
[13:22:58.927]                         }
[13:22:58.927]                       }
[13:22:58.927]                     }
[13:22:58.927]                     invisible(muffled)
[13:22:58.927]                   }
[13:22:58.927]                   muffleCondition(cond)
[13:22:58.927]                 })
[13:22:58.927]             }))
[13:22:58.927]             future::FutureResult(value = ...future.value$value, 
[13:22:58.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.927]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.927]                     ...future.globalenv.names))
[13:22:58.927]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.927]         }, condition = base::local({
[13:22:58.927]             c <- base::c
[13:22:58.927]             inherits <- base::inherits
[13:22:58.927]             invokeRestart <- base::invokeRestart
[13:22:58.927]             length <- base::length
[13:22:58.927]             list <- base::list
[13:22:58.927]             seq.int <- base::seq.int
[13:22:58.927]             signalCondition <- base::signalCondition
[13:22:58.927]             sys.calls <- base::sys.calls
[13:22:58.927]             `[[` <- base::`[[`
[13:22:58.927]             `+` <- base::`+`
[13:22:58.927]             `<<-` <- base::`<<-`
[13:22:58.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.927]                   3L)]
[13:22:58.927]             }
[13:22:58.927]             function(cond) {
[13:22:58.927]                 is_error <- inherits(cond, "error")
[13:22:58.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.927]                   NULL)
[13:22:58.927]                 if (is_error) {
[13:22:58.927]                   sessionInformation <- function() {
[13:22:58.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.927]                       search = base::search(), system = base::Sys.info())
[13:22:58.927]                   }
[13:22:58.927]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.927]                     cond$call), session = sessionInformation(), 
[13:22:58.927]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.927]                   signalCondition(cond)
[13:22:58.927]                 }
[13:22:58.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.927]                 "immediateCondition"))) {
[13:22:58.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.927]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.927]                   if (TRUE && !signal) {
[13:22:58.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.927]                     {
[13:22:58.927]                       inherits <- base::inherits
[13:22:58.927]                       invokeRestart <- base::invokeRestart
[13:22:58.927]                       is.null <- base::is.null
[13:22:58.927]                       muffled <- FALSE
[13:22:58.927]                       if (inherits(cond, "message")) {
[13:22:58.927]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.927]                         if (muffled) 
[13:22:58.927]                           invokeRestart("muffleMessage")
[13:22:58.927]                       }
[13:22:58.927]                       else if (inherits(cond, "warning")) {
[13:22:58.927]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.927]                         if (muffled) 
[13:22:58.927]                           invokeRestart("muffleWarning")
[13:22:58.927]                       }
[13:22:58.927]                       else if (inherits(cond, "condition")) {
[13:22:58.927]                         if (!is.null(pattern)) {
[13:22:58.927]                           computeRestarts <- base::computeRestarts
[13:22:58.927]                           grepl <- base::grepl
[13:22:58.927]                           restarts <- computeRestarts(cond)
[13:22:58.927]                           for (restart in restarts) {
[13:22:58.927]                             name <- restart$name
[13:22:58.927]                             if (is.null(name)) 
[13:22:58.927]                               next
[13:22:58.927]                             if (!grepl(pattern, name)) 
[13:22:58.927]                               next
[13:22:58.927]                             invokeRestart(restart)
[13:22:58.927]                             muffled <- TRUE
[13:22:58.927]                             break
[13:22:58.927]                           }
[13:22:58.927]                         }
[13:22:58.927]                       }
[13:22:58.927]                       invisible(muffled)
[13:22:58.927]                     }
[13:22:58.927]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.927]                   }
[13:22:58.927]                 }
[13:22:58.927]                 else {
[13:22:58.927]                   if (TRUE) {
[13:22:58.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.927]                     {
[13:22:58.927]                       inherits <- base::inherits
[13:22:58.927]                       invokeRestart <- base::invokeRestart
[13:22:58.927]                       is.null <- base::is.null
[13:22:58.927]                       muffled <- FALSE
[13:22:58.927]                       if (inherits(cond, "message")) {
[13:22:58.927]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.927]                         if (muffled) 
[13:22:58.927]                           invokeRestart("muffleMessage")
[13:22:58.927]                       }
[13:22:58.927]                       else if (inherits(cond, "warning")) {
[13:22:58.927]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.927]                         if (muffled) 
[13:22:58.927]                           invokeRestart("muffleWarning")
[13:22:58.927]                       }
[13:22:58.927]                       else if (inherits(cond, "condition")) {
[13:22:58.927]                         if (!is.null(pattern)) {
[13:22:58.927]                           computeRestarts <- base::computeRestarts
[13:22:58.927]                           grepl <- base::grepl
[13:22:58.927]                           restarts <- computeRestarts(cond)
[13:22:58.927]                           for (restart in restarts) {
[13:22:58.927]                             name <- restart$name
[13:22:58.927]                             if (is.null(name)) 
[13:22:58.927]                               next
[13:22:58.927]                             if (!grepl(pattern, name)) 
[13:22:58.927]                               next
[13:22:58.927]                             invokeRestart(restart)
[13:22:58.927]                             muffled <- TRUE
[13:22:58.927]                             break
[13:22:58.927]                           }
[13:22:58.927]                         }
[13:22:58.927]                       }
[13:22:58.927]                       invisible(muffled)
[13:22:58.927]                     }
[13:22:58.927]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.927]                   }
[13:22:58.927]                 }
[13:22:58.927]             }
[13:22:58.927]         }))
[13:22:58.927]     }, error = function(ex) {
[13:22:58.927]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.927]                 ...future.rng), started = ...future.startTime, 
[13:22:58.927]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.927]             version = "1.8"), class = "FutureResult")
[13:22:58.927]     }, finally = {
[13:22:58.927]         if (!identical(...future.workdir, getwd())) 
[13:22:58.927]             setwd(...future.workdir)
[13:22:58.927]         {
[13:22:58.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.927]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.927]             }
[13:22:58.927]             base::options(...future.oldOptions)
[13:22:58.927]             if (.Platform$OS.type == "windows") {
[13:22:58.927]                 old_names <- names(...future.oldEnvVars)
[13:22:58.927]                 envs <- base::Sys.getenv()
[13:22:58.927]                 names <- names(envs)
[13:22:58.927]                 common <- intersect(names, old_names)
[13:22:58.927]                 added <- setdiff(names, old_names)
[13:22:58.927]                 removed <- setdiff(old_names, names)
[13:22:58.927]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.927]                   envs[common]]
[13:22:58.927]                 NAMES <- toupper(changed)
[13:22:58.927]                 args <- list()
[13:22:58.927]                 for (kk in seq_along(NAMES)) {
[13:22:58.927]                   name <- changed[[kk]]
[13:22:58.927]                   NAME <- NAMES[[kk]]
[13:22:58.927]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.927]                     next
[13:22:58.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.927]                 }
[13:22:58.927]                 NAMES <- toupper(added)
[13:22:58.927]                 for (kk in seq_along(NAMES)) {
[13:22:58.927]                   name <- added[[kk]]
[13:22:58.927]                   NAME <- NAMES[[kk]]
[13:22:58.927]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.927]                     next
[13:22:58.927]                   args[[name]] <- ""
[13:22:58.927]                 }
[13:22:58.927]                 NAMES <- toupper(removed)
[13:22:58.927]                 for (kk in seq_along(NAMES)) {
[13:22:58.927]                   name <- removed[[kk]]
[13:22:58.927]                   NAME <- NAMES[[kk]]
[13:22:58.927]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.927]                     next
[13:22:58.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.927]                 }
[13:22:58.927]                 if (length(args) > 0) 
[13:22:58.927]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.927]             }
[13:22:58.927]             else {
[13:22:58.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.927]             }
[13:22:58.927]             {
[13:22:58.927]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.927]                   0L) {
[13:22:58.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.927]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.927]                   base::options(opts)
[13:22:58.927]                 }
[13:22:58.927]                 {
[13:22:58.927]                   {
[13:22:58.927]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.927]                     NULL
[13:22:58.927]                   }
[13:22:58.927]                   options(future.plan = NULL)
[13:22:58.927]                   if (is.na(NA_character_)) 
[13:22:58.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.927]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.927]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.927]                     envir = parent.frame()) 
[13:22:58.927]                   {
[13:22:58.927]                     if (is.function(workers)) 
[13:22:58.927]                       workers <- workers()
[13:22:58.927]                     workers <- structure(as.integer(workers), 
[13:22:58.927]                       class = class(workers))
[13:22:58.927]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.927]                       workers >= 1)
[13:22:58.927]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.927]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.927]                     }
[13:22:58.927]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.927]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.927]                       envir = envir)
[13:22:58.927]                     if (!future$lazy) 
[13:22:58.927]                       future <- run(future)
[13:22:58.927]                     invisible(future)
[13:22:58.927]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.927]                 }
[13:22:58.927]             }
[13:22:58.927]         }
[13:22:58.927]     })
[13:22:58.927]     if (TRUE) {
[13:22:58.927]         base::sink(type = "output", split = FALSE)
[13:22:58.927]         if (TRUE) {
[13:22:58.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.927]         }
[13:22:58.927]         else {
[13:22:58.927]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.927]         }
[13:22:58.927]         base::close(...future.stdout)
[13:22:58.927]         ...future.stdout <- NULL
[13:22:58.927]     }
[13:22:58.927]     ...future.result$conditions <- ...future.conditions
[13:22:58.927]     ...future.result$finished <- base::Sys.time()
[13:22:58.927]     ...future.result
[13:22:58.927] }
[13:22:58.930] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:58.930] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:58.930] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:58.930] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:58.931] MultisessionFuture started
[13:22:58.931] - Launch lazy future ... done
[13:22:58.931] run() for ‘MultisessionFuture’ ... done
[13:22:58.931] result() for ClusterFuture ...
[13:22:58.932] receiveMessageFromWorker() for ClusterFuture ...
[13:22:58.932] - Validating connection of MultisessionFuture
[13:22:58.977] - received message: FutureResult
[13:22:58.977] - Received FutureResult
[13:22:58.978] - Erased future from FutureRegistry
[13:22:58.978] result() for ClusterFuture ...
[13:22:58.978] - result already collected: FutureResult
[13:22:58.978] result() for ClusterFuture ... done
[13:22:58.978] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:58.978] result() for ClusterFuture ... done
[13:22:58.978] result() for ClusterFuture ...
[13:22:58.978] - result already collected: FutureResult
[13:22:58.979] result() for ClusterFuture ... done
[13:22:58.979] getGlobalsAndPackages() ...
[13:22:58.979] Searching for globals...
[13:22:58.980] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:58.980] Searching for globals ... DONE
[13:22:58.980] Resolving globals: FALSE
[13:22:58.981] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:58.981] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:58.981] - globals: [1] ‘a’
[13:22:58.981] 
[13:22:58.981] getGlobalsAndPackages() ... DONE
[13:22:58.982] run() for ‘Future’ ...
[13:22:58.982] - state: ‘created’
[13:22:58.982] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:58.996] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:58.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:58.996]   - Field: ‘node’
[13:22:58.996]   - Field: ‘label’
[13:22:58.996]   - Field: ‘local’
[13:22:58.997]   - Field: ‘owner’
[13:22:58.997]   - Field: ‘envir’
[13:22:58.997]   - Field: ‘workers’
[13:22:58.997]   - Field: ‘packages’
[13:22:58.997]   - Field: ‘gc’
[13:22:58.997]   - Field: ‘conditions’
[13:22:58.997]   - Field: ‘persistent’
[13:22:58.997]   - Field: ‘expr’
[13:22:58.997]   - Field: ‘uuid’
[13:22:58.997]   - Field: ‘seed’
[13:22:58.998]   - Field: ‘version’
[13:22:58.998]   - Field: ‘result’
[13:22:58.998]   - Field: ‘asynchronous’
[13:22:58.998]   - Field: ‘calls’
[13:22:58.998]   - Field: ‘globals’
[13:22:58.998]   - Field: ‘stdout’
[13:22:58.998]   - Field: ‘earlySignal’
[13:22:58.998]   - Field: ‘lazy’
[13:22:58.998]   - Field: ‘state’
[13:22:58.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:58.998] - Launch lazy future ...
[13:22:58.999] Packages needed by the future expression (n = 0): <none>
[13:22:58.999] Packages needed by future strategies (n = 0): <none>
[13:22:58.999] {
[13:22:58.999]     {
[13:22:58.999]         {
[13:22:58.999]             ...future.startTime <- base::Sys.time()
[13:22:58.999]             {
[13:22:58.999]                 {
[13:22:58.999]                   {
[13:22:58.999]                     {
[13:22:58.999]                       base::local({
[13:22:58.999]                         has_future <- base::requireNamespace("future", 
[13:22:58.999]                           quietly = TRUE)
[13:22:58.999]                         if (has_future) {
[13:22:58.999]                           ns <- base::getNamespace("future")
[13:22:58.999]                           version <- ns[[".package"]][["version"]]
[13:22:58.999]                           if (is.null(version)) 
[13:22:58.999]                             version <- utils::packageVersion("future")
[13:22:58.999]                         }
[13:22:58.999]                         else {
[13:22:58.999]                           version <- NULL
[13:22:58.999]                         }
[13:22:58.999]                         if (!has_future || version < "1.8.0") {
[13:22:58.999]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:58.999]                             "", base::R.version$version.string), 
[13:22:58.999]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:58.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:58.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:58.999]                               "release", "version")], collapse = " "), 
[13:22:58.999]                             hostname = base::Sys.info()[["nodename"]])
[13:22:58.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:58.999]                             info)
[13:22:58.999]                           info <- base::paste(info, collapse = "; ")
[13:22:58.999]                           if (!has_future) {
[13:22:58.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:58.999]                               info)
[13:22:58.999]                           }
[13:22:58.999]                           else {
[13:22:58.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:58.999]                               info, version)
[13:22:58.999]                           }
[13:22:58.999]                           base::stop(msg)
[13:22:58.999]                         }
[13:22:58.999]                       })
[13:22:58.999]                     }
[13:22:58.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:58.999]                     base::options(mc.cores = 1L)
[13:22:58.999]                   }
[13:22:58.999]                   options(future.plan = NULL)
[13:22:58.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:58.999]                 }
[13:22:58.999]                 ...future.workdir <- getwd()
[13:22:58.999]             }
[13:22:58.999]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:58.999]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:58.999]         }
[13:22:58.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:58.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:58.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:58.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:58.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:58.999]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:58.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:58.999]             base::names(...future.oldOptions))
[13:22:58.999]     }
[13:22:58.999]     if (FALSE) {
[13:22:58.999]     }
[13:22:58.999]     else {
[13:22:58.999]         if (TRUE) {
[13:22:58.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:58.999]                 open = "w")
[13:22:58.999]         }
[13:22:58.999]         else {
[13:22:58.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:58.999]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:58.999]         }
[13:22:58.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:58.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:58.999]             base::sink(type = "output", split = FALSE)
[13:22:58.999]             base::close(...future.stdout)
[13:22:58.999]         }, add = TRUE)
[13:22:58.999]     }
[13:22:58.999]     ...future.frame <- base::sys.nframe()
[13:22:58.999]     ...future.conditions <- base::list()
[13:22:58.999]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:58.999]     if (FALSE) {
[13:22:58.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:58.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:58.999]     }
[13:22:58.999]     ...future.result <- base::tryCatch({
[13:22:58.999]         base::withCallingHandlers({
[13:22:58.999]             ...future.value <- base::withVisible(base::local({
[13:22:58.999]                 ...future.makeSendCondition <- base::local({
[13:22:58.999]                   sendCondition <- NULL
[13:22:58.999]                   function(frame = 1L) {
[13:22:58.999]                     if (is.function(sendCondition)) 
[13:22:58.999]                       return(sendCondition)
[13:22:58.999]                     ns <- getNamespace("parallel")
[13:22:58.999]                     if (exists("sendData", mode = "function", 
[13:22:58.999]                       envir = ns)) {
[13:22:58.999]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:58.999]                         envir = ns)
[13:22:58.999]                       envir <- sys.frame(frame)
[13:22:58.999]                       master <- NULL
[13:22:58.999]                       while (!identical(envir, .GlobalEnv) && 
[13:22:58.999]                         !identical(envir, emptyenv())) {
[13:22:58.999]                         if (exists("master", mode = "list", envir = envir, 
[13:22:58.999]                           inherits = FALSE)) {
[13:22:58.999]                           master <- get("master", mode = "list", 
[13:22:58.999]                             envir = envir, inherits = FALSE)
[13:22:58.999]                           if (inherits(master, c("SOCKnode", 
[13:22:58.999]                             "SOCK0node"))) {
[13:22:58.999]                             sendCondition <<- function(cond) {
[13:22:58.999]                               data <- list(type = "VALUE", value = cond, 
[13:22:58.999]                                 success = TRUE)
[13:22:58.999]                               parallel_sendData(master, data)
[13:22:58.999]                             }
[13:22:58.999]                             return(sendCondition)
[13:22:58.999]                           }
[13:22:58.999]                         }
[13:22:58.999]                         frame <- frame + 1L
[13:22:58.999]                         envir <- sys.frame(frame)
[13:22:58.999]                       }
[13:22:58.999]                     }
[13:22:58.999]                     sendCondition <<- function(cond) NULL
[13:22:58.999]                   }
[13:22:58.999]                 })
[13:22:58.999]                 withCallingHandlers({
[13:22:58.999]                   {
[13:22:58.999]                     2 * a
[13:22:58.999]                   }
[13:22:58.999]                 }, immediateCondition = function(cond) {
[13:22:58.999]                   sendCondition <- ...future.makeSendCondition()
[13:22:58.999]                   sendCondition(cond)
[13:22:58.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.999]                   {
[13:22:58.999]                     inherits <- base::inherits
[13:22:58.999]                     invokeRestart <- base::invokeRestart
[13:22:58.999]                     is.null <- base::is.null
[13:22:58.999]                     muffled <- FALSE
[13:22:58.999]                     if (inherits(cond, "message")) {
[13:22:58.999]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:58.999]                       if (muffled) 
[13:22:58.999]                         invokeRestart("muffleMessage")
[13:22:58.999]                     }
[13:22:58.999]                     else if (inherits(cond, "warning")) {
[13:22:58.999]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:58.999]                       if (muffled) 
[13:22:58.999]                         invokeRestart("muffleWarning")
[13:22:58.999]                     }
[13:22:58.999]                     else if (inherits(cond, "condition")) {
[13:22:58.999]                       if (!is.null(pattern)) {
[13:22:58.999]                         computeRestarts <- base::computeRestarts
[13:22:58.999]                         grepl <- base::grepl
[13:22:58.999]                         restarts <- computeRestarts(cond)
[13:22:58.999]                         for (restart in restarts) {
[13:22:58.999]                           name <- restart$name
[13:22:58.999]                           if (is.null(name)) 
[13:22:58.999]                             next
[13:22:58.999]                           if (!grepl(pattern, name)) 
[13:22:58.999]                             next
[13:22:58.999]                           invokeRestart(restart)
[13:22:58.999]                           muffled <- TRUE
[13:22:58.999]                           break
[13:22:58.999]                         }
[13:22:58.999]                       }
[13:22:58.999]                     }
[13:22:58.999]                     invisible(muffled)
[13:22:58.999]                   }
[13:22:58.999]                   muffleCondition(cond)
[13:22:58.999]                 })
[13:22:58.999]             }))
[13:22:58.999]             future::FutureResult(value = ...future.value$value, 
[13:22:58.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.999]                   ...future.rng), globalenv = if (FALSE) 
[13:22:58.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:58.999]                     ...future.globalenv.names))
[13:22:58.999]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:58.999]         }, condition = base::local({
[13:22:58.999]             c <- base::c
[13:22:58.999]             inherits <- base::inherits
[13:22:58.999]             invokeRestart <- base::invokeRestart
[13:22:58.999]             length <- base::length
[13:22:58.999]             list <- base::list
[13:22:58.999]             seq.int <- base::seq.int
[13:22:58.999]             signalCondition <- base::signalCondition
[13:22:58.999]             sys.calls <- base::sys.calls
[13:22:58.999]             `[[` <- base::`[[`
[13:22:58.999]             `+` <- base::`+`
[13:22:58.999]             `<<-` <- base::`<<-`
[13:22:58.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:58.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:58.999]                   3L)]
[13:22:58.999]             }
[13:22:58.999]             function(cond) {
[13:22:58.999]                 is_error <- inherits(cond, "error")
[13:22:58.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:58.999]                   NULL)
[13:22:58.999]                 if (is_error) {
[13:22:58.999]                   sessionInformation <- function() {
[13:22:58.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:58.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:58.999]                       search = base::search(), system = base::Sys.info())
[13:22:58.999]                   }
[13:22:58.999]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:58.999]                     cond$call), session = sessionInformation(), 
[13:22:58.999]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:58.999]                   signalCondition(cond)
[13:22:58.999]                 }
[13:22:58.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:58.999]                 "immediateCondition"))) {
[13:22:58.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:58.999]                   ...future.conditions[[length(...future.conditions) + 
[13:22:58.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:58.999]                   if (TRUE && !signal) {
[13:22:58.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.999]                     {
[13:22:58.999]                       inherits <- base::inherits
[13:22:58.999]                       invokeRestart <- base::invokeRestart
[13:22:58.999]                       is.null <- base::is.null
[13:22:58.999]                       muffled <- FALSE
[13:22:58.999]                       if (inherits(cond, "message")) {
[13:22:58.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.999]                         if (muffled) 
[13:22:58.999]                           invokeRestart("muffleMessage")
[13:22:58.999]                       }
[13:22:58.999]                       else if (inherits(cond, "warning")) {
[13:22:58.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.999]                         if (muffled) 
[13:22:58.999]                           invokeRestart("muffleWarning")
[13:22:58.999]                       }
[13:22:58.999]                       else if (inherits(cond, "condition")) {
[13:22:58.999]                         if (!is.null(pattern)) {
[13:22:58.999]                           computeRestarts <- base::computeRestarts
[13:22:58.999]                           grepl <- base::grepl
[13:22:58.999]                           restarts <- computeRestarts(cond)
[13:22:58.999]                           for (restart in restarts) {
[13:22:58.999]                             name <- restart$name
[13:22:58.999]                             if (is.null(name)) 
[13:22:58.999]                               next
[13:22:58.999]                             if (!grepl(pattern, name)) 
[13:22:58.999]                               next
[13:22:58.999]                             invokeRestart(restart)
[13:22:58.999]                             muffled <- TRUE
[13:22:58.999]                             break
[13:22:58.999]                           }
[13:22:58.999]                         }
[13:22:58.999]                       }
[13:22:58.999]                       invisible(muffled)
[13:22:58.999]                     }
[13:22:58.999]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.999]                   }
[13:22:58.999]                 }
[13:22:58.999]                 else {
[13:22:58.999]                   if (TRUE) {
[13:22:58.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:58.999]                     {
[13:22:58.999]                       inherits <- base::inherits
[13:22:58.999]                       invokeRestart <- base::invokeRestart
[13:22:58.999]                       is.null <- base::is.null
[13:22:58.999]                       muffled <- FALSE
[13:22:58.999]                       if (inherits(cond, "message")) {
[13:22:58.999]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:58.999]                         if (muffled) 
[13:22:58.999]                           invokeRestart("muffleMessage")
[13:22:58.999]                       }
[13:22:58.999]                       else if (inherits(cond, "warning")) {
[13:22:58.999]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:58.999]                         if (muffled) 
[13:22:58.999]                           invokeRestart("muffleWarning")
[13:22:58.999]                       }
[13:22:58.999]                       else if (inherits(cond, "condition")) {
[13:22:58.999]                         if (!is.null(pattern)) {
[13:22:58.999]                           computeRestarts <- base::computeRestarts
[13:22:58.999]                           grepl <- base::grepl
[13:22:58.999]                           restarts <- computeRestarts(cond)
[13:22:58.999]                           for (restart in restarts) {
[13:22:58.999]                             name <- restart$name
[13:22:58.999]                             if (is.null(name)) 
[13:22:58.999]                               next
[13:22:58.999]                             if (!grepl(pattern, name)) 
[13:22:58.999]                               next
[13:22:58.999]                             invokeRestart(restart)
[13:22:58.999]                             muffled <- TRUE
[13:22:58.999]                             break
[13:22:58.999]                           }
[13:22:58.999]                         }
[13:22:58.999]                       }
[13:22:58.999]                       invisible(muffled)
[13:22:58.999]                     }
[13:22:58.999]                     muffleCondition(cond, pattern = "^muffle")
[13:22:58.999]                   }
[13:22:58.999]                 }
[13:22:58.999]             }
[13:22:58.999]         }))
[13:22:58.999]     }, error = function(ex) {
[13:22:58.999]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:58.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:58.999]                 ...future.rng), started = ...future.startTime, 
[13:22:58.999]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:58.999]             version = "1.8"), class = "FutureResult")
[13:22:58.999]     }, finally = {
[13:22:58.999]         if (!identical(...future.workdir, getwd())) 
[13:22:58.999]             setwd(...future.workdir)
[13:22:58.999]         {
[13:22:58.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:58.999]                 ...future.oldOptions$nwarnings <- NULL
[13:22:58.999]             }
[13:22:58.999]             base::options(...future.oldOptions)
[13:22:58.999]             if (.Platform$OS.type == "windows") {
[13:22:58.999]                 old_names <- names(...future.oldEnvVars)
[13:22:58.999]                 envs <- base::Sys.getenv()
[13:22:58.999]                 names <- names(envs)
[13:22:58.999]                 common <- intersect(names, old_names)
[13:22:58.999]                 added <- setdiff(names, old_names)
[13:22:58.999]                 removed <- setdiff(old_names, names)
[13:22:58.999]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:58.999]                   envs[common]]
[13:22:58.999]                 NAMES <- toupper(changed)
[13:22:58.999]                 args <- list()
[13:22:58.999]                 for (kk in seq_along(NAMES)) {
[13:22:58.999]                   name <- changed[[kk]]
[13:22:58.999]                   NAME <- NAMES[[kk]]
[13:22:58.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.999]                     next
[13:22:58.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.999]                 }
[13:22:58.999]                 NAMES <- toupper(added)
[13:22:58.999]                 for (kk in seq_along(NAMES)) {
[13:22:58.999]                   name <- added[[kk]]
[13:22:58.999]                   NAME <- NAMES[[kk]]
[13:22:58.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.999]                     next
[13:22:58.999]                   args[[name]] <- ""
[13:22:58.999]                 }
[13:22:58.999]                 NAMES <- toupper(removed)
[13:22:58.999]                 for (kk in seq_along(NAMES)) {
[13:22:58.999]                   name <- removed[[kk]]
[13:22:58.999]                   NAME <- NAMES[[kk]]
[13:22:58.999]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:58.999]                     next
[13:22:58.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:58.999]                 }
[13:22:58.999]                 if (length(args) > 0) 
[13:22:58.999]                   base::do.call(base::Sys.setenv, args = args)
[13:22:58.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:58.999]             }
[13:22:58.999]             else {
[13:22:58.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:58.999]             }
[13:22:58.999]             {
[13:22:58.999]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:58.999]                   0L) {
[13:22:58.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:58.999]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:58.999]                   base::options(opts)
[13:22:58.999]                 }
[13:22:58.999]                 {
[13:22:58.999]                   {
[13:22:58.999]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:58.999]                     NULL
[13:22:58.999]                   }
[13:22:58.999]                   options(future.plan = NULL)
[13:22:58.999]                   if (is.na(NA_character_)) 
[13:22:58.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:58.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:58.999]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:58.999]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:58.999]                     envir = parent.frame()) 
[13:22:58.999]                   {
[13:22:58.999]                     if (is.function(workers)) 
[13:22:58.999]                       workers <- workers()
[13:22:58.999]                     workers <- structure(as.integer(workers), 
[13:22:58.999]                       class = class(workers))
[13:22:58.999]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:58.999]                       workers >= 1)
[13:22:58.999]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:58.999]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:58.999]                     }
[13:22:58.999]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:58.999]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:58.999]                       envir = envir)
[13:22:58.999]                     if (!future$lazy) 
[13:22:58.999]                       future <- run(future)
[13:22:58.999]                     invisible(future)
[13:22:58.999]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:58.999]                 }
[13:22:58.999]             }
[13:22:58.999]         }
[13:22:58.999]     })
[13:22:58.999]     if (TRUE) {
[13:22:58.999]         base::sink(type = "output", split = FALSE)
[13:22:58.999]         if (TRUE) {
[13:22:58.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:58.999]         }
[13:22:58.999]         else {
[13:22:58.999]             ...future.result["stdout"] <- base::list(NULL)
[13:22:58.999]         }
[13:22:58.999]         base::close(...future.stdout)
[13:22:58.999]         ...future.stdout <- NULL
[13:22:58.999]     }
[13:22:58.999]     ...future.result$conditions <- ...future.conditions
[13:22:58.999]     ...future.result$finished <- base::Sys.time()
[13:22:58.999]     ...future.result
[13:22:58.999] }
[13:22:59.002] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:59.002] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:59.003] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:59.003] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:59.003] MultisessionFuture started
[13:22:59.003] - Launch lazy future ... done
[13:22:59.004] run() for ‘MultisessionFuture’ ... done
[13:22:59.004] result() for ClusterFuture ...
[13:22:59.004] receiveMessageFromWorker() for ClusterFuture ...
[13:22:59.004] - Validating connection of MultisessionFuture
[13:22:59.049] - received message: FutureResult
[13:22:59.049] - Received FutureResult
[13:22:59.049] - Erased future from FutureRegistry
[13:22:59.050] result() for ClusterFuture ...
[13:22:59.050] - result already collected: FutureResult
[13:22:59.050] result() for ClusterFuture ... done
[13:22:59.050] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:59.050] result() for ClusterFuture ... done
[13:22:59.050] result() for ClusterFuture ...
[13:22:59.050] - result already collected: FutureResult
[13:22:59.050] result() for ClusterFuture ... done
[13:22:59.051] getGlobalsAndPackages() ...
[13:22:59.051] Searching for globals...
[13:22:59.052] - globals found: [3] ‘{’, ‘*’, ‘a’
[13:22:59.052] Searching for globals ... DONE
[13:22:59.052] Resolving globals: FALSE
[13:22:59.052] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:59.053] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:22:59.053] - globals: [1] ‘a’
[13:22:59.053] 
[13:22:59.053] getGlobalsAndPackages() ... DONE
[13:22:59.053] run() for ‘Future’ ...
[13:22:59.054] - state: ‘created’
[13:22:59.054] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:59.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:59.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:59.068]   - Field: ‘node’
[13:22:59.068]   - Field: ‘label’
[13:22:59.068]   - Field: ‘local’
[13:22:59.068]   - Field: ‘owner’
[13:22:59.068]   - Field: ‘envir’
[13:22:59.068]   - Field: ‘workers’
[13:22:59.069]   - Field: ‘packages’
[13:22:59.069]   - Field: ‘gc’
[13:22:59.069]   - Field: ‘conditions’
[13:22:59.069]   - Field: ‘persistent’
[13:22:59.069]   - Field: ‘expr’
[13:22:59.069]   - Field: ‘uuid’
[13:22:59.069]   - Field: ‘seed’
[13:22:59.069]   - Field: ‘version’
[13:22:59.069]   - Field: ‘result’
[13:22:59.069]   - Field: ‘asynchronous’
[13:22:59.069]   - Field: ‘calls’
[13:22:59.070]   - Field: ‘globals’
[13:22:59.070]   - Field: ‘stdout’
[13:22:59.070]   - Field: ‘earlySignal’
[13:22:59.070]   - Field: ‘lazy’
[13:22:59.070]   - Field: ‘state’
[13:22:59.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:59.070] - Launch lazy future ...
[13:22:59.070] Packages needed by the future expression (n = 0): <none>
[13:22:59.071] Packages needed by future strategies (n = 0): <none>
[13:22:59.071] {
[13:22:59.071]     {
[13:22:59.071]         {
[13:22:59.071]             ...future.startTime <- base::Sys.time()
[13:22:59.071]             {
[13:22:59.071]                 {
[13:22:59.071]                   {
[13:22:59.071]                     {
[13:22:59.071]                       base::local({
[13:22:59.071]                         has_future <- base::requireNamespace("future", 
[13:22:59.071]                           quietly = TRUE)
[13:22:59.071]                         if (has_future) {
[13:22:59.071]                           ns <- base::getNamespace("future")
[13:22:59.071]                           version <- ns[[".package"]][["version"]]
[13:22:59.071]                           if (is.null(version)) 
[13:22:59.071]                             version <- utils::packageVersion("future")
[13:22:59.071]                         }
[13:22:59.071]                         else {
[13:22:59.071]                           version <- NULL
[13:22:59.071]                         }
[13:22:59.071]                         if (!has_future || version < "1.8.0") {
[13:22:59.071]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:59.071]                             "", base::R.version$version.string), 
[13:22:59.071]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:59.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:59.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:59.071]                               "release", "version")], collapse = " "), 
[13:22:59.071]                             hostname = base::Sys.info()[["nodename"]])
[13:22:59.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:59.071]                             info)
[13:22:59.071]                           info <- base::paste(info, collapse = "; ")
[13:22:59.071]                           if (!has_future) {
[13:22:59.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:59.071]                               info)
[13:22:59.071]                           }
[13:22:59.071]                           else {
[13:22:59.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:59.071]                               info, version)
[13:22:59.071]                           }
[13:22:59.071]                           base::stop(msg)
[13:22:59.071]                         }
[13:22:59.071]                       })
[13:22:59.071]                     }
[13:22:59.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:59.071]                     base::options(mc.cores = 1L)
[13:22:59.071]                   }
[13:22:59.071]                   options(future.plan = NULL)
[13:22:59.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:59.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:59.071]                 }
[13:22:59.071]                 ...future.workdir <- getwd()
[13:22:59.071]             }
[13:22:59.071]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:59.071]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:59.071]         }
[13:22:59.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:59.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:59.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:59.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:59.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:59.071]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:59.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:59.071]             base::names(...future.oldOptions))
[13:22:59.071]     }
[13:22:59.071]     if (FALSE) {
[13:22:59.071]     }
[13:22:59.071]     else {
[13:22:59.071]         if (TRUE) {
[13:22:59.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:59.071]                 open = "w")
[13:22:59.071]         }
[13:22:59.071]         else {
[13:22:59.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:59.071]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:59.071]         }
[13:22:59.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:59.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:59.071]             base::sink(type = "output", split = FALSE)
[13:22:59.071]             base::close(...future.stdout)
[13:22:59.071]         }, add = TRUE)
[13:22:59.071]     }
[13:22:59.071]     ...future.frame <- base::sys.nframe()
[13:22:59.071]     ...future.conditions <- base::list()
[13:22:59.071]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:59.071]     if (FALSE) {
[13:22:59.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:59.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:59.071]     }
[13:22:59.071]     ...future.result <- base::tryCatch({
[13:22:59.071]         base::withCallingHandlers({
[13:22:59.071]             ...future.value <- base::withVisible(base::local({
[13:22:59.071]                 ...future.makeSendCondition <- base::local({
[13:22:59.071]                   sendCondition <- NULL
[13:22:59.071]                   function(frame = 1L) {
[13:22:59.071]                     if (is.function(sendCondition)) 
[13:22:59.071]                       return(sendCondition)
[13:22:59.071]                     ns <- getNamespace("parallel")
[13:22:59.071]                     if (exists("sendData", mode = "function", 
[13:22:59.071]                       envir = ns)) {
[13:22:59.071]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:59.071]                         envir = ns)
[13:22:59.071]                       envir <- sys.frame(frame)
[13:22:59.071]                       master <- NULL
[13:22:59.071]                       while (!identical(envir, .GlobalEnv) && 
[13:22:59.071]                         !identical(envir, emptyenv())) {
[13:22:59.071]                         if (exists("master", mode = "list", envir = envir, 
[13:22:59.071]                           inherits = FALSE)) {
[13:22:59.071]                           master <- get("master", mode = "list", 
[13:22:59.071]                             envir = envir, inherits = FALSE)
[13:22:59.071]                           if (inherits(master, c("SOCKnode", 
[13:22:59.071]                             "SOCK0node"))) {
[13:22:59.071]                             sendCondition <<- function(cond) {
[13:22:59.071]                               data <- list(type = "VALUE", value = cond, 
[13:22:59.071]                                 success = TRUE)
[13:22:59.071]                               parallel_sendData(master, data)
[13:22:59.071]                             }
[13:22:59.071]                             return(sendCondition)
[13:22:59.071]                           }
[13:22:59.071]                         }
[13:22:59.071]                         frame <- frame + 1L
[13:22:59.071]                         envir <- sys.frame(frame)
[13:22:59.071]                       }
[13:22:59.071]                     }
[13:22:59.071]                     sendCondition <<- function(cond) NULL
[13:22:59.071]                   }
[13:22:59.071]                 })
[13:22:59.071]                 withCallingHandlers({
[13:22:59.071]                   {
[13:22:59.071]                     2 * a
[13:22:59.071]                   }
[13:22:59.071]                 }, immediateCondition = function(cond) {
[13:22:59.071]                   sendCondition <- ...future.makeSendCondition()
[13:22:59.071]                   sendCondition(cond)
[13:22:59.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:59.071]                   {
[13:22:59.071]                     inherits <- base::inherits
[13:22:59.071]                     invokeRestart <- base::invokeRestart
[13:22:59.071]                     is.null <- base::is.null
[13:22:59.071]                     muffled <- FALSE
[13:22:59.071]                     if (inherits(cond, "message")) {
[13:22:59.071]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:59.071]                       if (muffled) 
[13:22:59.071]                         invokeRestart("muffleMessage")
[13:22:59.071]                     }
[13:22:59.071]                     else if (inherits(cond, "warning")) {
[13:22:59.071]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:59.071]                       if (muffled) 
[13:22:59.071]                         invokeRestart("muffleWarning")
[13:22:59.071]                     }
[13:22:59.071]                     else if (inherits(cond, "condition")) {
[13:22:59.071]                       if (!is.null(pattern)) {
[13:22:59.071]                         computeRestarts <- base::computeRestarts
[13:22:59.071]                         grepl <- base::grepl
[13:22:59.071]                         restarts <- computeRestarts(cond)
[13:22:59.071]                         for (restart in restarts) {
[13:22:59.071]                           name <- restart$name
[13:22:59.071]                           if (is.null(name)) 
[13:22:59.071]                             next
[13:22:59.071]                           if (!grepl(pattern, name)) 
[13:22:59.071]                             next
[13:22:59.071]                           invokeRestart(restart)
[13:22:59.071]                           muffled <- TRUE
[13:22:59.071]                           break
[13:22:59.071]                         }
[13:22:59.071]                       }
[13:22:59.071]                     }
[13:22:59.071]                     invisible(muffled)
[13:22:59.071]                   }
[13:22:59.071]                   muffleCondition(cond)
[13:22:59.071]                 })
[13:22:59.071]             }))
[13:22:59.071]             future::FutureResult(value = ...future.value$value, 
[13:22:59.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:59.071]                   ...future.rng), globalenv = if (FALSE) 
[13:22:59.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:59.071]                     ...future.globalenv.names))
[13:22:59.071]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:59.071]         }, condition = base::local({
[13:22:59.071]             c <- base::c
[13:22:59.071]             inherits <- base::inherits
[13:22:59.071]             invokeRestart <- base::invokeRestart
[13:22:59.071]             length <- base::length
[13:22:59.071]             list <- base::list
[13:22:59.071]             seq.int <- base::seq.int
[13:22:59.071]             signalCondition <- base::signalCondition
[13:22:59.071]             sys.calls <- base::sys.calls
[13:22:59.071]             `[[` <- base::`[[`
[13:22:59.071]             `+` <- base::`+`
[13:22:59.071]             `<<-` <- base::`<<-`
[13:22:59.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:59.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:59.071]                   3L)]
[13:22:59.071]             }
[13:22:59.071]             function(cond) {
[13:22:59.071]                 is_error <- inherits(cond, "error")
[13:22:59.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:59.071]                   NULL)
[13:22:59.071]                 if (is_error) {
[13:22:59.071]                   sessionInformation <- function() {
[13:22:59.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:59.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:59.071]                       search = base::search(), system = base::Sys.info())
[13:22:59.071]                   }
[13:22:59.071]                   ...future.conditions[[length(...future.conditions) + 
[13:22:59.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:59.071]                     cond$call), session = sessionInformation(), 
[13:22:59.071]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:59.071]                   signalCondition(cond)
[13:22:59.071]                 }
[13:22:59.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:59.071]                 "immediateCondition"))) {
[13:22:59.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:59.071]                   ...future.conditions[[length(...future.conditions) + 
[13:22:59.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:59.071]                   if (TRUE && !signal) {
[13:22:59.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:59.071]                     {
[13:22:59.071]                       inherits <- base::inherits
[13:22:59.071]                       invokeRestart <- base::invokeRestart
[13:22:59.071]                       is.null <- base::is.null
[13:22:59.071]                       muffled <- FALSE
[13:22:59.071]                       if (inherits(cond, "message")) {
[13:22:59.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:59.071]                         if (muffled) 
[13:22:59.071]                           invokeRestart("muffleMessage")
[13:22:59.071]                       }
[13:22:59.071]                       else if (inherits(cond, "warning")) {
[13:22:59.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:59.071]                         if (muffled) 
[13:22:59.071]                           invokeRestart("muffleWarning")
[13:22:59.071]                       }
[13:22:59.071]                       else if (inherits(cond, "condition")) {
[13:22:59.071]                         if (!is.null(pattern)) {
[13:22:59.071]                           computeRestarts <- base::computeRestarts
[13:22:59.071]                           grepl <- base::grepl
[13:22:59.071]                           restarts <- computeRestarts(cond)
[13:22:59.071]                           for (restart in restarts) {
[13:22:59.071]                             name <- restart$name
[13:22:59.071]                             if (is.null(name)) 
[13:22:59.071]                               next
[13:22:59.071]                             if (!grepl(pattern, name)) 
[13:22:59.071]                               next
[13:22:59.071]                             invokeRestart(restart)
[13:22:59.071]                             muffled <- TRUE
[13:22:59.071]                             break
[13:22:59.071]                           }
[13:22:59.071]                         }
[13:22:59.071]                       }
[13:22:59.071]                       invisible(muffled)
[13:22:59.071]                     }
[13:22:59.071]                     muffleCondition(cond, pattern = "^muffle")
[13:22:59.071]                   }
[13:22:59.071]                 }
[13:22:59.071]                 else {
[13:22:59.071]                   if (TRUE) {
[13:22:59.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:59.071]                     {
[13:22:59.071]                       inherits <- base::inherits
[13:22:59.071]                       invokeRestart <- base::invokeRestart
[13:22:59.071]                       is.null <- base::is.null
[13:22:59.071]                       muffled <- FALSE
[13:22:59.071]                       if (inherits(cond, "message")) {
[13:22:59.071]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:59.071]                         if (muffled) 
[13:22:59.071]                           invokeRestart("muffleMessage")
[13:22:59.071]                       }
[13:22:59.071]                       else if (inherits(cond, "warning")) {
[13:22:59.071]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:59.071]                         if (muffled) 
[13:22:59.071]                           invokeRestart("muffleWarning")
[13:22:59.071]                       }
[13:22:59.071]                       else if (inherits(cond, "condition")) {
[13:22:59.071]                         if (!is.null(pattern)) {
[13:22:59.071]                           computeRestarts <- base::computeRestarts
[13:22:59.071]                           grepl <- base::grepl
[13:22:59.071]                           restarts <- computeRestarts(cond)
[13:22:59.071]                           for (restart in restarts) {
[13:22:59.071]                             name <- restart$name
[13:22:59.071]                             if (is.null(name)) 
[13:22:59.071]                               next
[13:22:59.071]                             if (!grepl(pattern, name)) 
[13:22:59.071]                               next
[13:22:59.071]                             invokeRestart(restart)
[13:22:59.071]                             muffled <- TRUE
[13:22:59.071]                             break
[13:22:59.071]                           }
[13:22:59.071]                         }
[13:22:59.071]                       }
[13:22:59.071]                       invisible(muffled)
[13:22:59.071]                     }
[13:22:59.071]                     muffleCondition(cond, pattern = "^muffle")
[13:22:59.071]                   }
[13:22:59.071]                 }
[13:22:59.071]             }
[13:22:59.071]         }))
[13:22:59.071]     }, error = function(ex) {
[13:22:59.071]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:59.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:59.071]                 ...future.rng), started = ...future.startTime, 
[13:22:59.071]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:59.071]             version = "1.8"), class = "FutureResult")
[13:22:59.071]     }, finally = {
[13:22:59.071]         if (!identical(...future.workdir, getwd())) 
[13:22:59.071]             setwd(...future.workdir)
[13:22:59.071]         {
[13:22:59.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:59.071]                 ...future.oldOptions$nwarnings <- NULL
[13:22:59.071]             }
[13:22:59.071]             base::options(...future.oldOptions)
[13:22:59.071]             if (.Platform$OS.type == "windows") {
[13:22:59.071]                 old_names <- names(...future.oldEnvVars)
[13:22:59.071]                 envs <- base::Sys.getenv()
[13:22:59.071]                 names <- names(envs)
[13:22:59.071]                 common <- intersect(names, old_names)
[13:22:59.071]                 added <- setdiff(names, old_names)
[13:22:59.071]                 removed <- setdiff(old_names, names)
[13:22:59.071]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:59.071]                   envs[common]]
[13:22:59.071]                 NAMES <- toupper(changed)
[13:22:59.071]                 args <- list()
[13:22:59.071]                 for (kk in seq_along(NAMES)) {
[13:22:59.071]                   name <- changed[[kk]]
[13:22:59.071]                   NAME <- NAMES[[kk]]
[13:22:59.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:59.071]                     next
[13:22:59.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:59.071]                 }
[13:22:59.071]                 NAMES <- toupper(added)
[13:22:59.071]                 for (kk in seq_along(NAMES)) {
[13:22:59.071]                   name <- added[[kk]]
[13:22:59.071]                   NAME <- NAMES[[kk]]
[13:22:59.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:59.071]                     next
[13:22:59.071]                   args[[name]] <- ""
[13:22:59.071]                 }
[13:22:59.071]                 NAMES <- toupper(removed)
[13:22:59.071]                 for (kk in seq_along(NAMES)) {
[13:22:59.071]                   name <- removed[[kk]]
[13:22:59.071]                   NAME <- NAMES[[kk]]
[13:22:59.071]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:59.071]                     next
[13:22:59.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:59.071]                 }
[13:22:59.071]                 if (length(args) > 0) 
[13:22:59.071]                   base::do.call(base::Sys.setenv, args = args)
[13:22:59.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:59.071]             }
[13:22:59.071]             else {
[13:22:59.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:59.071]             }
[13:22:59.071]             {
[13:22:59.071]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:59.071]                   0L) {
[13:22:59.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:59.071]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:59.071]                   base::options(opts)
[13:22:59.071]                 }
[13:22:59.071]                 {
[13:22:59.071]                   {
[13:22:59.071]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:59.071]                     NULL
[13:22:59.071]                   }
[13:22:59.071]                   options(future.plan = NULL)
[13:22:59.071]                   if (is.na(NA_character_)) 
[13:22:59.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:59.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:59.071]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:59.071]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:59.071]                     envir = parent.frame()) 
[13:22:59.071]                   {
[13:22:59.071]                     if (is.function(workers)) 
[13:22:59.071]                       workers <- workers()
[13:22:59.071]                     workers <- structure(as.integer(workers), 
[13:22:59.071]                       class = class(workers))
[13:22:59.071]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:59.071]                       workers >= 1)
[13:22:59.071]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:59.071]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:59.071]                     }
[13:22:59.071]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:59.071]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:59.071]                       envir = envir)
[13:22:59.071]                     if (!future$lazy) 
[13:22:59.071]                       future <- run(future)
[13:22:59.071]                     invisible(future)
[13:22:59.071]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:59.071]                 }
[13:22:59.071]             }
[13:22:59.071]         }
[13:22:59.071]     })
[13:22:59.071]     if (TRUE) {
[13:22:59.071]         base::sink(type = "output", split = FALSE)
[13:22:59.071]         if (TRUE) {
[13:22:59.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:59.071]         }
[13:22:59.071]         else {
[13:22:59.071]             ...future.result["stdout"] <- base::list(NULL)
[13:22:59.071]         }
[13:22:59.071]         base::close(...future.stdout)
[13:22:59.071]         ...future.stdout <- NULL
[13:22:59.071]     }
[13:22:59.071]     ...future.result$conditions <- ...future.conditions
[13:22:59.071]     ...future.result$finished <- base::Sys.time()
[13:22:59.071]     ...future.result
[13:22:59.071] }
[13:22:59.074] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:59.074] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[13:22:59.075] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[13:22:59.075] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:59.075] MultisessionFuture started
[13:22:59.075] - Launch lazy future ... done
[13:22:59.075] run() for ‘MultisessionFuture’ ... done
[13:22:59.076] result() for ClusterFuture ...
[13:22:59.076] receiveMessageFromWorker() for ClusterFuture ...
[13:22:59.076] - Validating connection of MultisessionFuture
[13:22:59.121] - received message: FutureResult
[13:22:59.121] - Received FutureResult
[13:22:59.122] - Erased future from FutureRegistry
[13:22:59.122] result() for ClusterFuture ...
[13:22:59.122] - result already collected: FutureResult
[13:22:59.122] result() for ClusterFuture ... done
[13:22:59.122] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:59.122] result() for ClusterFuture ... done
[13:22:59.122] result() for ClusterFuture ...
[13:22:59.122] - result already collected: FutureResult
[13:22:59.122] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[13:22:59.123] plan(): Setting new future strategy stack:
[13:22:59.123] List of future strategies:
[13:22:59.123] 1. FutureStrategy:
[13:22:59.123]    - args: function (..., envir = parent.frame())
[13:22:59.123]    - tweaked: FALSE
[13:22:59.123]    - call: future::plan(oplan)
[13:22:59.124] plan(): nbrOfWorkers() = 1
> 
