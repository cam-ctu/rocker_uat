
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:33.872] plan(): Setting new future strategy stack:
[16:04:33.873] List of future strategies:
[16:04:33.873] 1. sequential:
[16:04:33.873]    - args: function (..., envir = parent.frame())
[16:04:33.873]    - tweaked: FALSE
[16:04:33.873]    - call: future::plan("sequential")
[16:04:33.887] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[16:04:33.898] getGlobalsAndPackages() ...
[16:04:33.898] Searching for globals...
[16:04:33.904] - globals found: [2] ‘{’, ‘cat’
[16:04:33.904] Searching for globals ... DONE
[16:04:33.904] Resolving globals: FALSE
[16:04:33.905] 
[16:04:33.905] 
[16:04:33.905] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[16:04:33.906] run() for ‘Future’ ...
[16:04:33.906] - state: ‘created’
[16:04:33.906] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.907] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.907]   - Field: ‘label’
[16:04:33.907]   - Field: ‘local’
[16:04:33.907]   - Field: ‘owner’
[16:04:33.907]   - Field: ‘envir’
[16:04:33.907]   - Field: ‘packages’
[16:04:33.907]   - Field: ‘gc’
[16:04:33.908]   - Field: ‘conditions’
[16:04:33.908]   - Field: ‘expr’
[16:04:33.908]   - Field: ‘uuid’
[16:04:33.908]   - Field: ‘seed’
[16:04:33.908]   - Field: ‘version’
[16:04:33.908]   - Field: ‘result’
[16:04:33.908]   - Field: ‘asynchronous’
[16:04:33.908]   - Field: ‘calls’
[16:04:33.908]   - Field: ‘globals’
[16:04:33.908]   - Field: ‘stdout’
[16:04:33.908]   - Field: ‘earlySignal’
[16:04:33.909]   - Field: ‘lazy’
[16:04:33.909]   - Field: ‘state’
[16:04:33.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:33.909] - Launch lazy future ...
[16:04:33.910] Packages needed by the future expression (n = 0): <none>
[16:04:33.910] Packages needed by future strategies (n = 0): <none>
[16:04:33.911] {
[16:04:33.911]     {
[16:04:33.911]         {
[16:04:33.911]             ...future.startTime <- base::Sys.time()
[16:04:33.911]             {
[16:04:33.911]                 {
[16:04:33.911]                   {
[16:04:33.911]                     base::local({
[16:04:33.911]                       has_future <- base::requireNamespace("future", 
[16:04:33.911]                         quietly = TRUE)
[16:04:33.911]                       if (has_future) {
[16:04:33.911]                         ns <- base::getNamespace("future")
[16:04:33.911]                         version <- ns[[".package"]][["version"]]
[16:04:33.911]                         if (is.null(version)) 
[16:04:33.911]                           version <- utils::packageVersion("future")
[16:04:33.911]                       }
[16:04:33.911]                       else {
[16:04:33.911]                         version <- NULL
[16:04:33.911]                       }
[16:04:33.911]                       if (!has_future || version < "1.8.0") {
[16:04:33.911]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:33.911]                           "", base::R.version$version.string), 
[16:04:33.911]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:33.911]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:33.911]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:33.911]                             "release", "version")], collapse = " "), 
[16:04:33.911]                           hostname = base::Sys.info()[["nodename"]])
[16:04:33.911]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:33.911]                           info)
[16:04:33.911]                         info <- base::paste(info, collapse = "; ")
[16:04:33.911]                         if (!has_future) {
[16:04:33.911]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:33.911]                             info)
[16:04:33.911]                         }
[16:04:33.911]                         else {
[16:04:33.911]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:33.911]                             info, version)
[16:04:33.911]                         }
[16:04:33.911]                         base::stop(msg)
[16:04:33.911]                       }
[16:04:33.911]                     })
[16:04:33.911]                   }
[16:04:33.911]                   options(future.plan = NULL)
[16:04:33.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:33.911]                 }
[16:04:33.911]                 ...future.workdir <- getwd()
[16:04:33.911]             }
[16:04:33.911]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:33.911]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:33.911]         }
[16:04:33.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:33.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:33.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:33.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:33.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:33.911]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:33.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:33.911]             base::names(...future.oldOptions))
[16:04:33.911]     }
[16:04:33.911]     if (FALSE) {
[16:04:33.911]     }
[16:04:33.911]     else {
[16:04:33.911]         if (TRUE) {
[16:04:33.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:33.911]                 open = "w")
[16:04:33.911]         }
[16:04:33.911]         else {
[16:04:33.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:33.911]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:33.911]         }
[16:04:33.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:33.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:33.911]             base::sink(type = "output", split = FALSE)
[16:04:33.911]             base::close(...future.stdout)
[16:04:33.911]         }, add = TRUE)
[16:04:33.911]     }
[16:04:33.911]     ...future.frame <- base::sys.nframe()
[16:04:33.911]     ...future.conditions <- base::list()
[16:04:33.911]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:33.911]     if (FALSE) {
[16:04:33.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:33.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:33.911]     }
[16:04:33.911]     ...future.result <- base::tryCatch({
[16:04:33.911]         base::withCallingHandlers({
[16:04:33.911]             ...future.value <- base::withVisible(base::local({
[16:04:33.911]                 cat("Future assignment evaluated\n")
[16:04:33.911]                 2
[16:04:33.911]             }))
[16:04:33.911]             future::FutureResult(value = ...future.value$value, 
[16:04:33.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.911]                   ...future.rng), globalenv = if (FALSE) 
[16:04:33.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:33.911]                     ...future.globalenv.names))
[16:04:33.911]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:33.911]         }, condition = base::local({
[16:04:33.911]             c <- base::c
[16:04:33.911]             inherits <- base::inherits
[16:04:33.911]             invokeRestart <- base::invokeRestart
[16:04:33.911]             length <- base::length
[16:04:33.911]             list <- base::list
[16:04:33.911]             seq.int <- base::seq.int
[16:04:33.911]             signalCondition <- base::signalCondition
[16:04:33.911]             sys.calls <- base::sys.calls
[16:04:33.911]             `[[` <- base::`[[`
[16:04:33.911]             `+` <- base::`+`
[16:04:33.911]             `<<-` <- base::`<<-`
[16:04:33.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:33.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:33.911]                   3L)]
[16:04:33.911]             }
[16:04:33.911]             function(cond) {
[16:04:33.911]                 is_error <- inherits(cond, "error")
[16:04:33.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:33.911]                   NULL)
[16:04:33.911]                 if (is_error) {
[16:04:33.911]                   sessionInformation <- function() {
[16:04:33.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:33.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:33.911]                       search = base::search(), system = base::Sys.info())
[16:04:33.911]                   }
[16:04:33.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:33.911]                     cond$call), session = sessionInformation(), 
[16:04:33.911]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:33.911]                   signalCondition(cond)
[16:04:33.911]                 }
[16:04:33.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:33.911]                 "immediateCondition"))) {
[16:04:33.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:33.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:33.911]                   if (TRUE && !signal) {
[16:04:33.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.911]                     {
[16:04:33.911]                       inherits <- base::inherits
[16:04:33.911]                       invokeRestart <- base::invokeRestart
[16:04:33.911]                       is.null <- base::is.null
[16:04:33.911]                       muffled <- FALSE
[16:04:33.911]                       if (inherits(cond, "message")) {
[16:04:33.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.911]                         if (muffled) 
[16:04:33.911]                           invokeRestart("muffleMessage")
[16:04:33.911]                       }
[16:04:33.911]                       else if (inherits(cond, "warning")) {
[16:04:33.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.911]                         if (muffled) 
[16:04:33.911]                           invokeRestart("muffleWarning")
[16:04:33.911]                       }
[16:04:33.911]                       else if (inherits(cond, "condition")) {
[16:04:33.911]                         if (!is.null(pattern)) {
[16:04:33.911]                           computeRestarts <- base::computeRestarts
[16:04:33.911]                           grepl <- base::grepl
[16:04:33.911]                           restarts <- computeRestarts(cond)
[16:04:33.911]                           for (restart in restarts) {
[16:04:33.911]                             name <- restart$name
[16:04:33.911]                             if (is.null(name)) 
[16:04:33.911]                               next
[16:04:33.911]                             if (!grepl(pattern, name)) 
[16:04:33.911]                               next
[16:04:33.911]                             invokeRestart(restart)
[16:04:33.911]                             muffled <- TRUE
[16:04:33.911]                             break
[16:04:33.911]                           }
[16:04:33.911]                         }
[16:04:33.911]                       }
[16:04:33.911]                       invisible(muffled)
[16:04:33.911]                     }
[16:04:33.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.911]                   }
[16:04:33.911]                 }
[16:04:33.911]                 else {
[16:04:33.911]                   if (TRUE) {
[16:04:33.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.911]                     {
[16:04:33.911]                       inherits <- base::inherits
[16:04:33.911]                       invokeRestart <- base::invokeRestart
[16:04:33.911]                       is.null <- base::is.null
[16:04:33.911]                       muffled <- FALSE
[16:04:33.911]                       if (inherits(cond, "message")) {
[16:04:33.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.911]                         if (muffled) 
[16:04:33.911]                           invokeRestart("muffleMessage")
[16:04:33.911]                       }
[16:04:33.911]                       else if (inherits(cond, "warning")) {
[16:04:33.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.911]                         if (muffled) 
[16:04:33.911]                           invokeRestart("muffleWarning")
[16:04:33.911]                       }
[16:04:33.911]                       else if (inherits(cond, "condition")) {
[16:04:33.911]                         if (!is.null(pattern)) {
[16:04:33.911]                           computeRestarts <- base::computeRestarts
[16:04:33.911]                           grepl <- base::grepl
[16:04:33.911]                           restarts <- computeRestarts(cond)
[16:04:33.911]                           for (restart in restarts) {
[16:04:33.911]                             name <- restart$name
[16:04:33.911]                             if (is.null(name)) 
[16:04:33.911]                               next
[16:04:33.911]                             if (!grepl(pattern, name)) 
[16:04:33.911]                               next
[16:04:33.911]                             invokeRestart(restart)
[16:04:33.911]                             muffled <- TRUE
[16:04:33.911]                             break
[16:04:33.911]                           }
[16:04:33.911]                         }
[16:04:33.911]                       }
[16:04:33.911]                       invisible(muffled)
[16:04:33.911]                     }
[16:04:33.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.911]                   }
[16:04:33.911]                 }
[16:04:33.911]             }
[16:04:33.911]         }))
[16:04:33.911]     }, error = function(ex) {
[16:04:33.911]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:33.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.911]                 ...future.rng), started = ...future.startTime, 
[16:04:33.911]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:33.911]             version = "1.8"), class = "FutureResult")
[16:04:33.911]     }, finally = {
[16:04:33.911]         if (!identical(...future.workdir, getwd())) 
[16:04:33.911]             setwd(...future.workdir)
[16:04:33.911]         {
[16:04:33.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:33.911]                 ...future.oldOptions$nwarnings <- NULL
[16:04:33.911]             }
[16:04:33.911]             base::options(...future.oldOptions)
[16:04:33.911]             if (.Platform$OS.type == "windows") {
[16:04:33.911]                 old_names <- names(...future.oldEnvVars)
[16:04:33.911]                 envs <- base::Sys.getenv()
[16:04:33.911]                 names <- names(envs)
[16:04:33.911]                 common <- intersect(names, old_names)
[16:04:33.911]                 added <- setdiff(names, old_names)
[16:04:33.911]                 removed <- setdiff(old_names, names)
[16:04:33.911]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:33.911]                   envs[common]]
[16:04:33.911]                 NAMES <- toupper(changed)
[16:04:33.911]                 args <- list()
[16:04:33.911]                 for (kk in seq_along(NAMES)) {
[16:04:33.911]                   name <- changed[[kk]]
[16:04:33.911]                   NAME <- NAMES[[kk]]
[16:04:33.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.911]                     next
[16:04:33.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.911]                 }
[16:04:33.911]                 NAMES <- toupper(added)
[16:04:33.911]                 for (kk in seq_along(NAMES)) {
[16:04:33.911]                   name <- added[[kk]]
[16:04:33.911]                   NAME <- NAMES[[kk]]
[16:04:33.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.911]                     next
[16:04:33.911]                   args[[name]] <- ""
[16:04:33.911]                 }
[16:04:33.911]                 NAMES <- toupper(removed)
[16:04:33.911]                 for (kk in seq_along(NAMES)) {
[16:04:33.911]                   name <- removed[[kk]]
[16:04:33.911]                   NAME <- NAMES[[kk]]
[16:04:33.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.911]                     next
[16:04:33.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.911]                 }
[16:04:33.911]                 if (length(args) > 0) 
[16:04:33.911]                   base::do.call(base::Sys.setenv, args = args)
[16:04:33.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:33.911]             }
[16:04:33.911]             else {
[16:04:33.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:33.911]             }
[16:04:33.911]             {
[16:04:33.911]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:33.911]                   0L) {
[16:04:33.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:33.911]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:33.911]                   base::options(opts)
[16:04:33.911]                 }
[16:04:33.911]                 {
[16:04:33.911]                   {
[16:04:33.911]                     NULL
[16:04:33.911]                     RNGkind("Mersenne-Twister")
[16:04:33.911]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:33.911]                       inherits = FALSE)
[16:04:33.911]                   }
[16:04:33.911]                   options(future.plan = NULL)
[16:04:33.911]                   if (is.na(NA_character_)) 
[16:04:33.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:33.911]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:33.911]                   {
[16:04:33.911]                     future <- SequentialFuture(..., envir = envir)
[16:04:33.911]                     if (!future$lazy) 
[16:04:33.911]                       future <- run(future)
[16:04:33.911]                     invisible(future)
[16:04:33.911]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:33.911]                 }
[16:04:33.911]             }
[16:04:33.911]         }
[16:04:33.911]     })
[16:04:33.911]     if (TRUE) {
[16:04:33.911]         base::sink(type = "output", split = FALSE)
[16:04:33.911]         if (TRUE) {
[16:04:33.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:33.911]         }
[16:04:33.911]         else {
[16:04:33.911]             ...future.result["stdout"] <- base::list(NULL)
[16:04:33.911]         }
[16:04:33.911]         base::close(...future.stdout)
[16:04:33.911]         ...future.stdout <- NULL
[16:04:33.911]     }
[16:04:33.911]     ...future.result$conditions <- ...future.conditions
[16:04:33.911]     ...future.result$finished <- base::Sys.time()
[16:04:33.911]     ...future.result
[16:04:33.911] }
[16:04:33.913] plan(): Setting new future strategy stack:
[16:04:33.913] List of future strategies:
[16:04:33.913] 1. sequential:
[16:04:33.913]    - args: function (..., envir = parent.frame())
[16:04:33.913]    - tweaked: FALSE
[16:04:33.913]    - call: NULL
[16:04:33.913] plan(): nbrOfWorkers() = 1
[16:04:33.914] plan(): Setting new future strategy stack:
[16:04:33.914] List of future strategies:
[16:04:33.914] 1. sequential:
[16:04:33.914]    - args: function (..., envir = parent.frame())
[16:04:33.914]    - tweaked: FALSE
[16:04:33.914]    - call: future::plan("sequential")
[16:04:33.915] plan(): nbrOfWorkers() = 1
[16:04:33.915] SequentialFuture started (and completed)
[16:04:33.915] - Launch lazy future ... done
[16:04:33.915] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[16:04:33.941] plan(): Setting new future strategy stack:
[16:04:33.941] List of future strategies:
[16:04:33.941] 1. sequential:
[16:04:33.941]    - args: function (..., envir = parent.frame())
[16:04:33.941]    - tweaked: FALSE
[16:04:33.941]    - call: plan(strategy)
[16:04:33.952] plan(): nbrOfWorkers() = 1
[16:04:33.952] getGlobalsAndPackages() ...
[16:04:33.952] Searching for globals...
[16:04:33.953] - globals found: [1] ‘{’
[16:04:33.953] Searching for globals ... DONE
[16:04:33.953] Resolving globals: FALSE
[16:04:33.953] 
[16:04:33.953] 
[16:04:33.953] getGlobalsAndPackages() ... DONE
[16:04:33.954] run() for ‘Future’ ...
[16:04:33.954] - state: ‘created’
[16:04:33.954] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.954]   - Field: ‘label’
[16:04:33.954]   - Field: ‘local’
[16:04:33.954]   - Field: ‘owner’
[16:04:33.955]   - Field: ‘envir’
[16:04:33.955]   - Field: ‘packages’
[16:04:33.955]   - Field: ‘gc’
[16:04:33.955]   - Field: ‘conditions’
[16:04:33.955]   - Field: ‘expr’
[16:04:33.955]   - Field: ‘uuid’
[16:04:33.955]   - Field: ‘seed’
[16:04:33.955]   - Field: ‘version’
[16:04:33.955]   - Field: ‘result’
[16:04:33.955]   - Field: ‘asynchronous’
[16:04:33.955]   - Field: ‘calls’
[16:04:33.955]   - Field: ‘globals’
[16:04:33.956]   - Field: ‘stdout’
[16:04:33.956]   - Field: ‘earlySignal’
[16:04:33.956]   - Field: ‘lazy’
[16:04:33.956]   - Field: ‘state’
[16:04:33.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:33.956] - Launch lazy future ...
[16:04:33.956] Packages needed by the future expression (n = 0): <none>
[16:04:33.956] Packages needed by future strategies (n = 0): <none>
[16:04:33.957] {
[16:04:33.957]     {
[16:04:33.957]         {
[16:04:33.957]             ...future.startTime <- base::Sys.time()
[16:04:33.957]             {
[16:04:33.957]                 {
[16:04:33.957]                   {
[16:04:33.957]                     base::local({
[16:04:33.957]                       has_future <- base::requireNamespace("future", 
[16:04:33.957]                         quietly = TRUE)
[16:04:33.957]                       if (has_future) {
[16:04:33.957]                         ns <- base::getNamespace("future")
[16:04:33.957]                         version <- ns[[".package"]][["version"]]
[16:04:33.957]                         if (is.null(version)) 
[16:04:33.957]                           version <- utils::packageVersion("future")
[16:04:33.957]                       }
[16:04:33.957]                       else {
[16:04:33.957]                         version <- NULL
[16:04:33.957]                       }
[16:04:33.957]                       if (!has_future || version < "1.8.0") {
[16:04:33.957]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:33.957]                           "", base::R.version$version.string), 
[16:04:33.957]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:33.957]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:33.957]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:33.957]                             "release", "version")], collapse = " "), 
[16:04:33.957]                           hostname = base::Sys.info()[["nodename"]])
[16:04:33.957]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:33.957]                           info)
[16:04:33.957]                         info <- base::paste(info, collapse = "; ")
[16:04:33.957]                         if (!has_future) {
[16:04:33.957]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:33.957]                             info)
[16:04:33.957]                         }
[16:04:33.957]                         else {
[16:04:33.957]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:33.957]                             info, version)
[16:04:33.957]                         }
[16:04:33.957]                         base::stop(msg)
[16:04:33.957]                       }
[16:04:33.957]                     })
[16:04:33.957]                   }
[16:04:33.957]                   options(future.plan = NULL)
[16:04:33.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:33.957]                 }
[16:04:33.957]                 ...future.workdir <- getwd()
[16:04:33.957]             }
[16:04:33.957]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:33.957]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:33.957]         }
[16:04:33.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:33.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:33.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:33.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:33.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:33.957]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:33.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:33.957]             base::names(...future.oldOptions))
[16:04:33.957]     }
[16:04:33.957]     if (FALSE) {
[16:04:33.957]     }
[16:04:33.957]     else {
[16:04:33.957]         if (TRUE) {
[16:04:33.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:33.957]                 open = "w")
[16:04:33.957]         }
[16:04:33.957]         else {
[16:04:33.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:33.957]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:33.957]         }
[16:04:33.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:33.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:33.957]             base::sink(type = "output", split = FALSE)
[16:04:33.957]             base::close(...future.stdout)
[16:04:33.957]         }, add = TRUE)
[16:04:33.957]     }
[16:04:33.957]     ...future.frame <- base::sys.nframe()
[16:04:33.957]     ...future.conditions <- base::list()
[16:04:33.957]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:33.957]     if (FALSE) {
[16:04:33.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:33.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:33.957]     }
[16:04:33.957]     ...future.result <- base::tryCatch({
[16:04:33.957]         base::withCallingHandlers({
[16:04:33.957]             ...future.value <- base::withVisible(base::local({
[16:04:33.957]                 2
[16:04:33.957]             }))
[16:04:33.957]             future::FutureResult(value = ...future.value$value, 
[16:04:33.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.957]                   ...future.rng), globalenv = if (FALSE) 
[16:04:33.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:33.957]                     ...future.globalenv.names))
[16:04:33.957]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:33.957]         }, condition = base::local({
[16:04:33.957]             c <- base::c
[16:04:33.957]             inherits <- base::inherits
[16:04:33.957]             invokeRestart <- base::invokeRestart
[16:04:33.957]             length <- base::length
[16:04:33.957]             list <- base::list
[16:04:33.957]             seq.int <- base::seq.int
[16:04:33.957]             signalCondition <- base::signalCondition
[16:04:33.957]             sys.calls <- base::sys.calls
[16:04:33.957]             `[[` <- base::`[[`
[16:04:33.957]             `+` <- base::`+`
[16:04:33.957]             `<<-` <- base::`<<-`
[16:04:33.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:33.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:33.957]                   3L)]
[16:04:33.957]             }
[16:04:33.957]             function(cond) {
[16:04:33.957]                 is_error <- inherits(cond, "error")
[16:04:33.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:33.957]                   NULL)
[16:04:33.957]                 if (is_error) {
[16:04:33.957]                   sessionInformation <- function() {
[16:04:33.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:33.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:33.957]                       search = base::search(), system = base::Sys.info())
[16:04:33.957]                   }
[16:04:33.957]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:33.957]                     cond$call), session = sessionInformation(), 
[16:04:33.957]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:33.957]                   signalCondition(cond)
[16:04:33.957]                 }
[16:04:33.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:33.957]                 "immediateCondition"))) {
[16:04:33.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:33.957]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:33.957]                   if (TRUE && !signal) {
[16:04:33.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.957]                     {
[16:04:33.957]                       inherits <- base::inherits
[16:04:33.957]                       invokeRestart <- base::invokeRestart
[16:04:33.957]                       is.null <- base::is.null
[16:04:33.957]                       muffled <- FALSE
[16:04:33.957]                       if (inherits(cond, "message")) {
[16:04:33.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.957]                         if (muffled) 
[16:04:33.957]                           invokeRestart("muffleMessage")
[16:04:33.957]                       }
[16:04:33.957]                       else if (inherits(cond, "warning")) {
[16:04:33.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.957]                         if (muffled) 
[16:04:33.957]                           invokeRestart("muffleWarning")
[16:04:33.957]                       }
[16:04:33.957]                       else if (inherits(cond, "condition")) {
[16:04:33.957]                         if (!is.null(pattern)) {
[16:04:33.957]                           computeRestarts <- base::computeRestarts
[16:04:33.957]                           grepl <- base::grepl
[16:04:33.957]                           restarts <- computeRestarts(cond)
[16:04:33.957]                           for (restart in restarts) {
[16:04:33.957]                             name <- restart$name
[16:04:33.957]                             if (is.null(name)) 
[16:04:33.957]                               next
[16:04:33.957]                             if (!grepl(pattern, name)) 
[16:04:33.957]                               next
[16:04:33.957]                             invokeRestart(restart)
[16:04:33.957]                             muffled <- TRUE
[16:04:33.957]                             break
[16:04:33.957]                           }
[16:04:33.957]                         }
[16:04:33.957]                       }
[16:04:33.957]                       invisible(muffled)
[16:04:33.957]                     }
[16:04:33.957]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.957]                   }
[16:04:33.957]                 }
[16:04:33.957]                 else {
[16:04:33.957]                   if (TRUE) {
[16:04:33.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.957]                     {
[16:04:33.957]                       inherits <- base::inherits
[16:04:33.957]                       invokeRestart <- base::invokeRestart
[16:04:33.957]                       is.null <- base::is.null
[16:04:33.957]                       muffled <- FALSE
[16:04:33.957]                       if (inherits(cond, "message")) {
[16:04:33.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.957]                         if (muffled) 
[16:04:33.957]                           invokeRestart("muffleMessage")
[16:04:33.957]                       }
[16:04:33.957]                       else if (inherits(cond, "warning")) {
[16:04:33.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.957]                         if (muffled) 
[16:04:33.957]                           invokeRestart("muffleWarning")
[16:04:33.957]                       }
[16:04:33.957]                       else if (inherits(cond, "condition")) {
[16:04:33.957]                         if (!is.null(pattern)) {
[16:04:33.957]                           computeRestarts <- base::computeRestarts
[16:04:33.957]                           grepl <- base::grepl
[16:04:33.957]                           restarts <- computeRestarts(cond)
[16:04:33.957]                           for (restart in restarts) {
[16:04:33.957]                             name <- restart$name
[16:04:33.957]                             if (is.null(name)) 
[16:04:33.957]                               next
[16:04:33.957]                             if (!grepl(pattern, name)) 
[16:04:33.957]                               next
[16:04:33.957]                             invokeRestart(restart)
[16:04:33.957]                             muffled <- TRUE
[16:04:33.957]                             break
[16:04:33.957]                           }
[16:04:33.957]                         }
[16:04:33.957]                       }
[16:04:33.957]                       invisible(muffled)
[16:04:33.957]                     }
[16:04:33.957]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.957]                   }
[16:04:33.957]                 }
[16:04:33.957]             }
[16:04:33.957]         }))
[16:04:33.957]     }, error = function(ex) {
[16:04:33.957]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:33.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.957]                 ...future.rng), started = ...future.startTime, 
[16:04:33.957]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:33.957]             version = "1.8"), class = "FutureResult")
[16:04:33.957]     }, finally = {
[16:04:33.957]         if (!identical(...future.workdir, getwd())) 
[16:04:33.957]             setwd(...future.workdir)
[16:04:33.957]         {
[16:04:33.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:33.957]                 ...future.oldOptions$nwarnings <- NULL
[16:04:33.957]             }
[16:04:33.957]             base::options(...future.oldOptions)
[16:04:33.957]             if (.Platform$OS.type == "windows") {
[16:04:33.957]                 old_names <- names(...future.oldEnvVars)
[16:04:33.957]                 envs <- base::Sys.getenv()
[16:04:33.957]                 names <- names(envs)
[16:04:33.957]                 common <- intersect(names, old_names)
[16:04:33.957]                 added <- setdiff(names, old_names)
[16:04:33.957]                 removed <- setdiff(old_names, names)
[16:04:33.957]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:33.957]                   envs[common]]
[16:04:33.957]                 NAMES <- toupper(changed)
[16:04:33.957]                 args <- list()
[16:04:33.957]                 for (kk in seq_along(NAMES)) {
[16:04:33.957]                   name <- changed[[kk]]
[16:04:33.957]                   NAME <- NAMES[[kk]]
[16:04:33.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.957]                     next
[16:04:33.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.957]                 }
[16:04:33.957]                 NAMES <- toupper(added)
[16:04:33.957]                 for (kk in seq_along(NAMES)) {
[16:04:33.957]                   name <- added[[kk]]
[16:04:33.957]                   NAME <- NAMES[[kk]]
[16:04:33.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.957]                     next
[16:04:33.957]                   args[[name]] <- ""
[16:04:33.957]                 }
[16:04:33.957]                 NAMES <- toupper(removed)
[16:04:33.957]                 for (kk in seq_along(NAMES)) {
[16:04:33.957]                   name <- removed[[kk]]
[16:04:33.957]                   NAME <- NAMES[[kk]]
[16:04:33.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.957]                     next
[16:04:33.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.957]                 }
[16:04:33.957]                 if (length(args) > 0) 
[16:04:33.957]                   base::do.call(base::Sys.setenv, args = args)
[16:04:33.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:33.957]             }
[16:04:33.957]             else {
[16:04:33.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:33.957]             }
[16:04:33.957]             {
[16:04:33.957]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:33.957]                   0L) {
[16:04:33.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:33.957]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:33.957]                   base::options(opts)
[16:04:33.957]                 }
[16:04:33.957]                 {
[16:04:33.957]                   {
[16:04:33.957]                     NULL
[16:04:33.957]                     RNGkind("Mersenne-Twister")
[16:04:33.957]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:33.957]                       inherits = FALSE)
[16:04:33.957]                   }
[16:04:33.957]                   options(future.plan = NULL)
[16:04:33.957]                   if (is.na(NA_character_)) 
[16:04:33.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:33.957]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:33.957]                   {
[16:04:33.957]                     future <- SequentialFuture(..., envir = envir)
[16:04:33.957]                     if (!future$lazy) 
[16:04:33.957]                       future <- run(future)
[16:04:33.957]                     invisible(future)
[16:04:33.957]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:33.957]                 }
[16:04:33.957]             }
[16:04:33.957]         }
[16:04:33.957]     })
[16:04:33.957]     if (TRUE) {
[16:04:33.957]         base::sink(type = "output", split = FALSE)
[16:04:33.957]         if (TRUE) {
[16:04:33.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:33.957]         }
[16:04:33.957]         else {
[16:04:33.957]             ...future.result["stdout"] <- base::list(NULL)
[16:04:33.957]         }
[16:04:33.957]         base::close(...future.stdout)
[16:04:33.957]         ...future.stdout <- NULL
[16:04:33.957]     }
[16:04:33.957]     ...future.result$conditions <- ...future.conditions
[16:04:33.957]     ...future.result$finished <- base::Sys.time()
[16:04:33.957]     ...future.result
[16:04:33.957] }
[16:04:33.958] plan(): Setting new future strategy stack:
[16:04:33.958] List of future strategies:
[16:04:33.958] 1. sequential:
[16:04:33.958]    - args: function (..., envir = parent.frame())
[16:04:33.958]    - tweaked: FALSE
[16:04:33.958]    - call: NULL
[16:04:33.959] plan(): nbrOfWorkers() = 1
[16:04:33.959] plan(): Setting new future strategy stack:
[16:04:33.960] List of future strategies:
[16:04:33.960] 1. sequential:
[16:04:33.960]    - args: function (..., envir = parent.frame())
[16:04:33.960]    - tweaked: FALSE
[16:04:33.960]    - call: plan(strategy)
[16:04:33.960] plan(): nbrOfWorkers() = 1
[16:04:33.960] SequentialFuture started (and completed)
[16:04:33.960] - Launch lazy future ... done
[16:04:33.960] run() for ‘SequentialFuture’ ... done
[16:04:33.960] getGlobalsAndPackages() ...
[16:04:33.961] Searching for globals...
[16:04:33.961] - globals found: [1] ‘{’
[16:04:33.961] Searching for globals ... DONE
[16:04:33.961] Resolving globals: FALSE
[16:04:33.961] 
[16:04:33.962] 
[16:04:33.962] getGlobalsAndPackages() ... DONE
[16:04:33.962] run() for ‘Future’ ...
[16:04:33.962] - state: ‘created’
[16:04:33.962] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.962] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.962]   - Field: ‘label’
[16:04:33.963]   - Field: ‘local’
[16:04:33.963]   - Field: ‘owner’
[16:04:33.963]   - Field: ‘envir’
[16:04:33.963]   - Field: ‘packages’
[16:04:33.963]   - Field: ‘gc’
[16:04:33.963]   - Field: ‘conditions’
[16:04:33.963]   - Field: ‘expr’
[16:04:33.963]   - Field: ‘uuid’
[16:04:33.963]   - Field: ‘seed’
[16:04:33.963]   - Field: ‘version’
[16:04:33.963]   - Field: ‘result’
[16:04:33.964]   - Field: ‘asynchronous’
[16:04:33.964]   - Field: ‘calls’
[16:04:33.964]   - Field: ‘globals’
[16:04:33.964]   - Field: ‘stdout’
[16:04:33.964]   - Field: ‘earlySignal’
[16:04:33.964]   - Field: ‘lazy’
[16:04:33.964]   - Field: ‘state’
[16:04:33.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:33.964] - Launch lazy future ...
[16:04:33.964] Packages needed by the future expression (n = 0): <none>
[16:04:33.965] Packages needed by future strategies (n = 0): <none>
[16:04:33.965] {
[16:04:33.965]     {
[16:04:33.965]         {
[16:04:33.965]             ...future.startTime <- base::Sys.time()
[16:04:33.965]             {
[16:04:33.965]                 {
[16:04:33.965]                   {
[16:04:33.965]                     base::local({
[16:04:33.965]                       has_future <- base::requireNamespace("future", 
[16:04:33.965]                         quietly = TRUE)
[16:04:33.965]                       if (has_future) {
[16:04:33.965]                         ns <- base::getNamespace("future")
[16:04:33.965]                         version <- ns[[".package"]][["version"]]
[16:04:33.965]                         if (is.null(version)) 
[16:04:33.965]                           version <- utils::packageVersion("future")
[16:04:33.965]                       }
[16:04:33.965]                       else {
[16:04:33.965]                         version <- NULL
[16:04:33.965]                       }
[16:04:33.965]                       if (!has_future || version < "1.8.0") {
[16:04:33.965]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:33.965]                           "", base::R.version$version.string), 
[16:04:33.965]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:33.965]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:33.965]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:33.965]                             "release", "version")], collapse = " "), 
[16:04:33.965]                           hostname = base::Sys.info()[["nodename"]])
[16:04:33.965]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:33.965]                           info)
[16:04:33.965]                         info <- base::paste(info, collapse = "; ")
[16:04:33.965]                         if (!has_future) {
[16:04:33.965]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:33.965]                             info)
[16:04:33.965]                         }
[16:04:33.965]                         else {
[16:04:33.965]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:33.965]                             info, version)
[16:04:33.965]                         }
[16:04:33.965]                         base::stop(msg)
[16:04:33.965]                       }
[16:04:33.965]                     })
[16:04:33.965]                   }
[16:04:33.965]                   options(future.plan = NULL)
[16:04:33.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:33.965]                 }
[16:04:33.965]                 ...future.workdir <- getwd()
[16:04:33.965]             }
[16:04:33.965]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:33.965]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:33.965]         }
[16:04:33.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:33.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:33.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:33.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:33.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:33.965]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:33.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:33.965]             base::names(...future.oldOptions))
[16:04:33.965]     }
[16:04:33.965]     if (FALSE) {
[16:04:33.965]     }
[16:04:33.965]     else {
[16:04:33.965]         if (TRUE) {
[16:04:33.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:33.965]                 open = "w")
[16:04:33.965]         }
[16:04:33.965]         else {
[16:04:33.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:33.965]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:33.965]         }
[16:04:33.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:33.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:33.965]             base::sink(type = "output", split = FALSE)
[16:04:33.965]             base::close(...future.stdout)
[16:04:33.965]         }, add = TRUE)
[16:04:33.965]     }
[16:04:33.965]     ...future.frame <- base::sys.nframe()
[16:04:33.965]     ...future.conditions <- base::list()
[16:04:33.965]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:33.965]     if (FALSE) {
[16:04:33.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:33.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:33.965]     }
[16:04:33.965]     ...future.result <- base::tryCatch({
[16:04:33.965]         base::withCallingHandlers({
[16:04:33.965]             ...future.value <- base::withVisible(base::local({
[16:04:33.965]                 4
[16:04:33.965]             }))
[16:04:33.965]             future::FutureResult(value = ...future.value$value, 
[16:04:33.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.965]                   ...future.rng), globalenv = if (FALSE) 
[16:04:33.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:33.965]                     ...future.globalenv.names))
[16:04:33.965]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:33.965]         }, condition = base::local({
[16:04:33.965]             c <- base::c
[16:04:33.965]             inherits <- base::inherits
[16:04:33.965]             invokeRestart <- base::invokeRestart
[16:04:33.965]             length <- base::length
[16:04:33.965]             list <- base::list
[16:04:33.965]             seq.int <- base::seq.int
[16:04:33.965]             signalCondition <- base::signalCondition
[16:04:33.965]             sys.calls <- base::sys.calls
[16:04:33.965]             `[[` <- base::`[[`
[16:04:33.965]             `+` <- base::`+`
[16:04:33.965]             `<<-` <- base::`<<-`
[16:04:33.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:33.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:33.965]                   3L)]
[16:04:33.965]             }
[16:04:33.965]             function(cond) {
[16:04:33.965]                 is_error <- inherits(cond, "error")
[16:04:33.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:33.965]                   NULL)
[16:04:33.965]                 if (is_error) {
[16:04:33.965]                   sessionInformation <- function() {
[16:04:33.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:33.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:33.965]                       search = base::search(), system = base::Sys.info())
[16:04:33.965]                   }
[16:04:33.965]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:33.965]                     cond$call), session = sessionInformation(), 
[16:04:33.965]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:33.965]                   signalCondition(cond)
[16:04:33.965]                 }
[16:04:33.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:33.965]                 "immediateCondition"))) {
[16:04:33.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:33.965]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:33.965]                   if (TRUE && !signal) {
[16:04:33.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.965]                     {
[16:04:33.965]                       inherits <- base::inherits
[16:04:33.965]                       invokeRestart <- base::invokeRestart
[16:04:33.965]                       is.null <- base::is.null
[16:04:33.965]                       muffled <- FALSE
[16:04:33.965]                       if (inherits(cond, "message")) {
[16:04:33.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.965]                         if (muffled) 
[16:04:33.965]                           invokeRestart("muffleMessage")
[16:04:33.965]                       }
[16:04:33.965]                       else if (inherits(cond, "warning")) {
[16:04:33.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.965]                         if (muffled) 
[16:04:33.965]                           invokeRestart("muffleWarning")
[16:04:33.965]                       }
[16:04:33.965]                       else if (inherits(cond, "condition")) {
[16:04:33.965]                         if (!is.null(pattern)) {
[16:04:33.965]                           computeRestarts <- base::computeRestarts
[16:04:33.965]                           grepl <- base::grepl
[16:04:33.965]                           restarts <- computeRestarts(cond)
[16:04:33.965]                           for (restart in restarts) {
[16:04:33.965]                             name <- restart$name
[16:04:33.965]                             if (is.null(name)) 
[16:04:33.965]                               next
[16:04:33.965]                             if (!grepl(pattern, name)) 
[16:04:33.965]                               next
[16:04:33.965]                             invokeRestart(restart)
[16:04:33.965]                             muffled <- TRUE
[16:04:33.965]                             break
[16:04:33.965]                           }
[16:04:33.965]                         }
[16:04:33.965]                       }
[16:04:33.965]                       invisible(muffled)
[16:04:33.965]                     }
[16:04:33.965]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.965]                   }
[16:04:33.965]                 }
[16:04:33.965]                 else {
[16:04:33.965]                   if (TRUE) {
[16:04:33.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.965]                     {
[16:04:33.965]                       inherits <- base::inherits
[16:04:33.965]                       invokeRestart <- base::invokeRestart
[16:04:33.965]                       is.null <- base::is.null
[16:04:33.965]                       muffled <- FALSE
[16:04:33.965]                       if (inherits(cond, "message")) {
[16:04:33.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.965]                         if (muffled) 
[16:04:33.965]                           invokeRestart("muffleMessage")
[16:04:33.965]                       }
[16:04:33.965]                       else if (inherits(cond, "warning")) {
[16:04:33.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.965]                         if (muffled) 
[16:04:33.965]                           invokeRestart("muffleWarning")
[16:04:33.965]                       }
[16:04:33.965]                       else if (inherits(cond, "condition")) {
[16:04:33.965]                         if (!is.null(pattern)) {
[16:04:33.965]                           computeRestarts <- base::computeRestarts
[16:04:33.965]                           grepl <- base::grepl
[16:04:33.965]                           restarts <- computeRestarts(cond)
[16:04:33.965]                           for (restart in restarts) {
[16:04:33.965]                             name <- restart$name
[16:04:33.965]                             if (is.null(name)) 
[16:04:33.965]                               next
[16:04:33.965]                             if (!grepl(pattern, name)) 
[16:04:33.965]                               next
[16:04:33.965]                             invokeRestart(restart)
[16:04:33.965]                             muffled <- TRUE
[16:04:33.965]                             break
[16:04:33.965]                           }
[16:04:33.965]                         }
[16:04:33.965]                       }
[16:04:33.965]                       invisible(muffled)
[16:04:33.965]                     }
[16:04:33.965]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.965]                   }
[16:04:33.965]                 }
[16:04:33.965]             }
[16:04:33.965]         }))
[16:04:33.965]     }, error = function(ex) {
[16:04:33.965]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:33.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.965]                 ...future.rng), started = ...future.startTime, 
[16:04:33.965]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:33.965]             version = "1.8"), class = "FutureResult")
[16:04:33.965]     }, finally = {
[16:04:33.965]         if (!identical(...future.workdir, getwd())) 
[16:04:33.965]             setwd(...future.workdir)
[16:04:33.965]         {
[16:04:33.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:33.965]                 ...future.oldOptions$nwarnings <- NULL
[16:04:33.965]             }
[16:04:33.965]             base::options(...future.oldOptions)
[16:04:33.965]             if (.Platform$OS.type == "windows") {
[16:04:33.965]                 old_names <- names(...future.oldEnvVars)
[16:04:33.965]                 envs <- base::Sys.getenv()
[16:04:33.965]                 names <- names(envs)
[16:04:33.965]                 common <- intersect(names, old_names)
[16:04:33.965]                 added <- setdiff(names, old_names)
[16:04:33.965]                 removed <- setdiff(old_names, names)
[16:04:33.965]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:33.965]                   envs[common]]
[16:04:33.965]                 NAMES <- toupper(changed)
[16:04:33.965]                 args <- list()
[16:04:33.965]                 for (kk in seq_along(NAMES)) {
[16:04:33.965]                   name <- changed[[kk]]
[16:04:33.965]                   NAME <- NAMES[[kk]]
[16:04:33.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.965]                     next
[16:04:33.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.965]                 }
[16:04:33.965]                 NAMES <- toupper(added)
[16:04:33.965]                 for (kk in seq_along(NAMES)) {
[16:04:33.965]                   name <- added[[kk]]
[16:04:33.965]                   NAME <- NAMES[[kk]]
[16:04:33.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.965]                     next
[16:04:33.965]                   args[[name]] <- ""
[16:04:33.965]                 }
[16:04:33.965]                 NAMES <- toupper(removed)
[16:04:33.965]                 for (kk in seq_along(NAMES)) {
[16:04:33.965]                   name <- removed[[kk]]
[16:04:33.965]                   NAME <- NAMES[[kk]]
[16:04:33.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.965]                     next
[16:04:33.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.965]                 }
[16:04:33.965]                 if (length(args) > 0) 
[16:04:33.965]                   base::do.call(base::Sys.setenv, args = args)
[16:04:33.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:33.965]             }
[16:04:33.965]             else {
[16:04:33.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:33.965]             }
[16:04:33.965]             {
[16:04:33.965]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:33.965]                   0L) {
[16:04:33.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:33.965]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:33.965]                   base::options(opts)
[16:04:33.965]                 }
[16:04:33.965]                 {
[16:04:33.965]                   {
[16:04:33.965]                     NULL
[16:04:33.965]                     RNGkind("Mersenne-Twister")
[16:04:33.965]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:33.965]                       inherits = FALSE)
[16:04:33.965]                   }
[16:04:33.965]                   options(future.plan = NULL)
[16:04:33.965]                   if (is.na(NA_character_)) 
[16:04:33.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:33.965]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:33.965]                   {
[16:04:33.965]                     future <- SequentialFuture(..., envir = envir)
[16:04:33.965]                     if (!future$lazy) 
[16:04:33.965]                       future <- run(future)
[16:04:33.965]                     invisible(future)
[16:04:33.965]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:33.965]                 }
[16:04:33.965]             }
[16:04:33.965]         }
[16:04:33.965]     })
[16:04:33.965]     if (TRUE) {
[16:04:33.965]         base::sink(type = "output", split = FALSE)
[16:04:33.965]         if (TRUE) {
[16:04:33.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:33.965]         }
[16:04:33.965]         else {
[16:04:33.965]             ...future.result["stdout"] <- base::list(NULL)
[16:04:33.965]         }
[16:04:33.965]         base::close(...future.stdout)
[16:04:33.965]         ...future.stdout <- NULL
[16:04:33.965]     }
[16:04:33.965]     ...future.result$conditions <- ...future.conditions
[16:04:33.965]     ...future.result$finished <- base::Sys.time()
[16:04:33.965]     ...future.result
[16:04:33.965] }
[16:04:33.967] plan(): Setting new future strategy stack:
[16:04:33.967] List of future strategies:
[16:04:33.967] 1. sequential:
[16:04:33.967]    - args: function (..., envir = parent.frame())
[16:04:33.967]    - tweaked: FALSE
[16:04:33.967]    - call: NULL
[16:04:33.967] plan(): nbrOfWorkers() = 1
[16:04:33.968] plan(): Setting new future strategy stack:
[16:04:33.968] List of future strategies:
[16:04:33.968] 1. sequential:
[16:04:33.968]    - args: function (..., envir = parent.frame())
[16:04:33.968]    - tweaked: FALSE
[16:04:33.968]    - call: plan(strategy)
[16:04:33.968] plan(): nbrOfWorkers() = 1
[16:04:33.968] SequentialFuture started (and completed)
[16:04:33.968] - Launch lazy future ... done
[16:04:33.968] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[16:04:33.969] getGlobalsAndPackages() ...
[16:04:33.969] Searching for globals...
[16:04:33.970] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:33.970] Searching for globals ... DONE
[16:04:33.970] Resolving globals: FALSE
[16:04:33.971] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:33.971] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:33.971] - globals: [1] ‘a’
[16:04:33.971] 
[16:04:33.971] getGlobalsAndPackages() ... DONE
[16:04:33.971] run() for ‘Future’ ...
[16:04:33.972] - state: ‘created’
[16:04:33.972] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.972] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.972]   - Field: ‘label’
[16:04:33.972]   - Field: ‘local’
[16:04:33.972]   - Field: ‘owner’
[16:04:33.972]   - Field: ‘envir’
[16:04:33.972]   - Field: ‘packages’
[16:04:33.973]   - Field: ‘gc’
[16:04:33.973]   - Field: ‘conditions’
[16:04:33.973]   - Field: ‘expr’
[16:04:33.973]   - Field: ‘uuid’
[16:04:33.973]   - Field: ‘seed’
[16:04:33.973]   - Field: ‘version’
[16:04:33.973]   - Field: ‘result’
[16:04:33.973]   - Field: ‘asynchronous’
[16:04:33.973]   - Field: ‘calls’
[16:04:33.973]   - Field: ‘globals’
[16:04:33.973]   - Field: ‘stdout’
[16:04:33.974]   - Field: ‘earlySignal’
[16:04:33.974]   - Field: ‘lazy’
[16:04:33.974]   - Field: ‘state’
[16:04:33.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:33.974] - Launch lazy future ...
[16:04:33.974] Packages needed by the future expression (n = 0): <none>
[16:04:33.974] Packages needed by future strategies (n = 0): <none>
[16:04:33.975] {
[16:04:33.975]     {
[16:04:33.975]         {
[16:04:33.975]             ...future.startTime <- base::Sys.time()
[16:04:33.975]             {
[16:04:33.975]                 {
[16:04:33.975]                   {
[16:04:33.975]                     base::local({
[16:04:33.975]                       has_future <- base::requireNamespace("future", 
[16:04:33.975]                         quietly = TRUE)
[16:04:33.975]                       if (has_future) {
[16:04:33.975]                         ns <- base::getNamespace("future")
[16:04:33.975]                         version <- ns[[".package"]][["version"]]
[16:04:33.975]                         if (is.null(version)) 
[16:04:33.975]                           version <- utils::packageVersion("future")
[16:04:33.975]                       }
[16:04:33.975]                       else {
[16:04:33.975]                         version <- NULL
[16:04:33.975]                       }
[16:04:33.975]                       if (!has_future || version < "1.8.0") {
[16:04:33.975]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:33.975]                           "", base::R.version$version.string), 
[16:04:33.975]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:33.975]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:33.975]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:33.975]                             "release", "version")], collapse = " "), 
[16:04:33.975]                           hostname = base::Sys.info()[["nodename"]])
[16:04:33.975]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:33.975]                           info)
[16:04:33.975]                         info <- base::paste(info, collapse = "; ")
[16:04:33.975]                         if (!has_future) {
[16:04:33.975]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:33.975]                             info)
[16:04:33.975]                         }
[16:04:33.975]                         else {
[16:04:33.975]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:33.975]                             info, version)
[16:04:33.975]                         }
[16:04:33.975]                         base::stop(msg)
[16:04:33.975]                       }
[16:04:33.975]                     })
[16:04:33.975]                   }
[16:04:33.975]                   options(future.plan = NULL)
[16:04:33.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:33.975]                 }
[16:04:33.975]                 ...future.workdir <- getwd()
[16:04:33.975]             }
[16:04:33.975]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:33.975]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:33.975]         }
[16:04:33.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:33.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:33.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:33.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:33.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:33.975]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:33.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:33.975]             base::names(...future.oldOptions))
[16:04:33.975]     }
[16:04:33.975]     if (FALSE) {
[16:04:33.975]     }
[16:04:33.975]     else {
[16:04:33.975]         if (TRUE) {
[16:04:33.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:33.975]                 open = "w")
[16:04:33.975]         }
[16:04:33.975]         else {
[16:04:33.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:33.975]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:33.975]         }
[16:04:33.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:33.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:33.975]             base::sink(type = "output", split = FALSE)
[16:04:33.975]             base::close(...future.stdout)
[16:04:33.975]         }, add = TRUE)
[16:04:33.975]     }
[16:04:33.975]     ...future.frame <- base::sys.nframe()
[16:04:33.975]     ...future.conditions <- base::list()
[16:04:33.975]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:33.975]     if (FALSE) {
[16:04:33.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:33.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:33.975]     }
[16:04:33.975]     ...future.result <- base::tryCatch({
[16:04:33.975]         base::withCallingHandlers({
[16:04:33.975]             ...future.value <- base::withVisible(base::local({
[16:04:33.975]                 2 * a
[16:04:33.975]             }))
[16:04:33.975]             future::FutureResult(value = ...future.value$value, 
[16:04:33.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.975]                   ...future.rng), globalenv = if (FALSE) 
[16:04:33.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:33.975]                     ...future.globalenv.names))
[16:04:33.975]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:33.975]         }, condition = base::local({
[16:04:33.975]             c <- base::c
[16:04:33.975]             inherits <- base::inherits
[16:04:33.975]             invokeRestart <- base::invokeRestart
[16:04:33.975]             length <- base::length
[16:04:33.975]             list <- base::list
[16:04:33.975]             seq.int <- base::seq.int
[16:04:33.975]             signalCondition <- base::signalCondition
[16:04:33.975]             sys.calls <- base::sys.calls
[16:04:33.975]             `[[` <- base::`[[`
[16:04:33.975]             `+` <- base::`+`
[16:04:33.975]             `<<-` <- base::`<<-`
[16:04:33.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:33.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:33.975]                   3L)]
[16:04:33.975]             }
[16:04:33.975]             function(cond) {
[16:04:33.975]                 is_error <- inherits(cond, "error")
[16:04:33.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:33.975]                   NULL)
[16:04:33.975]                 if (is_error) {
[16:04:33.975]                   sessionInformation <- function() {
[16:04:33.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:33.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:33.975]                       search = base::search(), system = base::Sys.info())
[16:04:33.975]                   }
[16:04:33.975]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:33.975]                     cond$call), session = sessionInformation(), 
[16:04:33.975]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:33.975]                   signalCondition(cond)
[16:04:33.975]                 }
[16:04:33.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:33.975]                 "immediateCondition"))) {
[16:04:33.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:33.975]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:33.975]                   if (TRUE && !signal) {
[16:04:33.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.975]                     {
[16:04:33.975]                       inherits <- base::inherits
[16:04:33.975]                       invokeRestart <- base::invokeRestart
[16:04:33.975]                       is.null <- base::is.null
[16:04:33.975]                       muffled <- FALSE
[16:04:33.975]                       if (inherits(cond, "message")) {
[16:04:33.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.975]                         if (muffled) 
[16:04:33.975]                           invokeRestart("muffleMessage")
[16:04:33.975]                       }
[16:04:33.975]                       else if (inherits(cond, "warning")) {
[16:04:33.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.975]                         if (muffled) 
[16:04:33.975]                           invokeRestart("muffleWarning")
[16:04:33.975]                       }
[16:04:33.975]                       else if (inherits(cond, "condition")) {
[16:04:33.975]                         if (!is.null(pattern)) {
[16:04:33.975]                           computeRestarts <- base::computeRestarts
[16:04:33.975]                           grepl <- base::grepl
[16:04:33.975]                           restarts <- computeRestarts(cond)
[16:04:33.975]                           for (restart in restarts) {
[16:04:33.975]                             name <- restart$name
[16:04:33.975]                             if (is.null(name)) 
[16:04:33.975]                               next
[16:04:33.975]                             if (!grepl(pattern, name)) 
[16:04:33.975]                               next
[16:04:33.975]                             invokeRestart(restart)
[16:04:33.975]                             muffled <- TRUE
[16:04:33.975]                             break
[16:04:33.975]                           }
[16:04:33.975]                         }
[16:04:33.975]                       }
[16:04:33.975]                       invisible(muffled)
[16:04:33.975]                     }
[16:04:33.975]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.975]                   }
[16:04:33.975]                 }
[16:04:33.975]                 else {
[16:04:33.975]                   if (TRUE) {
[16:04:33.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.975]                     {
[16:04:33.975]                       inherits <- base::inherits
[16:04:33.975]                       invokeRestart <- base::invokeRestart
[16:04:33.975]                       is.null <- base::is.null
[16:04:33.975]                       muffled <- FALSE
[16:04:33.975]                       if (inherits(cond, "message")) {
[16:04:33.975]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.975]                         if (muffled) 
[16:04:33.975]                           invokeRestart("muffleMessage")
[16:04:33.975]                       }
[16:04:33.975]                       else if (inherits(cond, "warning")) {
[16:04:33.975]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.975]                         if (muffled) 
[16:04:33.975]                           invokeRestart("muffleWarning")
[16:04:33.975]                       }
[16:04:33.975]                       else if (inherits(cond, "condition")) {
[16:04:33.975]                         if (!is.null(pattern)) {
[16:04:33.975]                           computeRestarts <- base::computeRestarts
[16:04:33.975]                           grepl <- base::grepl
[16:04:33.975]                           restarts <- computeRestarts(cond)
[16:04:33.975]                           for (restart in restarts) {
[16:04:33.975]                             name <- restart$name
[16:04:33.975]                             if (is.null(name)) 
[16:04:33.975]                               next
[16:04:33.975]                             if (!grepl(pattern, name)) 
[16:04:33.975]                               next
[16:04:33.975]                             invokeRestart(restart)
[16:04:33.975]                             muffled <- TRUE
[16:04:33.975]                             break
[16:04:33.975]                           }
[16:04:33.975]                         }
[16:04:33.975]                       }
[16:04:33.975]                       invisible(muffled)
[16:04:33.975]                     }
[16:04:33.975]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.975]                   }
[16:04:33.975]                 }
[16:04:33.975]             }
[16:04:33.975]         }))
[16:04:33.975]     }, error = function(ex) {
[16:04:33.975]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:33.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.975]                 ...future.rng), started = ...future.startTime, 
[16:04:33.975]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:33.975]             version = "1.8"), class = "FutureResult")
[16:04:33.975]     }, finally = {
[16:04:33.975]         if (!identical(...future.workdir, getwd())) 
[16:04:33.975]             setwd(...future.workdir)
[16:04:33.975]         {
[16:04:33.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:33.975]                 ...future.oldOptions$nwarnings <- NULL
[16:04:33.975]             }
[16:04:33.975]             base::options(...future.oldOptions)
[16:04:33.975]             if (.Platform$OS.type == "windows") {
[16:04:33.975]                 old_names <- names(...future.oldEnvVars)
[16:04:33.975]                 envs <- base::Sys.getenv()
[16:04:33.975]                 names <- names(envs)
[16:04:33.975]                 common <- intersect(names, old_names)
[16:04:33.975]                 added <- setdiff(names, old_names)
[16:04:33.975]                 removed <- setdiff(old_names, names)
[16:04:33.975]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:33.975]                   envs[common]]
[16:04:33.975]                 NAMES <- toupper(changed)
[16:04:33.975]                 args <- list()
[16:04:33.975]                 for (kk in seq_along(NAMES)) {
[16:04:33.975]                   name <- changed[[kk]]
[16:04:33.975]                   NAME <- NAMES[[kk]]
[16:04:33.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.975]                     next
[16:04:33.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.975]                 }
[16:04:33.975]                 NAMES <- toupper(added)
[16:04:33.975]                 for (kk in seq_along(NAMES)) {
[16:04:33.975]                   name <- added[[kk]]
[16:04:33.975]                   NAME <- NAMES[[kk]]
[16:04:33.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.975]                     next
[16:04:33.975]                   args[[name]] <- ""
[16:04:33.975]                 }
[16:04:33.975]                 NAMES <- toupper(removed)
[16:04:33.975]                 for (kk in seq_along(NAMES)) {
[16:04:33.975]                   name <- removed[[kk]]
[16:04:33.975]                   NAME <- NAMES[[kk]]
[16:04:33.975]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.975]                     next
[16:04:33.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.975]                 }
[16:04:33.975]                 if (length(args) > 0) 
[16:04:33.975]                   base::do.call(base::Sys.setenv, args = args)
[16:04:33.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:33.975]             }
[16:04:33.975]             else {
[16:04:33.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:33.975]             }
[16:04:33.975]             {
[16:04:33.975]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:33.975]                   0L) {
[16:04:33.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:33.975]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:33.975]                   base::options(opts)
[16:04:33.975]                 }
[16:04:33.975]                 {
[16:04:33.975]                   {
[16:04:33.975]                     NULL
[16:04:33.975]                     RNGkind("Mersenne-Twister")
[16:04:33.975]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:33.975]                       inherits = FALSE)
[16:04:33.975]                   }
[16:04:33.975]                   options(future.plan = NULL)
[16:04:33.975]                   if (is.na(NA_character_)) 
[16:04:33.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:33.975]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:33.975]                   {
[16:04:33.975]                     future <- SequentialFuture(..., envir = envir)
[16:04:33.975]                     if (!future$lazy) 
[16:04:33.975]                       future <- run(future)
[16:04:33.975]                     invisible(future)
[16:04:33.975]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:33.975]                 }
[16:04:33.975]             }
[16:04:33.975]         }
[16:04:33.975]     })
[16:04:33.975]     if (TRUE) {
[16:04:33.975]         base::sink(type = "output", split = FALSE)
[16:04:33.975]         if (TRUE) {
[16:04:33.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:33.975]         }
[16:04:33.975]         else {
[16:04:33.975]             ...future.result["stdout"] <- base::list(NULL)
[16:04:33.975]         }
[16:04:33.975]         base::close(...future.stdout)
[16:04:33.975]         ...future.stdout <- NULL
[16:04:33.975]     }
[16:04:33.975]     ...future.result$conditions <- ...future.conditions
[16:04:33.975]     ...future.result$finished <- base::Sys.time()
[16:04:33.975]     ...future.result
[16:04:33.975] }
[16:04:33.976] assign_globals() ...
[16:04:33.976] List of 1
[16:04:33.976]  $ a: num 1
[16:04:33.976]  - attr(*, "where")=List of 1
[16:04:33.976]   ..$ a:<environment: R_EmptyEnv> 
[16:04:33.976]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:33.976]  - attr(*, "resolved")= logi FALSE
[16:04:33.976]  - attr(*, "total_size")= num 56
[16:04:33.976]  - attr(*, "already-done")= logi TRUE
[16:04:33.982] - copied ‘a’ to environment
[16:04:33.982] assign_globals() ... done
[16:04:33.982] plan(): Setting new future strategy stack:
[16:04:33.982] List of future strategies:
[16:04:33.982] 1. sequential:
[16:04:33.982]    - args: function (..., envir = parent.frame())
[16:04:33.982]    - tweaked: FALSE
[16:04:33.982]    - call: NULL
[16:04:33.983] plan(): nbrOfWorkers() = 1
[16:04:33.983] plan(): Setting new future strategy stack:
[16:04:33.984] List of future strategies:
[16:04:33.984] 1. sequential:
[16:04:33.984]    - args: function (..., envir = parent.frame())
[16:04:33.984]    - tweaked: FALSE
[16:04:33.984]    - call: plan(strategy)
[16:04:33.984] plan(): nbrOfWorkers() = 1
[16:04:33.984] SequentialFuture started (and completed)
[16:04:33.984] - Launch lazy future ... done
[16:04:33.984] run() for ‘SequentialFuture’ ... done
[16:04:33.985] getGlobalsAndPackages() ...
[16:04:33.985] Searching for globals...
[16:04:33.985] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:33.985] Searching for globals ... DONE
[16:04:33.986] Resolving globals: FALSE
[16:04:33.986] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:33.986] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:33.986] - globals: [1] ‘a’
[16:04:33.986] 
[16:04:33.986] getGlobalsAndPackages() ... DONE
[16:04:33.987] run() for ‘Future’ ...
[16:04:33.987] - state: ‘created’
[16:04:33.987] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.987]   - Field: ‘label’
[16:04:33.987]   - Field: ‘local’
[16:04:33.988]   - Field: ‘owner’
[16:04:33.988]   - Field: ‘envir’
[16:04:33.988]   - Field: ‘packages’
[16:04:33.988]   - Field: ‘gc’
[16:04:33.988]   - Field: ‘conditions’
[16:04:33.988]   - Field: ‘expr’
[16:04:33.988]   - Field: ‘uuid’
[16:04:33.988]   - Field: ‘seed’
[16:04:33.988]   - Field: ‘version’
[16:04:33.988]   - Field: ‘result’
[16:04:33.988]   - Field: ‘asynchronous’
[16:04:33.989]   - Field: ‘calls’
[16:04:33.989]   - Field: ‘globals’
[16:04:33.989]   - Field: ‘stdout’
[16:04:33.989]   - Field: ‘earlySignal’
[16:04:33.989]   - Field: ‘lazy’
[16:04:33.989]   - Field: ‘state’
[16:04:33.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:33.989] - Launch lazy future ...
[16:04:33.989] Packages needed by the future expression (n = 0): <none>
[16:04:33.989] Packages needed by future strategies (n = 0): <none>
[16:04:33.990] {
[16:04:33.990]     {
[16:04:33.990]         {
[16:04:33.990]             ...future.startTime <- base::Sys.time()
[16:04:33.990]             {
[16:04:33.990]                 {
[16:04:33.990]                   {
[16:04:33.990]                     base::local({
[16:04:33.990]                       has_future <- base::requireNamespace("future", 
[16:04:33.990]                         quietly = TRUE)
[16:04:33.990]                       if (has_future) {
[16:04:33.990]                         ns <- base::getNamespace("future")
[16:04:33.990]                         version <- ns[[".package"]][["version"]]
[16:04:33.990]                         if (is.null(version)) 
[16:04:33.990]                           version <- utils::packageVersion("future")
[16:04:33.990]                       }
[16:04:33.990]                       else {
[16:04:33.990]                         version <- NULL
[16:04:33.990]                       }
[16:04:33.990]                       if (!has_future || version < "1.8.0") {
[16:04:33.990]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:33.990]                           "", base::R.version$version.string), 
[16:04:33.990]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:33.990]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:33.990]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:33.990]                             "release", "version")], collapse = " "), 
[16:04:33.990]                           hostname = base::Sys.info()[["nodename"]])
[16:04:33.990]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:33.990]                           info)
[16:04:33.990]                         info <- base::paste(info, collapse = "; ")
[16:04:33.990]                         if (!has_future) {
[16:04:33.990]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:33.990]                             info)
[16:04:33.990]                         }
[16:04:33.990]                         else {
[16:04:33.990]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:33.990]                             info, version)
[16:04:33.990]                         }
[16:04:33.990]                         base::stop(msg)
[16:04:33.990]                       }
[16:04:33.990]                     })
[16:04:33.990]                   }
[16:04:33.990]                   options(future.plan = NULL)
[16:04:33.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:33.990]                 }
[16:04:33.990]                 ...future.workdir <- getwd()
[16:04:33.990]             }
[16:04:33.990]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:33.990]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:33.990]         }
[16:04:33.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:33.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:33.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:33.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:33.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:33.990]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:33.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:33.990]             base::names(...future.oldOptions))
[16:04:33.990]     }
[16:04:33.990]     if (FALSE) {
[16:04:33.990]     }
[16:04:33.990]     else {
[16:04:33.990]         if (TRUE) {
[16:04:33.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:33.990]                 open = "w")
[16:04:33.990]         }
[16:04:33.990]         else {
[16:04:33.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:33.990]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:33.990]         }
[16:04:33.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:33.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:33.990]             base::sink(type = "output", split = FALSE)
[16:04:33.990]             base::close(...future.stdout)
[16:04:33.990]         }, add = TRUE)
[16:04:33.990]     }
[16:04:33.990]     ...future.frame <- base::sys.nframe()
[16:04:33.990]     ...future.conditions <- base::list()
[16:04:33.990]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:33.990]     if (FALSE) {
[16:04:33.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:33.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:33.990]     }
[16:04:33.990]     ...future.result <- base::tryCatch({
[16:04:33.990]         base::withCallingHandlers({
[16:04:33.990]             ...future.value <- base::withVisible(base::local({
[16:04:33.990]                 2 * a
[16:04:33.990]             }))
[16:04:33.990]             future::FutureResult(value = ...future.value$value, 
[16:04:33.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.990]                   ...future.rng), globalenv = if (FALSE) 
[16:04:33.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:33.990]                     ...future.globalenv.names))
[16:04:33.990]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:33.990]         }, condition = base::local({
[16:04:33.990]             c <- base::c
[16:04:33.990]             inherits <- base::inherits
[16:04:33.990]             invokeRestart <- base::invokeRestart
[16:04:33.990]             length <- base::length
[16:04:33.990]             list <- base::list
[16:04:33.990]             seq.int <- base::seq.int
[16:04:33.990]             signalCondition <- base::signalCondition
[16:04:33.990]             sys.calls <- base::sys.calls
[16:04:33.990]             `[[` <- base::`[[`
[16:04:33.990]             `+` <- base::`+`
[16:04:33.990]             `<<-` <- base::`<<-`
[16:04:33.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:33.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:33.990]                   3L)]
[16:04:33.990]             }
[16:04:33.990]             function(cond) {
[16:04:33.990]                 is_error <- inherits(cond, "error")
[16:04:33.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:33.990]                   NULL)
[16:04:33.990]                 if (is_error) {
[16:04:33.990]                   sessionInformation <- function() {
[16:04:33.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:33.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:33.990]                       search = base::search(), system = base::Sys.info())
[16:04:33.990]                   }
[16:04:33.990]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:33.990]                     cond$call), session = sessionInformation(), 
[16:04:33.990]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:33.990]                   signalCondition(cond)
[16:04:33.990]                 }
[16:04:33.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:33.990]                 "immediateCondition"))) {
[16:04:33.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:33.990]                   ...future.conditions[[length(...future.conditions) + 
[16:04:33.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:33.990]                   if (TRUE && !signal) {
[16:04:33.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.990]                     {
[16:04:33.990]                       inherits <- base::inherits
[16:04:33.990]                       invokeRestart <- base::invokeRestart
[16:04:33.990]                       is.null <- base::is.null
[16:04:33.990]                       muffled <- FALSE
[16:04:33.990]                       if (inherits(cond, "message")) {
[16:04:33.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.990]                         if (muffled) 
[16:04:33.990]                           invokeRestart("muffleMessage")
[16:04:33.990]                       }
[16:04:33.990]                       else if (inherits(cond, "warning")) {
[16:04:33.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.990]                         if (muffled) 
[16:04:33.990]                           invokeRestart("muffleWarning")
[16:04:33.990]                       }
[16:04:33.990]                       else if (inherits(cond, "condition")) {
[16:04:33.990]                         if (!is.null(pattern)) {
[16:04:33.990]                           computeRestarts <- base::computeRestarts
[16:04:33.990]                           grepl <- base::grepl
[16:04:33.990]                           restarts <- computeRestarts(cond)
[16:04:33.990]                           for (restart in restarts) {
[16:04:33.990]                             name <- restart$name
[16:04:33.990]                             if (is.null(name)) 
[16:04:33.990]                               next
[16:04:33.990]                             if (!grepl(pattern, name)) 
[16:04:33.990]                               next
[16:04:33.990]                             invokeRestart(restart)
[16:04:33.990]                             muffled <- TRUE
[16:04:33.990]                             break
[16:04:33.990]                           }
[16:04:33.990]                         }
[16:04:33.990]                       }
[16:04:33.990]                       invisible(muffled)
[16:04:33.990]                     }
[16:04:33.990]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.990]                   }
[16:04:33.990]                 }
[16:04:33.990]                 else {
[16:04:33.990]                   if (TRUE) {
[16:04:33.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:33.990]                     {
[16:04:33.990]                       inherits <- base::inherits
[16:04:33.990]                       invokeRestart <- base::invokeRestart
[16:04:33.990]                       is.null <- base::is.null
[16:04:33.990]                       muffled <- FALSE
[16:04:33.990]                       if (inherits(cond, "message")) {
[16:04:33.990]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:33.990]                         if (muffled) 
[16:04:33.990]                           invokeRestart("muffleMessage")
[16:04:33.990]                       }
[16:04:33.990]                       else if (inherits(cond, "warning")) {
[16:04:33.990]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:33.990]                         if (muffled) 
[16:04:33.990]                           invokeRestart("muffleWarning")
[16:04:33.990]                       }
[16:04:33.990]                       else if (inherits(cond, "condition")) {
[16:04:33.990]                         if (!is.null(pattern)) {
[16:04:33.990]                           computeRestarts <- base::computeRestarts
[16:04:33.990]                           grepl <- base::grepl
[16:04:33.990]                           restarts <- computeRestarts(cond)
[16:04:33.990]                           for (restart in restarts) {
[16:04:33.990]                             name <- restart$name
[16:04:33.990]                             if (is.null(name)) 
[16:04:33.990]                               next
[16:04:33.990]                             if (!grepl(pattern, name)) 
[16:04:33.990]                               next
[16:04:33.990]                             invokeRestart(restart)
[16:04:33.990]                             muffled <- TRUE
[16:04:33.990]                             break
[16:04:33.990]                           }
[16:04:33.990]                         }
[16:04:33.990]                       }
[16:04:33.990]                       invisible(muffled)
[16:04:33.990]                     }
[16:04:33.990]                     muffleCondition(cond, pattern = "^muffle")
[16:04:33.990]                   }
[16:04:33.990]                 }
[16:04:33.990]             }
[16:04:33.990]         }))
[16:04:33.990]     }, error = function(ex) {
[16:04:33.990]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:33.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:33.990]                 ...future.rng), started = ...future.startTime, 
[16:04:33.990]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:33.990]             version = "1.8"), class = "FutureResult")
[16:04:33.990]     }, finally = {
[16:04:33.990]         if (!identical(...future.workdir, getwd())) 
[16:04:33.990]             setwd(...future.workdir)
[16:04:33.990]         {
[16:04:33.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:33.990]                 ...future.oldOptions$nwarnings <- NULL
[16:04:33.990]             }
[16:04:33.990]             base::options(...future.oldOptions)
[16:04:33.990]             if (.Platform$OS.type == "windows") {
[16:04:33.990]                 old_names <- names(...future.oldEnvVars)
[16:04:33.990]                 envs <- base::Sys.getenv()
[16:04:33.990]                 names <- names(envs)
[16:04:33.990]                 common <- intersect(names, old_names)
[16:04:33.990]                 added <- setdiff(names, old_names)
[16:04:33.990]                 removed <- setdiff(old_names, names)
[16:04:33.990]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:33.990]                   envs[common]]
[16:04:33.990]                 NAMES <- toupper(changed)
[16:04:33.990]                 args <- list()
[16:04:33.990]                 for (kk in seq_along(NAMES)) {
[16:04:33.990]                   name <- changed[[kk]]
[16:04:33.990]                   NAME <- NAMES[[kk]]
[16:04:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.990]                     next
[16:04:33.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.990]                 }
[16:04:33.990]                 NAMES <- toupper(added)
[16:04:33.990]                 for (kk in seq_along(NAMES)) {
[16:04:33.990]                   name <- added[[kk]]
[16:04:33.990]                   NAME <- NAMES[[kk]]
[16:04:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.990]                     next
[16:04:33.990]                   args[[name]] <- ""
[16:04:33.990]                 }
[16:04:33.990]                 NAMES <- toupper(removed)
[16:04:33.990]                 for (kk in seq_along(NAMES)) {
[16:04:33.990]                   name <- removed[[kk]]
[16:04:33.990]                   NAME <- NAMES[[kk]]
[16:04:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:33.990]                     next
[16:04:33.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:33.990]                 }
[16:04:33.990]                 if (length(args) > 0) 
[16:04:33.990]                   base::do.call(base::Sys.setenv, args = args)
[16:04:33.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:33.990]             }
[16:04:33.990]             else {
[16:04:33.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:33.990]             }
[16:04:33.990]             {
[16:04:33.990]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:33.990]                   0L) {
[16:04:33.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:33.990]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:33.990]                   base::options(opts)
[16:04:33.990]                 }
[16:04:33.990]                 {
[16:04:33.990]                   {
[16:04:33.990]                     NULL
[16:04:33.990]                     RNGkind("Mersenne-Twister")
[16:04:33.990]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:33.990]                       inherits = FALSE)
[16:04:33.990]                   }
[16:04:33.990]                   options(future.plan = NULL)
[16:04:33.990]                   if (is.na(NA_character_)) 
[16:04:33.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:33.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:33.990]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:33.990]                   {
[16:04:33.990]                     future <- SequentialFuture(..., envir = envir)
[16:04:33.990]                     if (!future$lazy) 
[16:04:33.990]                       future <- run(future)
[16:04:33.990]                     invisible(future)
[16:04:33.990]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:33.990]                 }
[16:04:33.990]             }
[16:04:33.990]         }
[16:04:33.990]     })
[16:04:33.990]     if (TRUE) {
[16:04:33.990]         base::sink(type = "output", split = FALSE)
[16:04:33.990]         if (TRUE) {
[16:04:33.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:33.990]         }
[16:04:33.990]         else {
[16:04:33.990]             ...future.result["stdout"] <- base::list(NULL)
[16:04:33.990]         }
[16:04:33.990]         base::close(...future.stdout)
[16:04:33.990]         ...future.stdout <- NULL
[16:04:33.990]     }
[16:04:33.990]     ...future.result$conditions <- ...future.conditions
[16:04:33.990]     ...future.result$finished <- base::Sys.time()
[16:04:33.990]     ...future.result
[16:04:33.990] }
[16:04:33.991] assign_globals() ...
[16:04:33.991] List of 1
[16:04:33.991]  $ a: num 1
[16:04:33.991]  - attr(*, "where")=List of 1
[16:04:33.991]   ..$ a:<environment: R_EmptyEnv> 
[16:04:33.991]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:33.991]  - attr(*, "resolved")= logi FALSE
[16:04:33.991]  - attr(*, "total_size")= num 56
[16:04:33.991]  - attr(*, "already-done")= logi TRUE
[16:04:33.994] - copied ‘a’ to environment
[16:04:33.994] assign_globals() ... done
[16:04:33.994] plan(): Setting new future strategy stack:
[16:04:33.994] List of future strategies:
[16:04:33.994] 1. sequential:
[16:04:33.994]    - args: function (..., envir = parent.frame())
[16:04:33.994]    - tweaked: FALSE
[16:04:33.994]    - call: NULL
[16:04:33.994] plan(): nbrOfWorkers() = 1
[16:04:33.995] plan(): Setting new future strategy stack:
[16:04:33.995] List of future strategies:
[16:04:33.995] 1. sequential:
[16:04:33.995]    - args: function (..., envir = parent.frame())
[16:04:33.995]    - tweaked: FALSE
[16:04:33.995]    - call: plan(strategy)
[16:04:33.995] plan(): nbrOfWorkers() = 1
[16:04:33.996] SequentialFuture started (and completed)
[16:04:33.996] - Launch lazy future ... done
[16:04:33.996] run() for ‘SequentialFuture’ ... done
[16:04:33.996] getGlobalsAndPackages() ...
[16:04:33.996] Searching for globals...
[16:04:33.997] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:33.997] Searching for globals ... DONE
[16:04:33.997] Resolving globals: FALSE
[16:04:33.997] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:33.998] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:33.998] - globals: [1] ‘a’
[16:04:33.998] 
[16:04:33.998] getGlobalsAndPackages() ... DONE
[16:04:33.998] run() for ‘Future’ ...
[16:04:33.998] - state: ‘created’
[16:04:33.998] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:33.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:33.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:33.999]   - Field: ‘label’
[16:04:33.999]   - Field: ‘local’
[16:04:33.999]   - Field: ‘owner’
[16:04:33.999]   - Field: ‘envir’
[16:04:33.999]   - Field: ‘packages’
[16:04:33.999]   - Field: ‘gc’
[16:04:33.999]   - Field: ‘conditions’
[16:04:34.000]   - Field: ‘expr’
[16:04:34.000]   - Field: ‘uuid’
[16:04:34.000]   - Field: ‘seed’
[16:04:34.000]   - Field: ‘version’
[16:04:34.000]   - Field: ‘result’
[16:04:34.000]   - Field: ‘asynchronous’
[16:04:34.000]   - Field: ‘calls’
[16:04:34.000]   - Field: ‘globals’
[16:04:34.000]   - Field: ‘stdout’
[16:04:34.000]   - Field: ‘earlySignal’
[16:04:34.000]   - Field: ‘lazy’
[16:04:34.000]   - Field: ‘state’
[16:04:34.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:34.001] - Launch lazy future ...
[16:04:34.001] Packages needed by the future expression (n = 0): <none>
[16:04:34.001] Packages needed by future strategies (n = 0): <none>
[16:04:34.001] {
[16:04:34.001]     {
[16:04:34.001]         {
[16:04:34.001]             ...future.startTime <- base::Sys.time()
[16:04:34.001]             {
[16:04:34.001]                 {
[16:04:34.001]                   {
[16:04:34.001]                     base::local({
[16:04:34.001]                       has_future <- base::requireNamespace("future", 
[16:04:34.001]                         quietly = TRUE)
[16:04:34.001]                       if (has_future) {
[16:04:34.001]                         ns <- base::getNamespace("future")
[16:04:34.001]                         version <- ns[[".package"]][["version"]]
[16:04:34.001]                         if (is.null(version)) 
[16:04:34.001]                           version <- utils::packageVersion("future")
[16:04:34.001]                       }
[16:04:34.001]                       else {
[16:04:34.001]                         version <- NULL
[16:04:34.001]                       }
[16:04:34.001]                       if (!has_future || version < "1.8.0") {
[16:04:34.001]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.001]                           "", base::R.version$version.string), 
[16:04:34.001]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:34.001]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.001]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.001]                             "release", "version")], collapse = " "), 
[16:04:34.001]                           hostname = base::Sys.info()[["nodename"]])
[16:04:34.001]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.001]                           info)
[16:04:34.001]                         info <- base::paste(info, collapse = "; ")
[16:04:34.001]                         if (!has_future) {
[16:04:34.001]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.001]                             info)
[16:04:34.001]                         }
[16:04:34.001]                         else {
[16:04:34.001]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.001]                             info, version)
[16:04:34.001]                         }
[16:04:34.001]                         base::stop(msg)
[16:04:34.001]                       }
[16:04:34.001]                     })
[16:04:34.001]                   }
[16:04:34.001]                   options(future.plan = NULL)
[16:04:34.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.001]                 }
[16:04:34.001]                 ...future.workdir <- getwd()
[16:04:34.001]             }
[16:04:34.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.001]         }
[16:04:34.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.001]             base::names(...future.oldOptions))
[16:04:34.001]     }
[16:04:34.001]     if (FALSE) {
[16:04:34.001]     }
[16:04:34.001]     else {
[16:04:34.001]         if (TRUE) {
[16:04:34.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.001]                 open = "w")
[16:04:34.001]         }
[16:04:34.001]         else {
[16:04:34.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.001]         }
[16:04:34.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.001]             base::sink(type = "output", split = FALSE)
[16:04:34.001]             base::close(...future.stdout)
[16:04:34.001]         }, add = TRUE)
[16:04:34.001]     }
[16:04:34.001]     ...future.frame <- base::sys.nframe()
[16:04:34.001]     ...future.conditions <- base::list()
[16:04:34.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.001]     if (FALSE) {
[16:04:34.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.001]     }
[16:04:34.001]     ...future.result <- base::tryCatch({
[16:04:34.001]         base::withCallingHandlers({
[16:04:34.001]             ...future.value <- base::withVisible(base::local({
[16:04:34.001]                 2 * a
[16:04:34.001]             }))
[16:04:34.001]             future::FutureResult(value = ...future.value$value, 
[16:04:34.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.001]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.001]                     ...future.globalenv.names))
[16:04:34.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.001]         }, condition = base::local({
[16:04:34.001]             c <- base::c
[16:04:34.001]             inherits <- base::inherits
[16:04:34.001]             invokeRestart <- base::invokeRestart
[16:04:34.001]             length <- base::length
[16:04:34.001]             list <- base::list
[16:04:34.001]             seq.int <- base::seq.int
[16:04:34.001]             signalCondition <- base::signalCondition
[16:04:34.001]             sys.calls <- base::sys.calls
[16:04:34.001]             `[[` <- base::`[[`
[16:04:34.001]             `+` <- base::`+`
[16:04:34.001]             `<<-` <- base::`<<-`
[16:04:34.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.001]                   3L)]
[16:04:34.001]             }
[16:04:34.001]             function(cond) {
[16:04:34.001]                 is_error <- inherits(cond, "error")
[16:04:34.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.001]                   NULL)
[16:04:34.001]                 if (is_error) {
[16:04:34.001]                   sessionInformation <- function() {
[16:04:34.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.001]                       search = base::search(), system = base::Sys.info())
[16:04:34.001]                   }
[16:04:34.001]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.001]                     cond$call), session = sessionInformation(), 
[16:04:34.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.001]                   signalCondition(cond)
[16:04:34.001]                 }
[16:04:34.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.001]                 "immediateCondition"))) {
[16:04:34.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.001]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.001]                   if (TRUE && !signal) {
[16:04:34.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.001]                     {
[16:04:34.001]                       inherits <- base::inherits
[16:04:34.001]                       invokeRestart <- base::invokeRestart
[16:04:34.001]                       is.null <- base::is.null
[16:04:34.001]                       muffled <- FALSE
[16:04:34.001]                       if (inherits(cond, "message")) {
[16:04:34.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.001]                         if (muffled) 
[16:04:34.001]                           invokeRestart("muffleMessage")
[16:04:34.001]                       }
[16:04:34.001]                       else if (inherits(cond, "warning")) {
[16:04:34.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.001]                         if (muffled) 
[16:04:34.001]                           invokeRestart("muffleWarning")
[16:04:34.001]                       }
[16:04:34.001]                       else if (inherits(cond, "condition")) {
[16:04:34.001]                         if (!is.null(pattern)) {
[16:04:34.001]                           computeRestarts <- base::computeRestarts
[16:04:34.001]                           grepl <- base::grepl
[16:04:34.001]                           restarts <- computeRestarts(cond)
[16:04:34.001]                           for (restart in restarts) {
[16:04:34.001]                             name <- restart$name
[16:04:34.001]                             if (is.null(name)) 
[16:04:34.001]                               next
[16:04:34.001]                             if (!grepl(pattern, name)) 
[16:04:34.001]                               next
[16:04:34.001]                             invokeRestart(restart)
[16:04:34.001]                             muffled <- TRUE
[16:04:34.001]                             break
[16:04:34.001]                           }
[16:04:34.001]                         }
[16:04:34.001]                       }
[16:04:34.001]                       invisible(muffled)
[16:04:34.001]                     }
[16:04:34.001]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.001]                   }
[16:04:34.001]                 }
[16:04:34.001]                 else {
[16:04:34.001]                   if (TRUE) {
[16:04:34.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.001]                     {
[16:04:34.001]                       inherits <- base::inherits
[16:04:34.001]                       invokeRestart <- base::invokeRestart
[16:04:34.001]                       is.null <- base::is.null
[16:04:34.001]                       muffled <- FALSE
[16:04:34.001]                       if (inherits(cond, "message")) {
[16:04:34.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.001]                         if (muffled) 
[16:04:34.001]                           invokeRestart("muffleMessage")
[16:04:34.001]                       }
[16:04:34.001]                       else if (inherits(cond, "warning")) {
[16:04:34.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.001]                         if (muffled) 
[16:04:34.001]                           invokeRestart("muffleWarning")
[16:04:34.001]                       }
[16:04:34.001]                       else if (inherits(cond, "condition")) {
[16:04:34.001]                         if (!is.null(pattern)) {
[16:04:34.001]                           computeRestarts <- base::computeRestarts
[16:04:34.001]                           grepl <- base::grepl
[16:04:34.001]                           restarts <- computeRestarts(cond)
[16:04:34.001]                           for (restart in restarts) {
[16:04:34.001]                             name <- restart$name
[16:04:34.001]                             if (is.null(name)) 
[16:04:34.001]                               next
[16:04:34.001]                             if (!grepl(pattern, name)) 
[16:04:34.001]                               next
[16:04:34.001]                             invokeRestart(restart)
[16:04:34.001]                             muffled <- TRUE
[16:04:34.001]                             break
[16:04:34.001]                           }
[16:04:34.001]                         }
[16:04:34.001]                       }
[16:04:34.001]                       invisible(muffled)
[16:04:34.001]                     }
[16:04:34.001]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.001]                   }
[16:04:34.001]                 }
[16:04:34.001]             }
[16:04:34.001]         }))
[16:04:34.001]     }, error = function(ex) {
[16:04:34.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.001]                 ...future.rng), started = ...future.startTime, 
[16:04:34.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.001]             version = "1.8"), class = "FutureResult")
[16:04:34.001]     }, finally = {
[16:04:34.001]         if (!identical(...future.workdir, getwd())) 
[16:04:34.001]             setwd(...future.workdir)
[16:04:34.001]         {
[16:04:34.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.001]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.001]             }
[16:04:34.001]             base::options(...future.oldOptions)
[16:04:34.001]             if (.Platform$OS.type == "windows") {
[16:04:34.001]                 old_names <- names(...future.oldEnvVars)
[16:04:34.001]                 envs <- base::Sys.getenv()
[16:04:34.001]                 names <- names(envs)
[16:04:34.001]                 common <- intersect(names, old_names)
[16:04:34.001]                 added <- setdiff(names, old_names)
[16:04:34.001]                 removed <- setdiff(old_names, names)
[16:04:34.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.001]                   envs[common]]
[16:04:34.001]                 NAMES <- toupper(changed)
[16:04:34.001]                 args <- list()
[16:04:34.001]                 for (kk in seq_along(NAMES)) {
[16:04:34.001]                   name <- changed[[kk]]
[16:04:34.001]                   NAME <- NAMES[[kk]]
[16:04:34.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.001]                     next
[16:04:34.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.001]                 }
[16:04:34.001]                 NAMES <- toupper(added)
[16:04:34.001]                 for (kk in seq_along(NAMES)) {
[16:04:34.001]                   name <- added[[kk]]
[16:04:34.001]                   NAME <- NAMES[[kk]]
[16:04:34.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.001]                     next
[16:04:34.001]                   args[[name]] <- ""
[16:04:34.001]                 }
[16:04:34.001]                 NAMES <- toupper(removed)
[16:04:34.001]                 for (kk in seq_along(NAMES)) {
[16:04:34.001]                   name <- removed[[kk]]
[16:04:34.001]                   NAME <- NAMES[[kk]]
[16:04:34.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.001]                     next
[16:04:34.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.001]                 }
[16:04:34.001]                 if (length(args) > 0) 
[16:04:34.001]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.001]             }
[16:04:34.001]             else {
[16:04:34.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.001]             }
[16:04:34.001]             {
[16:04:34.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.001]                   0L) {
[16:04:34.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.001]                   base::options(opts)
[16:04:34.001]                 }
[16:04:34.001]                 {
[16:04:34.001]                   {
[16:04:34.001]                     NULL
[16:04:34.001]                     RNGkind("Mersenne-Twister")
[16:04:34.001]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:34.001]                       inherits = FALSE)
[16:04:34.001]                   }
[16:04:34.001]                   options(future.plan = NULL)
[16:04:34.001]                   if (is.na(NA_character_)) 
[16:04:34.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.001]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:34.001]                   {
[16:04:34.001]                     future <- SequentialFuture(..., envir = envir)
[16:04:34.001]                     if (!future$lazy) 
[16:04:34.001]                       future <- run(future)
[16:04:34.001]                     invisible(future)
[16:04:34.001]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.001]                 }
[16:04:34.001]             }
[16:04:34.001]         }
[16:04:34.001]     })
[16:04:34.001]     if (TRUE) {
[16:04:34.001]         base::sink(type = "output", split = FALSE)
[16:04:34.001]         if (TRUE) {
[16:04:34.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.001]         }
[16:04:34.001]         else {
[16:04:34.001]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.001]         }
[16:04:34.001]         base::close(...future.stdout)
[16:04:34.001]         ...future.stdout <- NULL
[16:04:34.001]     }
[16:04:34.001]     ...future.result$conditions <- ...future.conditions
[16:04:34.001]     ...future.result$finished <- base::Sys.time()
[16:04:34.001]     ...future.result
[16:04:34.001] }
[16:04:34.003] assign_globals() ...
[16:04:34.003] List of 1
[16:04:34.003]  $ a: num 1
[16:04:34.003]  - attr(*, "where")=List of 1
[16:04:34.003]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.003]  - attr(*, "resolved")= logi FALSE
[16:04:34.003]  - attr(*, "total_size")= num 56
[16:04:34.003]  - attr(*, "already-done")= logi TRUE
[16:04:34.005] - copied ‘a’ to environment
[16:04:34.005] assign_globals() ... done
[16:04:34.006] plan(): Setting new future strategy stack:
[16:04:34.006] List of future strategies:
[16:04:34.006] 1. sequential:
[16:04:34.006]    - args: function (..., envir = parent.frame())
[16:04:34.006]    - tweaked: FALSE
[16:04:34.006]    - call: NULL
[16:04:34.006] plan(): nbrOfWorkers() = 1
[16:04:34.007] plan(): Setting new future strategy stack:
[16:04:34.007] List of future strategies:
[16:04:34.007] 1. sequential:
[16:04:34.007]    - args: function (..., envir = parent.frame())
[16:04:34.007]    - tweaked: FALSE
[16:04:34.007]    - call: plan(strategy)
[16:04:34.007] plan(): nbrOfWorkers() = 1
[16:04:34.007] SequentialFuture started (and completed)
[16:04:34.008] - Launch lazy future ... done
[16:04:34.008] run() for ‘SequentialFuture’ ... done
[16:04:34.009] getGlobalsAndPackages() ...
[16:04:34.009] Searching for globals...
[16:04:34.009] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.010] Searching for globals ... DONE
[16:04:34.010] Resolving globals: FALSE
[16:04:34.010] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.010] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.010] - globals: [1] ‘a’
[16:04:34.010] 
[16:04:34.011] getGlobalsAndPackages() ... DONE
[16:04:34.011] run() for ‘Future’ ...
[16:04:34.011] - state: ‘created’
[16:04:34.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:34.011] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:34.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:34.011]   - Field: ‘label’
[16:04:34.012]   - Field: ‘local’
[16:04:34.012]   - Field: ‘owner’
[16:04:34.012]   - Field: ‘envir’
[16:04:34.012]   - Field: ‘packages’
[16:04:34.012]   - Field: ‘gc’
[16:04:34.012]   - Field: ‘conditions’
[16:04:34.012]   - Field: ‘expr’
[16:04:34.012]   - Field: ‘uuid’
[16:04:34.012]   - Field: ‘seed’
[16:04:34.012]   - Field: ‘version’
[16:04:34.012]   - Field: ‘result’
[16:04:34.013]   - Field: ‘asynchronous’
[16:04:34.013]   - Field: ‘calls’
[16:04:34.013]   - Field: ‘globals’
[16:04:34.013]   - Field: ‘stdout’
[16:04:34.013]   - Field: ‘earlySignal’
[16:04:34.013]   - Field: ‘lazy’
[16:04:34.013]   - Field: ‘state’
[16:04:34.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:34.013] - Launch lazy future ...
[16:04:34.013] Packages needed by the future expression (n = 0): <none>
[16:04:34.014] Packages needed by future strategies (n = 0): <none>
[16:04:34.014] {
[16:04:34.014]     {
[16:04:34.014]         {
[16:04:34.014]             ...future.startTime <- base::Sys.time()
[16:04:34.014]             {
[16:04:34.014]                 {
[16:04:34.014]                   {
[16:04:34.014]                     base::local({
[16:04:34.014]                       has_future <- base::requireNamespace("future", 
[16:04:34.014]                         quietly = TRUE)
[16:04:34.014]                       if (has_future) {
[16:04:34.014]                         ns <- base::getNamespace("future")
[16:04:34.014]                         version <- ns[[".package"]][["version"]]
[16:04:34.014]                         if (is.null(version)) 
[16:04:34.014]                           version <- utils::packageVersion("future")
[16:04:34.014]                       }
[16:04:34.014]                       else {
[16:04:34.014]                         version <- NULL
[16:04:34.014]                       }
[16:04:34.014]                       if (!has_future || version < "1.8.0") {
[16:04:34.014]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.014]                           "", base::R.version$version.string), 
[16:04:34.014]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:34.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.014]                             "release", "version")], collapse = " "), 
[16:04:34.014]                           hostname = base::Sys.info()[["nodename"]])
[16:04:34.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.014]                           info)
[16:04:34.014]                         info <- base::paste(info, collapse = "; ")
[16:04:34.014]                         if (!has_future) {
[16:04:34.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.014]                             info)
[16:04:34.014]                         }
[16:04:34.014]                         else {
[16:04:34.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.014]                             info, version)
[16:04:34.014]                         }
[16:04:34.014]                         base::stop(msg)
[16:04:34.014]                       }
[16:04:34.014]                     })
[16:04:34.014]                   }
[16:04:34.014]                   options(future.plan = NULL)
[16:04:34.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.014]                 }
[16:04:34.014]                 ...future.workdir <- getwd()
[16:04:34.014]             }
[16:04:34.014]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.014]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.014]         }
[16:04:34.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.014]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.014]             base::names(...future.oldOptions))
[16:04:34.014]     }
[16:04:34.014]     if (FALSE) {
[16:04:34.014]     }
[16:04:34.014]     else {
[16:04:34.014]         if (TRUE) {
[16:04:34.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.014]                 open = "w")
[16:04:34.014]         }
[16:04:34.014]         else {
[16:04:34.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.014]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.014]         }
[16:04:34.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.014]             base::sink(type = "output", split = FALSE)
[16:04:34.014]             base::close(...future.stdout)
[16:04:34.014]         }, add = TRUE)
[16:04:34.014]     }
[16:04:34.014]     ...future.frame <- base::sys.nframe()
[16:04:34.014]     ...future.conditions <- base::list()
[16:04:34.014]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.014]     if (FALSE) {
[16:04:34.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.014]     }
[16:04:34.014]     ...future.result <- base::tryCatch({
[16:04:34.014]         base::withCallingHandlers({
[16:04:34.014]             ...future.value <- base::withVisible(base::local({
[16:04:34.014]                 2 * a
[16:04:34.014]             }))
[16:04:34.014]             future::FutureResult(value = ...future.value$value, 
[16:04:34.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.014]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.014]                     ...future.globalenv.names))
[16:04:34.014]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.014]         }, condition = base::local({
[16:04:34.014]             c <- base::c
[16:04:34.014]             inherits <- base::inherits
[16:04:34.014]             invokeRestart <- base::invokeRestart
[16:04:34.014]             length <- base::length
[16:04:34.014]             list <- base::list
[16:04:34.014]             seq.int <- base::seq.int
[16:04:34.014]             signalCondition <- base::signalCondition
[16:04:34.014]             sys.calls <- base::sys.calls
[16:04:34.014]             `[[` <- base::`[[`
[16:04:34.014]             `+` <- base::`+`
[16:04:34.014]             `<<-` <- base::`<<-`
[16:04:34.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.014]                   3L)]
[16:04:34.014]             }
[16:04:34.014]             function(cond) {
[16:04:34.014]                 is_error <- inherits(cond, "error")
[16:04:34.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.014]                   NULL)
[16:04:34.014]                 if (is_error) {
[16:04:34.014]                   sessionInformation <- function() {
[16:04:34.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.014]                       search = base::search(), system = base::Sys.info())
[16:04:34.014]                   }
[16:04:34.014]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.014]                     cond$call), session = sessionInformation(), 
[16:04:34.014]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.014]                   signalCondition(cond)
[16:04:34.014]                 }
[16:04:34.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.014]                 "immediateCondition"))) {
[16:04:34.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.014]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.014]                   if (TRUE && !signal) {
[16:04:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.014]                     {
[16:04:34.014]                       inherits <- base::inherits
[16:04:34.014]                       invokeRestart <- base::invokeRestart
[16:04:34.014]                       is.null <- base::is.null
[16:04:34.014]                       muffled <- FALSE
[16:04:34.014]                       if (inherits(cond, "message")) {
[16:04:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.014]                         if (muffled) 
[16:04:34.014]                           invokeRestart("muffleMessage")
[16:04:34.014]                       }
[16:04:34.014]                       else if (inherits(cond, "warning")) {
[16:04:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.014]                         if (muffled) 
[16:04:34.014]                           invokeRestart("muffleWarning")
[16:04:34.014]                       }
[16:04:34.014]                       else if (inherits(cond, "condition")) {
[16:04:34.014]                         if (!is.null(pattern)) {
[16:04:34.014]                           computeRestarts <- base::computeRestarts
[16:04:34.014]                           grepl <- base::grepl
[16:04:34.014]                           restarts <- computeRestarts(cond)
[16:04:34.014]                           for (restart in restarts) {
[16:04:34.014]                             name <- restart$name
[16:04:34.014]                             if (is.null(name)) 
[16:04:34.014]                               next
[16:04:34.014]                             if (!grepl(pattern, name)) 
[16:04:34.014]                               next
[16:04:34.014]                             invokeRestart(restart)
[16:04:34.014]                             muffled <- TRUE
[16:04:34.014]                             break
[16:04:34.014]                           }
[16:04:34.014]                         }
[16:04:34.014]                       }
[16:04:34.014]                       invisible(muffled)
[16:04:34.014]                     }
[16:04:34.014]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.014]                   }
[16:04:34.014]                 }
[16:04:34.014]                 else {
[16:04:34.014]                   if (TRUE) {
[16:04:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.014]                     {
[16:04:34.014]                       inherits <- base::inherits
[16:04:34.014]                       invokeRestart <- base::invokeRestart
[16:04:34.014]                       is.null <- base::is.null
[16:04:34.014]                       muffled <- FALSE
[16:04:34.014]                       if (inherits(cond, "message")) {
[16:04:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.014]                         if (muffled) 
[16:04:34.014]                           invokeRestart("muffleMessage")
[16:04:34.014]                       }
[16:04:34.014]                       else if (inherits(cond, "warning")) {
[16:04:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.014]                         if (muffled) 
[16:04:34.014]                           invokeRestart("muffleWarning")
[16:04:34.014]                       }
[16:04:34.014]                       else if (inherits(cond, "condition")) {
[16:04:34.014]                         if (!is.null(pattern)) {
[16:04:34.014]                           computeRestarts <- base::computeRestarts
[16:04:34.014]                           grepl <- base::grepl
[16:04:34.014]                           restarts <- computeRestarts(cond)
[16:04:34.014]                           for (restart in restarts) {
[16:04:34.014]                             name <- restart$name
[16:04:34.014]                             if (is.null(name)) 
[16:04:34.014]                               next
[16:04:34.014]                             if (!grepl(pattern, name)) 
[16:04:34.014]                               next
[16:04:34.014]                             invokeRestart(restart)
[16:04:34.014]                             muffled <- TRUE
[16:04:34.014]                             break
[16:04:34.014]                           }
[16:04:34.014]                         }
[16:04:34.014]                       }
[16:04:34.014]                       invisible(muffled)
[16:04:34.014]                     }
[16:04:34.014]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.014]                   }
[16:04:34.014]                 }
[16:04:34.014]             }
[16:04:34.014]         }))
[16:04:34.014]     }, error = function(ex) {
[16:04:34.014]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.014]                 ...future.rng), started = ...future.startTime, 
[16:04:34.014]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.014]             version = "1.8"), class = "FutureResult")
[16:04:34.014]     }, finally = {
[16:04:34.014]         if (!identical(...future.workdir, getwd())) 
[16:04:34.014]             setwd(...future.workdir)
[16:04:34.014]         {
[16:04:34.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.014]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.014]             }
[16:04:34.014]             base::options(...future.oldOptions)
[16:04:34.014]             if (.Platform$OS.type == "windows") {
[16:04:34.014]                 old_names <- names(...future.oldEnvVars)
[16:04:34.014]                 envs <- base::Sys.getenv()
[16:04:34.014]                 names <- names(envs)
[16:04:34.014]                 common <- intersect(names, old_names)
[16:04:34.014]                 added <- setdiff(names, old_names)
[16:04:34.014]                 removed <- setdiff(old_names, names)
[16:04:34.014]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.014]                   envs[common]]
[16:04:34.014]                 NAMES <- toupper(changed)
[16:04:34.014]                 args <- list()
[16:04:34.014]                 for (kk in seq_along(NAMES)) {
[16:04:34.014]                   name <- changed[[kk]]
[16:04:34.014]                   NAME <- NAMES[[kk]]
[16:04:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.014]                     next
[16:04:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.014]                 }
[16:04:34.014]                 NAMES <- toupper(added)
[16:04:34.014]                 for (kk in seq_along(NAMES)) {
[16:04:34.014]                   name <- added[[kk]]
[16:04:34.014]                   NAME <- NAMES[[kk]]
[16:04:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.014]                     next
[16:04:34.014]                   args[[name]] <- ""
[16:04:34.014]                 }
[16:04:34.014]                 NAMES <- toupper(removed)
[16:04:34.014]                 for (kk in seq_along(NAMES)) {
[16:04:34.014]                   name <- removed[[kk]]
[16:04:34.014]                   NAME <- NAMES[[kk]]
[16:04:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.014]                     next
[16:04:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.014]                 }
[16:04:34.014]                 if (length(args) > 0) 
[16:04:34.014]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.014]             }
[16:04:34.014]             else {
[16:04:34.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.014]             }
[16:04:34.014]             {
[16:04:34.014]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.014]                   0L) {
[16:04:34.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.014]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.014]                   base::options(opts)
[16:04:34.014]                 }
[16:04:34.014]                 {
[16:04:34.014]                   {
[16:04:34.014]                     NULL
[16:04:34.014]                     RNGkind("Mersenne-Twister")
[16:04:34.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:34.014]                       inherits = FALSE)
[16:04:34.014]                   }
[16:04:34.014]                   options(future.plan = NULL)
[16:04:34.014]                   if (is.na(NA_character_)) 
[16:04:34.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.014]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:34.014]                   {
[16:04:34.014]                     future <- SequentialFuture(..., envir = envir)
[16:04:34.014]                     if (!future$lazy) 
[16:04:34.014]                       future <- run(future)
[16:04:34.014]                     invisible(future)
[16:04:34.014]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.014]                 }
[16:04:34.014]             }
[16:04:34.014]         }
[16:04:34.014]     })
[16:04:34.014]     if (TRUE) {
[16:04:34.014]         base::sink(type = "output", split = FALSE)
[16:04:34.014]         if (TRUE) {
[16:04:34.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.014]         }
[16:04:34.014]         else {
[16:04:34.014]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.014]         }
[16:04:34.014]         base::close(...future.stdout)
[16:04:34.014]         ...future.stdout <- NULL
[16:04:34.014]     }
[16:04:34.014]     ...future.result$conditions <- ...future.conditions
[16:04:34.014]     ...future.result$finished <- base::Sys.time()
[16:04:34.014]     ...future.result
[16:04:34.014] }
[16:04:34.015] assign_globals() ...
[16:04:34.016] List of 1
[16:04:34.016]  $ a: num 1
[16:04:34.016]  - attr(*, "where")=List of 1
[16:04:34.016]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.016]  - attr(*, "resolved")= logi FALSE
[16:04:34.016]  - attr(*, "total_size")= num 56
[16:04:34.016]  - attr(*, "already-done")= logi TRUE
[16:04:34.018] - copied ‘a’ to environment
[16:04:34.018] assign_globals() ... done
[16:04:34.018] plan(): Setting new future strategy stack:
[16:04:34.018] List of future strategies:
[16:04:34.018] 1. sequential:
[16:04:34.018]    - args: function (..., envir = parent.frame())
[16:04:34.018]    - tweaked: FALSE
[16:04:34.018]    - call: NULL
[16:04:34.019] plan(): nbrOfWorkers() = 1
[16:04:34.019] plan(): Setting new future strategy stack:
[16:04:34.019] List of future strategies:
[16:04:34.019] 1. sequential:
[16:04:34.019]    - args: function (..., envir = parent.frame())
[16:04:34.019]    - tweaked: FALSE
[16:04:34.019]    - call: plan(strategy)
[16:04:34.020] plan(): nbrOfWorkers() = 1
[16:04:34.020] SequentialFuture started (and completed)
[16:04:34.020] - Launch lazy future ... done
[16:04:34.020] run() for ‘SequentialFuture’ ... done
[16:04:34.020] getGlobalsAndPackages() ...
[16:04:34.020] Searching for globals...
[16:04:34.021] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.021] Searching for globals ... DONE
[16:04:34.021] Resolving globals: FALSE
[16:04:34.022] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.022] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.022] - globals: [1] ‘a’
[16:04:34.022] 
[16:04:34.022] getGlobalsAndPackages() ... DONE
[16:04:34.022] run() for ‘Future’ ...
[16:04:34.022] - state: ‘created’
[16:04:34.023] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:34.023] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:34.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:34.023]   - Field: ‘label’
[16:04:34.023]   - Field: ‘local’
[16:04:34.023]   - Field: ‘owner’
[16:04:34.023]   - Field: ‘envir’
[16:04:34.023]   - Field: ‘packages’
[16:04:34.024]   - Field: ‘gc’
[16:04:34.024]   - Field: ‘conditions’
[16:04:34.024]   - Field: ‘expr’
[16:04:34.024]   - Field: ‘uuid’
[16:04:34.024]   - Field: ‘seed’
[16:04:34.024]   - Field: ‘version’
[16:04:34.024]   - Field: ‘result’
[16:04:34.024]   - Field: ‘asynchronous’
[16:04:34.024]   - Field: ‘calls’
[16:04:34.024]   - Field: ‘globals’
[16:04:34.024]   - Field: ‘stdout’
[16:04:34.024]   - Field: ‘earlySignal’
[16:04:34.025]   - Field: ‘lazy’
[16:04:34.025]   - Field: ‘state’
[16:04:34.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:34.025] - Launch lazy future ...
[16:04:34.025] Packages needed by the future expression (n = 0): <none>
[16:04:34.025] Packages needed by future strategies (n = 0): <none>
[16:04:34.025] {
[16:04:34.025]     {
[16:04:34.025]         {
[16:04:34.025]             ...future.startTime <- base::Sys.time()
[16:04:34.025]             {
[16:04:34.025]                 {
[16:04:34.025]                   {
[16:04:34.025]                     base::local({
[16:04:34.025]                       has_future <- base::requireNamespace("future", 
[16:04:34.025]                         quietly = TRUE)
[16:04:34.025]                       if (has_future) {
[16:04:34.025]                         ns <- base::getNamespace("future")
[16:04:34.025]                         version <- ns[[".package"]][["version"]]
[16:04:34.025]                         if (is.null(version)) 
[16:04:34.025]                           version <- utils::packageVersion("future")
[16:04:34.025]                       }
[16:04:34.025]                       else {
[16:04:34.025]                         version <- NULL
[16:04:34.025]                       }
[16:04:34.025]                       if (!has_future || version < "1.8.0") {
[16:04:34.025]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.025]                           "", base::R.version$version.string), 
[16:04:34.025]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:34.025]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.025]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.025]                             "release", "version")], collapse = " "), 
[16:04:34.025]                           hostname = base::Sys.info()[["nodename"]])
[16:04:34.025]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.025]                           info)
[16:04:34.025]                         info <- base::paste(info, collapse = "; ")
[16:04:34.025]                         if (!has_future) {
[16:04:34.025]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.025]                             info)
[16:04:34.025]                         }
[16:04:34.025]                         else {
[16:04:34.025]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.025]                             info, version)
[16:04:34.025]                         }
[16:04:34.025]                         base::stop(msg)
[16:04:34.025]                       }
[16:04:34.025]                     })
[16:04:34.025]                   }
[16:04:34.025]                   options(future.plan = NULL)
[16:04:34.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.025]                 }
[16:04:34.025]                 ...future.workdir <- getwd()
[16:04:34.025]             }
[16:04:34.025]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.025]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.025]         }
[16:04:34.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.025]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.025]             base::names(...future.oldOptions))
[16:04:34.025]     }
[16:04:34.025]     if (FALSE) {
[16:04:34.025]     }
[16:04:34.025]     else {
[16:04:34.025]         if (TRUE) {
[16:04:34.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.025]                 open = "w")
[16:04:34.025]         }
[16:04:34.025]         else {
[16:04:34.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.025]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.025]         }
[16:04:34.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.025]             base::sink(type = "output", split = FALSE)
[16:04:34.025]             base::close(...future.stdout)
[16:04:34.025]         }, add = TRUE)
[16:04:34.025]     }
[16:04:34.025]     ...future.frame <- base::sys.nframe()
[16:04:34.025]     ...future.conditions <- base::list()
[16:04:34.025]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.025]     if (FALSE) {
[16:04:34.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.025]     }
[16:04:34.025]     ...future.result <- base::tryCatch({
[16:04:34.025]         base::withCallingHandlers({
[16:04:34.025]             ...future.value <- base::withVisible(base::local({
[16:04:34.025]                 2 * a
[16:04:34.025]             }))
[16:04:34.025]             future::FutureResult(value = ...future.value$value, 
[16:04:34.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.025]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.025]                     ...future.globalenv.names))
[16:04:34.025]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.025]         }, condition = base::local({
[16:04:34.025]             c <- base::c
[16:04:34.025]             inherits <- base::inherits
[16:04:34.025]             invokeRestart <- base::invokeRestart
[16:04:34.025]             length <- base::length
[16:04:34.025]             list <- base::list
[16:04:34.025]             seq.int <- base::seq.int
[16:04:34.025]             signalCondition <- base::signalCondition
[16:04:34.025]             sys.calls <- base::sys.calls
[16:04:34.025]             `[[` <- base::`[[`
[16:04:34.025]             `+` <- base::`+`
[16:04:34.025]             `<<-` <- base::`<<-`
[16:04:34.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.025]                   3L)]
[16:04:34.025]             }
[16:04:34.025]             function(cond) {
[16:04:34.025]                 is_error <- inherits(cond, "error")
[16:04:34.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.025]                   NULL)
[16:04:34.025]                 if (is_error) {
[16:04:34.025]                   sessionInformation <- function() {
[16:04:34.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.025]                       search = base::search(), system = base::Sys.info())
[16:04:34.025]                   }
[16:04:34.025]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.025]                     cond$call), session = sessionInformation(), 
[16:04:34.025]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.025]                   signalCondition(cond)
[16:04:34.025]                 }
[16:04:34.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.025]                 "immediateCondition"))) {
[16:04:34.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.025]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.025]                   if (TRUE && !signal) {
[16:04:34.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.025]                     {
[16:04:34.025]                       inherits <- base::inherits
[16:04:34.025]                       invokeRestart <- base::invokeRestart
[16:04:34.025]                       is.null <- base::is.null
[16:04:34.025]                       muffled <- FALSE
[16:04:34.025]                       if (inherits(cond, "message")) {
[16:04:34.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.025]                         if (muffled) 
[16:04:34.025]                           invokeRestart("muffleMessage")
[16:04:34.025]                       }
[16:04:34.025]                       else if (inherits(cond, "warning")) {
[16:04:34.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.025]                         if (muffled) 
[16:04:34.025]                           invokeRestart("muffleWarning")
[16:04:34.025]                       }
[16:04:34.025]                       else if (inherits(cond, "condition")) {
[16:04:34.025]                         if (!is.null(pattern)) {
[16:04:34.025]                           computeRestarts <- base::computeRestarts
[16:04:34.025]                           grepl <- base::grepl
[16:04:34.025]                           restarts <- computeRestarts(cond)
[16:04:34.025]                           for (restart in restarts) {
[16:04:34.025]                             name <- restart$name
[16:04:34.025]                             if (is.null(name)) 
[16:04:34.025]                               next
[16:04:34.025]                             if (!grepl(pattern, name)) 
[16:04:34.025]                               next
[16:04:34.025]                             invokeRestart(restart)
[16:04:34.025]                             muffled <- TRUE
[16:04:34.025]                             break
[16:04:34.025]                           }
[16:04:34.025]                         }
[16:04:34.025]                       }
[16:04:34.025]                       invisible(muffled)
[16:04:34.025]                     }
[16:04:34.025]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.025]                   }
[16:04:34.025]                 }
[16:04:34.025]                 else {
[16:04:34.025]                   if (TRUE) {
[16:04:34.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.025]                     {
[16:04:34.025]                       inherits <- base::inherits
[16:04:34.025]                       invokeRestart <- base::invokeRestart
[16:04:34.025]                       is.null <- base::is.null
[16:04:34.025]                       muffled <- FALSE
[16:04:34.025]                       if (inherits(cond, "message")) {
[16:04:34.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.025]                         if (muffled) 
[16:04:34.025]                           invokeRestart("muffleMessage")
[16:04:34.025]                       }
[16:04:34.025]                       else if (inherits(cond, "warning")) {
[16:04:34.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.025]                         if (muffled) 
[16:04:34.025]                           invokeRestart("muffleWarning")
[16:04:34.025]                       }
[16:04:34.025]                       else if (inherits(cond, "condition")) {
[16:04:34.025]                         if (!is.null(pattern)) {
[16:04:34.025]                           computeRestarts <- base::computeRestarts
[16:04:34.025]                           grepl <- base::grepl
[16:04:34.025]                           restarts <- computeRestarts(cond)
[16:04:34.025]                           for (restart in restarts) {
[16:04:34.025]                             name <- restart$name
[16:04:34.025]                             if (is.null(name)) 
[16:04:34.025]                               next
[16:04:34.025]                             if (!grepl(pattern, name)) 
[16:04:34.025]                               next
[16:04:34.025]                             invokeRestart(restart)
[16:04:34.025]                             muffled <- TRUE
[16:04:34.025]                             break
[16:04:34.025]                           }
[16:04:34.025]                         }
[16:04:34.025]                       }
[16:04:34.025]                       invisible(muffled)
[16:04:34.025]                     }
[16:04:34.025]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.025]                   }
[16:04:34.025]                 }
[16:04:34.025]             }
[16:04:34.025]         }))
[16:04:34.025]     }, error = function(ex) {
[16:04:34.025]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.025]                 ...future.rng), started = ...future.startTime, 
[16:04:34.025]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.025]             version = "1.8"), class = "FutureResult")
[16:04:34.025]     }, finally = {
[16:04:34.025]         if (!identical(...future.workdir, getwd())) 
[16:04:34.025]             setwd(...future.workdir)
[16:04:34.025]         {
[16:04:34.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.025]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.025]             }
[16:04:34.025]             base::options(...future.oldOptions)
[16:04:34.025]             if (.Platform$OS.type == "windows") {
[16:04:34.025]                 old_names <- names(...future.oldEnvVars)
[16:04:34.025]                 envs <- base::Sys.getenv()
[16:04:34.025]                 names <- names(envs)
[16:04:34.025]                 common <- intersect(names, old_names)
[16:04:34.025]                 added <- setdiff(names, old_names)
[16:04:34.025]                 removed <- setdiff(old_names, names)
[16:04:34.025]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.025]                   envs[common]]
[16:04:34.025]                 NAMES <- toupper(changed)
[16:04:34.025]                 args <- list()
[16:04:34.025]                 for (kk in seq_along(NAMES)) {
[16:04:34.025]                   name <- changed[[kk]]
[16:04:34.025]                   NAME <- NAMES[[kk]]
[16:04:34.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.025]                     next
[16:04:34.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.025]                 }
[16:04:34.025]                 NAMES <- toupper(added)
[16:04:34.025]                 for (kk in seq_along(NAMES)) {
[16:04:34.025]                   name <- added[[kk]]
[16:04:34.025]                   NAME <- NAMES[[kk]]
[16:04:34.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.025]                     next
[16:04:34.025]                   args[[name]] <- ""
[16:04:34.025]                 }
[16:04:34.025]                 NAMES <- toupper(removed)
[16:04:34.025]                 for (kk in seq_along(NAMES)) {
[16:04:34.025]                   name <- removed[[kk]]
[16:04:34.025]                   NAME <- NAMES[[kk]]
[16:04:34.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.025]                     next
[16:04:34.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.025]                 }
[16:04:34.025]                 if (length(args) > 0) 
[16:04:34.025]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.025]             }
[16:04:34.025]             else {
[16:04:34.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.025]             }
[16:04:34.025]             {
[16:04:34.025]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.025]                   0L) {
[16:04:34.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.025]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.025]                   base::options(opts)
[16:04:34.025]                 }
[16:04:34.025]                 {
[16:04:34.025]                   {
[16:04:34.025]                     NULL
[16:04:34.025]                     RNGkind("Mersenne-Twister")
[16:04:34.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:34.025]                       inherits = FALSE)
[16:04:34.025]                   }
[16:04:34.025]                   options(future.plan = NULL)
[16:04:34.025]                   if (is.na(NA_character_)) 
[16:04:34.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.025]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:34.025]                   {
[16:04:34.025]                     future <- SequentialFuture(..., envir = envir)
[16:04:34.025]                     if (!future$lazy) 
[16:04:34.025]                       future <- run(future)
[16:04:34.025]                     invisible(future)
[16:04:34.025]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.025]                 }
[16:04:34.025]             }
[16:04:34.025]         }
[16:04:34.025]     })
[16:04:34.025]     if (TRUE) {
[16:04:34.025]         base::sink(type = "output", split = FALSE)
[16:04:34.025]         if (TRUE) {
[16:04:34.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.025]         }
[16:04:34.025]         else {
[16:04:34.025]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.025]         }
[16:04:34.025]         base::close(...future.stdout)
[16:04:34.025]         ...future.stdout <- NULL
[16:04:34.025]     }
[16:04:34.025]     ...future.result$conditions <- ...future.conditions
[16:04:34.025]     ...future.result$finished <- base::Sys.time()
[16:04:34.025]     ...future.result
[16:04:34.025] }
[16:04:34.027] assign_globals() ...
[16:04:34.027] List of 1
[16:04:34.027]  $ a: num 1
[16:04:34.027]  - attr(*, "where")=List of 1
[16:04:34.027]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.027]  - attr(*, "resolved")= logi FALSE
[16:04:34.027]  - attr(*, "total_size")= num 56
[16:04:34.027]  - attr(*, "already-done")= logi TRUE
[16:04:34.029] - copied ‘a’ to environment
[16:04:34.029] assign_globals() ... done
[16:04:34.030] plan(): Setting new future strategy stack:
[16:04:34.030] List of future strategies:
[16:04:34.030] 1. sequential:
[16:04:34.030]    - args: function (..., envir = parent.frame())
[16:04:34.030]    - tweaked: FALSE
[16:04:34.030]    - call: NULL
[16:04:34.030] plan(): nbrOfWorkers() = 1
[16:04:34.031] plan(): Setting new future strategy stack:
[16:04:34.031] List of future strategies:
[16:04:34.031] 1. sequential:
[16:04:34.031]    - args: function (..., envir = parent.frame())
[16:04:34.031]    - tweaked: FALSE
[16:04:34.031]    - call: plan(strategy)
[16:04:34.031] plan(): nbrOfWorkers() = 1
[16:04:34.031] SequentialFuture started (and completed)
[16:04:34.031] - Launch lazy future ... done
[16:04:34.031] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[16:04:34.037] plan(): Setting new future strategy stack:
[16:04:34.037] List of future strategies:
[16:04:34.037] 1. multicore:
[16:04:34.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.037]    - tweaked: FALSE
[16:04:34.037]    - call: plan(strategy)
[16:04:34.041] plan(): nbrOfWorkers() = 2
[16:04:34.041] getGlobalsAndPackages() ...
[16:04:34.041] Searching for globals...
[16:04:34.042] - globals found: [1] ‘{’
[16:04:34.042] Searching for globals ... DONE
[16:04:34.042] Resolving globals: FALSE
[16:04:34.042] 
[16:04:34.042] 
[16:04:34.042] getGlobalsAndPackages() ... DONE
[16:04:34.043] run() for ‘Future’ ...
[16:04:34.043] - state: ‘created’
[16:04:34.043] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.046] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.047]   - Field: ‘label’
[16:04:34.047]   - Field: ‘local’
[16:04:34.047]   - Field: ‘owner’
[16:04:34.047]   - Field: ‘envir’
[16:04:34.047]   - Field: ‘workers’
[16:04:34.047]   - Field: ‘packages’
[16:04:34.047]   - Field: ‘gc’
[16:04:34.047]   - Field: ‘job’
[16:04:34.047]   - Field: ‘conditions’
[16:04:34.047]   - Field: ‘expr’
[16:04:34.047]   - Field: ‘uuid’
[16:04:34.048]   - Field: ‘seed’
[16:04:34.048]   - Field: ‘version’
[16:04:34.048]   - Field: ‘result’
[16:04:34.048]   - Field: ‘asynchronous’
[16:04:34.048]   - Field: ‘calls’
[16:04:34.048]   - Field: ‘globals’
[16:04:34.048]   - Field: ‘stdout’
[16:04:34.048]   - Field: ‘earlySignal’
[16:04:34.048]   - Field: ‘lazy’
[16:04:34.048]   - Field: ‘state’
[16:04:34.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.048] - Launch lazy future ...
[16:04:34.049] Packages needed by the future expression (n = 0): <none>
[16:04:34.050] Packages needed by future strategies (n = 0): <none>
[16:04:34.050] {
[16:04:34.050]     {
[16:04:34.050]         {
[16:04:34.050]             ...future.startTime <- base::Sys.time()
[16:04:34.050]             {
[16:04:34.050]                 {
[16:04:34.050]                   {
[16:04:34.050]                     {
[16:04:34.050]                       base::local({
[16:04:34.050]                         has_future <- base::requireNamespace("future", 
[16:04:34.050]                           quietly = TRUE)
[16:04:34.050]                         if (has_future) {
[16:04:34.050]                           ns <- base::getNamespace("future")
[16:04:34.050]                           version <- ns[[".package"]][["version"]]
[16:04:34.050]                           if (is.null(version)) 
[16:04:34.050]                             version <- utils::packageVersion("future")
[16:04:34.050]                         }
[16:04:34.050]                         else {
[16:04:34.050]                           version <- NULL
[16:04:34.050]                         }
[16:04:34.050]                         if (!has_future || version < "1.8.0") {
[16:04:34.050]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.050]                             "", base::R.version$version.string), 
[16:04:34.050]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.050]                               "release", "version")], collapse = " "), 
[16:04:34.050]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.050]                             info)
[16:04:34.050]                           info <- base::paste(info, collapse = "; ")
[16:04:34.050]                           if (!has_future) {
[16:04:34.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.050]                               info)
[16:04:34.050]                           }
[16:04:34.050]                           else {
[16:04:34.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.050]                               info, version)
[16:04:34.050]                           }
[16:04:34.050]                           base::stop(msg)
[16:04:34.050]                         }
[16:04:34.050]                       })
[16:04:34.050]                     }
[16:04:34.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.050]                     base::options(mc.cores = 1L)
[16:04:34.050]                   }
[16:04:34.050]                   options(future.plan = NULL)
[16:04:34.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.050]                 }
[16:04:34.050]                 ...future.workdir <- getwd()
[16:04:34.050]             }
[16:04:34.050]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.050]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.050]         }
[16:04:34.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.050]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.050]             base::names(...future.oldOptions))
[16:04:34.050]     }
[16:04:34.050]     if (FALSE) {
[16:04:34.050]     }
[16:04:34.050]     else {
[16:04:34.050]         if (TRUE) {
[16:04:34.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.050]                 open = "w")
[16:04:34.050]         }
[16:04:34.050]         else {
[16:04:34.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.050]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.050]         }
[16:04:34.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.050]             base::sink(type = "output", split = FALSE)
[16:04:34.050]             base::close(...future.stdout)
[16:04:34.050]         }, add = TRUE)
[16:04:34.050]     }
[16:04:34.050]     ...future.frame <- base::sys.nframe()
[16:04:34.050]     ...future.conditions <- base::list()
[16:04:34.050]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.050]     if (FALSE) {
[16:04:34.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.050]     }
[16:04:34.050]     ...future.result <- base::tryCatch({
[16:04:34.050]         base::withCallingHandlers({
[16:04:34.050]             ...future.value <- base::withVisible(base::local({
[16:04:34.050]                 withCallingHandlers({
[16:04:34.050]                   {
[16:04:34.050]                     2
[16:04:34.050]                   }
[16:04:34.050]                 }, immediateCondition = function(cond) {
[16:04:34.050]                   save_rds <- function (object, pathname, ...) 
[16:04:34.050]                   {
[16:04:34.050]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.050]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.050]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.050]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.050]                         fi_tmp[["mtime"]])
[16:04:34.050]                     }
[16:04:34.050]                     tryCatch({
[16:04:34.050]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.050]                     }, error = function(ex) {
[16:04:34.050]                       msg <- conditionMessage(ex)
[16:04:34.050]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.050]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.050]                         fi_tmp[["mtime"]], msg)
[16:04:34.050]                       ex$message <- msg
[16:04:34.050]                       stop(ex)
[16:04:34.050]                     })
[16:04:34.050]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.050]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.050]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.050]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.050]                       fi <- file.info(pathname)
[16:04:34.050]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.050]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.050]                         fi[["size"]], fi[["mtime"]])
[16:04:34.050]                       stop(msg)
[16:04:34.050]                     }
[16:04:34.050]                     invisible(pathname)
[16:04:34.050]                   }
[16:04:34.050]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.050]                     rootPath = tempdir()) 
[16:04:34.050]                   {
[16:04:34.050]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.050]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.050]                       tmpdir = path, fileext = ".rds")
[16:04:34.050]                     save_rds(obj, file)
[16:04:34.050]                   }
[16:04:34.050]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.050]                   {
[16:04:34.050]                     inherits <- base::inherits
[16:04:34.050]                     invokeRestart <- base::invokeRestart
[16:04:34.050]                     is.null <- base::is.null
[16:04:34.050]                     muffled <- FALSE
[16:04:34.050]                     if (inherits(cond, "message")) {
[16:04:34.050]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.050]                       if (muffled) 
[16:04:34.050]                         invokeRestart("muffleMessage")
[16:04:34.050]                     }
[16:04:34.050]                     else if (inherits(cond, "warning")) {
[16:04:34.050]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.050]                       if (muffled) 
[16:04:34.050]                         invokeRestart("muffleWarning")
[16:04:34.050]                     }
[16:04:34.050]                     else if (inherits(cond, "condition")) {
[16:04:34.050]                       if (!is.null(pattern)) {
[16:04:34.050]                         computeRestarts <- base::computeRestarts
[16:04:34.050]                         grepl <- base::grepl
[16:04:34.050]                         restarts <- computeRestarts(cond)
[16:04:34.050]                         for (restart in restarts) {
[16:04:34.050]                           name <- restart$name
[16:04:34.050]                           if (is.null(name)) 
[16:04:34.050]                             next
[16:04:34.050]                           if (!grepl(pattern, name)) 
[16:04:34.050]                             next
[16:04:34.050]                           invokeRestart(restart)
[16:04:34.050]                           muffled <- TRUE
[16:04:34.050]                           break
[16:04:34.050]                         }
[16:04:34.050]                       }
[16:04:34.050]                     }
[16:04:34.050]                     invisible(muffled)
[16:04:34.050]                   }
[16:04:34.050]                   muffleCondition(cond)
[16:04:34.050]                 })
[16:04:34.050]             }))
[16:04:34.050]             future::FutureResult(value = ...future.value$value, 
[16:04:34.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.050]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.050]                     ...future.globalenv.names))
[16:04:34.050]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.050]         }, condition = base::local({
[16:04:34.050]             c <- base::c
[16:04:34.050]             inherits <- base::inherits
[16:04:34.050]             invokeRestart <- base::invokeRestart
[16:04:34.050]             length <- base::length
[16:04:34.050]             list <- base::list
[16:04:34.050]             seq.int <- base::seq.int
[16:04:34.050]             signalCondition <- base::signalCondition
[16:04:34.050]             sys.calls <- base::sys.calls
[16:04:34.050]             `[[` <- base::`[[`
[16:04:34.050]             `+` <- base::`+`
[16:04:34.050]             `<<-` <- base::`<<-`
[16:04:34.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.050]                   3L)]
[16:04:34.050]             }
[16:04:34.050]             function(cond) {
[16:04:34.050]                 is_error <- inherits(cond, "error")
[16:04:34.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.050]                   NULL)
[16:04:34.050]                 if (is_error) {
[16:04:34.050]                   sessionInformation <- function() {
[16:04:34.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.050]                       search = base::search(), system = base::Sys.info())
[16:04:34.050]                   }
[16:04:34.050]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.050]                     cond$call), session = sessionInformation(), 
[16:04:34.050]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.050]                   signalCondition(cond)
[16:04:34.050]                 }
[16:04:34.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.050]                 "immediateCondition"))) {
[16:04:34.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.050]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.050]                   if (TRUE && !signal) {
[16:04:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.050]                     {
[16:04:34.050]                       inherits <- base::inherits
[16:04:34.050]                       invokeRestart <- base::invokeRestart
[16:04:34.050]                       is.null <- base::is.null
[16:04:34.050]                       muffled <- FALSE
[16:04:34.050]                       if (inherits(cond, "message")) {
[16:04:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.050]                         if (muffled) 
[16:04:34.050]                           invokeRestart("muffleMessage")
[16:04:34.050]                       }
[16:04:34.050]                       else if (inherits(cond, "warning")) {
[16:04:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.050]                         if (muffled) 
[16:04:34.050]                           invokeRestart("muffleWarning")
[16:04:34.050]                       }
[16:04:34.050]                       else if (inherits(cond, "condition")) {
[16:04:34.050]                         if (!is.null(pattern)) {
[16:04:34.050]                           computeRestarts <- base::computeRestarts
[16:04:34.050]                           grepl <- base::grepl
[16:04:34.050]                           restarts <- computeRestarts(cond)
[16:04:34.050]                           for (restart in restarts) {
[16:04:34.050]                             name <- restart$name
[16:04:34.050]                             if (is.null(name)) 
[16:04:34.050]                               next
[16:04:34.050]                             if (!grepl(pattern, name)) 
[16:04:34.050]                               next
[16:04:34.050]                             invokeRestart(restart)
[16:04:34.050]                             muffled <- TRUE
[16:04:34.050]                             break
[16:04:34.050]                           }
[16:04:34.050]                         }
[16:04:34.050]                       }
[16:04:34.050]                       invisible(muffled)
[16:04:34.050]                     }
[16:04:34.050]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.050]                   }
[16:04:34.050]                 }
[16:04:34.050]                 else {
[16:04:34.050]                   if (TRUE) {
[16:04:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.050]                     {
[16:04:34.050]                       inherits <- base::inherits
[16:04:34.050]                       invokeRestart <- base::invokeRestart
[16:04:34.050]                       is.null <- base::is.null
[16:04:34.050]                       muffled <- FALSE
[16:04:34.050]                       if (inherits(cond, "message")) {
[16:04:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.050]                         if (muffled) 
[16:04:34.050]                           invokeRestart("muffleMessage")
[16:04:34.050]                       }
[16:04:34.050]                       else if (inherits(cond, "warning")) {
[16:04:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.050]                         if (muffled) 
[16:04:34.050]                           invokeRestart("muffleWarning")
[16:04:34.050]                       }
[16:04:34.050]                       else if (inherits(cond, "condition")) {
[16:04:34.050]                         if (!is.null(pattern)) {
[16:04:34.050]                           computeRestarts <- base::computeRestarts
[16:04:34.050]                           grepl <- base::grepl
[16:04:34.050]                           restarts <- computeRestarts(cond)
[16:04:34.050]                           for (restart in restarts) {
[16:04:34.050]                             name <- restart$name
[16:04:34.050]                             if (is.null(name)) 
[16:04:34.050]                               next
[16:04:34.050]                             if (!grepl(pattern, name)) 
[16:04:34.050]                               next
[16:04:34.050]                             invokeRestart(restart)
[16:04:34.050]                             muffled <- TRUE
[16:04:34.050]                             break
[16:04:34.050]                           }
[16:04:34.050]                         }
[16:04:34.050]                       }
[16:04:34.050]                       invisible(muffled)
[16:04:34.050]                     }
[16:04:34.050]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.050]                   }
[16:04:34.050]                 }
[16:04:34.050]             }
[16:04:34.050]         }))
[16:04:34.050]     }, error = function(ex) {
[16:04:34.050]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.050]                 ...future.rng), started = ...future.startTime, 
[16:04:34.050]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.050]             version = "1.8"), class = "FutureResult")
[16:04:34.050]     }, finally = {
[16:04:34.050]         if (!identical(...future.workdir, getwd())) 
[16:04:34.050]             setwd(...future.workdir)
[16:04:34.050]         {
[16:04:34.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.050]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.050]             }
[16:04:34.050]             base::options(...future.oldOptions)
[16:04:34.050]             if (.Platform$OS.type == "windows") {
[16:04:34.050]                 old_names <- names(...future.oldEnvVars)
[16:04:34.050]                 envs <- base::Sys.getenv()
[16:04:34.050]                 names <- names(envs)
[16:04:34.050]                 common <- intersect(names, old_names)
[16:04:34.050]                 added <- setdiff(names, old_names)
[16:04:34.050]                 removed <- setdiff(old_names, names)
[16:04:34.050]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.050]                   envs[common]]
[16:04:34.050]                 NAMES <- toupper(changed)
[16:04:34.050]                 args <- list()
[16:04:34.050]                 for (kk in seq_along(NAMES)) {
[16:04:34.050]                   name <- changed[[kk]]
[16:04:34.050]                   NAME <- NAMES[[kk]]
[16:04:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.050]                     next
[16:04:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.050]                 }
[16:04:34.050]                 NAMES <- toupper(added)
[16:04:34.050]                 for (kk in seq_along(NAMES)) {
[16:04:34.050]                   name <- added[[kk]]
[16:04:34.050]                   NAME <- NAMES[[kk]]
[16:04:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.050]                     next
[16:04:34.050]                   args[[name]] <- ""
[16:04:34.050]                 }
[16:04:34.050]                 NAMES <- toupper(removed)
[16:04:34.050]                 for (kk in seq_along(NAMES)) {
[16:04:34.050]                   name <- removed[[kk]]
[16:04:34.050]                   NAME <- NAMES[[kk]]
[16:04:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.050]                     next
[16:04:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.050]                 }
[16:04:34.050]                 if (length(args) > 0) 
[16:04:34.050]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.050]             }
[16:04:34.050]             else {
[16:04:34.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.050]             }
[16:04:34.050]             {
[16:04:34.050]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.050]                   0L) {
[16:04:34.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.050]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.050]                   base::options(opts)
[16:04:34.050]                 }
[16:04:34.050]                 {
[16:04:34.050]                   {
[16:04:34.050]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.050]                     NULL
[16:04:34.050]                   }
[16:04:34.050]                   options(future.plan = NULL)
[16:04:34.050]                   if (is.na(NA_character_)) 
[16:04:34.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.050]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.050]                     envir = parent.frame()) 
[16:04:34.050]                   {
[16:04:34.050]                     default_workers <- missing(workers)
[16:04:34.050]                     if (is.function(workers)) 
[16:04:34.050]                       workers <- workers()
[16:04:34.050]                     workers <- structure(as.integer(workers), 
[16:04:34.050]                       class = class(workers))
[16:04:34.050]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.050]                       1L)
[16:04:34.050]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.050]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.050]                       if (default_workers) 
[16:04:34.050]                         supportsMulticore(warn = TRUE)
[16:04:34.050]                       return(sequential(..., envir = envir))
[16:04:34.050]                     }
[16:04:34.050]                     oopts <- options(mc.cores = workers)
[16:04:34.050]                     on.exit(options(oopts))
[16:04:34.050]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.050]                       envir = envir)
[16:04:34.050]                     if (!future$lazy) 
[16:04:34.050]                       future <- run(future)
[16:04:34.050]                     invisible(future)
[16:04:34.050]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.050]                 }
[16:04:34.050]             }
[16:04:34.050]         }
[16:04:34.050]     })
[16:04:34.050]     if (TRUE) {
[16:04:34.050]         base::sink(type = "output", split = FALSE)
[16:04:34.050]         if (TRUE) {
[16:04:34.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.050]         }
[16:04:34.050]         else {
[16:04:34.050]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.050]         }
[16:04:34.050]         base::close(...future.stdout)
[16:04:34.050]         ...future.stdout <- NULL
[16:04:34.050]     }
[16:04:34.050]     ...future.result$conditions <- ...future.conditions
[16:04:34.050]     ...future.result$finished <- base::Sys.time()
[16:04:34.050]     ...future.result
[16:04:34.050] }
[16:04:34.052] requestCore(): workers = 2
[16:04:34.055] MulticoreFuture started
[16:04:34.055] - Launch lazy future ... done
[16:04:34.056] plan(): Setting new future strategy stack:
[16:04:34.056] run() for ‘MulticoreFuture’ ... done
[16:04:34.056] getGlobalsAndPackages() ...
[16:04:34.056] List of future strategies:
[16:04:34.056] 1. sequential:
[16:04:34.056]    - args: function (..., envir = parent.frame())
[16:04:34.056]    - tweaked: FALSE
[16:04:34.056]    - call: NULL
[16:04:34.056] Searching for globals...
[16:04:34.057] plan(): nbrOfWorkers() = 1
[16:04:34.058] - globals found: [1] ‘{’
[16:04:34.058] Searching for globals ... DONE
[16:04:34.058] plan(): Setting new future strategy stack:
[16:04:34.059] Resolving globals: FALSE
[16:04:34.059] List of future strategies:
[16:04:34.059] 1. multicore:
[16:04:34.059]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.059]    - tweaked: FALSE
[16:04:34.059]    - call: plan(strategy)
[16:04:34.059] 
[16:04:34.059] 
[16:04:34.059] getGlobalsAndPackages() ... DONE
[16:04:34.060] run() for ‘Future’ ...
[16:04:34.060] - state: ‘created’
[16:04:34.060] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.063] plan(): nbrOfWorkers() = 2
[16:04:34.065] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.065]   - Field: ‘label’
[16:04:34.065]   - Field: ‘local’
[16:04:34.065]   - Field: ‘owner’
[16:04:34.066]   - Field: ‘envir’
[16:04:34.066]   - Field: ‘workers’
[16:04:34.066]   - Field: ‘packages’
[16:04:34.066]   - Field: ‘gc’
[16:04:34.066]   - Field: ‘job’
[16:04:34.066]   - Field: ‘conditions’
[16:04:34.066]   - Field: ‘expr’
[16:04:34.067]   - Field: ‘uuid’
[16:04:34.067]   - Field: ‘seed’
[16:04:34.067]   - Field: ‘version’
[16:04:34.067]   - Field: ‘result’
[16:04:34.067]   - Field: ‘asynchronous’
[16:04:34.067]   - Field: ‘calls’
[16:04:34.068]   - Field: ‘globals’
[16:04:34.068]   - Field: ‘stdout’
[16:04:34.068]   - Field: ‘earlySignal’
[16:04:34.068]   - Field: ‘lazy’
[16:04:34.068]   - Field: ‘state’
[16:04:34.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.068] - Launch lazy future ...
[16:04:34.069] Packages needed by the future expression (n = 0): <none>
[16:04:34.069] Packages needed by future strategies (n = 0): <none>
[16:04:34.070] {
[16:04:34.070]     {
[16:04:34.070]         {
[16:04:34.070]             ...future.startTime <- base::Sys.time()
[16:04:34.070]             {
[16:04:34.070]                 {
[16:04:34.070]                   {
[16:04:34.070]                     {
[16:04:34.070]                       base::local({
[16:04:34.070]                         has_future <- base::requireNamespace("future", 
[16:04:34.070]                           quietly = TRUE)
[16:04:34.070]                         if (has_future) {
[16:04:34.070]                           ns <- base::getNamespace("future")
[16:04:34.070]                           version <- ns[[".package"]][["version"]]
[16:04:34.070]                           if (is.null(version)) 
[16:04:34.070]                             version <- utils::packageVersion("future")
[16:04:34.070]                         }
[16:04:34.070]                         else {
[16:04:34.070]                           version <- NULL
[16:04:34.070]                         }
[16:04:34.070]                         if (!has_future || version < "1.8.0") {
[16:04:34.070]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.070]                             "", base::R.version$version.string), 
[16:04:34.070]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.070]                               "release", "version")], collapse = " "), 
[16:04:34.070]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.070]                             info)
[16:04:34.070]                           info <- base::paste(info, collapse = "; ")
[16:04:34.070]                           if (!has_future) {
[16:04:34.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.070]                               info)
[16:04:34.070]                           }
[16:04:34.070]                           else {
[16:04:34.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.070]                               info, version)
[16:04:34.070]                           }
[16:04:34.070]                           base::stop(msg)
[16:04:34.070]                         }
[16:04:34.070]                       })
[16:04:34.070]                     }
[16:04:34.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.070]                     base::options(mc.cores = 1L)
[16:04:34.070]                   }
[16:04:34.070]                   options(future.plan = NULL)
[16:04:34.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.070]                 }
[16:04:34.070]                 ...future.workdir <- getwd()
[16:04:34.070]             }
[16:04:34.070]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.070]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.070]         }
[16:04:34.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.070]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.070]             base::names(...future.oldOptions))
[16:04:34.070]     }
[16:04:34.070]     if (FALSE) {
[16:04:34.070]     }
[16:04:34.070]     else {
[16:04:34.070]         if (TRUE) {
[16:04:34.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.070]                 open = "w")
[16:04:34.070]         }
[16:04:34.070]         else {
[16:04:34.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.070]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.070]         }
[16:04:34.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.070]             base::sink(type = "output", split = FALSE)
[16:04:34.070]             base::close(...future.stdout)
[16:04:34.070]         }, add = TRUE)
[16:04:34.070]     }
[16:04:34.070]     ...future.frame <- base::sys.nframe()
[16:04:34.070]     ...future.conditions <- base::list()
[16:04:34.070]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.070]     if (FALSE) {
[16:04:34.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.070]     }
[16:04:34.070]     ...future.result <- base::tryCatch({
[16:04:34.070]         base::withCallingHandlers({
[16:04:34.070]             ...future.value <- base::withVisible(base::local({
[16:04:34.070]                 withCallingHandlers({
[16:04:34.070]                   {
[16:04:34.070]                     4
[16:04:34.070]                   }
[16:04:34.070]                 }, immediateCondition = function(cond) {
[16:04:34.070]                   save_rds <- function (object, pathname, ...) 
[16:04:34.070]                   {
[16:04:34.070]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.070]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.070]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.070]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.070]                         fi_tmp[["mtime"]])
[16:04:34.070]                     }
[16:04:34.070]                     tryCatch({
[16:04:34.070]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.070]                     }, error = function(ex) {
[16:04:34.070]                       msg <- conditionMessage(ex)
[16:04:34.070]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.070]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.070]                         fi_tmp[["mtime"]], msg)
[16:04:34.070]                       ex$message <- msg
[16:04:34.070]                       stop(ex)
[16:04:34.070]                     })
[16:04:34.070]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.070]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.070]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.070]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.070]                       fi <- file.info(pathname)
[16:04:34.070]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.070]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.070]                         fi[["size"]], fi[["mtime"]])
[16:04:34.070]                       stop(msg)
[16:04:34.070]                     }
[16:04:34.070]                     invisible(pathname)
[16:04:34.070]                   }
[16:04:34.070]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.070]                     rootPath = tempdir()) 
[16:04:34.070]                   {
[16:04:34.070]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.070]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.070]                       tmpdir = path, fileext = ".rds")
[16:04:34.070]                     save_rds(obj, file)
[16:04:34.070]                   }
[16:04:34.070]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.070]                   {
[16:04:34.070]                     inherits <- base::inherits
[16:04:34.070]                     invokeRestart <- base::invokeRestart
[16:04:34.070]                     is.null <- base::is.null
[16:04:34.070]                     muffled <- FALSE
[16:04:34.070]                     if (inherits(cond, "message")) {
[16:04:34.070]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.070]                       if (muffled) 
[16:04:34.070]                         invokeRestart("muffleMessage")
[16:04:34.070]                     }
[16:04:34.070]                     else if (inherits(cond, "warning")) {
[16:04:34.070]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.070]                       if (muffled) 
[16:04:34.070]                         invokeRestart("muffleWarning")
[16:04:34.070]                     }
[16:04:34.070]                     else if (inherits(cond, "condition")) {
[16:04:34.070]                       if (!is.null(pattern)) {
[16:04:34.070]                         computeRestarts <- base::computeRestarts
[16:04:34.070]                         grepl <- base::grepl
[16:04:34.070]                         restarts <- computeRestarts(cond)
[16:04:34.070]                         for (restart in restarts) {
[16:04:34.070]                           name <- restart$name
[16:04:34.070]                           if (is.null(name)) 
[16:04:34.070]                             next
[16:04:34.070]                           if (!grepl(pattern, name)) 
[16:04:34.070]                             next
[16:04:34.070]                           invokeRestart(restart)
[16:04:34.070]                           muffled <- TRUE
[16:04:34.070]                           break
[16:04:34.070]                         }
[16:04:34.070]                       }
[16:04:34.070]                     }
[16:04:34.070]                     invisible(muffled)
[16:04:34.070]                   }
[16:04:34.070]                   muffleCondition(cond)
[16:04:34.070]                 })
[16:04:34.070]             }))
[16:04:34.070]             future::FutureResult(value = ...future.value$value, 
[16:04:34.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.070]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.070]                     ...future.globalenv.names))
[16:04:34.070]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.070]         }, condition = base::local({
[16:04:34.070]             c <- base::c
[16:04:34.070]             inherits <- base::inherits
[16:04:34.070]             invokeRestart <- base::invokeRestart
[16:04:34.070]             length <- base::length
[16:04:34.070]             list <- base::list
[16:04:34.070]             seq.int <- base::seq.int
[16:04:34.070]             signalCondition <- base::signalCondition
[16:04:34.070]             sys.calls <- base::sys.calls
[16:04:34.070]             `[[` <- base::`[[`
[16:04:34.070]             `+` <- base::`+`
[16:04:34.070]             `<<-` <- base::`<<-`
[16:04:34.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.070]                   3L)]
[16:04:34.070]             }
[16:04:34.070]             function(cond) {
[16:04:34.070]                 is_error <- inherits(cond, "error")
[16:04:34.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.070]                   NULL)
[16:04:34.070]                 if (is_error) {
[16:04:34.070]                   sessionInformation <- function() {
[16:04:34.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.070]                       search = base::search(), system = base::Sys.info())
[16:04:34.070]                   }
[16:04:34.070]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.070]                     cond$call), session = sessionInformation(), 
[16:04:34.070]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.070]                   signalCondition(cond)
[16:04:34.070]                 }
[16:04:34.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.070]                 "immediateCondition"))) {
[16:04:34.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.070]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.070]                   if (TRUE && !signal) {
[16:04:34.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.070]                     {
[16:04:34.070]                       inherits <- base::inherits
[16:04:34.070]                       invokeRestart <- base::invokeRestart
[16:04:34.070]                       is.null <- base::is.null
[16:04:34.070]                       muffled <- FALSE
[16:04:34.070]                       if (inherits(cond, "message")) {
[16:04:34.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.070]                         if (muffled) 
[16:04:34.070]                           invokeRestart("muffleMessage")
[16:04:34.070]                       }
[16:04:34.070]                       else if (inherits(cond, "warning")) {
[16:04:34.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.070]                         if (muffled) 
[16:04:34.070]                           invokeRestart("muffleWarning")
[16:04:34.070]                       }
[16:04:34.070]                       else if (inherits(cond, "condition")) {
[16:04:34.070]                         if (!is.null(pattern)) {
[16:04:34.070]                           computeRestarts <- base::computeRestarts
[16:04:34.070]                           grepl <- base::grepl
[16:04:34.070]                           restarts <- computeRestarts(cond)
[16:04:34.070]                           for (restart in restarts) {
[16:04:34.070]                             name <- restart$name
[16:04:34.070]                             if (is.null(name)) 
[16:04:34.070]                               next
[16:04:34.070]                             if (!grepl(pattern, name)) 
[16:04:34.070]                               next
[16:04:34.070]                             invokeRestart(restart)
[16:04:34.070]                             muffled <- TRUE
[16:04:34.070]                             break
[16:04:34.070]                           }
[16:04:34.070]                         }
[16:04:34.070]                       }
[16:04:34.070]                       invisible(muffled)
[16:04:34.070]                     }
[16:04:34.070]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.070]                   }
[16:04:34.070]                 }
[16:04:34.070]                 else {
[16:04:34.070]                   if (TRUE) {
[16:04:34.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.070]                     {
[16:04:34.070]                       inherits <- base::inherits
[16:04:34.070]                       invokeRestart <- base::invokeRestart
[16:04:34.070]                       is.null <- base::is.null
[16:04:34.070]                       muffled <- FALSE
[16:04:34.070]                       if (inherits(cond, "message")) {
[16:04:34.070]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.070]                         if (muffled) 
[16:04:34.070]                           invokeRestart("muffleMessage")
[16:04:34.070]                       }
[16:04:34.070]                       else if (inherits(cond, "warning")) {
[16:04:34.070]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.070]                         if (muffled) 
[16:04:34.070]                           invokeRestart("muffleWarning")
[16:04:34.070]                       }
[16:04:34.070]                       else if (inherits(cond, "condition")) {
[16:04:34.070]                         if (!is.null(pattern)) {
[16:04:34.070]                           computeRestarts <- base::computeRestarts
[16:04:34.070]                           grepl <- base::grepl
[16:04:34.070]                           restarts <- computeRestarts(cond)
[16:04:34.070]                           for (restart in restarts) {
[16:04:34.070]                             name <- restart$name
[16:04:34.070]                             if (is.null(name)) 
[16:04:34.070]                               next
[16:04:34.070]                             if (!grepl(pattern, name)) 
[16:04:34.070]                               next
[16:04:34.070]                             invokeRestart(restart)
[16:04:34.070]                             muffled <- TRUE
[16:04:34.070]                             break
[16:04:34.070]                           }
[16:04:34.070]                         }
[16:04:34.070]                       }
[16:04:34.070]                       invisible(muffled)
[16:04:34.070]                     }
[16:04:34.070]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.070]                   }
[16:04:34.070]                 }
[16:04:34.070]             }
[16:04:34.070]         }))
[16:04:34.070]     }, error = function(ex) {
[16:04:34.070]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.070]                 ...future.rng), started = ...future.startTime, 
[16:04:34.070]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.070]             version = "1.8"), class = "FutureResult")
[16:04:34.070]     }, finally = {
[16:04:34.070]         if (!identical(...future.workdir, getwd())) 
[16:04:34.070]             setwd(...future.workdir)
[16:04:34.070]         {
[16:04:34.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.070]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.070]             }
[16:04:34.070]             base::options(...future.oldOptions)
[16:04:34.070]             if (.Platform$OS.type == "windows") {
[16:04:34.070]                 old_names <- names(...future.oldEnvVars)
[16:04:34.070]                 envs <- base::Sys.getenv()
[16:04:34.070]                 names <- names(envs)
[16:04:34.070]                 common <- intersect(names, old_names)
[16:04:34.070]                 added <- setdiff(names, old_names)
[16:04:34.070]                 removed <- setdiff(old_names, names)
[16:04:34.070]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.070]                   envs[common]]
[16:04:34.070]                 NAMES <- toupper(changed)
[16:04:34.070]                 args <- list()
[16:04:34.070]                 for (kk in seq_along(NAMES)) {
[16:04:34.070]                   name <- changed[[kk]]
[16:04:34.070]                   NAME <- NAMES[[kk]]
[16:04:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.070]                     next
[16:04:34.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.070]                 }
[16:04:34.070]                 NAMES <- toupper(added)
[16:04:34.070]                 for (kk in seq_along(NAMES)) {
[16:04:34.070]                   name <- added[[kk]]
[16:04:34.070]                   NAME <- NAMES[[kk]]
[16:04:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.070]                     next
[16:04:34.070]                   args[[name]] <- ""
[16:04:34.070]                 }
[16:04:34.070]                 NAMES <- toupper(removed)
[16:04:34.070]                 for (kk in seq_along(NAMES)) {
[16:04:34.070]                   name <- removed[[kk]]
[16:04:34.070]                   NAME <- NAMES[[kk]]
[16:04:34.070]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.070]                     next
[16:04:34.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.070]                 }
[16:04:34.070]                 if (length(args) > 0) 
[16:04:34.070]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.070]             }
[16:04:34.070]             else {
[16:04:34.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.070]             }
[16:04:34.070]             {
[16:04:34.070]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.070]                   0L) {
[16:04:34.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.070]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.070]                   base::options(opts)
[16:04:34.070]                 }
[16:04:34.070]                 {
[16:04:34.070]                   {
[16:04:34.070]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.070]                     NULL
[16:04:34.070]                   }
[16:04:34.070]                   options(future.plan = NULL)
[16:04:34.070]                   if (is.na(NA_character_)) 
[16:04:34.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.070]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.070]                     envir = parent.frame()) 
[16:04:34.070]                   {
[16:04:34.070]                     default_workers <- missing(workers)
[16:04:34.070]                     if (is.function(workers)) 
[16:04:34.070]                       workers <- workers()
[16:04:34.070]                     workers <- structure(as.integer(workers), 
[16:04:34.070]                       class = class(workers))
[16:04:34.070]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.070]                       1L)
[16:04:34.070]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.070]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.070]                       if (default_workers) 
[16:04:34.070]                         supportsMulticore(warn = TRUE)
[16:04:34.070]                       return(sequential(..., envir = envir))
[16:04:34.070]                     }
[16:04:34.070]                     oopts <- options(mc.cores = workers)
[16:04:34.070]                     on.exit(options(oopts))
[16:04:34.070]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.070]                       envir = envir)
[16:04:34.070]                     if (!future$lazy) 
[16:04:34.070]                       future <- run(future)
[16:04:34.070]                     invisible(future)
[16:04:34.070]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.070]                 }
[16:04:34.070]             }
[16:04:34.070]         }
[16:04:34.070]     })
[16:04:34.070]     if (TRUE) {
[16:04:34.070]         base::sink(type = "output", split = FALSE)
[16:04:34.070]         if (TRUE) {
[16:04:34.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.070]         }
[16:04:34.070]         else {
[16:04:34.070]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.070]         }
[16:04:34.070]         base::close(...future.stdout)
[16:04:34.070]         ...future.stdout <- NULL
[16:04:34.070]     }
[16:04:34.070]     ...future.result$conditions <- ...future.conditions
[16:04:34.070]     ...future.result$finished <- base::Sys.time()
[16:04:34.070]     ...future.result
[16:04:34.070] }
[16:04:34.073] requestCore(): workers = 2
[16:04:34.078] MulticoreFuture started
[16:04:34.079] - Launch lazy future ... done
[16:04:34.079] run() for ‘MulticoreFuture’ ... done
[16:04:34.080] plan(): Setting new future strategy stack:
[16:04:34.080] result() for MulticoreFuture ...
[16:04:34.080] List of future strategies:
[16:04:34.080] 1. sequential:
[16:04:34.080]    - args: function (..., envir = parent.frame())
[16:04:34.080]    - tweaked: FALSE
[16:04:34.080]    - call: NULL
[16:04:34.081] plan(): nbrOfWorkers() = 1
[16:04:34.083] plan(): Setting new future strategy stack:
[16:04:34.083] result() for MulticoreFuture ...
[16:04:34.083] List of future strategies:
[16:04:34.083] 1. multicore:
[16:04:34.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.083]    - tweaked: FALSE
[16:04:34.083]    - call: plan(strategy)
[16:04:34.083] result() for MulticoreFuture ... done
[16:04:34.083] result() for MulticoreFuture ... done
[16:04:34.083] result() for MulticoreFuture ...
[16:04:34.084] result() for MulticoreFuture ... done
u$a = 2
[16:04:34.084] result() for MulticoreFuture ...
[16:04:34.092] plan(): nbrOfWorkers() = 2
[16:04:34.092] result() for MulticoreFuture ...
[16:04:34.092] result() for MulticoreFuture ... done
[16:04:34.095] result() for MulticoreFuture ... done
[16:04:34.095] result() for MulticoreFuture ...
[16:04:34.095] result() for MulticoreFuture ... done
v$a = 4
[16:04:34.095] getGlobalsAndPackages() ...
[16:04:34.096] Searching for globals...
[16:04:34.097] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.097] Searching for globals ... DONE
[16:04:34.097] Resolving globals: FALSE
[16:04:34.098] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.098] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.099] - globals: [1] ‘a’
[16:04:34.099] 
[16:04:34.099] getGlobalsAndPackages() ... DONE
[16:04:34.099] run() for ‘Future’ ...
[16:04:34.099] - state: ‘created’
[16:04:34.099] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.103] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.104]   - Field: ‘label’
[16:04:34.104]   - Field: ‘local’
[16:04:34.104]   - Field: ‘owner’
[16:04:34.104]   - Field: ‘envir’
[16:04:34.104]   - Field: ‘workers’
[16:04:34.104]   - Field: ‘packages’
[16:04:34.104]   - Field: ‘gc’
[16:04:34.104]   - Field: ‘job’
[16:04:34.104]   - Field: ‘conditions’
[16:04:34.105]   - Field: ‘expr’
[16:04:34.105]   - Field: ‘uuid’
[16:04:34.105]   - Field: ‘seed’
[16:04:34.105]   - Field: ‘version’
[16:04:34.105]   - Field: ‘result’
[16:04:34.105]   - Field: ‘asynchronous’
[16:04:34.105]   - Field: ‘calls’
[16:04:34.105]   - Field: ‘globals’
[16:04:34.105]   - Field: ‘stdout’
[16:04:34.106]   - Field: ‘earlySignal’
[16:04:34.106]   - Field: ‘lazy’
[16:04:34.106]   - Field: ‘state’
[16:04:34.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.106] - Launch lazy future ...
[16:04:34.106] Packages needed by the future expression (n = 0): <none>
[16:04:34.106] Packages needed by future strategies (n = 0): <none>
[16:04:34.107] {
[16:04:34.107]     {
[16:04:34.107]         {
[16:04:34.107]             ...future.startTime <- base::Sys.time()
[16:04:34.107]             {
[16:04:34.107]                 {
[16:04:34.107]                   {
[16:04:34.107]                     {
[16:04:34.107]                       base::local({
[16:04:34.107]                         has_future <- base::requireNamespace("future", 
[16:04:34.107]                           quietly = TRUE)
[16:04:34.107]                         if (has_future) {
[16:04:34.107]                           ns <- base::getNamespace("future")
[16:04:34.107]                           version <- ns[[".package"]][["version"]]
[16:04:34.107]                           if (is.null(version)) 
[16:04:34.107]                             version <- utils::packageVersion("future")
[16:04:34.107]                         }
[16:04:34.107]                         else {
[16:04:34.107]                           version <- NULL
[16:04:34.107]                         }
[16:04:34.107]                         if (!has_future || version < "1.8.0") {
[16:04:34.107]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.107]                             "", base::R.version$version.string), 
[16:04:34.107]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.107]                               "release", "version")], collapse = " "), 
[16:04:34.107]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.107]                             info)
[16:04:34.107]                           info <- base::paste(info, collapse = "; ")
[16:04:34.107]                           if (!has_future) {
[16:04:34.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.107]                               info)
[16:04:34.107]                           }
[16:04:34.107]                           else {
[16:04:34.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.107]                               info, version)
[16:04:34.107]                           }
[16:04:34.107]                           base::stop(msg)
[16:04:34.107]                         }
[16:04:34.107]                       })
[16:04:34.107]                     }
[16:04:34.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.107]                     base::options(mc.cores = 1L)
[16:04:34.107]                   }
[16:04:34.107]                   options(future.plan = NULL)
[16:04:34.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.107]                 }
[16:04:34.107]                 ...future.workdir <- getwd()
[16:04:34.107]             }
[16:04:34.107]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.107]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.107]         }
[16:04:34.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.107]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.107]             base::names(...future.oldOptions))
[16:04:34.107]     }
[16:04:34.107]     if (FALSE) {
[16:04:34.107]     }
[16:04:34.107]     else {
[16:04:34.107]         if (TRUE) {
[16:04:34.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.107]                 open = "w")
[16:04:34.107]         }
[16:04:34.107]         else {
[16:04:34.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.107]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.107]         }
[16:04:34.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.107]             base::sink(type = "output", split = FALSE)
[16:04:34.107]             base::close(...future.stdout)
[16:04:34.107]         }, add = TRUE)
[16:04:34.107]     }
[16:04:34.107]     ...future.frame <- base::sys.nframe()
[16:04:34.107]     ...future.conditions <- base::list()
[16:04:34.107]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.107]     if (FALSE) {
[16:04:34.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.107]     }
[16:04:34.107]     ...future.result <- base::tryCatch({
[16:04:34.107]         base::withCallingHandlers({
[16:04:34.107]             ...future.value <- base::withVisible(base::local({
[16:04:34.107]                 withCallingHandlers({
[16:04:34.107]                   {
[16:04:34.107]                     2 * a
[16:04:34.107]                   }
[16:04:34.107]                 }, immediateCondition = function(cond) {
[16:04:34.107]                   save_rds <- function (object, pathname, ...) 
[16:04:34.107]                   {
[16:04:34.107]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.107]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.107]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.107]                         fi_tmp[["mtime"]])
[16:04:34.107]                     }
[16:04:34.107]                     tryCatch({
[16:04:34.107]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.107]                     }, error = function(ex) {
[16:04:34.107]                       msg <- conditionMessage(ex)
[16:04:34.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.107]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.107]                         fi_tmp[["mtime"]], msg)
[16:04:34.107]                       ex$message <- msg
[16:04:34.107]                       stop(ex)
[16:04:34.107]                     })
[16:04:34.107]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.107]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.107]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.107]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.107]                       fi <- file.info(pathname)
[16:04:34.107]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.107]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.107]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.107]                         fi[["size"]], fi[["mtime"]])
[16:04:34.107]                       stop(msg)
[16:04:34.107]                     }
[16:04:34.107]                     invisible(pathname)
[16:04:34.107]                   }
[16:04:34.107]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.107]                     rootPath = tempdir()) 
[16:04:34.107]                   {
[16:04:34.107]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.107]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.107]                       tmpdir = path, fileext = ".rds")
[16:04:34.107]                     save_rds(obj, file)
[16:04:34.107]                   }
[16:04:34.107]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.107]                   {
[16:04:34.107]                     inherits <- base::inherits
[16:04:34.107]                     invokeRestart <- base::invokeRestart
[16:04:34.107]                     is.null <- base::is.null
[16:04:34.107]                     muffled <- FALSE
[16:04:34.107]                     if (inherits(cond, "message")) {
[16:04:34.107]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.107]                       if (muffled) 
[16:04:34.107]                         invokeRestart("muffleMessage")
[16:04:34.107]                     }
[16:04:34.107]                     else if (inherits(cond, "warning")) {
[16:04:34.107]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.107]                       if (muffled) 
[16:04:34.107]                         invokeRestart("muffleWarning")
[16:04:34.107]                     }
[16:04:34.107]                     else if (inherits(cond, "condition")) {
[16:04:34.107]                       if (!is.null(pattern)) {
[16:04:34.107]                         computeRestarts <- base::computeRestarts
[16:04:34.107]                         grepl <- base::grepl
[16:04:34.107]                         restarts <- computeRestarts(cond)
[16:04:34.107]                         for (restart in restarts) {
[16:04:34.107]                           name <- restart$name
[16:04:34.107]                           if (is.null(name)) 
[16:04:34.107]                             next
[16:04:34.107]                           if (!grepl(pattern, name)) 
[16:04:34.107]                             next
[16:04:34.107]                           invokeRestart(restart)
[16:04:34.107]                           muffled <- TRUE
[16:04:34.107]                           break
[16:04:34.107]                         }
[16:04:34.107]                       }
[16:04:34.107]                     }
[16:04:34.107]                     invisible(muffled)
[16:04:34.107]                   }
[16:04:34.107]                   muffleCondition(cond)
[16:04:34.107]                 })
[16:04:34.107]             }))
[16:04:34.107]             future::FutureResult(value = ...future.value$value, 
[16:04:34.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.107]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.107]                     ...future.globalenv.names))
[16:04:34.107]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.107]         }, condition = base::local({
[16:04:34.107]             c <- base::c
[16:04:34.107]             inherits <- base::inherits
[16:04:34.107]             invokeRestart <- base::invokeRestart
[16:04:34.107]             length <- base::length
[16:04:34.107]             list <- base::list
[16:04:34.107]             seq.int <- base::seq.int
[16:04:34.107]             signalCondition <- base::signalCondition
[16:04:34.107]             sys.calls <- base::sys.calls
[16:04:34.107]             `[[` <- base::`[[`
[16:04:34.107]             `+` <- base::`+`
[16:04:34.107]             `<<-` <- base::`<<-`
[16:04:34.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.107]                   3L)]
[16:04:34.107]             }
[16:04:34.107]             function(cond) {
[16:04:34.107]                 is_error <- inherits(cond, "error")
[16:04:34.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.107]                   NULL)
[16:04:34.107]                 if (is_error) {
[16:04:34.107]                   sessionInformation <- function() {
[16:04:34.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.107]                       search = base::search(), system = base::Sys.info())
[16:04:34.107]                   }
[16:04:34.107]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.107]                     cond$call), session = sessionInformation(), 
[16:04:34.107]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.107]                   signalCondition(cond)
[16:04:34.107]                 }
[16:04:34.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.107]                 "immediateCondition"))) {
[16:04:34.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.107]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.107]                   if (TRUE && !signal) {
[16:04:34.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.107]                     {
[16:04:34.107]                       inherits <- base::inherits
[16:04:34.107]                       invokeRestart <- base::invokeRestart
[16:04:34.107]                       is.null <- base::is.null
[16:04:34.107]                       muffled <- FALSE
[16:04:34.107]                       if (inherits(cond, "message")) {
[16:04:34.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.107]                         if (muffled) 
[16:04:34.107]                           invokeRestart("muffleMessage")
[16:04:34.107]                       }
[16:04:34.107]                       else if (inherits(cond, "warning")) {
[16:04:34.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.107]                         if (muffled) 
[16:04:34.107]                           invokeRestart("muffleWarning")
[16:04:34.107]                       }
[16:04:34.107]                       else if (inherits(cond, "condition")) {
[16:04:34.107]                         if (!is.null(pattern)) {
[16:04:34.107]                           computeRestarts <- base::computeRestarts
[16:04:34.107]                           grepl <- base::grepl
[16:04:34.107]                           restarts <- computeRestarts(cond)
[16:04:34.107]                           for (restart in restarts) {
[16:04:34.107]                             name <- restart$name
[16:04:34.107]                             if (is.null(name)) 
[16:04:34.107]                               next
[16:04:34.107]                             if (!grepl(pattern, name)) 
[16:04:34.107]                               next
[16:04:34.107]                             invokeRestart(restart)
[16:04:34.107]                             muffled <- TRUE
[16:04:34.107]                             break
[16:04:34.107]                           }
[16:04:34.107]                         }
[16:04:34.107]                       }
[16:04:34.107]                       invisible(muffled)
[16:04:34.107]                     }
[16:04:34.107]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.107]                   }
[16:04:34.107]                 }
[16:04:34.107]                 else {
[16:04:34.107]                   if (TRUE) {
[16:04:34.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.107]                     {
[16:04:34.107]                       inherits <- base::inherits
[16:04:34.107]                       invokeRestart <- base::invokeRestart
[16:04:34.107]                       is.null <- base::is.null
[16:04:34.107]                       muffled <- FALSE
[16:04:34.107]                       if (inherits(cond, "message")) {
[16:04:34.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.107]                         if (muffled) 
[16:04:34.107]                           invokeRestart("muffleMessage")
[16:04:34.107]                       }
[16:04:34.107]                       else if (inherits(cond, "warning")) {
[16:04:34.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.107]                         if (muffled) 
[16:04:34.107]                           invokeRestart("muffleWarning")
[16:04:34.107]                       }
[16:04:34.107]                       else if (inherits(cond, "condition")) {
[16:04:34.107]                         if (!is.null(pattern)) {
[16:04:34.107]                           computeRestarts <- base::computeRestarts
[16:04:34.107]                           grepl <- base::grepl
[16:04:34.107]                           restarts <- computeRestarts(cond)
[16:04:34.107]                           for (restart in restarts) {
[16:04:34.107]                             name <- restart$name
[16:04:34.107]                             if (is.null(name)) 
[16:04:34.107]                               next
[16:04:34.107]                             if (!grepl(pattern, name)) 
[16:04:34.107]                               next
[16:04:34.107]                             invokeRestart(restart)
[16:04:34.107]                             muffled <- TRUE
[16:04:34.107]                             break
[16:04:34.107]                           }
[16:04:34.107]                         }
[16:04:34.107]                       }
[16:04:34.107]                       invisible(muffled)
[16:04:34.107]                     }
[16:04:34.107]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.107]                   }
[16:04:34.107]                 }
[16:04:34.107]             }
[16:04:34.107]         }))
[16:04:34.107]     }, error = function(ex) {
[16:04:34.107]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.107]                 ...future.rng), started = ...future.startTime, 
[16:04:34.107]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.107]             version = "1.8"), class = "FutureResult")
[16:04:34.107]     }, finally = {
[16:04:34.107]         if (!identical(...future.workdir, getwd())) 
[16:04:34.107]             setwd(...future.workdir)
[16:04:34.107]         {
[16:04:34.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.107]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.107]             }
[16:04:34.107]             base::options(...future.oldOptions)
[16:04:34.107]             if (.Platform$OS.type == "windows") {
[16:04:34.107]                 old_names <- names(...future.oldEnvVars)
[16:04:34.107]                 envs <- base::Sys.getenv()
[16:04:34.107]                 names <- names(envs)
[16:04:34.107]                 common <- intersect(names, old_names)
[16:04:34.107]                 added <- setdiff(names, old_names)
[16:04:34.107]                 removed <- setdiff(old_names, names)
[16:04:34.107]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.107]                   envs[common]]
[16:04:34.107]                 NAMES <- toupper(changed)
[16:04:34.107]                 args <- list()
[16:04:34.107]                 for (kk in seq_along(NAMES)) {
[16:04:34.107]                   name <- changed[[kk]]
[16:04:34.107]                   NAME <- NAMES[[kk]]
[16:04:34.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.107]                     next
[16:04:34.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.107]                 }
[16:04:34.107]                 NAMES <- toupper(added)
[16:04:34.107]                 for (kk in seq_along(NAMES)) {
[16:04:34.107]                   name <- added[[kk]]
[16:04:34.107]                   NAME <- NAMES[[kk]]
[16:04:34.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.107]                     next
[16:04:34.107]                   args[[name]] <- ""
[16:04:34.107]                 }
[16:04:34.107]                 NAMES <- toupper(removed)
[16:04:34.107]                 for (kk in seq_along(NAMES)) {
[16:04:34.107]                   name <- removed[[kk]]
[16:04:34.107]                   NAME <- NAMES[[kk]]
[16:04:34.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.107]                     next
[16:04:34.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.107]                 }
[16:04:34.107]                 if (length(args) > 0) 
[16:04:34.107]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.107]             }
[16:04:34.107]             else {
[16:04:34.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.107]             }
[16:04:34.107]             {
[16:04:34.107]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.107]                   0L) {
[16:04:34.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.107]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.107]                   base::options(opts)
[16:04:34.107]                 }
[16:04:34.107]                 {
[16:04:34.107]                   {
[16:04:34.107]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.107]                     NULL
[16:04:34.107]                   }
[16:04:34.107]                   options(future.plan = NULL)
[16:04:34.107]                   if (is.na(NA_character_)) 
[16:04:34.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.107]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.107]                     envir = parent.frame()) 
[16:04:34.107]                   {
[16:04:34.107]                     default_workers <- missing(workers)
[16:04:34.107]                     if (is.function(workers)) 
[16:04:34.107]                       workers <- workers()
[16:04:34.107]                     workers <- structure(as.integer(workers), 
[16:04:34.107]                       class = class(workers))
[16:04:34.107]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.107]                       1L)
[16:04:34.107]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.107]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.107]                       if (default_workers) 
[16:04:34.107]                         supportsMulticore(warn = TRUE)
[16:04:34.107]                       return(sequential(..., envir = envir))
[16:04:34.107]                     }
[16:04:34.107]                     oopts <- options(mc.cores = workers)
[16:04:34.107]                     on.exit(options(oopts))
[16:04:34.107]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.107]                       envir = envir)
[16:04:34.107]                     if (!future$lazy) 
[16:04:34.107]                       future <- run(future)
[16:04:34.107]                     invisible(future)
[16:04:34.107]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.107]                 }
[16:04:34.107]             }
[16:04:34.107]         }
[16:04:34.107]     })
[16:04:34.107]     if (TRUE) {
[16:04:34.107]         base::sink(type = "output", split = FALSE)
[16:04:34.107]         if (TRUE) {
[16:04:34.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.107]         }
[16:04:34.107]         else {
[16:04:34.107]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.107]         }
[16:04:34.107]         base::close(...future.stdout)
[16:04:34.107]         ...future.stdout <- NULL
[16:04:34.107]     }
[16:04:34.107]     ...future.result$conditions <- ...future.conditions
[16:04:34.107]     ...future.result$finished <- base::Sys.time()
[16:04:34.107]     ...future.result
[16:04:34.107] }
[16:04:34.109] assign_globals() ...
[16:04:34.109] List of 1
[16:04:34.109]  $ a: num 1
[16:04:34.109]  - attr(*, "where")=List of 1
[16:04:34.109]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.109]  - attr(*, "resolved")= logi FALSE
[16:04:34.109]  - attr(*, "total_size")= num 56
[16:04:34.109]  - attr(*, "already-done")= logi TRUE
[16:04:34.113] - copied ‘a’ to environment
[16:04:34.113] assign_globals() ... done
[16:04:34.113] requestCore(): workers = 2
[16:04:34.114] MulticoreFuture started
[16:04:34.115] - Launch lazy future ... done
[16:04:34.115] run() for ‘MulticoreFuture’ ... done
[16:04:34.115] result() for MulticoreFuture ...
[16:04:34.116] plan(): Setting new future strategy stack:
[16:04:34.116] List of future strategies:
[16:04:34.116] 1. sequential:
[16:04:34.116]    - args: function (..., envir = parent.frame())
[16:04:34.116]    - tweaked: FALSE
[16:04:34.116]    - call: NULL
[16:04:34.117] plan(): nbrOfWorkers() = 1
[16:04:34.118] plan(): Setting new future strategy stack:
[16:04:34.119] List of future strategies:
[16:04:34.119] 1. multicore:
[16:04:34.119]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.119]    - tweaked: FALSE
[16:04:34.119]    - call: plan(strategy)
[16:04:34.124] plan(): nbrOfWorkers() = 2
[16:04:34.124] result() for MulticoreFuture ...
[16:04:34.124] result() for MulticoreFuture ... done
[16:04:34.125] result() for MulticoreFuture ... done
[16:04:34.125] result() for MulticoreFuture ...
[16:04:34.125] result() for MulticoreFuture ... done
[16:04:34.125] getGlobalsAndPackages() ...
[16:04:34.125] Searching for globals...
[16:04:34.126] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.127] Searching for globals ... DONE
[16:04:34.127] Resolving globals: FALSE
[16:04:34.127] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.128] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.128] - globals: [1] ‘a’
[16:04:34.128] 
[16:04:34.128] getGlobalsAndPackages() ... DONE
[16:04:34.129] run() for ‘Future’ ...
[16:04:34.129] - state: ‘created’
[16:04:34.129] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.133]   - Field: ‘label’
[16:04:34.133]   - Field: ‘local’
[16:04:34.133]   - Field: ‘owner’
[16:04:34.133]   - Field: ‘envir’
[16:04:34.134]   - Field: ‘workers’
[16:04:34.134]   - Field: ‘packages’
[16:04:34.134]   - Field: ‘gc’
[16:04:34.134]   - Field: ‘job’
[16:04:34.134]   - Field: ‘conditions’
[16:04:34.134]   - Field: ‘expr’
[16:04:34.134]   - Field: ‘uuid’
[16:04:34.134]   - Field: ‘seed’
[16:04:34.135]   - Field: ‘version’
[16:04:34.135]   - Field: ‘result’
[16:04:34.135]   - Field: ‘asynchronous’
[16:04:34.135]   - Field: ‘calls’
[16:04:34.135]   - Field: ‘globals’
[16:04:34.135]   - Field: ‘stdout’
[16:04:34.135]   - Field: ‘earlySignal’
[16:04:34.135]   - Field: ‘lazy’
[16:04:34.135]   - Field: ‘state’
[16:04:34.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.136] - Launch lazy future ...
[16:04:34.136] Packages needed by the future expression (n = 0): <none>
[16:04:34.136] Packages needed by future strategies (n = 0): <none>
[16:04:34.137] {
[16:04:34.137]     {
[16:04:34.137]         {
[16:04:34.137]             ...future.startTime <- base::Sys.time()
[16:04:34.137]             {
[16:04:34.137]                 {
[16:04:34.137]                   {
[16:04:34.137]                     {
[16:04:34.137]                       base::local({
[16:04:34.137]                         has_future <- base::requireNamespace("future", 
[16:04:34.137]                           quietly = TRUE)
[16:04:34.137]                         if (has_future) {
[16:04:34.137]                           ns <- base::getNamespace("future")
[16:04:34.137]                           version <- ns[[".package"]][["version"]]
[16:04:34.137]                           if (is.null(version)) 
[16:04:34.137]                             version <- utils::packageVersion("future")
[16:04:34.137]                         }
[16:04:34.137]                         else {
[16:04:34.137]                           version <- NULL
[16:04:34.137]                         }
[16:04:34.137]                         if (!has_future || version < "1.8.0") {
[16:04:34.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.137]                             "", base::R.version$version.string), 
[16:04:34.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.137]                               "release", "version")], collapse = " "), 
[16:04:34.137]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.137]                             info)
[16:04:34.137]                           info <- base::paste(info, collapse = "; ")
[16:04:34.137]                           if (!has_future) {
[16:04:34.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.137]                               info)
[16:04:34.137]                           }
[16:04:34.137]                           else {
[16:04:34.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.137]                               info, version)
[16:04:34.137]                           }
[16:04:34.137]                           base::stop(msg)
[16:04:34.137]                         }
[16:04:34.137]                       })
[16:04:34.137]                     }
[16:04:34.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.137]                     base::options(mc.cores = 1L)
[16:04:34.137]                   }
[16:04:34.137]                   options(future.plan = NULL)
[16:04:34.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.137]                 }
[16:04:34.137]                 ...future.workdir <- getwd()
[16:04:34.137]             }
[16:04:34.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.137]         }
[16:04:34.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.137]             base::names(...future.oldOptions))
[16:04:34.137]     }
[16:04:34.137]     if (FALSE) {
[16:04:34.137]     }
[16:04:34.137]     else {
[16:04:34.137]         if (TRUE) {
[16:04:34.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.137]                 open = "w")
[16:04:34.137]         }
[16:04:34.137]         else {
[16:04:34.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.137]         }
[16:04:34.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.137]             base::sink(type = "output", split = FALSE)
[16:04:34.137]             base::close(...future.stdout)
[16:04:34.137]         }, add = TRUE)
[16:04:34.137]     }
[16:04:34.137]     ...future.frame <- base::sys.nframe()
[16:04:34.137]     ...future.conditions <- base::list()
[16:04:34.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.137]     if (FALSE) {
[16:04:34.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.137]     }
[16:04:34.137]     ...future.result <- base::tryCatch({
[16:04:34.137]         base::withCallingHandlers({
[16:04:34.137]             ...future.value <- base::withVisible(base::local({
[16:04:34.137]                 withCallingHandlers({
[16:04:34.137]                   {
[16:04:34.137]                     2 * a
[16:04:34.137]                   }
[16:04:34.137]                 }, immediateCondition = function(cond) {
[16:04:34.137]                   save_rds <- function (object, pathname, ...) 
[16:04:34.137]                   {
[16:04:34.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.137]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.137]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.137]                         fi_tmp[["mtime"]])
[16:04:34.137]                     }
[16:04:34.137]                     tryCatch({
[16:04:34.137]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.137]                     }, error = function(ex) {
[16:04:34.137]                       msg <- conditionMessage(ex)
[16:04:34.137]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.137]                         fi_tmp[["mtime"]], msg)
[16:04:34.137]                       ex$message <- msg
[16:04:34.137]                       stop(ex)
[16:04:34.137]                     })
[16:04:34.137]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.137]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.137]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.137]                       fi <- file.info(pathname)
[16:04:34.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.137]                         fi[["size"]], fi[["mtime"]])
[16:04:34.137]                       stop(msg)
[16:04:34.137]                     }
[16:04:34.137]                     invisible(pathname)
[16:04:34.137]                   }
[16:04:34.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.137]                     rootPath = tempdir()) 
[16:04:34.137]                   {
[16:04:34.137]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.137]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.137]                       tmpdir = path, fileext = ".rds")
[16:04:34.137]                     save_rds(obj, file)
[16:04:34.137]                   }
[16:04:34.137]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.137]                   {
[16:04:34.137]                     inherits <- base::inherits
[16:04:34.137]                     invokeRestart <- base::invokeRestart
[16:04:34.137]                     is.null <- base::is.null
[16:04:34.137]                     muffled <- FALSE
[16:04:34.137]                     if (inherits(cond, "message")) {
[16:04:34.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.137]                       if (muffled) 
[16:04:34.137]                         invokeRestart("muffleMessage")
[16:04:34.137]                     }
[16:04:34.137]                     else if (inherits(cond, "warning")) {
[16:04:34.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.137]                       if (muffled) 
[16:04:34.137]                         invokeRestart("muffleWarning")
[16:04:34.137]                     }
[16:04:34.137]                     else if (inherits(cond, "condition")) {
[16:04:34.137]                       if (!is.null(pattern)) {
[16:04:34.137]                         computeRestarts <- base::computeRestarts
[16:04:34.137]                         grepl <- base::grepl
[16:04:34.137]                         restarts <- computeRestarts(cond)
[16:04:34.137]                         for (restart in restarts) {
[16:04:34.137]                           name <- restart$name
[16:04:34.137]                           if (is.null(name)) 
[16:04:34.137]                             next
[16:04:34.137]                           if (!grepl(pattern, name)) 
[16:04:34.137]                             next
[16:04:34.137]                           invokeRestart(restart)
[16:04:34.137]                           muffled <- TRUE
[16:04:34.137]                           break
[16:04:34.137]                         }
[16:04:34.137]                       }
[16:04:34.137]                     }
[16:04:34.137]                     invisible(muffled)
[16:04:34.137]                   }
[16:04:34.137]                   muffleCondition(cond)
[16:04:34.137]                 })
[16:04:34.137]             }))
[16:04:34.137]             future::FutureResult(value = ...future.value$value, 
[16:04:34.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.137]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.137]                     ...future.globalenv.names))
[16:04:34.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.137]         }, condition = base::local({
[16:04:34.137]             c <- base::c
[16:04:34.137]             inherits <- base::inherits
[16:04:34.137]             invokeRestart <- base::invokeRestart
[16:04:34.137]             length <- base::length
[16:04:34.137]             list <- base::list
[16:04:34.137]             seq.int <- base::seq.int
[16:04:34.137]             signalCondition <- base::signalCondition
[16:04:34.137]             sys.calls <- base::sys.calls
[16:04:34.137]             `[[` <- base::`[[`
[16:04:34.137]             `+` <- base::`+`
[16:04:34.137]             `<<-` <- base::`<<-`
[16:04:34.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.137]                   3L)]
[16:04:34.137]             }
[16:04:34.137]             function(cond) {
[16:04:34.137]                 is_error <- inherits(cond, "error")
[16:04:34.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.137]                   NULL)
[16:04:34.137]                 if (is_error) {
[16:04:34.137]                   sessionInformation <- function() {
[16:04:34.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.137]                       search = base::search(), system = base::Sys.info())
[16:04:34.137]                   }
[16:04:34.137]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.137]                     cond$call), session = sessionInformation(), 
[16:04:34.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.137]                   signalCondition(cond)
[16:04:34.137]                 }
[16:04:34.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.137]                 "immediateCondition"))) {
[16:04:34.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.137]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.137]                   if (TRUE && !signal) {
[16:04:34.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.137]                     {
[16:04:34.137]                       inherits <- base::inherits
[16:04:34.137]                       invokeRestart <- base::invokeRestart
[16:04:34.137]                       is.null <- base::is.null
[16:04:34.137]                       muffled <- FALSE
[16:04:34.137]                       if (inherits(cond, "message")) {
[16:04:34.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.137]                         if (muffled) 
[16:04:34.137]                           invokeRestart("muffleMessage")
[16:04:34.137]                       }
[16:04:34.137]                       else if (inherits(cond, "warning")) {
[16:04:34.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.137]                         if (muffled) 
[16:04:34.137]                           invokeRestart("muffleWarning")
[16:04:34.137]                       }
[16:04:34.137]                       else if (inherits(cond, "condition")) {
[16:04:34.137]                         if (!is.null(pattern)) {
[16:04:34.137]                           computeRestarts <- base::computeRestarts
[16:04:34.137]                           grepl <- base::grepl
[16:04:34.137]                           restarts <- computeRestarts(cond)
[16:04:34.137]                           for (restart in restarts) {
[16:04:34.137]                             name <- restart$name
[16:04:34.137]                             if (is.null(name)) 
[16:04:34.137]                               next
[16:04:34.137]                             if (!grepl(pattern, name)) 
[16:04:34.137]                               next
[16:04:34.137]                             invokeRestart(restart)
[16:04:34.137]                             muffled <- TRUE
[16:04:34.137]                             break
[16:04:34.137]                           }
[16:04:34.137]                         }
[16:04:34.137]                       }
[16:04:34.137]                       invisible(muffled)
[16:04:34.137]                     }
[16:04:34.137]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.137]                   }
[16:04:34.137]                 }
[16:04:34.137]                 else {
[16:04:34.137]                   if (TRUE) {
[16:04:34.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.137]                     {
[16:04:34.137]                       inherits <- base::inherits
[16:04:34.137]                       invokeRestart <- base::invokeRestart
[16:04:34.137]                       is.null <- base::is.null
[16:04:34.137]                       muffled <- FALSE
[16:04:34.137]                       if (inherits(cond, "message")) {
[16:04:34.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.137]                         if (muffled) 
[16:04:34.137]                           invokeRestart("muffleMessage")
[16:04:34.137]                       }
[16:04:34.137]                       else if (inherits(cond, "warning")) {
[16:04:34.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.137]                         if (muffled) 
[16:04:34.137]                           invokeRestart("muffleWarning")
[16:04:34.137]                       }
[16:04:34.137]                       else if (inherits(cond, "condition")) {
[16:04:34.137]                         if (!is.null(pattern)) {
[16:04:34.137]                           computeRestarts <- base::computeRestarts
[16:04:34.137]                           grepl <- base::grepl
[16:04:34.137]                           restarts <- computeRestarts(cond)
[16:04:34.137]                           for (restart in restarts) {
[16:04:34.137]                             name <- restart$name
[16:04:34.137]                             if (is.null(name)) 
[16:04:34.137]                               next
[16:04:34.137]                             if (!grepl(pattern, name)) 
[16:04:34.137]                               next
[16:04:34.137]                             invokeRestart(restart)
[16:04:34.137]                             muffled <- TRUE
[16:04:34.137]                             break
[16:04:34.137]                           }
[16:04:34.137]                         }
[16:04:34.137]                       }
[16:04:34.137]                       invisible(muffled)
[16:04:34.137]                     }
[16:04:34.137]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.137]                   }
[16:04:34.137]                 }
[16:04:34.137]             }
[16:04:34.137]         }))
[16:04:34.137]     }, error = function(ex) {
[16:04:34.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.137]                 ...future.rng), started = ...future.startTime, 
[16:04:34.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.137]             version = "1.8"), class = "FutureResult")
[16:04:34.137]     }, finally = {
[16:04:34.137]         if (!identical(...future.workdir, getwd())) 
[16:04:34.137]             setwd(...future.workdir)
[16:04:34.137]         {
[16:04:34.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.137]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.137]             }
[16:04:34.137]             base::options(...future.oldOptions)
[16:04:34.137]             if (.Platform$OS.type == "windows") {
[16:04:34.137]                 old_names <- names(...future.oldEnvVars)
[16:04:34.137]                 envs <- base::Sys.getenv()
[16:04:34.137]                 names <- names(envs)
[16:04:34.137]                 common <- intersect(names, old_names)
[16:04:34.137]                 added <- setdiff(names, old_names)
[16:04:34.137]                 removed <- setdiff(old_names, names)
[16:04:34.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.137]                   envs[common]]
[16:04:34.137]                 NAMES <- toupper(changed)
[16:04:34.137]                 args <- list()
[16:04:34.137]                 for (kk in seq_along(NAMES)) {
[16:04:34.137]                   name <- changed[[kk]]
[16:04:34.137]                   NAME <- NAMES[[kk]]
[16:04:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.137]                     next
[16:04:34.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.137]                 }
[16:04:34.137]                 NAMES <- toupper(added)
[16:04:34.137]                 for (kk in seq_along(NAMES)) {
[16:04:34.137]                   name <- added[[kk]]
[16:04:34.137]                   NAME <- NAMES[[kk]]
[16:04:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.137]                     next
[16:04:34.137]                   args[[name]] <- ""
[16:04:34.137]                 }
[16:04:34.137]                 NAMES <- toupper(removed)
[16:04:34.137]                 for (kk in seq_along(NAMES)) {
[16:04:34.137]                   name <- removed[[kk]]
[16:04:34.137]                   NAME <- NAMES[[kk]]
[16:04:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.137]                     next
[16:04:34.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.137]                 }
[16:04:34.137]                 if (length(args) > 0) 
[16:04:34.137]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.137]             }
[16:04:34.137]             else {
[16:04:34.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.137]             }
[16:04:34.137]             {
[16:04:34.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.137]                   0L) {
[16:04:34.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.137]                   base::options(opts)
[16:04:34.137]                 }
[16:04:34.137]                 {
[16:04:34.137]                   {
[16:04:34.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.137]                     NULL
[16:04:34.137]                   }
[16:04:34.137]                   options(future.plan = NULL)
[16:04:34.137]                   if (is.na(NA_character_)) 
[16:04:34.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.137]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.137]                     envir = parent.frame()) 
[16:04:34.137]                   {
[16:04:34.137]                     default_workers <- missing(workers)
[16:04:34.137]                     if (is.function(workers)) 
[16:04:34.137]                       workers <- workers()
[16:04:34.137]                     workers <- structure(as.integer(workers), 
[16:04:34.137]                       class = class(workers))
[16:04:34.137]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.137]                       1L)
[16:04:34.137]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.137]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.137]                       if (default_workers) 
[16:04:34.137]                         supportsMulticore(warn = TRUE)
[16:04:34.137]                       return(sequential(..., envir = envir))
[16:04:34.137]                     }
[16:04:34.137]                     oopts <- options(mc.cores = workers)
[16:04:34.137]                     on.exit(options(oopts))
[16:04:34.137]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.137]                       envir = envir)
[16:04:34.137]                     if (!future$lazy) 
[16:04:34.137]                       future <- run(future)
[16:04:34.137]                     invisible(future)
[16:04:34.137]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.137]                 }
[16:04:34.137]             }
[16:04:34.137]         }
[16:04:34.137]     })
[16:04:34.137]     if (TRUE) {
[16:04:34.137]         base::sink(type = "output", split = FALSE)
[16:04:34.137]         if (TRUE) {
[16:04:34.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.137]         }
[16:04:34.137]         else {
[16:04:34.137]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.137]         }
[16:04:34.137]         base::close(...future.stdout)
[16:04:34.137]         ...future.stdout <- NULL
[16:04:34.137]     }
[16:04:34.137]     ...future.result$conditions <- ...future.conditions
[16:04:34.137]     ...future.result$finished <- base::Sys.time()
[16:04:34.137]     ...future.result
[16:04:34.137] }
[16:04:34.139] assign_globals() ...
[16:04:34.139] List of 1
[16:04:34.139]  $ a: num 1
[16:04:34.139]  - attr(*, "where")=List of 1
[16:04:34.139]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.139]  - attr(*, "resolved")= logi FALSE
[16:04:34.139]  - attr(*, "total_size")= num 56
[16:04:34.139]  - attr(*, "already-done")= logi TRUE
[16:04:34.142] - copied ‘a’ to environment
[16:04:34.143] assign_globals() ... done
[16:04:34.143] requestCore(): workers = 2
[16:04:34.144] MulticoreFuture started
[16:04:34.145] - Launch lazy future ... done
[16:04:34.145] run() for ‘MulticoreFuture’ ... done
[16:04:34.145] result() for MulticoreFuture ...
[16:04:34.145] plan(): Setting new future strategy stack:
[16:04:34.146] List of future strategies:
[16:04:34.146] 1. sequential:
[16:04:34.146]    - args: function (..., envir = parent.frame())
[16:04:34.146]    - tweaked: FALSE
[16:04:34.146]    - call: NULL
[16:04:34.146] plan(): nbrOfWorkers() = 1
[16:04:34.148] plan(): Setting new future strategy stack:
[16:04:34.149] List of future strategies:
[16:04:34.149] 1. multicore:
[16:04:34.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.149]    - tweaked: FALSE
[16:04:34.149]    - call: plan(strategy)
[16:04:34.158] plan(): nbrOfWorkers() = 2
[16:04:34.159] result() for MulticoreFuture ...
[16:04:34.159] result() for MulticoreFuture ... done
[16:04:34.159] result() for MulticoreFuture ... done
[16:04:34.159] result() for MulticoreFuture ...
[16:04:34.159] result() for MulticoreFuture ... done
[16:04:34.159] getGlobalsAndPackages() ...
[16:04:34.160] Searching for globals...
[16:04:34.163] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.163] Searching for globals ... DONE
[16:04:34.163] Resolving globals: FALSE
[16:04:34.164] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.164] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.165] - globals: [1] ‘a’
[16:04:34.165] 
[16:04:34.165] getGlobalsAndPackages() ... DONE
[16:04:34.165] run() for ‘Future’ ...
[16:04:34.165] - state: ‘created’
[16:04:34.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.170] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.170]   - Field: ‘label’
[16:04:34.170]   - Field: ‘local’
[16:04:34.170]   - Field: ‘owner’
[16:04:34.170]   - Field: ‘envir’
[16:04:34.170]   - Field: ‘workers’
[16:04:34.170]   - Field: ‘packages’
[16:04:34.171]   - Field: ‘gc’
[16:04:34.171]   - Field: ‘job’
[16:04:34.171]   - Field: ‘conditions’
[16:04:34.171]   - Field: ‘expr’
[16:04:34.171]   - Field: ‘uuid’
[16:04:34.171]   - Field: ‘seed’
[16:04:34.171]   - Field: ‘version’
[16:04:34.171]   - Field: ‘result’
[16:04:34.172]   - Field: ‘asynchronous’
[16:04:34.172]   - Field: ‘calls’
[16:04:34.172]   - Field: ‘globals’
[16:04:34.172]   - Field: ‘stdout’
[16:04:34.172]   - Field: ‘earlySignal’
[16:04:34.172]   - Field: ‘lazy’
[16:04:34.172]   - Field: ‘state’
[16:04:34.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.172] - Launch lazy future ...
[16:04:34.173] Packages needed by the future expression (n = 0): <none>
[16:04:34.173] Packages needed by future strategies (n = 0): <none>
[16:04:34.173] {
[16:04:34.173]     {
[16:04:34.173]         {
[16:04:34.173]             ...future.startTime <- base::Sys.time()
[16:04:34.173]             {
[16:04:34.173]                 {
[16:04:34.173]                   {
[16:04:34.173]                     {
[16:04:34.173]                       base::local({
[16:04:34.173]                         has_future <- base::requireNamespace("future", 
[16:04:34.173]                           quietly = TRUE)
[16:04:34.173]                         if (has_future) {
[16:04:34.173]                           ns <- base::getNamespace("future")
[16:04:34.173]                           version <- ns[[".package"]][["version"]]
[16:04:34.173]                           if (is.null(version)) 
[16:04:34.173]                             version <- utils::packageVersion("future")
[16:04:34.173]                         }
[16:04:34.173]                         else {
[16:04:34.173]                           version <- NULL
[16:04:34.173]                         }
[16:04:34.173]                         if (!has_future || version < "1.8.0") {
[16:04:34.173]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.173]                             "", base::R.version$version.string), 
[16:04:34.173]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.173]                               "release", "version")], collapse = " "), 
[16:04:34.173]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.173]                             info)
[16:04:34.173]                           info <- base::paste(info, collapse = "; ")
[16:04:34.173]                           if (!has_future) {
[16:04:34.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.173]                               info)
[16:04:34.173]                           }
[16:04:34.173]                           else {
[16:04:34.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.173]                               info, version)
[16:04:34.173]                           }
[16:04:34.173]                           base::stop(msg)
[16:04:34.173]                         }
[16:04:34.173]                       })
[16:04:34.173]                     }
[16:04:34.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.173]                     base::options(mc.cores = 1L)
[16:04:34.173]                   }
[16:04:34.173]                   options(future.plan = NULL)
[16:04:34.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.173]                 }
[16:04:34.173]                 ...future.workdir <- getwd()
[16:04:34.173]             }
[16:04:34.173]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.173]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.173]         }
[16:04:34.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.173]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.173]             base::names(...future.oldOptions))
[16:04:34.173]     }
[16:04:34.173]     if (FALSE) {
[16:04:34.173]     }
[16:04:34.173]     else {
[16:04:34.173]         if (TRUE) {
[16:04:34.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.173]                 open = "w")
[16:04:34.173]         }
[16:04:34.173]         else {
[16:04:34.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.173]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.173]         }
[16:04:34.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.173]             base::sink(type = "output", split = FALSE)
[16:04:34.173]             base::close(...future.stdout)
[16:04:34.173]         }, add = TRUE)
[16:04:34.173]     }
[16:04:34.173]     ...future.frame <- base::sys.nframe()
[16:04:34.173]     ...future.conditions <- base::list()
[16:04:34.173]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.173]     if (FALSE) {
[16:04:34.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.173]     }
[16:04:34.173]     ...future.result <- base::tryCatch({
[16:04:34.173]         base::withCallingHandlers({
[16:04:34.173]             ...future.value <- base::withVisible(base::local({
[16:04:34.173]                 withCallingHandlers({
[16:04:34.173]                   {
[16:04:34.173]                     2 * a
[16:04:34.173]                   }
[16:04:34.173]                 }, immediateCondition = function(cond) {
[16:04:34.173]                   save_rds <- function (object, pathname, ...) 
[16:04:34.173]                   {
[16:04:34.173]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.173]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.173]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.173]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.173]                         fi_tmp[["mtime"]])
[16:04:34.173]                     }
[16:04:34.173]                     tryCatch({
[16:04:34.173]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.173]                     }, error = function(ex) {
[16:04:34.173]                       msg <- conditionMessage(ex)
[16:04:34.173]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.173]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.173]                         fi_tmp[["mtime"]], msg)
[16:04:34.173]                       ex$message <- msg
[16:04:34.173]                       stop(ex)
[16:04:34.173]                     })
[16:04:34.173]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.173]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.173]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.173]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.173]                       fi <- file.info(pathname)
[16:04:34.173]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.173]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.173]                         fi[["size"]], fi[["mtime"]])
[16:04:34.173]                       stop(msg)
[16:04:34.173]                     }
[16:04:34.173]                     invisible(pathname)
[16:04:34.173]                   }
[16:04:34.173]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.173]                     rootPath = tempdir()) 
[16:04:34.173]                   {
[16:04:34.173]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.173]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.173]                       tmpdir = path, fileext = ".rds")
[16:04:34.173]                     save_rds(obj, file)
[16:04:34.173]                   }
[16:04:34.173]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.173]                   {
[16:04:34.173]                     inherits <- base::inherits
[16:04:34.173]                     invokeRestart <- base::invokeRestart
[16:04:34.173]                     is.null <- base::is.null
[16:04:34.173]                     muffled <- FALSE
[16:04:34.173]                     if (inherits(cond, "message")) {
[16:04:34.173]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.173]                       if (muffled) 
[16:04:34.173]                         invokeRestart("muffleMessage")
[16:04:34.173]                     }
[16:04:34.173]                     else if (inherits(cond, "warning")) {
[16:04:34.173]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.173]                       if (muffled) 
[16:04:34.173]                         invokeRestart("muffleWarning")
[16:04:34.173]                     }
[16:04:34.173]                     else if (inherits(cond, "condition")) {
[16:04:34.173]                       if (!is.null(pattern)) {
[16:04:34.173]                         computeRestarts <- base::computeRestarts
[16:04:34.173]                         grepl <- base::grepl
[16:04:34.173]                         restarts <- computeRestarts(cond)
[16:04:34.173]                         for (restart in restarts) {
[16:04:34.173]                           name <- restart$name
[16:04:34.173]                           if (is.null(name)) 
[16:04:34.173]                             next
[16:04:34.173]                           if (!grepl(pattern, name)) 
[16:04:34.173]                             next
[16:04:34.173]                           invokeRestart(restart)
[16:04:34.173]                           muffled <- TRUE
[16:04:34.173]                           break
[16:04:34.173]                         }
[16:04:34.173]                       }
[16:04:34.173]                     }
[16:04:34.173]                     invisible(muffled)
[16:04:34.173]                   }
[16:04:34.173]                   muffleCondition(cond)
[16:04:34.173]                 })
[16:04:34.173]             }))
[16:04:34.173]             future::FutureResult(value = ...future.value$value, 
[16:04:34.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.173]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.173]                     ...future.globalenv.names))
[16:04:34.173]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.173]         }, condition = base::local({
[16:04:34.173]             c <- base::c
[16:04:34.173]             inherits <- base::inherits
[16:04:34.173]             invokeRestart <- base::invokeRestart
[16:04:34.173]             length <- base::length
[16:04:34.173]             list <- base::list
[16:04:34.173]             seq.int <- base::seq.int
[16:04:34.173]             signalCondition <- base::signalCondition
[16:04:34.173]             sys.calls <- base::sys.calls
[16:04:34.173]             `[[` <- base::`[[`
[16:04:34.173]             `+` <- base::`+`
[16:04:34.173]             `<<-` <- base::`<<-`
[16:04:34.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.173]                   3L)]
[16:04:34.173]             }
[16:04:34.173]             function(cond) {
[16:04:34.173]                 is_error <- inherits(cond, "error")
[16:04:34.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.173]                   NULL)
[16:04:34.173]                 if (is_error) {
[16:04:34.173]                   sessionInformation <- function() {
[16:04:34.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.173]                       search = base::search(), system = base::Sys.info())
[16:04:34.173]                   }
[16:04:34.173]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.173]                     cond$call), session = sessionInformation(), 
[16:04:34.173]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.173]                   signalCondition(cond)
[16:04:34.173]                 }
[16:04:34.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.173]                 "immediateCondition"))) {
[16:04:34.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.173]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.173]                   if (TRUE && !signal) {
[16:04:34.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.173]                     {
[16:04:34.173]                       inherits <- base::inherits
[16:04:34.173]                       invokeRestart <- base::invokeRestart
[16:04:34.173]                       is.null <- base::is.null
[16:04:34.173]                       muffled <- FALSE
[16:04:34.173]                       if (inherits(cond, "message")) {
[16:04:34.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.173]                         if (muffled) 
[16:04:34.173]                           invokeRestart("muffleMessage")
[16:04:34.173]                       }
[16:04:34.173]                       else if (inherits(cond, "warning")) {
[16:04:34.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.173]                         if (muffled) 
[16:04:34.173]                           invokeRestart("muffleWarning")
[16:04:34.173]                       }
[16:04:34.173]                       else if (inherits(cond, "condition")) {
[16:04:34.173]                         if (!is.null(pattern)) {
[16:04:34.173]                           computeRestarts <- base::computeRestarts
[16:04:34.173]                           grepl <- base::grepl
[16:04:34.173]                           restarts <- computeRestarts(cond)
[16:04:34.173]                           for (restart in restarts) {
[16:04:34.173]                             name <- restart$name
[16:04:34.173]                             if (is.null(name)) 
[16:04:34.173]                               next
[16:04:34.173]                             if (!grepl(pattern, name)) 
[16:04:34.173]                               next
[16:04:34.173]                             invokeRestart(restart)
[16:04:34.173]                             muffled <- TRUE
[16:04:34.173]                             break
[16:04:34.173]                           }
[16:04:34.173]                         }
[16:04:34.173]                       }
[16:04:34.173]                       invisible(muffled)
[16:04:34.173]                     }
[16:04:34.173]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.173]                   }
[16:04:34.173]                 }
[16:04:34.173]                 else {
[16:04:34.173]                   if (TRUE) {
[16:04:34.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.173]                     {
[16:04:34.173]                       inherits <- base::inherits
[16:04:34.173]                       invokeRestart <- base::invokeRestart
[16:04:34.173]                       is.null <- base::is.null
[16:04:34.173]                       muffled <- FALSE
[16:04:34.173]                       if (inherits(cond, "message")) {
[16:04:34.173]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.173]                         if (muffled) 
[16:04:34.173]                           invokeRestart("muffleMessage")
[16:04:34.173]                       }
[16:04:34.173]                       else if (inherits(cond, "warning")) {
[16:04:34.173]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.173]                         if (muffled) 
[16:04:34.173]                           invokeRestart("muffleWarning")
[16:04:34.173]                       }
[16:04:34.173]                       else if (inherits(cond, "condition")) {
[16:04:34.173]                         if (!is.null(pattern)) {
[16:04:34.173]                           computeRestarts <- base::computeRestarts
[16:04:34.173]                           grepl <- base::grepl
[16:04:34.173]                           restarts <- computeRestarts(cond)
[16:04:34.173]                           for (restart in restarts) {
[16:04:34.173]                             name <- restart$name
[16:04:34.173]                             if (is.null(name)) 
[16:04:34.173]                               next
[16:04:34.173]                             if (!grepl(pattern, name)) 
[16:04:34.173]                               next
[16:04:34.173]                             invokeRestart(restart)
[16:04:34.173]                             muffled <- TRUE
[16:04:34.173]                             break
[16:04:34.173]                           }
[16:04:34.173]                         }
[16:04:34.173]                       }
[16:04:34.173]                       invisible(muffled)
[16:04:34.173]                     }
[16:04:34.173]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.173]                   }
[16:04:34.173]                 }
[16:04:34.173]             }
[16:04:34.173]         }))
[16:04:34.173]     }, error = function(ex) {
[16:04:34.173]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.173]                 ...future.rng), started = ...future.startTime, 
[16:04:34.173]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.173]             version = "1.8"), class = "FutureResult")
[16:04:34.173]     }, finally = {
[16:04:34.173]         if (!identical(...future.workdir, getwd())) 
[16:04:34.173]             setwd(...future.workdir)
[16:04:34.173]         {
[16:04:34.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.173]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.173]             }
[16:04:34.173]             base::options(...future.oldOptions)
[16:04:34.173]             if (.Platform$OS.type == "windows") {
[16:04:34.173]                 old_names <- names(...future.oldEnvVars)
[16:04:34.173]                 envs <- base::Sys.getenv()
[16:04:34.173]                 names <- names(envs)
[16:04:34.173]                 common <- intersect(names, old_names)
[16:04:34.173]                 added <- setdiff(names, old_names)
[16:04:34.173]                 removed <- setdiff(old_names, names)
[16:04:34.173]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.173]                   envs[common]]
[16:04:34.173]                 NAMES <- toupper(changed)
[16:04:34.173]                 args <- list()
[16:04:34.173]                 for (kk in seq_along(NAMES)) {
[16:04:34.173]                   name <- changed[[kk]]
[16:04:34.173]                   NAME <- NAMES[[kk]]
[16:04:34.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.173]                     next
[16:04:34.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.173]                 }
[16:04:34.173]                 NAMES <- toupper(added)
[16:04:34.173]                 for (kk in seq_along(NAMES)) {
[16:04:34.173]                   name <- added[[kk]]
[16:04:34.173]                   NAME <- NAMES[[kk]]
[16:04:34.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.173]                     next
[16:04:34.173]                   args[[name]] <- ""
[16:04:34.173]                 }
[16:04:34.173]                 NAMES <- toupper(removed)
[16:04:34.173]                 for (kk in seq_along(NAMES)) {
[16:04:34.173]                   name <- removed[[kk]]
[16:04:34.173]                   NAME <- NAMES[[kk]]
[16:04:34.173]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.173]                     next
[16:04:34.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.173]                 }
[16:04:34.173]                 if (length(args) > 0) 
[16:04:34.173]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.173]             }
[16:04:34.173]             else {
[16:04:34.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.173]             }
[16:04:34.173]             {
[16:04:34.173]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.173]                   0L) {
[16:04:34.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.173]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.173]                   base::options(opts)
[16:04:34.173]                 }
[16:04:34.173]                 {
[16:04:34.173]                   {
[16:04:34.173]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.173]                     NULL
[16:04:34.173]                   }
[16:04:34.173]                   options(future.plan = NULL)
[16:04:34.173]                   if (is.na(NA_character_)) 
[16:04:34.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.173]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.173]                     envir = parent.frame()) 
[16:04:34.173]                   {
[16:04:34.173]                     default_workers <- missing(workers)
[16:04:34.173]                     if (is.function(workers)) 
[16:04:34.173]                       workers <- workers()
[16:04:34.173]                     workers <- structure(as.integer(workers), 
[16:04:34.173]                       class = class(workers))
[16:04:34.173]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.173]                       1L)
[16:04:34.173]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.173]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.173]                       if (default_workers) 
[16:04:34.173]                         supportsMulticore(warn = TRUE)
[16:04:34.173]                       return(sequential(..., envir = envir))
[16:04:34.173]                     }
[16:04:34.173]                     oopts <- options(mc.cores = workers)
[16:04:34.173]                     on.exit(options(oopts))
[16:04:34.173]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.173]                       envir = envir)
[16:04:34.173]                     if (!future$lazy) 
[16:04:34.173]                       future <- run(future)
[16:04:34.173]                     invisible(future)
[16:04:34.173]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.173]                 }
[16:04:34.173]             }
[16:04:34.173]         }
[16:04:34.173]     })
[16:04:34.173]     if (TRUE) {
[16:04:34.173]         base::sink(type = "output", split = FALSE)
[16:04:34.173]         if (TRUE) {
[16:04:34.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.173]         }
[16:04:34.173]         else {
[16:04:34.173]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.173]         }
[16:04:34.173]         base::close(...future.stdout)
[16:04:34.173]         ...future.stdout <- NULL
[16:04:34.173]     }
[16:04:34.173]     ...future.result$conditions <- ...future.conditions
[16:04:34.173]     ...future.result$finished <- base::Sys.time()
[16:04:34.173]     ...future.result
[16:04:34.173] }
[16:04:34.176] assign_globals() ...
[16:04:34.176] List of 1
[16:04:34.176]  $ a: num 1
[16:04:34.176]  - attr(*, "where")=List of 1
[16:04:34.176]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.176]  - attr(*, "resolved")= logi FALSE
[16:04:34.176]  - attr(*, "total_size")= num 56
[16:04:34.176]  - attr(*, "already-done")= logi TRUE
[16:04:34.179] - copied ‘a’ to environment
[16:04:34.179] assign_globals() ... done
[16:04:34.179] requestCore(): workers = 2
[16:04:34.181] MulticoreFuture started
[16:04:34.181] - Launch lazy future ... done
[16:04:34.181] run() for ‘MulticoreFuture’ ... done
[16:04:34.182] result() for MulticoreFuture ...
[16:04:34.182] plan(): Setting new future strategy stack:
[16:04:34.182] List of future strategies:
[16:04:34.182] 1. sequential:
[16:04:34.182]    - args: function (..., envir = parent.frame())
[16:04:34.182]    - tweaked: FALSE
[16:04:34.182]    - call: NULL
[16:04:34.183] plan(): nbrOfWorkers() = 1
[16:04:34.185] plan(): Setting new future strategy stack:
[16:04:34.185] List of future strategies:
[16:04:34.185] 1. multicore:
[16:04:34.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.185]    - tweaked: FALSE
[16:04:34.185]    - call: plan(strategy)
[16:04:34.190] plan(): nbrOfWorkers() = 2
[16:04:34.191] result() for MulticoreFuture ...
[16:04:34.191] result() for MulticoreFuture ... done
[16:04:34.191] result() for MulticoreFuture ... done
[16:04:34.191] result() for MulticoreFuture ...
[16:04:34.191] result() for MulticoreFuture ... done
[16:04:34.192] getGlobalsAndPackages() ...
[16:04:34.192] Searching for globals...
[16:04:34.193] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.193] Searching for globals ... DONE
[16:04:34.193] Resolving globals: FALSE
[16:04:34.194] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.194] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.194] - globals: [1] ‘a’
[16:04:34.194] 
[16:04:34.195] getGlobalsAndPackages() ... DONE
[16:04:34.195] run() for ‘Future’ ...
[16:04:34.195] - state: ‘created’
[16:04:34.195] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.199] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.200]   - Field: ‘label’
[16:04:34.200]   - Field: ‘local’
[16:04:34.200]   - Field: ‘owner’
[16:04:34.200]   - Field: ‘envir’
[16:04:34.200]   - Field: ‘workers’
[16:04:34.200]   - Field: ‘packages’
[16:04:34.200]   - Field: ‘gc’
[16:04:34.200]   - Field: ‘job’
[16:04:34.201]   - Field: ‘conditions’
[16:04:34.201]   - Field: ‘expr’
[16:04:34.201]   - Field: ‘uuid’
[16:04:34.201]   - Field: ‘seed’
[16:04:34.201]   - Field: ‘version’
[16:04:34.201]   - Field: ‘result’
[16:04:34.201]   - Field: ‘asynchronous’
[16:04:34.201]   - Field: ‘calls’
[16:04:34.201]   - Field: ‘globals’
[16:04:34.202]   - Field: ‘stdout’
[16:04:34.202]   - Field: ‘earlySignal’
[16:04:34.202]   - Field: ‘lazy’
[16:04:34.202]   - Field: ‘state’
[16:04:34.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.202] - Launch lazy future ...
[16:04:34.202] Packages needed by the future expression (n = 0): <none>
[16:04:34.203] Packages needed by future strategies (n = 0): <none>
[16:04:34.203] {
[16:04:34.203]     {
[16:04:34.203]         {
[16:04:34.203]             ...future.startTime <- base::Sys.time()
[16:04:34.203]             {
[16:04:34.203]                 {
[16:04:34.203]                   {
[16:04:34.203]                     {
[16:04:34.203]                       base::local({
[16:04:34.203]                         has_future <- base::requireNamespace("future", 
[16:04:34.203]                           quietly = TRUE)
[16:04:34.203]                         if (has_future) {
[16:04:34.203]                           ns <- base::getNamespace("future")
[16:04:34.203]                           version <- ns[[".package"]][["version"]]
[16:04:34.203]                           if (is.null(version)) 
[16:04:34.203]                             version <- utils::packageVersion("future")
[16:04:34.203]                         }
[16:04:34.203]                         else {
[16:04:34.203]                           version <- NULL
[16:04:34.203]                         }
[16:04:34.203]                         if (!has_future || version < "1.8.0") {
[16:04:34.203]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.203]                             "", base::R.version$version.string), 
[16:04:34.203]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.203]                               "release", "version")], collapse = " "), 
[16:04:34.203]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.203]                             info)
[16:04:34.203]                           info <- base::paste(info, collapse = "; ")
[16:04:34.203]                           if (!has_future) {
[16:04:34.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.203]                               info)
[16:04:34.203]                           }
[16:04:34.203]                           else {
[16:04:34.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.203]                               info, version)
[16:04:34.203]                           }
[16:04:34.203]                           base::stop(msg)
[16:04:34.203]                         }
[16:04:34.203]                       })
[16:04:34.203]                     }
[16:04:34.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.203]                     base::options(mc.cores = 1L)
[16:04:34.203]                   }
[16:04:34.203]                   options(future.plan = NULL)
[16:04:34.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.203]                 }
[16:04:34.203]                 ...future.workdir <- getwd()
[16:04:34.203]             }
[16:04:34.203]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.203]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.203]         }
[16:04:34.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.203]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.203]             base::names(...future.oldOptions))
[16:04:34.203]     }
[16:04:34.203]     if (FALSE) {
[16:04:34.203]     }
[16:04:34.203]     else {
[16:04:34.203]         if (TRUE) {
[16:04:34.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.203]                 open = "w")
[16:04:34.203]         }
[16:04:34.203]         else {
[16:04:34.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.203]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.203]         }
[16:04:34.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.203]             base::sink(type = "output", split = FALSE)
[16:04:34.203]             base::close(...future.stdout)
[16:04:34.203]         }, add = TRUE)
[16:04:34.203]     }
[16:04:34.203]     ...future.frame <- base::sys.nframe()
[16:04:34.203]     ...future.conditions <- base::list()
[16:04:34.203]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.203]     if (FALSE) {
[16:04:34.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.203]     }
[16:04:34.203]     ...future.result <- base::tryCatch({
[16:04:34.203]         base::withCallingHandlers({
[16:04:34.203]             ...future.value <- base::withVisible(base::local({
[16:04:34.203]                 withCallingHandlers({
[16:04:34.203]                   {
[16:04:34.203]                     2 * a
[16:04:34.203]                   }
[16:04:34.203]                 }, immediateCondition = function(cond) {
[16:04:34.203]                   save_rds <- function (object, pathname, ...) 
[16:04:34.203]                   {
[16:04:34.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.203]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.203]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.203]                         fi_tmp[["mtime"]])
[16:04:34.203]                     }
[16:04:34.203]                     tryCatch({
[16:04:34.203]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.203]                     }, error = function(ex) {
[16:04:34.203]                       msg <- conditionMessage(ex)
[16:04:34.203]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.203]                         fi_tmp[["mtime"]], msg)
[16:04:34.203]                       ex$message <- msg
[16:04:34.203]                       stop(ex)
[16:04:34.203]                     })
[16:04:34.203]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.203]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.203]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.203]                       fi <- file.info(pathname)
[16:04:34.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.203]                         fi[["size"]], fi[["mtime"]])
[16:04:34.203]                       stop(msg)
[16:04:34.203]                     }
[16:04:34.203]                     invisible(pathname)
[16:04:34.203]                   }
[16:04:34.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.203]                     rootPath = tempdir()) 
[16:04:34.203]                   {
[16:04:34.203]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.203]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.203]                       tmpdir = path, fileext = ".rds")
[16:04:34.203]                     save_rds(obj, file)
[16:04:34.203]                   }
[16:04:34.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.203]                   {
[16:04:34.203]                     inherits <- base::inherits
[16:04:34.203]                     invokeRestart <- base::invokeRestart
[16:04:34.203]                     is.null <- base::is.null
[16:04:34.203]                     muffled <- FALSE
[16:04:34.203]                     if (inherits(cond, "message")) {
[16:04:34.203]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.203]                       if (muffled) 
[16:04:34.203]                         invokeRestart("muffleMessage")
[16:04:34.203]                     }
[16:04:34.203]                     else if (inherits(cond, "warning")) {
[16:04:34.203]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.203]                       if (muffled) 
[16:04:34.203]                         invokeRestart("muffleWarning")
[16:04:34.203]                     }
[16:04:34.203]                     else if (inherits(cond, "condition")) {
[16:04:34.203]                       if (!is.null(pattern)) {
[16:04:34.203]                         computeRestarts <- base::computeRestarts
[16:04:34.203]                         grepl <- base::grepl
[16:04:34.203]                         restarts <- computeRestarts(cond)
[16:04:34.203]                         for (restart in restarts) {
[16:04:34.203]                           name <- restart$name
[16:04:34.203]                           if (is.null(name)) 
[16:04:34.203]                             next
[16:04:34.203]                           if (!grepl(pattern, name)) 
[16:04:34.203]                             next
[16:04:34.203]                           invokeRestart(restart)
[16:04:34.203]                           muffled <- TRUE
[16:04:34.203]                           break
[16:04:34.203]                         }
[16:04:34.203]                       }
[16:04:34.203]                     }
[16:04:34.203]                     invisible(muffled)
[16:04:34.203]                   }
[16:04:34.203]                   muffleCondition(cond)
[16:04:34.203]                 })
[16:04:34.203]             }))
[16:04:34.203]             future::FutureResult(value = ...future.value$value, 
[16:04:34.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.203]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.203]                     ...future.globalenv.names))
[16:04:34.203]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.203]         }, condition = base::local({
[16:04:34.203]             c <- base::c
[16:04:34.203]             inherits <- base::inherits
[16:04:34.203]             invokeRestart <- base::invokeRestart
[16:04:34.203]             length <- base::length
[16:04:34.203]             list <- base::list
[16:04:34.203]             seq.int <- base::seq.int
[16:04:34.203]             signalCondition <- base::signalCondition
[16:04:34.203]             sys.calls <- base::sys.calls
[16:04:34.203]             `[[` <- base::`[[`
[16:04:34.203]             `+` <- base::`+`
[16:04:34.203]             `<<-` <- base::`<<-`
[16:04:34.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.203]                   3L)]
[16:04:34.203]             }
[16:04:34.203]             function(cond) {
[16:04:34.203]                 is_error <- inherits(cond, "error")
[16:04:34.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.203]                   NULL)
[16:04:34.203]                 if (is_error) {
[16:04:34.203]                   sessionInformation <- function() {
[16:04:34.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.203]                       search = base::search(), system = base::Sys.info())
[16:04:34.203]                   }
[16:04:34.203]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.203]                     cond$call), session = sessionInformation(), 
[16:04:34.203]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.203]                   signalCondition(cond)
[16:04:34.203]                 }
[16:04:34.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.203]                 "immediateCondition"))) {
[16:04:34.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.203]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.203]                   if (TRUE && !signal) {
[16:04:34.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.203]                     {
[16:04:34.203]                       inherits <- base::inherits
[16:04:34.203]                       invokeRestart <- base::invokeRestart
[16:04:34.203]                       is.null <- base::is.null
[16:04:34.203]                       muffled <- FALSE
[16:04:34.203]                       if (inherits(cond, "message")) {
[16:04:34.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.203]                         if (muffled) 
[16:04:34.203]                           invokeRestart("muffleMessage")
[16:04:34.203]                       }
[16:04:34.203]                       else if (inherits(cond, "warning")) {
[16:04:34.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.203]                         if (muffled) 
[16:04:34.203]                           invokeRestart("muffleWarning")
[16:04:34.203]                       }
[16:04:34.203]                       else if (inherits(cond, "condition")) {
[16:04:34.203]                         if (!is.null(pattern)) {
[16:04:34.203]                           computeRestarts <- base::computeRestarts
[16:04:34.203]                           grepl <- base::grepl
[16:04:34.203]                           restarts <- computeRestarts(cond)
[16:04:34.203]                           for (restart in restarts) {
[16:04:34.203]                             name <- restart$name
[16:04:34.203]                             if (is.null(name)) 
[16:04:34.203]                               next
[16:04:34.203]                             if (!grepl(pattern, name)) 
[16:04:34.203]                               next
[16:04:34.203]                             invokeRestart(restart)
[16:04:34.203]                             muffled <- TRUE
[16:04:34.203]                             break
[16:04:34.203]                           }
[16:04:34.203]                         }
[16:04:34.203]                       }
[16:04:34.203]                       invisible(muffled)
[16:04:34.203]                     }
[16:04:34.203]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.203]                   }
[16:04:34.203]                 }
[16:04:34.203]                 else {
[16:04:34.203]                   if (TRUE) {
[16:04:34.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.203]                     {
[16:04:34.203]                       inherits <- base::inherits
[16:04:34.203]                       invokeRestart <- base::invokeRestart
[16:04:34.203]                       is.null <- base::is.null
[16:04:34.203]                       muffled <- FALSE
[16:04:34.203]                       if (inherits(cond, "message")) {
[16:04:34.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.203]                         if (muffled) 
[16:04:34.203]                           invokeRestart("muffleMessage")
[16:04:34.203]                       }
[16:04:34.203]                       else if (inherits(cond, "warning")) {
[16:04:34.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.203]                         if (muffled) 
[16:04:34.203]                           invokeRestart("muffleWarning")
[16:04:34.203]                       }
[16:04:34.203]                       else if (inherits(cond, "condition")) {
[16:04:34.203]                         if (!is.null(pattern)) {
[16:04:34.203]                           computeRestarts <- base::computeRestarts
[16:04:34.203]                           grepl <- base::grepl
[16:04:34.203]                           restarts <- computeRestarts(cond)
[16:04:34.203]                           for (restart in restarts) {
[16:04:34.203]                             name <- restart$name
[16:04:34.203]                             if (is.null(name)) 
[16:04:34.203]                               next
[16:04:34.203]                             if (!grepl(pattern, name)) 
[16:04:34.203]                               next
[16:04:34.203]                             invokeRestart(restart)
[16:04:34.203]                             muffled <- TRUE
[16:04:34.203]                             break
[16:04:34.203]                           }
[16:04:34.203]                         }
[16:04:34.203]                       }
[16:04:34.203]                       invisible(muffled)
[16:04:34.203]                     }
[16:04:34.203]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.203]                   }
[16:04:34.203]                 }
[16:04:34.203]             }
[16:04:34.203]         }))
[16:04:34.203]     }, error = function(ex) {
[16:04:34.203]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.203]                 ...future.rng), started = ...future.startTime, 
[16:04:34.203]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.203]             version = "1.8"), class = "FutureResult")
[16:04:34.203]     }, finally = {
[16:04:34.203]         if (!identical(...future.workdir, getwd())) 
[16:04:34.203]             setwd(...future.workdir)
[16:04:34.203]         {
[16:04:34.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.203]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.203]             }
[16:04:34.203]             base::options(...future.oldOptions)
[16:04:34.203]             if (.Platform$OS.type == "windows") {
[16:04:34.203]                 old_names <- names(...future.oldEnvVars)
[16:04:34.203]                 envs <- base::Sys.getenv()
[16:04:34.203]                 names <- names(envs)
[16:04:34.203]                 common <- intersect(names, old_names)
[16:04:34.203]                 added <- setdiff(names, old_names)
[16:04:34.203]                 removed <- setdiff(old_names, names)
[16:04:34.203]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.203]                   envs[common]]
[16:04:34.203]                 NAMES <- toupper(changed)
[16:04:34.203]                 args <- list()
[16:04:34.203]                 for (kk in seq_along(NAMES)) {
[16:04:34.203]                   name <- changed[[kk]]
[16:04:34.203]                   NAME <- NAMES[[kk]]
[16:04:34.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.203]                     next
[16:04:34.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.203]                 }
[16:04:34.203]                 NAMES <- toupper(added)
[16:04:34.203]                 for (kk in seq_along(NAMES)) {
[16:04:34.203]                   name <- added[[kk]]
[16:04:34.203]                   NAME <- NAMES[[kk]]
[16:04:34.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.203]                     next
[16:04:34.203]                   args[[name]] <- ""
[16:04:34.203]                 }
[16:04:34.203]                 NAMES <- toupper(removed)
[16:04:34.203]                 for (kk in seq_along(NAMES)) {
[16:04:34.203]                   name <- removed[[kk]]
[16:04:34.203]                   NAME <- NAMES[[kk]]
[16:04:34.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.203]                     next
[16:04:34.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.203]                 }
[16:04:34.203]                 if (length(args) > 0) 
[16:04:34.203]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.203]             }
[16:04:34.203]             else {
[16:04:34.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.203]             }
[16:04:34.203]             {
[16:04:34.203]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.203]                   0L) {
[16:04:34.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.203]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.203]                   base::options(opts)
[16:04:34.203]                 }
[16:04:34.203]                 {
[16:04:34.203]                   {
[16:04:34.203]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.203]                     NULL
[16:04:34.203]                   }
[16:04:34.203]                   options(future.plan = NULL)
[16:04:34.203]                   if (is.na(NA_character_)) 
[16:04:34.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.203]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.203]                     envir = parent.frame()) 
[16:04:34.203]                   {
[16:04:34.203]                     default_workers <- missing(workers)
[16:04:34.203]                     if (is.function(workers)) 
[16:04:34.203]                       workers <- workers()
[16:04:34.203]                     workers <- structure(as.integer(workers), 
[16:04:34.203]                       class = class(workers))
[16:04:34.203]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.203]                       1L)
[16:04:34.203]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.203]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.203]                       if (default_workers) 
[16:04:34.203]                         supportsMulticore(warn = TRUE)
[16:04:34.203]                       return(sequential(..., envir = envir))
[16:04:34.203]                     }
[16:04:34.203]                     oopts <- options(mc.cores = workers)
[16:04:34.203]                     on.exit(options(oopts))
[16:04:34.203]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.203]                       envir = envir)
[16:04:34.203]                     if (!future$lazy) 
[16:04:34.203]                       future <- run(future)
[16:04:34.203]                     invisible(future)
[16:04:34.203]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.203]                 }
[16:04:34.203]             }
[16:04:34.203]         }
[16:04:34.203]     })
[16:04:34.203]     if (TRUE) {
[16:04:34.203]         base::sink(type = "output", split = FALSE)
[16:04:34.203]         if (TRUE) {
[16:04:34.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.203]         }
[16:04:34.203]         else {
[16:04:34.203]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.203]         }
[16:04:34.203]         base::close(...future.stdout)
[16:04:34.203]         ...future.stdout <- NULL
[16:04:34.203]     }
[16:04:34.203]     ...future.result$conditions <- ...future.conditions
[16:04:34.203]     ...future.result$finished <- base::Sys.time()
[16:04:34.203]     ...future.result
[16:04:34.203] }
[16:04:34.206] assign_globals() ...
[16:04:34.206] List of 1
[16:04:34.206]  $ a: num 1
[16:04:34.206]  - attr(*, "where")=List of 1
[16:04:34.206]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.206]  - attr(*, "resolved")= logi FALSE
[16:04:34.206]  - attr(*, "total_size")= num 56
[16:04:34.206]  - attr(*, "already-done")= logi TRUE
[16:04:34.209] - copied ‘a’ to environment
[16:04:34.209] assign_globals() ... done
[16:04:34.209] requestCore(): workers = 2
[16:04:34.211] MulticoreFuture started
[16:04:34.211] - Launch lazy future ... done
[16:04:34.211] run() for ‘MulticoreFuture’ ... done
[16:04:34.212] result() for MulticoreFuture ...
[16:04:34.212] plan(): Setting new future strategy stack:
[16:04:34.212] List of future strategies:
[16:04:34.212] 1. sequential:
[16:04:34.212]    - args: function (..., envir = parent.frame())
[16:04:34.212]    - tweaked: FALSE
[16:04:34.212]    - call: NULL
[16:04:34.213] plan(): nbrOfWorkers() = 1
[16:04:34.215] plan(): Setting new future strategy stack:
[16:04:34.215] List of future strategies:
[16:04:34.215] 1. multicore:
[16:04:34.215]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.215]    - tweaked: FALSE
[16:04:34.215]    - call: plan(strategy)
[16:04:34.224] plan(): nbrOfWorkers() = 2
[16:04:34.225] result() for MulticoreFuture ...
[16:04:34.225] result() for MulticoreFuture ... done
[16:04:34.225] result() for MulticoreFuture ... done
[16:04:34.225] result() for MulticoreFuture ...
[16:04:34.225] result() for MulticoreFuture ... done
[16:04:34.226] getGlobalsAndPackages() ...
[16:04:34.226] Searching for globals...
[16:04:34.229] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:34.229] Searching for globals ... DONE
[16:04:34.229] Resolving globals: FALSE
[16:04:34.230] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:34.231] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:34.231] - globals: [1] ‘a’
[16:04:34.231] 
[16:04:34.231] getGlobalsAndPackages() ... DONE
[16:04:34.231] run() for ‘Future’ ...
[16:04:34.232] - state: ‘created’
[16:04:34.232] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:34.236]   - Field: ‘label’
[16:04:34.236]   - Field: ‘local’
[16:04:34.236]   - Field: ‘owner’
[16:04:34.236]   - Field: ‘envir’
[16:04:34.237]   - Field: ‘workers’
[16:04:34.237]   - Field: ‘packages’
[16:04:34.237]   - Field: ‘gc’
[16:04:34.237]   - Field: ‘job’
[16:04:34.237]   - Field: ‘conditions’
[16:04:34.237]   - Field: ‘expr’
[16:04:34.237]   - Field: ‘uuid’
[16:04:34.237]   - Field: ‘seed’
[16:04:34.238]   - Field: ‘version’
[16:04:34.238]   - Field: ‘result’
[16:04:34.238]   - Field: ‘asynchronous’
[16:04:34.238]   - Field: ‘calls’
[16:04:34.238]   - Field: ‘globals’
[16:04:34.238]   - Field: ‘stdout’
[16:04:34.238]   - Field: ‘earlySignal’
[16:04:34.238]   - Field: ‘lazy’
[16:04:34.238]   - Field: ‘state’
[16:04:34.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:34.239] - Launch lazy future ...
[16:04:34.239] Packages needed by the future expression (n = 0): <none>
[16:04:34.239] Packages needed by future strategies (n = 0): <none>
[16:04:34.240] {
[16:04:34.240]     {
[16:04:34.240]         {
[16:04:34.240]             ...future.startTime <- base::Sys.time()
[16:04:34.240]             {
[16:04:34.240]                 {
[16:04:34.240]                   {
[16:04:34.240]                     {
[16:04:34.240]                       base::local({
[16:04:34.240]                         has_future <- base::requireNamespace("future", 
[16:04:34.240]                           quietly = TRUE)
[16:04:34.240]                         if (has_future) {
[16:04:34.240]                           ns <- base::getNamespace("future")
[16:04:34.240]                           version <- ns[[".package"]][["version"]]
[16:04:34.240]                           if (is.null(version)) 
[16:04:34.240]                             version <- utils::packageVersion("future")
[16:04:34.240]                         }
[16:04:34.240]                         else {
[16:04:34.240]                           version <- NULL
[16:04:34.240]                         }
[16:04:34.240]                         if (!has_future || version < "1.8.0") {
[16:04:34.240]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.240]                             "", base::R.version$version.string), 
[16:04:34.240]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.240]                               "release", "version")], collapse = " "), 
[16:04:34.240]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.240]                             info)
[16:04:34.240]                           info <- base::paste(info, collapse = "; ")
[16:04:34.240]                           if (!has_future) {
[16:04:34.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.240]                               info)
[16:04:34.240]                           }
[16:04:34.240]                           else {
[16:04:34.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.240]                               info, version)
[16:04:34.240]                           }
[16:04:34.240]                           base::stop(msg)
[16:04:34.240]                         }
[16:04:34.240]                       })
[16:04:34.240]                     }
[16:04:34.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.240]                     base::options(mc.cores = 1L)
[16:04:34.240]                   }
[16:04:34.240]                   options(future.plan = NULL)
[16:04:34.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.240]                 }
[16:04:34.240]                 ...future.workdir <- getwd()
[16:04:34.240]             }
[16:04:34.240]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.240]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.240]         }
[16:04:34.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.240]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.240]             base::names(...future.oldOptions))
[16:04:34.240]     }
[16:04:34.240]     if (FALSE) {
[16:04:34.240]     }
[16:04:34.240]     else {
[16:04:34.240]         if (TRUE) {
[16:04:34.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.240]                 open = "w")
[16:04:34.240]         }
[16:04:34.240]         else {
[16:04:34.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.240]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.240]         }
[16:04:34.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.240]             base::sink(type = "output", split = FALSE)
[16:04:34.240]             base::close(...future.stdout)
[16:04:34.240]         }, add = TRUE)
[16:04:34.240]     }
[16:04:34.240]     ...future.frame <- base::sys.nframe()
[16:04:34.240]     ...future.conditions <- base::list()
[16:04:34.240]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.240]     if (FALSE) {
[16:04:34.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.240]     }
[16:04:34.240]     ...future.result <- base::tryCatch({
[16:04:34.240]         base::withCallingHandlers({
[16:04:34.240]             ...future.value <- base::withVisible(base::local({
[16:04:34.240]                 withCallingHandlers({
[16:04:34.240]                   {
[16:04:34.240]                     2 * a
[16:04:34.240]                   }
[16:04:34.240]                 }, immediateCondition = function(cond) {
[16:04:34.240]                   save_rds <- function (object, pathname, ...) 
[16:04:34.240]                   {
[16:04:34.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:34.240]                     if (file_test("-f", pathname_tmp)) {
[16:04:34.240]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:34.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.240]                         fi_tmp[["mtime"]])
[16:04:34.240]                     }
[16:04:34.240]                     tryCatch({
[16:04:34.240]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:34.240]                     }, error = function(ex) {
[16:04:34.240]                       msg <- conditionMessage(ex)
[16:04:34.240]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:34.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.240]                         fi_tmp[["mtime"]], msg)
[16:04:34.240]                       ex$message <- msg
[16:04:34.240]                       stop(ex)
[16:04:34.240]                     })
[16:04:34.240]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:34.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:34.240]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:34.240]                       fi_tmp <- file.info(pathname_tmp)
[16:04:34.240]                       fi <- file.info(pathname)
[16:04:34.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:34.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:34.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:34.240]                         fi[["size"]], fi[["mtime"]])
[16:04:34.240]                       stop(msg)
[16:04:34.240]                     }
[16:04:34.240]                     invisible(pathname)
[16:04:34.240]                   }
[16:04:34.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:34.240]                     rootPath = tempdir()) 
[16:04:34.240]                   {
[16:04:34.240]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:34.240]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:34.240]                       tmpdir = path, fileext = ".rds")
[16:04:34.240]                     save_rds(obj, file)
[16:04:34.240]                   }
[16:04:34.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpaIR5va/.future/immediateConditions")
[16:04:34.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.240]                   {
[16:04:34.240]                     inherits <- base::inherits
[16:04:34.240]                     invokeRestart <- base::invokeRestart
[16:04:34.240]                     is.null <- base::is.null
[16:04:34.240]                     muffled <- FALSE
[16:04:34.240]                     if (inherits(cond, "message")) {
[16:04:34.240]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.240]                       if (muffled) 
[16:04:34.240]                         invokeRestart("muffleMessage")
[16:04:34.240]                     }
[16:04:34.240]                     else if (inherits(cond, "warning")) {
[16:04:34.240]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.240]                       if (muffled) 
[16:04:34.240]                         invokeRestart("muffleWarning")
[16:04:34.240]                     }
[16:04:34.240]                     else if (inherits(cond, "condition")) {
[16:04:34.240]                       if (!is.null(pattern)) {
[16:04:34.240]                         computeRestarts <- base::computeRestarts
[16:04:34.240]                         grepl <- base::grepl
[16:04:34.240]                         restarts <- computeRestarts(cond)
[16:04:34.240]                         for (restart in restarts) {
[16:04:34.240]                           name <- restart$name
[16:04:34.240]                           if (is.null(name)) 
[16:04:34.240]                             next
[16:04:34.240]                           if (!grepl(pattern, name)) 
[16:04:34.240]                             next
[16:04:34.240]                           invokeRestart(restart)
[16:04:34.240]                           muffled <- TRUE
[16:04:34.240]                           break
[16:04:34.240]                         }
[16:04:34.240]                       }
[16:04:34.240]                     }
[16:04:34.240]                     invisible(muffled)
[16:04:34.240]                   }
[16:04:34.240]                   muffleCondition(cond)
[16:04:34.240]                 })
[16:04:34.240]             }))
[16:04:34.240]             future::FutureResult(value = ...future.value$value, 
[16:04:34.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.240]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.240]                     ...future.globalenv.names))
[16:04:34.240]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.240]         }, condition = base::local({
[16:04:34.240]             c <- base::c
[16:04:34.240]             inherits <- base::inherits
[16:04:34.240]             invokeRestart <- base::invokeRestart
[16:04:34.240]             length <- base::length
[16:04:34.240]             list <- base::list
[16:04:34.240]             seq.int <- base::seq.int
[16:04:34.240]             signalCondition <- base::signalCondition
[16:04:34.240]             sys.calls <- base::sys.calls
[16:04:34.240]             `[[` <- base::`[[`
[16:04:34.240]             `+` <- base::`+`
[16:04:34.240]             `<<-` <- base::`<<-`
[16:04:34.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.240]                   3L)]
[16:04:34.240]             }
[16:04:34.240]             function(cond) {
[16:04:34.240]                 is_error <- inherits(cond, "error")
[16:04:34.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.240]                   NULL)
[16:04:34.240]                 if (is_error) {
[16:04:34.240]                   sessionInformation <- function() {
[16:04:34.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.240]                       search = base::search(), system = base::Sys.info())
[16:04:34.240]                   }
[16:04:34.240]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.240]                     cond$call), session = sessionInformation(), 
[16:04:34.240]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.240]                   signalCondition(cond)
[16:04:34.240]                 }
[16:04:34.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.240]                 "immediateCondition"))) {
[16:04:34.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.240]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.240]                   if (TRUE && !signal) {
[16:04:34.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.240]                     {
[16:04:34.240]                       inherits <- base::inherits
[16:04:34.240]                       invokeRestart <- base::invokeRestart
[16:04:34.240]                       is.null <- base::is.null
[16:04:34.240]                       muffled <- FALSE
[16:04:34.240]                       if (inherits(cond, "message")) {
[16:04:34.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.240]                         if (muffled) 
[16:04:34.240]                           invokeRestart("muffleMessage")
[16:04:34.240]                       }
[16:04:34.240]                       else if (inherits(cond, "warning")) {
[16:04:34.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.240]                         if (muffled) 
[16:04:34.240]                           invokeRestart("muffleWarning")
[16:04:34.240]                       }
[16:04:34.240]                       else if (inherits(cond, "condition")) {
[16:04:34.240]                         if (!is.null(pattern)) {
[16:04:34.240]                           computeRestarts <- base::computeRestarts
[16:04:34.240]                           grepl <- base::grepl
[16:04:34.240]                           restarts <- computeRestarts(cond)
[16:04:34.240]                           for (restart in restarts) {
[16:04:34.240]                             name <- restart$name
[16:04:34.240]                             if (is.null(name)) 
[16:04:34.240]                               next
[16:04:34.240]                             if (!grepl(pattern, name)) 
[16:04:34.240]                               next
[16:04:34.240]                             invokeRestart(restart)
[16:04:34.240]                             muffled <- TRUE
[16:04:34.240]                             break
[16:04:34.240]                           }
[16:04:34.240]                         }
[16:04:34.240]                       }
[16:04:34.240]                       invisible(muffled)
[16:04:34.240]                     }
[16:04:34.240]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.240]                   }
[16:04:34.240]                 }
[16:04:34.240]                 else {
[16:04:34.240]                   if (TRUE) {
[16:04:34.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.240]                     {
[16:04:34.240]                       inherits <- base::inherits
[16:04:34.240]                       invokeRestart <- base::invokeRestart
[16:04:34.240]                       is.null <- base::is.null
[16:04:34.240]                       muffled <- FALSE
[16:04:34.240]                       if (inherits(cond, "message")) {
[16:04:34.240]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.240]                         if (muffled) 
[16:04:34.240]                           invokeRestart("muffleMessage")
[16:04:34.240]                       }
[16:04:34.240]                       else if (inherits(cond, "warning")) {
[16:04:34.240]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.240]                         if (muffled) 
[16:04:34.240]                           invokeRestart("muffleWarning")
[16:04:34.240]                       }
[16:04:34.240]                       else if (inherits(cond, "condition")) {
[16:04:34.240]                         if (!is.null(pattern)) {
[16:04:34.240]                           computeRestarts <- base::computeRestarts
[16:04:34.240]                           grepl <- base::grepl
[16:04:34.240]                           restarts <- computeRestarts(cond)
[16:04:34.240]                           for (restart in restarts) {
[16:04:34.240]                             name <- restart$name
[16:04:34.240]                             if (is.null(name)) 
[16:04:34.240]                               next
[16:04:34.240]                             if (!grepl(pattern, name)) 
[16:04:34.240]                               next
[16:04:34.240]                             invokeRestart(restart)
[16:04:34.240]                             muffled <- TRUE
[16:04:34.240]                             break
[16:04:34.240]                           }
[16:04:34.240]                         }
[16:04:34.240]                       }
[16:04:34.240]                       invisible(muffled)
[16:04:34.240]                     }
[16:04:34.240]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.240]                   }
[16:04:34.240]                 }
[16:04:34.240]             }
[16:04:34.240]         }))
[16:04:34.240]     }, error = function(ex) {
[16:04:34.240]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.240]                 ...future.rng), started = ...future.startTime, 
[16:04:34.240]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.240]             version = "1.8"), class = "FutureResult")
[16:04:34.240]     }, finally = {
[16:04:34.240]         if (!identical(...future.workdir, getwd())) 
[16:04:34.240]             setwd(...future.workdir)
[16:04:34.240]         {
[16:04:34.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.240]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.240]             }
[16:04:34.240]             base::options(...future.oldOptions)
[16:04:34.240]             if (.Platform$OS.type == "windows") {
[16:04:34.240]                 old_names <- names(...future.oldEnvVars)
[16:04:34.240]                 envs <- base::Sys.getenv()
[16:04:34.240]                 names <- names(envs)
[16:04:34.240]                 common <- intersect(names, old_names)
[16:04:34.240]                 added <- setdiff(names, old_names)
[16:04:34.240]                 removed <- setdiff(old_names, names)
[16:04:34.240]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.240]                   envs[common]]
[16:04:34.240]                 NAMES <- toupper(changed)
[16:04:34.240]                 args <- list()
[16:04:34.240]                 for (kk in seq_along(NAMES)) {
[16:04:34.240]                   name <- changed[[kk]]
[16:04:34.240]                   NAME <- NAMES[[kk]]
[16:04:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.240]                     next
[16:04:34.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.240]                 }
[16:04:34.240]                 NAMES <- toupper(added)
[16:04:34.240]                 for (kk in seq_along(NAMES)) {
[16:04:34.240]                   name <- added[[kk]]
[16:04:34.240]                   NAME <- NAMES[[kk]]
[16:04:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.240]                     next
[16:04:34.240]                   args[[name]] <- ""
[16:04:34.240]                 }
[16:04:34.240]                 NAMES <- toupper(removed)
[16:04:34.240]                 for (kk in seq_along(NAMES)) {
[16:04:34.240]                   name <- removed[[kk]]
[16:04:34.240]                   NAME <- NAMES[[kk]]
[16:04:34.240]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.240]                     next
[16:04:34.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.240]                 }
[16:04:34.240]                 if (length(args) > 0) 
[16:04:34.240]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.240]             }
[16:04:34.240]             else {
[16:04:34.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.240]             }
[16:04:34.240]             {
[16:04:34.240]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.240]                   0L) {
[16:04:34.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.240]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.240]                   base::options(opts)
[16:04:34.240]                 }
[16:04:34.240]                 {
[16:04:34.240]                   {
[16:04:34.240]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.240]                     NULL
[16:04:34.240]                   }
[16:04:34.240]                   options(future.plan = NULL)
[16:04:34.240]                   if (is.na(NA_character_)) 
[16:04:34.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.240]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:34.240]                     envir = parent.frame()) 
[16:04:34.240]                   {
[16:04:34.240]                     default_workers <- missing(workers)
[16:04:34.240]                     if (is.function(workers)) 
[16:04:34.240]                       workers <- workers()
[16:04:34.240]                     workers <- structure(as.integer(workers), 
[16:04:34.240]                       class = class(workers))
[16:04:34.240]                     stop_if_not(is.finite(workers), workers >= 
[16:04:34.240]                       1L)
[16:04:34.240]                     if ((workers == 1L && !inherits(workers, 
[16:04:34.240]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:34.240]                       if (default_workers) 
[16:04:34.240]                         supportsMulticore(warn = TRUE)
[16:04:34.240]                       return(sequential(..., envir = envir))
[16:04:34.240]                     }
[16:04:34.240]                     oopts <- options(mc.cores = workers)
[16:04:34.240]                     on.exit(options(oopts))
[16:04:34.240]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:34.240]                       envir = envir)
[16:04:34.240]                     if (!future$lazy) 
[16:04:34.240]                       future <- run(future)
[16:04:34.240]                     invisible(future)
[16:04:34.240]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.240]                 }
[16:04:34.240]             }
[16:04:34.240]         }
[16:04:34.240]     })
[16:04:34.240]     if (TRUE) {
[16:04:34.240]         base::sink(type = "output", split = FALSE)
[16:04:34.240]         if (TRUE) {
[16:04:34.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.240]         }
[16:04:34.240]         else {
[16:04:34.240]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.240]         }
[16:04:34.240]         base::close(...future.stdout)
[16:04:34.240]         ...future.stdout <- NULL
[16:04:34.240]     }
[16:04:34.240]     ...future.result$conditions <- ...future.conditions
[16:04:34.240]     ...future.result$finished <- base::Sys.time()
[16:04:34.240]     ...future.result
[16:04:34.240] }
[16:04:34.242] assign_globals() ...
[16:04:34.242] List of 1
[16:04:34.242]  $ a: num 1
[16:04:34.242]  - attr(*, "where")=List of 1
[16:04:34.242]   ..$ a:<environment: R_EmptyEnv> 
[16:04:34.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:34.242]  - attr(*, "resolved")= logi FALSE
[16:04:34.242]  - attr(*, "total_size")= num 56
[16:04:34.242]  - attr(*, "already-done")= logi TRUE
[16:04:34.245] - copied ‘a’ to environment
[16:04:34.245] assign_globals() ... done
[16:04:34.245] requestCore(): workers = 2
[16:04:34.247] MulticoreFuture started
[16:04:34.247] - Launch lazy future ... done
[16:04:34.248] run() for ‘MulticoreFuture’ ... done
[16:04:34.248] result() for MulticoreFuture ...
[16:04:34.248] plan(): Setting new future strategy stack:
[16:04:34.248] List of future strategies:
[16:04:34.248] 1. sequential:
[16:04:34.248]    - args: function (..., envir = parent.frame())
[16:04:34.248]    - tweaked: FALSE
[16:04:34.248]    - call: NULL
[16:04:34.249] plan(): nbrOfWorkers() = 1
[16:04:34.251] plan(): Setting new future strategy stack:
[16:04:34.251] List of future strategies:
[16:04:34.251] 1. multicore:
[16:04:34.251]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:34.251]    - tweaked: FALSE
[16:04:34.251]    - call: plan(strategy)
[16:04:34.256] plan(): nbrOfWorkers() = 2
[16:04:34.257] result() for MulticoreFuture ...
[16:04:34.257] result() for MulticoreFuture ... done
[16:04:34.257] result() for MulticoreFuture ... done
[16:04:34.257] result() for MulticoreFuture ...
[16:04:34.258] result() for MulticoreFuture ... done
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[16:04:34.258] plan(): Setting new future strategy stack:
[16:04:34.258] List of future strategies:
[16:04:34.258] 1. multisession:
[16:04:34.258]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:34.258]    - tweaked: FALSE
[16:04:34.258]    - call: plan(strategy)
[16:04:34.259] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:34.259] multisession:
[16:04:34.259] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:34.259] - tweaked: FALSE
[16:04:34.259] - call: plan(strategy)
[16:04:34.266] getGlobalsAndPackages() ...
[16:04:34.266] Not searching for globals
[16:04:34.266] - globals: [0] <none>
[16:04:34.266] getGlobalsAndPackages() ... DONE
[16:04:34.267] [local output] makeClusterPSOCK() ...
[16:04:34.306] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:34.308] [local output] Base port: 11412
[16:04:34.308] [local output] Getting setup options for 2 cluster nodes ...
[16:04:34.308] [local output]  - Node 1 of 2 ...
[16:04:34.308] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:34.309] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpaIR5va/worker.rank=1.parallelly.parent=82539.1426b1c60309c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpaIR5va/worker.rank=1.parallelly.parent=82539.1426b1c60309c.pid")'’
[16:04:34.494] - Possible to infer worker's PID: TRUE
[16:04:34.494] [local output] Rscript port: 11412

[16:04:34.495] [local output]  - Node 2 of 2 ...
[16:04:34.495] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:34.496] [local output] Rscript port: 11412

[16:04:34.496] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:34.496] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:34.497] [local output] Setting up PSOCK nodes in parallel
[16:04:34.497] List of 36
[16:04:34.497]  $ worker          : chr "localhost"
[16:04:34.497]   ..- attr(*, "localhost")= logi TRUE
[16:04:34.497]  $ master          : chr "localhost"
[16:04:34.497]  $ port            : int 11412
[16:04:34.497]  $ connectTimeout  : num 120
[16:04:34.497]  $ timeout         : num 2592000
[16:04:34.497]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:34.497]  $ homogeneous     : logi TRUE
[16:04:34.497]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:34.497]  $ rscript_envs    : NULL
[16:04:34.497]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:34.497]  $ rscript_startup : NULL
[16:04:34.497]  $ rscript_sh      : chr "sh"
[16:04:34.497]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:34.497]  $ methods         : logi TRUE
[16:04:34.497]  $ socketOptions   : chr "no-delay"
[16:04:34.497]  $ useXDR          : logi FALSE
[16:04:34.497]  $ outfile         : chr "/dev/null"
[16:04:34.497]  $ renice          : int NA
[16:04:34.497]  $ rshcmd          : NULL
[16:04:34.497]  $ user            : chr(0) 
[16:04:34.497]  $ revtunnel       : logi FALSE
[16:04:34.497]  $ rshlogfile      : NULL
[16:04:34.497]  $ rshopts         : chr(0) 
[16:04:34.497]  $ rank            : int 1
[16:04:34.497]  $ manual          : logi FALSE
[16:04:34.497]  $ dryrun          : logi FALSE
[16:04:34.497]  $ quiet           : logi FALSE
[16:04:34.497]  $ setup_strategy  : chr "parallel"
[16:04:34.497]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:34.497]  $ pidfile         : chr "/tmp/RtmpaIR5va/worker.rank=1.parallelly.parent=82539.1426b1c60309c.pid"
[16:04:34.497]  $ rshcmd_label    : NULL
[16:04:34.497]  $ rsh_call        : NULL
[16:04:34.497]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:34.497]  $ localMachine    : logi TRUE
[16:04:34.497]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:34.497]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:34.497]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:34.497]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:34.497]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:34.497]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:34.497]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:34.497]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:34.497]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:34.497]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:34.497]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:34.497]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:34.497]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:34.497]  $ arguments       :List of 28
[16:04:34.497]   ..$ worker          : chr "localhost"
[16:04:34.497]   ..$ master          : NULL
[16:04:34.497]   ..$ port            : int 11412
[16:04:34.497]   ..$ connectTimeout  : num 120
[16:04:34.497]   ..$ timeout         : num 2592000
[16:04:34.497]   ..$ rscript         : NULL
[16:04:34.497]   ..$ homogeneous     : NULL
[16:04:34.497]   ..$ rscript_args    : NULL
[16:04:34.497]   ..$ rscript_envs    : NULL
[16:04:34.497]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:34.497]   ..$ rscript_startup : NULL
[16:04:34.497]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:34.497]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:34.497]   ..$ methods         : logi TRUE
[16:04:34.497]   ..$ socketOptions   : chr "no-delay"
[16:04:34.497]   ..$ useXDR          : logi FALSE
[16:04:34.497]   ..$ outfile         : chr "/dev/null"
[16:04:34.497]   ..$ renice          : int NA
[16:04:34.497]   ..$ rshcmd          : NULL
[16:04:34.497]   ..$ user            : NULL
[16:04:34.497]   ..$ revtunnel       : logi NA
[16:04:34.497]   ..$ rshlogfile      : NULL
[16:04:34.497]   ..$ rshopts         : NULL
[16:04:34.497]   ..$ rank            : int 1
[16:04:34.497]   ..$ manual          : logi FALSE
[16:04:34.497]   ..$ dryrun          : logi FALSE
[16:04:34.497]   ..$ quiet           : logi FALSE
[16:04:34.497]   ..$ setup_strategy  : chr "parallel"
[16:04:34.497]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:34.513] [local output] System call to launch all workers:
[16:04:34.514] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpaIR5va/worker.rank=1.parallelly.parent=82539.1426b1c60309c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11412 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:34.514] [local output] Starting PSOCK main server
[16:04:34.519] [local output] Workers launched
[16:04:34.519] [local output] Waiting for workers to connect back
[16:04:34.520]  - [local output] 0 workers out of 2 ready
[16:04:34.756]  - [local output] 0 workers out of 2 ready
[16:04:34.757]  - [local output] 1 workers out of 2 ready
[16:04:34.765]  - [local output] 1 workers out of 2 ready
[16:04:34.765]  - [local output] 2 workers out of 2 ready
[16:04:34.765] [local output] Launching of workers completed
[16:04:34.765] [local output] Collecting session information from workers
[16:04:34.766] [local output]  - Worker #1 of 2
[16:04:34.767] [local output]  - Worker #2 of 2
[16:04:34.767] [local output] makeClusterPSOCK() ... done
[16:04:34.778] Packages needed by the future expression (n = 0): <none>
[16:04:34.778] Packages needed by future strategies (n = 0): <none>
[16:04:34.778] {
[16:04:34.778]     {
[16:04:34.778]         {
[16:04:34.778]             ...future.startTime <- base::Sys.time()
[16:04:34.778]             {
[16:04:34.778]                 {
[16:04:34.778]                   {
[16:04:34.778]                     {
[16:04:34.778]                       base::local({
[16:04:34.778]                         has_future <- base::requireNamespace("future", 
[16:04:34.778]                           quietly = TRUE)
[16:04:34.778]                         if (has_future) {
[16:04:34.778]                           ns <- base::getNamespace("future")
[16:04:34.778]                           version <- ns[[".package"]][["version"]]
[16:04:34.778]                           if (is.null(version)) 
[16:04:34.778]                             version <- utils::packageVersion("future")
[16:04:34.778]                         }
[16:04:34.778]                         else {
[16:04:34.778]                           version <- NULL
[16:04:34.778]                         }
[16:04:34.778]                         if (!has_future || version < "1.8.0") {
[16:04:34.778]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.778]                             "", base::R.version$version.string), 
[16:04:34.778]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.778]                               "release", "version")], collapse = " "), 
[16:04:34.778]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.778]                             info)
[16:04:34.778]                           info <- base::paste(info, collapse = "; ")
[16:04:34.778]                           if (!has_future) {
[16:04:34.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.778]                               info)
[16:04:34.778]                           }
[16:04:34.778]                           else {
[16:04:34.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.778]                               info, version)
[16:04:34.778]                           }
[16:04:34.778]                           base::stop(msg)
[16:04:34.778]                         }
[16:04:34.778]                       })
[16:04:34.778]                     }
[16:04:34.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.778]                     base::options(mc.cores = 1L)
[16:04:34.778]                   }
[16:04:34.778]                   options(future.plan = NULL)
[16:04:34.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.778]                 }
[16:04:34.778]                 ...future.workdir <- getwd()
[16:04:34.778]             }
[16:04:34.778]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.778]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.778]         }
[16:04:34.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.778]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.778]             base::names(...future.oldOptions))
[16:04:34.778]     }
[16:04:34.778]     if (FALSE) {
[16:04:34.778]     }
[16:04:34.778]     else {
[16:04:34.778]         if (TRUE) {
[16:04:34.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.778]                 open = "w")
[16:04:34.778]         }
[16:04:34.778]         else {
[16:04:34.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.778]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.778]         }
[16:04:34.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.778]             base::sink(type = "output", split = FALSE)
[16:04:34.778]             base::close(...future.stdout)
[16:04:34.778]         }, add = TRUE)
[16:04:34.778]     }
[16:04:34.778]     ...future.frame <- base::sys.nframe()
[16:04:34.778]     ...future.conditions <- base::list()
[16:04:34.778]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.778]     if (FALSE) {
[16:04:34.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.778]     }
[16:04:34.778]     ...future.result <- base::tryCatch({
[16:04:34.778]         base::withCallingHandlers({
[16:04:34.778]             ...future.value <- base::withVisible(base::local({
[16:04:34.778]                 ...future.makeSendCondition <- base::local({
[16:04:34.778]                   sendCondition <- NULL
[16:04:34.778]                   function(frame = 1L) {
[16:04:34.778]                     if (is.function(sendCondition)) 
[16:04:34.778]                       return(sendCondition)
[16:04:34.778]                     ns <- getNamespace("parallel")
[16:04:34.778]                     if (exists("sendData", mode = "function", 
[16:04:34.778]                       envir = ns)) {
[16:04:34.778]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:34.778]                         envir = ns)
[16:04:34.778]                       envir <- sys.frame(frame)
[16:04:34.778]                       master <- NULL
[16:04:34.778]                       while (!identical(envir, .GlobalEnv) && 
[16:04:34.778]                         !identical(envir, emptyenv())) {
[16:04:34.778]                         if (exists("master", mode = "list", envir = envir, 
[16:04:34.778]                           inherits = FALSE)) {
[16:04:34.778]                           master <- get("master", mode = "list", 
[16:04:34.778]                             envir = envir, inherits = FALSE)
[16:04:34.778]                           if (inherits(master, c("SOCKnode", 
[16:04:34.778]                             "SOCK0node"))) {
[16:04:34.778]                             sendCondition <<- function(cond) {
[16:04:34.778]                               data <- list(type = "VALUE", value = cond, 
[16:04:34.778]                                 success = TRUE)
[16:04:34.778]                               parallel_sendData(master, data)
[16:04:34.778]                             }
[16:04:34.778]                             return(sendCondition)
[16:04:34.778]                           }
[16:04:34.778]                         }
[16:04:34.778]                         frame <- frame + 1L
[16:04:34.778]                         envir <- sys.frame(frame)
[16:04:34.778]                       }
[16:04:34.778]                     }
[16:04:34.778]                     sendCondition <<- function(cond) NULL
[16:04:34.778]                   }
[16:04:34.778]                 })
[16:04:34.778]                 withCallingHandlers({
[16:04:34.778]                   NA
[16:04:34.778]                 }, immediateCondition = function(cond) {
[16:04:34.778]                   sendCondition <- ...future.makeSendCondition()
[16:04:34.778]                   sendCondition(cond)
[16:04:34.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.778]                   {
[16:04:34.778]                     inherits <- base::inherits
[16:04:34.778]                     invokeRestart <- base::invokeRestart
[16:04:34.778]                     is.null <- base::is.null
[16:04:34.778]                     muffled <- FALSE
[16:04:34.778]                     if (inherits(cond, "message")) {
[16:04:34.778]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.778]                       if (muffled) 
[16:04:34.778]                         invokeRestart("muffleMessage")
[16:04:34.778]                     }
[16:04:34.778]                     else if (inherits(cond, "warning")) {
[16:04:34.778]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.778]                       if (muffled) 
[16:04:34.778]                         invokeRestart("muffleWarning")
[16:04:34.778]                     }
[16:04:34.778]                     else if (inherits(cond, "condition")) {
[16:04:34.778]                       if (!is.null(pattern)) {
[16:04:34.778]                         computeRestarts <- base::computeRestarts
[16:04:34.778]                         grepl <- base::grepl
[16:04:34.778]                         restarts <- computeRestarts(cond)
[16:04:34.778]                         for (restart in restarts) {
[16:04:34.778]                           name <- restart$name
[16:04:34.778]                           if (is.null(name)) 
[16:04:34.778]                             next
[16:04:34.778]                           if (!grepl(pattern, name)) 
[16:04:34.778]                             next
[16:04:34.778]                           invokeRestart(restart)
[16:04:34.778]                           muffled <- TRUE
[16:04:34.778]                           break
[16:04:34.778]                         }
[16:04:34.778]                       }
[16:04:34.778]                     }
[16:04:34.778]                     invisible(muffled)
[16:04:34.778]                   }
[16:04:34.778]                   muffleCondition(cond)
[16:04:34.778]                 })
[16:04:34.778]             }))
[16:04:34.778]             future::FutureResult(value = ...future.value$value, 
[16:04:34.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.778]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.778]                     ...future.globalenv.names))
[16:04:34.778]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.778]         }, condition = base::local({
[16:04:34.778]             c <- base::c
[16:04:34.778]             inherits <- base::inherits
[16:04:34.778]             invokeRestart <- base::invokeRestart
[16:04:34.778]             length <- base::length
[16:04:34.778]             list <- base::list
[16:04:34.778]             seq.int <- base::seq.int
[16:04:34.778]             signalCondition <- base::signalCondition
[16:04:34.778]             sys.calls <- base::sys.calls
[16:04:34.778]             `[[` <- base::`[[`
[16:04:34.778]             `+` <- base::`+`
[16:04:34.778]             `<<-` <- base::`<<-`
[16:04:34.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.778]                   3L)]
[16:04:34.778]             }
[16:04:34.778]             function(cond) {
[16:04:34.778]                 is_error <- inherits(cond, "error")
[16:04:34.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.778]                   NULL)
[16:04:34.778]                 if (is_error) {
[16:04:34.778]                   sessionInformation <- function() {
[16:04:34.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.778]                       search = base::search(), system = base::Sys.info())
[16:04:34.778]                   }
[16:04:34.778]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.778]                     cond$call), session = sessionInformation(), 
[16:04:34.778]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.778]                   signalCondition(cond)
[16:04:34.778]                 }
[16:04:34.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.778]                 "immediateCondition"))) {
[16:04:34.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.778]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.778]                   if (TRUE && !signal) {
[16:04:34.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.778]                     {
[16:04:34.778]                       inherits <- base::inherits
[16:04:34.778]                       invokeRestart <- base::invokeRestart
[16:04:34.778]                       is.null <- base::is.null
[16:04:34.778]                       muffled <- FALSE
[16:04:34.778]                       if (inherits(cond, "message")) {
[16:04:34.778]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.778]                         if (muffled) 
[16:04:34.778]                           invokeRestart("muffleMessage")
[16:04:34.778]                       }
[16:04:34.778]                       else if (inherits(cond, "warning")) {
[16:04:34.778]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.778]                         if (muffled) 
[16:04:34.778]                           invokeRestart("muffleWarning")
[16:04:34.778]                       }
[16:04:34.778]                       else if (inherits(cond, "condition")) {
[16:04:34.778]                         if (!is.null(pattern)) {
[16:04:34.778]                           computeRestarts <- base::computeRestarts
[16:04:34.778]                           grepl <- base::grepl
[16:04:34.778]                           restarts <- computeRestarts(cond)
[16:04:34.778]                           for (restart in restarts) {
[16:04:34.778]                             name <- restart$name
[16:04:34.778]                             if (is.null(name)) 
[16:04:34.778]                               next
[16:04:34.778]                             if (!grepl(pattern, name)) 
[16:04:34.778]                               next
[16:04:34.778]                             invokeRestart(restart)
[16:04:34.778]                             muffled <- TRUE
[16:04:34.778]                             break
[16:04:34.778]                           }
[16:04:34.778]                         }
[16:04:34.778]                       }
[16:04:34.778]                       invisible(muffled)
[16:04:34.778]                     }
[16:04:34.778]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.778]                   }
[16:04:34.778]                 }
[16:04:34.778]                 else {
[16:04:34.778]                   if (TRUE) {
[16:04:34.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.778]                     {
[16:04:34.778]                       inherits <- base::inherits
[16:04:34.778]                       invokeRestart <- base::invokeRestart
[16:04:34.778]                       is.null <- base::is.null
[16:04:34.778]                       muffled <- FALSE
[16:04:34.778]                       if (inherits(cond, "message")) {
[16:04:34.778]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.778]                         if (muffled) 
[16:04:34.778]                           invokeRestart("muffleMessage")
[16:04:34.778]                       }
[16:04:34.778]                       else if (inherits(cond, "warning")) {
[16:04:34.778]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.778]                         if (muffled) 
[16:04:34.778]                           invokeRestart("muffleWarning")
[16:04:34.778]                       }
[16:04:34.778]                       else if (inherits(cond, "condition")) {
[16:04:34.778]                         if (!is.null(pattern)) {
[16:04:34.778]                           computeRestarts <- base::computeRestarts
[16:04:34.778]                           grepl <- base::grepl
[16:04:34.778]                           restarts <- computeRestarts(cond)
[16:04:34.778]                           for (restart in restarts) {
[16:04:34.778]                             name <- restart$name
[16:04:34.778]                             if (is.null(name)) 
[16:04:34.778]                               next
[16:04:34.778]                             if (!grepl(pattern, name)) 
[16:04:34.778]                               next
[16:04:34.778]                             invokeRestart(restart)
[16:04:34.778]                             muffled <- TRUE
[16:04:34.778]                             break
[16:04:34.778]                           }
[16:04:34.778]                         }
[16:04:34.778]                       }
[16:04:34.778]                       invisible(muffled)
[16:04:34.778]                     }
[16:04:34.778]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.778]                   }
[16:04:34.778]                 }
[16:04:34.778]             }
[16:04:34.778]         }))
[16:04:34.778]     }, error = function(ex) {
[16:04:34.778]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.778]                 ...future.rng), started = ...future.startTime, 
[16:04:34.778]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.778]             version = "1.8"), class = "FutureResult")
[16:04:34.778]     }, finally = {
[16:04:34.778]         if (!identical(...future.workdir, getwd())) 
[16:04:34.778]             setwd(...future.workdir)
[16:04:34.778]         {
[16:04:34.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.778]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.778]             }
[16:04:34.778]             base::options(...future.oldOptions)
[16:04:34.778]             if (.Platform$OS.type == "windows") {
[16:04:34.778]                 old_names <- names(...future.oldEnvVars)
[16:04:34.778]                 envs <- base::Sys.getenv()
[16:04:34.778]                 names <- names(envs)
[16:04:34.778]                 common <- intersect(names, old_names)
[16:04:34.778]                 added <- setdiff(names, old_names)
[16:04:34.778]                 removed <- setdiff(old_names, names)
[16:04:34.778]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.778]                   envs[common]]
[16:04:34.778]                 NAMES <- toupper(changed)
[16:04:34.778]                 args <- list()
[16:04:34.778]                 for (kk in seq_along(NAMES)) {
[16:04:34.778]                   name <- changed[[kk]]
[16:04:34.778]                   NAME <- NAMES[[kk]]
[16:04:34.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.778]                     next
[16:04:34.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.778]                 }
[16:04:34.778]                 NAMES <- toupper(added)
[16:04:34.778]                 for (kk in seq_along(NAMES)) {
[16:04:34.778]                   name <- added[[kk]]
[16:04:34.778]                   NAME <- NAMES[[kk]]
[16:04:34.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.778]                     next
[16:04:34.778]                   args[[name]] <- ""
[16:04:34.778]                 }
[16:04:34.778]                 NAMES <- toupper(removed)
[16:04:34.778]                 for (kk in seq_along(NAMES)) {
[16:04:34.778]                   name <- removed[[kk]]
[16:04:34.778]                   NAME <- NAMES[[kk]]
[16:04:34.778]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.778]                     next
[16:04:34.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.778]                 }
[16:04:34.778]                 if (length(args) > 0) 
[16:04:34.778]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.778]             }
[16:04:34.778]             else {
[16:04:34.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.778]             }
[16:04:34.778]             {
[16:04:34.778]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.778]                   0L) {
[16:04:34.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.778]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.778]                   base::options(opts)
[16:04:34.778]                 }
[16:04:34.778]                 {
[16:04:34.778]                   {
[16:04:34.778]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.778]                     NULL
[16:04:34.778]                   }
[16:04:34.778]                   options(future.plan = NULL)
[16:04:34.778]                   if (is.na(NA_character_)) 
[16:04:34.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.778]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:34.778]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:34.778]                     envir = parent.frame()) 
[16:04:34.778]                   {
[16:04:34.778]                     if (is.function(workers)) 
[16:04:34.778]                       workers <- workers()
[16:04:34.778]                     workers <- structure(as.integer(workers), 
[16:04:34.778]                       class = class(workers))
[16:04:34.778]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:34.778]                       workers >= 1)
[16:04:34.778]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:34.778]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:34.778]                     }
[16:04:34.778]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:34.778]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:34.778]                       envir = envir)
[16:04:34.778]                     if (!future$lazy) 
[16:04:34.778]                       future <- run(future)
[16:04:34.778]                     invisible(future)
[16:04:34.778]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.778]                 }
[16:04:34.778]             }
[16:04:34.778]         }
[16:04:34.778]     })
[16:04:34.778]     if (TRUE) {
[16:04:34.778]         base::sink(type = "output", split = FALSE)
[16:04:34.778]         if (TRUE) {
[16:04:34.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.778]         }
[16:04:34.778]         else {
[16:04:34.778]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.778]         }
[16:04:34.778]         base::close(...future.stdout)
[16:04:34.778]         ...future.stdout <- NULL
[16:04:34.778]     }
[16:04:34.778]     ...future.result$conditions <- ...future.conditions
[16:04:34.778]     ...future.result$finished <- base::Sys.time()
[16:04:34.778]     ...future.result
[16:04:34.778] }
[16:04:34.831] MultisessionFuture started
[16:04:34.831] result() for ClusterFuture ...
[16:04:34.832] receiveMessageFromWorker() for ClusterFuture ...
[16:04:34.832] - Validating connection of MultisessionFuture
[16:04:34.877] - received message: FutureResult
[16:04:34.878] - Received FutureResult
[16:04:34.878] - Erased future from FutureRegistry
[16:04:34.878] result() for ClusterFuture ...
[16:04:34.878] - result already collected: FutureResult
[16:04:34.878] result() for ClusterFuture ... done
[16:04:34.878] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:34.878] result() for ClusterFuture ... done
[16:04:34.879] result() for ClusterFuture ...
[16:04:34.879] - result already collected: FutureResult
[16:04:34.879] result() for ClusterFuture ... done
[16:04:34.879] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:34.883] plan(): nbrOfWorkers() = 2
[16:04:34.883] getGlobalsAndPackages() ...
[16:04:34.883] Searching for globals...
[16:04:34.884] - globals found: [1] ‘{’
[16:04:34.884] Searching for globals ... DONE
[16:04:34.884] Resolving globals: FALSE
[16:04:34.884] 
[16:04:34.884] 
[16:04:34.885] getGlobalsAndPackages() ... DONE
[16:04:34.885] run() for ‘Future’ ...
[16:04:34.885] - state: ‘created’
[16:04:34.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.899] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:34.900]   - Field: ‘node’
[16:04:34.900]   - Field: ‘label’
[16:04:34.900]   - Field: ‘local’
[16:04:34.900]   - Field: ‘owner’
[16:04:34.900]   - Field: ‘envir’
[16:04:34.900]   - Field: ‘workers’
[16:04:34.900]   - Field: ‘packages’
[16:04:34.900]   - Field: ‘gc’
[16:04:34.900]   - Field: ‘conditions’
[16:04:34.901]   - Field: ‘persistent’
[16:04:34.901]   - Field: ‘expr’
[16:04:34.901]   - Field: ‘uuid’
[16:04:34.901]   - Field: ‘seed’
[16:04:34.901]   - Field: ‘version’
[16:04:34.901]   - Field: ‘result’
[16:04:34.901]   - Field: ‘asynchronous’
[16:04:34.901]   - Field: ‘calls’
[16:04:34.902]   - Field: ‘globals’
[16:04:34.902]   - Field: ‘stdout’
[16:04:34.902]   - Field: ‘earlySignal’
[16:04:34.902]   - Field: ‘lazy’
[16:04:34.902]   - Field: ‘state’
[16:04:34.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:34.902] - Launch lazy future ...
[16:04:34.903] Packages needed by the future expression (n = 0): <none>
[16:04:34.903] Packages needed by future strategies (n = 0): <none>
[16:04:34.903] {
[16:04:34.903]     {
[16:04:34.903]         {
[16:04:34.903]             ...future.startTime <- base::Sys.time()
[16:04:34.903]             {
[16:04:34.903]                 {
[16:04:34.903]                   {
[16:04:34.903]                     {
[16:04:34.903]                       base::local({
[16:04:34.903]                         has_future <- base::requireNamespace("future", 
[16:04:34.903]                           quietly = TRUE)
[16:04:34.903]                         if (has_future) {
[16:04:34.903]                           ns <- base::getNamespace("future")
[16:04:34.903]                           version <- ns[[".package"]][["version"]]
[16:04:34.903]                           if (is.null(version)) 
[16:04:34.903]                             version <- utils::packageVersion("future")
[16:04:34.903]                         }
[16:04:34.903]                         else {
[16:04:34.903]                           version <- NULL
[16:04:34.903]                         }
[16:04:34.903]                         if (!has_future || version < "1.8.0") {
[16:04:34.903]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.903]                             "", base::R.version$version.string), 
[16:04:34.903]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.903]                               "release", "version")], collapse = " "), 
[16:04:34.903]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.903]                             info)
[16:04:34.903]                           info <- base::paste(info, collapse = "; ")
[16:04:34.903]                           if (!has_future) {
[16:04:34.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.903]                               info)
[16:04:34.903]                           }
[16:04:34.903]                           else {
[16:04:34.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.903]                               info, version)
[16:04:34.903]                           }
[16:04:34.903]                           base::stop(msg)
[16:04:34.903]                         }
[16:04:34.903]                       })
[16:04:34.903]                     }
[16:04:34.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.903]                     base::options(mc.cores = 1L)
[16:04:34.903]                   }
[16:04:34.903]                   options(future.plan = NULL)
[16:04:34.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.903]                 }
[16:04:34.903]                 ...future.workdir <- getwd()
[16:04:34.903]             }
[16:04:34.903]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.903]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.903]         }
[16:04:34.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.903]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.903]             base::names(...future.oldOptions))
[16:04:34.903]     }
[16:04:34.903]     if (FALSE) {
[16:04:34.903]     }
[16:04:34.903]     else {
[16:04:34.903]         if (TRUE) {
[16:04:34.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.903]                 open = "w")
[16:04:34.903]         }
[16:04:34.903]         else {
[16:04:34.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.903]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.903]         }
[16:04:34.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.903]             base::sink(type = "output", split = FALSE)
[16:04:34.903]             base::close(...future.stdout)
[16:04:34.903]         }, add = TRUE)
[16:04:34.903]     }
[16:04:34.903]     ...future.frame <- base::sys.nframe()
[16:04:34.903]     ...future.conditions <- base::list()
[16:04:34.903]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.903]     if (FALSE) {
[16:04:34.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.903]     }
[16:04:34.903]     ...future.result <- base::tryCatch({
[16:04:34.903]         base::withCallingHandlers({
[16:04:34.903]             ...future.value <- base::withVisible(base::local({
[16:04:34.903]                 ...future.makeSendCondition <- base::local({
[16:04:34.903]                   sendCondition <- NULL
[16:04:34.903]                   function(frame = 1L) {
[16:04:34.903]                     if (is.function(sendCondition)) 
[16:04:34.903]                       return(sendCondition)
[16:04:34.903]                     ns <- getNamespace("parallel")
[16:04:34.903]                     if (exists("sendData", mode = "function", 
[16:04:34.903]                       envir = ns)) {
[16:04:34.903]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:34.903]                         envir = ns)
[16:04:34.903]                       envir <- sys.frame(frame)
[16:04:34.903]                       master <- NULL
[16:04:34.903]                       while (!identical(envir, .GlobalEnv) && 
[16:04:34.903]                         !identical(envir, emptyenv())) {
[16:04:34.903]                         if (exists("master", mode = "list", envir = envir, 
[16:04:34.903]                           inherits = FALSE)) {
[16:04:34.903]                           master <- get("master", mode = "list", 
[16:04:34.903]                             envir = envir, inherits = FALSE)
[16:04:34.903]                           if (inherits(master, c("SOCKnode", 
[16:04:34.903]                             "SOCK0node"))) {
[16:04:34.903]                             sendCondition <<- function(cond) {
[16:04:34.903]                               data <- list(type = "VALUE", value = cond, 
[16:04:34.903]                                 success = TRUE)
[16:04:34.903]                               parallel_sendData(master, data)
[16:04:34.903]                             }
[16:04:34.903]                             return(sendCondition)
[16:04:34.903]                           }
[16:04:34.903]                         }
[16:04:34.903]                         frame <- frame + 1L
[16:04:34.903]                         envir <- sys.frame(frame)
[16:04:34.903]                       }
[16:04:34.903]                     }
[16:04:34.903]                     sendCondition <<- function(cond) NULL
[16:04:34.903]                   }
[16:04:34.903]                 })
[16:04:34.903]                 withCallingHandlers({
[16:04:34.903]                   {
[16:04:34.903]                     2
[16:04:34.903]                   }
[16:04:34.903]                 }, immediateCondition = function(cond) {
[16:04:34.903]                   sendCondition <- ...future.makeSendCondition()
[16:04:34.903]                   sendCondition(cond)
[16:04:34.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.903]                   {
[16:04:34.903]                     inherits <- base::inherits
[16:04:34.903]                     invokeRestart <- base::invokeRestart
[16:04:34.903]                     is.null <- base::is.null
[16:04:34.903]                     muffled <- FALSE
[16:04:34.903]                     if (inherits(cond, "message")) {
[16:04:34.903]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.903]                       if (muffled) 
[16:04:34.903]                         invokeRestart("muffleMessage")
[16:04:34.903]                     }
[16:04:34.903]                     else if (inherits(cond, "warning")) {
[16:04:34.903]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.903]                       if (muffled) 
[16:04:34.903]                         invokeRestart("muffleWarning")
[16:04:34.903]                     }
[16:04:34.903]                     else if (inherits(cond, "condition")) {
[16:04:34.903]                       if (!is.null(pattern)) {
[16:04:34.903]                         computeRestarts <- base::computeRestarts
[16:04:34.903]                         grepl <- base::grepl
[16:04:34.903]                         restarts <- computeRestarts(cond)
[16:04:34.903]                         for (restart in restarts) {
[16:04:34.903]                           name <- restart$name
[16:04:34.903]                           if (is.null(name)) 
[16:04:34.903]                             next
[16:04:34.903]                           if (!grepl(pattern, name)) 
[16:04:34.903]                             next
[16:04:34.903]                           invokeRestart(restart)
[16:04:34.903]                           muffled <- TRUE
[16:04:34.903]                           break
[16:04:34.903]                         }
[16:04:34.903]                       }
[16:04:34.903]                     }
[16:04:34.903]                     invisible(muffled)
[16:04:34.903]                   }
[16:04:34.903]                   muffleCondition(cond)
[16:04:34.903]                 })
[16:04:34.903]             }))
[16:04:34.903]             future::FutureResult(value = ...future.value$value, 
[16:04:34.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.903]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.903]                     ...future.globalenv.names))
[16:04:34.903]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.903]         }, condition = base::local({
[16:04:34.903]             c <- base::c
[16:04:34.903]             inherits <- base::inherits
[16:04:34.903]             invokeRestart <- base::invokeRestart
[16:04:34.903]             length <- base::length
[16:04:34.903]             list <- base::list
[16:04:34.903]             seq.int <- base::seq.int
[16:04:34.903]             signalCondition <- base::signalCondition
[16:04:34.903]             sys.calls <- base::sys.calls
[16:04:34.903]             `[[` <- base::`[[`
[16:04:34.903]             `+` <- base::`+`
[16:04:34.903]             `<<-` <- base::`<<-`
[16:04:34.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.903]                   3L)]
[16:04:34.903]             }
[16:04:34.903]             function(cond) {
[16:04:34.903]                 is_error <- inherits(cond, "error")
[16:04:34.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.903]                   NULL)
[16:04:34.903]                 if (is_error) {
[16:04:34.903]                   sessionInformation <- function() {
[16:04:34.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.903]                       search = base::search(), system = base::Sys.info())
[16:04:34.903]                   }
[16:04:34.903]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.903]                     cond$call), session = sessionInformation(), 
[16:04:34.903]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.903]                   signalCondition(cond)
[16:04:34.903]                 }
[16:04:34.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.903]                 "immediateCondition"))) {
[16:04:34.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.903]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.903]                   if (TRUE && !signal) {
[16:04:34.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.903]                     {
[16:04:34.903]                       inherits <- base::inherits
[16:04:34.903]                       invokeRestart <- base::invokeRestart
[16:04:34.903]                       is.null <- base::is.null
[16:04:34.903]                       muffled <- FALSE
[16:04:34.903]                       if (inherits(cond, "message")) {
[16:04:34.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.903]                         if (muffled) 
[16:04:34.903]                           invokeRestart("muffleMessage")
[16:04:34.903]                       }
[16:04:34.903]                       else if (inherits(cond, "warning")) {
[16:04:34.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.903]                         if (muffled) 
[16:04:34.903]                           invokeRestart("muffleWarning")
[16:04:34.903]                       }
[16:04:34.903]                       else if (inherits(cond, "condition")) {
[16:04:34.903]                         if (!is.null(pattern)) {
[16:04:34.903]                           computeRestarts <- base::computeRestarts
[16:04:34.903]                           grepl <- base::grepl
[16:04:34.903]                           restarts <- computeRestarts(cond)
[16:04:34.903]                           for (restart in restarts) {
[16:04:34.903]                             name <- restart$name
[16:04:34.903]                             if (is.null(name)) 
[16:04:34.903]                               next
[16:04:34.903]                             if (!grepl(pattern, name)) 
[16:04:34.903]                               next
[16:04:34.903]                             invokeRestart(restart)
[16:04:34.903]                             muffled <- TRUE
[16:04:34.903]                             break
[16:04:34.903]                           }
[16:04:34.903]                         }
[16:04:34.903]                       }
[16:04:34.903]                       invisible(muffled)
[16:04:34.903]                     }
[16:04:34.903]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.903]                   }
[16:04:34.903]                 }
[16:04:34.903]                 else {
[16:04:34.903]                   if (TRUE) {
[16:04:34.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.903]                     {
[16:04:34.903]                       inherits <- base::inherits
[16:04:34.903]                       invokeRestart <- base::invokeRestart
[16:04:34.903]                       is.null <- base::is.null
[16:04:34.903]                       muffled <- FALSE
[16:04:34.903]                       if (inherits(cond, "message")) {
[16:04:34.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.903]                         if (muffled) 
[16:04:34.903]                           invokeRestart("muffleMessage")
[16:04:34.903]                       }
[16:04:34.903]                       else if (inherits(cond, "warning")) {
[16:04:34.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.903]                         if (muffled) 
[16:04:34.903]                           invokeRestart("muffleWarning")
[16:04:34.903]                       }
[16:04:34.903]                       else if (inherits(cond, "condition")) {
[16:04:34.903]                         if (!is.null(pattern)) {
[16:04:34.903]                           computeRestarts <- base::computeRestarts
[16:04:34.903]                           grepl <- base::grepl
[16:04:34.903]                           restarts <- computeRestarts(cond)
[16:04:34.903]                           for (restart in restarts) {
[16:04:34.903]                             name <- restart$name
[16:04:34.903]                             if (is.null(name)) 
[16:04:34.903]                               next
[16:04:34.903]                             if (!grepl(pattern, name)) 
[16:04:34.903]                               next
[16:04:34.903]                             invokeRestart(restart)
[16:04:34.903]                             muffled <- TRUE
[16:04:34.903]                             break
[16:04:34.903]                           }
[16:04:34.903]                         }
[16:04:34.903]                       }
[16:04:34.903]                       invisible(muffled)
[16:04:34.903]                     }
[16:04:34.903]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.903]                   }
[16:04:34.903]                 }
[16:04:34.903]             }
[16:04:34.903]         }))
[16:04:34.903]     }, error = function(ex) {
[16:04:34.903]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.903]                 ...future.rng), started = ...future.startTime, 
[16:04:34.903]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.903]             version = "1.8"), class = "FutureResult")
[16:04:34.903]     }, finally = {
[16:04:34.903]         if (!identical(...future.workdir, getwd())) 
[16:04:34.903]             setwd(...future.workdir)
[16:04:34.903]         {
[16:04:34.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.903]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.903]             }
[16:04:34.903]             base::options(...future.oldOptions)
[16:04:34.903]             if (.Platform$OS.type == "windows") {
[16:04:34.903]                 old_names <- names(...future.oldEnvVars)
[16:04:34.903]                 envs <- base::Sys.getenv()
[16:04:34.903]                 names <- names(envs)
[16:04:34.903]                 common <- intersect(names, old_names)
[16:04:34.903]                 added <- setdiff(names, old_names)
[16:04:34.903]                 removed <- setdiff(old_names, names)
[16:04:34.903]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.903]                   envs[common]]
[16:04:34.903]                 NAMES <- toupper(changed)
[16:04:34.903]                 args <- list()
[16:04:34.903]                 for (kk in seq_along(NAMES)) {
[16:04:34.903]                   name <- changed[[kk]]
[16:04:34.903]                   NAME <- NAMES[[kk]]
[16:04:34.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.903]                     next
[16:04:34.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.903]                 }
[16:04:34.903]                 NAMES <- toupper(added)
[16:04:34.903]                 for (kk in seq_along(NAMES)) {
[16:04:34.903]                   name <- added[[kk]]
[16:04:34.903]                   NAME <- NAMES[[kk]]
[16:04:34.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.903]                     next
[16:04:34.903]                   args[[name]] <- ""
[16:04:34.903]                 }
[16:04:34.903]                 NAMES <- toupper(removed)
[16:04:34.903]                 for (kk in seq_along(NAMES)) {
[16:04:34.903]                   name <- removed[[kk]]
[16:04:34.903]                   NAME <- NAMES[[kk]]
[16:04:34.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.903]                     next
[16:04:34.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.903]                 }
[16:04:34.903]                 if (length(args) > 0) 
[16:04:34.903]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.903]             }
[16:04:34.903]             else {
[16:04:34.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.903]             }
[16:04:34.903]             {
[16:04:34.903]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.903]                   0L) {
[16:04:34.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.903]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.903]                   base::options(opts)
[16:04:34.903]                 }
[16:04:34.903]                 {
[16:04:34.903]                   {
[16:04:34.903]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.903]                     NULL
[16:04:34.903]                   }
[16:04:34.903]                   options(future.plan = NULL)
[16:04:34.903]                   if (is.na(NA_character_)) 
[16:04:34.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.903]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:34.903]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:34.903]                     envir = parent.frame()) 
[16:04:34.903]                   {
[16:04:34.903]                     if (is.function(workers)) 
[16:04:34.903]                       workers <- workers()
[16:04:34.903]                     workers <- structure(as.integer(workers), 
[16:04:34.903]                       class = class(workers))
[16:04:34.903]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:34.903]                       workers >= 1)
[16:04:34.903]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:34.903]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:34.903]                     }
[16:04:34.903]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:34.903]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:34.903]                       envir = envir)
[16:04:34.903]                     if (!future$lazy) 
[16:04:34.903]                       future <- run(future)
[16:04:34.903]                     invisible(future)
[16:04:34.903]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.903]                 }
[16:04:34.903]             }
[16:04:34.903]         }
[16:04:34.903]     })
[16:04:34.903]     if (TRUE) {
[16:04:34.903]         base::sink(type = "output", split = FALSE)
[16:04:34.903]         if (TRUE) {
[16:04:34.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.903]         }
[16:04:34.903]         else {
[16:04:34.903]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.903]         }
[16:04:34.903]         base::close(...future.stdout)
[16:04:34.903]         ...future.stdout <- NULL
[16:04:34.903]     }
[16:04:34.903]     ...future.result$conditions <- ...future.conditions
[16:04:34.903]     ...future.result$finished <- base::Sys.time()
[16:04:34.903]     ...future.result
[16:04:34.903] }
[16:04:34.907] MultisessionFuture started
[16:04:34.907] - Launch lazy future ... done
[16:04:34.907] run() for ‘MultisessionFuture’ ... done
[16:04:34.907] getGlobalsAndPackages() ...
[16:04:34.907] Searching for globals...
[16:04:34.908] - globals found: [1] ‘{’
[16:04:34.908] Searching for globals ... DONE
[16:04:34.908] Resolving globals: FALSE
[16:04:34.909] 
[16:04:34.909] 
[16:04:34.909] getGlobalsAndPackages() ... DONE
[16:04:34.909] run() for ‘Future’ ...
[16:04:34.909] - state: ‘created’
[16:04:34.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:34.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:34.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:34.924]   - Field: ‘node’
[16:04:34.924]   - Field: ‘label’
[16:04:34.924]   - Field: ‘local’
[16:04:34.924]   - Field: ‘owner’
[16:04:34.924]   - Field: ‘envir’
[16:04:34.924]   - Field: ‘workers’
[16:04:34.924]   - Field: ‘packages’
[16:04:34.925]   - Field: ‘gc’
[16:04:34.925]   - Field: ‘conditions’
[16:04:34.925]   - Field: ‘persistent’
[16:04:34.925]   - Field: ‘expr’
[16:04:34.925]   - Field: ‘uuid’
[16:04:34.925]   - Field: ‘seed’
[16:04:34.925]   - Field: ‘version’
[16:04:34.925]   - Field: ‘result’
[16:04:34.925]   - Field: ‘asynchronous’
[16:04:34.926]   - Field: ‘calls’
[16:04:34.926]   - Field: ‘globals’
[16:04:34.926]   - Field: ‘stdout’
[16:04:34.926]   - Field: ‘earlySignal’
[16:04:34.926]   - Field: ‘lazy’
[16:04:34.926]   - Field: ‘state’
[16:04:34.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:34.926] - Launch lazy future ...
[16:04:34.927] Packages needed by the future expression (n = 0): <none>
[16:04:34.927] Packages needed by future strategies (n = 0): <none>
[16:04:34.927] {
[16:04:34.927]     {
[16:04:34.927]         {
[16:04:34.927]             ...future.startTime <- base::Sys.time()
[16:04:34.927]             {
[16:04:34.927]                 {
[16:04:34.927]                   {
[16:04:34.927]                     {
[16:04:34.927]                       base::local({
[16:04:34.927]                         has_future <- base::requireNamespace("future", 
[16:04:34.927]                           quietly = TRUE)
[16:04:34.927]                         if (has_future) {
[16:04:34.927]                           ns <- base::getNamespace("future")
[16:04:34.927]                           version <- ns[[".package"]][["version"]]
[16:04:34.927]                           if (is.null(version)) 
[16:04:34.927]                             version <- utils::packageVersion("future")
[16:04:34.927]                         }
[16:04:34.927]                         else {
[16:04:34.927]                           version <- NULL
[16:04:34.927]                         }
[16:04:34.927]                         if (!has_future || version < "1.8.0") {
[16:04:34.927]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:34.927]                             "", base::R.version$version.string), 
[16:04:34.927]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:34.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:34.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:34.927]                               "release", "version")], collapse = " "), 
[16:04:34.927]                             hostname = base::Sys.info()[["nodename"]])
[16:04:34.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:34.927]                             info)
[16:04:34.927]                           info <- base::paste(info, collapse = "; ")
[16:04:34.927]                           if (!has_future) {
[16:04:34.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:34.927]                               info)
[16:04:34.927]                           }
[16:04:34.927]                           else {
[16:04:34.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:34.927]                               info, version)
[16:04:34.927]                           }
[16:04:34.927]                           base::stop(msg)
[16:04:34.927]                         }
[16:04:34.927]                       })
[16:04:34.927]                     }
[16:04:34.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:34.927]                     base::options(mc.cores = 1L)
[16:04:34.927]                   }
[16:04:34.927]                   options(future.plan = NULL)
[16:04:34.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:34.927]                 }
[16:04:34.927]                 ...future.workdir <- getwd()
[16:04:34.927]             }
[16:04:34.927]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:34.927]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:34.927]         }
[16:04:34.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:34.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:34.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:34.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:34.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:34.927]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:34.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:34.927]             base::names(...future.oldOptions))
[16:04:34.927]     }
[16:04:34.927]     if (FALSE) {
[16:04:34.927]     }
[16:04:34.927]     else {
[16:04:34.927]         if (TRUE) {
[16:04:34.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:34.927]                 open = "w")
[16:04:34.927]         }
[16:04:34.927]         else {
[16:04:34.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:34.927]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:34.927]         }
[16:04:34.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:34.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:34.927]             base::sink(type = "output", split = FALSE)
[16:04:34.927]             base::close(...future.stdout)
[16:04:34.927]         }, add = TRUE)
[16:04:34.927]     }
[16:04:34.927]     ...future.frame <- base::sys.nframe()
[16:04:34.927]     ...future.conditions <- base::list()
[16:04:34.927]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:34.927]     if (FALSE) {
[16:04:34.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:34.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:34.927]     }
[16:04:34.927]     ...future.result <- base::tryCatch({
[16:04:34.927]         base::withCallingHandlers({
[16:04:34.927]             ...future.value <- base::withVisible(base::local({
[16:04:34.927]                 ...future.makeSendCondition <- base::local({
[16:04:34.927]                   sendCondition <- NULL
[16:04:34.927]                   function(frame = 1L) {
[16:04:34.927]                     if (is.function(sendCondition)) 
[16:04:34.927]                       return(sendCondition)
[16:04:34.927]                     ns <- getNamespace("parallel")
[16:04:34.927]                     if (exists("sendData", mode = "function", 
[16:04:34.927]                       envir = ns)) {
[16:04:34.927]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:34.927]                         envir = ns)
[16:04:34.927]                       envir <- sys.frame(frame)
[16:04:34.927]                       master <- NULL
[16:04:34.927]                       while (!identical(envir, .GlobalEnv) && 
[16:04:34.927]                         !identical(envir, emptyenv())) {
[16:04:34.927]                         if (exists("master", mode = "list", envir = envir, 
[16:04:34.927]                           inherits = FALSE)) {
[16:04:34.927]                           master <- get("master", mode = "list", 
[16:04:34.927]                             envir = envir, inherits = FALSE)
[16:04:34.927]                           if (inherits(master, c("SOCKnode", 
[16:04:34.927]                             "SOCK0node"))) {
[16:04:34.927]                             sendCondition <<- function(cond) {
[16:04:34.927]                               data <- list(type = "VALUE", value = cond, 
[16:04:34.927]                                 success = TRUE)
[16:04:34.927]                               parallel_sendData(master, data)
[16:04:34.927]                             }
[16:04:34.927]                             return(sendCondition)
[16:04:34.927]                           }
[16:04:34.927]                         }
[16:04:34.927]                         frame <- frame + 1L
[16:04:34.927]                         envir <- sys.frame(frame)
[16:04:34.927]                       }
[16:04:34.927]                     }
[16:04:34.927]                     sendCondition <<- function(cond) NULL
[16:04:34.927]                   }
[16:04:34.927]                 })
[16:04:34.927]                 withCallingHandlers({
[16:04:34.927]                   {
[16:04:34.927]                     4
[16:04:34.927]                   }
[16:04:34.927]                 }, immediateCondition = function(cond) {
[16:04:34.927]                   sendCondition <- ...future.makeSendCondition()
[16:04:34.927]                   sendCondition(cond)
[16:04:34.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.927]                   {
[16:04:34.927]                     inherits <- base::inherits
[16:04:34.927]                     invokeRestart <- base::invokeRestart
[16:04:34.927]                     is.null <- base::is.null
[16:04:34.927]                     muffled <- FALSE
[16:04:34.927]                     if (inherits(cond, "message")) {
[16:04:34.927]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:34.927]                       if (muffled) 
[16:04:34.927]                         invokeRestart("muffleMessage")
[16:04:34.927]                     }
[16:04:34.927]                     else if (inherits(cond, "warning")) {
[16:04:34.927]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:34.927]                       if (muffled) 
[16:04:34.927]                         invokeRestart("muffleWarning")
[16:04:34.927]                     }
[16:04:34.927]                     else if (inherits(cond, "condition")) {
[16:04:34.927]                       if (!is.null(pattern)) {
[16:04:34.927]                         computeRestarts <- base::computeRestarts
[16:04:34.927]                         grepl <- base::grepl
[16:04:34.927]                         restarts <- computeRestarts(cond)
[16:04:34.927]                         for (restart in restarts) {
[16:04:34.927]                           name <- restart$name
[16:04:34.927]                           if (is.null(name)) 
[16:04:34.927]                             next
[16:04:34.927]                           if (!grepl(pattern, name)) 
[16:04:34.927]                             next
[16:04:34.927]                           invokeRestart(restart)
[16:04:34.927]                           muffled <- TRUE
[16:04:34.927]                           break
[16:04:34.927]                         }
[16:04:34.927]                       }
[16:04:34.927]                     }
[16:04:34.927]                     invisible(muffled)
[16:04:34.927]                   }
[16:04:34.927]                   muffleCondition(cond)
[16:04:34.927]                 })
[16:04:34.927]             }))
[16:04:34.927]             future::FutureResult(value = ...future.value$value, 
[16:04:34.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.927]                   ...future.rng), globalenv = if (FALSE) 
[16:04:34.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:34.927]                     ...future.globalenv.names))
[16:04:34.927]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:34.927]         }, condition = base::local({
[16:04:34.927]             c <- base::c
[16:04:34.927]             inherits <- base::inherits
[16:04:34.927]             invokeRestart <- base::invokeRestart
[16:04:34.927]             length <- base::length
[16:04:34.927]             list <- base::list
[16:04:34.927]             seq.int <- base::seq.int
[16:04:34.927]             signalCondition <- base::signalCondition
[16:04:34.927]             sys.calls <- base::sys.calls
[16:04:34.927]             `[[` <- base::`[[`
[16:04:34.927]             `+` <- base::`+`
[16:04:34.927]             `<<-` <- base::`<<-`
[16:04:34.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:34.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:34.927]                   3L)]
[16:04:34.927]             }
[16:04:34.927]             function(cond) {
[16:04:34.927]                 is_error <- inherits(cond, "error")
[16:04:34.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:34.927]                   NULL)
[16:04:34.927]                 if (is_error) {
[16:04:34.927]                   sessionInformation <- function() {
[16:04:34.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:34.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:34.927]                       search = base::search(), system = base::Sys.info())
[16:04:34.927]                   }
[16:04:34.927]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:34.927]                     cond$call), session = sessionInformation(), 
[16:04:34.927]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:34.927]                   signalCondition(cond)
[16:04:34.927]                 }
[16:04:34.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:34.927]                 "immediateCondition"))) {
[16:04:34.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:34.927]                   ...future.conditions[[length(...future.conditions) + 
[16:04:34.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:34.927]                   if (TRUE && !signal) {
[16:04:34.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.927]                     {
[16:04:34.927]                       inherits <- base::inherits
[16:04:34.927]                       invokeRestart <- base::invokeRestart
[16:04:34.927]                       is.null <- base::is.null
[16:04:34.927]                       muffled <- FALSE
[16:04:34.927]                       if (inherits(cond, "message")) {
[16:04:34.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.927]                         if (muffled) 
[16:04:34.927]                           invokeRestart("muffleMessage")
[16:04:34.927]                       }
[16:04:34.927]                       else if (inherits(cond, "warning")) {
[16:04:34.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.927]                         if (muffled) 
[16:04:34.927]                           invokeRestart("muffleWarning")
[16:04:34.927]                       }
[16:04:34.927]                       else if (inherits(cond, "condition")) {
[16:04:34.927]                         if (!is.null(pattern)) {
[16:04:34.927]                           computeRestarts <- base::computeRestarts
[16:04:34.927]                           grepl <- base::grepl
[16:04:34.927]                           restarts <- computeRestarts(cond)
[16:04:34.927]                           for (restart in restarts) {
[16:04:34.927]                             name <- restart$name
[16:04:34.927]                             if (is.null(name)) 
[16:04:34.927]                               next
[16:04:34.927]                             if (!grepl(pattern, name)) 
[16:04:34.927]                               next
[16:04:34.927]                             invokeRestart(restart)
[16:04:34.927]                             muffled <- TRUE
[16:04:34.927]                             break
[16:04:34.927]                           }
[16:04:34.927]                         }
[16:04:34.927]                       }
[16:04:34.927]                       invisible(muffled)
[16:04:34.927]                     }
[16:04:34.927]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.927]                   }
[16:04:34.927]                 }
[16:04:34.927]                 else {
[16:04:34.927]                   if (TRUE) {
[16:04:34.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:34.927]                     {
[16:04:34.927]                       inherits <- base::inherits
[16:04:34.927]                       invokeRestart <- base::invokeRestart
[16:04:34.927]                       is.null <- base::is.null
[16:04:34.927]                       muffled <- FALSE
[16:04:34.927]                       if (inherits(cond, "message")) {
[16:04:34.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:34.927]                         if (muffled) 
[16:04:34.927]                           invokeRestart("muffleMessage")
[16:04:34.927]                       }
[16:04:34.927]                       else if (inherits(cond, "warning")) {
[16:04:34.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:34.927]                         if (muffled) 
[16:04:34.927]                           invokeRestart("muffleWarning")
[16:04:34.927]                       }
[16:04:34.927]                       else if (inherits(cond, "condition")) {
[16:04:34.927]                         if (!is.null(pattern)) {
[16:04:34.927]                           computeRestarts <- base::computeRestarts
[16:04:34.927]                           grepl <- base::grepl
[16:04:34.927]                           restarts <- computeRestarts(cond)
[16:04:34.927]                           for (restart in restarts) {
[16:04:34.927]                             name <- restart$name
[16:04:34.927]                             if (is.null(name)) 
[16:04:34.927]                               next
[16:04:34.927]                             if (!grepl(pattern, name)) 
[16:04:34.927]                               next
[16:04:34.927]                             invokeRestart(restart)
[16:04:34.927]                             muffled <- TRUE
[16:04:34.927]                             break
[16:04:34.927]                           }
[16:04:34.927]                         }
[16:04:34.927]                       }
[16:04:34.927]                       invisible(muffled)
[16:04:34.927]                     }
[16:04:34.927]                     muffleCondition(cond, pattern = "^muffle")
[16:04:34.927]                   }
[16:04:34.927]                 }
[16:04:34.927]             }
[16:04:34.927]         }))
[16:04:34.927]     }, error = function(ex) {
[16:04:34.927]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:34.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:34.927]                 ...future.rng), started = ...future.startTime, 
[16:04:34.927]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:34.927]             version = "1.8"), class = "FutureResult")
[16:04:34.927]     }, finally = {
[16:04:34.927]         if (!identical(...future.workdir, getwd())) 
[16:04:34.927]             setwd(...future.workdir)
[16:04:34.927]         {
[16:04:34.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:34.927]                 ...future.oldOptions$nwarnings <- NULL
[16:04:34.927]             }
[16:04:34.927]             base::options(...future.oldOptions)
[16:04:34.927]             if (.Platform$OS.type == "windows") {
[16:04:34.927]                 old_names <- names(...future.oldEnvVars)
[16:04:34.927]                 envs <- base::Sys.getenv()
[16:04:34.927]                 names <- names(envs)
[16:04:34.927]                 common <- intersect(names, old_names)
[16:04:34.927]                 added <- setdiff(names, old_names)
[16:04:34.927]                 removed <- setdiff(old_names, names)
[16:04:34.927]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:34.927]                   envs[common]]
[16:04:34.927]                 NAMES <- toupper(changed)
[16:04:34.927]                 args <- list()
[16:04:34.927]                 for (kk in seq_along(NAMES)) {
[16:04:34.927]                   name <- changed[[kk]]
[16:04:34.927]                   NAME <- NAMES[[kk]]
[16:04:34.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.927]                     next
[16:04:34.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.927]                 }
[16:04:34.927]                 NAMES <- toupper(added)
[16:04:34.927]                 for (kk in seq_along(NAMES)) {
[16:04:34.927]                   name <- added[[kk]]
[16:04:34.927]                   NAME <- NAMES[[kk]]
[16:04:34.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.927]                     next
[16:04:34.927]                   args[[name]] <- ""
[16:04:34.927]                 }
[16:04:34.927]                 NAMES <- toupper(removed)
[16:04:34.927]                 for (kk in seq_along(NAMES)) {
[16:04:34.927]                   name <- removed[[kk]]
[16:04:34.927]                   NAME <- NAMES[[kk]]
[16:04:34.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:34.927]                     next
[16:04:34.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:34.927]                 }
[16:04:34.927]                 if (length(args) > 0) 
[16:04:34.927]                   base::do.call(base::Sys.setenv, args = args)
[16:04:34.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:34.927]             }
[16:04:34.927]             else {
[16:04:34.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:34.927]             }
[16:04:34.927]             {
[16:04:34.927]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:34.927]                   0L) {
[16:04:34.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:34.927]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:34.927]                   base::options(opts)
[16:04:34.927]                 }
[16:04:34.927]                 {
[16:04:34.927]                   {
[16:04:34.927]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:34.927]                     NULL
[16:04:34.927]                   }
[16:04:34.927]                   options(future.plan = NULL)
[16:04:34.927]                   if (is.na(NA_character_)) 
[16:04:34.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:34.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:34.927]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:34.927]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:34.927]                     envir = parent.frame()) 
[16:04:34.927]                   {
[16:04:34.927]                     if (is.function(workers)) 
[16:04:34.927]                       workers <- workers()
[16:04:34.927]                     workers <- structure(as.integer(workers), 
[16:04:34.927]                       class = class(workers))
[16:04:34.927]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:34.927]                       workers >= 1)
[16:04:34.927]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:34.927]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:34.927]                     }
[16:04:34.927]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:34.927]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:34.927]                       envir = envir)
[16:04:34.927]                     if (!future$lazy) 
[16:04:34.927]                       future <- run(future)
[16:04:34.927]                     invisible(future)
[16:04:34.927]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:34.927]                 }
[16:04:34.927]             }
[16:04:34.927]         }
[16:04:34.927]     })
[16:04:34.927]     if (TRUE) {
[16:04:34.927]         base::sink(type = "output", split = FALSE)
[16:04:34.927]         if (TRUE) {
[16:04:34.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:34.927]         }
[16:04:34.927]         else {
[16:04:34.927]             ...future.result["stdout"] <- base::list(NULL)
[16:04:34.927]         }
[16:04:34.927]         base::close(...future.stdout)
[16:04:34.927]         ...future.stdout <- NULL
[16:04:34.927]     }
[16:04:34.927]     ...future.result$conditions <- ...future.conditions
[16:04:34.927]     ...future.result$finished <- base::Sys.time()
[16:04:34.927]     ...future.result
[16:04:34.927] }
[16:04:34.981] MultisessionFuture started
[16:04:34.981] - Launch lazy future ... done
[16:04:34.981] run() for ‘MultisessionFuture’ ... done
[16:04:34.981] result() for ClusterFuture ...
[16:04:34.981] receiveMessageFromWorker() for ClusterFuture ...
[16:04:34.981] - Validating connection of MultisessionFuture
[16:04:34.982] - received message: FutureResult
[16:04:34.982] - Received FutureResult
[16:04:34.982] - Erased future from FutureRegistry
[16:04:34.982] result() for ClusterFuture ...
[16:04:34.982] - result already collected: FutureResult
[16:04:34.982] result() for ClusterFuture ... done
[16:04:34.982] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:34.982] result() for ClusterFuture ... done
[16:04:34.983] result() for ClusterFuture ...
[16:04:34.983] - result already collected: FutureResult
[16:04:34.983] result() for ClusterFuture ... done
u$a = 2
[16:04:34.983] result() for ClusterFuture ...
[16:04:34.983] receiveMessageFromWorker() for ClusterFuture ...
[16:04:34.983] - Validating connection of MultisessionFuture
[16:04:35.024] - received message: FutureResult
[16:04:35.025] - Received FutureResult
[16:04:35.025] - Erased future from FutureRegistry
[16:04:35.025] result() for ClusterFuture ...
[16:04:35.025] - result already collected: FutureResult
[16:04:35.025] result() for ClusterFuture ... done
[16:04:35.025] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.025] result() for ClusterFuture ... done
[16:04:35.026] result() for ClusterFuture ...
[16:04:35.026] - result already collected: FutureResult
[16:04:35.026] result() for ClusterFuture ... done
v$a = 4
[16:04:35.026] getGlobalsAndPackages() ...
[16:04:35.026] Searching for globals...
[16:04:35.027] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:35.027] Searching for globals ... DONE
[16:04:35.028] Resolving globals: FALSE
[16:04:35.028] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:35.028] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:35.029] - globals: [1] ‘a’
[16:04:35.029] 
[16:04:35.029] getGlobalsAndPackages() ... DONE
[16:04:35.029] run() for ‘Future’ ...
[16:04:35.029] - state: ‘created’
[16:04:35.029] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:35.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:35.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:35.044]   - Field: ‘node’
[16:04:35.044]   - Field: ‘label’
[16:04:35.044]   - Field: ‘local’
[16:04:35.044]   - Field: ‘owner’
[16:04:35.044]   - Field: ‘envir’
[16:04:35.045]   - Field: ‘workers’
[16:04:35.045]   - Field: ‘packages’
[16:04:35.045]   - Field: ‘gc’
[16:04:35.045]   - Field: ‘conditions’
[16:04:35.045]   - Field: ‘persistent’
[16:04:35.045]   - Field: ‘expr’
[16:04:35.045]   - Field: ‘uuid’
[16:04:35.045]   - Field: ‘seed’
[16:04:35.045]   - Field: ‘version’
[16:04:35.046]   - Field: ‘result’
[16:04:35.046]   - Field: ‘asynchronous’
[16:04:35.046]   - Field: ‘calls’
[16:04:35.046]   - Field: ‘globals’
[16:04:35.046]   - Field: ‘stdout’
[16:04:35.046]   - Field: ‘earlySignal’
[16:04:35.046]   - Field: ‘lazy’
[16:04:35.046]   - Field: ‘state’
[16:04:35.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:35.047] - Launch lazy future ...
[16:04:35.047] Packages needed by the future expression (n = 0): <none>
[16:04:35.047] Packages needed by future strategies (n = 0): <none>
[16:04:35.048] {
[16:04:35.048]     {
[16:04:35.048]         {
[16:04:35.048]             ...future.startTime <- base::Sys.time()
[16:04:35.048]             {
[16:04:35.048]                 {
[16:04:35.048]                   {
[16:04:35.048]                     {
[16:04:35.048]                       base::local({
[16:04:35.048]                         has_future <- base::requireNamespace("future", 
[16:04:35.048]                           quietly = TRUE)
[16:04:35.048]                         if (has_future) {
[16:04:35.048]                           ns <- base::getNamespace("future")
[16:04:35.048]                           version <- ns[[".package"]][["version"]]
[16:04:35.048]                           if (is.null(version)) 
[16:04:35.048]                             version <- utils::packageVersion("future")
[16:04:35.048]                         }
[16:04:35.048]                         else {
[16:04:35.048]                           version <- NULL
[16:04:35.048]                         }
[16:04:35.048]                         if (!has_future || version < "1.8.0") {
[16:04:35.048]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:35.048]                             "", base::R.version$version.string), 
[16:04:35.048]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:35.048]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:35.048]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:35.048]                               "release", "version")], collapse = " "), 
[16:04:35.048]                             hostname = base::Sys.info()[["nodename"]])
[16:04:35.048]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:35.048]                             info)
[16:04:35.048]                           info <- base::paste(info, collapse = "; ")
[16:04:35.048]                           if (!has_future) {
[16:04:35.048]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:35.048]                               info)
[16:04:35.048]                           }
[16:04:35.048]                           else {
[16:04:35.048]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:35.048]                               info, version)
[16:04:35.048]                           }
[16:04:35.048]                           base::stop(msg)
[16:04:35.048]                         }
[16:04:35.048]                       })
[16:04:35.048]                     }
[16:04:35.048]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:35.048]                     base::options(mc.cores = 1L)
[16:04:35.048]                   }
[16:04:35.048]                   options(future.plan = NULL)
[16:04:35.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:35.048]                 }
[16:04:35.048]                 ...future.workdir <- getwd()
[16:04:35.048]             }
[16:04:35.048]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:35.048]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:35.048]         }
[16:04:35.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:35.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:35.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:35.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:35.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:35.048]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:35.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:35.048]             base::names(...future.oldOptions))
[16:04:35.048]     }
[16:04:35.048]     if (FALSE) {
[16:04:35.048]     }
[16:04:35.048]     else {
[16:04:35.048]         if (TRUE) {
[16:04:35.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:35.048]                 open = "w")
[16:04:35.048]         }
[16:04:35.048]         else {
[16:04:35.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:35.048]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:35.048]         }
[16:04:35.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:35.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:35.048]             base::sink(type = "output", split = FALSE)
[16:04:35.048]             base::close(...future.stdout)
[16:04:35.048]         }, add = TRUE)
[16:04:35.048]     }
[16:04:35.048]     ...future.frame <- base::sys.nframe()
[16:04:35.048]     ...future.conditions <- base::list()
[16:04:35.048]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:35.048]     if (FALSE) {
[16:04:35.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:35.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:35.048]     }
[16:04:35.048]     ...future.result <- base::tryCatch({
[16:04:35.048]         base::withCallingHandlers({
[16:04:35.048]             ...future.value <- base::withVisible(base::local({
[16:04:35.048]                 ...future.makeSendCondition <- base::local({
[16:04:35.048]                   sendCondition <- NULL
[16:04:35.048]                   function(frame = 1L) {
[16:04:35.048]                     if (is.function(sendCondition)) 
[16:04:35.048]                       return(sendCondition)
[16:04:35.048]                     ns <- getNamespace("parallel")
[16:04:35.048]                     if (exists("sendData", mode = "function", 
[16:04:35.048]                       envir = ns)) {
[16:04:35.048]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:35.048]                         envir = ns)
[16:04:35.048]                       envir <- sys.frame(frame)
[16:04:35.048]                       master <- NULL
[16:04:35.048]                       while (!identical(envir, .GlobalEnv) && 
[16:04:35.048]                         !identical(envir, emptyenv())) {
[16:04:35.048]                         if (exists("master", mode = "list", envir = envir, 
[16:04:35.048]                           inherits = FALSE)) {
[16:04:35.048]                           master <- get("master", mode = "list", 
[16:04:35.048]                             envir = envir, inherits = FALSE)
[16:04:35.048]                           if (inherits(master, c("SOCKnode", 
[16:04:35.048]                             "SOCK0node"))) {
[16:04:35.048]                             sendCondition <<- function(cond) {
[16:04:35.048]                               data <- list(type = "VALUE", value = cond, 
[16:04:35.048]                                 success = TRUE)
[16:04:35.048]                               parallel_sendData(master, data)
[16:04:35.048]                             }
[16:04:35.048]                             return(sendCondition)
[16:04:35.048]                           }
[16:04:35.048]                         }
[16:04:35.048]                         frame <- frame + 1L
[16:04:35.048]                         envir <- sys.frame(frame)
[16:04:35.048]                       }
[16:04:35.048]                     }
[16:04:35.048]                     sendCondition <<- function(cond) NULL
[16:04:35.048]                   }
[16:04:35.048]                 })
[16:04:35.048]                 withCallingHandlers({
[16:04:35.048]                   {
[16:04:35.048]                     2 * a
[16:04:35.048]                   }
[16:04:35.048]                 }, immediateCondition = function(cond) {
[16:04:35.048]                   sendCondition <- ...future.makeSendCondition()
[16:04:35.048]                   sendCondition(cond)
[16:04:35.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.048]                   {
[16:04:35.048]                     inherits <- base::inherits
[16:04:35.048]                     invokeRestart <- base::invokeRestart
[16:04:35.048]                     is.null <- base::is.null
[16:04:35.048]                     muffled <- FALSE
[16:04:35.048]                     if (inherits(cond, "message")) {
[16:04:35.048]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:35.048]                       if (muffled) 
[16:04:35.048]                         invokeRestart("muffleMessage")
[16:04:35.048]                     }
[16:04:35.048]                     else if (inherits(cond, "warning")) {
[16:04:35.048]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:35.048]                       if (muffled) 
[16:04:35.048]                         invokeRestart("muffleWarning")
[16:04:35.048]                     }
[16:04:35.048]                     else if (inherits(cond, "condition")) {
[16:04:35.048]                       if (!is.null(pattern)) {
[16:04:35.048]                         computeRestarts <- base::computeRestarts
[16:04:35.048]                         grepl <- base::grepl
[16:04:35.048]                         restarts <- computeRestarts(cond)
[16:04:35.048]                         for (restart in restarts) {
[16:04:35.048]                           name <- restart$name
[16:04:35.048]                           if (is.null(name)) 
[16:04:35.048]                             next
[16:04:35.048]                           if (!grepl(pattern, name)) 
[16:04:35.048]                             next
[16:04:35.048]                           invokeRestart(restart)
[16:04:35.048]                           muffled <- TRUE
[16:04:35.048]                           break
[16:04:35.048]                         }
[16:04:35.048]                       }
[16:04:35.048]                     }
[16:04:35.048]                     invisible(muffled)
[16:04:35.048]                   }
[16:04:35.048]                   muffleCondition(cond)
[16:04:35.048]                 })
[16:04:35.048]             }))
[16:04:35.048]             future::FutureResult(value = ...future.value$value, 
[16:04:35.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.048]                   ...future.rng), globalenv = if (FALSE) 
[16:04:35.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:35.048]                     ...future.globalenv.names))
[16:04:35.048]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:35.048]         }, condition = base::local({
[16:04:35.048]             c <- base::c
[16:04:35.048]             inherits <- base::inherits
[16:04:35.048]             invokeRestart <- base::invokeRestart
[16:04:35.048]             length <- base::length
[16:04:35.048]             list <- base::list
[16:04:35.048]             seq.int <- base::seq.int
[16:04:35.048]             signalCondition <- base::signalCondition
[16:04:35.048]             sys.calls <- base::sys.calls
[16:04:35.048]             `[[` <- base::`[[`
[16:04:35.048]             `+` <- base::`+`
[16:04:35.048]             `<<-` <- base::`<<-`
[16:04:35.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:35.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:35.048]                   3L)]
[16:04:35.048]             }
[16:04:35.048]             function(cond) {
[16:04:35.048]                 is_error <- inherits(cond, "error")
[16:04:35.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:35.048]                   NULL)
[16:04:35.048]                 if (is_error) {
[16:04:35.048]                   sessionInformation <- function() {
[16:04:35.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:35.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:35.048]                       search = base::search(), system = base::Sys.info())
[16:04:35.048]                   }
[16:04:35.048]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:35.048]                     cond$call), session = sessionInformation(), 
[16:04:35.048]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:35.048]                   signalCondition(cond)
[16:04:35.048]                 }
[16:04:35.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:35.048]                 "immediateCondition"))) {
[16:04:35.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:35.048]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:35.048]                   if (TRUE && !signal) {
[16:04:35.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.048]                     {
[16:04:35.048]                       inherits <- base::inherits
[16:04:35.048]                       invokeRestart <- base::invokeRestart
[16:04:35.048]                       is.null <- base::is.null
[16:04:35.048]                       muffled <- FALSE
[16:04:35.048]                       if (inherits(cond, "message")) {
[16:04:35.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.048]                         if (muffled) 
[16:04:35.048]                           invokeRestart("muffleMessage")
[16:04:35.048]                       }
[16:04:35.048]                       else if (inherits(cond, "warning")) {
[16:04:35.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.048]                         if (muffled) 
[16:04:35.048]                           invokeRestart("muffleWarning")
[16:04:35.048]                       }
[16:04:35.048]                       else if (inherits(cond, "condition")) {
[16:04:35.048]                         if (!is.null(pattern)) {
[16:04:35.048]                           computeRestarts <- base::computeRestarts
[16:04:35.048]                           grepl <- base::grepl
[16:04:35.048]                           restarts <- computeRestarts(cond)
[16:04:35.048]                           for (restart in restarts) {
[16:04:35.048]                             name <- restart$name
[16:04:35.048]                             if (is.null(name)) 
[16:04:35.048]                               next
[16:04:35.048]                             if (!grepl(pattern, name)) 
[16:04:35.048]                               next
[16:04:35.048]                             invokeRestart(restart)
[16:04:35.048]                             muffled <- TRUE
[16:04:35.048]                             break
[16:04:35.048]                           }
[16:04:35.048]                         }
[16:04:35.048]                       }
[16:04:35.048]                       invisible(muffled)
[16:04:35.048]                     }
[16:04:35.048]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.048]                   }
[16:04:35.048]                 }
[16:04:35.048]                 else {
[16:04:35.048]                   if (TRUE) {
[16:04:35.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.048]                     {
[16:04:35.048]                       inherits <- base::inherits
[16:04:35.048]                       invokeRestart <- base::invokeRestart
[16:04:35.048]                       is.null <- base::is.null
[16:04:35.048]                       muffled <- FALSE
[16:04:35.048]                       if (inherits(cond, "message")) {
[16:04:35.048]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.048]                         if (muffled) 
[16:04:35.048]                           invokeRestart("muffleMessage")
[16:04:35.048]                       }
[16:04:35.048]                       else if (inherits(cond, "warning")) {
[16:04:35.048]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.048]                         if (muffled) 
[16:04:35.048]                           invokeRestart("muffleWarning")
[16:04:35.048]                       }
[16:04:35.048]                       else if (inherits(cond, "condition")) {
[16:04:35.048]                         if (!is.null(pattern)) {
[16:04:35.048]                           computeRestarts <- base::computeRestarts
[16:04:35.048]                           grepl <- base::grepl
[16:04:35.048]                           restarts <- computeRestarts(cond)
[16:04:35.048]                           for (restart in restarts) {
[16:04:35.048]                             name <- restart$name
[16:04:35.048]                             if (is.null(name)) 
[16:04:35.048]                               next
[16:04:35.048]                             if (!grepl(pattern, name)) 
[16:04:35.048]                               next
[16:04:35.048]                             invokeRestart(restart)
[16:04:35.048]                             muffled <- TRUE
[16:04:35.048]                             break
[16:04:35.048]                           }
[16:04:35.048]                         }
[16:04:35.048]                       }
[16:04:35.048]                       invisible(muffled)
[16:04:35.048]                     }
[16:04:35.048]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.048]                   }
[16:04:35.048]                 }
[16:04:35.048]             }
[16:04:35.048]         }))
[16:04:35.048]     }, error = function(ex) {
[16:04:35.048]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:35.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.048]                 ...future.rng), started = ...future.startTime, 
[16:04:35.048]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:35.048]             version = "1.8"), class = "FutureResult")
[16:04:35.048]     }, finally = {
[16:04:35.048]         if (!identical(...future.workdir, getwd())) 
[16:04:35.048]             setwd(...future.workdir)
[16:04:35.048]         {
[16:04:35.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:35.048]                 ...future.oldOptions$nwarnings <- NULL
[16:04:35.048]             }
[16:04:35.048]             base::options(...future.oldOptions)
[16:04:35.048]             if (.Platform$OS.type == "windows") {
[16:04:35.048]                 old_names <- names(...future.oldEnvVars)
[16:04:35.048]                 envs <- base::Sys.getenv()
[16:04:35.048]                 names <- names(envs)
[16:04:35.048]                 common <- intersect(names, old_names)
[16:04:35.048]                 added <- setdiff(names, old_names)
[16:04:35.048]                 removed <- setdiff(old_names, names)
[16:04:35.048]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:35.048]                   envs[common]]
[16:04:35.048]                 NAMES <- toupper(changed)
[16:04:35.048]                 args <- list()
[16:04:35.048]                 for (kk in seq_along(NAMES)) {
[16:04:35.048]                   name <- changed[[kk]]
[16:04:35.048]                   NAME <- NAMES[[kk]]
[16:04:35.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.048]                     next
[16:04:35.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.048]                 }
[16:04:35.048]                 NAMES <- toupper(added)
[16:04:35.048]                 for (kk in seq_along(NAMES)) {
[16:04:35.048]                   name <- added[[kk]]
[16:04:35.048]                   NAME <- NAMES[[kk]]
[16:04:35.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.048]                     next
[16:04:35.048]                   args[[name]] <- ""
[16:04:35.048]                 }
[16:04:35.048]                 NAMES <- toupper(removed)
[16:04:35.048]                 for (kk in seq_along(NAMES)) {
[16:04:35.048]                   name <- removed[[kk]]
[16:04:35.048]                   NAME <- NAMES[[kk]]
[16:04:35.048]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.048]                     next
[16:04:35.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.048]                 }
[16:04:35.048]                 if (length(args) > 0) 
[16:04:35.048]                   base::do.call(base::Sys.setenv, args = args)
[16:04:35.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:35.048]             }
[16:04:35.048]             else {
[16:04:35.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:35.048]             }
[16:04:35.048]             {
[16:04:35.048]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:35.048]                   0L) {
[16:04:35.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:35.048]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:35.048]                   base::options(opts)
[16:04:35.048]                 }
[16:04:35.048]                 {
[16:04:35.048]                   {
[16:04:35.048]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:35.048]                     NULL
[16:04:35.048]                   }
[16:04:35.048]                   options(future.plan = NULL)
[16:04:35.048]                   if (is.na(NA_character_)) 
[16:04:35.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:35.048]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:35.048]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:35.048]                     envir = parent.frame()) 
[16:04:35.048]                   {
[16:04:35.048]                     if (is.function(workers)) 
[16:04:35.048]                       workers <- workers()
[16:04:35.048]                     workers <- structure(as.integer(workers), 
[16:04:35.048]                       class = class(workers))
[16:04:35.048]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:35.048]                       workers >= 1)
[16:04:35.048]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:35.048]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:35.048]                     }
[16:04:35.048]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:35.048]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:35.048]                       envir = envir)
[16:04:35.048]                     if (!future$lazy) 
[16:04:35.048]                       future <- run(future)
[16:04:35.048]                     invisible(future)
[16:04:35.048]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:35.048]                 }
[16:04:35.048]             }
[16:04:35.048]         }
[16:04:35.048]     })
[16:04:35.048]     if (TRUE) {
[16:04:35.048]         base::sink(type = "output", split = FALSE)
[16:04:35.048]         if (TRUE) {
[16:04:35.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:35.048]         }
[16:04:35.048]         else {
[16:04:35.048]             ...future.result["stdout"] <- base::list(NULL)
[16:04:35.048]         }
[16:04:35.048]         base::close(...future.stdout)
[16:04:35.048]         ...future.stdout <- NULL
[16:04:35.048]     }
[16:04:35.048]     ...future.result$conditions <- ...future.conditions
[16:04:35.048]     ...future.result$finished <- base::Sys.time()
[16:04:35.048]     ...future.result
[16:04:35.048] }
[16:04:35.051] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:04:35.051] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:04:35.051] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:04:35.051] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:04:35.052] MultisessionFuture started
[16:04:35.052] - Launch lazy future ... done
[16:04:35.052] run() for ‘MultisessionFuture’ ... done
[16:04:35.053] result() for ClusterFuture ...
[16:04:35.053] receiveMessageFromWorker() for ClusterFuture ...
[16:04:35.053] - Validating connection of MultisessionFuture
[16:04:35.100] - received message: FutureResult
[16:04:35.100] - Received FutureResult
[16:04:35.100] - Erased future from FutureRegistry
[16:04:35.100] result() for ClusterFuture ...
[16:04:35.100] - result already collected: FutureResult
[16:04:35.100] result() for ClusterFuture ... done
[16:04:35.101] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.101] result() for ClusterFuture ... done
[16:04:35.101] result() for ClusterFuture ...
[16:04:35.101] - result already collected: FutureResult
[16:04:35.101] result() for ClusterFuture ... done
[16:04:35.101] getGlobalsAndPackages() ...
[16:04:35.101] Searching for globals...
[16:04:35.102] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:35.103] Searching for globals ... DONE
[16:04:35.103] Resolving globals: FALSE
[16:04:35.103] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:35.104] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:35.104] - globals: [1] ‘a’
[16:04:35.104] 
[16:04:35.104] getGlobalsAndPackages() ... DONE
[16:04:35.104] run() for ‘Future’ ...
[16:04:35.104] - state: ‘created’
[16:04:35.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:35.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:35.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:35.120]   - Field: ‘node’
[16:04:35.120]   - Field: ‘label’
[16:04:35.120]   - Field: ‘local’
[16:04:35.120]   - Field: ‘owner’
[16:04:35.120]   - Field: ‘envir’
[16:04:35.121]   - Field: ‘workers’
[16:04:35.121]   - Field: ‘packages’
[16:04:35.121]   - Field: ‘gc’
[16:04:35.121]   - Field: ‘conditions’
[16:04:35.121]   - Field: ‘persistent’
[16:04:35.121]   - Field: ‘expr’
[16:04:35.121]   - Field: ‘uuid’
[16:04:35.121]   - Field: ‘seed’
[16:04:35.121]   - Field: ‘version’
[16:04:35.121]   - Field: ‘result’
[16:04:35.121]   - Field: ‘asynchronous’
[16:04:35.121]   - Field: ‘calls’
[16:04:35.122]   - Field: ‘globals’
[16:04:35.122]   - Field: ‘stdout’
[16:04:35.122]   - Field: ‘earlySignal’
[16:04:35.122]   - Field: ‘lazy’
[16:04:35.122]   - Field: ‘state’
[16:04:35.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:35.122] - Launch lazy future ...
[16:04:35.122] Packages needed by the future expression (n = 0): <none>
[16:04:35.122] Packages needed by future strategies (n = 0): <none>
[16:04:35.123] {
[16:04:35.123]     {
[16:04:35.123]         {
[16:04:35.123]             ...future.startTime <- base::Sys.time()
[16:04:35.123]             {
[16:04:35.123]                 {
[16:04:35.123]                   {
[16:04:35.123]                     {
[16:04:35.123]                       base::local({
[16:04:35.123]                         has_future <- base::requireNamespace("future", 
[16:04:35.123]                           quietly = TRUE)
[16:04:35.123]                         if (has_future) {
[16:04:35.123]                           ns <- base::getNamespace("future")
[16:04:35.123]                           version <- ns[[".package"]][["version"]]
[16:04:35.123]                           if (is.null(version)) 
[16:04:35.123]                             version <- utils::packageVersion("future")
[16:04:35.123]                         }
[16:04:35.123]                         else {
[16:04:35.123]                           version <- NULL
[16:04:35.123]                         }
[16:04:35.123]                         if (!has_future || version < "1.8.0") {
[16:04:35.123]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:35.123]                             "", base::R.version$version.string), 
[16:04:35.123]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:35.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:35.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:35.123]                               "release", "version")], collapse = " "), 
[16:04:35.123]                             hostname = base::Sys.info()[["nodename"]])
[16:04:35.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:35.123]                             info)
[16:04:35.123]                           info <- base::paste(info, collapse = "; ")
[16:04:35.123]                           if (!has_future) {
[16:04:35.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:35.123]                               info)
[16:04:35.123]                           }
[16:04:35.123]                           else {
[16:04:35.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:35.123]                               info, version)
[16:04:35.123]                           }
[16:04:35.123]                           base::stop(msg)
[16:04:35.123]                         }
[16:04:35.123]                       })
[16:04:35.123]                     }
[16:04:35.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:35.123]                     base::options(mc.cores = 1L)
[16:04:35.123]                   }
[16:04:35.123]                   options(future.plan = NULL)
[16:04:35.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:35.123]                 }
[16:04:35.123]                 ...future.workdir <- getwd()
[16:04:35.123]             }
[16:04:35.123]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:35.123]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:35.123]         }
[16:04:35.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:35.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:35.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:35.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:35.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:35.123]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:35.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:35.123]             base::names(...future.oldOptions))
[16:04:35.123]     }
[16:04:35.123]     if (FALSE) {
[16:04:35.123]     }
[16:04:35.123]     else {
[16:04:35.123]         if (TRUE) {
[16:04:35.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:35.123]                 open = "w")
[16:04:35.123]         }
[16:04:35.123]         else {
[16:04:35.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:35.123]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:35.123]         }
[16:04:35.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:35.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:35.123]             base::sink(type = "output", split = FALSE)
[16:04:35.123]             base::close(...future.stdout)
[16:04:35.123]         }, add = TRUE)
[16:04:35.123]     }
[16:04:35.123]     ...future.frame <- base::sys.nframe()
[16:04:35.123]     ...future.conditions <- base::list()
[16:04:35.123]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:35.123]     if (FALSE) {
[16:04:35.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:35.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:35.123]     }
[16:04:35.123]     ...future.result <- base::tryCatch({
[16:04:35.123]         base::withCallingHandlers({
[16:04:35.123]             ...future.value <- base::withVisible(base::local({
[16:04:35.123]                 ...future.makeSendCondition <- base::local({
[16:04:35.123]                   sendCondition <- NULL
[16:04:35.123]                   function(frame = 1L) {
[16:04:35.123]                     if (is.function(sendCondition)) 
[16:04:35.123]                       return(sendCondition)
[16:04:35.123]                     ns <- getNamespace("parallel")
[16:04:35.123]                     if (exists("sendData", mode = "function", 
[16:04:35.123]                       envir = ns)) {
[16:04:35.123]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:35.123]                         envir = ns)
[16:04:35.123]                       envir <- sys.frame(frame)
[16:04:35.123]                       master <- NULL
[16:04:35.123]                       while (!identical(envir, .GlobalEnv) && 
[16:04:35.123]                         !identical(envir, emptyenv())) {
[16:04:35.123]                         if (exists("master", mode = "list", envir = envir, 
[16:04:35.123]                           inherits = FALSE)) {
[16:04:35.123]                           master <- get("master", mode = "list", 
[16:04:35.123]                             envir = envir, inherits = FALSE)
[16:04:35.123]                           if (inherits(master, c("SOCKnode", 
[16:04:35.123]                             "SOCK0node"))) {
[16:04:35.123]                             sendCondition <<- function(cond) {
[16:04:35.123]                               data <- list(type = "VALUE", value = cond, 
[16:04:35.123]                                 success = TRUE)
[16:04:35.123]                               parallel_sendData(master, data)
[16:04:35.123]                             }
[16:04:35.123]                             return(sendCondition)
[16:04:35.123]                           }
[16:04:35.123]                         }
[16:04:35.123]                         frame <- frame + 1L
[16:04:35.123]                         envir <- sys.frame(frame)
[16:04:35.123]                       }
[16:04:35.123]                     }
[16:04:35.123]                     sendCondition <<- function(cond) NULL
[16:04:35.123]                   }
[16:04:35.123]                 })
[16:04:35.123]                 withCallingHandlers({
[16:04:35.123]                   {
[16:04:35.123]                     2 * a
[16:04:35.123]                   }
[16:04:35.123]                 }, immediateCondition = function(cond) {
[16:04:35.123]                   sendCondition <- ...future.makeSendCondition()
[16:04:35.123]                   sendCondition(cond)
[16:04:35.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.123]                   {
[16:04:35.123]                     inherits <- base::inherits
[16:04:35.123]                     invokeRestart <- base::invokeRestart
[16:04:35.123]                     is.null <- base::is.null
[16:04:35.123]                     muffled <- FALSE
[16:04:35.123]                     if (inherits(cond, "message")) {
[16:04:35.123]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:35.123]                       if (muffled) 
[16:04:35.123]                         invokeRestart("muffleMessage")
[16:04:35.123]                     }
[16:04:35.123]                     else if (inherits(cond, "warning")) {
[16:04:35.123]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:35.123]                       if (muffled) 
[16:04:35.123]                         invokeRestart("muffleWarning")
[16:04:35.123]                     }
[16:04:35.123]                     else if (inherits(cond, "condition")) {
[16:04:35.123]                       if (!is.null(pattern)) {
[16:04:35.123]                         computeRestarts <- base::computeRestarts
[16:04:35.123]                         grepl <- base::grepl
[16:04:35.123]                         restarts <- computeRestarts(cond)
[16:04:35.123]                         for (restart in restarts) {
[16:04:35.123]                           name <- restart$name
[16:04:35.123]                           if (is.null(name)) 
[16:04:35.123]                             next
[16:04:35.123]                           if (!grepl(pattern, name)) 
[16:04:35.123]                             next
[16:04:35.123]                           invokeRestart(restart)
[16:04:35.123]                           muffled <- TRUE
[16:04:35.123]                           break
[16:04:35.123]                         }
[16:04:35.123]                       }
[16:04:35.123]                     }
[16:04:35.123]                     invisible(muffled)
[16:04:35.123]                   }
[16:04:35.123]                   muffleCondition(cond)
[16:04:35.123]                 })
[16:04:35.123]             }))
[16:04:35.123]             future::FutureResult(value = ...future.value$value, 
[16:04:35.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.123]                   ...future.rng), globalenv = if (FALSE) 
[16:04:35.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:35.123]                     ...future.globalenv.names))
[16:04:35.123]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:35.123]         }, condition = base::local({
[16:04:35.123]             c <- base::c
[16:04:35.123]             inherits <- base::inherits
[16:04:35.123]             invokeRestart <- base::invokeRestart
[16:04:35.123]             length <- base::length
[16:04:35.123]             list <- base::list
[16:04:35.123]             seq.int <- base::seq.int
[16:04:35.123]             signalCondition <- base::signalCondition
[16:04:35.123]             sys.calls <- base::sys.calls
[16:04:35.123]             `[[` <- base::`[[`
[16:04:35.123]             `+` <- base::`+`
[16:04:35.123]             `<<-` <- base::`<<-`
[16:04:35.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:35.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:35.123]                   3L)]
[16:04:35.123]             }
[16:04:35.123]             function(cond) {
[16:04:35.123]                 is_error <- inherits(cond, "error")
[16:04:35.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:35.123]                   NULL)
[16:04:35.123]                 if (is_error) {
[16:04:35.123]                   sessionInformation <- function() {
[16:04:35.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:35.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:35.123]                       search = base::search(), system = base::Sys.info())
[16:04:35.123]                   }
[16:04:35.123]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:35.123]                     cond$call), session = sessionInformation(), 
[16:04:35.123]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:35.123]                   signalCondition(cond)
[16:04:35.123]                 }
[16:04:35.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:35.123]                 "immediateCondition"))) {
[16:04:35.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:35.123]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:35.123]                   if (TRUE && !signal) {
[16:04:35.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.123]                     {
[16:04:35.123]                       inherits <- base::inherits
[16:04:35.123]                       invokeRestart <- base::invokeRestart
[16:04:35.123]                       is.null <- base::is.null
[16:04:35.123]                       muffled <- FALSE
[16:04:35.123]                       if (inherits(cond, "message")) {
[16:04:35.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.123]                         if (muffled) 
[16:04:35.123]                           invokeRestart("muffleMessage")
[16:04:35.123]                       }
[16:04:35.123]                       else if (inherits(cond, "warning")) {
[16:04:35.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.123]                         if (muffled) 
[16:04:35.123]                           invokeRestart("muffleWarning")
[16:04:35.123]                       }
[16:04:35.123]                       else if (inherits(cond, "condition")) {
[16:04:35.123]                         if (!is.null(pattern)) {
[16:04:35.123]                           computeRestarts <- base::computeRestarts
[16:04:35.123]                           grepl <- base::grepl
[16:04:35.123]                           restarts <- computeRestarts(cond)
[16:04:35.123]                           for (restart in restarts) {
[16:04:35.123]                             name <- restart$name
[16:04:35.123]                             if (is.null(name)) 
[16:04:35.123]                               next
[16:04:35.123]                             if (!grepl(pattern, name)) 
[16:04:35.123]                               next
[16:04:35.123]                             invokeRestart(restart)
[16:04:35.123]                             muffled <- TRUE
[16:04:35.123]                             break
[16:04:35.123]                           }
[16:04:35.123]                         }
[16:04:35.123]                       }
[16:04:35.123]                       invisible(muffled)
[16:04:35.123]                     }
[16:04:35.123]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.123]                   }
[16:04:35.123]                 }
[16:04:35.123]                 else {
[16:04:35.123]                   if (TRUE) {
[16:04:35.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.123]                     {
[16:04:35.123]                       inherits <- base::inherits
[16:04:35.123]                       invokeRestart <- base::invokeRestart
[16:04:35.123]                       is.null <- base::is.null
[16:04:35.123]                       muffled <- FALSE
[16:04:35.123]                       if (inherits(cond, "message")) {
[16:04:35.123]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.123]                         if (muffled) 
[16:04:35.123]                           invokeRestart("muffleMessage")
[16:04:35.123]                       }
[16:04:35.123]                       else if (inherits(cond, "warning")) {
[16:04:35.123]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.123]                         if (muffled) 
[16:04:35.123]                           invokeRestart("muffleWarning")
[16:04:35.123]                       }
[16:04:35.123]                       else if (inherits(cond, "condition")) {
[16:04:35.123]                         if (!is.null(pattern)) {
[16:04:35.123]                           computeRestarts <- base::computeRestarts
[16:04:35.123]                           grepl <- base::grepl
[16:04:35.123]                           restarts <- computeRestarts(cond)
[16:04:35.123]                           for (restart in restarts) {
[16:04:35.123]                             name <- restart$name
[16:04:35.123]                             if (is.null(name)) 
[16:04:35.123]                               next
[16:04:35.123]                             if (!grepl(pattern, name)) 
[16:04:35.123]                               next
[16:04:35.123]                             invokeRestart(restart)
[16:04:35.123]                             muffled <- TRUE
[16:04:35.123]                             break
[16:04:35.123]                           }
[16:04:35.123]                         }
[16:04:35.123]                       }
[16:04:35.123]                       invisible(muffled)
[16:04:35.123]                     }
[16:04:35.123]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.123]                   }
[16:04:35.123]                 }
[16:04:35.123]             }
[16:04:35.123]         }))
[16:04:35.123]     }, error = function(ex) {
[16:04:35.123]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:35.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.123]                 ...future.rng), started = ...future.startTime, 
[16:04:35.123]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:35.123]             version = "1.8"), class = "FutureResult")
[16:04:35.123]     }, finally = {
[16:04:35.123]         if (!identical(...future.workdir, getwd())) 
[16:04:35.123]             setwd(...future.workdir)
[16:04:35.123]         {
[16:04:35.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:35.123]                 ...future.oldOptions$nwarnings <- NULL
[16:04:35.123]             }
[16:04:35.123]             base::options(...future.oldOptions)
[16:04:35.123]             if (.Platform$OS.type == "windows") {
[16:04:35.123]                 old_names <- names(...future.oldEnvVars)
[16:04:35.123]                 envs <- base::Sys.getenv()
[16:04:35.123]                 names <- names(envs)
[16:04:35.123]                 common <- intersect(names, old_names)
[16:04:35.123]                 added <- setdiff(names, old_names)
[16:04:35.123]                 removed <- setdiff(old_names, names)
[16:04:35.123]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:35.123]                   envs[common]]
[16:04:35.123]                 NAMES <- toupper(changed)
[16:04:35.123]                 args <- list()
[16:04:35.123]                 for (kk in seq_along(NAMES)) {
[16:04:35.123]                   name <- changed[[kk]]
[16:04:35.123]                   NAME <- NAMES[[kk]]
[16:04:35.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.123]                     next
[16:04:35.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.123]                 }
[16:04:35.123]                 NAMES <- toupper(added)
[16:04:35.123]                 for (kk in seq_along(NAMES)) {
[16:04:35.123]                   name <- added[[kk]]
[16:04:35.123]                   NAME <- NAMES[[kk]]
[16:04:35.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.123]                     next
[16:04:35.123]                   args[[name]] <- ""
[16:04:35.123]                 }
[16:04:35.123]                 NAMES <- toupper(removed)
[16:04:35.123]                 for (kk in seq_along(NAMES)) {
[16:04:35.123]                   name <- removed[[kk]]
[16:04:35.123]                   NAME <- NAMES[[kk]]
[16:04:35.123]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.123]                     next
[16:04:35.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.123]                 }
[16:04:35.123]                 if (length(args) > 0) 
[16:04:35.123]                   base::do.call(base::Sys.setenv, args = args)
[16:04:35.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:35.123]             }
[16:04:35.123]             else {
[16:04:35.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:35.123]             }
[16:04:35.123]             {
[16:04:35.123]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:35.123]                   0L) {
[16:04:35.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:35.123]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:35.123]                   base::options(opts)
[16:04:35.123]                 }
[16:04:35.123]                 {
[16:04:35.123]                   {
[16:04:35.123]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:35.123]                     NULL
[16:04:35.123]                   }
[16:04:35.123]                   options(future.plan = NULL)
[16:04:35.123]                   if (is.na(NA_character_)) 
[16:04:35.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:35.123]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:35.123]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:35.123]                     envir = parent.frame()) 
[16:04:35.123]                   {
[16:04:35.123]                     if (is.function(workers)) 
[16:04:35.123]                       workers <- workers()
[16:04:35.123]                     workers <- structure(as.integer(workers), 
[16:04:35.123]                       class = class(workers))
[16:04:35.123]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:35.123]                       workers >= 1)
[16:04:35.123]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:35.123]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:35.123]                     }
[16:04:35.123]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:35.123]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:35.123]                       envir = envir)
[16:04:35.123]                     if (!future$lazy) 
[16:04:35.123]                       future <- run(future)
[16:04:35.123]                     invisible(future)
[16:04:35.123]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:35.123]                 }
[16:04:35.123]             }
[16:04:35.123]         }
[16:04:35.123]     })
[16:04:35.123]     if (TRUE) {
[16:04:35.123]         base::sink(type = "output", split = FALSE)
[16:04:35.123]         if (TRUE) {
[16:04:35.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:35.123]         }
[16:04:35.123]         else {
[16:04:35.123]             ...future.result["stdout"] <- base::list(NULL)
[16:04:35.123]         }
[16:04:35.123]         base::close(...future.stdout)
[16:04:35.123]         ...future.stdout <- NULL
[16:04:35.123]     }
[16:04:35.123]     ...future.result$conditions <- ...future.conditions
[16:04:35.123]     ...future.result$finished <- base::Sys.time()
[16:04:35.123]     ...future.result
[16:04:35.123] }
[16:04:35.125] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:04:35.126] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:04:35.126] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:04:35.126] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:04:35.127] MultisessionFuture started
[16:04:35.127] - Launch lazy future ... done
[16:04:35.127] run() for ‘MultisessionFuture’ ... done
[16:04:35.127] result() for ClusterFuture ...
[16:04:35.127] receiveMessageFromWorker() for ClusterFuture ...
[16:04:35.127] - Validating connection of MultisessionFuture
[16:04:35.171] - received message: FutureResult
[16:04:35.172] - Received FutureResult
[16:04:35.172] - Erased future from FutureRegistry
[16:04:35.172] result() for ClusterFuture ...
[16:04:35.172] - result already collected: FutureResult
[16:04:35.172] result() for ClusterFuture ... done
[16:04:35.172] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.172] result() for ClusterFuture ... done
[16:04:35.172] result() for ClusterFuture ...
[16:04:35.172] - result already collected: FutureResult
[16:04:35.172] result() for ClusterFuture ... done
[16:04:35.173] getGlobalsAndPackages() ...
[16:04:35.173] Searching for globals...
[16:04:35.173] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:35.174] Searching for globals ... DONE
[16:04:35.174] Resolving globals: FALSE
[16:04:35.174] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:35.174] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:35.174] - globals: [1] ‘a’
[16:04:35.175] 
[16:04:35.175] getGlobalsAndPackages() ... DONE
[16:04:35.175] run() for ‘Future’ ...
[16:04:35.175] - state: ‘created’
[16:04:35.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:35.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:35.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:35.189]   - Field: ‘node’
[16:04:35.189]   - Field: ‘label’
[16:04:35.189]   - Field: ‘local’
[16:04:35.189]   - Field: ‘owner’
[16:04:35.189]   - Field: ‘envir’
[16:04:35.189]   - Field: ‘workers’
[16:04:35.189]   - Field: ‘packages’
[16:04:35.189]   - Field: ‘gc’
[16:04:35.190]   - Field: ‘conditions’
[16:04:35.190]   - Field: ‘persistent’
[16:04:35.190]   - Field: ‘expr’
[16:04:35.190]   - Field: ‘uuid’
[16:04:35.190]   - Field: ‘seed’
[16:04:35.190]   - Field: ‘version’
[16:04:35.190]   - Field: ‘result’
[16:04:35.190]   - Field: ‘asynchronous’
[16:04:35.190]   - Field: ‘calls’
[16:04:35.190]   - Field: ‘globals’
[16:04:35.190]   - Field: ‘stdout’
[16:04:35.191]   - Field: ‘earlySignal’
[16:04:35.191]   - Field: ‘lazy’
[16:04:35.191]   - Field: ‘state’
[16:04:35.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:35.191] - Launch lazy future ...
[16:04:35.191] Packages needed by the future expression (n = 0): <none>
[16:04:35.191] Packages needed by future strategies (n = 0): <none>
[16:04:35.192] {
[16:04:35.192]     {
[16:04:35.192]         {
[16:04:35.192]             ...future.startTime <- base::Sys.time()
[16:04:35.192]             {
[16:04:35.192]                 {
[16:04:35.192]                   {
[16:04:35.192]                     {
[16:04:35.192]                       base::local({
[16:04:35.192]                         has_future <- base::requireNamespace("future", 
[16:04:35.192]                           quietly = TRUE)
[16:04:35.192]                         if (has_future) {
[16:04:35.192]                           ns <- base::getNamespace("future")
[16:04:35.192]                           version <- ns[[".package"]][["version"]]
[16:04:35.192]                           if (is.null(version)) 
[16:04:35.192]                             version <- utils::packageVersion("future")
[16:04:35.192]                         }
[16:04:35.192]                         else {
[16:04:35.192]                           version <- NULL
[16:04:35.192]                         }
[16:04:35.192]                         if (!has_future || version < "1.8.0") {
[16:04:35.192]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:35.192]                             "", base::R.version$version.string), 
[16:04:35.192]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:35.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:35.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:35.192]                               "release", "version")], collapse = " "), 
[16:04:35.192]                             hostname = base::Sys.info()[["nodename"]])
[16:04:35.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:35.192]                             info)
[16:04:35.192]                           info <- base::paste(info, collapse = "; ")
[16:04:35.192]                           if (!has_future) {
[16:04:35.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:35.192]                               info)
[16:04:35.192]                           }
[16:04:35.192]                           else {
[16:04:35.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:35.192]                               info, version)
[16:04:35.192]                           }
[16:04:35.192]                           base::stop(msg)
[16:04:35.192]                         }
[16:04:35.192]                       })
[16:04:35.192]                     }
[16:04:35.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:35.192]                     base::options(mc.cores = 1L)
[16:04:35.192]                   }
[16:04:35.192]                   options(future.plan = NULL)
[16:04:35.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:35.192]                 }
[16:04:35.192]                 ...future.workdir <- getwd()
[16:04:35.192]             }
[16:04:35.192]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:35.192]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:35.192]         }
[16:04:35.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:35.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:35.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:35.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:35.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:35.192]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:35.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:35.192]             base::names(...future.oldOptions))
[16:04:35.192]     }
[16:04:35.192]     if (FALSE) {
[16:04:35.192]     }
[16:04:35.192]     else {
[16:04:35.192]         if (TRUE) {
[16:04:35.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:35.192]                 open = "w")
[16:04:35.192]         }
[16:04:35.192]         else {
[16:04:35.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:35.192]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:35.192]         }
[16:04:35.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:35.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:35.192]             base::sink(type = "output", split = FALSE)
[16:04:35.192]             base::close(...future.stdout)
[16:04:35.192]         }, add = TRUE)
[16:04:35.192]     }
[16:04:35.192]     ...future.frame <- base::sys.nframe()
[16:04:35.192]     ...future.conditions <- base::list()
[16:04:35.192]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:35.192]     if (FALSE) {
[16:04:35.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:35.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:35.192]     }
[16:04:35.192]     ...future.result <- base::tryCatch({
[16:04:35.192]         base::withCallingHandlers({
[16:04:35.192]             ...future.value <- base::withVisible(base::local({
[16:04:35.192]                 ...future.makeSendCondition <- base::local({
[16:04:35.192]                   sendCondition <- NULL
[16:04:35.192]                   function(frame = 1L) {
[16:04:35.192]                     if (is.function(sendCondition)) 
[16:04:35.192]                       return(sendCondition)
[16:04:35.192]                     ns <- getNamespace("parallel")
[16:04:35.192]                     if (exists("sendData", mode = "function", 
[16:04:35.192]                       envir = ns)) {
[16:04:35.192]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:35.192]                         envir = ns)
[16:04:35.192]                       envir <- sys.frame(frame)
[16:04:35.192]                       master <- NULL
[16:04:35.192]                       while (!identical(envir, .GlobalEnv) && 
[16:04:35.192]                         !identical(envir, emptyenv())) {
[16:04:35.192]                         if (exists("master", mode = "list", envir = envir, 
[16:04:35.192]                           inherits = FALSE)) {
[16:04:35.192]                           master <- get("master", mode = "list", 
[16:04:35.192]                             envir = envir, inherits = FALSE)
[16:04:35.192]                           if (inherits(master, c("SOCKnode", 
[16:04:35.192]                             "SOCK0node"))) {
[16:04:35.192]                             sendCondition <<- function(cond) {
[16:04:35.192]                               data <- list(type = "VALUE", value = cond, 
[16:04:35.192]                                 success = TRUE)
[16:04:35.192]                               parallel_sendData(master, data)
[16:04:35.192]                             }
[16:04:35.192]                             return(sendCondition)
[16:04:35.192]                           }
[16:04:35.192]                         }
[16:04:35.192]                         frame <- frame + 1L
[16:04:35.192]                         envir <- sys.frame(frame)
[16:04:35.192]                       }
[16:04:35.192]                     }
[16:04:35.192]                     sendCondition <<- function(cond) NULL
[16:04:35.192]                   }
[16:04:35.192]                 })
[16:04:35.192]                 withCallingHandlers({
[16:04:35.192]                   {
[16:04:35.192]                     2 * a
[16:04:35.192]                   }
[16:04:35.192]                 }, immediateCondition = function(cond) {
[16:04:35.192]                   sendCondition <- ...future.makeSendCondition()
[16:04:35.192]                   sendCondition(cond)
[16:04:35.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.192]                   {
[16:04:35.192]                     inherits <- base::inherits
[16:04:35.192]                     invokeRestart <- base::invokeRestart
[16:04:35.192]                     is.null <- base::is.null
[16:04:35.192]                     muffled <- FALSE
[16:04:35.192]                     if (inherits(cond, "message")) {
[16:04:35.192]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:35.192]                       if (muffled) 
[16:04:35.192]                         invokeRestart("muffleMessage")
[16:04:35.192]                     }
[16:04:35.192]                     else if (inherits(cond, "warning")) {
[16:04:35.192]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:35.192]                       if (muffled) 
[16:04:35.192]                         invokeRestart("muffleWarning")
[16:04:35.192]                     }
[16:04:35.192]                     else if (inherits(cond, "condition")) {
[16:04:35.192]                       if (!is.null(pattern)) {
[16:04:35.192]                         computeRestarts <- base::computeRestarts
[16:04:35.192]                         grepl <- base::grepl
[16:04:35.192]                         restarts <- computeRestarts(cond)
[16:04:35.192]                         for (restart in restarts) {
[16:04:35.192]                           name <- restart$name
[16:04:35.192]                           if (is.null(name)) 
[16:04:35.192]                             next
[16:04:35.192]                           if (!grepl(pattern, name)) 
[16:04:35.192]                             next
[16:04:35.192]                           invokeRestart(restart)
[16:04:35.192]                           muffled <- TRUE
[16:04:35.192]                           break
[16:04:35.192]                         }
[16:04:35.192]                       }
[16:04:35.192]                     }
[16:04:35.192]                     invisible(muffled)
[16:04:35.192]                   }
[16:04:35.192]                   muffleCondition(cond)
[16:04:35.192]                 })
[16:04:35.192]             }))
[16:04:35.192]             future::FutureResult(value = ...future.value$value, 
[16:04:35.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.192]                   ...future.rng), globalenv = if (FALSE) 
[16:04:35.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:35.192]                     ...future.globalenv.names))
[16:04:35.192]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:35.192]         }, condition = base::local({
[16:04:35.192]             c <- base::c
[16:04:35.192]             inherits <- base::inherits
[16:04:35.192]             invokeRestart <- base::invokeRestart
[16:04:35.192]             length <- base::length
[16:04:35.192]             list <- base::list
[16:04:35.192]             seq.int <- base::seq.int
[16:04:35.192]             signalCondition <- base::signalCondition
[16:04:35.192]             sys.calls <- base::sys.calls
[16:04:35.192]             `[[` <- base::`[[`
[16:04:35.192]             `+` <- base::`+`
[16:04:35.192]             `<<-` <- base::`<<-`
[16:04:35.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:35.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:35.192]                   3L)]
[16:04:35.192]             }
[16:04:35.192]             function(cond) {
[16:04:35.192]                 is_error <- inherits(cond, "error")
[16:04:35.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:35.192]                   NULL)
[16:04:35.192]                 if (is_error) {
[16:04:35.192]                   sessionInformation <- function() {
[16:04:35.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:35.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:35.192]                       search = base::search(), system = base::Sys.info())
[16:04:35.192]                   }
[16:04:35.192]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:35.192]                     cond$call), session = sessionInformation(), 
[16:04:35.192]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:35.192]                   signalCondition(cond)
[16:04:35.192]                 }
[16:04:35.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:35.192]                 "immediateCondition"))) {
[16:04:35.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:35.192]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:35.192]                   if (TRUE && !signal) {
[16:04:35.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.192]                     {
[16:04:35.192]                       inherits <- base::inherits
[16:04:35.192]                       invokeRestart <- base::invokeRestart
[16:04:35.192]                       is.null <- base::is.null
[16:04:35.192]                       muffled <- FALSE
[16:04:35.192]                       if (inherits(cond, "message")) {
[16:04:35.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.192]                         if (muffled) 
[16:04:35.192]                           invokeRestart("muffleMessage")
[16:04:35.192]                       }
[16:04:35.192]                       else if (inherits(cond, "warning")) {
[16:04:35.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.192]                         if (muffled) 
[16:04:35.192]                           invokeRestart("muffleWarning")
[16:04:35.192]                       }
[16:04:35.192]                       else if (inherits(cond, "condition")) {
[16:04:35.192]                         if (!is.null(pattern)) {
[16:04:35.192]                           computeRestarts <- base::computeRestarts
[16:04:35.192]                           grepl <- base::grepl
[16:04:35.192]                           restarts <- computeRestarts(cond)
[16:04:35.192]                           for (restart in restarts) {
[16:04:35.192]                             name <- restart$name
[16:04:35.192]                             if (is.null(name)) 
[16:04:35.192]                               next
[16:04:35.192]                             if (!grepl(pattern, name)) 
[16:04:35.192]                               next
[16:04:35.192]                             invokeRestart(restart)
[16:04:35.192]                             muffled <- TRUE
[16:04:35.192]                             break
[16:04:35.192]                           }
[16:04:35.192]                         }
[16:04:35.192]                       }
[16:04:35.192]                       invisible(muffled)
[16:04:35.192]                     }
[16:04:35.192]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.192]                   }
[16:04:35.192]                 }
[16:04:35.192]                 else {
[16:04:35.192]                   if (TRUE) {
[16:04:35.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.192]                     {
[16:04:35.192]                       inherits <- base::inherits
[16:04:35.192]                       invokeRestart <- base::invokeRestart
[16:04:35.192]                       is.null <- base::is.null
[16:04:35.192]                       muffled <- FALSE
[16:04:35.192]                       if (inherits(cond, "message")) {
[16:04:35.192]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.192]                         if (muffled) 
[16:04:35.192]                           invokeRestart("muffleMessage")
[16:04:35.192]                       }
[16:04:35.192]                       else if (inherits(cond, "warning")) {
[16:04:35.192]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.192]                         if (muffled) 
[16:04:35.192]                           invokeRestart("muffleWarning")
[16:04:35.192]                       }
[16:04:35.192]                       else if (inherits(cond, "condition")) {
[16:04:35.192]                         if (!is.null(pattern)) {
[16:04:35.192]                           computeRestarts <- base::computeRestarts
[16:04:35.192]                           grepl <- base::grepl
[16:04:35.192]                           restarts <- computeRestarts(cond)
[16:04:35.192]                           for (restart in restarts) {
[16:04:35.192]                             name <- restart$name
[16:04:35.192]                             if (is.null(name)) 
[16:04:35.192]                               next
[16:04:35.192]                             if (!grepl(pattern, name)) 
[16:04:35.192]                               next
[16:04:35.192]                             invokeRestart(restart)
[16:04:35.192]                             muffled <- TRUE
[16:04:35.192]                             break
[16:04:35.192]                           }
[16:04:35.192]                         }
[16:04:35.192]                       }
[16:04:35.192]                       invisible(muffled)
[16:04:35.192]                     }
[16:04:35.192]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.192]                   }
[16:04:35.192]                 }
[16:04:35.192]             }
[16:04:35.192]         }))
[16:04:35.192]     }, error = function(ex) {
[16:04:35.192]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:35.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.192]                 ...future.rng), started = ...future.startTime, 
[16:04:35.192]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:35.192]             version = "1.8"), class = "FutureResult")
[16:04:35.192]     }, finally = {
[16:04:35.192]         if (!identical(...future.workdir, getwd())) 
[16:04:35.192]             setwd(...future.workdir)
[16:04:35.192]         {
[16:04:35.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:35.192]                 ...future.oldOptions$nwarnings <- NULL
[16:04:35.192]             }
[16:04:35.192]             base::options(...future.oldOptions)
[16:04:35.192]             if (.Platform$OS.type == "windows") {
[16:04:35.192]                 old_names <- names(...future.oldEnvVars)
[16:04:35.192]                 envs <- base::Sys.getenv()
[16:04:35.192]                 names <- names(envs)
[16:04:35.192]                 common <- intersect(names, old_names)
[16:04:35.192]                 added <- setdiff(names, old_names)
[16:04:35.192]                 removed <- setdiff(old_names, names)
[16:04:35.192]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:35.192]                   envs[common]]
[16:04:35.192]                 NAMES <- toupper(changed)
[16:04:35.192]                 args <- list()
[16:04:35.192]                 for (kk in seq_along(NAMES)) {
[16:04:35.192]                   name <- changed[[kk]]
[16:04:35.192]                   NAME <- NAMES[[kk]]
[16:04:35.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.192]                     next
[16:04:35.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.192]                 }
[16:04:35.192]                 NAMES <- toupper(added)
[16:04:35.192]                 for (kk in seq_along(NAMES)) {
[16:04:35.192]                   name <- added[[kk]]
[16:04:35.192]                   NAME <- NAMES[[kk]]
[16:04:35.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.192]                     next
[16:04:35.192]                   args[[name]] <- ""
[16:04:35.192]                 }
[16:04:35.192]                 NAMES <- toupper(removed)
[16:04:35.192]                 for (kk in seq_along(NAMES)) {
[16:04:35.192]                   name <- removed[[kk]]
[16:04:35.192]                   NAME <- NAMES[[kk]]
[16:04:35.192]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.192]                     next
[16:04:35.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.192]                 }
[16:04:35.192]                 if (length(args) > 0) 
[16:04:35.192]                   base::do.call(base::Sys.setenv, args = args)
[16:04:35.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:35.192]             }
[16:04:35.192]             else {
[16:04:35.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:35.192]             }
[16:04:35.192]             {
[16:04:35.192]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:35.192]                   0L) {
[16:04:35.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:35.192]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:35.192]                   base::options(opts)
[16:04:35.192]                 }
[16:04:35.192]                 {
[16:04:35.192]                   {
[16:04:35.192]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:35.192]                     NULL
[16:04:35.192]                   }
[16:04:35.192]                   options(future.plan = NULL)
[16:04:35.192]                   if (is.na(NA_character_)) 
[16:04:35.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:35.192]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:35.192]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:35.192]                     envir = parent.frame()) 
[16:04:35.192]                   {
[16:04:35.192]                     if (is.function(workers)) 
[16:04:35.192]                       workers <- workers()
[16:04:35.192]                     workers <- structure(as.integer(workers), 
[16:04:35.192]                       class = class(workers))
[16:04:35.192]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:35.192]                       workers >= 1)
[16:04:35.192]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:35.192]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:35.192]                     }
[16:04:35.192]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:35.192]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:35.192]                       envir = envir)
[16:04:35.192]                     if (!future$lazy) 
[16:04:35.192]                       future <- run(future)
[16:04:35.192]                     invisible(future)
[16:04:35.192]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:35.192]                 }
[16:04:35.192]             }
[16:04:35.192]         }
[16:04:35.192]     })
[16:04:35.192]     if (TRUE) {
[16:04:35.192]         base::sink(type = "output", split = FALSE)
[16:04:35.192]         if (TRUE) {
[16:04:35.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:35.192]         }
[16:04:35.192]         else {
[16:04:35.192]             ...future.result["stdout"] <- base::list(NULL)
[16:04:35.192]         }
[16:04:35.192]         base::close(...future.stdout)
[16:04:35.192]         ...future.stdout <- NULL
[16:04:35.192]     }
[16:04:35.192]     ...future.result$conditions <- ...future.conditions
[16:04:35.192]     ...future.result$finished <- base::Sys.time()
[16:04:35.192]     ...future.result
[16:04:35.192] }
[16:04:35.194] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:04:35.194] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:04:35.195] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:04:35.195] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:04:35.195] MultisessionFuture started
[16:04:35.196] - Launch lazy future ... done
[16:04:35.196] run() for ‘MultisessionFuture’ ... done
[16:04:35.196] result() for ClusterFuture ...
[16:04:35.196] receiveMessageFromWorker() for ClusterFuture ...
[16:04:35.196] - Validating connection of MultisessionFuture
[16:04:35.243] - received message: FutureResult
[16:04:35.243] - Received FutureResult
[16:04:35.243] - Erased future from FutureRegistry
[16:04:35.243] result() for ClusterFuture ...
[16:04:35.244] - result already collected: FutureResult
[16:04:35.244] result() for ClusterFuture ... done
[16:04:35.244] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.244] result() for ClusterFuture ... done
[16:04:35.244] result() for ClusterFuture ...
[16:04:35.244] - result already collected: FutureResult
[16:04:35.244] result() for ClusterFuture ... done
[16:04:35.244] getGlobalsAndPackages() ...
[16:04:35.244] Searching for globals...
[16:04:35.245] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:35.245] Searching for globals ... DONE
[16:04:35.245] Resolving globals: FALSE
[16:04:35.246] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:35.246] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:35.246] - globals: [1] ‘a’
[16:04:35.246] 
[16:04:35.246] getGlobalsAndPackages() ... DONE
[16:04:35.247] run() for ‘Future’ ...
[16:04:35.247] - state: ‘created’
[16:04:35.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:35.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:35.260] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:35.260]   - Field: ‘node’
[16:04:35.261]   - Field: ‘label’
[16:04:35.261]   - Field: ‘local’
[16:04:35.261]   - Field: ‘owner’
[16:04:35.261]   - Field: ‘envir’
[16:04:35.261]   - Field: ‘workers’
[16:04:35.261]   - Field: ‘packages’
[16:04:35.261]   - Field: ‘gc’
[16:04:35.261]   - Field: ‘conditions’
[16:04:35.261]   - Field: ‘persistent’
[16:04:35.261]   - Field: ‘expr’
[16:04:35.261]   - Field: ‘uuid’
[16:04:35.262]   - Field: ‘seed’
[16:04:35.262]   - Field: ‘version’
[16:04:35.262]   - Field: ‘result’
[16:04:35.262]   - Field: ‘asynchronous’
[16:04:35.262]   - Field: ‘calls’
[16:04:35.262]   - Field: ‘globals’
[16:04:35.262]   - Field: ‘stdout’
[16:04:35.262]   - Field: ‘earlySignal’
[16:04:35.262]   - Field: ‘lazy’
[16:04:35.262]   - Field: ‘state’
[16:04:35.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:35.263] - Launch lazy future ...
[16:04:35.263] Packages needed by the future expression (n = 0): <none>
[16:04:35.263] Packages needed by future strategies (n = 0): <none>
[16:04:35.263] {
[16:04:35.263]     {
[16:04:35.263]         {
[16:04:35.263]             ...future.startTime <- base::Sys.time()
[16:04:35.263]             {
[16:04:35.263]                 {
[16:04:35.263]                   {
[16:04:35.263]                     {
[16:04:35.263]                       base::local({
[16:04:35.263]                         has_future <- base::requireNamespace("future", 
[16:04:35.263]                           quietly = TRUE)
[16:04:35.263]                         if (has_future) {
[16:04:35.263]                           ns <- base::getNamespace("future")
[16:04:35.263]                           version <- ns[[".package"]][["version"]]
[16:04:35.263]                           if (is.null(version)) 
[16:04:35.263]                             version <- utils::packageVersion("future")
[16:04:35.263]                         }
[16:04:35.263]                         else {
[16:04:35.263]                           version <- NULL
[16:04:35.263]                         }
[16:04:35.263]                         if (!has_future || version < "1.8.0") {
[16:04:35.263]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:35.263]                             "", base::R.version$version.string), 
[16:04:35.263]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:35.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:35.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:35.263]                               "release", "version")], collapse = " "), 
[16:04:35.263]                             hostname = base::Sys.info()[["nodename"]])
[16:04:35.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:35.263]                             info)
[16:04:35.263]                           info <- base::paste(info, collapse = "; ")
[16:04:35.263]                           if (!has_future) {
[16:04:35.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:35.263]                               info)
[16:04:35.263]                           }
[16:04:35.263]                           else {
[16:04:35.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:35.263]                               info, version)
[16:04:35.263]                           }
[16:04:35.263]                           base::stop(msg)
[16:04:35.263]                         }
[16:04:35.263]                       })
[16:04:35.263]                     }
[16:04:35.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:35.263]                     base::options(mc.cores = 1L)
[16:04:35.263]                   }
[16:04:35.263]                   options(future.plan = NULL)
[16:04:35.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:35.263]                 }
[16:04:35.263]                 ...future.workdir <- getwd()
[16:04:35.263]             }
[16:04:35.263]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:35.263]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:35.263]         }
[16:04:35.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:35.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:35.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:35.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:35.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:35.263]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:35.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:35.263]             base::names(...future.oldOptions))
[16:04:35.263]     }
[16:04:35.263]     if (FALSE) {
[16:04:35.263]     }
[16:04:35.263]     else {
[16:04:35.263]         if (TRUE) {
[16:04:35.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:35.263]                 open = "w")
[16:04:35.263]         }
[16:04:35.263]         else {
[16:04:35.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:35.263]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:35.263]         }
[16:04:35.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:35.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:35.263]             base::sink(type = "output", split = FALSE)
[16:04:35.263]             base::close(...future.stdout)
[16:04:35.263]         }, add = TRUE)
[16:04:35.263]     }
[16:04:35.263]     ...future.frame <- base::sys.nframe()
[16:04:35.263]     ...future.conditions <- base::list()
[16:04:35.263]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:35.263]     if (FALSE) {
[16:04:35.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:35.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:35.263]     }
[16:04:35.263]     ...future.result <- base::tryCatch({
[16:04:35.263]         base::withCallingHandlers({
[16:04:35.263]             ...future.value <- base::withVisible(base::local({
[16:04:35.263]                 ...future.makeSendCondition <- base::local({
[16:04:35.263]                   sendCondition <- NULL
[16:04:35.263]                   function(frame = 1L) {
[16:04:35.263]                     if (is.function(sendCondition)) 
[16:04:35.263]                       return(sendCondition)
[16:04:35.263]                     ns <- getNamespace("parallel")
[16:04:35.263]                     if (exists("sendData", mode = "function", 
[16:04:35.263]                       envir = ns)) {
[16:04:35.263]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:35.263]                         envir = ns)
[16:04:35.263]                       envir <- sys.frame(frame)
[16:04:35.263]                       master <- NULL
[16:04:35.263]                       while (!identical(envir, .GlobalEnv) && 
[16:04:35.263]                         !identical(envir, emptyenv())) {
[16:04:35.263]                         if (exists("master", mode = "list", envir = envir, 
[16:04:35.263]                           inherits = FALSE)) {
[16:04:35.263]                           master <- get("master", mode = "list", 
[16:04:35.263]                             envir = envir, inherits = FALSE)
[16:04:35.263]                           if (inherits(master, c("SOCKnode", 
[16:04:35.263]                             "SOCK0node"))) {
[16:04:35.263]                             sendCondition <<- function(cond) {
[16:04:35.263]                               data <- list(type = "VALUE", value = cond, 
[16:04:35.263]                                 success = TRUE)
[16:04:35.263]                               parallel_sendData(master, data)
[16:04:35.263]                             }
[16:04:35.263]                             return(sendCondition)
[16:04:35.263]                           }
[16:04:35.263]                         }
[16:04:35.263]                         frame <- frame + 1L
[16:04:35.263]                         envir <- sys.frame(frame)
[16:04:35.263]                       }
[16:04:35.263]                     }
[16:04:35.263]                     sendCondition <<- function(cond) NULL
[16:04:35.263]                   }
[16:04:35.263]                 })
[16:04:35.263]                 withCallingHandlers({
[16:04:35.263]                   {
[16:04:35.263]                     2 * a
[16:04:35.263]                   }
[16:04:35.263]                 }, immediateCondition = function(cond) {
[16:04:35.263]                   sendCondition <- ...future.makeSendCondition()
[16:04:35.263]                   sendCondition(cond)
[16:04:35.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.263]                   {
[16:04:35.263]                     inherits <- base::inherits
[16:04:35.263]                     invokeRestart <- base::invokeRestart
[16:04:35.263]                     is.null <- base::is.null
[16:04:35.263]                     muffled <- FALSE
[16:04:35.263]                     if (inherits(cond, "message")) {
[16:04:35.263]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:35.263]                       if (muffled) 
[16:04:35.263]                         invokeRestart("muffleMessage")
[16:04:35.263]                     }
[16:04:35.263]                     else if (inherits(cond, "warning")) {
[16:04:35.263]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:35.263]                       if (muffled) 
[16:04:35.263]                         invokeRestart("muffleWarning")
[16:04:35.263]                     }
[16:04:35.263]                     else if (inherits(cond, "condition")) {
[16:04:35.263]                       if (!is.null(pattern)) {
[16:04:35.263]                         computeRestarts <- base::computeRestarts
[16:04:35.263]                         grepl <- base::grepl
[16:04:35.263]                         restarts <- computeRestarts(cond)
[16:04:35.263]                         for (restart in restarts) {
[16:04:35.263]                           name <- restart$name
[16:04:35.263]                           if (is.null(name)) 
[16:04:35.263]                             next
[16:04:35.263]                           if (!grepl(pattern, name)) 
[16:04:35.263]                             next
[16:04:35.263]                           invokeRestart(restart)
[16:04:35.263]                           muffled <- TRUE
[16:04:35.263]                           break
[16:04:35.263]                         }
[16:04:35.263]                       }
[16:04:35.263]                     }
[16:04:35.263]                     invisible(muffled)
[16:04:35.263]                   }
[16:04:35.263]                   muffleCondition(cond)
[16:04:35.263]                 })
[16:04:35.263]             }))
[16:04:35.263]             future::FutureResult(value = ...future.value$value, 
[16:04:35.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.263]                   ...future.rng), globalenv = if (FALSE) 
[16:04:35.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:35.263]                     ...future.globalenv.names))
[16:04:35.263]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:35.263]         }, condition = base::local({
[16:04:35.263]             c <- base::c
[16:04:35.263]             inherits <- base::inherits
[16:04:35.263]             invokeRestart <- base::invokeRestart
[16:04:35.263]             length <- base::length
[16:04:35.263]             list <- base::list
[16:04:35.263]             seq.int <- base::seq.int
[16:04:35.263]             signalCondition <- base::signalCondition
[16:04:35.263]             sys.calls <- base::sys.calls
[16:04:35.263]             `[[` <- base::`[[`
[16:04:35.263]             `+` <- base::`+`
[16:04:35.263]             `<<-` <- base::`<<-`
[16:04:35.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:35.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:35.263]                   3L)]
[16:04:35.263]             }
[16:04:35.263]             function(cond) {
[16:04:35.263]                 is_error <- inherits(cond, "error")
[16:04:35.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:35.263]                   NULL)
[16:04:35.263]                 if (is_error) {
[16:04:35.263]                   sessionInformation <- function() {
[16:04:35.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:35.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:35.263]                       search = base::search(), system = base::Sys.info())
[16:04:35.263]                   }
[16:04:35.263]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:35.263]                     cond$call), session = sessionInformation(), 
[16:04:35.263]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:35.263]                   signalCondition(cond)
[16:04:35.263]                 }
[16:04:35.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:35.263]                 "immediateCondition"))) {
[16:04:35.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:35.263]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:35.263]                   if (TRUE && !signal) {
[16:04:35.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.263]                     {
[16:04:35.263]                       inherits <- base::inherits
[16:04:35.263]                       invokeRestart <- base::invokeRestart
[16:04:35.263]                       is.null <- base::is.null
[16:04:35.263]                       muffled <- FALSE
[16:04:35.263]                       if (inherits(cond, "message")) {
[16:04:35.263]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.263]                         if (muffled) 
[16:04:35.263]                           invokeRestart("muffleMessage")
[16:04:35.263]                       }
[16:04:35.263]                       else if (inherits(cond, "warning")) {
[16:04:35.263]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.263]                         if (muffled) 
[16:04:35.263]                           invokeRestart("muffleWarning")
[16:04:35.263]                       }
[16:04:35.263]                       else if (inherits(cond, "condition")) {
[16:04:35.263]                         if (!is.null(pattern)) {
[16:04:35.263]                           computeRestarts <- base::computeRestarts
[16:04:35.263]                           grepl <- base::grepl
[16:04:35.263]                           restarts <- computeRestarts(cond)
[16:04:35.263]                           for (restart in restarts) {
[16:04:35.263]                             name <- restart$name
[16:04:35.263]                             if (is.null(name)) 
[16:04:35.263]                               next
[16:04:35.263]                             if (!grepl(pattern, name)) 
[16:04:35.263]                               next
[16:04:35.263]                             invokeRestart(restart)
[16:04:35.263]                             muffled <- TRUE
[16:04:35.263]                             break
[16:04:35.263]                           }
[16:04:35.263]                         }
[16:04:35.263]                       }
[16:04:35.263]                       invisible(muffled)
[16:04:35.263]                     }
[16:04:35.263]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.263]                   }
[16:04:35.263]                 }
[16:04:35.263]                 else {
[16:04:35.263]                   if (TRUE) {
[16:04:35.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.263]                     {
[16:04:35.263]                       inherits <- base::inherits
[16:04:35.263]                       invokeRestart <- base::invokeRestart
[16:04:35.263]                       is.null <- base::is.null
[16:04:35.263]                       muffled <- FALSE
[16:04:35.263]                       if (inherits(cond, "message")) {
[16:04:35.263]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.263]                         if (muffled) 
[16:04:35.263]                           invokeRestart("muffleMessage")
[16:04:35.263]                       }
[16:04:35.263]                       else if (inherits(cond, "warning")) {
[16:04:35.263]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.263]                         if (muffled) 
[16:04:35.263]                           invokeRestart("muffleWarning")
[16:04:35.263]                       }
[16:04:35.263]                       else if (inherits(cond, "condition")) {
[16:04:35.263]                         if (!is.null(pattern)) {
[16:04:35.263]                           computeRestarts <- base::computeRestarts
[16:04:35.263]                           grepl <- base::grepl
[16:04:35.263]                           restarts <- computeRestarts(cond)
[16:04:35.263]                           for (restart in restarts) {
[16:04:35.263]                             name <- restart$name
[16:04:35.263]                             if (is.null(name)) 
[16:04:35.263]                               next
[16:04:35.263]                             if (!grepl(pattern, name)) 
[16:04:35.263]                               next
[16:04:35.263]                             invokeRestart(restart)
[16:04:35.263]                             muffled <- TRUE
[16:04:35.263]                             break
[16:04:35.263]                           }
[16:04:35.263]                         }
[16:04:35.263]                       }
[16:04:35.263]                       invisible(muffled)
[16:04:35.263]                     }
[16:04:35.263]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.263]                   }
[16:04:35.263]                 }
[16:04:35.263]             }
[16:04:35.263]         }))
[16:04:35.263]     }, error = function(ex) {
[16:04:35.263]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:35.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.263]                 ...future.rng), started = ...future.startTime, 
[16:04:35.263]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:35.263]             version = "1.8"), class = "FutureResult")
[16:04:35.263]     }, finally = {
[16:04:35.263]         if (!identical(...future.workdir, getwd())) 
[16:04:35.263]             setwd(...future.workdir)
[16:04:35.263]         {
[16:04:35.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:35.263]                 ...future.oldOptions$nwarnings <- NULL
[16:04:35.263]             }
[16:04:35.263]             base::options(...future.oldOptions)
[16:04:35.263]             if (.Platform$OS.type == "windows") {
[16:04:35.263]                 old_names <- names(...future.oldEnvVars)
[16:04:35.263]                 envs <- base::Sys.getenv()
[16:04:35.263]                 names <- names(envs)
[16:04:35.263]                 common <- intersect(names, old_names)
[16:04:35.263]                 added <- setdiff(names, old_names)
[16:04:35.263]                 removed <- setdiff(old_names, names)
[16:04:35.263]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:35.263]                   envs[common]]
[16:04:35.263]                 NAMES <- toupper(changed)
[16:04:35.263]                 args <- list()
[16:04:35.263]                 for (kk in seq_along(NAMES)) {
[16:04:35.263]                   name <- changed[[kk]]
[16:04:35.263]                   NAME <- NAMES[[kk]]
[16:04:35.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.263]                     next
[16:04:35.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.263]                 }
[16:04:35.263]                 NAMES <- toupper(added)
[16:04:35.263]                 for (kk in seq_along(NAMES)) {
[16:04:35.263]                   name <- added[[kk]]
[16:04:35.263]                   NAME <- NAMES[[kk]]
[16:04:35.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.263]                     next
[16:04:35.263]                   args[[name]] <- ""
[16:04:35.263]                 }
[16:04:35.263]                 NAMES <- toupper(removed)
[16:04:35.263]                 for (kk in seq_along(NAMES)) {
[16:04:35.263]                   name <- removed[[kk]]
[16:04:35.263]                   NAME <- NAMES[[kk]]
[16:04:35.263]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.263]                     next
[16:04:35.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.263]                 }
[16:04:35.263]                 if (length(args) > 0) 
[16:04:35.263]                   base::do.call(base::Sys.setenv, args = args)
[16:04:35.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:35.263]             }
[16:04:35.263]             else {
[16:04:35.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:35.263]             }
[16:04:35.263]             {
[16:04:35.263]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:35.263]                   0L) {
[16:04:35.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:35.263]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:35.263]                   base::options(opts)
[16:04:35.263]                 }
[16:04:35.263]                 {
[16:04:35.263]                   {
[16:04:35.263]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:35.263]                     NULL
[16:04:35.263]                   }
[16:04:35.263]                   options(future.plan = NULL)
[16:04:35.263]                   if (is.na(NA_character_)) 
[16:04:35.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:35.263]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:35.263]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:35.263]                     envir = parent.frame()) 
[16:04:35.263]                   {
[16:04:35.263]                     if (is.function(workers)) 
[16:04:35.263]                       workers <- workers()
[16:04:35.263]                     workers <- structure(as.integer(workers), 
[16:04:35.263]                       class = class(workers))
[16:04:35.263]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:35.263]                       workers >= 1)
[16:04:35.263]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:35.263]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:35.263]                     }
[16:04:35.263]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:35.263]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:35.263]                       envir = envir)
[16:04:35.263]                     if (!future$lazy) 
[16:04:35.263]                       future <- run(future)
[16:04:35.263]                     invisible(future)
[16:04:35.263]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:35.263]                 }
[16:04:35.263]             }
[16:04:35.263]         }
[16:04:35.263]     })
[16:04:35.263]     if (TRUE) {
[16:04:35.263]         base::sink(type = "output", split = FALSE)
[16:04:35.263]         if (TRUE) {
[16:04:35.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:35.263]         }
[16:04:35.263]         else {
[16:04:35.263]             ...future.result["stdout"] <- base::list(NULL)
[16:04:35.263]         }
[16:04:35.263]         base::close(...future.stdout)
[16:04:35.263]         ...future.stdout <- NULL
[16:04:35.263]     }
[16:04:35.263]     ...future.result$conditions <- ...future.conditions
[16:04:35.263]     ...future.result$finished <- base::Sys.time()
[16:04:35.263]     ...future.result
[16:04:35.263] }
[16:04:35.266] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:04:35.266] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:04:35.266] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:04:35.267] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:04:35.267] MultisessionFuture started
[16:04:35.267] - Launch lazy future ... done
[16:04:35.267] run() for ‘MultisessionFuture’ ... done
[16:04:35.268] result() for ClusterFuture ...
[16:04:35.268] receiveMessageFromWorker() for ClusterFuture ...
[16:04:35.268] - Validating connection of MultisessionFuture
[16:04:35.315] - received message: FutureResult
[16:04:35.316] - Received FutureResult
[16:04:35.316] - Erased future from FutureRegistry
[16:04:35.316] result() for ClusterFuture ...
[16:04:35.316] - result already collected: FutureResult
[16:04:35.316] result() for ClusterFuture ... done
[16:04:35.316] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.316] result() for ClusterFuture ... done
[16:04:35.316] result() for ClusterFuture ...
[16:04:35.316] - result already collected: FutureResult
[16:04:35.316] result() for ClusterFuture ... done
[16:04:35.317] getGlobalsAndPackages() ...
[16:04:35.317] Searching for globals...
[16:04:35.318] - globals found: [3] ‘{’, ‘*’, ‘a’
[16:04:35.318] Searching for globals ... DONE
[16:04:35.318] Resolving globals: FALSE
[16:04:35.318] The total size of the 1 globals is 56 bytes (56 bytes)
[16:04:35.319] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:04:35.319] - globals: [1] ‘a’
[16:04:35.319] 
[16:04:35.319] getGlobalsAndPackages() ... DONE
[16:04:35.319] run() for ‘Future’ ...
[16:04:35.319] - state: ‘created’
[16:04:35.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:35.333] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:35.333] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:35.333]   - Field: ‘node’
[16:04:35.333]   - Field: ‘label’
[16:04:35.333]   - Field: ‘local’
[16:04:35.333]   - Field: ‘owner’
[16:04:35.333]   - Field: ‘envir’
[16:04:35.333]   - Field: ‘workers’
[16:04:35.334]   - Field: ‘packages’
[16:04:35.334]   - Field: ‘gc’
[16:04:35.334]   - Field: ‘conditions’
[16:04:35.334]   - Field: ‘persistent’
[16:04:35.334]   - Field: ‘expr’
[16:04:35.334]   - Field: ‘uuid’
[16:04:35.334]   - Field: ‘seed’
[16:04:35.334]   - Field: ‘version’
[16:04:35.334]   - Field: ‘result’
[16:04:35.334]   - Field: ‘asynchronous’
[16:04:35.334]   - Field: ‘calls’
[16:04:35.335]   - Field: ‘globals’
[16:04:35.335]   - Field: ‘stdout’
[16:04:35.335]   - Field: ‘earlySignal’
[16:04:35.335]   - Field: ‘lazy’
[16:04:35.335]   - Field: ‘state’
[16:04:35.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:35.335] - Launch lazy future ...
[16:04:35.335] Packages needed by the future expression (n = 0): <none>
[16:04:35.335] Packages needed by future strategies (n = 0): <none>
[16:04:35.336] {
[16:04:35.336]     {
[16:04:35.336]         {
[16:04:35.336]             ...future.startTime <- base::Sys.time()
[16:04:35.336]             {
[16:04:35.336]                 {
[16:04:35.336]                   {
[16:04:35.336]                     {
[16:04:35.336]                       base::local({
[16:04:35.336]                         has_future <- base::requireNamespace("future", 
[16:04:35.336]                           quietly = TRUE)
[16:04:35.336]                         if (has_future) {
[16:04:35.336]                           ns <- base::getNamespace("future")
[16:04:35.336]                           version <- ns[[".package"]][["version"]]
[16:04:35.336]                           if (is.null(version)) 
[16:04:35.336]                             version <- utils::packageVersion("future")
[16:04:35.336]                         }
[16:04:35.336]                         else {
[16:04:35.336]                           version <- NULL
[16:04:35.336]                         }
[16:04:35.336]                         if (!has_future || version < "1.8.0") {
[16:04:35.336]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:35.336]                             "", base::R.version$version.string), 
[16:04:35.336]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:35.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:35.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:35.336]                               "release", "version")], collapse = " "), 
[16:04:35.336]                             hostname = base::Sys.info()[["nodename"]])
[16:04:35.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:35.336]                             info)
[16:04:35.336]                           info <- base::paste(info, collapse = "; ")
[16:04:35.336]                           if (!has_future) {
[16:04:35.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:35.336]                               info)
[16:04:35.336]                           }
[16:04:35.336]                           else {
[16:04:35.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:35.336]                               info, version)
[16:04:35.336]                           }
[16:04:35.336]                           base::stop(msg)
[16:04:35.336]                         }
[16:04:35.336]                       })
[16:04:35.336]                     }
[16:04:35.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:35.336]                     base::options(mc.cores = 1L)
[16:04:35.336]                   }
[16:04:35.336]                   options(future.plan = NULL)
[16:04:35.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:35.336]                 }
[16:04:35.336]                 ...future.workdir <- getwd()
[16:04:35.336]             }
[16:04:35.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:35.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:35.336]         }
[16:04:35.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:35.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:35.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:35.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:35.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:35.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:35.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:35.336]             base::names(...future.oldOptions))
[16:04:35.336]     }
[16:04:35.336]     if (FALSE) {
[16:04:35.336]     }
[16:04:35.336]     else {
[16:04:35.336]         if (TRUE) {
[16:04:35.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:35.336]                 open = "w")
[16:04:35.336]         }
[16:04:35.336]         else {
[16:04:35.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:35.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:35.336]         }
[16:04:35.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:35.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:35.336]             base::sink(type = "output", split = FALSE)
[16:04:35.336]             base::close(...future.stdout)
[16:04:35.336]         }, add = TRUE)
[16:04:35.336]     }
[16:04:35.336]     ...future.frame <- base::sys.nframe()
[16:04:35.336]     ...future.conditions <- base::list()
[16:04:35.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:35.336]     if (FALSE) {
[16:04:35.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:35.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:35.336]     }
[16:04:35.336]     ...future.result <- base::tryCatch({
[16:04:35.336]         base::withCallingHandlers({
[16:04:35.336]             ...future.value <- base::withVisible(base::local({
[16:04:35.336]                 ...future.makeSendCondition <- base::local({
[16:04:35.336]                   sendCondition <- NULL
[16:04:35.336]                   function(frame = 1L) {
[16:04:35.336]                     if (is.function(sendCondition)) 
[16:04:35.336]                       return(sendCondition)
[16:04:35.336]                     ns <- getNamespace("parallel")
[16:04:35.336]                     if (exists("sendData", mode = "function", 
[16:04:35.336]                       envir = ns)) {
[16:04:35.336]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:35.336]                         envir = ns)
[16:04:35.336]                       envir <- sys.frame(frame)
[16:04:35.336]                       master <- NULL
[16:04:35.336]                       while (!identical(envir, .GlobalEnv) && 
[16:04:35.336]                         !identical(envir, emptyenv())) {
[16:04:35.336]                         if (exists("master", mode = "list", envir = envir, 
[16:04:35.336]                           inherits = FALSE)) {
[16:04:35.336]                           master <- get("master", mode = "list", 
[16:04:35.336]                             envir = envir, inherits = FALSE)
[16:04:35.336]                           if (inherits(master, c("SOCKnode", 
[16:04:35.336]                             "SOCK0node"))) {
[16:04:35.336]                             sendCondition <<- function(cond) {
[16:04:35.336]                               data <- list(type = "VALUE", value = cond, 
[16:04:35.336]                                 success = TRUE)
[16:04:35.336]                               parallel_sendData(master, data)
[16:04:35.336]                             }
[16:04:35.336]                             return(sendCondition)
[16:04:35.336]                           }
[16:04:35.336]                         }
[16:04:35.336]                         frame <- frame + 1L
[16:04:35.336]                         envir <- sys.frame(frame)
[16:04:35.336]                       }
[16:04:35.336]                     }
[16:04:35.336]                     sendCondition <<- function(cond) NULL
[16:04:35.336]                   }
[16:04:35.336]                 })
[16:04:35.336]                 withCallingHandlers({
[16:04:35.336]                   {
[16:04:35.336]                     2 * a
[16:04:35.336]                   }
[16:04:35.336]                 }, immediateCondition = function(cond) {
[16:04:35.336]                   sendCondition <- ...future.makeSendCondition()
[16:04:35.336]                   sendCondition(cond)
[16:04:35.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.336]                   {
[16:04:35.336]                     inherits <- base::inherits
[16:04:35.336]                     invokeRestart <- base::invokeRestart
[16:04:35.336]                     is.null <- base::is.null
[16:04:35.336]                     muffled <- FALSE
[16:04:35.336]                     if (inherits(cond, "message")) {
[16:04:35.336]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:35.336]                       if (muffled) 
[16:04:35.336]                         invokeRestart("muffleMessage")
[16:04:35.336]                     }
[16:04:35.336]                     else if (inherits(cond, "warning")) {
[16:04:35.336]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:35.336]                       if (muffled) 
[16:04:35.336]                         invokeRestart("muffleWarning")
[16:04:35.336]                     }
[16:04:35.336]                     else if (inherits(cond, "condition")) {
[16:04:35.336]                       if (!is.null(pattern)) {
[16:04:35.336]                         computeRestarts <- base::computeRestarts
[16:04:35.336]                         grepl <- base::grepl
[16:04:35.336]                         restarts <- computeRestarts(cond)
[16:04:35.336]                         for (restart in restarts) {
[16:04:35.336]                           name <- restart$name
[16:04:35.336]                           if (is.null(name)) 
[16:04:35.336]                             next
[16:04:35.336]                           if (!grepl(pattern, name)) 
[16:04:35.336]                             next
[16:04:35.336]                           invokeRestart(restart)
[16:04:35.336]                           muffled <- TRUE
[16:04:35.336]                           break
[16:04:35.336]                         }
[16:04:35.336]                       }
[16:04:35.336]                     }
[16:04:35.336]                     invisible(muffled)
[16:04:35.336]                   }
[16:04:35.336]                   muffleCondition(cond)
[16:04:35.336]                 })
[16:04:35.336]             }))
[16:04:35.336]             future::FutureResult(value = ...future.value$value, 
[16:04:35.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.336]                   ...future.rng), globalenv = if (FALSE) 
[16:04:35.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:35.336]                     ...future.globalenv.names))
[16:04:35.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:35.336]         }, condition = base::local({
[16:04:35.336]             c <- base::c
[16:04:35.336]             inherits <- base::inherits
[16:04:35.336]             invokeRestart <- base::invokeRestart
[16:04:35.336]             length <- base::length
[16:04:35.336]             list <- base::list
[16:04:35.336]             seq.int <- base::seq.int
[16:04:35.336]             signalCondition <- base::signalCondition
[16:04:35.336]             sys.calls <- base::sys.calls
[16:04:35.336]             `[[` <- base::`[[`
[16:04:35.336]             `+` <- base::`+`
[16:04:35.336]             `<<-` <- base::`<<-`
[16:04:35.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:35.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:35.336]                   3L)]
[16:04:35.336]             }
[16:04:35.336]             function(cond) {
[16:04:35.336]                 is_error <- inherits(cond, "error")
[16:04:35.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:35.336]                   NULL)
[16:04:35.336]                 if (is_error) {
[16:04:35.336]                   sessionInformation <- function() {
[16:04:35.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:35.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:35.336]                       search = base::search(), system = base::Sys.info())
[16:04:35.336]                   }
[16:04:35.336]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:35.336]                     cond$call), session = sessionInformation(), 
[16:04:35.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:35.336]                   signalCondition(cond)
[16:04:35.336]                 }
[16:04:35.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:35.336]                 "immediateCondition"))) {
[16:04:35.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:35.336]                   ...future.conditions[[length(...future.conditions) + 
[16:04:35.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:35.336]                   if (TRUE && !signal) {
[16:04:35.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.336]                     {
[16:04:35.336]                       inherits <- base::inherits
[16:04:35.336]                       invokeRestart <- base::invokeRestart
[16:04:35.336]                       is.null <- base::is.null
[16:04:35.336]                       muffled <- FALSE
[16:04:35.336]                       if (inherits(cond, "message")) {
[16:04:35.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.336]                         if (muffled) 
[16:04:35.336]                           invokeRestart("muffleMessage")
[16:04:35.336]                       }
[16:04:35.336]                       else if (inherits(cond, "warning")) {
[16:04:35.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.336]                         if (muffled) 
[16:04:35.336]                           invokeRestart("muffleWarning")
[16:04:35.336]                       }
[16:04:35.336]                       else if (inherits(cond, "condition")) {
[16:04:35.336]                         if (!is.null(pattern)) {
[16:04:35.336]                           computeRestarts <- base::computeRestarts
[16:04:35.336]                           grepl <- base::grepl
[16:04:35.336]                           restarts <- computeRestarts(cond)
[16:04:35.336]                           for (restart in restarts) {
[16:04:35.336]                             name <- restart$name
[16:04:35.336]                             if (is.null(name)) 
[16:04:35.336]                               next
[16:04:35.336]                             if (!grepl(pattern, name)) 
[16:04:35.336]                               next
[16:04:35.336]                             invokeRestart(restart)
[16:04:35.336]                             muffled <- TRUE
[16:04:35.336]                             break
[16:04:35.336]                           }
[16:04:35.336]                         }
[16:04:35.336]                       }
[16:04:35.336]                       invisible(muffled)
[16:04:35.336]                     }
[16:04:35.336]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.336]                   }
[16:04:35.336]                 }
[16:04:35.336]                 else {
[16:04:35.336]                   if (TRUE) {
[16:04:35.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:35.336]                     {
[16:04:35.336]                       inherits <- base::inherits
[16:04:35.336]                       invokeRestart <- base::invokeRestart
[16:04:35.336]                       is.null <- base::is.null
[16:04:35.336]                       muffled <- FALSE
[16:04:35.336]                       if (inherits(cond, "message")) {
[16:04:35.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:35.336]                         if (muffled) 
[16:04:35.336]                           invokeRestart("muffleMessage")
[16:04:35.336]                       }
[16:04:35.336]                       else if (inherits(cond, "warning")) {
[16:04:35.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:35.336]                         if (muffled) 
[16:04:35.336]                           invokeRestart("muffleWarning")
[16:04:35.336]                       }
[16:04:35.336]                       else if (inherits(cond, "condition")) {
[16:04:35.336]                         if (!is.null(pattern)) {
[16:04:35.336]                           computeRestarts <- base::computeRestarts
[16:04:35.336]                           grepl <- base::grepl
[16:04:35.336]                           restarts <- computeRestarts(cond)
[16:04:35.336]                           for (restart in restarts) {
[16:04:35.336]                             name <- restart$name
[16:04:35.336]                             if (is.null(name)) 
[16:04:35.336]                               next
[16:04:35.336]                             if (!grepl(pattern, name)) 
[16:04:35.336]                               next
[16:04:35.336]                             invokeRestart(restart)
[16:04:35.336]                             muffled <- TRUE
[16:04:35.336]                             break
[16:04:35.336]                           }
[16:04:35.336]                         }
[16:04:35.336]                       }
[16:04:35.336]                       invisible(muffled)
[16:04:35.336]                     }
[16:04:35.336]                     muffleCondition(cond, pattern = "^muffle")
[16:04:35.336]                   }
[16:04:35.336]                 }
[16:04:35.336]             }
[16:04:35.336]         }))
[16:04:35.336]     }, error = function(ex) {
[16:04:35.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:35.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:35.336]                 ...future.rng), started = ...future.startTime, 
[16:04:35.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:35.336]             version = "1.8"), class = "FutureResult")
[16:04:35.336]     }, finally = {
[16:04:35.336]         if (!identical(...future.workdir, getwd())) 
[16:04:35.336]             setwd(...future.workdir)
[16:04:35.336]         {
[16:04:35.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:35.336]                 ...future.oldOptions$nwarnings <- NULL
[16:04:35.336]             }
[16:04:35.336]             base::options(...future.oldOptions)
[16:04:35.336]             if (.Platform$OS.type == "windows") {
[16:04:35.336]                 old_names <- names(...future.oldEnvVars)
[16:04:35.336]                 envs <- base::Sys.getenv()
[16:04:35.336]                 names <- names(envs)
[16:04:35.336]                 common <- intersect(names, old_names)
[16:04:35.336]                 added <- setdiff(names, old_names)
[16:04:35.336]                 removed <- setdiff(old_names, names)
[16:04:35.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:35.336]                   envs[common]]
[16:04:35.336]                 NAMES <- toupper(changed)
[16:04:35.336]                 args <- list()
[16:04:35.336]                 for (kk in seq_along(NAMES)) {
[16:04:35.336]                   name <- changed[[kk]]
[16:04:35.336]                   NAME <- NAMES[[kk]]
[16:04:35.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.336]                     next
[16:04:35.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.336]                 }
[16:04:35.336]                 NAMES <- toupper(added)
[16:04:35.336]                 for (kk in seq_along(NAMES)) {
[16:04:35.336]                   name <- added[[kk]]
[16:04:35.336]                   NAME <- NAMES[[kk]]
[16:04:35.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.336]                     next
[16:04:35.336]                   args[[name]] <- ""
[16:04:35.336]                 }
[16:04:35.336]                 NAMES <- toupper(removed)
[16:04:35.336]                 for (kk in seq_along(NAMES)) {
[16:04:35.336]                   name <- removed[[kk]]
[16:04:35.336]                   NAME <- NAMES[[kk]]
[16:04:35.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:35.336]                     next
[16:04:35.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:35.336]                 }
[16:04:35.336]                 if (length(args) > 0) 
[16:04:35.336]                   base::do.call(base::Sys.setenv, args = args)
[16:04:35.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:35.336]             }
[16:04:35.336]             else {
[16:04:35.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:35.336]             }
[16:04:35.336]             {
[16:04:35.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:35.336]                   0L) {
[16:04:35.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:35.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:35.336]                   base::options(opts)
[16:04:35.336]                 }
[16:04:35.336]                 {
[16:04:35.336]                   {
[16:04:35.336]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:35.336]                     NULL
[16:04:35.336]                   }
[16:04:35.336]                   options(future.plan = NULL)
[16:04:35.336]                   if (is.na(NA_character_)) 
[16:04:35.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:35.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:35.336]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:35.336]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:35.336]                     envir = parent.frame()) 
[16:04:35.336]                   {
[16:04:35.336]                     if (is.function(workers)) 
[16:04:35.336]                       workers <- workers()
[16:04:35.336]                     workers <- structure(as.integer(workers), 
[16:04:35.336]                       class = class(workers))
[16:04:35.336]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:35.336]                       workers >= 1)
[16:04:35.336]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:35.336]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:35.336]                     }
[16:04:35.336]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:35.336]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:35.336]                       envir = envir)
[16:04:35.336]                     if (!future$lazy) 
[16:04:35.336]                       future <- run(future)
[16:04:35.336]                     invisible(future)
[16:04:35.336]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:35.336]                 }
[16:04:35.336]             }
[16:04:35.336]         }
[16:04:35.336]     })
[16:04:35.336]     if (TRUE) {
[16:04:35.336]         base::sink(type = "output", split = FALSE)
[16:04:35.336]         if (TRUE) {
[16:04:35.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:35.336]         }
[16:04:35.336]         else {
[16:04:35.336]             ...future.result["stdout"] <- base::list(NULL)
[16:04:35.336]         }
[16:04:35.336]         base::close(...future.stdout)
[16:04:35.336]         ...future.stdout <- NULL
[16:04:35.336]     }
[16:04:35.336]     ...future.result$conditions <- ...future.conditions
[16:04:35.336]     ...future.result$finished <- base::Sys.time()
[16:04:35.336]     ...future.result
[16:04:35.336] }
[16:04:35.338] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:04:35.339] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[16:04:35.339] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[16:04:35.339] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:04:35.340] MultisessionFuture started
[16:04:35.340] - Launch lazy future ... done
[16:04:35.340] run() for ‘MultisessionFuture’ ... done
[16:04:35.340] result() for ClusterFuture ...
[16:04:35.340] receiveMessageFromWorker() for ClusterFuture ...
[16:04:35.340] - Validating connection of MultisessionFuture
[16:04:35.387] - received message: FutureResult
[16:04:35.388] - Received FutureResult
[16:04:35.388] - Erased future from FutureRegistry
[16:04:35.388] result() for ClusterFuture ...
[16:04:35.388] - result already collected: FutureResult
[16:04:35.388] result() for ClusterFuture ... done
[16:04:35.388] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:35.388] result() for ClusterFuture ... done
[16:04:35.388] result() for ClusterFuture ...
[16:04:35.388] - result already collected: FutureResult
[16:04:35.388] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[16:04:35.389] plan(): Setting new future strategy stack:
[16:04:35.389] List of future strategies:
[16:04:35.389] 1. FutureStrategy:
[16:04:35.389]    - args: function (..., envir = parent.frame())
[16:04:35.389]    - tweaked: FALSE
[16:04:35.389]    - call: future::plan(oplan)
[16:04:35.390] plan(): nbrOfWorkers() = 1
> 
