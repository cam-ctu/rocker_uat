
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:24.057] plan(): Setting new future strategy stack:
[10:26:24.058] List of future strategies:
[10:26:24.058] 1. sequential:
[10:26:24.058]    - args: function (..., envir = parent.frame())
[10:26:24.058]    - tweaked: FALSE
[10:26:24.058]    - call: future::plan("sequential")
[10:26:24.072] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[10:26:24.085] plan(): Setting new future strategy stack:
[10:26:24.085] List of future strategies:
[10:26:24.085] 1. multicore:
[10:26:24.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.085]    - tweaked: FALSE
[10:26:24.085]    - call: plan(multicore)
[10:26:24.099] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[10:26:24.156] getGlobalsAndPackages() ...
[10:26:24.157] Not searching for globals
[10:26:24.157] - globals: [0] <none>
[10:26:24.157] getGlobalsAndPackages() ... DONE
[10:26:24.158] Packages needed by the future expression (n = 0): <none>
[10:26:24.158] Packages needed by future strategies (n = 0): <none>
[10:26:24.159] {
[10:26:24.159]     {
[10:26:24.159]         {
[10:26:24.159]             ...future.startTime <- base::Sys.time()
[10:26:24.159]             {
[10:26:24.159]                 {
[10:26:24.159]                   {
[10:26:24.159]                     base::local({
[10:26:24.159]                       has_future <- base::requireNamespace("future", 
[10:26:24.159]                         quietly = TRUE)
[10:26:24.159]                       if (has_future) {
[10:26:24.159]                         ns <- base::getNamespace("future")
[10:26:24.159]                         version <- ns[[".package"]][["version"]]
[10:26:24.159]                         if (is.null(version)) 
[10:26:24.159]                           version <- utils::packageVersion("future")
[10:26:24.159]                       }
[10:26:24.159]                       else {
[10:26:24.159]                         version <- NULL
[10:26:24.159]                       }
[10:26:24.159]                       if (!has_future || version < "1.8.0") {
[10:26:24.159]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.159]                           "", base::R.version$version.string), 
[10:26:24.159]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.159]                             "release", "version")], collapse = " "), 
[10:26:24.159]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.159]                           info)
[10:26:24.159]                         info <- base::paste(info, collapse = "; ")
[10:26:24.159]                         if (!has_future) {
[10:26:24.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.159]                             info)
[10:26:24.159]                         }
[10:26:24.159]                         else {
[10:26:24.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.159]                             info, version)
[10:26:24.159]                         }
[10:26:24.159]                         base::stop(msg)
[10:26:24.159]                       }
[10:26:24.159]                     })
[10:26:24.159]                   }
[10:26:24.159]                   options(future.plan = NULL)
[10:26:24.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.159]                 }
[10:26:24.159]                 ...future.workdir <- getwd()
[10:26:24.159]             }
[10:26:24.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.159]         }
[10:26:24.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.159]             base::names(...future.oldOptions))
[10:26:24.159]     }
[10:26:24.159]     if (FALSE) {
[10:26:24.159]     }
[10:26:24.159]     else {
[10:26:24.159]         if (TRUE) {
[10:26:24.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.159]                 open = "w")
[10:26:24.159]         }
[10:26:24.159]         else {
[10:26:24.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.159]         }
[10:26:24.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.159]             base::sink(type = "output", split = FALSE)
[10:26:24.159]             base::close(...future.stdout)
[10:26:24.159]         }, add = TRUE)
[10:26:24.159]     }
[10:26:24.159]     ...future.frame <- base::sys.nframe()
[10:26:24.159]     ...future.conditions <- base::list()
[10:26:24.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.159]     if (FALSE) {
[10:26:24.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.159]     }
[10:26:24.159]     ...future.result <- base::tryCatch({
[10:26:24.159]         base::withCallingHandlers({
[10:26:24.159]             ...future.value <- base::withVisible(base::local({
[10:26:24.159]                 42L
[10:26:24.159]             }))
[10:26:24.159]             future::FutureResult(value = ...future.value$value, 
[10:26:24.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.159]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.159]                     ...future.globalenv.names))
[10:26:24.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.159]         }, condition = base::local({
[10:26:24.159]             c <- base::c
[10:26:24.159]             inherits <- base::inherits
[10:26:24.159]             invokeRestart <- base::invokeRestart
[10:26:24.159]             length <- base::length
[10:26:24.159]             list <- base::list
[10:26:24.159]             seq.int <- base::seq.int
[10:26:24.159]             signalCondition <- base::signalCondition
[10:26:24.159]             sys.calls <- base::sys.calls
[10:26:24.159]             `[[` <- base::`[[`
[10:26:24.159]             `+` <- base::`+`
[10:26:24.159]             `<<-` <- base::`<<-`
[10:26:24.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.159]                   3L)]
[10:26:24.159]             }
[10:26:24.159]             function(cond) {
[10:26:24.159]                 is_error <- inherits(cond, "error")
[10:26:24.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.159]                   NULL)
[10:26:24.159]                 if (is_error) {
[10:26:24.159]                   sessionInformation <- function() {
[10:26:24.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.159]                       search = base::search(), system = base::Sys.info())
[10:26:24.159]                   }
[10:26:24.159]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.159]                     cond$call), session = sessionInformation(), 
[10:26:24.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.159]                   signalCondition(cond)
[10:26:24.159]                 }
[10:26:24.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.159]                 "immediateCondition"))) {
[10:26:24.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.159]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.159]                   if (TRUE && !signal) {
[10:26:24.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.159]                     {
[10:26:24.159]                       inherits <- base::inherits
[10:26:24.159]                       invokeRestart <- base::invokeRestart
[10:26:24.159]                       is.null <- base::is.null
[10:26:24.159]                       muffled <- FALSE
[10:26:24.159]                       if (inherits(cond, "message")) {
[10:26:24.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.159]                         if (muffled) 
[10:26:24.159]                           invokeRestart("muffleMessage")
[10:26:24.159]                       }
[10:26:24.159]                       else if (inherits(cond, "warning")) {
[10:26:24.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.159]                         if (muffled) 
[10:26:24.159]                           invokeRestart("muffleWarning")
[10:26:24.159]                       }
[10:26:24.159]                       else if (inherits(cond, "condition")) {
[10:26:24.159]                         if (!is.null(pattern)) {
[10:26:24.159]                           computeRestarts <- base::computeRestarts
[10:26:24.159]                           grepl <- base::grepl
[10:26:24.159]                           restarts <- computeRestarts(cond)
[10:26:24.159]                           for (restart in restarts) {
[10:26:24.159]                             name <- restart$name
[10:26:24.159]                             if (is.null(name)) 
[10:26:24.159]                               next
[10:26:24.159]                             if (!grepl(pattern, name)) 
[10:26:24.159]                               next
[10:26:24.159]                             invokeRestart(restart)
[10:26:24.159]                             muffled <- TRUE
[10:26:24.159]                             break
[10:26:24.159]                           }
[10:26:24.159]                         }
[10:26:24.159]                       }
[10:26:24.159]                       invisible(muffled)
[10:26:24.159]                     }
[10:26:24.159]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.159]                   }
[10:26:24.159]                 }
[10:26:24.159]                 else {
[10:26:24.159]                   if (TRUE) {
[10:26:24.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.159]                     {
[10:26:24.159]                       inherits <- base::inherits
[10:26:24.159]                       invokeRestart <- base::invokeRestart
[10:26:24.159]                       is.null <- base::is.null
[10:26:24.159]                       muffled <- FALSE
[10:26:24.159]                       if (inherits(cond, "message")) {
[10:26:24.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.159]                         if (muffled) 
[10:26:24.159]                           invokeRestart("muffleMessage")
[10:26:24.159]                       }
[10:26:24.159]                       else if (inherits(cond, "warning")) {
[10:26:24.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.159]                         if (muffled) 
[10:26:24.159]                           invokeRestart("muffleWarning")
[10:26:24.159]                       }
[10:26:24.159]                       else if (inherits(cond, "condition")) {
[10:26:24.159]                         if (!is.null(pattern)) {
[10:26:24.159]                           computeRestarts <- base::computeRestarts
[10:26:24.159]                           grepl <- base::grepl
[10:26:24.159]                           restarts <- computeRestarts(cond)
[10:26:24.159]                           for (restart in restarts) {
[10:26:24.159]                             name <- restart$name
[10:26:24.159]                             if (is.null(name)) 
[10:26:24.159]                               next
[10:26:24.159]                             if (!grepl(pattern, name)) 
[10:26:24.159]                               next
[10:26:24.159]                             invokeRestart(restart)
[10:26:24.159]                             muffled <- TRUE
[10:26:24.159]                             break
[10:26:24.159]                           }
[10:26:24.159]                         }
[10:26:24.159]                       }
[10:26:24.159]                       invisible(muffled)
[10:26:24.159]                     }
[10:26:24.159]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.159]                   }
[10:26:24.159]                 }
[10:26:24.159]             }
[10:26:24.159]         }))
[10:26:24.159]     }, error = function(ex) {
[10:26:24.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.159]                 ...future.rng), started = ...future.startTime, 
[10:26:24.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.159]             version = "1.8"), class = "FutureResult")
[10:26:24.159]     }, finally = {
[10:26:24.159]         if (!identical(...future.workdir, getwd())) 
[10:26:24.159]             setwd(...future.workdir)
[10:26:24.159]         {
[10:26:24.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.159]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.159]             }
[10:26:24.159]             base::options(...future.oldOptions)
[10:26:24.159]             if (.Platform$OS.type == "windows") {
[10:26:24.159]                 old_names <- names(...future.oldEnvVars)
[10:26:24.159]                 envs <- base::Sys.getenv()
[10:26:24.159]                 names <- names(envs)
[10:26:24.159]                 common <- intersect(names, old_names)
[10:26:24.159]                 added <- setdiff(names, old_names)
[10:26:24.159]                 removed <- setdiff(old_names, names)
[10:26:24.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.159]                   envs[common]]
[10:26:24.159]                 NAMES <- toupper(changed)
[10:26:24.159]                 args <- list()
[10:26:24.159]                 for (kk in seq_along(NAMES)) {
[10:26:24.159]                   name <- changed[[kk]]
[10:26:24.159]                   NAME <- NAMES[[kk]]
[10:26:24.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.159]                     next
[10:26:24.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.159]                 }
[10:26:24.159]                 NAMES <- toupper(added)
[10:26:24.159]                 for (kk in seq_along(NAMES)) {
[10:26:24.159]                   name <- added[[kk]]
[10:26:24.159]                   NAME <- NAMES[[kk]]
[10:26:24.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.159]                     next
[10:26:24.159]                   args[[name]] <- ""
[10:26:24.159]                 }
[10:26:24.159]                 NAMES <- toupper(removed)
[10:26:24.159]                 for (kk in seq_along(NAMES)) {
[10:26:24.159]                   name <- removed[[kk]]
[10:26:24.159]                   NAME <- NAMES[[kk]]
[10:26:24.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.159]                     next
[10:26:24.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.159]                 }
[10:26:24.159]                 if (length(args) > 0) 
[10:26:24.159]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.159]             }
[10:26:24.159]             else {
[10:26:24.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.159]             }
[10:26:24.159]             {
[10:26:24.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.159]                   0L) {
[10:26:24.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.159]                   base::options(opts)
[10:26:24.159]                 }
[10:26:24.159]                 {
[10:26:24.159]                   {
[10:26:24.159]                     NULL
[10:26:24.159]                     RNGkind("Mersenne-Twister")
[10:26:24.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.159]                       inherits = FALSE)
[10:26:24.159]                   }
[10:26:24.159]                   options(future.plan = NULL)
[10:26:24.159]                   if (is.na(NA_character_)) 
[10:26:24.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.159]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.159]                     envir = parent.frame()) 
[10:26:24.159]                   {
[10:26:24.159]                     default_workers <- missing(workers)
[10:26:24.159]                     if (is.function(workers)) 
[10:26:24.159]                       workers <- workers()
[10:26:24.159]                     workers <- structure(as.integer(workers), 
[10:26:24.159]                       class = class(workers))
[10:26:24.159]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.159]                       1L)
[10:26:24.159]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.159]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.159]                       if (default_workers) 
[10:26:24.159]                         supportsMulticore(warn = TRUE)
[10:26:24.159]                       return(sequential(..., envir = envir))
[10:26:24.159]                     }
[10:26:24.159]                     oopts <- options(mc.cores = workers)
[10:26:24.159]                     on.exit(options(oopts))
[10:26:24.159]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.159]                       envir = envir)
[10:26:24.159]                     if (!future$lazy) 
[10:26:24.159]                       future <- run(future)
[10:26:24.159]                     invisible(future)
[10:26:24.159]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.159]                 }
[10:26:24.159]             }
[10:26:24.159]         }
[10:26:24.159]     })
[10:26:24.159]     if (TRUE) {
[10:26:24.159]         base::sink(type = "output", split = FALSE)
[10:26:24.159]         if (TRUE) {
[10:26:24.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.159]         }
[10:26:24.159]         else {
[10:26:24.159]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.159]         }
[10:26:24.159]         base::close(...future.stdout)
[10:26:24.159]         ...future.stdout <- NULL
[10:26:24.159]     }
[10:26:24.159]     ...future.result$conditions <- ...future.conditions
[10:26:24.159]     ...future.result$finished <- base::Sys.time()
[10:26:24.159]     ...future.result
[10:26:24.159] }
[10:26:24.161] plan(): Setting new future strategy stack:
[10:26:24.161] List of future strategies:
[10:26:24.161] 1. sequential:
[10:26:24.161]    - args: function (..., envir = parent.frame())
[10:26:24.161]    - tweaked: FALSE
[10:26:24.161]    - call: NULL
[10:26:24.162] plan(): nbrOfWorkers() = 1
[10:26:24.163] plan(): Setting new future strategy stack:
[10:26:24.163] List of future strategies:
[10:26:24.163] 1. multicore:
[10:26:24.163]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.163]    - tweaked: FALSE
[10:26:24.163]    - call: plan(multicore)
[10:26:24.166] plan(): nbrOfWorkers() = 1
[10:26:24.166] SequentialFuture started (and completed)
[10:26:24.167] resolved() for ‘SequentialFuture’ ...
[10:26:24.167] - state: ‘finished’
[10:26:24.167] - run: TRUE
[10:26:24.167] - result: ‘FutureResult’
[10:26:24.167] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[10:26:24.171] getGlobalsAndPackages() ...
[10:26:24.171] Not searching for globals
[10:26:24.171] - globals: [0] <none>
[10:26:24.171] getGlobalsAndPackages() ... DONE
[10:26:24.172] Packages needed by the future expression (n = 0): <none>
[10:26:24.172] Packages needed by future strategies (n = 0): <none>
[10:26:24.172] {
[10:26:24.172]     {
[10:26:24.172]         {
[10:26:24.172]             ...future.startTime <- base::Sys.time()
[10:26:24.172]             {
[10:26:24.172]                 {
[10:26:24.172]                   {
[10:26:24.172]                     base::local({
[10:26:24.172]                       has_future <- base::requireNamespace("future", 
[10:26:24.172]                         quietly = TRUE)
[10:26:24.172]                       if (has_future) {
[10:26:24.172]                         ns <- base::getNamespace("future")
[10:26:24.172]                         version <- ns[[".package"]][["version"]]
[10:26:24.172]                         if (is.null(version)) 
[10:26:24.172]                           version <- utils::packageVersion("future")
[10:26:24.172]                       }
[10:26:24.172]                       else {
[10:26:24.172]                         version <- NULL
[10:26:24.172]                       }
[10:26:24.172]                       if (!has_future || version < "1.8.0") {
[10:26:24.172]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.172]                           "", base::R.version$version.string), 
[10:26:24.172]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.172]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.172]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.172]                             "release", "version")], collapse = " "), 
[10:26:24.172]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.172]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.172]                           info)
[10:26:24.172]                         info <- base::paste(info, collapse = "; ")
[10:26:24.172]                         if (!has_future) {
[10:26:24.172]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.172]                             info)
[10:26:24.172]                         }
[10:26:24.172]                         else {
[10:26:24.172]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.172]                             info, version)
[10:26:24.172]                         }
[10:26:24.172]                         base::stop(msg)
[10:26:24.172]                       }
[10:26:24.172]                     })
[10:26:24.172]                   }
[10:26:24.172]                   options(future.plan = NULL)
[10:26:24.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.172]                 }
[10:26:24.172]                 ...future.workdir <- getwd()
[10:26:24.172]             }
[10:26:24.172]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.172]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.172]         }
[10:26:24.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.172]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.172]             base::names(...future.oldOptions))
[10:26:24.172]     }
[10:26:24.172]     if (FALSE) {
[10:26:24.172]     }
[10:26:24.172]     else {
[10:26:24.172]         if (TRUE) {
[10:26:24.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.172]                 open = "w")
[10:26:24.172]         }
[10:26:24.172]         else {
[10:26:24.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.172]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.172]         }
[10:26:24.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.172]             base::sink(type = "output", split = FALSE)
[10:26:24.172]             base::close(...future.stdout)
[10:26:24.172]         }, add = TRUE)
[10:26:24.172]     }
[10:26:24.172]     ...future.frame <- base::sys.nframe()
[10:26:24.172]     ...future.conditions <- base::list()
[10:26:24.172]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.172]     if (FALSE) {
[10:26:24.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.172]     }
[10:26:24.172]     ...future.result <- base::tryCatch({
[10:26:24.172]         base::withCallingHandlers({
[10:26:24.172]             ...future.value <- base::withVisible(base::local({
[10:26:24.172]                 b <- 3
[10:26:24.172]                 c <- 2
[10:26:24.172]                 a * b * c
[10:26:24.172]             }))
[10:26:24.172]             future::FutureResult(value = ...future.value$value, 
[10:26:24.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.172]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.172]                     ...future.globalenv.names))
[10:26:24.172]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.172]         }, condition = base::local({
[10:26:24.172]             c <- base::c
[10:26:24.172]             inherits <- base::inherits
[10:26:24.172]             invokeRestart <- base::invokeRestart
[10:26:24.172]             length <- base::length
[10:26:24.172]             list <- base::list
[10:26:24.172]             seq.int <- base::seq.int
[10:26:24.172]             signalCondition <- base::signalCondition
[10:26:24.172]             sys.calls <- base::sys.calls
[10:26:24.172]             `[[` <- base::`[[`
[10:26:24.172]             `+` <- base::`+`
[10:26:24.172]             `<<-` <- base::`<<-`
[10:26:24.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.172]                   3L)]
[10:26:24.172]             }
[10:26:24.172]             function(cond) {
[10:26:24.172]                 is_error <- inherits(cond, "error")
[10:26:24.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.172]                   NULL)
[10:26:24.172]                 if (is_error) {
[10:26:24.172]                   sessionInformation <- function() {
[10:26:24.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.172]                       search = base::search(), system = base::Sys.info())
[10:26:24.172]                   }
[10:26:24.172]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.172]                     cond$call), session = sessionInformation(), 
[10:26:24.172]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.172]                   signalCondition(cond)
[10:26:24.172]                 }
[10:26:24.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.172]                 "immediateCondition"))) {
[10:26:24.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.172]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.172]                   if (TRUE && !signal) {
[10:26:24.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.172]                     {
[10:26:24.172]                       inherits <- base::inherits
[10:26:24.172]                       invokeRestart <- base::invokeRestart
[10:26:24.172]                       is.null <- base::is.null
[10:26:24.172]                       muffled <- FALSE
[10:26:24.172]                       if (inherits(cond, "message")) {
[10:26:24.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.172]                         if (muffled) 
[10:26:24.172]                           invokeRestart("muffleMessage")
[10:26:24.172]                       }
[10:26:24.172]                       else if (inherits(cond, "warning")) {
[10:26:24.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.172]                         if (muffled) 
[10:26:24.172]                           invokeRestart("muffleWarning")
[10:26:24.172]                       }
[10:26:24.172]                       else if (inherits(cond, "condition")) {
[10:26:24.172]                         if (!is.null(pattern)) {
[10:26:24.172]                           computeRestarts <- base::computeRestarts
[10:26:24.172]                           grepl <- base::grepl
[10:26:24.172]                           restarts <- computeRestarts(cond)
[10:26:24.172]                           for (restart in restarts) {
[10:26:24.172]                             name <- restart$name
[10:26:24.172]                             if (is.null(name)) 
[10:26:24.172]                               next
[10:26:24.172]                             if (!grepl(pattern, name)) 
[10:26:24.172]                               next
[10:26:24.172]                             invokeRestart(restart)
[10:26:24.172]                             muffled <- TRUE
[10:26:24.172]                             break
[10:26:24.172]                           }
[10:26:24.172]                         }
[10:26:24.172]                       }
[10:26:24.172]                       invisible(muffled)
[10:26:24.172]                     }
[10:26:24.172]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.172]                   }
[10:26:24.172]                 }
[10:26:24.172]                 else {
[10:26:24.172]                   if (TRUE) {
[10:26:24.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.172]                     {
[10:26:24.172]                       inherits <- base::inherits
[10:26:24.172]                       invokeRestart <- base::invokeRestart
[10:26:24.172]                       is.null <- base::is.null
[10:26:24.172]                       muffled <- FALSE
[10:26:24.172]                       if (inherits(cond, "message")) {
[10:26:24.172]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.172]                         if (muffled) 
[10:26:24.172]                           invokeRestart("muffleMessage")
[10:26:24.172]                       }
[10:26:24.172]                       else if (inherits(cond, "warning")) {
[10:26:24.172]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.172]                         if (muffled) 
[10:26:24.172]                           invokeRestart("muffleWarning")
[10:26:24.172]                       }
[10:26:24.172]                       else if (inherits(cond, "condition")) {
[10:26:24.172]                         if (!is.null(pattern)) {
[10:26:24.172]                           computeRestarts <- base::computeRestarts
[10:26:24.172]                           grepl <- base::grepl
[10:26:24.172]                           restarts <- computeRestarts(cond)
[10:26:24.172]                           for (restart in restarts) {
[10:26:24.172]                             name <- restart$name
[10:26:24.172]                             if (is.null(name)) 
[10:26:24.172]                               next
[10:26:24.172]                             if (!grepl(pattern, name)) 
[10:26:24.172]                               next
[10:26:24.172]                             invokeRestart(restart)
[10:26:24.172]                             muffled <- TRUE
[10:26:24.172]                             break
[10:26:24.172]                           }
[10:26:24.172]                         }
[10:26:24.172]                       }
[10:26:24.172]                       invisible(muffled)
[10:26:24.172]                     }
[10:26:24.172]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.172]                   }
[10:26:24.172]                 }
[10:26:24.172]             }
[10:26:24.172]         }))
[10:26:24.172]     }, error = function(ex) {
[10:26:24.172]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.172]                 ...future.rng), started = ...future.startTime, 
[10:26:24.172]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.172]             version = "1.8"), class = "FutureResult")
[10:26:24.172]     }, finally = {
[10:26:24.172]         if (!identical(...future.workdir, getwd())) 
[10:26:24.172]             setwd(...future.workdir)
[10:26:24.172]         {
[10:26:24.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.172]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.172]             }
[10:26:24.172]             base::options(...future.oldOptions)
[10:26:24.172]             if (.Platform$OS.type == "windows") {
[10:26:24.172]                 old_names <- names(...future.oldEnvVars)
[10:26:24.172]                 envs <- base::Sys.getenv()
[10:26:24.172]                 names <- names(envs)
[10:26:24.172]                 common <- intersect(names, old_names)
[10:26:24.172]                 added <- setdiff(names, old_names)
[10:26:24.172]                 removed <- setdiff(old_names, names)
[10:26:24.172]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.172]                   envs[common]]
[10:26:24.172]                 NAMES <- toupper(changed)
[10:26:24.172]                 args <- list()
[10:26:24.172]                 for (kk in seq_along(NAMES)) {
[10:26:24.172]                   name <- changed[[kk]]
[10:26:24.172]                   NAME <- NAMES[[kk]]
[10:26:24.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.172]                     next
[10:26:24.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.172]                 }
[10:26:24.172]                 NAMES <- toupper(added)
[10:26:24.172]                 for (kk in seq_along(NAMES)) {
[10:26:24.172]                   name <- added[[kk]]
[10:26:24.172]                   NAME <- NAMES[[kk]]
[10:26:24.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.172]                     next
[10:26:24.172]                   args[[name]] <- ""
[10:26:24.172]                 }
[10:26:24.172]                 NAMES <- toupper(removed)
[10:26:24.172]                 for (kk in seq_along(NAMES)) {
[10:26:24.172]                   name <- removed[[kk]]
[10:26:24.172]                   NAME <- NAMES[[kk]]
[10:26:24.172]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.172]                     next
[10:26:24.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.172]                 }
[10:26:24.172]                 if (length(args) > 0) 
[10:26:24.172]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.172]             }
[10:26:24.172]             else {
[10:26:24.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.172]             }
[10:26:24.172]             {
[10:26:24.172]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.172]                   0L) {
[10:26:24.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.172]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.172]                   base::options(opts)
[10:26:24.172]                 }
[10:26:24.172]                 {
[10:26:24.172]                   {
[10:26:24.172]                     NULL
[10:26:24.172]                     RNGkind("Mersenne-Twister")
[10:26:24.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.172]                       inherits = FALSE)
[10:26:24.172]                   }
[10:26:24.172]                   options(future.plan = NULL)
[10:26:24.172]                   if (is.na(NA_character_)) 
[10:26:24.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.172]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.172]                     envir = parent.frame()) 
[10:26:24.172]                   {
[10:26:24.172]                     default_workers <- missing(workers)
[10:26:24.172]                     if (is.function(workers)) 
[10:26:24.172]                       workers <- workers()
[10:26:24.172]                     workers <- structure(as.integer(workers), 
[10:26:24.172]                       class = class(workers))
[10:26:24.172]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.172]                       1L)
[10:26:24.172]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.172]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.172]                       if (default_workers) 
[10:26:24.172]                         supportsMulticore(warn = TRUE)
[10:26:24.172]                       return(sequential(..., envir = envir))
[10:26:24.172]                     }
[10:26:24.172]                     oopts <- options(mc.cores = workers)
[10:26:24.172]                     on.exit(options(oopts))
[10:26:24.172]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.172]                       envir = envir)
[10:26:24.172]                     if (!future$lazy) 
[10:26:24.172]                       future <- run(future)
[10:26:24.172]                     invisible(future)
[10:26:24.172]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.172]                 }
[10:26:24.172]             }
[10:26:24.172]         }
[10:26:24.172]     })
[10:26:24.172]     if (TRUE) {
[10:26:24.172]         base::sink(type = "output", split = FALSE)
[10:26:24.172]         if (TRUE) {
[10:26:24.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.172]         }
[10:26:24.172]         else {
[10:26:24.172]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.172]         }
[10:26:24.172]         base::close(...future.stdout)
[10:26:24.172]         ...future.stdout <- NULL
[10:26:24.172]     }
[10:26:24.172]     ...future.result$conditions <- ...future.conditions
[10:26:24.172]     ...future.result$finished <- base::Sys.time()
[10:26:24.172]     ...future.result
[10:26:24.172] }
[10:26:24.174] plan(): Setting new future strategy stack:
[10:26:24.174] List of future strategies:
[10:26:24.174] 1. sequential:
[10:26:24.174]    - args: function (..., envir = parent.frame())
[10:26:24.174]    - tweaked: FALSE
[10:26:24.174]    - call: NULL
[10:26:24.174] plan(): nbrOfWorkers() = 1
[10:26:24.175] plan(): Setting new future strategy stack:
[10:26:24.175] List of future strategies:
[10:26:24.175] 1. multicore:
[10:26:24.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.175]    - tweaked: FALSE
[10:26:24.175]    - call: plan(multicore)
[10:26:24.179] plan(): nbrOfWorkers() = 1
[10:26:24.179] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[10:26:24.183] getGlobalsAndPackages() ...
[10:26:24.183] Not searching for globals
[10:26:24.184] - globals: [0] <none>
[10:26:24.184] getGlobalsAndPackages() ... DONE
[10:26:24.184] Packages needed by the future expression (n = 0): <none>
[10:26:24.184] Packages needed by future strategies (n = 0): <none>
[10:26:24.184] {
[10:26:24.184]     {
[10:26:24.184]         {
[10:26:24.184]             ...future.startTime <- base::Sys.time()
[10:26:24.184]             {
[10:26:24.184]                 {
[10:26:24.184]                   {
[10:26:24.184]                     base::local({
[10:26:24.184]                       has_future <- base::requireNamespace("future", 
[10:26:24.184]                         quietly = TRUE)
[10:26:24.184]                       if (has_future) {
[10:26:24.184]                         ns <- base::getNamespace("future")
[10:26:24.184]                         version <- ns[[".package"]][["version"]]
[10:26:24.184]                         if (is.null(version)) 
[10:26:24.184]                           version <- utils::packageVersion("future")
[10:26:24.184]                       }
[10:26:24.184]                       else {
[10:26:24.184]                         version <- NULL
[10:26:24.184]                       }
[10:26:24.184]                       if (!has_future || version < "1.8.0") {
[10:26:24.184]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.184]                           "", base::R.version$version.string), 
[10:26:24.184]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.184]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.184]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.184]                             "release", "version")], collapse = " "), 
[10:26:24.184]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.184]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.184]                           info)
[10:26:24.184]                         info <- base::paste(info, collapse = "; ")
[10:26:24.184]                         if (!has_future) {
[10:26:24.184]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.184]                             info)
[10:26:24.184]                         }
[10:26:24.184]                         else {
[10:26:24.184]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.184]                             info, version)
[10:26:24.184]                         }
[10:26:24.184]                         base::stop(msg)
[10:26:24.184]                       }
[10:26:24.184]                     })
[10:26:24.184]                   }
[10:26:24.184]                   options(future.plan = NULL)
[10:26:24.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.184]                 }
[10:26:24.184]                 ...future.workdir <- getwd()
[10:26:24.184]             }
[10:26:24.184]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.184]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.184]         }
[10:26:24.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.184]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.184]             base::names(...future.oldOptions))
[10:26:24.184]     }
[10:26:24.184]     if (FALSE) {
[10:26:24.184]     }
[10:26:24.184]     else {
[10:26:24.184]         if (TRUE) {
[10:26:24.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.184]                 open = "w")
[10:26:24.184]         }
[10:26:24.184]         else {
[10:26:24.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.184]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.184]         }
[10:26:24.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.184]             base::sink(type = "output", split = FALSE)
[10:26:24.184]             base::close(...future.stdout)
[10:26:24.184]         }, add = TRUE)
[10:26:24.184]     }
[10:26:24.184]     ...future.frame <- base::sys.nframe()
[10:26:24.184]     ...future.conditions <- base::list()
[10:26:24.184]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.184]     if (FALSE) {
[10:26:24.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.184]     }
[10:26:24.184]     ...future.result <- base::tryCatch({
[10:26:24.184]         base::withCallingHandlers({
[10:26:24.184]             ...future.value <- base::withVisible(base::local({
[10:26:24.184]                 ii
[10:26:24.184]             }))
[10:26:24.184]             future::FutureResult(value = ...future.value$value, 
[10:26:24.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.184]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.184]                     ...future.globalenv.names))
[10:26:24.184]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.184]         }, condition = base::local({
[10:26:24.184]             c <- base::c
[10:26:24.184]             inherits <- base::inherits
[10:26:24.184]             invokeRestart <- base::invokeRestart
[10:26:24.184]             length <- base::length
[10:26:24.184]             list <- base::list
[10:26:24.184]             seq.int <- base::seq.int
[10:26:24.184]             signalCondition <- base::signalCondition
[10:26:24.184]             sys.calls <- base::sys.calls
[10:26:24.184]             `[[` <- base::`[[`
[10:26:24.184]             `+` <- base::`+`
[10:26:24.184]             `<<-` <- base::`<<-`
[10:26:24.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.184]                   3L)]
[10:26:24.184]             }
[10:26:24.184]             function(cond) {
[10:26:24.184]                 is_error <- inherits(cond, "error")
[10:26:24.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.184]                   NULL)
[10:26:24.184]                 if (is_error) {
[10:26:24.184]                   sessionInformation <- function() {
[10:26:24.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.184]                       search = base::search(), system = base::Sys.info())
[10:26:24.184]                   }
[10:26:24.184]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.184]                     cond$call), session = sessionInformation(), 
[10:26:24.184]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.184]                   signalCondition(cond)
[10:26:24.184]                 }
[10:26:24.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.184]                 "immediateCondition"))) {
[10:26:24.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.184]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.184]                   if (TRUE && !signal) {
[10:26:24.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.184]                     {
[10:26:24.184]                       inherits <- base::inherits
[10:26:24.184]                       invokeRestart <- base::invokeRestart
[10:26:24.184]                       is.null <- base::is.null
[10:26:24.184]                       muffled <- FALSE
[10:26:24.184]                       if (inherits(cond, "message")) {
[10:26:24.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.184]                         if (muffled) 
[10:26:24.184]                           invokeRestart("muffleMessage")
[10:26:24.184]                       }
[10:26:24.184]                       else if (inherits(cond, "warning")) {
[10:26:24.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.184]                         if (muffled) 
[10:26:24.184]                           invokeRestart("muffleWarning")
[10:26:24.184]                       }
[10:26:24.184]                       else if (inherits(cond, "condition")) {
[10:26:24.184]                         if (!is.null(pattern)) {
[10:26:24.184]                           computeRestarts <- base::computeRestarts
[10:26:24.184]                           grepl <- base::grepl
[10:26:24.184]                           restarts <- computeRestarts(cond)
[10:26:24.184]                           for (restart in restarts) {
[10:26:24.184]                             name <- restart$name
[10:26:24.184]                             if (is.null(name)) 
[10:26:24.184]                               next
[10:26:24.184]                             if (!grepl(pattern, name)) 
[10:26:24.184]                               next
[10:26:24.184]                             invokeRestart(restart)
[10:26:24.184]                             muffled <- TRUE
[10:26:24.184]                             break
[10:26:24.184]                           }
[10:26:24.184]                         }
[10:26:24.184]                       }
[10:26:24.184]                       invisible(muffled)
[10:26:24.184]                     }
[10:26:24.184]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.184]                   }
[10:26:24.184]                 }
[10:26:24.184]                 else {
[10:26:24.184]                   if (TRUE) {
[10:26:24.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.184]                     {
[10:26:24.184]                       inherits <- base::inherits
[10:26:24.184]                       invokeRestart <- base::invokeRestart
[10:26:24.184]                       is.null <- base::is.null
[10:26:24.184]                       muffled <- FALSE
[10:26:24.184]                       if (inherits(cond, "message")) {
[10:26:24.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.184]                         if (muffled) 
[10:26:24.184]                           invokeRestart("muffleMessage")
[10:26:24.184]                       }
[10:26:24.184]                       else if (inherits(cond, "warning")) {
[10:26:24.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.184]                         if (muffled) 
[10:26:24.184]                           invokeRestart("muffleWarning")
[10:26:24.184]                       }
[10:26:24.184]                       else if (inherits(cond, "condition")) {
[10:26:24.184]                         if (!is.null(pattern)) {
[10:26:24.184]                           computeRestarts <- base::computeRestarts
[10:26:24.184]                           grepl <- base::grepl
[10:26:24.184]                           restarts <- computeRestarts(cond)
[10:26:24.184]                           for (restart in restarts) {
[10:26:24.184]                             name <- restart$name
[10:26:24.184]                             if (is.null(name)) 
[10:26:24.184]                               next
[10:26:24.184]                             if (!grepl(pattern, name)) 
[10:26:24.184]                               next
[10:26:24.184]                             invokeRestart(restart)
[10:26:24.184]                             muffled <- TRUE
[10:26:24.184]                             break
[10:26:24.184]                           }
[10:26:24.184]                         }
[10:26:24.184]                       }
[10:26:24.184]                       invisible(muffled)
[10:26:24.184]                     }
[10:26:24.184]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.184]                   }
[10:26:24.184]                 }
[10:26:24.184]             }
[10:26:24.184]         }))
[10:26:24.184]     }, error = function(ex) {
[10:26:24.184]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.184]                 ...future.rng), started = ...future.startTime, 
[10:26:24.184]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.184]             version = "1.8"), class = "FutureResult")
[10:26:24.184]     }, finally = {
[10:26:24.184]         if (!identical(...future.workdir, getwd())) 
[10:26:24.184]             setwd(...future.workdir)
[10:26:24.184]         {
[10:26:24.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.184]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.184]             }
[10:26:24.184]             base::options(...future.oldOptions)
[10:26:24.184]             if (.Platform$OS.type == "windows") {
[10:26:24.184]                 old_names <- names(...future.oldEnvVars)
[10:26:24.184]                 envs <- base::Sys.getenv()
[10:26:24.184]                 names <- names(envs)
[10:26:24.184]                 common <- intersect(names, old_names)
[10:26:24.184]                 added <- setdiff(names, old_names)
[10:26:24.184]                 removed <- setdiff(old_names, names)
[10:26:24.184]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.184]                   envs[common]]
[10:26:24.184]                 NAMES <- toupper(changed)
[10:26:24.184]                 args <- list()
[10:26:24.184]                 for (kk in seq_along(NAMES)) {
[10:26:24.184]                   name <- changed[[kk]]
[10:26:24.184]                   NAME <- NAMES[[kk]]
[10:26:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.184]                     next
[10:26:24.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.184]                 }
[10:26:24.184]                 NAMES <- toupper(added)
[10:26:24.184]                 for (kk in seq_along(NAMES)) {
[10:26:24.184]                   name <- added[[kk]]
[10:26:24.184]                   NAME <- NAMES[[kk]]
[10:26:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.184]                     next
[10:26:24.184]                   args[[name]] <- ""
[10:26:24.184]                 }
[10:26:24.184]                 NAMES <- toupper(removed)
[10:26:24.184]                 for (kk in seq_along(NAMES)) {
[10:26:24.184]                   name <- removed[[kk]]
[10:26:24.184]                   NAME <- NAMES[[kk]]
[10:26:24.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.184]                     next
[10:26:24.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.184]                 }
[10:26:24.184]                 if (length(args) > 0) 
[10:26:24.184]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.184]             }
[10:26:24.184]             else {
[10:26:24.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.184]             }
[10:26:24.184]             {
[10:26:24.184]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.184]                   0L) {
[10:26:24.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.184]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.184]                   base::options(opts)
[10:26:24.184]                 }
[10:26:24.184]                 {
[10:26:24.184]                   {
[10:26:24.184]                     NULL
[10:26:24.184]                     RNGkind("Mersenne-Twister")
[10:26:24.184]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.184]                       inherits = FALSE)
[10:26:24.184]                   }
[10:26:24.184]                   options(future.plan = NULL)
[10:26:24.184]                   if (is.na(NA_character_)) 
[10:26:24.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.184]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.184]                     envir = parent.frame()) 
[10:26:24.184]                   {
[10:26:24.184]                     default_workers <- missing(workers)
[10:26:24.184]                     if (is.function(workers)) 
[10:26:24.184]                       workers <- workers()
[10:26:24.184]                     workers <- structure(as.integer(workers), 
[10:26:24.184]                       class = class(workers))
[10:26:24.184]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.184]                       1L)
[10:26:24.184]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.184]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.184]                       if (default_workers) 
[10:26:24.184]                         supportsMulticore(warn = TRUE)
[10:26:24.184]                       return(sequential(..., envir = envir))
[10:26:24.184]                     }
[10:26:24.184]                     oopts <- options(mc.cores = workers)
[10:26:24.184]                     on.exit(options(oopts))
[10:26:24.184]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.184]                       envir = envir)
[10:26:24.184]                     if (!future$lazy) 
[10:26:24.184]                       future <- run(future)
[10:26:24.184]                     invisible(future)
[10:26:24.184]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.184]                 }
[10:26:24.184]             }
[10:26:24.184]         }
[10:26:24.184]     })
[10:26:24.184]     if (TRUE) {
[10:26:24.184]         base::sink(type = "output", split = FALSE)
[10:26:24.184]         if (TRUE) {
[10:26:24.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.184]         }
[10:26:24.184]         else {
[10:26:24.184]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.184]         }
[10:26:24.184]         base::close(...future.stdout)
[10:26:24.184]         ...future.stdout <- NULL
[10:26:24.184]     }
[10:26:24.184]     ...future.result$conditions <- ...future.conditions
[10:26:24.184]     ...future.result$finished <- base::Sys.time()
[10:26:24.184]     ...future.result
[10:26:24.184] }
[10:26:24.186] plan(): Setting new future strategy stack:
[10:26:24.186] List of future strategies:
[10:26:24.186] 1. sequential:
[10:26:24.186]    - args: function (..., envir = parent.frame())
[10:26:24.186]    - tweaked: FALSE
[10:26:24.186]    - call: NULL
[10:26:24.187] plan(): nbrOfWorkers() = 1
[10:26:24.187] plan(): Setting new future strategy stack:
[10:26:24.187] List of future strategies:
[10:26:24.187] 1. multicore:
[10:26:24.187]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.187]    - tweaked: FALSE
[10:26:24.187]    - call: plan(multicore)
[10:26:24.191] plan(): nbrOfWorkers() = 1
[10:26:24.191] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[10:26:24.196] getGlobalsAndPackages() ...
[10:26:24.197] Not searching for globals
[10:26:24.197] - globals: [0] <none>
[10:26:24.197] getGlobalsAndPackages() ... DONE
[10:26:24.197] Packages needed by the future expression (n = 0): <none>
[10:26:24.197] Packages needed by future strategies (n = 0): <none>
[10:26:24.198] {
[10:26:24.198]     {
[10:26:24.198]         {
[10:26:24.198]             ...future.startTime <- base::Sys.time()
[10:26:24.198]             {
[10:26:24.198]                 {
[10:26:24.198]                   {
[10:26:24.198]                     base::local({
[10:26:24.198]                       has_future <- base::requireNamespace("future", 
[10:26:24.198]                         quietly = TRUE)
[10:26:24.198]                       if (has_future) {
[10:26:24.198]                         ns <- base::getNamespace("future")
[10:26:24.198]                         version <- ns[[".package"]][["version"]]
[10:26:24.198]                         if (is.null(version)) 
[10:26:24.198]                           version <- utils::packageVersion("future")
[10:26:24.198]                       }
[10:26:24.198]                       else {
[10:26:24.198]                         version <- NULL
[10:26:24.198]                       }
[10:26:24.198]                       if (!has_future || version < "1.8.0") {
[10:26:24.198]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.198]                           "", base::R.version$version.string), 
[10:26:24.198]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.198]                             "release", "version")], collapse = " "), 
[10:26:24.198]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.198]                           info)
[10:26:24.198]                         info <- base::paste(info, collapse = "; ")
[10:26:24.198]                         if (!has_future) {
[10:26:24.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.198]                             info)
[10:26:24.198]                         }
[10:26:24.198]                         else {
[10:26:24.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.198]                             info, version)
[10:26:24.198]                         }
[10:26:24.198]                         base::stop(msg)
[10:26:24.198]                       }
[10:26:24.198]                     })
[10:26:24.198]                   }
[10:26:24.198]                   options(future.plan = NULL)
[10:26:24.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.198]                 }
[10:26:24.198]                 ...future.workdir <- getwd()
[10:26:24.198]             }
[10:26:24.198]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.198]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.198]         }
[10:26:24.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.198]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.198]             base::names(...future.oldOptions))
[10:26:24.198]     }
[10:26:24.198]     if (FALSE) {
[10:26:24.198]     }
[10:26:24.198]     else {
[10:26:24.198]         if (TRUE) {
[10:26:24.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.198]                 open = "w")
[10:26:24.198]         }
[10:26:24.198]         else {
[10:26:24.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.198]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.198]         }
[10:26:24.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.198]             base::sink(type = "output", split = FALSE)
[10:26:24.198]             base::close(...future.stdout)
[10:26:24.198]         }, add = TRUE)
[10:26:24.198]     }
[10:26:24.198]     ...future.frame <- base::sys.nframe()
[10:26:24.198]     ...future.conditions <- base::list()
[10:26:24.198]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.198]     if (FALSE) {
[10:26:24.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.198]     }
[10:26:24.198]     ...future.result <- base::tryCatch({
[10:26:24.198]         base::withCallingHandlers({
[10:26:24.198]             ...future.value <- base::withVisible(base::local({
[10:26:24.198]                 ii
[10:26:24.198]             }))
[10:26:24.198]             future::FutureResult(value = ...future.value$value, 
[10:26:24.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.198]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.198]                     ...future.globalenv.names))
[10:26:24.198]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.198]         }, condition = base::local({
[10:26:24.198]             c <- base::c
[10:26:24.198]             inherits <- base::inherits
[10:26:24.198]             invokeRestart <- base::invokeRestart
[10:26:24.198]             length <- base::length
[10:26:24.198]             list <- base::list
[10:26:24.198]             seq.int <- base::seq.int
[10:26:24.198]             signalCondition <- base::signalCondition
[10:26:24.198]             sys.calls <- base::sys.calls
[10:26:24.198]             `[[` <- base::`[[`
[10:26:24.198]             `+` <- base::`+`
[10:26:24.198]             `<<-` <- base::`<<-`
[10:26:24.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.198]                   3L)]
[10:26:24.198]             }
[10:26:24.198]             function(cond) {
[10:26:24.198]                 is_error <- inherits(cond, "error")
[10:26:24.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.198]                   NULL)
[10:26:24.198]                 if (is_error) {
[10:26:24.198]                   sessionInformation <- function() {
[10:26:24.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.198]                       search = base::search(), system = base::Sys.info())
[10:26:24.198]                   }
[10:26:24.198]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.198]                     cond$call), session = sessionInformation(), 
[10:26:24.198]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.198]                   signalCondition(cond)
[10:26:24.198]                 }
[10:26:24.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.198]                 "immediateCondition"))) {
[10:26:24.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.198]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.198]                   if (TRUE && !signal) {
[10:26:24.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.198]                     {
[10:26:24.198]                       inherits <- base::inherits
[10:26:24.198]                       invokeRestart <- base::invokeRestart
[10:26:24.198]                       is.null <- base::is.null
[10:26:24.198]                       muffled <- FALSE
[10:26:24.198]                       if (inherits(cond, "message")) {
[10:26:24.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.198]                         if (muffled) 
[10:26:24.198]                           invokeRestart("muffleMessage")
[10:26:24.198]                       }
[10:26:24.198]                       else if (inherits(cond, "warning")) {
[10:26:24.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.198]                         if (muffled) 
[10:26:24.198]                           invokeRestart("muffleWarning")
[10:26:24.198]                       }
[10:26:24.198]                       else if (inherits(cond, "condition")) {
[10:26:24.198]                         if (!is.null(pattern)) {
[10:26:24.198]                           computeRestarts <- base::computeRestarts
[10:26:24.198]                           grepl <- base::grepl
[10:26:24.198]                           restarts <- computeRestarts(cond)
[10:26:24.198]                           for (restart in restarts) {
[10:26:24.198]                             name <- restart$name
[10:26:24.198]                             if (is.null(name)) 
[10:26:24.198]                               next
[10:26:24.198]                             if (!grepl(pattern, name)) 
[10:26:24.198]                               next
[10:26:24.198]                             invokeRestart(restart)
[10:26:24.198]                             muffled <- TRUE
[10:26:24.198]                             break
[10:26:24.198]                           }
[10:26:24.198]                         }
[10:26:24.198]                       }
[10:26:24.198]                       invisible(muffled)
[10:26:24.198]                     }
[10:26:24.198]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.198]                   }
[10:26:24.198]                 }
[10:26:24.198]                 else {
[10:26:24.198]                   if (TRUE) {
[10:26:24.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.198]                     {
[10:26:24.198]                       inherits <- base::inherits
[10:26:24.198]                       invokeRestart <- base::invokeRestart
[10:26:24.198]                       is.null <- base::is.null
[10:26:24.198]                       muffled <- FALSE
[10:26:24.198]                       if (inherits(cond, "message")) {
[10:26:24.198]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.198]                         if (muffled) 
[10:26:24.198]                           invokeRestart("muffleMessage")
[10:26:24.198]                       }
[10:26:24.198]                       else if (inherits(cond, "warning")) {
[10:26:24.198]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.198]                         if (muffled) 
[10:26:24.198]                           invokeRestart("muffleWarning")
[10:26:24.198]                       }
[10:26:24.198]                       else if (inherits(cond, "condition")) {
[10:26:24.198]                         if (!is.null(pattern)) {
[10:26:24.198]                           computeRestarts <- base::computeRestarts
[10:26:24.198]                           grepl <- base::grepl
[10:26:24.198]                           restarts <- computeRestarts(cond)
[10:26:24.198]                           for (restart in restarts) {
[10:26:24.198]                             name <- restart$name
[10:26:24.198]                             if (is.null(name)) 
[10:26:24.198]                               next
[10:26:24.198]                             if (!grepl(pattern, name)) 
[10:26:24.198]                               next
[10:26:24.198]                             invokeRestart(restart)
[10:26:24.198]                             muffled <- TRUE
[10:26:24.198]                             break
[10:26:24.198]                           }
[10:26:24.198]                         }
[10:26:24.198]                       }
[10:26:24.198]                       invisible(muffled)
[10:26:24.198]                     }
[10:26:24.198]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.198]                   }
[10:26:24.198]                 }
[10:26:24.198]             }
[10:26:24.198]         }))
[10:26:24.198]     }, error = function(ex) {
[10:26:24.198]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.198]                 ...future.rng), started = ...future.startTime, 
[10:26:24.198]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.198]             version = "1.8"), class = "FutureResult")
[10:26:24.198]     }, finally = {
[10:26:24.198]         if (!identical(...future.workdir, getwd())) 
[10:26:24.198]             setwd(...future.workdir)
[10:26:24.198]         {
[10:26:24.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.198]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.198]             }
[10:26:24.198]             base::options(...future.oldOptions)
[10:26:24.198]             if (.Platform$OS.type == "windows") {
[10:26:24.198]                 old_names <- names(...future.oldEnvVars)
[10:26:24.198]                 envs <- base::Sys.getenv()
[10:26:24.198]                 names <- names(envs)
[10:26:24.198]                 common <- intersect(names, old_names)
[10:26:24.198]                 added <- setdiff(names, old_names)
[10:26:24.198]                 removed <- setdiff(old_names, names)
[10:26:24.198]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.198]                   envs[common]]
[10:26:24.198]                 NAMES <- toupper(changed)
[10:26:24.198]                 args <- list()
[10:26:24.198]                 for (kk in seq_along(NAMES)) {
[10:26:24.198]                   name <- changed[[kk]]
[10:26:24.198]                   NAME <- NAMES[[kk]]
[10:26:24.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.198]                     next
[10:26:24.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.198]                 }
[10:26:24.198]                 NAMES <- toupper(added)
[10:26:24.198]                 for (kk in seq_along(NAMES)) {
[10:26:24.198]                   name <- added[[kk]]
[10:26:24.198]                   NAME <- NAMES[[kk]]
[10:26:24.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.198]                     next
[10:26:24.198]                   args[[name]] <- ""
[10:26:24.198]                 }
[10:26:24.198]                 NAMES <- toupper(removed)
[10:26:24.198]                 for (kk in seq_along(NAMES)) {
[10:26:24.198]                   name <- removed[[kk]]
[10:26:24.198]                   NAME <- NAMES[[kk]]
[10:26:24.198]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.198]                     next
[10:26:24.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.198]                 }
[10:26:24.198]                 if (length(args) > 0) 
[10:26:24.198]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.198]             }
[10:26:24.198]             else {
[10:26:24.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.198]             }
[10:26:24.198]             {
[10:26:24.198]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.198]                   0L) {
[10:26:24.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.198]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.198]                   base::options(opts)
[10:26:24.198]                 }
[10:26:24.198]                 {
[10:26:24.198]                   {
[10:26:24.198]                     NULL
[10:26:24.198]                     RNGkind("Mersenne-Twister")
[10:26:24.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.198]                       inherits = FALSE)
[10:26:24.198]                   }
[10:26:24.198]                   options(future.plan = NULL)
[10:26:24.198]                   if (is.na(NA_character_)) 
[10:26:24.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.198]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.198]                     envir = parent.frame()) 
[10:26:24.198]                   {
[10:26:24.198]                     default_workers <- missing(workers)
[10:26:24.198]                     if (is.function(workers)) 
[10:26:24.198]                       workers <- workers()
[10:26:24.198]                     workers <- structure(as.integer(workers), 
[10:26:24.198]                       class = class(workers))
[10:26:24.198]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.198]                       1L)
[10:26:24.198]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.198]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.198]                       if (default_workers) 
[10:26:24.198]                         supportsMulticore(warn = TRUE)
[10:26:24.198]                       return(sequential(..., envir = envir))
[10:26:24.198]                     }
[10:26:24.198]                     oopts <- options(mc.cores = workers)
[10:26:24.198]                     on.exit(options(oopts))
[10:26:24.198]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.198]                       envir = envir)
[10:26:24.198]                     if (!future$lazy) 
[10:26:24.198]                       future <- run(future)
[10:26:24.198]                     invisible(future)
[10:26:24.198]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.198]                 }
[10:26:24.198]             }
[10:26:24.198]         }
[10:26:24.198]     })
[10:26:24.198]     if (TRUE) {
[10:26:24.198]         base::sink(type = "output", split = FALSE)
[10:26:24.198]         if (TRUE) {
[10:26:24.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.198]         }
[10:26:24.198]         else {
[10:26:24.198]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.198]         }
[10:26:24.198]         base::close(...future.stdout)
[10:26:24.198]         ...future.stdout <- NULL
[10:26:24.198]     }
[10:26:24.198]     ...future.result$conditions <- ...future.conditions
[10:26:24.198]     ...future.result$finished <- base::Sys.time()
[10:26:24.198]     ...future.result
[10:26:24.198] }
[10:26:24.199] plan(): Setting new future strategy stack:
[10:26:24.199] List of future strategies:
[10:26:24.199] 1. sequential:
[10:26:24.199]    - args: function (..., envir = parent.frame())
[10:26:24.199]    - tweaked: FALSE
[10:26:24.199]    - call: NULL
[10:26:24.200] plan(): nbrOfWorkers() = 1
[10:26:24.201] plan(): Setting new future strategy stack:
[10:26:24.201] List of future strategies:
[10:26:24.201] 1. multicore:
[10:26:24.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.201]    - tweaked: FALSE
[10:26:24.201]    - call: plan(multicore)
[10:26:24.204] plan(): nbrOfWorkers() = 1
[10:26:24.204] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[10:26:24.207] getGlobalsAndPackages() ...
[10:26:24.208] Not searching for globals
[10:26:24.208] - globals: [0] <none>
[10:26:24.208] getGlobalsAndPackages() ... DONE
[10:26:24.208] Packages needed by the future expression (n = 0): <none>
[10:26:24.208] Packages needed by future strategies (n = 0): <none>
[10:26:24.209] {
[10:26:24.209]     {
[10:26:24.209]         {
[10:26:24.209]             ...future.startTime <- base::Sys.time()
[10:26:24.209]             {
[10:26:24.209]                 {
[10:26:24.209]                   {
[10:26:24.209]                     base::local({
[10:26:24.209]                       has_future <- base::requireNamespace("future", 
[10:26:24.209]                         quietly = TRUE)
[10:26:24.209]                       if (has_future) {
[10:26:24.209]                         ns <- base::getNamespace("future")
[10:26:24.209]                         version <- ns[[".package"]][["version"]]
[10:26:24.209]                         if (is.null(version)) 
[10:26:24.209]                           version <- utils::packageVersion("future")
[10:26:24.209]                       }
[10:26:24.209]                       else {
[10:26:24.209]                         version <- NULL
[10:26:24.209]                       }
[10:26:24.209]                       if (!has_future || version < "1.8.0") {
[10:26:24.209]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.209]                           "", base::R.version$version.string), 
[10:26:24.209]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.209]                             "release", "version")], collapse = " "), 
[10:26:24.209]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.209]                           info)
[10:26:24.209]                         info <- base::paste(info, collapse = "; ")
[10:26:24.209]                         if (!has_future) {
[10:26:24.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.209]                             info)
[10:26:24.209]                         }
[10:26:24.209]                         else {
[10:26:24.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.209]                             info, version)
[10:26:24.209]                         }
[10:26:24.209]                         base::stop(msg)
[10:26:24.209]                       }
[10:26:24.209]                     })
[10:26:24.209]                   }
[10:26:24.209]                   options(future.plan = NULL)
[10:26:24.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.209]                 }
[10:26:24.209]                 ...future.workdir <- getwd()
[10:26:24.209]             }
[10:26:24.209]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.209]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.209]         }
[10:26:24.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.209]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.209]             base::names(...future.oldOptions))
[10:26:24.209]     }
[10:26:24.209]     if (FALSE) {
[10:26:24.209]     }
[10:26:24.209]     else {
[10:26:24.209]         if (TRUE) {
[10:26:24.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.209]                 open = "w")
[10:26:24.209]         }
[10:26:24.209]         else {
[10:26:24.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.209]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.209]         }
[10:26:24.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.209]             base::sink(type = "output", split = FALSE)
[10:26:24.209]             base::close(...future.stdout)
[10:26:24.209]         }, add = TRUE)
[10:26:24.209]     }
[10:26:24.209]     ...future.frame <- base::sys.nframe()
[10:26:24.209]     ...future.conditions <- base::list()
[10:26:24.209]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.209]     if (FALSE) {
[10:26:24.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.209]     }
[10:26:24.209]     ...future.result <- base::tryCatch({
[10:26:24.209]         base::withCallingHandlers({
[10:26:24.209]             ...future.value <- base::withVisible(base::local({
[10:26:24.209]                 ii
[10:26:24.209]             }))
[10:26:24.209]             future::FutureResult(value = ...future.value$value, 
[10:26:24.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.209]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.209]                     ...future.globalenv.names))
[10:26:24.209]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.209]         }, condition = base::local({
[10:26:24.209]             c <- base::c
[10:26:24.209]             inherits <- base::inherits
[10:26:24.209]             invokeRestart <- base::invokeRestart
[10:26:24.209]             length <- base::length
[10:26:24.209]             list <- base::list
[10:26:24.209]             seq.int <- base::seq.int
[10:26:24.209]             signalCondition <- base::signalCondition
[10:26:24.209]             sys.calls <- base::sys.calls
[10:26:24.209]             `[[` <- base::`[[`
[10:26:24.209]             `+` <- base::`+`
[10:26:24.209]             `<<-` <- base::`<<-`
[10:26:24.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.209]                   3L)]
[10:26:24.209]             }
[10:26:24.209]             function(cond) {
[10:26:24.209]                 is_error <- inherits(cond, "error")
[10:26:24.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.209]                   NULL)
[10:26:24.209]                 if (is_error) {
[10:26:24.209]                   sessionInformation <- function() {
[10:26:24.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.209]                       search = base::search(), system = base::Sys.info())
[10:26:24.209]                   }
[10:26:24.209]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.209]                     cond$call), session = sessionInformation(), 
[10:26:24.209]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.209]                   signalCondition(cond)
[10:26:24.209]                 }
[10:26:24.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.209]                 "immediateCondition"))) {
[10:26:24.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.209]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.209]                   if (TRUE && !signal) {
[10:26:24.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.209]                     {
[10:26:24.209]                       inherits <- base::inherits
[10:26:24.209]                       invokeRestart <- base::invokeRestart
[10:26:24.209]                       is.null <- base::is.null
[10:26:24.209]                       muffled <- FALSE
[10:26:24.209]                       if (inherits(cond, "message")) {
[10:26:24.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.209]                         if (muffled) 
[10:26:24.209]                           invokeRestart("muffleMessage")
[10:26:24.209]                       }
[10:26:24.209]                       else if (inherits(cond, "warning")) {
[10:26:24.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.209]                         if (muffled) 
[10:26:24.209]                           invokeRestart("muffleWarning")
[10:26:24.209]                       }
[10:26:24.209]                       else if (inherits(cond, "condition")) {
[10:26:24.209]                         if (!is.null(pattern)) {
[10:26:24.209]                           computeRestarts <- base::computeRestarts
[10:26:24.209]                           grepl <- base::grepl
[10:26:24.209]                           restarts <- computeRestarts(cond)
[10:26:24.209]                           for (restart in restarts) {
[10:26:24.209]                             name <- restart$name
[10:26:24.209]                             if (is.null(name)) 
[10:26:24.209]                               next
[10:26:24.209]                             if (!grepl(pattern, name)) 
[10:26:24.209]                               next
[10:26:24.209]                             invokeRestart(restart)
[10:26:24.209]                             muffled <- TRUE
[10:26:24.209]                             break
[10:26:24.209]                           }
[10:26:24.209]                         }
[10:26:24.209]                       }
[10:26:24.209]                       invisible(muffled)
[10:26:24.209]                     }
[10:26:24.209]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.209]                   }
[10:26:24.209]                 }
[10:26:24.209]                 else {
[10:26:24.209]                   if (TRUE) {
[10:26:24.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.209]                     {
[10:26:24.209]                       inherits <- base::inherits
[10:26:24.209]                       invokeRestart <- base::invokeRestart
[10:26:24.209]                       is.null <- base::is.null
[10:26:24.209]                       muffled <- FALSE
[10:26:24.209]                       if (inherits(cond, "message")) {
[10:26:24.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.209]                         if (muffled) 
[10:26:24.209]                           invokeRestart("muffleMessage")
[10:26:24.209]                       }
[10:26:24.209]                       else if (inherits(cond, "warning")) {
[10:26:24.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.209]                         if (muffled) 
[10:26:24.209]                           invokeRestart("muffleWarning")
[10:26:24.209]                       }
[10:26:24.209]                       else if (inherits(cond, "condition")) {
[10:26:24.209]                         if (!is.null(pattern)) {
[10:26:24.209]                           computeRestarts <- base::computeRestarts
[10:26:24.209]                           grepl <- base::grepl
[10:26:24.209]                           restarts <- computeRestarts(cond)
[10:26:24.209]                           for (restart in restarts) {
[10:26:24.209]                             name <- restart$name
[10:26:24.209]                             if (is.null(name)) 
[10:26:24.209]                               next
[10:26:24.209]                             if (!grepl(pattern, name)) 
[10:26:24.209]                               next
[10:26:24.209]                             invokeRestart(restart)
[10:26:24.209]                             muffled <- TRUE
[10:26:24.209]                             break
[10:26:24.209]                           }
[10:26:24.209]                         }
[10:26:24.209]                       }
[10:26:24.209]                       invisible(muffled)
[10:26:24.209]                     }
[10:26:24.209]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.209]                   }
[10:26:24.209]                 }
[10:26:24.209]             }
[10:26:24.209]         }))
[10:26:24.209]     }, error = function(ex) {
[10:26:24.209]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.209]                 ...future.rng), started = ...future.startTime, 
[10:26:24.209]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.209]             version = "1.8"), class = "FutureResult")
[10:26:24.209]     }, finally = {
[10:26:24.209]         if (!identical(...future.workdir, getwd())) 
[10:26:24.209]             setwd(...future.workdir)
[10:26:24.209]         {
[10:26:24.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.209]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.209]             }
[10:26:24.209]             base::options(...future.oldOptions)
[10:26:24.209]             if (.Platform$OS.type == "windows") {
[10:26:24.209]                 old_names <- names(...future.oldEnvVars)
[10:26:24.209]                 envs <- base::Sys.getenv()
[10:26:24.209]                 names <- names(envs)
[10:26:24.209]                 common <- intersect(names, old_names)
[10:26:24.209]                 added <- setdiff(names, old_names)
[10:26:24.209]                 removed <- setdiff(old_names, names)
[10:26:24.209]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.209]                   envs[common]]
[10:26:24.209]                 NAMES <- toupper(changed)
[10:26:24.209]                 args <- list()
[10:26:24.209]                 for (kk in seq_along(NAMES)) {
[10:26:24.209]                   name <- changed[[kk]]
[10:26:24.209]                   NAME <- NAMES[[kk]]
[10:26:24.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.209]                     next
[10:26:24.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.209]                 }
[10:26:24.209]                 NAMES <- toupper(added)
[10:26:24.209]                 for (kk in seq_along(NAMES)) {
[10:26:24.209]                   name <- added[[kk]]
[10:26:24.209]                   NAME <- NAMES[[kk]]
[10:26:24.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.209]                     next
[10:26:24.209]                   args[[name]] <- ""
[10:26:24.209]                 }
[10:26:24.209]                 NAMES <- toupper(removed)
[10:26:24.209]                 for (kk in seq_along(NAMES)) {
[10:26:24.209]                   name <- removed[[kk]]
[10:26:24.209]                   NAME <- NAMES[[kk]]
[10:26:24.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.209]                     next
[10:26:24.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.209]                 }
[10:26:24.209]                 if (length(args) > 0) 
[10:26:24.209]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.209]             }
[10:26:24.209]             else {
[10:26:24.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.209]             }
[10:26:24.209]             {
[10:26:24.209]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.209]                   0L) {
[10:26:24.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.209]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.209]                   base::options(opts)
[10:26:24.209]                 }
[10:26:24.209]                 {
[10:26:24.209]                   {
[10:26:24.209]                     NULL
[10:26:24.209]                     RNGkind("Mersenne-Twister")
[10:26:24.209]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.209]                       inherits = FALSE)
[10:26:24.209]                   }
[10:26:24.209]                   options(future.plan = NULL)
[10:26:24.209]                   if (is.na(NA_character_)) 
[10:26:24.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.209]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.209]                     envir = parent.frame()) 
[10:26:24.209]                   {
[10:26:24.209]                     default_workers <- missing(workers)
[10:26:24.209]                     if (is.function(workers)) 
[10:26:24.209]                       workers <- workers()
[10:26:24.209]                     workers <- structure(as.integer(workers), 
[10:26:24.209]                       class = class(workers))
[10:26:24.209]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.209]                       1L)
[10:26:24.209]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.209]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.209]                       if (default_workers) 
[10:26:24.209]                         supportsMulticore(warn = TRUE)
[10:26:24.209]                       return(sequential(..., envir = envir))
[10:26:24.209]                     }
[10:26:24.209]                     oopts <- options(mc.cores = workers)
[10:26:24.209]                     on.exit(options(oopts))
[10:26:24.209]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.209]                       envir = envir)
[10:26:24.209]                     if (!future$lazy) 
[10:26:24.209]                       future <- run(future)
[10:26:24.209]                     invisible(future)
[10:26:24.209]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.209]                 }
[10:26:24.209]             }
[10:26:24.209]         }
[10:26:24.209]     })
[10:26:24.209]     if (TRUE) {
[10:26:24.209]         base::sink(type = "output", split = FALSE)
[10:26:24.209]         if (TRUE) {
[10:26:24.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.209]         }
[10:26:24.209]         else {
[10:26:24.209]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.209]         }
[10:26:24.209]         base::close(...future.stdout)
[10:26:24.209]         ...future.stdout <- NULL
[10:26:24.209]     }
[10:26:24.209]     ...future.result$conditions <- ...future.conditions
[10:26:24.209]     ...future.result$finished <- base::Sys.time()
[10:26:24.209]     ...future.result
[10:26:24.209] }
[10:26:24.210] plan(): Setting new future strategy stack:
[10:26:24.211] List of future strategies:
[10:26:24.211] 1. sequential:
[10:26:24.211]    - args: function (..., envir = parent.frame())
[10:26:24.211]    - tweaked: FALSE
[10:26:24.211]    - call: NULL
[10:26:24.211] plan(): nbrOfWorkers() = 1
[10:26:24.212] plan(): Setting new future strategy stack:
[10:26:24.212] List of future strategies:
[10:26:24.212] 1. multicore:
[10:26:24.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.212]    - tweaked: FALSE
[10:26:24.212]    - call: plan(multicore)
[10:26:24.215] plan(): nbrOfWorkers() = 1
[10:26:24.215] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[10:26:24.218] getGlobalsAndPackages() ...
[10:26:24.219] Not searching for globals
[10:26:24.219] - globals: [0] <none>
[10:26:24.219] getGlobalsAndPackages() ... DONE
[10:26:24.219] Packages needed by the future expression (n = 0): <none>
[10:26:24.219] Packages needed by future strategies (n = 0): <none>
[10:26:24.220] {
[10:26:24.220]     {
[10:26:24.220]         {
[10:26:24.220]             ...future.startTime <- base::Sys.time()
[10:26:24.220]             {
[10:26:24.220]                 {
[10:26:24.220]                   {
[10:26:24.220]                     base::local({
[10:26:24.220]                       has_future <- base::requireNamespace("future", 
[10:26:24.220]                         quietly = TRUE)
[10:26:24.220]                       if (has_future) {
[10:26:24.220]                         ns <- base::getNamespace("future")
[10:26:24.220]                         version <- ns[[".package"]][["version"]]
[10:26:24.220]                         if (is.null(version)) 
[10:26:24.220]                           version <- utils::packageVersion("future")
[10:26:24.220]                       }
[10:26:24.220]                       else {
[10:26:24.220]                         version <- NULL
[10:26:24.220]                       }
[10:26:24.220]                       if (!has_future || version < "1.8.0") {
[10:26:24.220]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.220]                           "", base::R.version$version.string), 
[10:26:24.220]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.220]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.220]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.220]                             "release", "version")], collapse = " "), 
[10:26:24.220]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.220]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.220]                           info)
[10:26:24.220]                         info <- base::paste(info, collapse = "; ")
[10:26:24.220]                         if (!has_future) {
[10:26:24.220]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.220]                             info)
[10:26:24.220]                         }
[10:26:24.220]                         else {
[10:26:24.220]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.220]                             info, version)
[10:26:24.220]                         }
[10:26:24.220]                         base::stop(msg)
[10:26:24.220]                       }
[10:26:24.220]                     })
[10:26:24.220]                   }
[10:26:24.220]                   options(future.plan = NULL)
[10:26:24.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.220]                 }
[10:26:24.220]                 ...future.workdir <- getwd()
[10:26:24.220]             }
[10:26:24.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.220]         }
[10:26:24.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.220]             base::names(...future.oldOptions))
[10:26:24.220]     }
[10:26:24.220]     if (FALSE) {
[10:26:24.220]     }
[10:26:24.220]     else {
[10:26:24.220]         if (TRUE) {
[10:26:24.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.220]                 open = "w")
[10:26:24.220]         }
[10:26:24.220]         else {
[10:26:24.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.220]         }
[10:26:24.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.220]             base::sink(type = "output", split = FALSE)
[10:26:24.220]             base::close(...future.stdout)
[10:26:24.220]         }, add = TRUE)
[10:26:24.220]     }
[10:26:24.220]     ...future.frame <- base::sys.nframe()
[10:26:24.220]     ...future.conditions <- base::list()
[10:26:24.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.220]     if (FALSE) {
[10:26:24.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.220]     }
[10:26:24.220]     ...future.result <- base::tryCatch({
[10:26:24.220]         base::withCallingHandlers({
[10:26:24.220]             ...future.value <- base::withVisible(base::local({
[10:26:24.220]                 ii
[10:26:24.220]             }))
[10:26:24.220]             future::FutureResult(value = ...future.value$value, 
[10:26:24.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.220]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.220]                     ...future.globalenv.names))
[10:26:24.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.220]         }, condition = base::local({
[10:26:24.220]             c <- base::c
[10:26:24.220]             inherits <- base::inherits
[10:26:24.220]             invokeRestart <- base::invokeRestart
[10:26:24.220]             length <- base::length
[10:26:24.220]             list <- base::list
[10:26:24.220]             seq.int <- base::seq.int
[10:26:24.220]             signalCondition <- base::signalCondition
[10:26:24.220]             sys.calls <- base::sys.calls
[10:26:24.220]             `[[` <- base::`[[`
[10:26:24.220]             `+` <- base::`+`
[10:26:24.220]             `<<-` <- base::`<<-`
[10:26:24.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.220]                   3L)]
[10:26:24.220]             }
[10:26:24.220]             function(cond) {
[10:26:24.220]                 is_error <- inherits(cond, "error")
[10:26:24.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.220]                   NULL)
[10:26:24.220]                 if (is_error) {
[10:26:24.220]                   sessionInformation <- function() {
[10:26:24.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.220]                       search = base::search(), system = base::Sys.info())
[10:26:24.220]                   }
[10:26:24.220]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.220]                     cond$call), session = sessionInformation(), 
[10:26:24.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.220]                   signalCondition(cond)
[10:26:24.220]                 }
[10:26:24.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.220]                 "immediateCondition"))) {
[10:26:24.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.220]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.220]                   if (TRUE && !signal) {
[10:26:24.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.220]                     {
[10:26:24.220]                       inherits <- base::inherits
[10:26:24.220]                       invokeRestart <- base::invokeRestart
[10:26:24.220]                       is.null <- base::is.null
[10:26:24.220]                       muffled <- FALSE
[10:26:24.220]                       if (inherits(cond, "message")) {
[10:26:24.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.220]                         if (muffled) 
[10:26:24.220]                           invokeRestart("muffleMessage")
[10:26:24.220]                       }
[10:26:24.220]                       else if (inherits(cond, "warning")) {
[10:26:24.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.220]                         if (muffled) 
[10:26:24.220]                           invokeRestart("muffleWarning")
[10:26:24.220]                       }
[10:26:24.220]                       else if (inherits(cond, "condition")) {
[10:26:24.220]                         if (!is.null(pattern)) {
[10:26:24.220]                           computeRestarts <- base::computeRestarts
[10:26:24.220]                           grepl <- base::grepl
[10:26:24.220]                           restarts <- computeRestarts(cond)
[10:26:24.220]                           for (restart in restarts) {
[10:26:24.220]                             name <- restart$name
[10:26:24.220]                             if (is.null(name)) 
[10:26:24.220]                               next
[10:26:24.220]                             if (!grepl(pattern, name)) 
[10:26:24.220]                               next
[10:26:24.220]                             invokeRestart(restart)
[10:26:24.220]                             muffled <- TRUE
[10:26:24.220]                             break
[10:26:24.220]                           }
[10:26:24.220]                         }
[10:26:24.220]                       }
[10:26:24.220]                       invisible(muffled)
[10:26:24.220]                     }
[10:26:24.220]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.220]                   }
[10:26:24.220]                 }
[10:26:24.220]                 else {
[10:26:24.220]                   if (TRUE) {
[10:26:24.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.220]                     {
[10:26:24.220]                       inherits <- base::inherits
[10:26:24.220]                       invokeRestart <- base::invokeRestart
[10:26:24.220]                       is.null <- base::is.null
[10:26:24.220]                       muffled <- FALSE
[10:26:24.220]                       if (inherits(cond, "message")) {
[10:26:24.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.220]                         if (muffled) 
[10:26:24.220]                           invokeRestart("muffleMessage")
[10:26:24.220]                       }
[10:26:24.220]                       else if (inherits(cond, "warning")) {
[10:26:24.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.220]                         if (muffled) 
[10:26:24.220]                           invokeRestart("muffleWarning")
[10:26:24.220]                       }
[10:26:24.220]                       else if (inherits(cond, "condition")) {
[10:26:24.220]                         if (!is.null(pattern)) {
[10:26:24.220]                           computeRestarts <- base::computeRestarts
[10:26:24.220]                           grepl <- base::grepl
[10:26:24.220]                           restarts <- computeRestarts(cond)
[10:26:24.220]                           for (restart in restarts) {
[10:26:24.220]                             name <- restart$name
[10:26:24.220]                             if (is.null(name)) 
[10:26:24.220]                               next
[10:26:24.220]                             if (!grepl(pattern, name)) 
[10:26:24.220]                               next
[10:26:24.220]                             invokeRestart(restart)
[10:26:24.220]                             muffled <- TRUE
[10:26:24.220]                             break
[10:26:24.220]                           }
[10:26:24.220]                         }
[10:26:24.220]                       }
[10:26:24.220]                       invisible(muffled)
[10:26:24.220]                     }
[10:26:24.220]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.220]                   }
[10:26:24.220]                 }
[10:26:24.220]             }
[10:26:24.220]         }))
[10:26:24.220]     }, error = function(ex) {
[10:26:24.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.220]                 ...future.rng), started = ...future.startTime, 
[10:26:24.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.220]             version = "1.8"), class = "FutureResult")
[10:26:24.220]     }, finally = {
[10:26:24.220]         if (!identical(...future.workdir, getwd())) 
[10:26:24.220]             setwd(...future.workdir)
[10:26:24.220]         {
[10:26:24.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.220]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.220]             }
[10:26:24.220]             base::options(...future.oldOptions)
[10:26:24.220]             if (.Platform$OS.type == "windows") {
[10:26:24.220]                 old_names <- names(...future.oldEnvVars)
[10:26:24.220]                 envs <- base::Sys.getenv()
[10:26:24.220]                 names <- names(envs)
[10:26:24.220]                 common <- intersect(names, old_names)
[10:26:24.220]                 added <- setdiff(names, old_names)
[10:26:24.220]                 removed <- setdiff(old_names, names)
[10:26:24.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.220]                   envs[common]]
[10:26:24.220]                 NAMES <- toupper(changed)
[10:26:24.220]                 args <- list()
[10:26:24.220]                 for (kk in seq_along(NAMES)) {
[10:26:24.220]                   name <- changed[[kk]]
[10:26:24.220]                   NAME <- NAMES[[kk]]
[10:26:24.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.220]                     next
[10:26:24.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.220]                 }
[10:26:24.220]                 NAMES <- toupper(added)
[10:26:24.220]                 for (kk in seq_along(NAMES)) {
[10:26:24.220]                   name <- added[[kk]]
[10:26:24.220]                   NAME <- NAMES[[kk]]
[10:26:24.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.220]                     next
[10:26:24.220]                   args[[name]] <- ""
[10:26:24.220]                 }
[10:26:24.220]                 NAMES <- toupper(removed)
[10:26:24.220]                 for (kk in seq_along(NAMES)) {
[10:26:24.220]                   name <- removed[[kk]]
[10:26:24.220]                   NAME <- NAMES[[kk]]
[10:26:24.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.220]                     next
[10:26:24.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.220]                 }
[10:26:24.220]                 if (length(args) > 0) 
[10:26:24.220]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.220]             }
[10:26:24.220]             else {
[10:26:24.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.220]             }
[10:26:24.220]             {
[10:26:24.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.220]                   0L) {
[10:26:24.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.220]                   base::options(opts)
[10:26:24.220]                 }
[10:26:24.220]                 {
[10:26:24.220]                   {
[10:26:24.220]                     NULL
[10:26:24.220]                     RNGkind("Mersenne-Twister")
[10:26:24.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.220]                       inherits = FALSE)
[10:26:24.220]                   }
[10:26:24.220]                   options(future.plan = NULL)
[10:26:24.220]                   if (is.na(NA_character_)) 
[10:26:24.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.220]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.220]                     envir = parent.frame()) 
[10:26:24.220]                   {
[10:26:24.220]                     default_workers <- missing(workers)
[10:26:24.220]                     if (is.function(workers)) 
[10:26:24.220]                       workers <- workers()
[10:26:24.220]                     workers <- structure(as.integer(workers), 
[10:26:24.220]                       class = class(workers))
[10:26:24.220]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.220]                       1L)
[10:26:24.220]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.220]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.220]                       if (default_workers) 
[10:26:24.220]                         supportsMulticore(warn = TRUE)
[10:26:24.220]                       return(sequential(..., envir = envir))
[10:26:24.220]                     }
[10:26:24.220]                     oopts <- options(mc.cores = workers)
[10:26:24.220]                     on.exit(options(oopts))
[10:26:24.220]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.220]                       envir = envir)
[10:26:24.220]                     if (!future$lazy) 
[10:26:24.220]                       future <- run(future)
[10:26:24.220]                     invisible(future)
[10:26:24.220]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.220]                 }
[10:26:24.220]             }
[10:26:24.220]         }
[10:26:24.220]     })
[10:26:24.220]     if (TRUE) {
[10:26:24.220]         base::sink(type = "output", split = FALSE)
[10:26:24.220]         if (TRUE) {
[10:26:24.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.220]         }
[10:26:24.220]         else {
[10:26:24.220]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.220]         }
[10:26:24.220]         base::close(...future.stdout)
[10:26:24.220]         ...future.stdout <- NULL
[10:26:24.220]     }
[10:26:24.220]     ...future.result$conditions <- ...future.conditions
[10:26:24.220]     ...future.result$finished <- base::Sys.time()
[10:26:24.220]     ...future.result
[10:26:24.220] }
[10:26:24.221] plan(): Setting new future strategy stack:
[10:26:24.221] List of future strategies:
[10:26:24.221] 1. sequential:
[10:26:24.221]    - args: function (..., envir = parent.frame())
[10:26:24.221]    - tweaked: FALSE
[10:26:24.221]    - call: NULL
[10:26:24.222] plan(): nbrOfWorkers() = 1
[10:26:24.222] plan(): Setting new future strategy stack:
[10:26:24.223] List of future strategies:
[10:26:24.223] 1. multicore:
[10:26:24.223]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.223]    - tweaked: FALSE
[10:26:24.223]    - call: plan(multicore)
[10:26:24.226] plan(): nbrOfWorkers() = 1
[10:26:24.226] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[10:26:24.230] getGlobalsAndPackages() ...
[10:26:24.230] Not searching for globals
[10:26:24.230] - globals: [0] <none>
[10:26:24.230] getGlobalsAndPackages() ... DONE
[10:26:24.231] Packages needed by the future expression (n = 0): <none>
[10:26:24.231] Packages needed by future strategies (n = 0): <none>
[10:26:24.231] {
[10:26:24.231]     {
[10:26:24.231]         {
[10:26:24.231]             ...future.startTime <- base::Sys.time()
[10:26:24.231]             {
[10:26:24.231]                 {
[10:26:24.231]                   {
[10:26:24.231]                     base::local({
[10:26:24.231]                       has_future <- base::requireNamespace("future", 
[10:26:24.231]                         quietly = TRUE)
[10:26:24.231]                       if (has_future) {
[10:26:24.231]                         ns <- base::getNamespace("future")
[10:26:24.231]                         version <- ns[[".package"]][["version"]]
[10:26:24.231]                         if (is.null(version)) 
[10:26:24.231]                           version <- utils::packageVersion("future")
[10:26:24.231]                       }
[10:26:24.231]                       else {
[10:26:24.231]                         version <- NULL
[10:26:24.231]                       }
[10:26:24.231]                       if (!has_future || version < "1.8.0") {
[10:26:24.231]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.231]                           "", base::R.version$version.string), 
[10:26:24.231]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.231]                             "release", "version")], collapse = " "), 
[10:26:24.231]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.231]                           info)
[10:26:24.231]                         info <- base::paste(info, collapse = "; ")
[10:26:24.231]                         if (!has_future) {
[10:26:24.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.231]                             info)
[10:26:24.231]                         }
[10:26:24.231]                         else {
[10:26:24.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.231]                             info, version)
[10:26:24.231]                         }
[10:26:24.231]                         base::stop(msg)
[10:26:24.231]                       }
[10:26:24.231]                     })
[10:26:24.231]                   }
[10:26:24.231]                   options(future.plan = NULL)
[10:26:24.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.231]                 }
[10:26:24.231]                 ...future.workdir <- getwd()
[10:26:24.231]             }
[10:26:24.231]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.231]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.231]         }
[10:26:24.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.231]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.231]             base::names(...future.oldOptions))
[10:26:24.231]     }
[10:26:24.231]     if (FALSE) {
[10:26:24.231]     }
[10:26:24.231]     else {
[10:26:24.231]         if (TRUE) {
[10:26:24.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.231]                 open = "w")
[10:26:24.231]         }
[10:26:24.231]         else {
[10:26:24.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.231]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.231]         }
[10:26:24.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.231]             base::sink(type = "output", split = FALSE)
[10:26:24.231]             base::close(...future.stdout)
[10:26:24.231]         }, add = TRUE)
[10:26:24.231]     }
[10:26:24.231]     ...future.frame <- base::sys.nframe()
[10:26:24.231]     ...future.conditions <- base::list()
[10:26:24.231]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.231]     if (FALSE) {
[10:26:24.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.231]     }
[10:26:24.231]     ...future.result <- base::tryCatch({
[10:26:24.231]         base::withCallingHandlers({
[10:26:24.231]             ...future.value <- base::withVisible(base::local({
[10:26:24.231]                 stop("Whoops!")
[10:26:24.231]                 1
[10:26:24.231]             }))
[10:26:24.231]             future::FutureResult(value = ...future.value$value, 
[10:26:24.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.231]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.231]                     ...future.globalenv.names))
[10:26:24.231]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.231]         }, condition = base::local({
[10:26:24.231]             c <- base::c
[10:26:24.231]             inherits <- base::inherits
[10:26:24.231]             invokeRestart <- base::invokeRestart
[10:26:24.231]             length <- base::length
[10:26:24.231]             list <- base::list
[10:26:24.231]             seq.int <- base::seq.int
[10:26:24.231]             signalCondition <- base::signalCondition
[10:26:24.231]             sys.calls <- base::sys.calls
[10:26:24.231]             `[[` <- base::`[[`
[10:26:24.231]             `+` <- base::`+`
[10:26:24.231]             `<<-` <- base::`<<-`
[10:26:24.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.231]                   3L)]
[10:26:24.231]             }
[10:26:24.231]             function(cond) {
[10:26:24.231]                 is_error <- inherits(cond, "error")
[10:26:24.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.231]                   NULL)
[10:26:24.231]                 if (is_error) {
[10:26:24.231]                   sessionInformation <- function() {
[10:26:24.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.231]                       search = base::search(), system = base::Sys.info())
[10:26:24.231]                   }
[10:26:24.231]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.231]                     cond$call), session = sessionInformation(), 
[10:26:24.231]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.231]                   signalCondition(cond)
[10:26:24.231]                 }
[10:26:24.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.231]                 "immediateCondition"))) {
[10:26:24.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.231]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.231]                   if (TRUE && !signal) {
[10:26:24.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.231]                     {
[10:26:24.231]                       inherits <- base::inherits
[10:26:24.231]                       invokeRestart <- base::invokeRestart
[10:26:24.231]                       is.null <- base::is.null
[10:26:24.231]                       muffled <- FALSE
[10:26:24.231]                       if (inherits(cond, "message")) {
[10:26:24.231]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.231]                         if (muffled) 
[10:26:24.231]                           invokeRestart("muffleMessage")
[10:26:24.231]                       }
[10:26:24.231]                       else if (inherits(cond, "warning")) {
[10:26:24.231]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.231]                         if (muffled) 
[10:26:24.231]                           invokeRestart("muffleWarning")
[10:26:24.231]                       }
[10:26:24.231]                       else if (inherits(cond, "condition")) {
[10:26:24.231]                         if (!is.null(pattern)) {
[10:26:24.231]                           computeRestarts <- base::computeRestarts
[10:26:24.231]                           grepl <- base::grepl
[10:26:24.231]                           restarts <- computeRestarts(cond)
[10:26:24.231]                           for (restart in restarts) {
[10:26:24.231]                             name <- restart$name
[10:26:24.231]                             if (is.null(name)) 
[10:26:24.231]                               next
[10:26:24.231]                             if (!grepl(pattern, name)) 
[10:26:24.231]                               next
[10:26:24.231]                             invokeRestart(restart)
[10:26:24.231]                             muffled <- TRUE
[10:26:24.231]                             break
[10:26:24.231]                           }
[10:26:24.231]                         }
[10:26:24.231]                       }
[10:26:24.231]                       invisible(muffled)
[10:26:24.231]                     }
[10:26:24.231]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.231]                   }
[10:26:24.231]                 }
[10:26:24.231]                 else {
[10:26:24.231]                   if (TRUE) {
[10:26:24.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.231]                     {
[10:26:24.231]                       inherits <- base::inherits
[10:26:24.231]                       invokeRestart <- base::invokeRestart
[10:26:24.231]                       is.null <- base::is.null
[10:26:24.231]                       muffled <- FALSE
[10:26:24.231]                       if (inherits(cond, "message")) {
[10:26:24.231]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.231]                         if (muffled) 
[10:26:24.231]                           invokeRestart("muffleMessage")
[10:26:24.231]                       }
[10:26:24.231]                       else if (inherits(cond, "warning")) {
[10:26:24.231]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.231]                         if (muffled) 
[10:26:24.231]                           invokeRestart("muffleWarning")
[10:26:24.231]                       }
[10:26:24.231]                       else if (inherits(cond, "condition")) {
[10:26:24.231]                         if (!is.null(pattern)) {
[10:26:24.231]                           computeRestarts <- base::computeRestarts
[10:26:24.231]                           grepl <- base::grepl
[10:26:24.231]                           restarts <- computeRestarts(cond)
[10:26:24.231]                           for (restart in restarts) {
[10:26:24.231]                             name <- restart$name
[10:26:24.231]                             if (is.null(name)) 
[10:26:24.231]                               next
[10:26:24.231]                             if (!grepl(pattern, name)) 
[10:26:24.231]                               next
[10:26:24.231]                             invokeRestart(restart)
[10:26:24.231]                             muffled <- TRUE
[10:26:24.231]                             break
[10:26:24.231]                           }
[10:26:24.231]                         }
[10:26:24.231]                       }
[10:26:24.231]                       invisible(muffled)
[10:26:24.231]                     }
[10:26:24.231]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.231]                   }
[10:26:24.231]                 }
[10:26:24.231]             }
[10:26:24.231]         }))
[10:26:24.231]     }, error = function(ex) {
[10:26:24.231]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.231]                 ...future.rng), started = ...future.startTime, 
[10:26:24.231]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.231]             version = "1.8"), class = "FutureResult")
[10:26:24.231]     }, finally = {
[10:26:24.231]         if (!identical(...future.workdir, getwd())) 
[10:26:24.231]             setwd(...future.workdir)
[10:26:24.231]         {
[10:26:24.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.231]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.231]             }
[10:26:24.231]             base::options(...future.oldOptions)
[10:26:24.231]             if (.Platform$OS.type == "windows") {
[10:26:24.231]                 old_names <- names(...future.oldEnvVars)
[10:26:24.231]                 envs <- base::Sys.getenv()
[10:26:24.231]                 names <- names(envs)
[10:26:24.231]                 common <- intersect(names, old_names)
[10:26:24.231]                 added <- setdiff(names, old_names)
[10:26:24.231]                 removed <- setdiff(old_names, names)
[10:26:24.231]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.231]                   envs[common]]
[10:26:24.231]                 NAMES <- toupper(changed)
[10:26:24.231]                 args <- list()
[10:26:24.231]                 for (kk in seq_along(NAMES)) {
[10:26:24.231]                   name <- changed[[kk]]
[10:26:24.231]                   NAME <- NAMES[[kk]]
[10:26:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.231]                     next
[10:26:24.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.231]                 }
[10:26:24.231]                 NAMES <- toupper(added)
[10:26:24.231]                 for (kk in seq_along(NAMES)) {
[10:26:24.231]                   name <- added[[kk]]
[10:26:24.231]                   NAME <- NAMES[[kk]]
[10:26:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.231]                     next
[10:26:24.231]                   args[[name]] <- ""
[10:26:24.231]                 }
[10:26:24.231]                 NAMES <- toupper(removed)
[10:26:24.231]                 for (kk in seq_along(NAMES)) {
[10:26:24.231]                   name <- removed[[kk]]
[10:26:24.231]                   NAME <- NAMES[[kk]]
[10:26:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.231]                     next
[10:26:24.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.231]                 }
[10:26:24.231]                 if (length(args) > 0) 
[10:26:24.231]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.231]             }
[10:26:24.231]             else {
[10:26:24.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.231]             }
[10:26:24.231]             {
[10:26:24.231]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.231]                   0L) {
[10:26:24.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.231]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.231]                   base::options(opts)
[10:26:24.231]                 }
[10:26:24.231]                 {
[10:26:24.231]                   {
[10:26:24.231]                     NULL
[10:26:24.231]                     RNGkind("Mersenne-Twister")
[10:26:24.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.231]                       inherits = FALSE)
[10:26:24.231]                   }
[10:26:24.231]                   options(future.plan = NULL)
[10:26:24.231]                   if (is.na(NA_character_)) 
[10:26:24.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.231]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.231]                     envir = parent.frame()) 
[10:26:24.231]                   {
[10:26:24.231]                     default_workers <- missing(workers)
[10:26:24.231]                     if (is.function(workers)) 
[10:26:24.231]                       workers <- workers()
[10:26:24.231]                     workers <- structure(as.integer(workers), 
[10:26:24.231]                       class = class(workers))
[10:26:24.231]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.231]                       1L)
[10:26:24.231]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.231]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.231]                       if (default_workers) 
[10:26:24.231]                         supportsMulticore(warn = TRUE)
[10:26:24.231]                       return(sequential(..., envir = envir))
[10:26:24.231]                     }
[10:26:24.231]                     oopts <- options(mc.cores = workers)
[10:26:24.231]                     on.exit(options(oopts))
[10:26:24.231]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.231]                       envir = envir)
[10:26:24.231]                     if (!future$lazy) 
[10:26:24.231]                       future <- run(future)
[10:26:24.231]                     invisible(future)
[10:26:24.231]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.231]                 }
[10:26:24.231]             }
[10:26:24.231]         }
[10:26:24.231]     })
[10:26:24.231]     if (TRUE) {
[10:26:24.231]         base::sink(type = "output", split = FALSE)
[10:26:24.231]         if (TRUE) {
[10:26:24.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.231]         }
[10:26:24.231]         else {
[10:26:24.231]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.231]         }
[10:26:24.231]         base::close(...future.stdout)
[10:26:24.231]         ...future.stdout <- NULL
[10:26:24.231]     }
[10:26:24.231]     ...future.result$conditions <- ...future.conditions
[10:26:24.231]     ...future.result$finished <- base::Sys.time()
[10:26:24.231]     ...future.result
[10:26:24.231] }
[10:26:24.233] plan(): Setting new future strategy stack:
[10:26:24.233] List of future strategies:
[10:26:24.233] 1. sequential:
[10:26:24.233]    - args: function (..., envir = parent.frame())
[10:26:24.233]    - tweaked: FALSE
[10:26:24.233]    - call: NULL
[10:26:24.233] plan(): nbrOfWorkers() = 1
[10:26:24.234] plan(): Setting new future strategy stack:
[10:26:24.234] List of future strategies:
[10:26:24.234] 1. multicore:
[10:26:24.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.234]    - tweaked: FALSE
[10:26:24.234]    - call: plan(multicore)
[10:26:24.238] plan(): nbrOfWorkers() = 1
[10:26:24.238] SequentialFuture started (and completed)
[10:26:24.238] signalConditions() ...
[10:26:24.238]  - include = ‘immediateCondition’
[10:26:24.238]  - exclude = 
[10:26:24.238]  - resignal = FALSE
[10:26:24.238]  - Number of conditions: 1
[10:26:24.238] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:24.239] signalConditions() ...
[10:26:24.239]  - include = ‘immediateCondition’
[10:26:24.239]  - exclude = 
[10:26:24.239]  - resignal = FALSE
[10:26:24.239]  - Number of conditions: 1
[10:26:24.239] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.240] signalConditions() ...
[10:26:24.240]  - include = ‘immediateCondition’
[10:26:24.240]  - exclude = 
[10:26:24.240]  - resignal = FALSE
[10:26:24.240]  - Number of conditions: 1
[10:26:24.240] signalConditions() ... done
[10:26:24.240] Future state: ‘finished’
[10:26:24.240] signalConditions() ...
[10:26:24.240]  - include = ‘condition’
[10:26:24.241]  - exclude = ‘immediateCondition’
[10:26:24.241]  - resignal = TRUE
[10:26:24.241]  - Number of conditions: 1
[10:26:24.241]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.241] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.241] signalConditions() ...
[10:26:24.241]  - include = ‘immediateCondition’
[10:26:24.242]  - exclude = 
[10:26:24.242]  - resignal = FALSE
[10:26:24.242]  - Number of conditions: 1
[10:26:24.242] signalConditions() ... done
[10:26:24.242] Future state: ‘finished’
[10:26:24.242] signalConditions() ...
[10:26:24.242]  - include = ‘condition’
[10:26:24.242]  - exclude = ‘immediateCondition’
[10:26:24.242]  - resignal = TRUE
[10:26:24.242]  - Number of conditions: 1
[10:26:24.242]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.243] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.246] getGlobalsAndPackages() ...
[10:26:24.246] Searching for globals...
[10:26:24.254] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:26:24.255] Searching for globals ... DONE
[10:26:24.255] Resolving globals: FALSE
[10:26:24.255] 
[10:26:24.255] 
[10:26:24.256] getGlobalsAndPackages() ... DONE
[10:26:24.256] Packages needed by the future expression (n = 0): <none>
[10:26:24.256] Packages needed by future strategies (n = 0): <none>
[10:26:24.256] {
[10:26:24.256]     {
[10:26:24.256]         {
[10:26:24.256]             ...future.startTime <- base::Sys.time()
[10:26:24.256]             {
[10:26:24.256]                 {
[10:26:24.256]                   {
[10:26:24.256]                     base::local({
[10:26:24.256]                       has_future <- base::requireNamespace("future", 
[10:26:24.256]                         quietly = TRUE)
[10:26:24.256]                       if (has_future) {
[10:26:24.256]                         ns <- base::getNamespace("future")
[10:26:24.256]                         version <- ns[[".package"]][["version"]]
[10:26:24.256]                         if (is.null(version)) 
[10:26:24.256]                           version <- utils::packageVersion("future")
[10:26:24.256]                       }
[10:26:24.256]                       else {
[10:26:24.256]                         version <- NULL
[10:26:24.256]                       }
[10:26:24.256]                       if (!has_future || version < "1.8.0") {
[10:26:24.256]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.256]                           "", base::R.version$version.string), 
[10:26:24.256]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.256]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.256]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.256]                             "release", "version")], collapse = " "), 
[10:26:24.256]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.256]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.256]                           info)
[10:26:24.256]                         info <- base::paste(info, collapse = "; ")
[10:26:24.256]                         if (!has_future) {
[10:26:24.256]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.256]                             info)
[10:26:24.256]                         }
[10:26:24.256]                         else {
[10:26:24.256]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.256]                             info, version)
[10:26:24.256]                         }
[10:26:24.256]                         base::stop(msg)
[10:26:24.256]                       }
[10:26:24.256]                     })
[10:26:24.256]                   }
[10:26:24.256]                   options(future.plan = NULL)
[10:26:24.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.256]                 }
[10:26:24.256]                 ...future.workdir <- getwd()
[10:26:24.256]             }
[10:26:24.256]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.256]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.256]         }
[10:26:24.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.256]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.256]             base::names(...future.oldOptions))
[10:26:24.256]     }
[10:26:24.256]     if (FALSE) {
[10:26:24.256]     }
[10:26:24.256]     else {
[10:26:24.256]         if (TRUE) {
[10:26:24.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.256]                 open = "w")
[10:26:24.256]         }
[10:26:24.256]         else {
[10:26:24.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.256]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.256]         }
[10:26:24.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.256]             base::sink(type = "output", split = FALSE)
[10:26:24.256]             base::close(...future.stdout)
[10:26:24.256]         }, add = TRUE)
[10:26:24.256]     }
[10:26:24.256]     ...future.frame <- base::sys.nframe()
[10:26:24.256]     ...future.conditions <- base::list()
[10:26:24.256]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.256]     if (FALSE) {
[10:26:24.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.256]     }
[10:26:24.256]     ...future.result <- base::tryCatch({
[10:26:24.256]         base::withCallingHandlers({
[10:26:24.256]             ...future.value <- base::withVisible(base::local({
[10:26:24.256]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:24.256]                   "error", "condition")))
[10:26:24.256]             }))
[10:26:24.256]             future::FutureResult(value = ...future.value$value, 
[10:26:24.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.256]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.256]                     ...future.globalenv.names))
[10:26:24.256]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.256]         }, condition = base::local({
[10:26:24.256]             c <- base::c
[10:26:24.256]             inherits <- base::inherits
[10:26:24.256]             invokeRestart <- base::invokeRestart
[10:26:24.256]             length <- base::length
[10:26:24.256]             list <- base::list
[10:26:24.256]             seq.int <- base::seq.int
[10:26:24.256]             signalCondition <- base::signalCondition
[10:26:24.256]             sys.calls <- base::sys.calls
[10:26:24.256]             `[[` <- base::`[[`
[10:26:24.256]             `+` <- base::`+`
[10:26:24.256]             `<<-` <- base::`<<-`
[10:26:24.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.256]                   3L)]
[10:26:24.256]             }
[10:26:24.256]             function(cond) {
[10:26:24.256]                 is_error <- inherits(cond, "error")
[10:26:24.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.256]                   NULL)
[10:26:24.256]                 if (is_error) {
[10:26:24.256]                   sessionInformation <- function() {
[10:26:24.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.256]                       search = base::search(), system = base::Sys.info())
[10:26:24.256]                   }
[10:26:24.256]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.256]                     cond$call), session = sessionInformation(), 
[10:26:24.256]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.256]                   signalCondition(cond)
[10:26:24.256]                 }
[10:26:24.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.256]                 "immediateCondition"))) {
[10:26:24.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.256]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.256]                   if (TRUE && !signal) {
[10:26:24.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.256]                     {
[10:26:24.256]                       inherits <- base::inherits
[10:26:24.256]                       invokeRestart <- base::invokeRestart
[10:26:24.256]                       is.null <- base::is.null
[10:26:24.256]                       muffled <- FALSE
[10:26:24.256]                       if (inherits(cond, "message")) {
[10:26:24.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.256]                         if (muffled) 
[10:26:24.256]                           invokeRestart("muffleMessage")
[10:26:24.256]                       }
[10:26:24.256]                       else if (inherits(cond, "warning")) {
[10:26:24.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.256]                         if (muffled) 
[10:26:24.256]                           invokeRestart("muffleWarning")
[10:26:24.256]                       }
[10:26:24.256]                       else if (inherits(cond, "condition")) {
[10:26:24.256]                         if (!is.null(pattern)) {
[10:26:24.256]                           computeRestarts <- base::computeRestarts
[10:26:24.256]                           grepl <- base::grepl
[10:26:24.256]                           restarts <- computeRestarts(cond)
[10:26:24.256]                           for (restart in restarts) {
[10:26:24.256]                             name <- restart$name
[10:26:24.256]                             if (is.null(name)) 
[10:26:24.256]                               next
[10:26:24.256]                             if (!grepl(pattern, name)) 
[10:26:24.256]                               next
[10:26:24.256]                             invokeRestart(restart)
[10:26:24.256]                             muffled <- TRUE
[10:26:24.256]                             break
[10:26:24.256]                           }
[10:26:24.256]                         }
[10:26:24.256]                       }
[10:26:24.256]                       invisible(muffled)
[10:26:24.256]                     }
[10:26:24.256]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.256]                   }
[10:26:24.256]                 }
[10:26:24.256]                 else {
[10:26:24.256]                   if (TRUE) {
[10:26:24.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.256]                     {
[10:26:24.256]                       inherits <- base::inherits
[10:26:24.256]                       invokeRestart <- base::invokeRestart
[10:26:24.256]                       is.null <- base::is.null
[10:26:24.256]                       muffled <- FALSE
[10:26:24.256]                       if (inherits(cond, "message")) {
[10:26:24.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.256]                         if (muffled) 
[10:26:24.256]                           invokeRestart("muffleMessage")
[10:26:24.256]                       }
[10:26:24.256]                       else if (inherits(cond, "warning")) {
[10:26:24.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.256]                         if (muffled) 
[10:26:24.256]                           invokeRestart("muffleWarning")
[10:26:24.256]                       }
[10:26:24.256]                       else if (inherits(cond, "condition")) {
[10:26:24.256]                         if (!is.null(pattern)) {
[10:26:24.256]                           computeRestarts <- base::computeRestarts
[10:26:24.256]                           grepl <- base::grepl
[10:26:24.256]                           restarts <- computeRestarts(cond)
[10:26:24.256]                           for (restart in restarts) {
[10:26:24.256]                             name <- restart$name
[10:26:24.256]                             if (is.null(name)) 
[10:26:24.256]                               next
[10:26:24.256]                             if (!grepl(pattern, name)) 
[10:26:24.256]                               next
[10:26:24.256]                             invokeRestart(restart)
[10:26:24.256]                             muffled <- TRUE
[10:26:24.256]                             break
[10:26:24.256]                           }
[10:26:24.256]                         }
[10:26:24.256]                       }
[10:26:24.256]                       invisible(muffled)
[10:26:24.256]                     }
[10:26:24.256]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.256]                   }
[10:26:24.256]                 }
[10:26:24.256]             }
[10:26:24.256]         }))
[10:26:24.256]     }, error = function(ex) {
[10:26:24.256]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.256]                 ...future.rng), started = ...future.startTime, 
[10:26:24.256]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.256]             version = "1.8"), class = "FutureResult")
[10:26:24.256]     }, finally = {
[10:26:24.256]         if (!identical(...future.workdir, getwd())) 
[10:26:24.256]             setwd(...future.workdir)
[10:26:24.256]         {
[10:26:24.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.256]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.256]             }
[10:26:24.256]             base::options(...future.oldOptions)
[10:26:24.256]             if (.Platform$OS.type == "windows") {
[10:26:24.256]                 old_names <- names(...future.oldEnvVars)
[10:26:24.256]                 envs <- base::Sys.getenv()
[10:26:24.256]                 names <- names(envs)
[10:26:24.256]                 common <- intersect(names, old_names)
[10:26:24.256]                 added <- setdiff(names, old_names)
[10:26:24.256]                 removed <- setdiff(old_names, names)
[10:26:24.256]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.256]                   envs[common]]
[10:26:24.256]                 NAMES <- toupper(changed)
[10:26:24.256]                 args <- list()
[10:26:24.256]                 for (kk in seq_along(NAMES)) {
[10:26:24.256]                   name <- changed[[kk]]
[10:26:24.256]                   NAME <- NAMES[[kk]]
[10:26:24.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.256]                     next
[10:26:24.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.256]                 }
[10:26:24.256]                 NAMES <- toupper(added)
[10:26:24.256]                 for (kk in seq_along(NAMES)) {
[10:26:24.256]                   name <- added[[kk]]
[10:26:24.256]                   NAME <- NAMES[[kk]]
[10:26:24.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.256]                     next
[10:26:24.256]                   args[[name]] <- ""
[10:26:24.256]                 }
[10:26:24.256]                 NAMES <- toupper(removed)
[10:26:24.256]                 for (kk in seq_along(NAMES)) {
[10:26:24.256]                   name <- removed[[kk]]
[10:26:24.256]                   NAME <- NAMES[[kk]]
[10:26:24.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.256]                     next
[10:26:24.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.256]                 }
[10:26:24.256]                 if (length(args) > 0) 
[10:26:24.256]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.256]             }
[10:26:24.256]             else {
[10:26:24.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.256]             }
[10:26:24.256]             {
[10:26:24.256]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.256]                   0L) {
[10:26:24.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.256]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.256]                   base::options(opts)
[10:26:24.256]                 }
[10:26:24.256]                 {
[10:26:24.256]                   {
[10:26:24.256]                     NULL
[10:26:24.256]                     RNGkind("Mersenne-Twister")
[10:26:24.256]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.256]                       inherits = FALSE)
[10:26:24.256]                   }
[10:26:24.256]                   options(future.plan = NULL)
[10:26:24.256]                   if (is.na(NA_character_)) 
[10:26:24.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.256]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.256]                     envir = parent.frame()) 
[10:26:24.256]                   {
[10:26:24.256]                     default_workers <- missing(workers)
[10:26:24.256]                     if (is.function(workers)) 
[10:26:24.256]                       workers <- workers()
[10:26:24.256]                     workers <- structure(as.integer(workers), 
[10:26:24.256]                       class = class(workers))
[10:26:24.256]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.256]                       1L)
[10:26:24.256]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.256]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.256]                       if (default_workers) 
[10:26:24.256]                         supportsMulticore(warn = TRUE)
[10:26:24.256]                       return(sequential(..., envir = envir))
[10:26:24.256]                     }
[10:26:24.256]                     oopts <- options(mc.cores = workers)
[10:26:24.256]                     on.exit(options(oopts))
[10:26:24.256]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.256]                       envir = envir)
[10:26:24.256]                     if (!future$lazy) 
[10:26:24.256]                       future <- run(future)
[10:26:24.256]                     invisible(future)
[10:26:24.256]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.256]                 }
[10:26:24.256]             }
[10:26:24.256]         }
[10:26:24.256]     })
[10:26:24.256]     if (TRUE) {
[10:26:24.256]         base::sink(type = "output", split = FALSE)
[10:26:24.256]         if (TRUE) {
[10:26:24.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.256]         }
[10:26:24.256]         else {
[10:26:24.256]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.256]         }
[10:26:24.256]         base::close(...future.stdout)
[10:26:24.256]         ...future.stdout <- NULL
[10:26:24.256]     }
[10:26:24.256]     ...future.result$conditions <- ...future.conditions
[10:26:24.256]     ...future.result$finished <- base::Sys.time()
[10:26:24.256]     ...future.result
[10:26:24.256] }
[10:26:24.258] plan(): Setting new future strategy stack:
[10:26:24.258] List of future strategies:
[10:26:24.258] 1. sequential:
[10:26:24.258]    - args: function (..., envir = parent.frame())
[10:26:24.258]    - tweaked: FALSE
[10:26:24.258]    - call: NULL
[10:26:24.259] plan(): nbrOfWorkers() = 1
[10:26:24.259] plan(): Setting new future strategy stack:
[10:26:24.259] List of future strategies:
[10:26:24.259] 1. multicore:
[10:26:24.259]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.259]    - tweaked: FALSE
[10:26:24.259]    - call: plan(multicore)
[10:26:24.263] plan(): nbrOfWorkers() = 1
[10:26:24.263] SequentialFuture started (and completed)
[10:26:24.263] signalConditions() ...
[10:26:24.263]  - include = ‘immediateCondition’
[10:26:24.263]  - exclude = 
[10:26:24.263]  - resignal = FALSE
[10:26:24.263]  - Number of conditions: 1
[10:26:24.264] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:24.264] signalConditions() ...
[10:26:24.264]  - include = ‘immediateCondition’
[10:26:24.264]  - exclude = 
[10:26:24.264]  - resignal = FALSE
[10:26:24.264]  - Number of conditions: 1
[10:26:24.265] signalConditions() ... done
<MyError: boom>
[10:26:24.265] signalConditions() ...
[10:26:24.265]  - include = ‘immediateCondition’
[10:26:24.265]  - exclude = 
[10:26:24.265]  - resignal = FALSE
[10:26:24.265]  - Number of conditions: 1
[10:26:24.265] signalConditions() ... done
[10:26:24.265] Future state: ‘finished’
[10:26:24.265] signalConditions() ...
[10:26:24.266]  - include = ‘condition’
[10:26:24.266]  - exclude = ‘immediateCondition’
[10:26:24.266]  - resignal = TRUE
[10:26:24.266]  - Number of conditions: 1
[10:26:24.266]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:24.266] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[10:26:24.269] getGlobalsAndPackages() ...
[10:26:24.269] Searching for globals...
[10:26:24.270] - globals found: [1] ‘{’
[10:26:24.270] Searching for globals ... DONE
[10:26:24.270] Resolving globals: FALSE
[10:26:24.270] 
[10:26:24.270] 
[10:26:24.270] getGlobalsAndPackages() ... DONE
[10:26:24.271] Packages needed by the future expression (n = 0): <none>
[10:26:24.271] Packages needed by future strategies (n = 0): <none>
[10:26:24.271] {
[10:26:24.271]     {
[10:26:24.271]         {
[10:26:24.271]             ...future.startTime <- base::Sys.time()
[10:26:24.271]             {
[10:26:24.271]                 {
[10:26:24.271]                   {
[10:26:24.271]                     base::local({
[10:26:24.271]                       has_future <- base::requireNamespace("future", 
[10:26:24.271]                         quietly = TRUE)
[10:26:24.271]                       if (has_future) {
[10:26:24.271]                         ns <- base::getNamespace("future")
[10:26:24.271]                         version <- ns[[".package"]][["version"]]
[10:26:24.271]                         if (is.null(version)) 
[10:26:24.271]                           version <- utils::packageVersion("future")
[10:26:24.271]                       }
[10:26:24.271]                       else {
[10:26:24.271]                         version <- NULL
[10:26:24.271]                       }
[10:26:24.271]                       if (!has_future || version < "1.8.0") {
[10:26:24.271]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.271]                           "", base::R.version$version.string), 
[10:26:24.271]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.271]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.271]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.271]                             "release", "version")], collapse = " "), 
[10:26:24.271]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.271]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.271]                           info)
[10:26:24.271]                         info <- base::paste(info, collapse = "; ")
[10:26:24.271]                         if (!has_future) {
[10:26:24.271]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.271]                             info)
[10:26:24.271]                         }
[10:26:24.271]                         else {
[10:26:24.271]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.271]                             info, version)
[10:26:24.271]                         }
[10:26:24.271]                         base::stop(msg)
[10:26:24.271]                       }
[10:26:24.271]                     })
[10:26:24.271]                   }
[10:26:24.271]                   options(future.plan = NULL)
[10:26:24.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.271]                 }
[10:26:24.271]                 ...future.workdir <- getwd()
[10:26:24.271]             }
[10:26:24.271]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.271]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.271]         }
[10:26:24.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.271]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.271]             base::names(...future.oldOptions))
[10:26:24.271]     }
[10:26:24.271]     if (FALSE) {
[10:26:24.271]     }
[10:26:24.271]     else {
[10:26:24.271]         if (TRUE) {
[10:26:24.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.271]                 open = "w")
[10:26:24.271]         }
[10:26:24.271]         else {
[10:26:24.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.271]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.271]         }
[10:26:24.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.271]             base::sink(type = "output", split = FALSE)
[10:26:24.271]             base::close(...future.stdout)
[10:26:24.271]         }, add = TRUE)
[10:26:24.271]     }
[10:26:24.271]     ...future.frame <- base::sys.nframe()
[10:26:24.271]     ...future.conditions <- base::list()
[10:26:24.271]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.271]     if (FALSE) {
[10:26:24.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.271]     }
[10:26:24.271]     ...future.result <- base::tryCatch({
[10:26:24.271]         base::withCallingHandlers({
[10:26:24.271]             ...future.value <- base::withVisible(base::local({
[10:26:24.271]                 42L
[10:26:24.271]             }))
[10:26:24.271]             future::FutureResult(value = ...future.value$value, 
[10:26:24.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.271]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.271]                     ...future.globalenv.names))
[10:26:24.271]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.271]         }, condition = base::local({
[10:26:24.271]             c <- base::c
[10:26:24.271]             inherits <- base::inherits
[10:26:24.271]             invokeRestart <- base::invokeRestart
[10:26:24.271]             length <- base::length
[10:26:24.271]             list <- base::list
[10:26:24.271]             seq.int <- base::seq.int
[10:26:24.271]             signalCondition <- base::signalCondition
[10:26:24.271]             sys.calls <- base::sys.calls
[10:26:24.271]             `[[` <- base::`[[`
[10:26:24.271]             `+` <- base::`+`
[10:26:24.271]             `<<-` <- base::`<<-`
[10:26:24.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.271]                   3L)]
[10:26:24.271]             }
[10:26:24.271]             function(cond) {
[10:26:24.271]                 is_error <- inherits(cond, "error")
[10:26:24.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.271]                   NULL)
[10:26:24.271]                 if (is_error) {
[10:26:24.271]                   sessionInformation <- function() {
[10:26:24.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.271]                       search = base::search(), system = base::Sys.info())
[10:26:24.271]                   }
[10:26:24.271]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.271]                     cond$call), session = sessionInformation(), 
[10:26:24.271]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.271]                   signalCondition(cond)
[10:26:24.271]                 }
[10:26:24.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.271]                 "immediateCondition"))) {
[10:26:24.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.271]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.271]                   if (TRUE && !signal) {
[10:26:24.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.271]                     {
[10:26:24.271]                       inherits <- base::inherits
[10:26:24.271]                       invokeRestart <- base::invokeRestart
[10:26:24.271]                       is.null <- base::is.null
[10:26:24.271]                       muffled <- FALSE
[10:26:24.271]                       if (inherits(cond, "message")) {
[10:26:24.271]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.271]                         if (muffled) 
[10:26:24.271]                           invokeRestart("muffleMessage")
[10:26:24.271]                       }
[10:26:24.271]                       else if (inherits(cond, "warning")) {
[10:26:24.271]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.271]                         if (muffled) 
[10:26:24.271]                           invokeRestart("muffleWarning")
[10:26:24.271]                       }
[10:26:24.271]                       else if (inherits(cond, "condition")) {
[10:26:24.271]                         if (!is.null(pattern)) {
[10:26:24.271]                           computeRestarts <- base::computeRestarts
[10:26:24.271]                           grepl <- base::grepl
[10:26:24.271]                           restarts <- computeRestarts(cond)
[10:26:24.271]                           for (restart in restarts) {
[10:26:24.271]                             name <- restart$name
[10:26:24.271]                             if (is.null(name)) 
[10:26:24.271]                               next
[10:26:24.271]                             if (!grepl(pattern, name)) 
[10:26:24.271]                               next
[10:26:24.271]                             invokeRestart(restart)
[10:26:24.271]                             muffled <- TRUE
[10:26:24.271]                             break
[10:26:24.271]                           }
[10:26:24.271]                         }
[10:26:24.271]                       }
[10:26:24.271]                       invisible(muffled)
[10:26:24.271]                     }
[10:26:24.271]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.271]                   }
[10:26:24.271]                 }
[10:26:24.271]                 else {
[10:26:24.271]                   if (TRUE) {
[10:26:24.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.271]                     {
[10:26:24.271]                       inherits <- base::inherits
[10:26:24.271]                       invokeRestart <- base::invokeRestart
[10:26:24.271]                       is.null <- base::is.null
[10:26:24.271]                       muffled <- FALSE
[10:26:24.271]                       if (inherits(cond, "message")) {
[10:26:24.271]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.271]                         if (muffled) 
[10:26:24.271]                           invokeRestart("muffleMessage")
[10:26:24.271]                       }
[10:26:24.271]                       else if (inherits(cond, "warning")) {
[10:26:24.271]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.271]                         if (muffled) 
[10:26:24.271]                           invokeRestart("muffleWarning")
[10:26:24.271]                       }
[10:26:24.271]                       else if (inherits(cond, "condition")) {
[10:26:24.271]                         if (!is.null(pattern)) {
[10:26:24.271]                           computeRestarts <- base::computeRestarts
[10:26:24.271]                           grepl <- base::grepl
[10:26:24.271]                           restarts <- computeRestarts(cond)
[10:26:24.271]                           for (restart in restarts) {
[10:26:24.271]                             name <- restart$name
[10:26:24.271]                             if (is.null(name)) 
[10:26:24.271]                               next
[10:26:24.271]                             if (!grepl(pattern, name)) 
[10:26:24.271]                               next
[10:26:24.271]                             invokeRestart(restart)
[10:26:24.271]                             muffled <- TRUE
[10:26:24.271]                             break
[10:26:24.271]                           }
[10:26:24.271]                         }
[10:26:24.271]                       }
[10:26:24.271]                       invisible(muffled)
[10:26:24.271]                     }
[10:26:24.271]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.271]                   }
[10:26:24.271]                 }
[10:26:24.271]             }
[10:26:24.271]         }))
[10:26:24.271]     }, error = function(ex) {
[10:26:24.271]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.271]                 ...future.rng), started = ...future.startTime, 
[10:26:24.271]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.271]             version = "1.8"), class = "FutureResult")
[10:26:24.271]     }, finally = {
[10:26:24.271]         if (!identical(...future.workdir, getwd())) 
[10:26:24.271]             setwd(...future.workdir)
[10:26:24.271]         {
[10:26:24.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.271]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.271]             }
[10:26:24.271]             base::options(...future.oldOptions)
[10:26:24.271]             if (.Platform$OS.type == "windows") {
[10:26:24.271]                 old_names <- names(...future.oldEnvVars)
[10:26:24.271]                 envs <- base::Sys.getenv()
[10:26:24.271]                 names <- names(envs)
[10:26:24.271]                 common <- intersect(names, old_names)
[10:26:24.271]                 added <- setdiff(names, old_names)
[10:26:24.271]                 removed <- setdiff(old_names, names)
[10:26:24.271]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.271]                   envs[common]]
[10:26:24.271]                 NAMES <- toupper(changed)
[10:26:24.271]                 args <- list()
[10:26:24.271]                 for (kk in seq_along(NAMES)) {
[10:26:24.271]                   name <- changed[[kk]]
[10:26:24.271]                   NAME <- NAMES[[kk]]
[10:26:24.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.271]                     next
[10:26:24.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.271]                 }
[10:26:24.271]                 NAMES <- toupper(added)
[10:26:24.271]                 for (kk in seq_along(NAMES)) {
[10:26:24.271]                   name <- added[[kk]]
[10:26:24.271]                   NAME <- NAMES[[kk]]
[10:26:24.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.271]                     next
[10:26:24.271]                   args[[name]] <- ""
[10:26:24.271]                 }
[10:26:24.271]                 NAMES <- toupper(removed)
[10:26:24.271]                 for (kk in seq_along(NAMES)) {
[10:26:24.271]                   name <- removed[[kk]]
[10:26:24.271]                   NAME <- NAMES[[kk]]
[10:26:24.271]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.271]                     next
[10:26:24.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.271]                 }
[10:26:24.271]                 if (length(args) > 0) 
[10:26:24.271]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.271]             }
[10:26:24.271]             else {
[10:26:24.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.271]             }
[10:26:24.271]             {
[10:26:24.271]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.271]                   0L) {
[10:26:24.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.271]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.271]                   base::options(opts)
[10:26:24.271]                 }
[10:26:24.271]                 {
[10:26:24.271]                   {
[10:26:24.271]                     NULL
[10:26:24.271]                     RNGkind("Mersenne-Twister")
[10:26:24.271]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.271]                       inherits = FALSE)
[10:26:24.271]                   }
[10:26:24.271]                   options(future.plan = NULL)
[10:26:24.271]                   if (is.na(NA_character_)) 
[10:26:24.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.271]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.271]                     envir = parent.frame()) 
[10:26:24.271]                   {
[10:26:24.271]                     default_workers <- missing(workers)
[10:26:24.271]                     if (is.function(workers)) 
[10:26:24.271]                       workers <- workers()
[10:26:24.271]                     workers <- structure(as.integer(workers), 
[10:26:24.271]                       class = class(workers))
[10:26:24.271]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.271]                       1L)
[10:26:24.271]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.271]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.271]                       if (default_workers) 
[10:26:24.271]                         supportsMulticore(warn = TRUE)
[10:26:24.271]                       return(sequential(..., envir = envir))
[10:26:24.271]                     }
[10:26:24.271]                     oopts <- options(mc.cores = workers)
[10:26:24.271]                     on.exit(options(oopts))
[10:26:24.271]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.271]                       envir = envir)
[10:26:24.271]                     if (!future$lazy) 
[10:26:24.271]                       future <- run(future)
[10:26:24.271]                     invisible(future)
[10:26:24.271]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.271]                 }
[10:26:24.271]             }
[10:26:24.271]         }
[10:26:24.271]     })
[10:26:24.271]     if (TRUE) {
[10:26:24.271]         base::sink(type = "output", split = FALSE)
[10:26:24.271]         if (TRUE) {
[10:26:24.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.271]         }
[10:26:24.271]         else {
[10:26:24.271]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.271]         }
[10:26:24.271]         base::close(...future.stdout)
[10:26:24.271]         ...future.stdout <- NULL
[10:26:24.271]     }
[10:26:24.271]     ...future.result$conditions <- ...future.conditions
[10:26:24.271]     ...future.result$finished <- base::Sys.time()
[10:26:24.271]     ...future.result
[10:26:24.271] }
[10:26:24.273] plan(): Setting new future strategy stack:
[10:26:24.273] List of future strategies:
[10:26:24.273] 1. sequential:
[10:26:24.273]    - args: function (..., envir = parent.frame())
[10:26:24.273]    - tweaked: FALSE
[10:26:24.273]    - call: NULL
[10:26:24.273] plan(): nbrOfWorkers() = 1
[10:26:24.274] plan(): Setting new future strategy stack:
[10:26:24.274] List of future strategies:
[10:26:24.274] 1. multicore:
[10:26:24.274]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.274]    - tweaked: FALSE
[10:26:24.274]    - call: plan(multicore)
[10:26:24.277] plan(): nbrOfWorkers() = 1
[10:26:24.278] SequentialFuture started (and completed)
[10:26:24.278] resolved() for ‘SequentialFuture’ ...
[10:26:24.278] - state: ‘finished’
[10:26:24.278] - run: TRUE
[10:26:24.278] - result: ‘FutureResult’
[10:26:24.278] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[10:26:24.281] getGlobalsAndPackages() ...
[10:26:24.281] Searching for globals...
[10:26:24.283] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:26:24.283] Searching for globals ... DONE
[10:26:24.283] Resolving globals: FALSE
[10:26:24.284] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.284] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:24.285] - globals: [1] ‘a’
[10:26:24.285] 
[10:26:24.285] getGlobalsAndPackages() ... DONE
[10:26:24.285] Packages needed by the future expression (n = 0): <none>
[10:26:24.285] Packages needed by future strategies (n = 0): <none>
[10:26:24.286] {
[10:26:24.286]     {
[10:26:24.286]         {
[10:26:24.286]             ...future.startTime <- base::Sys.time()
[10:26:24.286]             {
[10:26:24.286]                 {
[10:26:24.286]                   {
[10:26:24.286]                     base::local({
[10:26:24.286]                       has_future <- base::requireNamespace("future", 
[10:26:24.286]                         quietly = TRUE)
[10:26:24.286]                       if (has_future) {
[10:26:24.286]                         ns <- base::getNamespace("future")
[10:26:24.286]                         version <- ns[[".package"]][["version"]]
[10:26:24.286]                         if (is.null(version)) 
[10:26:24.286]                           version <- utils::packageVersion("future")
[10:26:24.286]                       }
[10:26:24.286]                       else {
[10:26:24.286]                         version <- NULL
[10:26:24.286]                       }
[10:26:24.286]                       if (!has_future || version < "1.8.0") {
[10:26:24.286]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.286]                           "", base::R.version$version.string), 
[10:26:24.286]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.286]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.286]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.286]                             "release", "version")], collapse = " "), 
[10:26:24.286]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.286]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.286]                           info)
[10:26:24.286]                         info <- base::paste(info, collapse = "; ")
[10:26:24.286]                         if (!has_future) {
[10:26:24.286]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.286]                             info)
[10:26:24.286]                         }
[10:26:24.286]                         else {
[10:26:24.286]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.286]                             info, version)
[10:26:24.286]                         }
[10:26:24.286]                         base::stop(msg)
[10:26:24.286]                       }
[10:26:24.286]                     })
[10:26:24.286]                   }
[10:26:24.286]                   options(future.plan = NULL)
[10:26:24.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.286]                 }
[10:26:24.286]                 ...future.workdir <- getwd()
[10:26:24.286]             }
[10:26:24.286]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.286]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.286]         }
[10:26:24.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.286]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.286]             base::names(...future.oldOptions))
[10:26:24.286]     }
[10:26:24.286]     if (FALSE) {
[10:26:24.286]     }
[10:26:24.286]     else {
[10:26:24.286]         if (TRUE) {
[10:26:24.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.286]                 open = "w")
[10:26:24.286]         }
[10:26:24.286]         else {
[10:26:24.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.286]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.286]         }
[10:26:24.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.286]             base::sink(type = "output", split = FALSE)
[10:26:24.286]             base::close(...future.stdout)
[10:26:24.286]         }, add = TRUE)
[10:26:24.286]     }
[10:26:24.286]     ...future.frame <- base::sys.nframe()
[10:26:24.286]     ...future.conditions <- base::list()
[10:26:24.286]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.286]     if (FALSE) {
[10:26:24.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.286]     }
[10:26:24.286]     ...future.result <- base::tryCatch({
[10:26:24.286]         base::withCallingHandlers({
[10:26:24.286]             ...future.value <- base::withVisible(base::local({
[10:26:24.286]                 b <- 3
[10:26:24.286]                 c <- 2
[10:26:24.286]                 a * b * c
[10:26:24.286]             }))
[10:26:24.286]             future::FutureResult(value = ...future.value$value, 
[10:26:24.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.286]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.286]                     ...future.globalenv.names))
[10:26:24.286]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.286]         }, condition = base::local({
[10:26:24.286]             c <- base::c
[10:26:24.286]             inherits <- base::inherits
[10:26:24.286]             invokeRestart <- base::invokeRestart
[10:26:24.286]             length <- base::length
[10:26:24.286]             list <- base::list
[10:26:24.286]             seq.int <- base::seq.int
[10:26:24.286]             signalCondition <- base::signalCondition
[10:26:24.286]             sys.calls <- base::sys.calls
[10:26:24.286]             `[[` <- base::`[[`
[10:26:24.286]             `+` <- base::`+`
[10:26:24.286]             `<<-` <- base::`<<-`
[10:26:24.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.286]                   3L)]
[10:26:24.286]             }
[10:26:24.286]             function(cond) {
[10:26:24.286]                 is_error <- inherits(cond, "error")
[10:26:24.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.286]                   NULL)
[10:26:24.286]                 if (is_error) {
[10:26:24.286]                   sessionInformation <- function() {
[10:26:24.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.286]                       search = base::search(), system = base::Sys.info())
[10:26:24.286]                   }
[10:26:24.286]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.286]                     cond$call), session = sessionInformation(), 
[10:26:24.286]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.286]                   signalCondition(cond)
[10:26:24.286]                 }
[10:26:24.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.286]                 "immediateCondition"))) {
[10:26:24.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.286]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.286]                   if (TRUE && !signal) {
[10:26:24.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.286]                     {
[10:26:24.286]                       inherits <- base::inherits
[10:26:24.286]                       invokeRestart <- base::invokeRestart
[10:26:24.286]                       is.null <- base::is.null
[10:26:24.286]                       muffled <- FALSE
[10:26:24.286]                       if (inherits(cond, "message")) {
[10:26:24.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.286]                         if (muffled) 
[10:26:24.286]                           invokeRestart("muffleMessage")
[10:26:24.286]                       }
[10:26:24.286]                       else if (inherits(cond, "warning")) {
[10:26:24.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.286]                         if (muffled) 
[10:26:24.286]                           invokeRestart("muffleWarning")
[10:26:24.286]                       }
[10:26:24.286]                       else if (inherits(cond, "condition")) {
[10:26:24.286]                         if (!is.null(pattern)) {
[10:26:24.286]                           computeRestarts <- base::computeRestarts
[10:26:24.286]                           grepl <- base::grepl
[10:26:24.286]                           restarts <- computeRestarts(cond)
[10:26:24.286]                           for (restart in restarts) {
[10:26:24.286]                             name <- restart$name
[10:26:24.286]                             if (is.null(name)) 
[10:26:24.286]                               next
[10:26:24.286]                             if (!grepl(pattern, name)) 
[10:26:24.286]                               next
[10:26:24.286]                             invokeRestart(restart)
[10:26:24.286]                             muffled <- TRUE
[10:26:24.286]                             break
[10:26:24.286]                           }
[10:26:24.286]                         }
[10:26:24.286]                       }
[10:26:24.286]                       invisible(muffled)
[10:26:24.286]                     }
[10:26:24.286]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.286]                   }
[10:26:24.286]                 }
[10:26:24.286]                 else {
[10:26:24.286]                   if (TRUE) {
[10:26:24.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.286]                     {
[10:26:24.286]                       inherits <- base::inherits
[10:26:24.286]                       invokeRestart <- base::invokeRestart
[10:26:24.286]                       is.null <- base::is.null
[10:26:24.286]                       muffled <- FALSE
[10:26:24.286]                       if (inherits(cond, "message")) {
[10:26:24.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.286]                         if (muffled) 
[10:26:24.286]                           invokeRestart("muffleMessage")
[10:26:24.286]                       }
[10:26:24.286]                       else if (inherits(cond, "warning")) {
[10:26:24.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.286]                         if (muffled) 
[10:26:24.286]                           invokeRestart("muffleWarning")
[10:26:24.286]                       }
[10:26:24.286]                       else if (inherits(cond, "condition")) {
[10:26:24.286]                         if (!is.null(pattern)) {
[10:26:24.286]                           computeRestarts <- base::computeRestarts
[10:26:24.286]                           grepl <- base::grepl
[10:26:24.286]                           restarts <- computeRestarts(cond)
[10:26:24.286]                           for (restart in restarts) {
[10:26:24.286]                             name <- restart$name
[10:26:24.286]                             if (is.null(name)) 
[10:26:24.286]                               next
[10:26:24.286]                             if (!grepl(pattern, name)) 
[10:26:24.286]                               next
[10:26:24.286]                             invokeRestart(restart)
[10:26:24.286]                             muffled <- TRUE
[10:26:24.286]                             break
[10:26:24.286]                           }
[10:26:24.286]                         }
[10:26:24.286]                       }
[10:26:24.286]                       invisible(muffled)
[10:26:24.286]                     }
[10:26:24.286]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.286]                   }
[10:26:24.286]                 }
[10:26:24.286]             }
[10:26:24.286]         }))
[10:26:24.286]     }, error = function(ex) {
[10:26:24.286]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.286]                 ...future.rng), started = ...future.startTime, 
[10:26:24.286]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.286]             version = "1.8"), class = "FutureResult")
[10:26:24.286]     }, finally = {
[10:26:24.286]         if (!identical(...future.workdir, getwd())) 
[10:26:24.286]             setwd(...future.workdir)
[10:26:24.286]         {
[10:26:24.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.286]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.286]             }
[10:26:24.286]             base::options(...future.oldOptions)
[10:26:24.286]             if (.Platform$OS.type == "windows") {
[10:26:24.286]                 old_names <- names(...future.oldEnvVars)
[10:26:24.286]                 envs <- base::Sys.getenv()
[10:26:24.286]                 names <- names(envs)
[10:26:24.286]                 common <- intersect(names, old_names)
[10:26:24.286]                 added <- setdiff(names, old_names)
[10:26:24.286]                 removed <- setdiff(old_names, names)
[10:26:24.286]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.286]                   envs[common]]
[10:26:24.286]                 NAMES <- toupper(changed)
[10:26:24.286]                 args <- list()
[10:26:24.286]                 for (kk in seq_along(NAMES)) {
[10:26:24.286]                   name <- changed[[kk]]
[10:26:24.286]                   NAME <- NAMES[[kk]]
[10:26:24.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.286]                     next
[10:26:24.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.286]                 }
[10:26:24.286]                 NAMES <- toupper(added)
[10:26:24.286]                 for (kk in seq_along(NAMES)) {
[10:26:24.286]                   name <- added[[kk]]
[10:26:24.286]                   NAME <- NAMES[[kk]]
[10:26:24.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.286]                     next
[10:26:24.286]                   args[[name]] <- ""
[10:26:24.286]                 }
[10:26:24.286]                 NAMES <- toupper(removed)
[10:26:24.286]                 for (kk in seq_along(NAMES)) {
[10:26:24.286]                   name <- removed[[kk]]
[10:26:24.286]                   NAME <- NAMES[[kk]]
[10:26:24.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.286]                     next
[10:26:24.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.286]                 }
[10:26:24.286]                 if (length(args) > 0) 
[10:26:24.286]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.286]             }
[10:26:24.286]             else {
[10:26:24.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.286]             }
[10:26:24.286]             {
[10:26:24.286]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.286]                   0L) {
[10:26:24.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.286]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.286]                   base::options(opts)
[10:26:24.286]                 }
[10:26:24.286]                 {
[10:26:24.286]                   {
[10:26:24.286]                     NULL
[10:26:24.286]                     RNGkind("Mersenne-Twister")
[10:26:24.286]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.286]                       inherits = FALSE)
[10:26:24.286]                   }
[10:26:24.286]                   options(future.plan = NULL)
[10:26:24.286]                   if (is.na(NA_character_)) 
[10:26:24.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.286]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.286]                     envir = parent.frame()) 
[10:26:24.286]                   {
[10:26:24.286]                     default_workers <- missing(workers)
[10:26:24.286]                     if (is.function(workers)) 
[10:26:24.286]                       workers <- workers()
[10:26:24.286]                     workers <- structure(as.integer(workers), 
[10:26:24.286]                       class = class(workers))
[10:26:24.286]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.286]                       1L)
[10:26:24.286]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.286]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.286]                       if (default_workers) 
[10:26:24.286]                         supportsMulticore(warn = TRUE)
[10:26:24.286]                       return(sequential(..., envir = envir))
[10:26:24.286]                     }
[10:26:24.286]                     oopts <- options(mc.cores = workers)
[10:26:24.286]                     on.exit(options(oopts))
[10:26:24.286]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.286]                       envir = envir)
[10:26:24.286]                     if (!future$lazy) 
[10:26:24.286]                       future <- run(future)
[10:26:24.286]                     invisible(future)
[10:26:24.286]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.286]                 }
[10:26:24.286]             }
[10:26:24.286]         }
[10:26:24.286]     })
[10:26:24.286]     if (TRUE) {
[10:26:24.286]         base::sink(type = "output", split = FALSE)
[10:26:24.286]         if (TRUE) {
[10:26:24.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.286]         }
[10:26:24.286]         else {
[10:26:24.286]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.286]         }
[10:26:24.286]         base::close(...future.stdout)
[10:26:24.286]         ...future.stdout <- NULL
[10:26:24.286]     }
[10:26:24.286]     ...future.result$conditions <- ...future.conditions
[10:26:24.286]     ...future.result$finished <- base::Sys.time()
[10:26:24.286]     ...future.result
[10:26:24.286] }
[10:26:24.287] assign_globals() ...
[10:26:24.287] List of 1
[10:26:24.287]  $ a: num 0
[10:26:24.287]  - attr(*, "where")=List of 1
[10:26:24.287]   ..$ a:<environment: R_EmptyEnv> 
[10:26:24.287]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.287]  - attr(*, "resolved")= logi FALSE
[10:26:24.287]  - attr(*, "total_size")= num 56
[10:26:24.294] - copied ‘a’ to environment
[10:26:24.294] assign_globals() ... done
[10:26:24.294] plan(): Setting new future strategy stack:
[10:26:24.294] List of future strategies:
[10:26:24.294] 1. sequential:
[10:26:24.294]    - args: function (..., envir = parent.frame())
[10:26:24.294]    - tweaked: FALSE
[10:26:24.294]    - call: NULL
[10:26:24.294] plan(): nbrOfWorkers() = 1
[10:26:24.295] plan(): Setting new future strategy stack:
[10:26:24.295] List of future strategies:
[10:26:24.295] 1. multicore:
[10:26:24.295]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.295]    - tweaked: FALSE
[10:26:24.295]    - call: plan(multicore)
[10:26:24.299] plan(): nbrOfWorkers() = 1
[10:26:24.299] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[10:26:24.303] getGlobalsAndPackages() ...
[10:26:24.303] Searching for globals...
[10:26:24.304] - globals found: [2] ‘{’, ‘ii’
[10:26:24.304] Searching for globals ... DONE
[10:26:24.304] Resolving globals: FALSE
[10:26:24.304] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.305] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.305] - globals: [1] ‘ii’
[10:26:24.305] 
[10:26:24.305] getGlobalsAndPackages() ... DONE
[10:26:24.305] Packages needed by the future expression (n = 0): <none>
[10:26:24.305] Packages needed by future strategies (n = 0): <none>
[10:26:24.306] {
[10:26:24.306]     {
[10:26:24.306]         {
[10:26:24.306]             ...future.startTime <- base::Sys.time()
[10:26:24.306]             {
[10:26:24.306]                 {
[10:26:24.306]                   {
[10:26:24.306]                     base::local({
[10:26:24.306]                       has_future <- base::requireNamespace("future", 
[10:26:24.306]                         quietly = TRUE)
[10:26:24.306]                       if (has_future) {
[10:26:24.306]                         ns <- base::getNamespace("future")
[10:26:24.306]                         version <- ns[[".package"]][["version"]]
[10:26:24.306]                         if (is.null(version)) 
[10:26:24.306]                           version <- utils::packageVersion("future")
[10:26:24.306]                       }
[10:26:24.306]                       else {
[10:26:24.306]                         version <- NULL
[10:26:24.306]                       }
[10:26:24.306]                       if (!has_future || version < "1.8.0") {
[10:26:24.306]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.306]                           "", base::R.version$version.string), 
[10:26:24.306]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.306]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.306]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.306]                             "release", "version")], collapse = " "), 
[10:26:24.306]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.306]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.306]                           info)
[10:26:24.306]                         info <- base::paste(info, collapse = "; ")
[10:26:24.306]                         if (!has_future) {
[10:26:24.306]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.306]                             info)
[10:26:24.306]                         }
[10:26:24.306]                         else {
[10:26:24.306]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.306]                             info, version)
[10:26:24.306]                         }
[10:26:24.306]                         base::stop(msg)
[10:26:24.306]                       }
[10:26:24.306]                     })
[10:26:24.306]                   }
[10:26:24.306]                   options(future.plan = NULL)
[10:26:24.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.306]                 }
[10:26:24.306]                 ...future.workdir <- getwd()
[10:26:24.306]             }
[10:26:24.306]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.306]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.306]         }
[10:26:24.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.306]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.306]             base::names(...future.oldOptions))
[10:26:24.306]     }
[10:26:24.306]     if (FALSE) {
[10:26:24.306]     }
[10:26:24.306]     else {
[10:26:24.306]         if (TRUE) {
[10:26:24.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.306]                 open = "w")
[10:26:24.306]         }
[10:26:24.306]         else {
[10:26:24.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.306]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.306]         }
[10:26:24.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.306]             base::sink(type = "output", split = FALSE)
[10:26:24.306]             base::close(...future.stdout)
[10:26:24.306]         }, add = TRUE)
[10:26:24.306]     }
[10:26:24.306]     ...future.frame <- base::sys.nframe()
[10:26:24.306]     ...future.conditions <- base::list()
[10:26:24.306]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.306]     if (FALSE) {
[10:26:24.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.306]     }
[10:26:24.306]     ...future.result <- base::tryCatch({
[10:26:24.306]         base::withCallingHandlers({
[10:26:24.306]             ...future.value <- base::withVisible(base::local({
[10:26:24.306]                 ii
[10:26:24.306]             }))
[10:26:24.306]             future::FutureResult(value = ...future.value$value, 
[10:26:24.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.306]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.306]                     ...future.globalenv.names))
[10:26:24.306]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.306]         }, condition = base::local({
[10:26:24.306]             c <- base::c
[10:26:24.306]             inherits <- base::inherits
[10:26:24.306]             invokeRestart <- base::invokeRestart
[10:26:24.306]             length <- base::length
[10:26:24.306]             list <- base::list
[10:26:24.306]             seq.int <- base::seq.int
[10:26:24.306]             signalCondition <- base::signalCondition
[10:26:24.306]             sys.calls <- base::sys.calls
[10:26:24.306]             `[[` <- base::`[[`
[10:26:24.306]             `+` <- base::`+`
[10:26:24.306]             `<<-` <- base::`<<-`
[10:26:24.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.306]                   3L)]
[10:26:24.306]             }
[10:26:24.306]             function(cond) {
[10:26:24.306]                 is_error <- inherits(cond, "error")
[10:26:24.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.306]                   NULL)
[10:26:24.306]                 if (is_error) {
[10:26:24.306]                   sessionInformation <- function() {
[10:26:24.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.306]                       search = base::search(), system = base::Sys.info())
[10:26:24.306]                   }
[10:26:24.306]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.306]                     cond$call), session = sessionInformation(), 
[10:26:24.306]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.306]                   signalCondition(cond)
[10:26:24.306]                 }
[10:26:24.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.306]                 "immediateCondition"))) {
[10:26:24.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.306]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.306]                   if (TRUE && !signal) {
[10:26:24.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.306]                     {
[10:26:24.306]                       inherits <- base::inherits
[10:26:24.306]                       invokeRestart <- base::invokeRestart
[10:26:24.306]                       is.null <- base::is.null
[10:26:24.306]                       muffled <- FALSE
[10:26:24.306]                       if (inherits(cond, "message")) {
[10:26:24.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.306]                         if (muffled) 
[10:26:24.306]                           invokeRestart("muffleMessage")
[10:26:24.306]                       }
[10:26:24.306]                       else if (inherits(cond, "warning")) {
[10:26:24.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.306]                         if (muffled) 
[10:26:24.306]                           invokeRestart("muffleWarning")
[10:26:24.306]                       }
[10:26:24.306]                       else if (inherits(cond, "condition")) {
[10:26:24.306]                         if (!is.null(pattern)) {
[10:26:24.306]                           computeRestarts <- base::computeRestarts
[10:26:24.306]                           grepl <- base::grepl
[10:26:24.306]                           restarts <- computeRestarts(cond)
[10:26:24.306]                           for (restart in restarts) {
[10:26:24.306]                             name <- restart$name
[10:26:24.306]                             if (is.null(name)) 
[10:26:24.306]                               next
[10:26:24.306]                             if (!grepl(pattern, name)) 
[10:26:24.306]                               next
[10:26:24.306]                             invokeRestart(restart)
[10:26:24.306]                             muffled <- TRUE
[10:26:24.306]                             break
[10:26:24.306]                           }
[10:26:24.306]                         }
[10:26:24.306]                       }
[10:26:24.306]                       invisible(muffled)
[10:26:24.306]                     }
[10:26:24.306]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.306]                   }
[10:26:24.306]                 }
[10:26:24.306]                 else {
[10:26:24.306]                   if (TRUE) {
[10:26:24.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.306]                     {
[10:26:24.306]                       inherits <- base::inherits
[10:26:24.306]                       invokeRestart <- base::invokeRestart
[10:26:24.306]                       is.null <- base::is.null
[10:26:24.306]                       muffled <- FALSE
[10:26:24.306]                       if (inherits(cond, "message")) {
[10:26:24.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.306]                         if (muffled) 
[10:26:24.306]                           invokeRestart("muffleMessage")
[10:26:24.306]                       }
[10:26:24.306]                       else if (inherits(cond, "warning")) {
[10:26:24.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.306]                         if (muffled) 
[10:26:24.306]                           invokeRestart("muffleWarning")
[10:26:24.306]                       }
[10:26:24.306]                       else if (inherits(cond, "condition")) {
[10:26:24.306]                         if (!is.null(pattern)) {
[10:26:24.306]                           computeRestarts <- base::computeRestarts
[10:26:24.306]                           grepl <- base::grepl
[10:26:24.306]                           restarts <- computeRestarts(cond)
[10:26:24.306]                           for (restart in restarts) {
[10:26:24.306]                             name <- restart$name
[10:26:24.306]                             if (is.null(name)) 
[10:26:24.306]                               next
[10:26:24.306]                             if (!grepl(pattern, name)) 
[10:26:24.306]                               next
[10:26:24.306]                             invokeRestart(restart)
[10:26:24.306]                             muffled <- TRUE
[10:26:24.306]                             break
[10:26:24.306]                           }
[10:26:24.306]                         }
[10:26:24.306]                       }
[10:26:24.306]                       invisible(muffled)
[10:26:24.306]                     }
[10:26:24.306]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.306]                   }
[10:26:24.306]                 }
[10:26:24.306]             }
[10:26:24.306]         }))
[10:26:24.306]     }, error = function(ex) {
[10:26:24.306]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.306]                 ...future.rng), started = ...future.startTime, 
[10:26:24.306]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.306]             version = "1.8"), class = "FutureResult")
[10:26:24.306]     }, finally = {
[10:26:24.306]         if (!identical(...future.workdir, getwd())) 
[10:26:24.306]             setwd(...future.workdir)
[10:26:24.306]         {
[10:26:24.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.306]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.306]             }
[10:26:24.306]             base::options(...future.oldOptions)
[10:26:24.306]             if (.Platform$OS.type == "windows") {
[10:26:24.306]                 old_names <- names(...future.oldEnvVars)
[10:26:24.306]                 envs <- base::Sys.getenv()
[10:26:24.306]                 names <- names(envs)
[10:26:24.306]                 common <- intersect(names, old_names)
[10:26:24.306]                 added <- setdiff(names, old_names)
[10:26:24.306]                 removed <- setdiff(old_names, names)
[10:26:24.306]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.306]                   envs[common]]
[10:26:24.306]                 NAMES <- toupper(changed)
[10:26:24.306]                 args <- list()
[10:26:24.306]                 for (kk in seq_along(NAMES)) {
[10:26:24.306]                   name <- changed[[kk]]
[10:26:24.306]                   NAME <- NAMES[[kk]]
[10:26:24.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.306]                     next
[10:26:24.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.306]                 }
[10:26:24.306]                 NAMES <- toupper(added)
[10:26:24.306]                 for (kk in seq_along(NAMES)) {
[10:26:24.306]                   name <- added[[kk]]
[10:26:24.306]                   NAME <- NAMES[[kk]]
[10:26:24.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.306]                     next
[10:26:24.306]                   args[[name]] <- ""
[10:26:24.306]                 }
[10:26:24.306]                 NAMES <- toupper(removed)
[10:26:24.306]                 for (kk in seq_along(NAMES)) {
[10:26:24.306]                   name <- removed[[kk]]
[10:26:24.306]                   NAME <- NAMES[[kk]]
[10:26:24.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.306]                     next
[10:26:24.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.306]                 }
[10:26:24.306]                 if (length(args) > 0) 
[10:26:24.306]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.306]             }
[10:26:24.306]             else {
[10:26:24.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.306]             }
[10:26:24.306]             {
[10:26:24.306]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.306]                   0L) {
[10:26:24.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.306]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.306]                   base::options(opts)
[10:26:24.306]                 }
[10:26:24.306]                 {
[10:26:24.306]                   {
[10:26:24.306]                     NULL
[10:26:24.306]                     RNGkind("Mersenne-Twister")
[10:26:24.306]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.306]                       inherits = FALSE)
[10:26:24.306]                   }
[10:26:24.306]                   options(future.plan = NULL)
[10:26:24.306]                   if (is.na(NA_character_)) 
[10:26:24.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.306]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.306]                     envir = parent.frame()) 
[10:26:24.306]                   {
[10:26:24.306]                     default_workers <- missing(workers)
[10:26:24.306]                     if (is.function(workers)) 
[10:26:24.306]                       workers <- workers()
[10:26:24.306]                     workers <- structure(as.integer(workers), 
[10:26:24.306]                       class = class(workers))
[10:26:24.306]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.306]                       1L)
[10:26:24.306]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.306]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.306]                       if (default_workers) 
[10:26:24.306]                         supportsMulticore(warn = TRUE)
[10:26:24.306]                       return(sequential(..., envir = envir))
[10:26:24.306]                     }
[10:26:24.306]                     oopts <- options(mc.cores = workers)
[10:26:24.306]                     on.exit(options(oopts))
[10:26:24.306]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.306]                       envir = envir)
[10:26:24.306]                     if (!future$lazy) 
[10:26:24.306]                       future <- run(future)
[10:26:24.306]                     invisible(future)
[10:26:24.306]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.306]                 }
[10:26:24.306]             }
[10:26:24.306]         }
[10:26:24.306]     })
[10:26:24.306]     if (TRUE) {
[10:26:24.306]         base::sink(type = "output", split = FALSE)
[10:26:24.306]         if (TRUE) {
[10:26:24.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.306]         }
[10:26:24.306]         else {
[10:26:24.306]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.306]         }
[10:26:24.306]         base::close(...future.stdout)
[10:26:24.306]         ...future.stdout <- NULL
[10:26:24.306]     }
[10:26:24.306]     ...future.result$conditions <- ...future.conditions
[10:26:24.306]     ...future.result$finished <- base::Sys.time()
[10:26:24.306]     ...future.result
[10:26:24.306] }
[10:26:24.307] assign_globals() ...
[10:26:24.307] List of 1
[10:26:24.307]  $ ii: int 1
[10:26:24.307]  - attr(*, "where")=List of 1
[10:26:24.307]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.307]  - attr(*, "resolved")= logi FALSE
[10:26:24.307]  - attr(*, "total_size")= num 56
[10:26:24.309] - copied ‘ii’ to environment
[10:26:24.310] assign_globals() ... done
[10:26:24.310] plan(): Setting new future strategy stack:
[10:26:24.310] List of future strategies:
[10:26:24.310] 1. sequential:
[10:26:24.310]    - args: function (..., envir = parent.frame())
[10:26:24.310]    - tweaked: FALSE
[10:26:24.310]    - call: NULL
[10:26:24.310] plan(): nbrOfWorkers() = 1
[10:26:24.311] plan(): Setting new future strategy stack:
[10:26:24.311] List of future strategies:
[10:26:24.311] 1. multicore:
[10:26:24.311]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.311]    - tweaked: FALSE
[10:26:24.311]    - call: plan(multicore)
[10:26:24.314] plan(): nbrOfWorkers() = 1
[10:26:24.314] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[10:26:24.318] getGlobalsAndPackages() ...
[10:26:24.318] Searching for globals...
[10:26:24.318] - globals found: [2] ‘{’, ‘ii’
[10:26:24.319] Searching for globals ... DONE
[10:26:24.319] Resolving globals: FALSE
[10:26:24.319] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.319] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.319] - globals: [1] ‘ii’
[10:26:24.320] 
[10:26:24.320] getGlobalsAndPackages() ... DONE
[10:26:24.320] Packages needed by the future expression (n = 0): <none>
[10:26:24.320] Packages needed by future strategies (n = 0): <none>
[10:26:24.320] {
[10:26:24.320]     {
[10:26:24.320]         {
[10:26:24.320]             ...future.startTime <- base::Sys.time()
[10:26:24.320]             {
[10:26:24.320]                 {
[10:26:24.320]                   {
[10:26:24.320]                     base::local({
[10:26:24.320]                       has_future <- base::requireNamespace("future", 
[10:26:24.320]                         quietly = TRUE)
[10:26:24.320]                       if (has_future) {
[10:26:24.320]                         ns <- base::getNamespace("future")
[10:26:24.320]                         version <- ns[[".package"]][["version"]]
[10:26:24.320]                         if (is.null(version)) 
[10:26:24.320]                           version <- utils::packageVersion("future")
[10:26:24.320]                       }
[10:26:24.320]                       else {
[10:26:24.320]                         version <- NULL
[10:26:24.320]                       }
[10:26:24.320]                       if (!has_future || version < "1.8.0") {
[10:26:24.320]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.320]                           "", base::R.version$version.string), 
[10:26:24.320]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.320]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.320]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.320]                             "release", "version")], collapse = " "), 
[10:26:24.320]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.320]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.320]                           info)
[10:26:24.320]                         info <- base::paste(info, collapse = "; ")
[10:26:24.320]                         if (!has_future) {
[10:26:24.320]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.320]                             info)
[10:26:24.320]                         }
[10:26:24.320]                         else {
[10:26:24.320]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.320]                             info, version)
[10:26:24.320]                         }
[10:26:24.320]                         base::stop(msg)
[10:26:24.320]                       }
[10:26:24.320]                     })
[10:26:24.320]                   }
[10:26:24.320]                   options(future.plan = NULL)
[10:26:24.320]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.320]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.320]                 }
[10:26:24.320]                 ...future.workdir <- getwd()
[10:26:24.320]             }
[10:26:24.320]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.320]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.320]         }
[10:26:24.320]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.320]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.320]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.320]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.320]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.320]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.320]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.320]             base::names(...future.oldOptions))
[10:26:24.320]     }
[10:26:24.320]     if (FALSE) {
[10:26:24.320]     }
[10:26:24.320]     else {
[10:26:24.320]         if (TRUE) {
[10:26:24.320]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.320]                 open = "w")
[10:26:24.320]         }
[10:26:24.320]         else {
[10:26:24.320]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.320]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.320]         }
[10:26:24.320]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.320]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.320]             base::sink(type = "output", split = FALSE)
[10:26:24.320]             base::close(...future.stdout)
[10:26:24.320]         }, add = TRUE)
[10:26:24.320]     }
[10:26:24.320]     ...future.frame <- base::sys.nframe()
[10:26:24.320]     ...future.conditions <- base::list()
[10:26:24.320]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.320]     if (FALSE) {
[10:26:24.320]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.320]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.320]     }
[10:26:24.320]     ...future.result <- base::tryCatch({
[10:26:24.320]         base::withCallingHandlers({
[10:26:24.320]             ...future.value <- base::withVisible(base::local({
[10:26:24.320]                 ii
[10:26:24.320]             }))
[10:26:24.320]             future::FutureResult(value = ...future.value$value, 
[10:26:24.320]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.320]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.320]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.320]                     ...future.globalenv.names))
[10:26:24.320]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.320]         }, condition = base::local({
[10:26:24.320]             c <- base::c
[10:26:24.320]             inherits <- base::inherits
[10:26:24.320]             invokeRestart <- base::invokeRestart
[10:26:24.320]             length <- base::length
[10:26:24.320]             list <- base::list
[10:26:24.320]             seq.int <- base::seq.int
[10:26:24.320]             signalCondition <- base::signalCondition
[10:26:24.320]             sys.calls <- base::sys.calls
[10:26:24.320]             `[[` <- base::`[[`
[10:26:24.320]             `+` <- base::`+`
[10:26:24.320]             `<<-` <- base::`<<-`
[10:26:24.320]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.320]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.320]                   3L)]
[10:26:24.320]             }
[10:26:24.320]             function(cond) {
[10:26:24.320]                 is_error <- inherits(cond, "error")
[10:26:24.320]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.320]                   NULL)
[10:26:24.320]                 if (is_error) {
[10:26:24.320]                   sessionInformation <- function() {
[10:26:24.320]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.320]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.320]                       search = base::search(), system = base::Sys.info())
[10:26:24.320]                   }
[10:26:24.320]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.320]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.320]                     cond$call), session = sessionInformation(), 
[10:26:24.320]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.320]                   signalCondition(cond)
[10:26:24.320]                 }
[10:26:24.320]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.320]                 "immediateCondition"))) {
[10:26:24.320]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.320]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.320]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.320]                   if (TRUE && !signal) {
[10:26:24.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.320]                     {
[10:26:24.320]                       inherits <- base::inherits
[10:26:24.320]                       invokeRestart <- base::invokeRestart
[10:26:24.320]                       is.null <- base::is.null
[10:26:24.320]                       muffled <- FALSE
[10:26:24.320]                       if (inherits(cond, "message")) {
[10:26:24.320]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.320]                         if (muffled) 
[10:26:24.320]                           invokeRestart("muffleMessage")
[10:26:24.320]                       }
[10:26:24.320]                       else if (inherits(cond, "warning")) {
[10:26:24.320]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.320]                         if (muffled) 
[10:26:24.320]                           invokeRestart("muffleWarning")
[10:26:24.320]                       }
[10:26:24.320]                       else if (inherits(cond, "condition")) {
[10:26:24.320]                         if (!is.null(pattern)) {
[10:26:24.320]                           computeRestarts <- base::computeRestarts
[10:26:24.320]                           grepl <- base::grepl
[10:26:24.320]                           restarts <- computeRestarts(cond)
[10:26:24.320]                           for (restart in restarts) {
[10:26:24.320]                             name <- restart$name
[10:26:24.320]                             if (is.null(name)) 
[10:26:24.320]                               next
[10:26:24.320]                             if (!grepl(pattern, name)) 
[10:26:24.320]                               next
[10:26:24.320]                             invokeRestart(restart)
[10:26:24.320]                             muffled <- TRUE
[10:26:24.320]                             break
[10:26:24.320]                           }
[10:26:24.320]                         }
[10:26:24.320]                       }
[10:26:24.320]                       invisible(muffled)
[10:26:24.320]                     }
[10:26:24.320]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.320]                   }
[10:26:24.320]                 }
[10:26:24.320]                 else {
[10:26:24.320]                   if (TRUE) {
[10:26:24.320]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.320]                     {
[10:26:24.320]                       inherits <- base::inherits
[10:26:24.320]                       invokeRestart <- base::invokeRestart
[10:26:24.320]                       is.null <- base::is.null
[10:26:24.320]                       muffled <- FALSE
[10:26:24.320]                       if (inherits(cond, "message")) {
[10:26:24.320]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.320]                         if (muffled) 
[10:26:24.320]                           invokeRestart("muffleMessage")
[10:26:24.320]                       }
[10:26:24.320]                       else if (inherits(cond, "warning")) {
[10:26:24.320]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.320]                         if (muffled) 
[10:26:24.320]                           invokeRestart("muffleWarning")
[10:26:24.320]                       }
[10:26:24.320]                       else if (inherits(cond, "condition")) {
[10:26:24.320]                         if (!is.null(pattern)) {
[10:26:24.320]                           computeRestarts <- base::computeRestarts
[10:26:24.320]                           grepl <- base::grepl
[10:26:24.320]                           restarts <- computeRestarts(cond)
[10:26:24.320]                           for (restart in restarts) {
[10:26:24.320]                             name <- restart$name
[10:26:24.320]                             if (is.null(name)) 
[10:26:24.320]                               next
[10:26:24.320]                             if (!grepl(pattern, name)) 
[10:26:24.320]                               next
[10:26:24.320]                             invokeRestart(restart)
[10:26:24.320]                             muffled <- TRUE
[10:26:24.320]                             break
[10:26:24.320]                           }
[10:26:24.320]                         }
[10:26:24.320]                       }
[10:26:24.320]                       invisible(muffled)
[10:26:24.320]                     }
[10:26:24.320]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.320]                   }
[10:26:24.320]                 }
[10:26:24.320]             }
[10:26:24.320]         }))
[10:26:24.320]     }, error = function(ex) {
[10:26:24.320]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.320]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.320]                 ...future.rng), started = ...future.startTime, 
[10:26:24.320]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.320]             version = "1.8"), class = "FutureResult")
[10:26:24.320]     }, finally = {
[10:26:24.320]         if (!identical(...future.workdir, getwd())) 
[10:26:24.320]             setwd(...future.workdir)
[10:26:24.320]         {
[10:26:24.320]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.320]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.320]             }
[10:26:24.320]             base::options(...future.oldOptions)
[10:26:24.320]             if (.Platform$OS.type == "windows") {
[10:26:24.320]                 old_names <- names(...future.oldEnvVars)
[10:26:24.320]                 envs <- base::Sys.getenv()
[10:26:24.320]                 names <- names(envs)
[10:26:24.320]                 common <- intersect(names, old_names)
[10:26:24.320]                 added <- setdiff(names, old_names)
[10:26:24.320]                 removed <- setdiff(old_names, names)
[10:26:24.320]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.320]                   envs[common]]
[10:26:24.320]                 NAMES <- toupper(changed)
[10:26:24.320]                 args <- list()
[10:26:24.320]                 for (kk in seq_along(NAMES)) {
[10:26:24.320]                   name <- changed[[kk]]
[10:26:24.320]                   NAME <- NAMES[[kk]]
[10:26:24.320]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.320]                     next
[10:26:24.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.320]                 }
[10:26:24.320]                 NAMES <- toupper(added)
[10:26:24.320]                 for (kk in seq_along(NAMES)) {
[10:26:24.320]                   name <- added[[kk]]
[10:26:24.320]                   NAME <- NAMES[[kk]]
[10:26:24.320]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.320]                     next
[10:26:24.320]                   args[[name]] <- ""
[10:26:24.320]                 }
[10:26:24.320]                 NAMES <- toupper(removed)
[10:26:24.320]                 for (kk in seq_along(NAMES)) {
[10:26:24.320]                   name <- removed[[kk]]
[10:26:24.320]                   NAME <- NAMES[[kk]]
[10:26:24.320]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.320]                     next
[10:26:24.320]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.320]                 }
[10:26:24.320]                 if (length(args) > 0) 
[10:26:24.320]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.320]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.320]             }
[10:26:24.320]             else {
[10:26:24.320]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.320]             }
[10:26:24.320]             {
[10:26:24.320]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.320]                   0L) {
[10:26:24.320]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.320]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.320]                   base::options(opts)
[10:26:24.320]                 }
[10:26:24.320]                 {
[10:26:24.320]                   {
[10:26:24.320]                     NULL
[10:26:24.320]                     RNGkind("Mersenne-Twister")
[10:26:24.320]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.320]                       inherits = FALSE)
[10:26:24.320]                   }
[10:26:24.320]                   options(future.plan = NULL)
[10:26:24.320]                   if (is.na(NA_character_)) 
[10:26:24.320]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.320]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.320]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.320]                     envir = parent.frame()) 
[10:26:24.320]                   {
[10:26:24.320]                     default_workers <- missing(workers)
[10:26:24.320]                     if (is.function(workers)) 
[10:26:24.320]                       workers <- workers()
[10:26:24.320]                     workers <- structure(as.integer(workers), 
[10:26:24.320]                       class = class(workers))
[10:26:24.320]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.320]                       1L)
[10:26:24.320]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.320]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.320]                       if (default_workers) 
[10:26:24.320]                         supportsMulticore(warn = TRUE)
[10:26:24.320]                       return(sequential(..., envir = envir))
[10:26:24.320]                     }
[10:26:24.320]                     oopts <- options(mc.cores = workers)
[10:26:24.320]                     on.exit(options(oopts))
[10:26:24.320]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.320]                       envir = envir)
[10:26:24.320]                     if (!future$lazy) 
[10:26:24.320]                       future <- run(future)
[10:26:24.320]                     invisible(future)
[10:26:24.320]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.320]                 }
[10:26:24.320]             }
[10:26:24.320]         }
[10:26:24.320]     })
[10:26:24.320]     if (TRUE) {
[10:26:24.320]         base::sink(type = "output", split = FALSE)
[10:26:24.320]         if (TRUE) {
[10:26:24.320]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.320]         }
[10:26:24.320]         else {
[10:26:24.320]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.320]         }
[10:26:24.320]         base::close(...future.stdout)
[10:26:24.320]         ...future.stdout <- NULL
[10:26:24.320]     }
[10:26:24.320]     ...future.result$conditions <- ...future.conditions
[10:26:24.320]     ...future.result$finished <- base::Sys.time()
[10:26:24.320]     ...future.result
[10:26:24.320] }
[10:26:24.322] assign_globals() ...
[10:26:24.322] List of 1
[10:26:24.322]  $ ii: int 2
[10:26:24.322]  - attr(*, "where")=List of 1
[10:26:24.322]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.322]  - attr(*, "resolved")= logi FALSE
[10:26:24.322]  - attr(*, "total_size")= num 56
[10:26:24.324] - copied ‘ii’ to environment
[10:26:24.324] assign_globals() ... done
[10:26:24.324] plan(): Setting new future strategy stack:
[10:26:24.325] List of future strategies:
[10:26:24.325] 1. sequential:
[10:26:24.325]    - args: function (..., envir = parent.frame())
[10:26:24.325]    - tweaked: FALSE
[10:26:24.325]    - call: NULL
[10:26:24.325] plan(): nbrOfWorkers() = 1
[10:26:24.326] plan(): Setting new future strategy stack:
[10:26:24.326] List of future strategies:
[10:26:24.326] 1. multicore:
[10:26:24.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.326]    - tweaked: FALSE
[10:26:24.326]    - call: plan(multicore)
[10:26:24.329] plan(): nbrOfWorkers() = 1
[10:26:24.329] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[10:26:24.332] getGlobalsAndPackages() ...
[10:26:24.332] Searching for globals...
[10:26:24.333] - globals found: [2] ‘{’, ‘ii’
[10:26:24.333] Searching for globals ... DONE
[10:26:24.333] Resolving globals: FALSE
[10:26:24.334] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.335] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.335] - globals: [1] ‘ii’
[10:26:24.336] 
[10:26:24.336] getGlobalsAndPackages() ... DONE
[10:26:24.336] Packages needed by the future expression (n = 0): <none>
[10:26:24.336] Packages needed by future strategies (n = 0): <none>
[10:26:24.336] {
[10:26:24.336]     {
[10:26:24.336]         {
[10:26:24.336]             ...future.startTime <- base::Sys.time()
[10:26:24.336]             {
[10:26:24.336]                 {
[10:26:24.336]                   {
[10:26:24.336]                     base::local({
[10:26:24.336]                       has_future <- base::requireNamespace("future", 
[10:26:24.336]                         quietly = TRUE)
[10:26:24.336]                       if (has_future) {
[10:26:24.336]                         ns <- base::getNamespace("future")
[10:26:24.336]                         version <- ns[[".package"]][["version"]]
[10:26:24.336]                         if (is.null(version)) 
[10:26:24.336]                           version <- utils::packageVersion("future")
[10:26:24.336]                       }
[10:26:24.336]                       else {
[10:26:24.336]                         version <- NULL
[10:26:24.336]                       }
[10:26:24.336]                       if (!has_future || version < "1.8.0") {
[10:26:24.336]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.336]                           "", base::R.version$version.string), 
[10:26:24.336]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.336]                             "release", "version")], collapse = " "), 
[10:26:24.336]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.336]                           info)
[10:26:24.336]                         info <- base::paste(info, collapse = "; ")
[10:26:24.336]                         if (!has_future) {
[10:26:24.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.336]                             info)
[10:26:24.336]                         }
[10:26:24.336]                         else {
[10:26:24.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.336]                             info, version)
[10:26:24.336]                         }
[10:26:24.336]                         base::stop(msg)
[10:26:24.336]                       }
[10:26:24.336]                     })
[10:26:24.336]                   }
[10:26:24.336]                   options(future.plan = NULL)
[10:26:24.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.336]                 }
[10:26:24.336]                 ...future.workdir <- getwd()
[10:26:24.336]             }
[10:26:24.336]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.336]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.336]         }
[10:26:24.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.336]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.336]             base::names(...future.oldOptions))
[10:26:24.336]     }
[10:26:24.336]     if (FALSE) {
[10:26:24.336]     }
[10:26:24.336]     else {
[10:26:24.336]         if (TRUE) {
[10:26:24.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.336]                 open = "w")
[10:26:24.336]         }
[10:26:24.336]         else {
[10:26:24.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.336]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.336]         }
[10:26:24.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.336]             base::sink(type = "output", split = FALSE)
[10:26:24.336]             base::close(...future.stdout)
[10:26:24.336]         }, add = TRUE)
[10:26:24.336]     }
[10:26:24.336]     ...future.frame <- base::sys.nframe()
[10:26:24.336]     ...future.conditions <- base::list()
[10:26:24.336]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.336]     if (FALSE) {
[10:26:24.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.336]     }
[10:26:24.336]     ...future.result <- base::tryCatch({
[10:26:24.336]         base::withCallingHandlers({
[10:26:24.336]             ...future.value <- base::withVisible(base::local({
[10:26:24.336]                 ii
[10:26:24.336]             }))
[10:26:24.336]             future::FutureResult(value = ...future.value$value, 
[10:26:24.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.336]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.336]                     ...future.globalenv.names))
[10:26:24.336]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.336]         }, condition = base::local({
[10:26:24.336]             c <- base::c
[10:26:24.336]             inherits <- base::inherits
[10:26:24.336]             invokeRestart <- base::invokeRestart
[10:26:24.336]             length <- base::length
[10:26:24.336]             list <- base::list
[10:26:24.336]             seq.int <- base::seq.int
[10:26:24.336]             signalCondition <- base::signalCondition
[10:26:24.336]             sys.calls <- base::sys.calls
[10:26:24.336]             `[[` <- base::`[[`
[10:26:24.336]             `+` <- base::`+`
[10:26:24.336]             `<<-` <- base::`<<-`
[10:26:24.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.336]                   3L)]
[10:26:24.336]             }
[10:26:24.336]             function(cond) {
[10:26:24.336]                 is_error <- inherits(cond, "error")
[10:26:24.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.336]                   NULL)
[10:26:24.336]                 if (is_error) {
[10:26:24.336]                   sessionInformation <- function() {
[10:26:24.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.336]                       search = base::search(), system = base::Sys.info())
[10:26:24.336]                   }
[10:26:24.336]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.336]                     cond$call), session = sessionInformation(), 
[10:26:24.336]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.336]                   signalCondition(cond)
[10:26:24.336]                 }
[10:26:24.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.336]                 "immediateCondition"))) {
[10:26:24.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.336]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.336]                   if (TRUE && !signal) {
[10:26:24.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.336]                     {
[10:26:24.336]                       inherits <- base::inherits
[10:26:24.336]                       invokeRestart <- base::invokeRestart
[10:26:24.336]                       is.null <- base::is.null
[10:26:24.336]                       muffled <- FALSE
[10:26:24.336]                       if (inherits(cond, "message")) {
[10:26:24.336]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.336]                         if (muffled) 
[10:26:24.336]                           invokeRestart("muffleMessage")
[10:26:24.336]                       }
[10:26:24.336]                       else if (inherits(cond, "warning")) {
[10:26:24.336]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.336]                         if (muffled) 
[10:26:24.336]                           invokeRestart("muffleWarning")
[10:26:24.336]                       }
[10:26:24.336]                       else if (inherits(cond, "condition")) {
[10:26:24.336]                         if (!is.null(pattern)) {
[10:26:24.336]                           computeRestarts <- base::computeRestarts
[10:26:24.336]                           grepl <- base::grepl
[10:26:24.336]                           restarts <- computeRestarts(cond)
[10:26:24.336]                           for (restart in restarts) {
[10:26:24.336]                             name <- restart$name
[10:26:24.336]                             if (is.null(name)) 
[10:26:24.336]                               next
[10:26:24.336]                             if (!grepl(pattern, name)) 
[10:26:24.336]                               next
[10:26:24.336]                             invokeRestart(restart)
[10:26:24.336]                             muffled <- TRUE
[10:26:24.336]                             break
[10:26:24.336]                           }
[10:26:24.336]                         }
[10:26:24.336]                       }
[10:26:24.336]                       invisible(muffled)
[10:26:24.336]                     }
[10:26:24.336]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.336]                   }
[10:26:24.336]                 }
[10:26:24.336]                 else {
[10:26:24.336]                   if (TRUE) {
[10:26:24.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.336]                     {
[10:26:24.336]                       inherits <- base::inherits
[10:26:24.336]                       invokeRestart <- base::invokeRestart
[10:26:24.336]                       is.null <- base::is.null
[10:26:24.336]                       muffled <- FALSE
[10:26:24.336]                       if (inherits(cond, "message")) {
[10:26:24.336]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.336]                         if (muffled) 
[10:26:24.336]                           invokeRestart("muffleMessage")
[10:26:24.336]                       }
[10:26:24.336]                       else if (inherits(cond, "warning")) {
[10:26:24.336]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.336]                         if (muffled) 
[10:26:24.336]                           invokeRestart("muffleWarning")
[10:26:24.336]                       }
[10:26:24.336]                       else if (inherits(cond, "condition")) {
[10:26:24.336]                         if (!is.null(pattern)) {
[10:26:24.336]                           computeRestarts <- base::computeRestarts
[10:26:24.336]                           grepl <- base::grepl
[10:26:24.336]                           restarts <- computeRestarts(cond)
[10:26:24.336]                           for (restart in restarts) {
[10:26:24.336]                             name <- restart$name
[10:26:24.336]                             if (is.null(name)) 
[10:26:24.336]                               next
[10:26:24.336]                             if (!grepl(pattern, name)) 
[10:26:24.336]                               next
[10:26:24.336]                             invokeRestart(restart)
[10:26:24.336]                             muffled <- TRUE
[10:26:24.336]                             break
[10:26:24.336]                           }
[10:26:24.336]                         }
[10:26:24.336]                       }
[10:26:24.336]                       invisible(muffled)
[10:26:24.336]                     }
[10:26:24.336]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.336]                   }
[10:26:24.336]                 }
[10:26:24.336]             }
[10:26:24.336]         }))
[10:26:24.336]     }, error = function(ex) {
[10:26:24.336]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.336]                 ...future.rng), started = ...future.startTime, 
[10:26:24.336]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.336]             version = "1.8"), class = "FutureResult")
[10:26:24.336]     }, finally = {
[10:26:24.336]         if (!identical(...future.workdir, getwd())) 
[10:26:24.336]             setwd(...future.workdir)
[10:26:24.336]         {
[10:26:24.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.336]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.336]             }
[10:26:24.336]             base::options(...future.oldOptions)
[10:26:24.336]             if (.Platform$OS.type == "windows") {
[10:26:24.336]                 old_names <- names(...future.oldEnvVars)
[10:26:24.336]                 envs <- base::Sys.getenv()
[10:26:24.336]                 names <- names(envs)
[10:26:24.336]                 common <- intersect(names, old_names)
[10:26:24.336]                 added <- setdiff(names, old_names)
[10:26:24.336]                 removed <- setdiff(old_names, names)
[10:26:24.336]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.336]                   envs[common]]
[10:26:24.336]                 NAMES <- toupper(changed)
[10:26:24.336]                 args <- list()
[10:26:24.336]                 for (kk in seq_along(NAMES)) {
[10:26:24.336]                   name <- changed[[kk]]
[10:26:24.336]                   NAME <- NAMES[[kk]]
[10:26:24.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.336]                     next
[10:26:24.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.336]                 }
[10:26:24.336]                 NAMES <- toupper(added)
[10:26:24.336]                 for (kk in seq_along(NAMES)) {
[10:26:24.336]                   name <- added[[kk]]
[10:26:24.336]                   NAME <- NAMES[[kk]]
[10:26:24.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.336]                     next
[10:26:24.336]                   args[[name]] <- ""
[10:26:24.336]                 }
[10:26:24.336]                 NAMES <- toupper(removed)
[10:26:24.336]                 for (kk in seq_along(NAMES)) {
[10:26:24.336]                   name <- removed[[kk]]
[10:26:24.336]                   NAME <- NAMES[[kk]]
[10:26:24.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.336]                     next
[10:26:24.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.336]                 }
[10:26:24.336]                 if (length(args) > 0) 
[10:26:24.336]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.336]             }
[10:26:24.336]             else {
[10:26:24.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.336]             }
[10:26:24.336]             {
[10:26:24.336]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.336]                   0L) {
[10:26:24.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.336]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.336]                   base::options(opts)
[10:26:24.336]                 }
[10:26:24.336]                 {
[10:26:24.336]                   {
[10:26:24.336]                     NULL
[10:26:24.336]                     RNGkind("Mersenne-Twister")
[10:26:24.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.336]                       inherits = FALSE)
[10:26:24.336]                   }
[10:26:24.336]                   options(future.plan = NULL)
[10:26:24.336]                   if (is.na(NA_character_)) 
[10:26:24.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.336]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.336]                     envir = parent.frame()) 
[10:26:24.336]                   {
[10:26:24.336]                     default_workers <- missing(workers)
[10:26:24.336]                     if (is.function(workers)) 
[10:26:24.336]                       workers <- workers()
[10:26:24.336]                     workers <- structure(as.integer(workers), 
[10:26:24.336]                       class = class(workers))
[10:26:24.336]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.336]                       1L)
[10:26:24.336]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.336]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.336]                       if (default_workers) 
[10:26:24.336]                         supportsMulticore(warn = TRUE)
[10:26:24.336]                       return(sequential(..., envir = envir))
[10:26:24.336]                     }
[10:26:24.336]                     oopts <- options(mc.cores = workers)
[10:26:24.336]                     on.exit(options(oopts))
[10:26:24.336]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.336]                       envir = envir)
[10:26:24.336]                     if (!future$lazy) 
[10:26:24.336]                       future <- run(future)
[10:26:24.336]                     invisible(future)
[10:26:24.336]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.336]                 }
[10:26:24.336]             }
[10:26:24.336]         }
[10:26:24.336]     })
[10:26:24.336]     if (TRUE) {
[10:26:24.336]         base::sink(type = "output", split = FALSE)
[10:26:24.336]         if (TRUE) {
[10:26:24.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.336]         }
[10:26:24.336]         else {
[10:26:24.336]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.336]         }
[10:26:24.336]         base::close(...future.stdout)
[10:26:24.336]         ...future.stdout <- NULL
[10:26:24.336]     }
[10:26:24.336]     ...future.result$conditions <- ...future.conditions
[10:26:24.336]     ...future.result$finished <- base::Sys.time()
[10:26:24.336]     ...future.result
[10:26:24.336] }
[10:26:24.338] assign_globals() ...
[10:26:24.338] List of 1
[10:26:24.338]  $ ii: int 3
[10:26:24.338]  - attr(*, "where")=List of 1
[10:26:24.338]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.338]  - attr(*, "resolved")= logi FALSE
[10:26:24.338]  - attr(*, "total_size")= num 56
[10:26:24.340] - copied ‘ii’ to environment
[10:26:24.340] assign_globals() ... done
[10:26:24.341] plan(): Setting new future strategy stack:
[10:26:24.341] List of future strategies:
[10:26:24.341] 1. sequential:
[10:26:24.341]    - args: function (..., envir = parent.frame())
[10:26:24.341]    - tweaked: FALSE
[10:26:24.341]    - call: NULL
[10:26:24.341] plan(): nbrOfWorkers() = 1
[10:26:24.342] plan(): Setting new future strategy stack:
[10:26:24.342] List of future strategies:
[10:26:24.342] 1. multicore:
[10:26:24.342]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.342]    - tweaked: FALSE
[10:26:24.342]    - call: plan(multicore)
[10:26:24.345] plan(): nbrOfWorkers() = 1
[10:26:24.345] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[10:26:24.348] getGlobalsAndPackages() ...
[10:26:24.348] Searching for globals...
[10:26:24.349] - globals found: [2] ‘{’, ‘ii’
[10:26:24.349] Searching for globals ... DONE
[10:26:24.349] Resolving globals: FALSE
[10:26:24.350] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.350] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.350] - globals: [1] ‘ii’
[10:26:24.350] 
[10:26:24.350] getGlobalsAndPackages() ... DONE
[10:26:24.351] Packages needed by the future expression (n = 0): <none>
[10:26:24.351] Packages needed by future strategies (n = 0): <none>
[10:26:24.351] {
[10:26:24.351]     {
[10:26:24.351]         {
[10:26:24.351]             ...future.startTime <- base::Sys.time()
[10:26:24.351]             {
[10:26:24.351]                 {
[10:26:24.351]                   {
[10:26:24.351]                     base::local({
[10:26:24.351]                       has_future <- base::requireNamespace("future", 
[10:26:24.351]                         quietly = TRUE)
[10:26:24.351]                       if (has_future) {
[10:26:24.351]                         ns <- base::getNamespace("future")
[10:26:24.351]                         version <- ns[[".package"]][["version"]]
[10:26:24.351]                         if (is.null(version)) 
[10:26:24.351]                           version <- utils::packageVersion("future")
[10:26:24.351]                       }
[10:26:24.351]                       else {
[10:26:24.351]                         version <- NULL
[10:26:24.351]                       }
[10:26:24.351]                       if (!has_future || version < "1.8.0") {
[10:26:24.351]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.351]                           "", base::R.version$version.string), 
[10:26:24.351]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.351]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.351]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.351]                             "release", "version")], collapse = " "), 
[10:26:24.351]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.351]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.351]                           info)
[10:26:24.351]                         info <- base::paste(info, collapse = "; ")
[10:26:24.351]                         if (!has_future) {
[10:26:24.351]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.351]                             info)
[10:26:24.351]                         }
[10:26:24.351]                         else {
[10:26:24.351]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.351]                             info, version)
[10:26:24.351]                         }
[10:26:24.351]                         base::stop(msg)
[10:26:24.351]                       }
[10:26:24.351]                     })
[10:26:24.351]                   }
[10:26:24.351]                   options(future.plan = NULL)
[10:26:24.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.351]                 }
[10:26:24.351]                 ...future.workdir <- getwd()
[10:26:24.351]             }
[10:26:24.351]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.351]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.351]         }
[10:26:24.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.351]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.351]             base::names(...future.oldOptions))
[10:26:24.351]     }
[10:26:24.351]     if (FALSE) {
[10:26:24.351]     }
[10:26:24.351]     else {
[10:26:24.351]         if (TRUE) {
[10:26:24.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.351]                 open = "w")
[10:26:24.351]         }
[10:26:24.351]         else {
[10:26:24.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.351]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.351]         }
[10:26:24.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.351]             base::sink(type = "output", split = FALSE)
[10:26:24.351]             base::close(...future.stdout)
[10:26:24.351]         }, add = TRUE)
[10:26:24.351]     }
[10:26:24.351]     ...future.frame <- base::sys.nframe()
[10:26:24.351]     ...future.conditions <- base::list()
[10:26:24.351]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.351]     if (FALSE) {
[10:26:24.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.351]     }
[10:26:24.351]     ...future.result <- base::tryCatch({
[10:26:24.351]         base::withCallingHandlers({
[10:26:24.351]             ...future.value <- base::withVisible(base::local({
[10:26:24.351]                 ii
[10:26:24.351]             }))
[10:26:24.351]             future::FutureResult(value = ...future.value$value, 
[10:26:24.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.351]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.351]                     ...future.globalenv.names))
[10:26:24.351]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.351]         }, condition = base::local({
[10:26:24.351]             c <- base::c
[10:26:24.351]             inherits <- base::inherits
[10:26:24.351]             invokeRestart <- base::invokeRestart
[10:26:24.351]             length <- base::length
[10:26:24.351]             list <- base::list
[10:26:24.351]             seq.int <- base::seq.int
[10:26:24.351]             signalCondition <- base::signalCondition
[10:26:24.351]             sys.calls <- base::sys.calls
[10:26:24.351]             `[[` <- base::`[[`
[10:26:24.351]             `+` <- base::`+`
[10:26:24.351]             `<<-` <- base::`<<-`
[10:26:24.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.351]                   3L)]
[10:26:24.351]             }
[10:26:24.351]             function(cond) {
[10:26:24.351]                 is_error <- inherits(cond, "error")
[10:26:24.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.351]                   NULL)
[10:26:24.351]                 if (is_error) {
[10:26:24.351]                   sessionInformation <- function() {
[10:26:24.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.351]                       search = base::search(), system = base::Sys.info())
[10:26:24.351]                   }
[10:26:24.351]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.351]                     cond$call), session = sessionInformation(), 
[10:26:24.351]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.351]                   signalCondition(cond)
[10:26:24.351]                 }
[10:26:24.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.351]                 "immediateCondition"))) {
[10:26:24.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.351]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.351]                   if (TRUE && !signal) {
[10:26:24.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.351]                     {
[10:26:24.351]                       inherits <- base::inherits
[10:26:24.351]                       invokeRestart <- base::invokeRestart
[10:26:24.351]                       is.null <- base::is.null
[10:26:24.351]                       muffled <- FALSE
[10:26:24.351]                       if (inherits(cond, "message")) {
[10:26:24.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.351]                         if (muffled) 
[10:26:24.351]                           invokeRestart("muffleMessage")
[10:26:24.351]                       }
[10:26:24.351]                       else if (inherits(cond, "warning")) {
[10:26:24.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.351]                         if (muffled) 
[10:26:24.351]                           invokeRestart("muffleWarning")
[10:26:24.351]                       }
[10:26:24.351]                       else if (inherits(cond, "condition")) {
[10:26:24.351]                         if (!is.null(pattern)) {
[10:26:24.351]                           computeRestarts <- base::computeRestarts
[10:26:24.351]                           grepl <- base::grepl
[10:26:24.351]                           restarts <- computeRestarts(cond)
[10:26:24.351]                           for (restart in restarts) {
[10:26:24.351]                             name <- restart$name
[10:26:24.351]                             if (is.null(name)) 
[10:26:24.351]                               next
[10:26:24.351]                             if (!grepl(pattern, name)) 
[10:26:24.351]                               next
[10:26:24.351]                             invokeRestart(restart)
[10:26:24.351]                             muffled <- TRUE
[10:26:24.351]                             break
[10:26:24.351]                           }
[10:26:24.351]                         }
[10:26:24.351]                       }
[10:26:24.351]                       invisible(muffled)
[10:26:24.351]                     }
[10:26:24.351]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.351]                   }
[10:26:24.351]                 }
[10:26:24.351]                 else {
[10:26:24.351]                   if (TRUE) {
[10:26:24.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.351]                     {
[10:26:24.351]                       inherits <- base::inherits
[10:26:24.351]                       invokeRestart <- base::invokeRestart
[10:26:24.351]                       is.null <- base::is.null
[10:26:24.351]                       muffled <- FALSE
[10:26:24.351]                       if (inherits(cond, "message")) {
[10:26:24.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.351]                         if (muffled) 
[10:26:24.351]                           invokeRestart("muffleMessage")
[10:26:24.351]                       }
[10:26:24.351]                       else if (inherits(cond, "warning")) {
[10:26:24.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.351]                         if (muffled) 
[10:26:24.351]                           invokeRestart("muffleWarning")
[10:26:24.351]                       }
[10:26:24.351]                       else if (inherits(cond, "condition")) {
[10:26:24.351]                         if (!is.null(pattern)) {
[10:26:24.351]                           computeRestarts <- base::computeRestarts
[10:26:24.351]                           grepl <- base::grepl
[10:26:24.351]                           restarts <- computeRestarts(cond)
[10:26:24.351]                           for (restart in restarts) {
[10:26:24.351]                             name <- restart$name
[10:26:24.351]                             if (is.null(name)) 
[10:26:24.351]                               next
[10:26:24.351]                             if (!grepl(pattern, name)) 
[10:26:24.351]                               next
[10:26:24.351]                             invokeRestart(restart)
[10:26:24.351]                             muffled <- TRUE
[10:26:24.351]                             break
[10:26:24.351]                           }
[10:26:24.351]                         }
[10:26:24.351]                       }
[10:26:24.351]                       invisible(muffled)
[10:26:24.351]                     }
[10:26:24.351]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.351]                   }
[10:26:24.351]                 }
[10:26:24.351]             }
[10:26:24.351]         }))
[10:26:24.351]     }, error = function(ex) {
[10:26:24.351]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.351]                 ...future.rng), started = ...future.startTime, 
[10:26:24.351]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.351]             version = "1.8"), class = "FutureResult")
[10:26:24.351]     }, finally = {
[10:26:24.351]         if (!identical(...future.workdir, getwd())) 
[10:26:24.351]             setwd(...future.workdir)
[10:26:24.351]         {
[10:26:24.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.351]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.351]             }
[10:26:24.351]             base::options(...future.oldOptions)
[10:26:24.351]             if (.Platform$OS.type == "windows") {
[10:26:24.351]                 old_names <- names(...future.oldEnvVars)
[10:26:24.351]                 envs <- base::Sys.getenv()
[10:26:24.351]                 names <- names(envs)
[10:26:24.351]                 common <- intersect(names, old_names)
[10:26:24.351]                 added <- setdiff(names, old_names)
[10:26:24.351]                 removed <- setdiff(old_names, names)
[10:26:24.351]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.351]                   envs[common]]
[10:26:24.351]                 NAMES <- toupper(changed)
[10:26:24.351]                 args <- list()
[10:26:24.351]                 for (kk in seq_along(NAMES)) {
[10:26:24.351]                   name <- changed[[kk]]
[10:26:24.351]                   NAME <- NAMES[[kk]]
[10:26:24.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.351]                     next
[10:26:24.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.351]                 }
[10:26:24.351]                 NAMES <- toupper(added)
[10:26:24.351]                 for (kk in seq_along(NAMES)) {
[10:26:24.351]                   name <- added[[kk]]
[10:26:24.351]                   NAME <- NAMES[[kk]]
[10:26:24.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.351]                     next
[10:26:24.351]                   args[[name]] <- ""
[10:26:24.351]                 }
[10:26:24.351]                 NAMES <- toupper(removed)
[10:26:24.351]                 for (kk in seq_along(NAMES)) {
[10:26:24.351]                   name <- removed[[kk]]
[10:26:24.351]                   NAME <- NAMES[[kk]]
[10:26:24.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.351]                     next
[10:26:24.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.351]                 }
[10:26:24.351]                 if (length(args) > 0) 
[10:26:24.351]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.351]             }
[10:26:24.351]             else {
[10:26:24.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.351]             }
[10:26:24.351]             {
[10:26:24.351]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.351]                   0L) {
[10:26:24.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.351]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.351]                   base::options(opts)
[10:26:24.351]                 }
[10:26:24.351]                 {
[10:26:24.351]                   {
[10:26:24.351]                     NULL
[10:26:24.351]                     RNGkind("Mersenne-Twister")
[10:26:24.351]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.351]                       inherits = FALSE)
[10:26:24.351]                   }
[10:26:24.351]                   options(future.plan = NULL)
[10:26:24.351]                   if (is.na(NA_character_)) 
[10:26:24.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.351]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.351]                     envir = parent.frame()) 
[10:26:24.351]                   {
[10:26:24.351]                     default_workers <- missing(workers)
[10:26:24.351]                     if (is.function(workers)) 
[10:26:24.351]                       workers <- workers()
[10:26:24.351]                     workers <- structure(as.integer(workers), 
[10:26:24.351]                       class = class(workers))
[10:26:24.351]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.351]                       1L)
[10:26:24.351]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.351]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.351]                       if (default_workers) 
[10:26:24.351]                         supportsMulticore(warn = TRUE)
[10:26:24.351]                       return(sequential(..., envir = envir))
[10:26:24.351]                     }
[10:26:24.351]                     oopts <- options(mc.cores = workers)
[10:26:24.351]                     on.exit(options(oopts))
[10:26:24.351]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.351]                       envir = envir)
[10:26:24.351]                     if (!future$lazy) 
[10:26:24.351]                       future <- run(future)
[10:26:24.351]                     invisible(future)
[10:26:24.351]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.351]                 }
[10:26:24.351]             }
[10:26:24.351]         }
[10:26:24.351]     })
[10:26:24.351]     if (TRUE) {
[10:26:24.351]         base::sink(type = "output", split = FALSE)
[10:26:24.351]         if (TRUE) {
[10:26:24.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.351]         }
[10:26:24.351]         else {
[10:26:24.351]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.351]         }
[10:26:24.351]         base::close(...future.stdout)
[10:26:24.351]         ...future.stdout <- NULL
[10:26:24.351]     }
[10:26:24.351]     ...future.result$conditions <- ...future.conditions
[10:26:24.351]     ...future.result$finished <- base::Sys.time()
[10:26:24.351]     ...future.result
[10:26:24.351] }
[10:26:24.353] assign_globals() ...
[10:26:24.353] List of 1
[10:26:24.353]  $ ii: int 4
[10:26:24.353]  - attr(*, "where")=List of 1
[10:26:24.353]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.353]  - attr(*, "resolved")= logi FALSE
[10:26:24.353]  - attr(*, "total_size")= num 56
[10:26:24.355] - copied ‘ii’ to environment
[10:26:24.355] assign_globals() ... done
[10:26:24.355] plan(): Setting new future strategy stack:
[10:26:24.355] List of future strategies:
[10:26:24.355] 1. sequential:
[10:26:24.355]    - args: function (..., envir = parent.frame())
[10:26:24.355]    - tweaked: FALSE
[10:26:24.355]    - call: NULL
[10:26:24.356] plan(): nbrOfWorkers() = 1
[10:26:24.356] plan(): Setting new future strategy stack:
[10:26:24.356] List of future strategies:
[10:26:24.356] 1. multicore:
[10:26:24.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.356]    - tweaked: FALSE
[10:26:24.356]    - call: plan(multicore)
[10:26:24.360] plan(): nbrOfWorkers() = 1
[10:26:24.360] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[10:26:24.364] getGlobalsAndPackages() ...
[10:26:24.364] Searching for globals...
[10:26:24.364] - globals found: [2] ‘{’, ‘stop’
[10:26:24.365] Searching for globals ... DONE
[10:26:24.365] Resolving globals: FALSE
[10:26:24.365] 
[10:26:24.365] 
[10:26:24.365] getGlobalsAndPackages() ... DONE
[10:26:24.366] Packages needed by the future expression (n = 0): <none>
[10:26:24.366] Packages needed by future strategies (n = 0): <none>
[10:26:24.366] {
[10:26:24.366]     {
[10:26:24.366]         {
[10:26:24.366]             ...future.startTime <- base::Sys.time()
[10:26:24.366]             {
[10:26:24.366]                 {
[10:26:24.366]                   {
[10:26:24.366]                     base::local({
[10:26:24.366]                       has_future <- base::requireNamespace("future", 
[10:26:24.366]                         quietly = TRUE)
[10:26:24.366]                       if (has_future) {
[10:26:24.366]                         ns <- base::getNamespace("future")
[10:26:24.366]                         version <- ns[[".package"]][["version"]]
[10:26:24.366]                         if (is.null(version)) 
[10:26:24.366]                           version <- utils::packageVersion("future")
[10:26:24.366]                       }
[10:26:24.366]                       else {
[10:26:24.366]                         version <- NULL
[10:26:24.366]                       }
[10:26:24.366]                       if (!has_future || version < "1.8.0") {
[10:26:24.366]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.366]                           "", base::R.version$version.string), 
[10:26:24.366]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.366]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.366]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.366]                             "release", "version")], collapse = " "), 
[10:26:24.366]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.366]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.366]                           info)
[10:26:24.366]                         info <- base::paste(info, collapse = "; ")
[10:26:24.366]                         if (!has_future) {
[10:26:24.366]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.366]                             info)
[10:26:24.366]                         }
[10:26:24.366]                         else {
[10:26:24.366]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.366]                             info, version)
[10:26:24.366]                         }
[10:26:24.366]                         base::stop(msg)
[10:26:24.366]                       }
[10:26:24.366]                     })
[10:26:24.366]                   }
[10:26:24.366]                   options(future.plan = NULL)
[10:26:24.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.366]                 }
[10:26:24.366]                 ...future.workdir <- getwd()
[10:26:24.366]             }
[10:26:24.366]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.366]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.366]         }
[10:26:24.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.366]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.366]             base::names(...future.oldOptions))
[10:26:24.366]     }
[10:26:24.366]     if (FALSE) {
[10:26:24.366]     }
[10:26:24.366]     else {
[10:26:24.366]         if (TRUE) {
[10:26:24.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.366]                 open = "w")
[10:26:24.366]         }
[10:26:24.366]         else {
[10:26:24.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.366]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.366]         }
[10:26:24.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.366]             base::sink(type = "output", split = FALSE)
[10:26:24.366]             base::close(...future.stdout)
[10:26:24.366]         }, add = TRUE)
[10:26:24.366]     }
[10:26:24.366]     ...future.frame <- base::sys.nframe()
[10:26:24.366]     ...future.conditions <- base::list()
[10:26:24.366]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.366]     if (FALSE) {
[10:26:24.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.366]     }
[10:26:24.366]     ...future.result <- base::tryCatch({
[10:26:24.366]         base::withCallingHandlers({
[10:26:24.366]             ...future.value <- base::withVisible(base::local({
[10:26:24.366]                 stop("Whoops!")
[10:26:24.366]                 1
[10:26:24.366]             }))
[10:26:24.366]             future::FutureResult(value = ...future.value$value, 
[10:26:24.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.366]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.366]                     ...future.globalenv.names))
[10:26:24.366]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.366]         }, condition = base::local({
[10:26:24.366]             c <- base::c
[10:26:24.366]             inherits <- base::inherits
[10:26:24.366]             invokeRestart <- base::invokeRestart
[10:26:24.366]             length <- base::length
[10:26:24.366]             list <- base::list
[10:26:24.366]             seq.int <- base::seq.int
[10:26:24.366]             signalCondition <- base::signalCondition
[10:26:24.366]             sys.calls <- base::sys.calls
[10:26:24.366]             `[[` <- base::`[[`
[10:26:24.366]             `+` <- base::`+`
[10:26:24.366]             `<<-` <- base::`<<-`
[10:26:24.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.366]                   3L)]
[10:26:24.366]             }
[10:26:24.366]             function(cond) {
[10:26:24.366]                 is_error <- inherits(cond, "error")
[10:26:24.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.366]                   NULL)
[10:26:24.366]                 if (is_error) {
[10:26:24.366]                   sessionInformation <- function() {
[10:26:24.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.366]                       search = base::search(), system = base::Sys.info())
[10:26:24.366]                   }
[10:26:24.366]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.366]                     cond$call), session = sessionInformation(), 
[10:26:24.366]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.366]                   signalCondition(cond)
[10:26:24.366]                 }
[10:26:24.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.366]                 "immediateCondition"))) {
[10:26:24.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.366]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.366]                   if (TRUE && !signal) {
[10:26:24.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.366]                     {
[10:26:24.366]                       inherits <- base::inherits
[10:26:24.366]                       invokeRestart <- base::invokeRestart
[10:26:24.366]                       is.null <- base::is.null
[10:26:24.366]                       muffled <- FALSE
[10:26:24.366]                       if (inherits(cond, "message")) {
[10:26:24.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.366]                         if (muffled) 
[10:26:24.366]                           invokeRestart("muffleMessage")
[10:26:24.366]                       }
[10:26:24.366]                       else if (inherits(cond, "warning")) {
[10:26:24.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.366]                         if (muffled) 
[10:26:24.366]                           invokeRestart("muffleWarning")
[10:26:24.366]                       }
[10:26:24.366]                       else if (inherits(cond, "condition")) {
[10:26:24.366]                         if (!is.null(pattern)) {
[10:26:24.366]                           computeRestarts <- base::computeRestarts
[10:26:24.366]                           grepl <- base::grepl
[10:26:24.366]                           restarts <- computeRestarts(cond)
[10:26:24.366]                           for (restart in restarts) {
[10:26:24.366]                             name <- restart$name
[10:26:24.366]                             if (is.null(name)) 
[10:26:24.366]                               next
[10:26:24.366]                             if (!grepl(pattern, name)) 
[10:26:24.366]                               next
[10:26:24.366]                             invokeRestart(restart)
[10:26:24.366]                             muffled <- TRUE
[10:26:24.366]                             break
[10:26:24.366]                           }
[10:26:24.366]                         }
[10:26:24.366]                       }
[10:26:24.366]                       invisible(muffled)
[10:26:24.366]                     }
[10:26:24.366]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.366]                   }
[10:26:24.366]                 }
[10:26:24.366]                 else {
[10:26:24.366]                   if (TRUE) {
[10:26:24.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.366]                     {
[10:26:24.366]                       inherits <- base::inherits
[10:26:24.366]                       invokeRestart <- base::invokeRestart
[10:26:24.366]                       is.null <- base::is.null
[10:26:24.366]                       muffled <- FALSE
[10:26:24.366]                       if (inherits(cond, "message")) {
[10:26:24.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.366]                         if (muffled) 
[10:26:24.366]                           invokeRestart("muffleMessage")
[10:26:24.366]                       }
[10:26:24.366]                       else if (inherits(cond, "warning")) {
[10:26:24.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.366]                         if (muffled) 
[10:26:24.366]                           invokeRestart("muffleWarning")
[10:26:24.366]                       }
[10:26:24.366]                       else if (inherits(cond, "condition")) {
[10:26:24.366]                         if (!is.null(pattern)) {
[10:26:24.366]                           computeRestarts <- base::computeRestarts
[10:26:24.366]                           grepl <- base::grepl
[10:26:24.366]                           restarts <- computeRestarts(cond)
[10:26:24.366]                           for (restart in restarts) {
[10:26:24.366]                             name <- restart$name
[10:26:24.366]                             if (is.null(name)) 
[10:26:24.366]                               next
[10:26:24.366]                             if (!grepl(pattern, name)) 
[10:26:24.366]                               next
[10:26:24.366]                             invokeRestart(restart)
[10:26:24.366]                             muffled <- TRUE
[10:26:24.366]                             break
[10:26:24.366]                           }
[10:26:24.366]                         }
[10:26:24.366]                       }
[10:26:24.366]                       invisible(muffled)
[10:26:24.366]                     }
[10:26:24.366]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.366]                   }
[10:26:24.366]                 }
[10:26:24.366]             }
[10:26:24.366]         }))
[10:26:24.366]     }, error = function(ex) {
[10:26:24.366]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.366]                 ...future.rng), started = ...future.startTime, 
[10:26:24.366]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.366]             version = "1.8"), class = "FutureResult")
[10:26:24.366]     }, finally = {
[10:26:24.366]         if (!identical(...future.workdir, getwd())) 
[10:26:24.366]             setwd(...future.workdir)
[10:26:24.366]         {
[10:26:24.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.366]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.366]             }
[10:26:24.366]             base::options(...future.oldOptions)
[10:26:24.366]             if (.Platform$OS.type == "windows") {
[10:26:24.366]                 old_names <- names(...future.oldEnvVars)
[10:26:24.366]                 envs <- base::Sys.getenv()
[10:26:24.366]                 names <- names(envs)
[10:26:24.366]                 common <- intersect(names, old_names)
[10:26:24.366]                 added <- setdiff(names, old_names)
[10:26:24.366]                 removed <- setdiff(old_names, names)
[10:26:24.366]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.366]                   envs[common]]
[10:26:24.366]                 NAMES <- toupper(changed)
[10:26:24.366]                 args <- list()
[10:26:24.366]                 for (kk in seq_along(NAMES)) {
[10:26:24.366]                   name <- changed[[kk]]
[10:26:24.366]                   NAME <- NAMES[[kk]]
[10:26:24.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.366]                     next
[10:26:24.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.366]                 }
[10:26:24.366]                 NAMES <- toupper(added)
[10:26:24.366]                 for (kk in seq_along(NAMES)) {
[10:26:24.366]                   name <- added[[kk]]
[10:26:24.366]                   NAME <- NAMES[[kk]]
[10:26:24.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.366]                     next
[10:26:24.366]                   args[[name]] <- ""
[10:26:24.366]                 }
[10:26:24.366]                 NAMES <- toupper(removed)
[10:26:24.366]                 for (kk in seq_along(NAMES)) {
[10:26:24.366]                   name <- removed[[kk]]
[10:26:24.366]                   NAME <- NAMES[[kk]]
[10:26:24.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.366]                     next
[10:26:24.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.366]                 }
[10:26:24.366]                 if (length(args) > 0) 
[10:26:24.366]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.366]             }
[10:26:24.366]             else {
[10:26:24.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.366]             }
[10:26:24.366]             {
[10:26:24.366]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.366]                   0L) {
[10:26:24.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.366]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.366]                   base::options(opts)
[10:26:24.366]                 }
[10:26:24.366]                 {
[10:26:24.366]                   {
[10:26:24.366]                     NULL
[10:26:24.366]                     RNGkind("Mersenne-Twister")
[10:26:24.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.366]                       inherits = FALSE)
[10:26:24.366]                   }
[10:26:24.366]                   options(future.plan = NULL)
[10:26:24.366]                   if (is.na(NA_character_)) 
[10:26:24.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.366]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.366]                     envir = parent.frame()) 
[10:26:24.366]                   {
[10:26:24.366]                     default_workers <- missing(workers)
[10:26:24.366]                     if (is.function(workers)) 
[10:26:24.366]                       workers <- workers()
[10:26:24.366]                     workers <- structure(as.integer(workers), 
[10:26:24.366]                       class = class(workers))
[10:26:24.366]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.366]                       1L)
[10:26:24.366]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.366]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.366]                       if (default_workers) 
[10:26:24.366]                         supportsMulticore(warn = TRUE)
[10:26:24.366]                       return(sequential(..., envir = envir))
[10:26:24.366]                     }
[10:26:24.366]                     oopts <- options(mc.cores = workers)
[10:26:24.366]                     on.exit(options(oopts))
[10:26:24.366]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.366]                       envir = envir)
[10:26:24.366]                     if (!future$lazy) 
[10:26:24.366]                       future <- run(future)
[10:26:24.366]                     invisible(future)
[10:26:24.366]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.366]                 }
[10:26:24.366]             }
[10:26:24.366]         }
[10:26:24.366]     })
[10:26:24.366]     if (TRUE) {
[10:26:24.366]         base::sink(type = "output", split = FALSE)
[10:26:24.366]         if (TRUE) {
[10:26:24.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.366]         }
[10:26:24.366]         else {
[10:26:24.366]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.366]         }
[10:26:24.366]         base::close(...future.stdout)
[10:26:24.366]         ...future.stdout <- NULL
[10:26:24.366]     }
[10:26:24.366]     ...future.result$conditions <- ...future.conditions
[10:26:24.366]     ...future.result$finished <- base::Sys.time()
[10:26:24.366]     ...future.result
[10:26:24.366] }
[10:26:24.368] plan(): Setting new future strategy stack:
[10:26:24.368] List of future strategies:
[10:26:24.368] 1. sequential:
[10:26:24.368]    - args: function (..., envir = parent.frame())
[10:26:24.368]    - tweaked: FALSE
[10:26:24.368]    - call: NULL
[10:26:24.368] plan(): nbrOfWorkers() = 1
[10:26:24.369] plan(): Setting new future strategy stack:
[10:26:24.369] List of future strategies:
[10:26:24.369] 1. multicore:
[10:26:24.369]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.369]    - tweaked: FALSE
[10:26:24.369]    - call: plan(multicore)
[10:26:24.373] plan(): nbrOfWorkers() = 1
[10:26:24.373] SequentialFuture started (and completed)
[10:26:24.373] signalConditions() ...
[10:26:24.373]  - include = ‘immediateCondition’
[10:26:24.373]  - exclude = 
[10:26:24.373]  - resignal = FALSE
[10:26:24.374]  - Number of conditions: 1
[10:26:24.374] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:24.374] signalConditions() ...
[10:26:24.374]  - include = ‘immediateCondition’
[10:26:24.375]  - exclude = 
[10:26:24.375]  - resignal = FALSE
[10:26:24.375]  - Number of conditions: 1
[10:26:24.375] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.375] signalConditions() ...
[10:26:24.377]  - include = ‘immediateCondition’
[10:26:24.377]  - exclude = 
[10:26:24.377]  - resignal = FALSE
[10:26:24.377]  - Number of conditions: 1
[10:26:24.377] signalConditions() ... done
[10:26:24.377] Future state: ‘finished’
[10:26:24.377] signalConditions() ...
[10:26:24.377]  - include = ‘condition’
[10:26:24.377]  - exclude = ‘immediateCondition’
[10:26:24.378]  - resignal = TRUE
[10:26:24.378]  - Number of conditions: 1
[10:26:24.378]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.378] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.378] signalConditions() ...
[10:26:24.378]  - include = ‘immediateCondition’
[10:26:24.378]  - exclude = 
[10:26:24.379]  - resignal = FALSE
[10:26:24.379]  - Number of conditions: 1
[10:26:24.379] signalConditions() ... done
[10:26:24.379] Future state: ‘finished’
[10:26:24.379] signalConditions() ...
[10:26:24.379]  - include = ‘condition’
[10:26:24.379]  - exclude = ‘immediateCondition’
[10:26:24.379]  - resignal = TRUE
[10:26:24.379]  - Number of conditions: 1
[10:26:24.379]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.379] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:26:24.383] getGlobalsAndPackages() ...
[10:26:24.383] Searching for globals...
[10:26:24.384] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:26:24.384] Searching for globals ... DONE
[10:26:24.384] Resolving globals: FALSE
[10:26:24.385] 
[10:26:24.385] 
[10:26:24.385] getGlobalsAndPackages() ... DONE
[10:26:24.385] Packages needed by the future expression (n = 0): <none>
[10:26:24.385] Packages needed by future strategies (n = 0): <none>
[10:26:24.386] {
[10:26:24.386]     {
[10:26:24.386]         {
[10:26:24.386]             ...future.startTime <- base::Sys.time()
[10:26:24.386]             {
[10:26:24.386]                 {
[10:26:24.386]                   {
[10:26:24.386]                     base::local({
[10:26:24.386]                       has_future <- base::requireNamespace("future", 
[10:26:24.386]                         quietly = TRUE)
[10:26:24.386]                       if (has_future) {
[10:26:24.386]                         ns <- base::getNamespace("future")
[10:26:24.386]                         version <- ns[[".package"]][["version"]]
[10:26:24.386]                         if (is.null(version)) 
[10:26:24.386]                           version <- utils::packageVersion("future")
[10:26:24.386]                       }
[10:26:24.386]                       else {
[10:26:24.386]                         version <- NULL
[10:26:24.386]                       }
[10:26:24.386]                       if (!has_future || version < "1.8.0") {
[10:26:24.386]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.386]                           "", base::R.version$version.string), 
[10:26:24.386]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.386]                             "release", "version")], collapse = " "), 
[10:26:24.386]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.386]                           info)
[10:26:24.386]                         info <- base::paste(info, collapse = "; ")
[10:26:24.386]                         if (!has_future) {
[10:26:24.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.386]                             info)
[10:26:24.386]                         }
[10:26:24.386]                         else {
[10:26:24.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.386]                             info, version)
[10:26:24.386]                         }
[10:26:24.386]                         base::stop(msg)
[10:26:24.386]                       }
[10:26:24.386]                     })
[10:26:24.386]                   }
[10:26:24.386]                   options(future.plan = NULL)
[10:26:24.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.386]                 }
[10:26:24.386]                 ...future.workdir <- getwd()
[10:26:24.386]             }
[10:26:24.386]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.386]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.386]         }
[10:26:24.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.386]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.386]             base::names(...future.oldOptions))
[10:26:24.386]     }
[10:26:24.386]     if (FALSE) {
[10:26:24.386]     }
[10:26:24.386]     else {
[10:26:24.386]         if (TRUE) {
[10:26:24.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.386]                 open = "w")
[10:26:24.386]         }
[10:26:24.386]         else {
[10:26:24.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.386]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.386]         }
[10:26:24.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.386]             base::sink(type = "output", split = FALSE)
[10:26:24.386]             base::close(...future.stdout)
[10:26:24.386]         }, add = TRUE)
[10:26:24.386]     }
[10:26:24.386]     ...future.frame <- base::sys.nframe()
[10:26:24.386]     ...future.conditions <- base::list()
[10:26:24.386]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.386]     if (FALSE) {
[10:26:24.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.386]     }
[10:26:24.386]     ...future.result <- base::tryCatch({
[10:26:24.386]         base::withCallingHandlers({
[10:26:24.386]             ...future.value <- base::withVisible(base::local({
[10:26:24.386]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:24.386]                   "error", "condition")))
[10:26:24.386]             }))
[10:26:24.386]             future::FutureResult(value = ...future.value$value, 
[10:26:24.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.386]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.386]                     ...future.globalenv.names))
[10:26:24.386]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.386]         }, condition = base::local({
[10:26:24.386]             c <- base::c
[10:26:24.386]             inherits <- base::inherits
[10:26:24.386]             invokeRestart <- base::invokeRestart
[10:26:24.386]             length <- base::length
[10:26:24.386]             list <- base::list
[10:26:24.386]             seq.int <- base::seq.int
[10:26:24.386]             signalCondition <- base::signalCondition
[10:26:24.386]             sys.calls <- base::sys.calls
[10:26:24.386]             `[[` <- base::`[[`
[10:26:24.386]             `+` <- base::`+`
[10:26:24.386]             `<<-` <- base::`<<-`
[10:26:24.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.386]                   3L)]
[10:26:24.386]             }
[10:26:24.386]             function(cond) {
[10:26:24.386]                 is_error <- inherits(cond, "error")
[10:26:24.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.386]                   NULL)
[10:26:24.386]                 if (is_error) {
[10:26:24.386]                   sessionInformation <- function() {
[10:26:24.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.386]                       search = base::search(), system = base::Sys.info())
[10:26:24.386]                   }
[10:26:24.386]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.386]                     cond$call), session = sessionInformation(), 
[10:26:24.386]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.386]                   signalCondition(cond)
[10:26:24.386]                 }
[10:26:24.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.386]                 "immediateCondition"))) {
[10:26:24.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.386]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.386]                   if (TRUE && !signal) {
[10:26:24.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.386]                     {
[10:26:24.386]                       inherits <- base::inherits
[10:26:24.386]                       invokeRestart <- base::invokeRestart
[10:26:24.386]                       is.null <- base::is.null
[10:26:24.386]                       muffled <- FALSE
[10:26:24.386]                       if (inherits(cond, "message")) {
[10:26:24.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.386]                         if (muffled) 
[10:26:24.386]                           invokeRestart("muffleMessage")
[10:26:24.386]                       }
[10:26:24.386]                       else if (inherits(cond, "warning")) {
[10:26:24.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.386]                         if (muffled) 
[10:26:24.386]                           invokeRestart("muffleWarning")
[10:26:24.386]                       }
[10:26:24.386]                       else if (inherits(cond, "condition")) {
[10:26:24.386]                         if (!is.null(pattern)) {
[10:26:24.386]                           computeRestarts <- base::computeRestarts
[10:26:24.386]                           grepl <- base::grepl
[10:26:24.386]                           restarts <- computeRestarts(cond)
[10:26:24.386]                           for (restart in restarts) {
[10:26:24.386]                             name <- restart$name
[10:26:24.386]                             if (is.null(name)) 
[10:26:24.386]                               next
[10:26:24.386]                             if (!grepl(pattern, name)) 
[10:26:24.386]                               next
[10:26:24.386]                             invokeRestart(restart)
[10:26:24.386]                             muffled <- TRUE
[10:26:24.386]                             break
[10:26:24.386]                           }
[10:26:24.386]                         }
[10:26:24.386]                       }
[10:26:24.386]                       invisible(muffled)
[10:26:24.386]                     }
[10:26:24.386]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.386]                   }
[10:26:24.386]                 }
[10:26:24.386]                 else {
[10:26:24.386]                   if (TRUE) {
[10:26:24.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.386]                     {
[10:26:24.386]                       inherits <- base::inherits
[10:26:24.386]                       invokeRestart <- base::invokeRestart
[10:26:24.386]                       is.null <- base::is.null
[10:26:24.386]                       muffled <- FALSE
[10:26:24.386]                       if (inherits(cond, "message")) {
[10:26:24.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.386]                         if (muffled) 
[10:26:24.386]                           invokeRestart("muffleMessage")
[10:26:24.386]                       }
[10:26:24.386]                       else if (inherits(cond, "warning")) {
[10:26:24.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.386]                         if (muffled) 
[10:26:24.386]                           invokeRestart("muffleWarning")
[10:26:24.386]                       }
[10:26:24.386]                       else if (inherits(cond, "condition")) {
[10:26:24.386]                         if (!is.null(pattern)) {
[10:26:24.386]                           computeRestarts <- base::computeRestarts
[10:26:24.386]                           grepl <- base::grepl
[10:26:24.386]                           restarts <- computeRestarts(cond)
[10:26:24.386]                           for (restart in restarts) {
[10:26:24.386]                             name <- restart$name
[10:26:24.386]                             if (is.null(name)) 
[10:26:24.386]                               next
[10:26:24.386]                             if (!grepl(pattern, name)) 
[10:26:24.386]                               next
[10:26:24.386]                             invokeRestart(restart)
[10:26:24.386]                             muffled <- TRUE
[10:26:24.386]                             break
[10:26:24.386]                           }
[10:26:24.386]                         }
[10:26:24.386]                       }
[10:26:24.386]                       invisible(muffled)
[10:26:24.386]                     }
[10:26:24.386]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.386]                   }
[10:26:24.386]                 }
[10:26:24.386]             }
[10:26:24.386]         }))
[10:26:24.386]     }, error = function(ex) {
[10:26:24.386]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.386]                 ...future.rng), started = ...future.startTime, 
[10:26:24.386]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.386]             version = "1.8"), class = "FutureResult")
[10:26:24.386]     }, finally = {
[10:26:24.386]         if (!identical(...future.workdir, getwd())) 
[10:26:24.386]             setwd(...future.workdir)
[10:26:24.386]         {
[10:26:24.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.386]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.386]             }
[10:26:24.386]             base::options(...future.oldOptions)
[10:26:24.386]             if (.Platform$OS.type == "windows") {
[10:26:24.386]                 old_names <- names(...future.oldEnvVars)
[10:26:24.386]                 envs <- base::Sys.getenv()
[10:26:24.386]                 names <- names(envs)
[10:26:24.386]                 common <- intersect(names, old_names)
[10:26:24.386]                 added <- setdiff(names, old_names)
[10:26:24.386]                 removed <- setdiff(old_names, names)
[10:26:24.386]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.386]                   envs[common]]
[10:26:24.386]                 NAMES <- toupper(changed)
[10:26:24.386]                 args <- list()
[10:26:24.386]                 for (kk in seq_along(NAMES)) {
[10:26:24.386]                   name <- changed[[kk]]
[10:26:24.386]                   NAME <- NAMES[[kk]]
[10:26:24.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.386]                     next
[10:26:24.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.386]                 }
[10:26:24.386]                 NAMES <- toupper(added)
[10:26:24.386]                 for (kk in seq_along(NAMES)) {
[10:26:24.386]                   name <- added[[kk]]
[10:26:24.386]                   NAME <- NAMES[[kk]]
[10:26:24.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.386]                     next
[10:26:24.386]                   args[[name]] <- ""
[10:26:24.386]                 }
[10:26:24.386]                 NAMES <- toupper(removed)
[10:26:24.386]                 for (kk in seq_along(NAMES)) {
[10:26:24.386]                   name <- removed[[kk]]
[10:26:24.386]                   NAME <- NAMES[[kk]]
[10:26:24.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.386]                     next
[10:26:24.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.386]                 }
[10:26:24.386]                 if (length(args) > 0) 
[10:26:24.386]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.386]             }
[10:26:24.386]             else {
[10:26:24.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.386]             }
[10:26:24.386]             {
[10:26:24.386]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.386]                   0L) {
[10:26:24.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.386]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.386]                   base::options(opts)
[10:26:24.386]                 }
[10:26:24.386]                 {
[10:26:24.386]                   {
[10:26:24.386]                     NULL
[10:26:24.386]                     RNGkind("Mersenne-Twister")
[10:26:24.386]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.386]                       inherits = FALSE)
[10:26:24.386]                   }
[10:26:24.386]                   options(future.plan = NULL)
[10:26:24.386]                   if (is.na(NA_character_)) 
[10:26:24.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.386]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.386]                     envir = parent.frame()) 
[10:26:24.386]                   {
[10:26:24.386]                     default_workers <- missing(workers)
[10:26:24.386]                     if (is.function(workers)) 
[10:26:24.386]                       workers <- workers()
[10:26:24.386]                     workers <- structure(as.integer(workers), 
[10:26:24.386]                       class = class(workers))
[10:26:24.386]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.386]                       1L)
[10:26:24.386]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.386]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.386]                       if (default_workers) 
[10:26:24.386]                         supportsMulticore(warn = TRUE)
[10:26:24.386]                       return(sequential(..., envir = envir))
[10:26:24.386]                     }
[10:26:24.386]                     oopts <- options(mc.cores = workers)
[10:26:24.386]                     on.exit(options(oopts))
[10:26:24.386]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.386]                       envir = envir)
[10:26:24.386]                     if (!future$lazy) 
[10:26:24.386]                       future <- run(future)
[10:26:24.386]                     invisible(future)
[10:26:24.386]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.386]                 }
[10:26:24.386]             }
[10:26:24.386]         }
[10:26:24.386]     })
[10:26:24.386]     if (TRUE) {
[10:26:24.386]         base::sink(type = "output", split = FALSE)
[10:26:24.386]         if (TRUE) {
[10:26:24.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.386]         }
[10:26:24.386]         else {
[10:26:24.386]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.386]         }
[10:26:24.386]         base::close(...future.stdout)
[10:26:24.386]         ...future.stdout <- NULL
[10:26:24.386]     }
[10:26:24.386]     ...future.result$conditions <- ...future.conditions
[10:26:24.386]     ...future.result$finished <- base::Sys.time()
[10:26:24.386]     ...future.result
[10:26:24.386] }
[10:26:24.387] plan(): Setting new future strategy stack:
[10:26:24.388] List of future strategies:
[10:26:24.388] 1. sequential:
[10:26:24.388]    - args: function (..., envir = parent.frame())
[10:26:24.388]    - tweaked: FALSE
[10:26:24.388]    - call: NULL
[10:26:24.388] plan(): nbrOfWorkers() = 1
[10:26:24.389] plan(): Setting new future strategy stack:
[10:26:24.389] List of future strategies:
[10:26:24.389] 1. multicore:
[10:26:24.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.389]    - tweaked: FALSE
[10:26:24.389]    - call: plan(multicore)
[10:26:24.392] plan(): nbrOfWorkers() = 1
[10:26:24.392] SequentialFuture started (and completed)
[10:26:24.392] signalConditions() ...
[10:26:24.392]  - include = ‘immediateCondition’
[10:26:24.393]  - exclude = 
[10:26:24.393]  - resignal = FALSE
[10:26:24.393]  - Number of conditions: 1
[10:26:24.393] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:24.393] signalConditions() ...
[10:26:24.393]  - include = ‘immediateCondition’
[10:26:24.394]  - exclude = 
[10:26:24.394]  - resignal = FALSE
[10:26:24.394]  - Number of conditions: 1
[10:26:24.394] signalConditions() ... done
<MyError: boom>
[10:26:24.394] signalConditions() ...
[10:26:24.394]  - include = ‘immediateCondition’
[10:26:24.394]  - exclude = 
[10:26:24.394]  - resignal = FALSE
[10:26:24.394]  - Number of conditions: 1
[10:26:24.394] signalConditions() ... done
[10:26:24.395] Future state: ‘finished’
[10:26:24.395] signalConditions() ...
[10:26:24.395]  - include = ‘condition’
[10:26:24.395]  - exclude = ‘immediateCondition’
[10:26:24.395]  - resignal = TRUE
[10:26:24.395]  - Number of conditions: 1
[10:26:24.395]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:24.395] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[10:26:24.395] getGlobalsAndPackages() ...
[10:26:24.396] Searching for globals...
[10:26:24.396] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:26:24.396] Searching for globals ... DONE
[10:26:24.396] Resolving globals: FALSE
[10:26:24.397] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:24.397] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[10:26:24.397] - globals: [2] ‘a’, ‘b’
[10:26:24.397] 
[10:26:24.398] getGlobalsAndPackages() ... DONE
[10:26:24.398] Packages needed by the future expression (n = 0): <none>
[10:26:24.398] Packages needed by future strategies (n = 0): <none>
[10:26:24.398] {
[10:26:24.398]     {
[10:26:24.398]         {
[10:26:24.398]             ...future.startTime <- base::Sys.time()
[10:26:24.398]             {
[10:26:24.398]                 {
[10:26:24.398]                   {
[10:26:24.398]                     base::local({
[10:26:24.398]                       has_future <- base::requireNamespace("future", 
[10:26:24.398]                         quietly = TRUE)
[10:26:24.398]                       if (has_future) {
[10:26:24.398]                         ns <- base::getNamespace("future")
[10:26:24.398]                         version <- ns[[".package"]][["version"]]
[10:26:24.398]                         if (is.null(version)) 
[10:26:24.398]                           version <- utils::packageVersion("future")
[10:26:24.398]                       }
[10:26:24.398]                       else {
[10:26:24.398]                         version <- NULL
[10:26:24.398]                       }
[10:26:24.398]                       if (!has_future || version < "1.8.0") {
[10:26:24.398]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.398]                           "", base::R.version$version.string), 
[10:26:24.398]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.398]                             "release", "version")], collapse = " "), 
[10:26:24.398]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.398]                           info)
[10:26:24.398]                         info <- base::paste(info, collapse = "; ")
[10:26:24.398]                         if (!has_future) {
[10:26:24.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.398]                             info)
[10:26:24.398]                         }
[10:26:24.398]                         else {
[10:26:24.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.398]                             info, version)
[10:26:24.398]                         }
[10:26:24.398]                         base::stop(msg)
[10:26:24.398]                       }
[10:26:24.398]                     })
[10:26:24.398]                   }
[10:26:24.398]                   options(future.plan = NULL)
[10:26:24.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.398]                 }
[10:26:24.398]                 ...future.workdir <- getwd()
[10:26:24.398]             }
[10:26:24.398]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.398]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.398]         }
[10:26:24.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.398]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.398]             base::names(...future.oldOptions))
[10:26:24.398]     }
[10:26:24.398]     if (FALSE) {
[10:26:24.398]     }
[10:26:24.398]     else {
[10:26:24.398]         if (TRUE) {
[10:26:24.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.398]                 open = "w")
[10:26:24.398]         }
[10:26:24.398]         else {
[10:26:24.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.398]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.398]         }
[10:26:24.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.398]             base::sink(type = "output", split = FALSE)
[10:26:24.398]             base::close(...future.stdout)
[10:26:24.398]         }, add = TRUE)
[10:26:24.398]     }
[10:26:24.398]     ...future.frame <- base::sys.nframe()
[10:26:24.398]     ...future.conditions <- base::list()
[10:26:24.398]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.398]     if (FALSE) {
[10:26:24.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.398]     }
[10:26:24.398]     ...future.result <- base::tryCatch({
[10:26:24.398]         base::withCallingHandlers({
[10:26:24.398]             ...future.value <- base::withVisible(base::local({
[10:26:24.398]                 a * b
[10:26:24.398]             }))
[10:26:24.398]             future::FutureResult(value = ...future.value$value, 
[10:26:24.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.398]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.398]                     ...future.globalenv.names))
[10:26:24.398]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.398]         }, condition = base::local({
[10:26:24.398]             c <- base::c
[10:26:24.398]             inherits <- base::inherits
[10:26:24.398]             invokeRestart <- base::invokeRestart
[10:26:24.398]             length <- base::length
[10:26:24.398]             list <- base::list
[10:26:24.398]             seq.int <- base::seq.int
[10:26:24.398]             signalCondition <- base::signalCondition
[10:26:24.398]             sys.calls <- base::sys.calls
[10:26:24.398]             `[[` <- base::`[[`
[10:26:24.398]             `+` <- base::`+`
[10:26:24.398]             `<<-` <- base::`<<-`
[10:26:24.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.398]                   3L)]
[10:26:24.398]             }
[10:26:24.398]             function(cond) {
[10:26:24.398]                 is_error <- inherits(cond, "error")
[10:26:24.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.398]                   NULL)
[10:26:24.398]                 if (is_error) {
[10:26:24.398]                   sessionInformation <- function() {
[10:26:24.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.398]                       search = base::search(), system = base::Sys.info())
[10:26:24.398]                   }
[10:26:24.398]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.398]                     cond$call), session = sessionInformation(), 
[10:26:24.398]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.398]                   signalCondition(cond)
[10:26:24.398]                 }
[10:26:24.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.398]                 "immediateCondition"))) {
[10:26:24.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.398]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.398]                   if (TRUE && !signal) {
[10:26:24.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.398]                     {
[10:26:24.398]                       inherits <- base::inherits
[10:26:24.398]                       invokeRestart <- base::invokeRestart
[10:26:24.398]                       is.null <- base::is.null
[10:26:24.398]                       muffled <- FALSE
[10:26:24.398]                       if (inherits(cond, "message")) {
[10:26:24.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.398]                         if (muffled) 
[10:26:24.398]                           invokeRestart("muffleMessage")
[10:26:24.398]                       }
[10:26:24.398]                       else if (inherits(cond, "warning")) {
[10:26:24.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.398]                         if (muffled) 
[10:26:24.398]                           invokeRestart("muffleWarning")
[10:26:24.398]                       }
[10:26:24.398]                       else if (inherits(cond, "condition")) {
[10:26:24.398]                         if (!is.null(pattern)) {
[10:26:24.398]                           computeRestarts <- base::computeRestarts
[10:26:24.398]                           grepl <- base::grepl
[10:26:24.398]                           restarts <- computeRestarts(cond)
[10:26:24.398]                           for (restart in restarts) {
[10:26:24.398]                             name <- restart$name
[10:26:24.398]                             if (is.null(name)) 
[10:26:24.398]                               next
[10:26:24.398]                             if (!grepl(pattern, name)) 
[10:26:24.398]                               next
[10:26:24.398]                             invokeRestart(restart)
[10:26:24.398]                             muffled <- TRUE
[10:26:24.398]                             break
[10:26:24.398]                           }
[10:26:24.398]                         }
[10:26:24.398]                       }
[10:26:24.398]                       invisible(muffled)
[10:26:24.398]                     }
[10:26:24.398]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.398]                   }
[10:26:24.398]                 }
[10:26:24.398]                 else {
[10:26:24.398]                   if (TRUE) {
[10:26:24.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.398]                     {
[10:26:24.398]                       inherits <- base::inherits
[10:26:24.398]                       invokeRestart <- base::invokeRestart
[10:26:24.398]                       is.null <- base::is.null
[10:26:24.398]                       muffled <- FALSE
[10:26:24.398]                       if (inherits(cond, "message")) {
[10:26:24.398]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.398]                         if (muffled) 
[10:26:24.398]                           invokeRestart("muffleMessage")
[10:26:24.398]                       }
[10:26:24.398]                       else if (inherits(cond, "warning")) {
[10:26:24.398]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.398]                         if (muffled) 
[10:26:24.398]                           invokeRestart("muffleWarning")
[10:26:24.398]                       }
[10:26:24.398]                       else if (inherits(cond, "condition")) {
[10:26:24.398]                         if (!is.null(pattern)) {
[10:26:24.398]                           computeRestarts <- base::computeRestarts
[10:26:24.398]                           grepl <- base::grepl
[10:26:24.398]                           restarts <- computeRestarts(cond)
[10:26:24.398]                           for (restart in restarts) {
[10:26:24.398]                             name <- restart$name
[10:26:24.398]                             if (is.null(name)) 
[10:26:24.398]                               next
[10:26:24.398]                             if (!grepl(pattern, name)) 
[10:26:24.398]                               next
[10:26:24.398]                             invokeRestart(restart)
[10:26:24.398]                             muffled <- TRUE
[10:26:24.398]                             break
[10:26:24.398]                           }
[10:26:24.398]                         }
[10:26:24.398]                       }
[10:26:24.398]                       invisible(muffled)
[10:26:24.398]                     }
[10:26:24.398]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.398]                   }
[10:26:24.398]                 }
[10:26:24.398]             }
[10:26:24.398]         }))
[10:26:24.398]     }, error = function(ex) {
[10:26:24.398]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.398]                 ...future.rng), started = ...future.startTime, 
[10:26:24.398]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.398]             version = "1.8"), class = "FutureResult")
[10:26:24.398]     }, finally = {
[10:26:24.398]         if (!identical(...future.workdir, getwd())) 
[10:26:24.398]             setwd(...future.workdir)
[10:26:24.398]         {
[10:26:24.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.398]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.398]             }
[10:26:24.398]             base::options(...future.oldOptions)
[10:26:24.398]             if (.Platform$OS.type == "windows") {
[10:26:24.398]                 old_names <- names(...future.oldEnvVars)
[10:26:24.398]                 envs <- base::Sys.getenv()
[10:26:24.398]                 names <- names(envs)
[10:26:24.398]                 common <- intersect(names, old_names)
[10:26:24.398]                 added <- setdiff(names, old_names)
[10:26:24.398]                 removed <- setdiff(old_names, names)
[10:26:24.398]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.398]                   envs[common]]
[10:26:24.398]                 NAMES <- toupper(changed)
[10:26:24.398]                 args <- list()
[10:26:24.398]                 for (kk in seq_along(NAMES)) {
[10:26:24.398]                   name <- changed[[kk]]
[10:26:24.398]                   NAME <- NAMES[[kk]]
[10:26:24.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.398]                     next
[10:26:24.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.398]                 }
[10:26:24.398]                 NAMES <- toupper(added)
[10:26:24.398]                 for (kk in seq_along(NAMES)) {
[10:26:24.398]                   name <- added[[kk]]
[10:26:24.398]                   NAME <- NAMES[[kk]]
[10:26:24.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.398]                     next
[10:26:24.398]                   args[[name]] <- ""
[10:26:24.398]                 }
[10:26:24.398]                 NAMES <- toupper(removed)
[10:26:24.398]                 for (kk in seq_along(NAMES)) {
[10:26:24.398]                   name <- removed[[kk]]
[10:26:24.398]                   NAME <- NAMES[[kk]]
[10:26:24.398]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.398]                     next
[10:26:24.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.398]                 }
[10:26:24.398]                 if (length(args) > 0) 
[10:26:24.398]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.398]             }
[10:26:24.398]             else {
[10:26:24.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.398]             }
[10:26:24.398]             {
[10:26:24.398]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.398]                   0L) {
[10:26:24.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.398]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.398]                   base::options(opts)
[10:26:24.398]                 }
[10:26:24.398]                 {
[10:26:24.398]                   {
[10:26:24.398]                     NULL
[10:26:24.398]                     RNGkind("Mersenne-Twister")
[10:26:24.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.398]                       inherits = FALSE)
[10:26:24.398]                   }
[10:26:24.398]                   options(future.plan = NULL)
[10:26:24.398]                   if (is.na(NA_character_)) 
[10:26:24.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.398]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.398]                     envir = parent.frame()) 
[10:26:24.398]                   {
[10:26:24.398]                     default_workers <- missing(workers)
[10:26:24.398]                     if (is.function(workers)) 
[10:26:24.398]                       workers <- workers()
[10:26:24.398]                     workers <- structure(as.integer(workers), 
[10:26:24.398]                       class = class(workers))
[10:26:24.398]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.398]                       1L)
[10:26:24.398]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.398]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.398]                       if (default_workers) 
[10:26:24.398]                         supportsMulticore(warn = TRUE)
[10:26:24.398]                       return(sequential(..., envir = envir))
[10:26:24.398]                     }
[10:26:24.398]                     oopts <- options(mc.cores = workers)
[10:26:24.398]                     on.exit(options(oopts))
[10:26:24.398]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.398]                       envir = envir)
[10:26:24.398]                     if (!future$lazy) 
[10:26:24.398]                       future <- run(future)
[10:26:24.398]                     invisible(future)
[10:26:24.398]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.398]                 }
[10:26:24.398]             }
[10:26:24.398]         }
[10:26:24.398]     })
[10:26:24.398]     if (TRUE) {
[10:26:24.398]         base::sink(type = "output", split = FALSE)
[10:26:24.398]         if (TRUE) {
[10:26:24.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.398]         }
[10:26:24.398]         else {
[10:26:24.398]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.398]         }
[10:26:24.398]         base::close(...future.stdout)
[10:26:24.398]         ...future.stdout <- NULL
[10:26:24.398]     }
[10:26:24.398]     ...future.result$conditions <- ...future.conditions
[10:26:24.398]     ...future.result$finished <- base::Sys.time()
[10:26:24.398]     ...future.result
[10:26:24.398] }
[10:26:24.400] assign_globals() ...
[10:26:24.400] List of 2
[10:26:24.400]  $ a: num 2
[10:26:24.400]  $ b: num 3
[10:26:24.400]  - attr(*, "where")=List of 2
[10:26:24.400]   ..$ a:<environment: R_EmptyEnv> 
[10:26:24.400]   ..$ b:<environment: R_EmptyEnv> 
[10:26:24.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.400]  - attr(*, "resolved")= logi FALSE
[10:26:24.400]  - attr(*, "total_size")= num 112
[10:26:24.403] - copied ‘a’ to environment
[10:26:24.403] - copied ‘b’ to environment
[10:26:24.403] assign_globals() ... done
[10:26:24.403] plan(): Setting new future strategy stack:
[10:26:24.403] List of future strategies:
[10:26:24.403] 1. sequential:
[10:26:24.403]    - args: function (..., envir = parent.frame())
[10:26:24.403]    - tweaked: FALSE
[10:26:24.403]    - call: NULL
[10:26:24.403] plan(): nbrOfWorkers() = 1
[10:26:24.404] plan(): Setting new future strategy stack:
[10:26:24.404] List of future strategies:
[10:26:24.404] 1. multicore:
[10:26:24.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.404]    - tweaked: FALSE
[10:26:24.404]    - call: plan(multicore)
[10:26:24.407] plan(): nbrOfWorkers() = 1
[10:26:24.408] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[10:26:24.416] getGlobalsAndPackages() ...
[10:26:24.416] Not searching for globals
[10:26:24.416] - globals: [0] <none>
[10:26:24.416] getGlobalsAndPackages() ... DONE
[10:26:24.417] Packages needed by the future expression (n = 0): <none>
[10:26:24.417] Packages needed by future strategies (n = 0): <none>
[10:26:24.418] {
[10:26:24.418]     {
[10:26:24.418]         {
[10:26:24.418]             ...future.startTime <- base::Sys.time()
[10:26:24.418]             {
[10:26:24.418]                 {
[10:26:24.418]                   {
[10:26:24.418]                     {
[10:26:24.418]                       base::local({
[10:26:24.418]                         has_future <- base::requireNamespace("future", 
[10:26:24.418]                           quietly = TRUE)
[10:26:24.418]                         if (has_future) {
[10:26:24.418]                           ns <- base::getNamespace("future")
[10:26:24.418]                           version <- ns[[".package"]][["version"]]
[10:26:24.418]                           if (is.null(version)) 
[10:26:24.418]                             version <- utils::packageVersion("future")
[10:26:24.418]                         }
[10:26:24.418]                         else {
[10:26:24.418]                           version <- NULL
[10:26:24.418]                         }
[10:26:24.418]                         if (!has_future || version < "1.8.0") {
[10:26:24.418]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.418]                             "", base::R.version$version.string), 
[10:26:24.418]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.418]                               "release", "version")], collapse = " "), 
[10:26:24.418]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.418]                             info)
[10:26:24.418]                           info <- base::paste(info, collapse = "; ")
[10:26:24.418]                           if (!has_future) {
[10:26:24.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.418]                               info)
[10:26:24.418]                           }
[10:26:24.418]                           else {
[10:26:24.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.418]                               info, version)
[10:26:24.418]                           }
[10:26:24.418]                           base::stop(msg)
[10:26:24.418]                         }
[10:26:24.418]                       })
[10:26:24.418]                     }
[10:26:24.418]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.418]                     base::options(mc.cores = 1L)
[10:26:24.418]                   }
[10:26:24.418]                   options(future.plan = NULL)
[10:26:24.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.418]                 }
[10:26:24.418]                 ...future.workdir <- getwd()
[10:26:24.418]             }
[10:26:24.418]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.418]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.418]         }
[10:26:24.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.418]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.418]             base::names(...future.oldOptions))
[10:26:24.418]     }
[10:26:24.418]     if (FALSE) {
[10:26:24.418]     }
[10:26:24.418]     else {
[10:26:24.418]         if (TRUE) {
[10:26:24.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.418]                 open = "w")
[10:26:24.418]         }
[10:26:24.418]         else {
[10:26:24.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.418]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.418]         }
[10:26:24.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.418]             base::sink(type = "output", split = FALSE)
[10:26:24.418]             base::close(...future.stdout)
[10:26:24.418]         }, add = TRUE)
[10:26:24.418]     }
[10:26:24.418]     ...future.frame <- base::sys.nframe()
[10:26:24.418]     ...future.conditions <- base::list()
[10:26:24.418]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.418]     if (FALSE) {
[10:26:24.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.418]     }
[10:26:24.418]     ...future.result <- base::tryCatch({
[10:26:24.418]         base::withCallingHandlers({
[10:26:24.418]             ...future.value <- base::withVisible(base::local({
[10:26:24.418]                 withCallingHandlers({
[10:26:24.418]                   {
[10:26:24.418]                     42L
[10:26:24.418]                   }
[10:26:24.418]                 }, immediateCondition = function(cond) {
[10:26:24.418]                   save_rds <- function (object, pathname, ...) 
[10:26:24.418]                   {
[10:26:24.418]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.418]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.418]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.418]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.418]                         fi_tmp[["mtime"]])
[10:26:24.418]                     }
[10:26:24.418]                     tryCatch({
[10:26:24.418]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.418]                     }, error = function(ex) {
[10:26:24.418]                       msg <- conditionMessage(ex)
[10:26:24.418]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.418]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.418]                         fi_tmp[["mtime"]], msg)
[10:26:24.418]                       ex$message <- msg
[10:26:24.418]                       stop(ex)
[10:26:24.418]                     })
[10:26:24.418]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.418]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.418]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.418]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.418]                       fi <- file.info(pathname)
[10:26:24.418]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.418]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.418]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.418]                         fi[["size"]], fi[["mtime"]])
[10:26:24.418]                       stop(msg)
[10:26:24.418]                     }
[10:26:24.418]                     invisible(pathname)
[10:26:24.418]                   }
[10:26:24.418]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.418]                     rootPath = tempdir()) 
[10:26:24.418]                   {
[10:26:24.418]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.418]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.418]                       tmpdir = path, fileext = ".rds")
[10:26:24.418]                     save_rds(obj, file)
[10:26:24.418]                   }
[10:26:24.418]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.418]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.418]                   {
[10:26:24.418]                     inherits <- base::inherits
[10:26:24.418]                     invokeRestart <- base::invokeRestart
[10:26:24.418]                     is.null <- base::is.null
[10:26:24.418]                     muffled <- FALSE
[10:26:24.418]                     if (inherits(cond, "message")) {
[10:26:24.418]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.418]                       if (muffled) 
[10:26:24.418]                         invokeRestart("muffleMessage")
[10:26:24.418]                     }
[10:26:24.418]                     else if (inherits(cond, "warning")) {
[10:26:24.418]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.418]                       if (muffled) 
[10:26:24.418]                         invokeRestart("muffleWarning")
[10:26:24.418]                     }
[10:26:24.418]                     else if (inherits(cond, "condition")) {
[10:26:24.418]                       if (!is.null(pattern)) {
[10:26:24.418]                         computeRestarts <- base::computeRestarts
[10:26:24.418]                         grepl <- base::grepl
[10:26:24.418]                         restarts <- computeRestarts(cond)
[10:26:24.418]                         for (restart in restarts) {
[10:26:24.418]                           name <- restart$name
[10:26:24.418]                           if (is.null(name)) 
[10:26:24.418]                             next
[10:26:24.418]                           if (!grepl(pattern, name)) 
[10:26:24.418]                             next
[10:26:24.418]                           invokeRestart(restart)
[10:26:24.418]                           muffled <- TRUE
[10:26:24.418]                           break
[10:26:24.418]                         }
[10:26:24.418]                       }
[10:26:24.418]                     }
[10:26:24.418]                     invisible(muffled)
[10:26:24.418]                   }
[10:26:24.418]                   muffleCondition(cond)
[10:26:24.418]                 })
[10:26:24.418]             }))
[10:26:24.418]             future::FutureResult(value = ...future.value$value, 
[10:26:24.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.418]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.418]                     ...future.globalenv.names))
[10:26:24.418]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.418]         }, condition = base::local({
[10:26:24.418]             c <- base::c
[10:26:24.418]             inherits <- base::inherits
[10:26:24.418]             invokeRestart <- base::invokeRestart
[10:26:24.418]             length <- base::length
[10:26:24.418]             list <- base::list
[10:26:24.418]             seq.int <- base::seq.int
[10:26:24.418]             signalCondition <- base::signalCondition
[10:26:24.418]             sys.calls <- base::sys.calls
[10:26:24.418]             `[[` <- base::`[[`
[10:26:24.418]             `+` <- base::`+`
[10:26:24.418]             `<<-` <- base::`<<-`
[10:26:24.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.418]                   3L)]
[10:26:24.418]             }
[10:26:24.418]             function(cond) {
[10:26:24.418]                 is_error <- inherits(cond, "error")
[10:26:24.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.418]                   NULL)
[10:26:24.418]                 if (is_error) {
[10:26:24.418]                   sessionInformation <- function() {
[10:26:24.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.418]                       search = base::search(), system = base::Sys.info())
[10:26:24.418]                   }
[10:26:24.418]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.418]                     cond$call), session = sessionInformation(), 
[10:26:24.418]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.418]                   signalCondition(cond)
[10:26:24.418]                 }
[10:26:24.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.418]                 "immediateCondition"))) {
[10:26:24.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.418]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.418]                   if (TRUE && !signal) {
[10:26:24.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.418]                     {
[10:26:24.418]                       inherits <- base::inherits
[10:26:24.418]                       invokeRestart <- base::invokeRestart
[10:26:24.418]                       is.null <- base::is.null
[10:26:24.418]                       muffled <- FALSE
[10:26:24.418]                       if (inherits(cond, "message")) {
[10:26:24.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.418]                         if (muffled) 
[10:26:24.418]                           invokeRestart("muffleMessage")
[10:26:24.418]                       }
[10:26:24.418]                       else if (inherits(cond, "warning")) {
[10:26:24.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.418]                         if (muffled) 
[10:26:24.418]                           invokeRestart("muffleWarning")
[10:26:24.418]                       }
[10:26:24.418]                       else if (inherits(cond, "condition")) {
[10:26:24.418]                         if (!is.null(pattern)) {
[10:26:24.418]                           computeRestarts <- base::computeRestarts
[10:26:24.418]                           grepl <- base::grepl
[10:26:24.418]                           restarts <- computeRestarts(cond)
[10:26:24.418]                           for (restart in restarts) {
[10:26:24.418]                             name <- restart$name
[10:26:24.418]                             if (is.null(name)) 
[10:26:24.418]                               next
[10:26:24.418]                             if (!grepl(pattern, name)) 
[10:26:24.418]                               next
[10:26:24.418]                             invokeRestart(restart)
[10:26:24.418]                             muffled <- TRUE
[10:26:24.418]                             break
[10:26:24.418]                           }
[10:26:24.418]                         }
[10:26:24.418]                       }
[10:26:24.418]                       invisible(muffled)
[10:26:24.418]                     }
[10:26:24.418]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.418]                   }
[10:26:24.418]                 }
[10:26:24.418]                 else {
[10:26:24.418]                   if (TRUE) {
[10:26:24.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.418]                     {
[10:26:24.418]                       inherits <- base::inherits
[10:26:24.418]                       invokeRestart <- base::invokeRestart
[10:26:24.418]                       is.null <- base::is.null
[10:26:24.418]                       muffled <- FALSE
[10:26:24.418]                       if (inherits(cond, "message")) {
[10:26:24.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.418]                         if (muffled) 
[10:26:24.418]                           invokeRestart("muffleMessage")
[10:26:24.418]                       }
[10:26:24.418]                       else if (inherits(cond, "warning")) {
[10:26:24.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.418]                         if (muffled) 
[10:26:24.418]                           invokeRestart("muffleWarning")
[10:26:24.418]                       }
[10:26:24.418]                       else if (inherits(cond, "condition")) {
[10:26:24.418]                         if (!is.null(pattern)) {
[10:26:24.418]                           computeRestarts <- base::computeRestarts
[10:26:24.418]                           grepl <- base::grepl
[10:26:24.418]                           restarts <- computeRestarts(cond)
[10:26:24.418]                           for (restart in restarts) {
[10:26:24.418]                             name <- restart$name
[10:26:24.418]                             if (is.null(name)) 
[10:26:24.418]                               next
[10:26:24.418]                             if (!grepl(pattern, name)) 
[10:26:24.418]                               next
[10:26:24.418]                             invokeRestart(restart)
[10:26:24.418]                             muffled <- TRUE
[10:26:24.418]                             break
[10:26:24.418]                           }
[10:26:24.418]                         }
[10:26:24.418]                       }
[10:26:24.418]                       invisible(muffled)
[10:26:24.418]                     }
[10:26:24.418]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.418]                   }
[10:26:24.418]                 }
[10:26:24.418]             }
[10:26:24.418]         }))
[10:26:24.418]     }, error = function(ex) {
[10:26:24.418]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.418]                 ...future.rng), started = ...future.startTime, 
[10:26:24.418]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.418]             version = "1.8"), class = "FutureResult")
[10:26:24.418]     }, finally = {
[10:26:24.418]         if (!identical(...future.workdir, getwd())) 
[10:26:24.418]             setwd(...future.workdir)
[10:26:24.418]         {
[10:26:24.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.418]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.418]             }
[10:26:24.418]             base::options(...future.oldOptions)
[10:26:24.418]             if (.Platform$OS.type == "windows") {
[10:26:24.418]                 old_names <- names(...future.oldEnvVars)
[10:26:24.418]                 envs <- base::Sys.getenv()
[10:26:24.418]                 names <- names(envs)
[10:26:24.418]                 common <- intersect(names, old_names)
[10:26:24.418]                 added <- setdiff(names, old_names)
[10:26:24.418]                 removed <- setdiff(old_names, names)
[10:26:24.418]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.418]                   envs[common]]
[10:26:24.418]                 NAMES <- toupper(changed)
[10:26:24.418]                 args <- list()
[10:26:24.418]                 for (kk in seq_along(NAMES)) {
[10:26:24.418]                   name <- changed[[kk]]
[10:26:24.418]                   NAME <- NAMES[[kk]]
[10:26:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.418]                     next
[10:26:24.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.418]                 }
[10:26:24.418]                 NAMES <- toupper(added)
[10:26:24.418]                 for (kk in seq_along(NAMES)) {
[10:26:24.418]                   name <- added[[kk]]
[10:26:24.418]                   NAME <- NAMES[[kk]]
[10:26:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.418]                     next
[10:26:24.418]                   args[[name]] <- ""
[10:26:24.418]                 }
[10:26:24.418]                 NAMES <- toupper(removed)
[10:26:24.418]                 for (kk in seq_along(NAMES)) {
[10:26:24.418]                   name <- removed[[kk]]
[10:26:24.418]                   NAME <- NAMES[[kk]]
[10:26:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.418]                     next
[10:26:24.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.418]                 }
[10:26:24.418]                 if (length(args) > 0) 
[10:26:24.418]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.418]             }
[10:26:24.418]             else {
[10:26:24.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.418]             }
[10:26:24.418]             {
[10:26:24.418]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.418]                   0L) {
[10:26:24.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.418]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.418]                   base::options(opts)
[10:26:24.418]                 }
[10:26:24.418]                 {
[10:26:24.418]                   {
[10:26:24.418]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.418]                     NULL
[10:26:24.418]                   }
[10:26:24.418]                   options(future.plan = NULL)
[10:26:24.418]                   if (is.na(NA_character_)) 
[10:26:24.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.418]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.418]                     envir = parent.frame()) 
[10:26:24.418]                   {
[10:26:24.418]                     default_workers <- missing(workers)
[10:26:24.418]                     if (is.function(workers)) 
[10:26:24.418]                       workers <- workers()
[10:26:24.418]                     workers <- structure(as.integer(workers), 
[10:26:24.418]                       class = class(workers))
[10:26:24.418]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.418]                       1L)
[10:26:24.418]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.418]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.418]                       if (default_workers) 
[10:26:24.418]                         supportsMulticore(warn = TRUE)
[10:26:24.418]                       return(sequential(..., envir = envir))
[10:26:24.418]                     }
[10:26:24.418]                     oopts <- options(mc.cores = workers)
[10:26:24.418]                     on.exit(options(oopts))
[10:26:24.418]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.418]                       envir = envir)
[10:26:24.418]                     if (!future$lazy) 
[10:26:24.418]                       future <- run(future)
[10:26:24.418]                     invisible(future)
[10:26:24.418]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.418]                 }
[10:26:24.418]             }
[10:26:24.418]         }
[10:26:24.418]     })
[10:26:24.418]     if (TRUE) {
[10:26:24.418]         base::sink(type = "output", split = FALSE)
[10:26:24.418]         if (TRUE) {
[10:26:24.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.418]         }
[10:26:24.418]         else {
[10:26:24.418]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.418]         }
[10:26:24.418]         base::close(...future.stdout)
[10:26:24.418]         ...future.stdout <- NULL
[10:26:24.418]     }
[10:26:24.418]     ...future.result$conditions <- ...future.conditions
[10:26:24.418]     ...future.result$finished <- base::Sys.time()
[10:26:24.418]     ...future.result
[10:26:24.418] }
[10:26:24.420] requestCore(): workers = 2
[10:26:24.423] MulticoreFuture started
[10:26:24.424] plan(): Setting new future strategy stack:
[10:26:24.424] List of future strategies:
[10:26:24.424] 1. sequential:
[10:26:24.424]    - args: function (..., envir = parent.frame())
[10:26:24.424]    - tweaked: FALSE
[10:26:24.424]    - call: NULL
[10:26:24.425] plan(): nbrOfWorkers() = 1
[10:26:24.427] plan(): Setting new future strategy stack:
[10:26:24.427] List of future strategies:
[10:26:24.427] 1. multicore:
[10:26:24.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.427]    - tweaked: FALSE
[10:26:24.427]    - call: plan(multicore)
[10:26:24.432] plan(): nbrOfWorkers() = 2
[1] TRUE
[10:26:24.434] result() for MulticoreFuture ...
[10:26:24.439] result() for MulticoreFuture ...
[10:26:24.439] result() for MulticoreFuture ... done
[10:26:24.439] result() for MulticoreFuture ... done
[10:26:24.439] result() for MulticoreFuture ...
[10:26:24.439] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = FALSE) with globals
[10:26:24.443] getGlobalsAndPackages() ...
[10:26:24.443] Not searching for globals
[10:26:24.443] - globals: [0] <none>
[10:26:24.444] getGlobalsAndPackages() ... DONE
[10:26:24.444] Packages needed by the future expression (n = 0): <none>
[10:26:24.444] Packages needed by future strategies (n = 0): <none>
[10:26:24.445] {
[10:26:24.445]     {
[10:26:24.445]         {
[10:26:24.445]             ...future.startTime <- base::Sys.time()
[10:26:24.445]             {
[10:26:24.445]                 {
[10:26:24.445]                   {
[10:26:24.445]                     {
[10:26:24.445]                       base::local({
[10:26:24.445]                         has_future <- base::requireNamespace("future", 
[10:26:24.445]                           quietly = TRUE)
[10:26:24.445]                         if (has_future) {
[10:26:24.445]                           ns <- base::getNamespace("future")
[10:26:24.445]                           version <- ns[[".package"]][["version"]]
[10:26:24.445]                           if (is.null(version)) 
[10:26:24.445]                             version <- utils::packageVersion("future")
[10:26:24.445]                         }
[10:26:24.445]                         else {
[10:26:24.445]                           version <- NULL
[10:26:24.445]                         }
[10:26:24.445]                         if (!has_future || version < "1.8.0") {
[10:26:24.445]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.445]                             "", base::R.version$version.string), 
[10:26:24.445]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.445]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.445]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.445]                               "release", "version")], collapse = " "), 
[10:26:24.445]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.445]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.445]                             info)
[10:26:24.445]                           info <- base::paste(info, collapse = "; ")
[10:26:24.445]                           if (!has_future) {
[10:26:24.445]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.445]                               info)
[10:26:24.445]                           }
[10:26:24.445]                           else {
[10:26:24.445]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.445]                               info, version)
[10:26:24.445]                           }
[10:26:24.445]                           base::stop(msg)
[10:26:24.445]                         }
[10:26:24.445]                       })
[10:26:24.445]                     }
[10:26:24.445]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.445]                     base::options(mc.cores = 1L)
[10:26:24.445]                   }
[10:26:24.445]                   options(future.plan = NULL)
[10:26:24.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.445]                 }
[10:26:24.445]                 ...future.workdir <- getwd()
[10:26:24.445]             }
[10:26:24.445]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.445]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.445]         }
[10:26:24.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.445]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.445]             base::names(...future.oldOptions))
[10:26:24.445]     }
[10:26:24.445]     if (FALSE) {
[10:26:24.445]     }
[10:26:24.445]     else {
[10:26:24.445]         if (TRUE) {
[10:26:24.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.445]                 open = "w")
[10:26:24.445]         }
[10:26:24.445]         else {
[10:26:24.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.445]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.445]         }
[10:26:24.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.445]             base::sink(type = "output", split = FALSE)
[10:26:24.445]             base::close(...future.stdout)
[10:26:24.445]         }, add = TRUE)
[10:26:24.445]     }
[10:26:24.445]     ...future.frame <- base::sys.nframe()
[10:26:24.445]     ...future.conditions <- base::list()
[10:26:24.445]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.445]     if (FALSE) {
[10:26:24.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.445]     }
[10:26:24.445]     ...future.result <- base::tryCatch({
[10:26:24.445]         base::withCallingHandlers({
[10:26:24.445]             ...future.value <- base::withVisible(base::local({
[10:26:24.445]                 withCallingHandlers({
[10:26:24.445]                   {
[10:26:24.445]                     b <- 3
[10:26:24.445]                     c <- 2
[10:26:24.445]                     a * b * c
[10:26:24.445]                   }
[10:26:24.445]                 }, immediateCondition = function(cond) {
[10:26:24.445]                   save_rds <- function (object, pathname, ...) 
[10:26:24.445]                   {
[10:26:24.445]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.445]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.445]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.445]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.445]                         fi_tmp[["mtime"]])
[10:26:24.445]                     }
[10:26:24.445]                     tryCatch({
[10:26:24.445]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.445]                     }, error = function(ex) {
[10:26:24.445]                       msg <- conditionMessage(ex)
[10:26:24.445]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.445]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.445]                         fi_tmp[["mtime"]], msg)
[10:26:24.445]                       ex$message <- msg
[10:26:24.445]                       stop(ex)
[10:26:24.445]                     })
[10:26:24.445]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.445]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.445]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.445]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.445]                       fi <- file.info(pathname)
[10:26:24.445]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.445]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.445]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.445]                         fi[["size"]], fi[["mtime"]])
[10:26:24.445]                       stop(msg)
[10:26:24.445]                     }
[10:26:24.445]                     invisible(pathname)
[10:26:24.445]                   }
[10:26:24.445]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.445]                     rootPath = tempdir()) 
[10:26:24.445]                   {
[10:26:24.445]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.445]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.445]                       tmpdir = path, fileext = ".rds")
[10:26:24.445]                     save_rds(obj, file)
[10:26:24.445]                   }
[10:26:24.445]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.445]                   {
[10:26:24.445]                     inherits <- base::inherits
[10:26:24.445]                     invokeRestart <- base::invokeRestart
[10:26:24.445]                     is.null <- base::is.null
[10:26:24.445]                     muffled <- FALSE
[10:26:24.445]                     if (inherits(cond, "message")) {
[10:26:24.445]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.445]                       if (muffled) 
[10:26:24.445]                         invokeRestart("muffleMessage")
[10:26:24.445]                     }
[10:26:24.445]                     else if (inherits(cond, "warning")) {
[10:26:24.445]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.445]                       if (muffled) 
[10:26:24.445]                         invokeRestart("muffleWarning")
[10:26:24.445]                     }
[10:26:24.445]                     else if (inherits(cond, "condition")) {
[10:26:24.445]                       if (!is.null(pattern)) {
[10:26:24.445]                         computeRestarts <- base::computeRestarts
[10:26:24.445]                         grepl <- base::grepl
[10:26:24.445]                         restarts <- computeRestarts(cond)
[10:26:24.445]                         for (restart in restarts) {
[10:26:24.445]                           name <- restart$name
[10:26:24.445]                           if (is.null(name)) 
[10:26:24.445]                             next
[10:26:24.445]                           if (!grepl(pattern, name)) 
[10:26:24.445]                             next
[10:26:24.445]                           invokeRestart(restart)
[10:26:24.445]                           muffled <- TRUE
[10:26:24.445]                           break
[10:26:24.445]                         }
[10:26:24.445]                       }
[10:26:24.445]                     }
[10:26:24.445]                     invisible(muffled)
[10:26:24.445]                   }
[10:26:24.445]                   muffleCondition(cond)
[10:26:24.445]                 })
[10:26:24.445]             }))
[10:26:24.445]             future::FutureResult(value = ...future.value$value, 
[10:26:24.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.445]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.445]                     ...future.globalenv.names))
[10:26:24.445]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.445]         }, condition = base::local({
[10:26:24.445]             c <- base::c
[10:26:24.445]             inherits <- base::inherits
[10:26:24.445]             invokeRestart <- base::invokeRestart
[10:26:24.445]             length <- base::length
[10:26:24.445]             list <- base::list
[10:26:24.445]             seq.int <- base::seq.int
[10:26:24.445]             signalCondition <- base::signalCondition
[10:26:24.445]             sys.calls <- base::sys.calls
[10:26:24.445]             `[[` <- base::`[[`
[10:26:24.445]             `+` <- base::`+`
[10:26:24.445]             `<<-` <- base::`<<-`
[10:26:24.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.445]                   3L)]
[10:26:24.445]             }
[10:26:24.445]             function(cond) {
[10:26:24.445]                 is_error <- inherits(cond, "error")
[10:26:24.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.445]                   NULL)
[10:26:24.445]                 if (is_error) {
[10:26:24.445]                   sessionInformation <- function() {
[10:26:24.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.445]                       search = base::search(), system = base::Sys.info())
[10:26:24.445]                   }
[10:26:24.445]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.445]                     cond$call), session = sessionInformation(), 
[10:26:24.445]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.445]                   signalCondition(cond)
[10:26:24.445]                 }
[10:26:24.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.445]                 "immediateCondition"))) {
[10:26:24.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.445]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.445]                   if (TRUE && !signal) {
[10:26:24.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.445]                     {
[10:26:24.445]                       inherits <- base::inherits
[10:26:24.445]                       invokeRestart <- base::invokeRestart
[10:26:24.445]                       is.null <- base::is.null
[10:26:24.445]                       muffled <- FALSE
[10:26:24.445]                       if (inherits(cond, "message")) {
[10:26:24.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.445]                         if (muffled) 
[10:26:24.445]                           invokeRestart("muffleMessage")
[10:26:24.445]                       }
[10:26:24.445]                       else if (inherits(cond, "warning")) {
[10:26:24.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.445]                         if (muffled) 
[10:26:24.445]                           invokeRestart("muffleWarning")
[10:26:24.445]                       }
[10:26:24.445]                       else if (inherits(cond, "condition")) {
[10:26:24.445]                         if (!is.null(pattern)) {
[10:26:24.445]                           computeRestarts <- base::computeRestarts
[10:26:24.445]                           grepl <- base::grepl
[10:26:24.445]                           restarts <- computeRestarts(cond)
[10:26:24.445]                           for (restart in restarts) {
[10:26:24.445]                             name <- restart$name
[10:26:24.445]                             if (is.null(name)) 
[10:26:24.445]                               next
[10:26:24.445]                             if (!grepl(pattern, name)) 
[10:26:24.445]                               next
[10:26:24.445]                             invokeRestart(restart)
[10:26:24.445]                             muffled <- TRUE
[10:26:24.445]                             break
[10:26:24.445]                           }
[10:26:24.445]                         }
[10:26:24.445]                       }
[10:26:24.445]                       invisible(muffled)
[10:26:24.445]                     }
[10:26:24.445]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.445]                   }
[10:26:24.445]                 }
[10:26:24.445]                 else {
[10:26:24.445]                   if (TRUE) {
[10:26:24.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.445]                     {
[10:26:24.445]                       inherits <- base::inherits
[10:26:24.445]                       invokeRestart <- base::invokeRestart
[10:26:24.445]                       is.null <- base::is.null
[10:26:24.445]                       muffled <- FALSE
[10:26:24.445]                       if (inherits(cond, "message")) {
[10:26:24.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.445]                         if (muffled) 
[10:26:24.445]                           invokeRestart("muffleMessage")
[10:26:24.445]                       }
[10:26:24.445]                       else if (inherits(cond, "warning")) {
[10:26:24.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.445]                         if (muffled) 
[10:26:24.445]                           invokeRestart("muffleWarning")
[10:26:24.445]                       }
[10:26:24.445]                       else if (inherits(cond, "condition")) {
[10:26:24.445]                         if (!is.null(pattern)) {
[10:26:24.445]                           computeRestarts <- base::computeRestarts
[10:26:24.445]                           grepl <- base::grepl
[10:26:24.445]                           restarts <- computeRestarts(cond)
[10:26:24.445]                           for (restart in restarts) {
[10:26:24.445]                             name <- restart$name
[10:26:24.445]                             if (is.null(name)) 
[10:26:24.445]                               next
[10:26:24.445]                             if (!grepl(pattern, name)) 
[10:26:24.445]                               next
[10:26:24.445]                             invokeRestart(restart)
[10:26:24.445]                             muffled <- TRUE
[10:26:24.445]                             break
[10:26:24.445]                           }
[10:26:24.445]                         }
[10:26:24.445]                       }
[10:26:24.445]                       invisible(muffled)
[10:26:24.445]                     }
[10:26:24.445]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.445]                   }
[10:26:24.445]                 }
[10:26:24.445]             }
[10:26:24.445]         }))
[10:26:24.445]     }, error = function(ex) {
[10:26:24.445]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.445]                 ...future.rng), started = ...future.startTime, 
[10:26:24.445]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.445]             version = "1.8"), class = "FutureResult")
[10:26:24.445]     }, finally = {
[10:26:24.445]         if (!identical(...future.workdir, getwd())) 
[10:26:24.445]             setwd(...future.workdir)
[10:26:24.445]         {
[10:26:24.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.445]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.445]             }
[10:26:24.445]             base::options(...future.oldOptions)
[10:26:24.445]             if (.Platform$OS.type == "windows") {
[10:26:24.445]                 old_names <- names(...future.oldEnvVars)
[10:26:24.445]                 envs <- base::Sys.getenv()
[10:26:24.445]                 names <- names(envs)
[10:26:24.445]                 common <- intersect(names, old_names)
[10:26:24.445]                 added <- setdiff(names, old_names)
[10:26:24.445]                 removed <- setdiff(old_names, names)
[10:26:24.445]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.445]                   envs[common]]
[10:26:24.445]                 NAMES <- toupper(changed)
[10:26:24.445]                 args <- list()
[10:26:24.445]                 for (kk in seq_along(NAMES)) {
[10:26:24.445]                   name <- changed[[kk]]
[10:26:24.445]                   NAME <- NAMES[[kk]]
[10:26:24.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.445]                     next
[10:26:24.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.445]                 }
[10:26:24.445]                 NAMES <- toupper(added)
[10:26:24.445]                 for (kk in seq_along(NAMES)) {
[10:26:24.445]                   name <- added[[kk]]
[10:26:24.445]                   NAME <- NAMES[[kk]]
[10:26:24.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.445]                     next
[10:26:24.445]                   args[[name]] <- ""
[10:26:24.445]                 }
[10:26:24.445]                 NAMES <- toupper(removed)
[10:26:24.445]                 for (kk in seq_along(NAMES)) {
[10:26:24.445]                   name <- removed[[kk]]
[10:26:24.445]                   NAME <- NAMES[[kk]]
[10:26:24.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.445]                     next
[10:26:24.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.445]                 }
[10:26:24.445]                 if (length(args) > 0) 
[10:26:24.445]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.445]             }
[10:26:24.445]             else {
[10:26:24.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.445]             }
[10:26:24.445]             {
[10:26:24.445]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.445]                   0L) {
[10:26:24.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.445]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.445]                   base::options(opts)
[10:26:24.445]                 }
[10:26:24.445]                 {
[10:26:24.445]                   {
[10:26:24.445]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.445]                     NULL
[10:26:24.445]                   }
[10:26:24.445]                   options(future.plan = NULL)
[10:26:24.445]                   if (is.na(NA_character_)) 
[10:26:24.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.445]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.445]                     envir = parent.frame()) 
[10:26:24.445]                   {
[10:26:24.445]                     default_workers <- missing(workers)
[10:26:24.445]                     if (is.function(workers)) 
[10:26:24.445]                       workers <- workers()
[10:26:24.445]                     workers <- structure(as.integer(workers), 
[10:26:24.445]                       class = class(workers))
[10:26:24.445]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.445]                       1L)
[10:26:24.445]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.445]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.445]                       if (default_workers) 
[10:26:24.445]                         supportsMulticore(warn = TRUE)
[10:26:24.445]                       return(sequential(..., envir = envir))
[10:26:24.445]                     }
[10:26:24.445]                     oopts <- options(mc.cores = workers)
[10:26:24.445]                     on.exit(options(oopts))
[10:26:24.445]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.445]                       envir = envir)
[10:26:24.445]                     if (!future$lazy) 
[10:26:24.445]                       future <- run(future)
[10:26:24.445]                     invisible(future)
[10:26:24.445]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.445]                 }
[10:26:24.445]             }
[10:26:24.445]         }
[10:26:24.445]     })
[10:26:24.445]     if (TRUE) {
[10:26:24.445]         base::sink(type = "output", split = FALSE)
[10:26:24.445]         if (TRUE) {
[10:26:24.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.445]         }
[10:26:24.445]         else {
[10:26:24.445]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.445]         }
[10:26:24.445]         base::close(...future.stdout)
[10:26:24.445]         ...future.stdout <- NULL
[10:26:24.445]     }
[10:26:24.445]     ...future.result$conditions <- ...future.conditions
[10:26:24.445]     ...future.result$finished <- base::Sys.time()
[10:26:24.445]     ...future.result
[10:26:24.445] }
[10:26:24.447] requestCore(): workers = 2
[10:26:24.449] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.450] plan(): Setting new future strategy stack:
[10:26:24.451] List of future strategies:
[10:26:24.451] 1. sequential:
[10:26:24.451]    - args: function (..., envir = parent.frame())
[10:26:24.451]    - tweaked: FALSE
[10:26:24.451]    - call: NULL
[10:26:24.452] plan(): nbrOfWorkers() = 1
[10:26:24.453] plan(): Setting new future strategy stack:
[10:26:24.454] List of future strategies:
[10:26:24.454] 1. multicore:
[10:26:24.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.454]    - tweaked: FALSE
[10:26:24.454]    - call: plan(multicore)
[10:26:24.458] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.459] result() for MulticoreFuture ...
[10:26:24.460] result() for MulticoreFuture ...
[10:26:24.460] result() for MulticoreFuture ... done
[10:26:24.460] result() for MulticoreFuture ... done
[10:26:24.460] result() for MulticoreFuture ...
[10:26:24.460] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[10:26:24.465] getGlobalsAndPackages() ...
[10:26:24.465] Not searching for globals
[10:26:24.465] - globals: [0] <none>
[10:26:24.465] getGlobalsAndPackages() ... DONE
[10:26:24.465] Packages needed by the future expression (n = 0): <none>
[10:26:24.466] Packages needed by future strategies (n = 0): <none>
[10:26:24.466] {
[10:26:24.466]     {
[10:26:24.466]         {
[10:26:24.466]             ...future.startTime <- base::Sys.time()
[10:26:24.466]             {
[10:26:24.466]                 {
[10:26:24.466]                   {
[10:26:24.466]                     {
[10:26:24.466]                       base::local({
[10:26:24.466]                         has_future <- base::requireNamespace("future", 
[10:26:24.466]                           quietly = TRUE)
[10:26:24.466]                         if (has_future) {
[10:26:24.466]                           ns <- base::getNamespace("future")
[10:26:24.466]                           version <- ns[[".package"]][["version"]]
[10:26:24.466]                           if (is.null(version)) 
[10:26:24.466]                             version <- utils::packageVersion("future")
[10:26:24.466]                         }
[10:26:24.466]                         else {
[10:26:24.466]                           version <- NULL
[10:26:24.466]                         }
[10:26:24.466]                         if (!has_future || version < "1.8.0") {
[10:26:24.466]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.466]                             "", base::R.version$version.string), 
[10:26:24.466]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.466]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.466]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.466]                               "release", "version")], collapse = " "), 
[10:26:24.466]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.466]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.466]                             info)
[10:26:24.466]                           info <- base::paste(info, collapse = "; ")
[10:26:24.466]                           if (!has_future) {
[10:26:24.466]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.466]                               info)
[10:26:24.466]                           }
[10:26:24.466]                           else {
[10:26:24.466]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.466]                               info, version)
[10:26:24.466]                           }
[10:26:24.466]                           base::stop(msg)
[10:26:24.466]                         }
[10:26:24.466]                       })
[10:26:24.466]                     }
[10:26:24.466]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.466]                     base::options(mc.cores = 1L)
[10:26:24.466]                   }
[10:26:24.466]                   options(future.plan = NULL)
[10:26:24.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.466]                 }
[10:26:24.466]                 ...future.workdir <- getwd()
[10:26:24.466]             }
[10:26:24.466]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.466]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.466]         }
[10:26:24.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.466]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.466]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.466]             base::names(...future.oldOptions))
[10:26:24.466]     }
[10:26:24.466]     if (FALSE) {
[10:26:24.466]     }
[10:26:24.466]     else {
[10:26:24.466]         if (TRUE) {
[10:26:24.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.466]                 open = "w")
[10:26:24.466]         }
[10:26:24.466]         else {
[10:26:24.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.466]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.466]         }
[10:26:24.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.466]             base::sink(type = "output", split = FALSE)
[10:26:24.466]             base::close(...future.stdout)
[10:26:24.466]         }, add = TRUE)
[10:26:24.466]     }
[10:26:24.466]     ...future.frame <- base::sys.nframe()
[10:26:24.466]     ...future.conditions <- base::list()
[10:26:24.466]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.466]     if (FALSE) {
[10:26:24.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.466]     }
[10:26:24.466]     ...future.result <- base::tryCatch({
[10:26:24.466]         base::withCallingHandlers({
[10:26:24.466]             ...future.value <- base::withVisible(base::local({
[10:26:24.466]                 withCallingHandlers({
[10:26:24.466]                   {
[10:26:24.466]                     ii
[10:26:24.466]                   }
[10:26:24.466]                 }, immediateCondition = function(cond) {
[10:26:24.466]                   save_rds <- function (object, pathname, ...) 
[10:26:24.466]                   {
[10:26:24.466]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.466]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.466]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.466]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.466]                         fi_tmp[["mtime"]])
[10:26:24.466]                     }
[10:26:24.466]                     tryCatch({
[10:26:24.466]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.466]                     }, error = function(ex) {
[10:26:24.466]                       msg <- conditionMessage(ex)
[10:26:24.466]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.466]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.466]                         fi_tmp[["mtime"]], msg)
[10:26:24.466]                       ex$message <- msg
[10:26:24.466]                       stop(ex)
[10:26:24.466]                     })
[10:26:24.466]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.466]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.466]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.466]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.466]                       fi <- file.info(pathname)
[10:26:24.466]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.466]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.466]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.466]                         fi[["size"]], fi[["mtime"]])
[10:26:24.466]                       stop(msg)
[10:26:24.466]                     }
[10:26:24.466]                     invisible(pathname)
[10:26:24.466]                   }
[10:26:24.466]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.466]                     rootPath = tempdir()) 
[10:26:24.466]                   {
[10:26:24.466]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.466]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.466]                       tmpdir = path, fileext = ".rds")
[10:26:24.466]                     save_rds(obj, file)
[10:26:24.466]                   }
[10:26:24.466]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.466]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.466]                   {
[10:26:24.466]                     inherits <- base::inherits
[10:26:24.466]                     invokeRestart <- base::invokeRestart
[10:26:24.466]                     is.null <- base::is.null
[10:26:24.466]                     muffled <- FALSE
[10:26:24.466]                     if (inherits(cond, "message")) {
[10:26:24.466]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.466]                       if (muffled) 
[10:26:24.466]                         invokeRestart("muffleMessage")
[10:26:24.466]                     }
[10:26:24.466]                     else if (inherits(cond, "warning")) {
[10:26:24.466]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.466]                       if (muffled) 
[10:26:24.466]                         invokeRestart("muffleWarning")
[10:26:24.466]                     }
[10:26:24.466]                     else if (inherits(cond, "condition")) {
[10:26:24.466]                       if (!is.null(pattern)) {
[10:26:24.466]                         computeRestarts <- base::computeRestarts
[10:26:24.466]                         grepl <- base::grepl
[10:26:24.466]                         restarts <- computeRestarts(cond)
[10:26:24.466]                         for (restart in restarts) {
[10:26:24.466]                           name <- restart$name
[10:26:24.466]                           if (is.null(name)) 
[10:26:24.466]                             next
[10:26:24.466]                           if (!grepl(pattern, name)) 
[10:26:24.466]                             next
[10:26:24.466]                           invokeRestart(restart)
[10:26:24.466]                           muffled <- TRUE
[10:26:24.466]                           break
[10:26:24.466]                         }
[10:26:24.466]                       }
[10:26:24.466]                     }
[10:26:24.466]                     invisible(muffled)
[10:26:24.466]                   }
[10:26:24.466]                   muffleCondition(cond)
[10:26:24.466]                 })
[10:26:24.466]             }))
[10:26:24.466]             future::FutureResult(value = ...future.value$value, 
[10:26:24.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.466]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.466]                     ...future.globalenv.names))
[10:26:24.466]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.466]         }, condition = base::local({
[10:26:24.466]             c <- base::c
[10:26:24.466]             inherits <- base::inherits
[10:26:24.466]             invokeRestart <- base::invokeRestart
[10:26:24.466]             length <- base::length
[10:26:24.466]             list <- base::list
[10:26:24.466]             seq.int <- base::seq.int
[10:26:24.466]             signalCondition <- base::signalCondition
[10:26:24.466]             sys.calls <- base::sys.calls
[10:26:24.466]             `[[` <- base::`[[`
[10:26:24.466]             `+` <- base::`+`
[10:26:24.466]             `<<-` <- base::`<<-`
[10:26:24.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.466]                   3L)]
[10:26:24.466]             }
[10:26:24.466]             function(cond) {
[10:26:24.466]                 is_error <- inherits(cond, "error")
[10:26:24.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.466]                   NULL)
[10:26:24.466]                 if (is_error) {
[10:26:24.466]                   sessionInformation <- function() {
[10:26:24.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.466]                       search = base::search(), system = base::Sys.info())
[10:26:24.466]                   }
[10:26:24.466]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.466]                     cond$call), session = sessionInformation(), 
[10:26:24.466]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.466]                   signalCondition(cond)
[10:26:24.466]                 }
[10:26:24.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.466]                 "immediateCondition"))) {
[10:26:24.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.466]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.466]                   if (TRUE && !signal) {
[10:26:24.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.466]                     {
[10:26:24.466]                       inherits <- base::inherits
[10:26:24.466]                       invokeRestart <- base::invokeRestart
[10:26:24.466]                       is.null <- base::is.null
[10:26:24.466]                       muffled <- FALSE
[10:26:24.466]                       if (inherits(cond, "message")) {
[10:26:24.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.466]                         if (muffled) 
[10:26:24.466]                           invokeRestart("muffleMessage")
[10:26:24.466]                       }
[10:26:24.466]                       else if (inherits(cond, "warning")) {
[10:26:24.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.466]                         if (muffled) 
[10:26:24.466]                           invokeRestart("muffleWarning")
[10:26:24.466]                       }
[10:26:24.466]                       else if (inherits(cond, "condition")) {
[10:26:24.466]                         if (!is.null(pattern)) {
[10:26:24.466]                           computeRestarts <- base::computeRestarts
[10:26:24.466]                           grepl <- base::grepl
[10:26:24.466]                           restarts <- computeRestarts(cond)
[10:26:24.466]                           for (restart in restarts) {
[10:26:24.466]                             name <- restart$name
[10:26:24.466]                             if (is.null(name)) 
[10:26:24.466]                               next
[10:26:24.466]                             if (!grepl(pattern, name)) 
[10:26:24.466]                               next
[10:26:24.466]                             invokeRestart(restart)
[10:26:24.466]                             muffled <- TRUE
[10:26:24.466]                             break
[10:26:24.466]                           }
[10:26:24.466]                         }
[10:26:24.466]                       }
[10:26:24.466]                       invisible(muffled)
[10:26:24.466]                     }
[10:26:24.466]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.466]                   }
[10:26:24.466]                 }
[10:26:24.466]                 else {
[10:26:24.466]                   if (TRUE) {
[10:26:24.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.466]                     {
[10:26:24.466]                       inherits <- base::inherits
[10:26:24.466]                       invokeRestart <- base::invokeRestart
[10:26:24.466]                       is.null <- base::is.null
[10:26:24.466]                       muffled <- FALSE
[10:26:24.466]                       if (inherits(cond, "message")) {
[10:26:24.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.466]                         if (muffled) 
[10:26:24.466]                           invokeRestart("muffleMessage")
[10:26:24.466]                       }
[10:26:24.466]                       else if (inherits(cond, "warning")) {
[10:26:24.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.466]                         if (muffled) 
[10:26:24.466]                           invokeRestart("muffleWarning")
[10:26:24.466]                       }
[10:26:24.466]                       else if (inherits(cond, "condition")) {
[10:26:24.466]                         if (!is.null(pattern)) {
[10:26:24.466]                           computeRestarts <- base::computeRestarts
[10:26:24.466]                           grepl <- base::grepl
[10:26:24.466]                           restarts <- computeRestarts(cond)
[10:26:24.466]                           for (restart in restarts) {
[10:26:24.466]                             name <- restart$name
[10:26:24.466]                             if (is.null(name)) 
[10:26:24.466]                               next
[10:26:24.466]                             if (!grepl(pattern, name)) 
[10:26:24.466]                               next
[10:26:24.466]                             invokeRestart(restart)
[10:26:24.466]                             muffled <- TRUE
[10:26:24.466]                             break
[10:26:24.466]                           }
[10:26:24.466]                         }
[10:26:24.466]                       }
[10:26:24.466]                       invisible(muffled)
[10:26:24.466]                     }
[10:26:24.466]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.466]                   }
[10:26:24.466]                 }
[10:26:24.466]             }
[10:26:24.466]         }))
[10:26:24.466]     }, error = function(ex) {
[10:26:24.466]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.466]                 ...future.rng), started = ...future.startTime, 
[10:26:24.466]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.466]             version = "1.8"), class = "FutureResult")
[10:26:24.466]     }, finally = {
[10:26:24.466]         if (!identical(...future.workdir, getwd())) 
[10:26:24.466]             setwd(...future.workdir)
[10:26:24.466]         {
[10:26:24.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.466]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.466]             }
[10:26:24.466]             base::options(...future.oldOptions)
[10:26:24.466]             if (.Platform$OS.type == "windows") {
[10:26:24.466]                 old_names <- names(...future.oldEnvVars)
[10:26:24.466]                 envs <- base::Sys.getenv()
[10:26:24.466]                 names <- names(envs)
[10:26:24.466]                 common <- intersect(names, old_names)
[10:26:24.466]                 added <- setdiff(names, old_names)
[10:26:24.466]                 removed <- setdiff(old_names, names)
[10:26:24.466]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.466]                   envs[common]]
[10:26:24.466]                 NAMES <- toupper(changed)
[10:26:24.466]                 args <- list()
[10:26:24.466]                 for (kk in seq_along(NAMES)) {
[10:26:24.466]                   name <- changed[[kk]]
[10:26:24.466]                   NAME <- NAMES[[kk]]
[10:26:24.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.466]                     next
[10:26:24.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.466]                 }
[10:26:24.466]                 NAMES <- toupper(added)
[10:26:24.466]                 for (kk in seq_along(NAMES)) {
[10:26:24.466]                   name <- added[[kk]]
[10:26:24.466]                   NAME <- NAMES[[kk]]
[10:26:24.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.466]                     next
[10:26:24.466]                   args[[name]] <- ""
[10:26:24.466]                 }
[10:26:24.466]                 NAMES <- toupper(removed)
[10:26:24.466]                 for (kk in seq_along(NAMES)) {
[10:26:24.466]                   name <- removed[[kk]]
[10:26:24.466]                   NAME <- NAMES[[kk]]
[10:26:24.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.466]                     next
[10:26:24.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.466]                 }
[10:26:24.466]                 if (length(args) > 0) 
[10:26:24.466]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.466]             }
[10:26:24.466]             else {
[10:26:24.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.466]             }
[10:26:24.466]             {
[10:26:24.466]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.466]                   0L) {
[10:26:24.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.466]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.466]                   base::options(opts)
[10:26:24.466]                 }
[10:26:24.466]                 {
[10:26:24.466]                   {
[10:26:24.466]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.466]                     NULL
[10:26:24.466]                   }
[10:26:24.466]                   options(future.plan = NULL)
[10:26:24.466]                   if (is.na(NA_character_)) 
[10:26:24.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.466]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.466]                     envir = parent.frame()) 
[10:26:24.466]                   {
[10:26:24.466]                     default_workers <- missing(workers)
[10:26:24.466]                     if (is.function(workers)) 
[10:26:24.466]                       workers <- workers()
[10:26:24.466]                     workers <- structure(as.integer(workers), 
[10:26:24.466]                       class = class(workers))
[10:26:24.466]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.466]                       1L)
[10:26:24.466]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.466]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.466]                       if (default_workers) 
[10:26:24.466]                         supportsMulticore(warn = TRUE)
[10:26:24.466]                       return(sequential(..., envir = envir))
[10:26:24.466]                     }
[10:26:24.466]                     oopts <- options(mc.cores = workers)
[10:26:24.466]                     on.exit(options(oopts))
[10:26:24.466]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.466]                       envir = envir)
[10:26:24.466]                     if (!future$lazy) 
[10:26:24.466]                       future <- run(future)
[10:26:24.466]                     invisible(future)
[10:26:24.466]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.466]                 }
[10:26:24.466]             }
[10:26:24.466]         }
[10:26:24.466]     })
[10:26:24.466]     if (TRUE) {
[10:26:24.466]         base::sink(type = "output", split = FALSE)
[10:26:24.466]         if (TRUE) {
[10:26:24.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.466]         }
[10:26:24.466]         else {
[10:26:24.466]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.466]         }
[10:26:24.466]         base::close(...future.stdout)
[10:26:24.466]         ...future.stdout <- NULL
[10:26:24.466]     }
[10:26:24.466]     ...future.result$conditions <- ...future.conditions
[10:26:24.466]     ...future.result$finished <- base::Sys.time()
[10:26:24.466]     ...future.result
[10:26:24.466] }
[10:26:24.469] requestCore(): workers = 2
[10:26:24.471] MulticoreFuture started
 - Creating multicore future #2 ...
[10:26:24.472] plan(): Setting new future strategy stack:
[10:26:24.472] List of future strategies:
[10:26:24.472] 1. sequential:
[10:26:24.472]    - args: function (..., envir = parent.frame())
[10:26:24.472]    - tweaked: FALSE
[10:26:24.472]    - call: NULL
[10:26:24.473] plan(): nbrOfWorkers() = 1
[10:26:24.475] plan(): Setting new future strategy stack:
[10:26:24.475] List of future strategies:
[10:26:24.475] 1. multicore:
[10:26:24.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.475]    - tweaked: FALSE
[10:26:24.475]    - call: plan(multicore)
[10:26:24.476] getGlobalsAndPackages() ...
[10:26:24.476] Not searching for globals
[10:26:24.476] - globals: [0] <none>
[10:26:24.477] getGlobalsAndPackages() ... DONE
[10:26:24.477] Packages needed by the future expression (n = 0): <none>
[10:26:24.478] Packages needed by future strategies (n = 0): <none>
[10:26:24.479] plan(): nbrOfWorkers() = 2
[10:26:24.478] {
[10:26:24.478]     {
[10:26:24.478]         {
[10:26:24.478]             ...future.startTime <- base::Sys.time()
[10:26:24.478]             {
[10:26:24.478]                 {
[10:26:24.478]                   {
[10:26:24.478]                     {
[10:26:24.478]                       base::local({
[10:26:24.478]                         has_future <- base::requireNamespace("future", 
[10:26:24.478]                           quietly = TRUE)
[10:26:24.478]                         if (has_future) {
[10:26:24.478]                           ns <- base::getNamespace("future")
[10:26:24.478]                           version <- ns[[".package"]][["version"]]
[10:26:24.478]                           if (is.null(version)) 
[10:26:24.478]                             version <- utils::packageVersion("future")
[10:26:24.478]                         }
[10:26:24.478]                         else {
[10:26:24.478]                           version <- NULL
[10:26:24.478]                         }
[10:26:24.478]                         if (!has_future || version < "1.8.0") {
[10:26:24.478]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.478]                             "", base::R.version$version.string), 
[10:26:24.478]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.478]                               "release", "version")], collapse = " "), 
[10:26:24.478]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.478]                             info)
[10:26:24.478]                           info <- base::paste(info, collapse = "; ")
[10:26:24.478]                           if (!has_future) {
[10:26:24.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.478]                               info)
[10:26:24.478]                           }
[10:26:24.478]                           else {
[10:26:24.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.478]                               info, version)
[10:26:24.478]                           }
[10:26:24.478]                           base::stop(msg)
[10:26:24.478]                         }
[10:26:24.478]                       })
[10:26:24.478]                     }
[10:26:24.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.478]                     base::options(mc.cores = 1L)
[10:26:24.478]                   }
[10:26:24.478]                   options(future.plan = NULL)
[10:26:24.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.478]                 }
[10:26:24.478]                 ...future.workdir <- getwd()
[10:26:24.478]             }
[10:26:24.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.478]         }
[10:26:24.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.478]             base::names(...future.oldOptions))
[10:26:24.478]     }
[10:26:24.478]     if (FALSE) {
[10:26:24.478]     }
[10:26:24.478]     else {
[10:26:24.478]         if (TRUE) {
[10:26:24.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.478]                 open = "w")
[10:26:24.478]         }
[10:26:24.478]         else {
[10:26:24.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.478]         }
[10:26:24.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.478]             base::sink(type = "output", split = FALSE)
[10:26:24.478]             base::close(...future.stdout)
[10:26:24.478]         }, add = TRUE)
[10:26:24.478]     }
[10:26:24.478]     ...future.frame <- base::sys.nframe()
[10:26:24.478]     ...future.conditions <- base::list()
[10:26:24.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.478]     if (FALSE) {
[10:26:24.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.478]     }
[10:26:24.478]     ...future.result <- base::tryCatch({
[10:26:24.478]         base::withCallingHandlers({
[10:26:24.478]             ...future.value <- base::withVisible(base::local({
[10:26:24.478]                 withCallingHandlers({
[10:26:24.478]                   {
[10:26:24.478]                     ii
[10:26:24.478]                   }
[10:26:24.478]                 }, immediateCondition = function(cond) {
[10:26:24.478]                   save_rds <- function (object, pathname, ...) 
[10:26:24.478]                   {
[10:26:24.478]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.478]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.478]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.478]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.478]                         fi_tmp[["mtime"]])
[10:26:24.478]                     }
[10:26:24.478]                     tryCatch({
[10:26:24.478]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.478]                     }, error = function(ex) {
[10:26:24.478]                       msg <- conditionMessage(ex)
[10:26:24.478]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.478]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.478]                         fi_tmp[["mtime"]], msg)
[10:26:24.478]                       ex$message <- msg
[10:26:24.478]                       stop(ex)
[10:26:24.478]                     })
[10:26:24.478]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.478]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.478]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.478]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.478]                       fi <- file.info(pathname)
[10:26:24.478]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.478]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.478]                         fi[["size"]], fi[["mtime"]])
[10:26:24.478]                       stop(msg)
[10:26:24.478]                     }
[10:26:24.478]                     invisible(pathname)
[10:26:24.478]                   }
[10:26:24.478]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.478]                     rootPath = tempdir()) 
[10:26:24.478]                   {
[10:26:24.478]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.478]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.478]                       tmpdir = path, fileext = ".rds")
[10:26:24.478]                     save_rds(obj, file)
[10:26:24.478]                   }
[10:26:24.478]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.478]                   {
[10:26:24.478]                     inherits <- base::inherits
[10:26:24.478]                     invokeRestart <- base::invokeRestart
[10:26:24.478]                     is.null <- base::is.null
[10:26:24.478]                     muffled <- FALSE
[10:26:24.478]                     if (inherits(cond, "message")) {
[10:26:24.478]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.478]                       if (muffled) 
[10:26:24.478]                         invokeRestart("muffleMessage")
[10:26:24.478]                     }
[10:26:24.478]                     else if (inherits(cond, "warning")) {
[10:26:24.478]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.478]                       if (muffled) 
[10:26:24.478]                         invokeRestart("muffleWarning")
[10:26:24.478]                     }
[10:26:24.478]                     else if (inherits(cond, "condition")) {
[10:26:24.478]                       if (!is.null(pattern)) {
[10:26:24.478]                         computeRestarts <- base::computeRestarts
[10:26:24.478]                         grepl <- base::grepl
[10:26:24.478]                         restarts <- computeRestarts(cond)
[10:26:24.478]                         for (restart in restarts) {
[10:26:24.478]                           name <- restart$name
[10:26:24.478]                           if (is.null(name)) 
[10:26:24.478]                             next
[10:26:24.478]                           if (!grepl(pattern, name)) 
[10:26:24.478]                             next
[10:26:24.478]                           invokeRestart(restart)
[10:26:24.478]                           muffled <- TRUE
[10:26:24.478]                           break
[10:26:24.478]                         }
[10:26:24.478]                       }
[10:26:24.478]                     }
[10:26:24.478]                     invisible(muffled)
[10:26:24.478]                   }
[10:26:24.478]                   muffleCondition(cond)
[10:26:24.478]                 })
[10:26:24.478]             }))
[10:26:24.478]             future::FutureResult(value = ...future.value$value, 
[10:26:24.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.478]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.478]                     ...future.globalenv.names))
[10:26:24.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.478]         }, condition = base::local({
[10:26:24.478]             c <- base::c
[10:26:24.478]             inherits <- base::inherits
[10:26:24.478]             invokeRestart <- base::invokeRestart
[10:26:24.478]             length <- base::length
[10:26:24.478]             list <- base::list
[10:26:24.478]             seq.int <- base::seq.int
[10:26:24.478]             signalCondition <- base::signalCondition
[10:26:24.478]             sys.calls <- base::sys.calls
[10:26:24.478]             `[[` <- base::`[[`
[10:26:24.478]             `+` <- base::`+`
[10:26:24.478]             `<<-` <- base::`<<-`
[10:26:24.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.478]                   3L)]
[10:26:24.478]             }
[10:26:24.478]             function(cond) {
[10:26:24.478]                 is_error <- inherits(cond, "error")
[10:26:24.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.478]                   NULL)
[10:26:24.478]                 if (is_error) {
[10:26:24.478]                   sessionInformation <- function() {
[10:26:24.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.478]                       search = base::search(), system = base::Sys.info())
[10:26:24.478]                   }
[10:26:24.478]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.478]                     cond$call), session = sessionInformation(), 
[10:26:24.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.478]                   signalCondition(cond)
[10:26:24.478]                 }
[10:26:24.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.478]                 "immediateCondition"))) {
[10:26:24.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.478]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.478]                   if (TRUE && !signal) {
[10:26:24.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.478]                     {
[10:26:24.478]                       inherits <- base::inherits
[10:26:24.478]                       invokeRestart <- base::invokeRestart
[10:26:24.478]                       is.null <- base::is.null
[10:26:24.478]                       muffled <- FALSE
[10:26:24.478]                       if (inherits(cond, "message")) {
[10:26:24.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.478]                         if (muffled) 
[10:26:24.478]                           invokeRestart("muffleMessage")
[10:26:24.478]                       }
[10:26:24.478]                       else if (inherits(cond, "warning")) {
[10:26:24.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.478]                         if (muffled) 
[10:26:24.478]                           invokeRestart("muffleWarning")
[10:26:24.478]                       }
[10:26:24.478]                       else if (inherits(cond, "condition")) {
[10:26:24.478]                         if (!is.null(pattern)) {
[10:26:24.478]                           computeRestarts <- base::computeRestarts
[10:26:24.478]                           grepl <- base::grepl
[10:26:24.478]                           restarts <- computeRestarts(cond)
[10:26:24.478]                           for (restart in restarts) {
[10:26:24.478]                             name <- restart$name
[10:26:24.478]                             if (is.null(name)) 
[10:26:24.478]                               next
[10:26:24.478]                             if (!grepl(pattern, name)) 
[10:26:24.478]                               next
[10:26:24.478]                             invokeRestart(restart)
[10:26:24.478]                             muffled <- TRUE
[10:26:24.478]                             break
[10:26:24.478]                           }
[10:26:24.478]                         }
[10:26:24.478]                       }
[10:26:24.478]                       invisible(muffled)
[10:26:24.478]                     }
[10:26:24.478]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.478]                   }
[10:26:24.478]                 }
[10:26:24.478]                 else {
[10:26:24.478]                   if (TRUE) {
[10:26:24.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.478]                     {
[10:26:24.478]                       inherits <- base::inherits
[10:26:24.478]                       invokeRestart <- base::invokeRestart
[10:26:24.478]                       is.null <- base::is.null
[10:26:24.478]                       muffled <- FALSE
[10:26:24.478]                       if (inherits(cond, "message")) {
[10:26:24.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.478]                         if (muffled) 
[10:26:24.478]                           invokeRestart("muffleMessage")
[10:26:24.478]                       }
[10:26:24.478]                       else if (inherits(cond, "warning")) {
[10:26:24.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.478]                         if (muffled) 
[10:26:24.478]                           invokeRestart("muffleWarning")
[10:26:24.478]                       }
[10:26:24.478]                       else if (inherits(cond, "condition")) {
[10:26:24.478]                         if (!is.null(pattern)) {
[10:26:24.478]                           computeRestarts <- base::computeRestarts
[10:26:24.478]                           grepl <- base::grepl
[10:26:24.478]                           restarts <- computeRestarts(cond)
[10:26:24.478]                           for (restart in restarts) {
[10:26:24.478]                             name <- restart$name
[10:26:24.478]                             if (is.null(name)) 
[10:26:24.478]                               next
[10:26:24.478]                             if (!grepl(pattern, name)) 
[10:26:24.478]                               next
[10:26:24.478]                             invokeRestart(restart)
[10:26:24.478]                             muffled <- TRUE
[10:26:24.478]                             break
[10:26:24.478]                           }
[10:26:24.478]                         }
[10:26:24.478]                       }
[10:26:24.478]                       invisible(muffled)
[10:26:24.478]                     }
[10:26:24.478]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.478]                   }
[10:26:24.478]                 }
[10:26:24.478]             }
[10:26:24.478]         }))
[10:26:24.478]     }, error = function(ex) {
[10:26:24.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.478]                 ...future.rng), started = ...future.startTime, 
[10:26:24.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.478]             version = "1.8"), class = "FutureResult")
[10:26:24.478]     }, finally = {
[10:26:24.478]         if (!identical(...future.workdir, getwd())) 
[10:26:24.478]             setwd(...future.workdir)
[10:26:24.478]         {
[10:26:24.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.478]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.478]             }
[10:26:24.478]             base::options(...future.oldOptions)
[10:26:24.478]             if (.Platform$OS.type == "windows") {
[10:26:24.478]                 old_names <- names(...future.oldEnvVars)
[10:26:24.478]                 envs <- base::Sys.getenv()
[10:26:24.478]                 names <- names(envs)
[10:26:24.478]                 common <- intersect(names, old_names)
[10:26:24.478]                 added <- setdiff(names, old_names)
[10:26:24.478]                 removed <- setdiff(old_names, names)
[10:26:24.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.478]                   envs[common]]
[10:26:24.478]                 NAMES <- toupper(changed)
[10:26:24.478]                 args <- list()
[10:26:24.478]                 for (kk in seq_along(NAMES)) {
[10:26:24.478]                   name <- changed[[kk]]
[10:26:24.478]                   NAME <- NAMES[[kk]]
[10:26:24.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.478]                     next
[10:26:24.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.478]                 }
[10:26:24.478]                 NAMES <- toupper(added)
[10:26:24.478]                 for (kk in seq_along(NAMES)) {
[10:26:24.478]                   name <- added[[kk]]
[10:26:24.478]                   NAME <- NAMES[[kk]]
[10:26:24.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.478]                     next
[10:26:24.478]                   args[[name]] <- ""
[10:26:24.478]                 }
[10:26:24.478]                 NAMES <- toupper(removed)
[10:26:24.478]                 for (kk in seq_along(NAMES)) {
[10:26:24.478]                   name <- removed[[kk]]
[10:26:24.478]                   NAME <- NAMES[[kk]]
[10:26:24.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.478]                     next
[10:26:24.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.478]                 }
[10:26:24.478]                 if (length(args) > 0) 
[10:26:24.478]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.478]             }
[10:26:24.478]             else {
[10:26:24.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.478]             }
[10:26:24.478]             {
[10:26:24.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.478]                   0L) {
[10:26:24.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.478]                   base::options(opts)
[10:26:24.478]                 }
[10:26:24.478]                 {
[10:26:24.478]                   {
[10:26:24.478]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.478]                     NULL
[10:26:24.478]                   }
[10:26:24.478]                   options(future.plan = NULL)
[10:26:24.478]                   if (is.na(NA_character_)) 
[10:26:24.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.478]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.478]                     envir = parent.frame()) 
[10:26:24.478]                   {
[10:26:24.478]                     default_workers <- missing(workers)
[10:26:24.478]                     if (is.function(workers)) 
[10:26:24.478]                       workers <- workers()
[10:26:24.478]                     workers <- structure(as.integer(workers), 
[10:26:24.478]                       class = class(workers))
[10:26:24.478]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.478]                       1L)
[10:26:24.478]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.478]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.478]                       if (default_workers) 
[10:26:24.478]                         supportsMulticore(warn = TRUE)
[10:26:24.478]                       return(sequential(..., envir = envir))
[10:26:24.478]                     }
[10:26:24.478]                     oopts <- options(mc.cores = workers)
[10:26:24.478]                     on.exit(options(oopts))
[10:26:24.478]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.478]                       envir = envir)
[10:26:24.478]                     if (!future$lazy) 
[10:26:24.478]                       future <- run(future)
[10:26:24.478]                     invisible(future)
[10:26:24.478]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.478]                 }
[10:26:24.478]             }
[10:26:24.478]         }
[10:26:24.478]     })
[10:26:24.478]     if (TRUE) {
[10:26:24.478]         base::sink(type = "output", split = FALSE)
[10:26:24.478]         if (TRUE) {
[10:26:24.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.478]         }
[10:26:24.478]         else {
[10:26:24.478]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.478]         }
[10:26:24.478]         base::close(...future.stdout)
[10:26:24.478]         ...future.stdout <- NULL
[10:26:24.478]     }
[10:26:24.478]     ...future.result$conditions <- ...future.conditions
[10:26:24.478]     ...future.result$finished <- base::Sys.time()
[10:26:24.478]     ...future.result
[10:26:24.478] }
[10:26:24.482] requestCore(): workers = 2
[10:26:24.483] MulticoreFuture started
 - Creating multicore future #3 ...
[10:26:24.484] plan(): Setting new future strategy stack:
[10:26:24.485] List of future strategies:
[10:26:24.485] 1. sequential:
[10:26:24.485]    - args: function (..., envir = parent.frame())
[10:26:24.485]    - tweaked: FALSE
[10:26:24.485]    - call: NULL
[10:26:24.486] plan(): nbrOfWorkers() = 1
[10:26:24.487] plan(): Setting new future strategy stack:
[10:26:24.488] List of future strategies:
[10:26:24.488] 1. multicore:
[10:26:24.488]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.488]    - tweaked: FALSE
[10:26:24.488]    - call: plan(multicore)
[10:26:24.489] getGlobalsAndPackages() ...
[10:26:24.489] Not searching for globals
[10:26:24.489] - globals: [0] <none>
[10:26:24.490] getGlobalsAndPackages() ... DONE
[10:26:24.490] Packages needed by the future expression (n = 0): <none>
[10:26:24.490] Packages needed by future strategies (n = 0): <none>
[10:26:24.492] plan(): nbrOfWorkers() = 2
[10:26:24.491] {
[10:26:24.491]     {
[10:26:24.491]         {
[10:26:24.491]             ...future.startTime <- base::Sys.time()
[10:26:24.491]             {
[10:26:24.491]                 {
[10:26:24.491]                   {
[10:26:24.491]                     {
[10:26:24.491]                       base::local({
[10:26:24.491]                         has_future <- base::requireNamespace("future", 
[10:26:24.491]                           quietly = TRUE)
[10:26:24.491]                         if (has_future) {
[10:26:24.491]                           ns <- base::getNamespace("future")
[10:26:24.491]                           version <- ns[[".package"]][["version"]]
[10:26:24.491]                           if (is.null(version)) 
[10:26:24.491]                             version <- utils::packageVersion("future")
[10:26:24.491]                         }
[10:26:24.491]                         else {
[10:26:24.491]                           version <- NULL
[10:26:24.491]                         }
[10:26:24.491]                         if (!has_future || version < "1.8.0") {
[10:26:24.491]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.491]                             "", base::R.version$version.string), 
[10:26:24.491]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.491]                               "release", "version")], collapse = " "), 
[10:26:24.491]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.491]                             info)
[10:26:24.491]                           info <- base::paste(info, collapse = "; ")
[10:26:24.491]                           if (!has_future) {
[10:26:24.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.491]                               info)
[10:26:24.491]                           }
[10:26:24.491]                           else {
[10:26:24.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.491]                               info, version)
[10:26:24.491]                           }
[10:26:24.491]                           base::stop(msg)
[10:26:24.491]                         }
[10:26:24.491]                       })
[10:26:24.491]                     }
[10:26:24.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.491]                     base::options(mc.cores = 1L)
[10:26:24.491]                   }
[10:26:24.491]                   options(future.plan = NULL)
[10:26:24.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.491]                 }
[10:26:24.491]                 ...future.workdir <- getwd()
[10:26:24.491]             }
[10:26:24.491]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.491]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.491]         }
[10:26:24.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.491]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.491]             base::names(...future.oldOptions))
[10:26:24.491]     }
[10:26:24.491]     if (FALSE) {
[10:26:24.491]     }
[10:26:24.491]     else {
[10:26:24.491]         if (TRUE) {
[10:26:24.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.491]                 open = "w")
[10:26:24.491]         }
[10:26:24.491]         else {
[10:26:24.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.491]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.491]         }
[10:26:24.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.491]             base::sink(type = "output", split = FALSE)
[10:26:24.491]             base::close(...future.stdout)
[10:26:24.491]         }, add = TRUE)
[10:26:24.491]     }
[10:26:24.491]     ...future.frame <- base::sys.nframe()
[10:26:24.491]     ...future.conditions <- base::list()
[10:26:24.491]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.491]     if (FALSE) {
[10:26:24.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.491]     }
[10:26:24.491]     ...future.result <- base::tryCatch({
[10:26:24.491]         base::withCallingHandlers({
[10:26:24.491]             ...future.value <- base::withVisible(base::local({
[10:26:24.491]                 withCallingHandlers({
[10:26:24.491]                   {
[10:26:24.491]                     ii
[10:26:24.491]                   }
[10:26:24.491]                 }, immediateCondition = function(cond) {
[10:26:24.491]                   save_rds <- function (object, pathname, ...) 
[10:26:24.491]                   {
[10:26:24.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.491]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.491]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.491]                         fi_tmp[["mtime"]])
[10:26:24.491]                     }
[10:26:24.491]                     tryCatch({
[10:26:24.491]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.491]                     }, error = function(ex) {
[10:26:24.491]                       msg <- conditionMessage(ex)
[10:26:24.491]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.491]                         fi_tmp[["mtime"]], msg)
[10:26:24.491]                       ex$message <- msg
[10:26:24.491]                       stop(ex)
[10:26:24.491]                     })
[10:26:24.491]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.491]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.491]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.491]                       fi <- file.info(pathname)
[10:26:24.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.491]                         fi[["size"]], fi[["mtime"]])
[10:26:24.491]                       stop(msg)
[10:26:24.491]                     }
[10:26:24.491]                     invisible(pathname)
[10:26:24.491]                   }
[10:26:24.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.491]                     rootPath = tempdir()) 
[10:26:24.491]                   {
[10:26:24.491]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.491]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.491]                       tmpdir = path, fileext = ".rds")
[10:26:24.491]                     save_rds(obj, file)
[10:26:24.491]                   }
[10:26:24.491]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.491]                   {
[10:26:24.491]                     inherits <- base::inherits
[10:26:24.491]                     invokeRestart <- base::invokeRestart
[10:26:24.491]                     is.null <- base::is.null
[10:26:24.491]                     muffled <- FALSE
[10:26:24.491]                     if (inherits(cond, "message")) {
[10:26:24.491]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.491]                       if (muffled) 
[10:26:24.491]                         invokeRestart("muffleMessage")
[10:26:24.491]                     }
[10:26:24.491]                     else if (inherits(cond, "warning")) {
[10:26:24.491]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.491]                       if (muffled) 
[10:26:24.491]                         invokeRestart("muffleWarning")
[10:26:24.491]                     }
[10:26:24.491]                     else if (inherits(cond, "condition")) {
[10:26:24.491]                       if (!is.null(pattern)) {
[10:26:24.491]                         computeRestarts <- base::computeRestarts
[10:26:24.491]                         grepl <- base::grepl
[10:26:24.491]                         restarts <- computeRestarts(cond)
[10:26:24.491]                         for (restart in restarts) {
[10:26:24.491]                           name <- restart$name
[10:26:24.491]                           if (is.null(name)) 
[10:26:24.491]                             next
[10:26:24.491]                           if (!grepl(pattern, name)) 
[10:26:24.491]                             next
[10:26:24.491]                           invokeRestart(restart)
[10:26:24.491]                           muffled <- TRUE
[10:26:24.491]                           break
[10:26:24.491]                         }
[10:26:24.491]                       }
[10:26:24.491]                     }
[10:26:24.491]                     invisible(muffled)
[10:26:24.491]                   }
[10:26:24.491]                   muffleCondition(cond)
[10:26:24.491]                 })
[10:26:24.491]             }))
[10:26:24.491]             future::FutureResult(value = ...future.value$value, 
[10:26:24.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.491]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.491]                     ...future.globalenv.names))
[10:26:24.491]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.491]         }, condition = base::local({
[10:26:24.491]             c <- base::c
[10:26:24.491]             inherits <- base::inherits
[10:26:24.491]             invokeRestart <- base::invokeRestart
[10:26:24.491]             length <- base::length
[10:26:24.491]             list <- base::list
[10:26:24.491]             seq.int <- base::seq.int
[10:26:24.491]             signalCondition <- base::signalCondition
[10:26:24.491]             sys.calls <- base::sys.calls
[10:26:24.491]             `[[` <- base::`[[`
[10:26:24.491]             `+` <- base::`+`
[10:26:24.491]             `<<-` <- base::`<<-`
[10:26:24.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.491]                   3L)]
[10:26:24.491]             }
[10:26:24.491]             function(cond) {
[10:26:24.491]                 is_error <- inherits(cond, "error")
[10:26:24.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.491]                   NULL)
[10:26:24.491]                 if (is_error) {
[10:26:24.491]                   sessionInformation <- function() {
[10:26:24.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.491]                       search = base::search(), system = base::Sys.info())
[10:26:24.491]                   }
[10:26:24.491]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.491]                     cond$call), session = sessionInformation(), 
[10:26:24.491]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.491]                   signalCondition(cond)
[10:26:24.491]                 }
[10:26:24.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.491]                 "immediateCondition"))) {
[10:26:24.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.491]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.491]                   if (TRUE && !signal) {
[10:26:24.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.491]                     {
[10:26:24.491]                       inherits <- base::inherits
[10:26:24.491]                       invokeRestart <- base::invokeRestart
[10:26:24.491]                       is.null <- base::is.null
[10:26:24.491]                       muffled <- FALSE
[10:26:24.491]                       if (inherits(cond, "message")) {
[10:26:24.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.491]                         if (muffled) 
[10:26:24.491]                           invokeRestart("muffleMessage")
[10:26:24.491]                       }
[10:26:24.491]                       else if (inherits(cond, "warning")) {
[10:26:24.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.491]                         if (muffled) 
[10:26:24.491]                           invokeRestart("muffleWarning")
[10:26:24.491]                       }
[10:26:24.491]                       else if (inherits(cond, "condition")) {
[10:26:24.491]                         if (!is.null(pattern)) {
[10:26:24.491]                           computeRestarts <- base::computeRestarts
[10:26:24.491]                           grepl <- base::grepl
[10:26:24.491]                           restarts <- computeRestarts(cond)
[10:26:24.491]                           for (restart in restarts) {
[10:26:24.491]                             name <- restart$name
[10:26:24.491]                             if (is.null(name)) 
[10:26:24.491]                               next
[10:26:24.491]                             if (!grepl(pattern, name)) 
[10:26:24.491]                               next
[10:26:24.491]                             invokeRestart(restart)
[10:26:24.491]                             muffled <- TRUE
[10:26:24.491]                             break
[10:26:24.491]                           }
[10:26:24.491]                         }
[10:26:24.491]                       }
[10:26:24.491]                       invisible(muffled)
[10:26:24.491]                     }
[10:26:24.491]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.491]                   }
[10:26:24.491]                 }
[10:26:24.491]                 else {
[10:26:24.491]                   if (TRUE) {
[10:26:24.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.491]                     {
[10:26:24.491]                       inherits <- base::inherits
[10:26:24.491]                       invokeRestart <- base::invokeRestart
[10:26:24.491]                       is.null <- base::is.null
[10:26:24.491]                       muffled <- FALSE
[10:26:24.491]                       if (inherits(cond, "message")) {
[10:26:24.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.491]                         if (muffled) 
[10:26:24.491]                           invokeRestart("muffleMessage")
[10:26:24.491]                       }
[10:26:24.491]                       else if (inherits(cond, "warning")) {
[10:26:24.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.491]                         if (muffled) 
[10:26:24.491]                           invokeRestart("muffleWarning")
[10:26:24.491]                       }
[10:26:24.491]                       else if (inherits(cond, "condition")) {
[10:26:24.491]                         if (!is.null(pattern)) {
[10:26:24.491]                           computeRestarts <- base::computeRestarts
[10:26:24.491]                           grepl <- base::grepl
[10:26:24.491]                           restarts <- computeRestarts(cond)
[10:26:24.491]                           for (restart in restarts) {
[10:26:24.491]                             name <- restart$name
[10:26:24.491]                             if (is.null(name)) 
[10:26:24.491]                               next
[10:26:24.491]                             if (!grepl(pattern, name)) 
[10:26:24.491]                               next
[10:26:24.491]                             invokeRestart(restart)
[10:26:24.491]                             muffled <- TRUE
[10:26:24.491]                             break
[10:26:24.491]                           }
[10:26:24.491]                         }
[10:26:24.491]                       }
[10:26:24.491]                       invisible(muffled)
[10:26:24.491]                     }
[10:26:24.491]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.491]                   }
[10:26:24.491]                 }
[10:26:24.491]             }
[10:26:24.491]         }))
[10:26:24.491]     }, error = function(ex) {
[10:26:24.491]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.491]                 ...future.rng), started = ...future.startTime, 
[10:26:24.491]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.491]             version = "1.8"), class = "FutureResult")
[10:26:24.491]     }, finally = {
[10:26:24.491]         if (!identical(...future.workdir, getwd())) 
[10:26:24.491]             setwd(...future.workdir)
[10:26:24.491]         {
[10:26:24.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.491]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.491]             }
[10:26:24.491]             base::options(...future.oldOptions)
[10:26:24.491]             if (.Platform$OS.type == "windows") {
[10:26:24.491]                 old_names <- names(...future.oldEnvVars)
[10:26:24.491]                 envs <- base::Sys.getenv()
[10:26:24.491]                 names <- names(envs)
[10:26:24.491]                 common <- intersect(names, old_names)
[10:26:24.491]                 added <- setdiff(names, old_names)
[10:26:24.491]                 removed <- setdiff(old_names, names)
[10:26:24.491]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.491]                   envs[common]]
[10:26:24.491]                 NAMES <- toupper(changed)
[10:26:24.491]                 args <- list()
[10:26:24.491]                 for (kk in seq_along(NAMES)) {
[10:26:24.491]                   name <- changed[[kk]]
[10:26:24.491]                   NAME <- NAMES[[kk]]
[10:26:24.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.491]                     next
[10:26:24.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.491]                 }
[10:26:24.491]                 NAMES <- toupper(added)
[10:26:24.491]                 for (kk in seq_along(NAMES)) {
[10:26:24.491]                   name <- added[[kk]]
[10:26:24.491]                   NAME <- NAMES[[kk]]
[10:26:24.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.491]                     next
[10:26:24.491]                   args[[name]] <- ""
[10:26:24.491]                 }
[10:26:24.491]                 NAMES <- toupper(removed)
[10:26:24.491]                 for (kk in seq_along(NAMES)) {
[10:26:24.491]                   name <- removed[[kk]]
[10:26:24.491]                   NAME <- NAMES[[kk]]
[10:26:24.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.491]                     next
[10:26:24.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.491]                 }
[10:26:24.491]                 if (length(args) > 0) 
[10:26:24.491]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.491]             }
[10:26:24.491]             else {
[10:26:24.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.491]             }
[10:26:24.491]             {
[10:26:24.491]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.491]                   0L) {
[10:26:24.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.491]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.491]                   base::options(opts)
[10:26:24.491]                 }
[10:26:24.491]                 {
[10:26:24.491]                   {
[10:26:24.491]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.491]                     NULL
[10:26:24.491]                   }
[10:26:24.491]                   options(future.plan = NULL)
[10:26:24.491]                   if (is.na(NA_character_)) 
[10:26:24.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.491]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.491]                     envir = parent.frame()) 
[10:26:24.491]                   {
[10:26:24.491]                     default_workers <- missing(workers)
[10:26:24.491]                     if (is.function(workers)) 
[10:26:24.491]                       workers <- workers()
[10:26:24.491]                     workers <- structure(as.integer(workers), 
[10:26:24.491]                       class = class(workers))
[10:26:24.491]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.491]                       1L)
[10:26:24.491]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.491]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.491]                       if (default_workers) 
[10:26:24.491]                         supportsMulticore(warn = TRUE)
[10:26:24.491]                       return(sequential(..., envir = envir))
[10:26:24.491]                     }
[10:26:24.491]                     oopts <- options(mc.cores = workers)
[10:26:24.491]                     on.exit(options(oopts))
[10:26:24.491]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.491]                       envir = envir)
[10:26:24.491]                     if (!future$lazy) 
[10:26:24.491]                       future <- run(future)
[10:26:24.491]                     invisible(future)
[10:26:24.491]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.491]                 }
[10:26:24.491]             }
[10:26:24.491]         }
[10:26:24.491]     })
[10:26:24.491]     if (TRUE) {
[10:26:24.491]         base::sink(type = "output", split = FALSE)
[10:26:24.491]         if (TRUE) {
[10:26:24.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.491]         }
[10:26:24.491]         else {
[10:26:24.491]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.491]         }
[10:26:24.491]         base::close(...future.stdout)
[10:26:24.491]         ...future.stdout <- NULL
[10:26:24.491]     }
[10:26:24.491]     ...future.result$conditions <- ...future.conditions
[10:26:24.491]     ...future.result$finished <- base::Sys.time()
[10:26:24.491]     ...future.result
[10:26:24.491] }
[10:26:24.494] requestCore(): workers = 2
[10:26:24.495] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:24.506] result() for MulticoreFuture ...
[10:26:24.507] result() for MulticoreFuture ...
[10:26:24.507] result() for MulticoreFuture ... done
[10:26:24.507] result() for MulticoreFuture ... done
[10:26:24.507] result() for MulticoreFuture ...
[10:26:24.507] result() for MulticoreFuture ... done
[10:26:24.510] MulticoreFuture started
 - Creating multicore future #4 ...
[10:26:24.511] plan(): Setting new future strategy stack:
[10:26:24.511] List of future strategies:
[10:26:24.511] 1. sequential:
[10:26:24.511]    - args: function (..., envir = parent.frame())
[10:26:24.511]    - tweaked: FALSE
[10:26:24.511]    - call: NULL
[10:26:24.512] plan(): nbrOfWorkers() = 1
[10:26:24.513] plan(): Setting new future strategy stack:
[10:26:24.514] List of future strategies:
[10:26:24.514] 1. multicore:
[10:26:24.514]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.514]    - tweaked: FALSE
[10:26:24.514]    - call: plan(multicore)
[10:26:24.515] getGlobalsAndPackages() ...
[10:26:24.515] Not searching for globals
[10:26:24.515] - globals: [0] <none>
[10:26:24.516] getGlobalsAndPackages() ... DONE
[10:26:24.516] Packages needed by the future expression (n = 0): <none>
[10:26:24.517] Packages needed by future strategies (n = 0): <none>
[10:26:24.518] plan(): nbrOfWorkers() = 2
[10:26:24.517] {
[10:26:24.517]     {
[10:26:24.517]         {
[10:26:24.517]             ...future.startTime <- base::Sys.time()
[10:26:24.517]             {
[10:26:24.517]                 {
[10:26:24.517]                   {
[10:26:24.517]                     {
[10:26:24.517]                       base::local({
[10:26:24.517]                         has_future <- base::requireNamespace("future", 
[10:26:24.517]                           quietly = TRUE)
[10:26:24.517]                         if (has_future) {
[10:26:24.517]                           ns <- base::getNamespace("future")
[10:26:24.517]                           version <- ns[[".package"]][["version"]]
[10:26:24.517]                           if (is.null(version)) 
[10:26:24.517]                             version <- utils::packageVersion("future")
[10:26:24.517]                         }
[10:26:24.517]                         else {
[10:26:24.517]                           version <- NULL
[10:26:24.517]                         }
[10:26:24.517]                         if (!has_future || version < "1.8.0") {
[10:26:24.517]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.517]                             "", base::R.version$version.string), 
[10:26:24.517]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.517]                               "release", "version")], collapse = " "), 
[10:26:24.517]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.517]                             info)
[10:26:24.517]                           info <- base::paste(info, collapse = "; ")
[10:26:24.517]                           if (!has_future) {
[10:26:24.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.517]                               info)
[10:26:24.517]                           }
[10:26:24.517]                           else {
[10:26:24.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.517]                               info, version)
[10:26:24.517]                           }
[10:26:24.517]                           base::stop(msg)
[10:26:24.517]                         }
[10:26:24.517]                       })
[10:26:24.517]                     }
[10:26:24.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.517]                     base::options(mc.cores = 1L)
[10:26:24.517]                   }
[10:26:24.517]                   options(future.plan = NULL)
[10:26:24.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.517]                 }
[10:26:24.517]                 ...future.workdir <- getwd()
[10:26:24.517]             }
[10:26:24.517]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.517]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.517]         }
[10:26:24.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.517]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.517]             base::names(...future.oldOptions))
[10:26:24.517]     }
[10:26:24.517]     if (FALSE) {
[10:26:24.517]     }
[10:26:24.517]     else {
[10:26:24.517]         if (TRUE) {
[10:26:24.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.517]                 open = "w")
[10:26:24.517]         }
[10:26:24.517]         else {
[10:26:24.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.517]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.517]         }
[10:26:24.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.517]             base::sink(type = "output", split = FALSE)
[10:26:24.517]             base::close(...future.stdout)
[10:26:24.517]         }, add = TRUE)
[10:26:24.517]     }
[10:26:24.517]     ...future.frame <- base::sys.nframe()
[10:26:24.517]     ...future.conditions <- base::list()
[10:26:24.517]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.517]     if (FALSE) {
[10:26:24.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.517]     }
[10:26:24.517]     ...future.result <- base::tryCatch({
[10:26:24.517]         base::withCallingHandlers({
[10:26:24.517]             ...future.value <- base::withVisible(base::local({
[10:26:24.517]                 withCallingHandlers({
[10:26:24.517]                   {
[10:26:24.517]                     ii
[10:26:24.517]                   }
[10:26:24.517]                 }, immediateCondition = function(cond) {
[10:26:24.517]                   save_rds <- function (object, pathname, ...) 
[10:26:24.517]                   {
[10:26:24.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.517]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.517]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.517]                         fi_tmp[["mtime"]])
[10:26:24.517]                     }
[10:26:24.517]                     tryCatch({
[10:26:24.517]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.517]                     }, error = function(ex) {
[10:26:24.517]                       msg <- conditionMessage(ex)
[10:26:24.517]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.517]                         fi_tmp[["mtime"]], msg)
[10:26:24.517]                       ex$message <- msg
[10:26:24.517]                       stop(ex)
[10:26:24.517]                     })
[10:26:24.517]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.517]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.517]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.517]                       fi <- file.info(pathname)
[10:26:24.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.517]                         fi[["size"]], fi[["mtime"]])
[10:26:24.517]                       stop(msg)
[10:26:24.517]                     }
[10:26:24.517]                     invisible(pathname)
[10:26:24.517]                   }
[10:26:24.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.517]                     rootPath = tempdir()) 
[10:26:24.517]                   {
[10:26:24.517]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.517]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.517]                       tmpdir = path, fileext = ".rds")
[10:26:24.517]                     save_rds(obj, file)
[10:26:24.517]                   }
[10:26:24.517]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.517]                   {
[10:26:24.517]                     inherits <- base::inherits
[10:26:24.517]                     invokeRestart <- base::invokeRestart
[10:26:24.517]                     is.null <- base::is.null
[10:26:24.517]                     muffled <- FALSE
[10:26:24.517]                     if (inherits(cond, "message")) {
[10:26:24.517]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.517]                       if (muffled) 
[10:26:24.517]                         invokeRestart("muffleMessage")
[10:26:24.517]                     }
[10:26:24.517]                     else if (inherits(cond, "warning")) {
[10:26:24.517]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.517]                       if (muffled) 
[10:26:24.517]                         invokeRestart("muffleWarning")
[10:26:24.517]                     }
[10:26:24.517]                     else if (inherits(cond, "condition")) {
[10:26:24.517]                       if (!is.null(pattern)) {
[10:26:24.517]                         computeRestarts <- base::computeRestarts
[10:26:24.517]                         grepl <- base::grepl
[10:26:24.517]                         restarts <- computeRestarts(cond)
[10:26:24.517]                         for (restart in restarts) {
[10:26:24.517]                           name <- restart$name
[10:26:24.517]                           if (is.null(name)) 
[10:26:24.517]                             next
[10:26:24.517]                           if (!grepl(pattern, name)) 
[10:26:24.517]                             next
[10:26:24.517]                           invokeRestart(restart)
[10:26:24.517]                           muffled <- TRUE
[10:26:24.517]                           break
[10:26:24.517]                         }
[10:26:24.517]                       }
[10:26:24.517]                     }
[10:26:24.517]                     invisible(muffled)
[10:26:24.517]                   }
[10:26:24.517]                   muffleCondition(cond)
[10:26:24.517]                 })
[10:26:24.517]             }))
[10:26:24.517]             future::FutureResult(value = ...future.value$value, 
[10:26:24.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.517]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.517]                     ...future.globalenv.names))
[10:26:24.517]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.517]         }, condition = base::local({
[10:26:24.517]             c <- base::c
[10:26:24.517]             inherits <- base::inherits
[10:26:24.517]             invokeRestart <- base::invokeRestart
[10:26:24.517]             length <- base::length
[10:26:24.517]             list <- base::list
[10:26:24.517]             seq.int <- base::seq.int
[10:26:24.517]             signalCondition <- base::signalCondition
[10:26:24.517]             sys.calls <- base::sys.calls
[10:26:24.517]             `[[` <- base::`[[`
[10:26:24.517]             `+` <- base::`+`
[10:26:24.517]             `<<-` <- base::`<<-`
[10:26:24.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.517]                   3L)]
[10:26:24.517]             }
[10:26:24.517]             function(cond) {
[10:26:24.517]                 is_error <- inherits(cond, "error")
[10:26:24.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.517]                   NULL)
[10:26:24.517]                 if (is_error) {
[10:26:24.517]                   sessionInformation <- function() {
[10:26:24.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.517]                       search = base::search(), system = base::Sys.info())
[10:26:24.517]                   }
[10:26:24.517]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.517]                     cond$call), session = sessionInformation(), 
[10:26:24.517]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.517]                   signalCondition(cond)
[10:26:24.517]                 }
[10:26:24.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.517]                 "immediateCondition"))) {
[10:26:24.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.517]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.517]                   if (TRUE && !signal) {
[10:26:24.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.517]                     {
[10:26:24.517]                       inherits <- base::inherits
[10:26:24.517]                       invokeRestart <- base::invokeRestart
[10:26:24.517]                       is.null <- base::is.null
[10:26:24.517]                       muffled <- FALSE
[10:26:24.517]                       if (inherits(cond, "message")) {
[10:26:24.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.517]                         if (muffled) 
[10:26:24.517]                           invokeRestart("muffleMessage")
[10:26:24.517]                       }
[10:26:24.517]                       else if (inherits(cond, "warning")) {
[10:26:24.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.517]                         if (muffled) 
[10:26:24.517]                           invokeRestart("muffleWarning")
[10:26:24.517]                       }
[10:26:24.517]                       else if (inherits(cond, "condition")) {
[10:26:24.517]                         if (!is.null(pattern)) {
[10:26:24.517]                           computeRestarts <- base::computeRestarts
[10:26:24.517]                           grepl <- base::grepl
[10:26:24.517]                           restarts <- computeRestarts(cond)
[10:26:24.517]                           for (restart in restarts) {
[10:26:24.517]                             name <- restart$name
[10:26:24.517]                             if (is.null(name)) 
[10:26:24.517]                               next
[10:26:24.517]                             if (!grepl(pattern, name)) 
[10:26:24.517]                               next
[10:26:24.517]                             invokeRestart(restart)
[10:26:24.517]                             muffled <- TRUE
[10:26:24.517]                             break
[10:26:24.517]                           }
[10:26:24.517]                         }
[10:26:24.517]                       }
[10:26:24.517]                       invisible(muffled)
[10:26:24.517]                     }
[10:26:24.517]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.517]                   }
[10:26:24.517]                 }
[10:26:24.517]                 else {
[10:26:24.517]                   if (TRUE) {
[10:26:24.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.517]                     {
[10:26:24.517]                       inherits <- base::inherits
[10:26:24.517]                       invokeRestart <- base::invokeRestart
[10:26:24.517]                       is.null <- base::is.null
[10:26:24.517]                       muffled <- FALSE
[10:26:24.517]                       if (inherits(cond, "message")) {
[10:26:24.517]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.517]                         if (muffled) 
[10:26:24.517]                           invokeRestart("muffleMessage")
[10:26:24.517]                       }
[10:26:24.517]                       else if (inherits(cond, "warning")) {
[10:26:24.517]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.517]                         if (muffled) 
[10:26:24.517]                           invokeRestart("muffleWarning")
[10:26:24.517]                       }
[10:26:24.517]                       else if (inherits(cond, "condition")) {
[10:26:24.517]                         if (!is.null(pattern)) {
[10:26:24.517]                           computeRestarts <- base::computeRestarts
[10:26:24.517]                           grepl <- base::grepl
[10:26:24.517]                           restarts <- computeRestarts(cond)
[10:26:24.517]                           for (restart in restarts) {
[10:26:24.517]                             name <- restart$name
[10:26:24.517]                             if (is.null(name)) 
[10:26:24.517]                               next
[10:26:24.517]                             if (!grepl(pattern, name)) 
[10:26:24.517]                               next
[10:26:24.517]                             invokeRestart(restart)
[10:26:24.517]                             muffled <- TRUE
[10:26:24.517]                             break
[10:26:24.517]                           }
[10:26:24.517]                         }
[10:26:24.517]                       }
[10:26:24.517]                       invisible(muffled)
[10:26:24.517]                     }
[10:26:24.517]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.517]                   }
[10:26:24.517]                 }
[10:26:24.517]             }
[10:26:24.517]         }))
[10:26:24.517]     }, error = function(ex) {
[10:26:24.517]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.517]                 ...future.rng), started = ...future.startTime, 
[10:26:24.517]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.517]             version = "1.8"), class = "FutureResult")
[10:26:24.517]     }, finally = {
[10:26:24.517]         if (!identical(...future.workdir, getwd())) 
[10:26:24.517]             setwd(...future.workdir)
[10:26:24.517]         {
[10:26:24.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.517]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.517]             }
[10:26:24.517]             base::options(...future.oldOptions)
[10:26:24.517]             if (.Platform$OS.type == "windows") {
[10:26:24.517]                 old_names <- names(...future.oldEnvVars)
[10:26:24.517]                 envs <- base::Sys.getenv()
[10:26:24.517]                 names <- names(envs)
[10:26:24.517]                 common <- intersect(names, old_names)
[10:26:24.517]                 added <- setdiff(names, old_names)
[10:26:24.517]                 removed <- setdiff(old_names, names)
[10:26:24.517]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.517]                   envs[common]]
[10:26:24.517]                 NAMES <- toupper(changed)
[10:26:24.517]                 args <- list()
[10:26:24.517]                 for (kk in seq_along(NAMES)) {
[10:26:24.517]                   name <- changed[[kk]]
[10:26:24.517]                   NAME <- NAMES[[kk]]
[10:26:24.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.517]                     next
[10:26:24.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.517]                 }
[10:26:24.517]                 NAMES <- toupper(added)
[10:26:24.517]                 for (kk in seq_along(NAMES)) {
[10:26:24.517]                   name <- added[[kk]]
[10:26:24.517]                   NAME <- NAMES[[kk]]
[10:26:24.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.517]                     next
[10:26:24.517]                   args[[name]] <- ""
[10:26:24.517]                 }
[10:26:24.517]                 NAMES <- toupper(removed)
[10:26:24.517]                 for (kk in seq_along(NAMES)) {
[10:26:24.517]                   name <- removed[[kk]]
[10:26:24.517]                   NAME <- NAMES[[kk]]
[10:26:24.517]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.517]                     next
[10:26:24.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.517]                 }
[10:26:24.517]                 if (length(args) > 0) 
[10:26:24.517]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.517]             }
[10:26:24.517]             else {
[10:26:24.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.517]             }
[10:26:24.517]             {
[10:26:24.517]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.517]                   0L) {
[10:26:24.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.517]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.517]                   base::options(opts)
[10:26:24.517]                 }
[10:26:24.517]                 {
[10:26:24.517]                   {
[10:26:24.517]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.517]                     NULL
[10:26:24.517]                   }
[10:26:24.517]                   options(future.plan = NULL)
[10:26:24.517]                   if (is.na(NA_character_)) 
[10:26:24.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.517]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.517]                     envir = parent.frame()) 
[10:26:24.517]                   {
[10:26:24.517]                     default_workers <- missing(workers)
[10:26:24.517]                     if (is.function(workers)) 
[10:26:24.517]                       workers <- workers()
[10:26:24.517]                     workers <- structure(as.integer(workers), 
[10:26:24.517]                       class = class(workers))
[10:26:24.517]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.517]                       1L)
[10:26:24.517]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.517]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.517]                       if (default_workers) 
[10:26:24.517]                         supportsMulticore(warn = TRUE)
[10:26:24.517]                       return(sequential(..., envir = envir))
[10:26:24.517]                     }
[10:26:24.517]                     oopts <- options(mc.cores = workers)
[10:26:24.517]                     on.exit(options(oopts))
[10:26:24.517]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.517]                       envir = envir)
[10:26:24.517]                     if (!future$lazy) 
[10:26:24.517]                       future <- run(future)
[10:26:24.517]                     invisible(future)
[10:26:24.517]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.517]                 }
[10:26:24.517]             }
[10:26:24.517]         }
[10:26:24.517]     })
[10:26:24.517]     if (TRUE) {
[10:26:24.517]         base::sink(type = "output", split = FALSE)
[10:26:24.517]         if (TRUE) {
[10:26:24.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.517]         }
[10:26:24.517]         else {
[10:26:24.517]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.517]         }
[10:26:24.517]         base::close(...future.stdout)
[10:26:24.517]         ...future.stdout <- NULL
[10:26:24.517]     }
[10:26:24.517]     ...future.result$conditions <- ...future.conditions
[10:26:24.517]     ...future.result$finished <- base::Sys.time()
[10:26:24.517]     ...future.result
[10:26:24.517] }
[10:26:24.528] requestCore(): workers = 2
[10:26:24.528] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:24.552] result() for MulticoreFuture ...
[10:26:24.553] result() for MulticoreFuture ...
[10:26:24.553] result() for MulticoreFuture ... done
[10:26:24.553] result() for MulticoreFuture ... done
[10:26:24.553] result() for MulticoreFuture ...
[10:26:24.553] result() for MulticoreFuture ... done
[10:26:24.555] MulticoreFuture started
 - Resolving 4 multicore futures
[10:26:24.557] result() for MulticoreFuture ...
[10:26:24.557] result() for MulticoreFuture ... done
[10:26:24.557] plan(): Setting new future strategy stack:
[10:26:24.557] result() for MulticoreFuture ...
[10:26:24.557] result() for MulticoreFuture ... done
[10:26:24.558] result() for MulticoreFuture ...
[10:26:24.558] result() for MulticoreFuture ... done
[10:26:24.557] List of future strategies:
[10:26:24.557] 1. sequential:
[10:26:24.557]    - args: function (..., envir = parent.frame())
[10:26:24.557]    - tweaked: FALSE
[10:26:24.557]    - call: NULL
[10:26:24.558] result() for MulticoreFuture ...
[10:26:24.558] result() for MulticoreFuture ... done
[10:26:24.558] plan(): nbrOfWorkers() = 1
[10:26:24.559] result() for MulticoreFuture ...
[10:26:24.560] result() for MulticoreFuture ...
[10:26:24.560] result() for MulticoreFuture ... done
[10:26:24.561] result() for MulticoreFuture ... done
[10:26:24.561] result() for MulticoreFuture ...
[10:26:24.561] result() for MulticoreFuture ... done
[10:26:24.561] plan(): Setting new future strategy stack:
[10:26:24.561] result() for MulticoreFuture ...
[10:26:24.561] List of future strategies:
[10:26:24.561] 1. multicore:
[10:26:24.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.561]    - tweaked: FALSE
[10:26:24.561]    - call: plan(multicore)
[10:26:24.566] plan(): nbrOfWorkers() = 2
[10:26:24.567] result() for MulticoreFuture ...
[10:26:24.567] result() for MulticoreFuture ... done
[10:26:24.567] result() for MulticoreFuture ... done
[10:26:24.568] result() for MulticoreFuture ...
[10:26:24.568] result() for MulticoreFuture ... done
*** multicore(..., globals = FALSE) and errors
[10:26:24.572] getGlobalsAndPackages() ...
[10:26:24.572] Not searching for globals
[10:26:24.573] - globals: [0] <none>
[10:26:24.573] getGlobalsAndPackages() ... DONE
[10:26:24.573] Packages needed by the future expression (n = 0): <none>
[10:26:24.573] Packages needed by future strategies (n = 0): <none>
[10:26:24.574] {
[10:26:24.574]     {
[10:26:24.574]         {
[10:26:24.574]             ...future.startTime <- base::Sys.time()
[10:26:24.574]             {
[10:26:24.574]                 {
[10:26:24.574]                   {
[10:26:24.574]                     {
[10:26:24.574]                       base::local({
[10:26:24.574]                         has_future <- base::requireNamespace("future", 
[10:26:24.574]                           quietly = TRUE)
[10:26:24.574]                         if (has_future) {
[10:26:24.574]                           ns <- base::getNamespace("future")
[10:26:24.574]                           version <- ns[[".package"]][["version"]]
[10:26:24.574]                           if (is.null(version)) 
[10:26:24.574]                             version <- utils::packageVersion("future")
[10:26:24.574]                         }
[10:26:24.574]                         else {
[10:26:24.574]                           version <- NULL
[10:26:24.574]                         }
[10:26:24.574]                         if (!has_future || version < "1.8.0") {
[10:26:24.574]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.574]                             "", base::R.version$version.string), 
[10:26:24.574]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.574]                               "release", "version")], collapse = " "), 
[10:26:24.574]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.574]                             info)
[10:26:24.574]                           info <- base::paste(info, collapse = "; ")
[10:26:24.574]                           if (!has_future) {
[10:26:24.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.574]                               info)
[10:26:24.574]                           }
[10:26:24.574]                           else {
[10:26:24.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.574]                               info, version)
[10:26:24.574]                           }
[10:26:24.574]                           base::stop(msg)
[10:26:24.574]                         }
[10:26:24.574]                       })
[10:26:24.574]                     }
[10:26:24.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.574]                     base::options(mc.cores = 1L)
[10:26:24.574]                   }
[10:26:24.574]                   options(future.plan = NULL)
[10:26:24.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.574]                 }
[10:26:24.574]                 ...future.workdir <- getwd()
[10:26:24.574]             }
[10:26:24.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.574]         }
[10:26:24.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.574]             base::names(...future.oldOptions))
[10:26:24.574]     }
[10:26:24.574]     if (FALSE) {
[10:26:24.574]     }
[10:26:24.574]     else {
[10:26:24.574]         if (TRUE) {
[10:26:24.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.574]                 open = "w")
[10:26:24.574]         }
[10:26:24.574]         else {
[10:26:24.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.574]         }
[10:26:24.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.574]             base::sink(type = "output", split = FALSE)
[10:26:24.574]             base::close(...future.stdout)
[10:26:24.574]         }, add = TRUE)
[10:26:24.574]     }
[10:26:24.574]     ...future.frame <- base::sys.nframe()
[10:26:24.574]     ...future.conditions <- base::list()
[10:26:24.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.574]     if (FALSE) {
[10:26:24.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.574]     }
[10:26:24.574]     ...future.result <- base::tryCatch({
[10:26:24.574]         base::withCallingHandlers({
[10:26:24.574]             ...future.value <- base::withVisible(base::local({
[10:26:24.574]                 withCallingHandlers({
[10:26:24.574]                   {
[10:26:24.574]                     stop("Whoops!")
[10:26:24.574]                     1
[10:26:24.574]                   }
[10:26:24.574]                 }, immediateCondition = function(cond) {
[10:26:24.574]                   save_rds <- function (object, pathname, ...) 
[10:26:24.574]                   {
[10:26:24.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.574]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.574]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.574]                         fi_tmp[["mtime"]])
[10:26:24.574]                     }
[10:26:24.574]                     tryCatch({
[10:26:24.574]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.574]                     }, error = function(ex) {
[10:26:24.574]                       msg <- conditionMessage(ex)
[10:26:24.574]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.574]                         fi_tmp[["mtime"]], msg)
[10:26:24.574]                       ex$message <- msg
[10:26:24.574]                       stop(ex)
[10:26:24.574]                     })
[10:26:24.574]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.574]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.574]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.574]                       fi <- file.info(pathname)
[10:26:24.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.574]                         fi[["size"]], fi[["mtime"]])
[10:26:24.574]                       stop(msg)
[10:26:24.574]                     }
[10:26:24.574]                     invisible(pathname)
[10:26:24.574]                   }
[10:26:24.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.574]                     rootPath = tempdir()) 
[10:26:24.574]                   {
[10:26:24.574]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.574]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.574]                       tmpdir = path, fileext = ".rds")
[10:26:24.574]                     save_rds(obj, file)
[10:26:24.574]                   }
[10:26:24.574]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.574]                   {
[10:26:24.574]                     inherits <- base::inherits
[10:26:24.574]                     invokeRestart <- base::invokeRestart
[10:26:24.574]                     is.null <- base::is.null
[10:26:24.574]                     muffled <- FALSE
[10:26:24.574]                     if (inherits(cond, "message")) {
[10:26:24.574]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.574]                       if (muffled) 
[10:26:24.574]                         invokeRestart("muffleMessage")
[10:26:24.574]                     }
[10:26:24.574]                     else if (inherits(cond, "warning")) {
[10:26:24.574]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.574]                       if (muffled) 
[10:26:24.574]                         invokeRestart("muffleWarning")
[10:26:24.574]                     }
[10:26:24.574]                     else if (inherits(cond, "condition")) {
[10:26:24.574]                       if (!is.null(pattern)) {
[10:26:24.574]                         computeRestarts <- base::computeRestarts
[10:26:24.574]                         grepl <- base::grepl
[10:26:24.574]                         restarts <- computeRestarts(cond)
[10:26:24.574]                         for (restart in restarts) {
[10:26:24.574]                           name <- restart$name
[10:26:24.574]                           if (is.null(name)) 
[10:26:24.574]                             next
[10:26:24.574]                           if (!grepl(pattern, name)) 
[10:26:24.574]                             next
[10:26:24.574]                           invokeRestart(restart)
[10:26:24.574]                           muffled <- TRUE
[10:26:24.574]                           break
[10:26:24.574]                         }
[10:26:24.574]                       }
[10:26:24.574]                     }
[10:26:24.574]                     invisible(muffled)
[10:26:24.574]                   }
[10:26:24.574]                   muffleCondition(cond)
[10:26:24.574]                 })
[10:26:24.574]             }))
[10:26:24.574]             future::FutureResult(value = ...future.value$value, 
[10:26:24.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.574]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.574]                     ...future.globalenv.names))
[10:26:24.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.574]         }, condition = base::local({
[10:26:24.574]             c <- base::c
[10:26:24.574]             inherits <- base::inherits
[10:26:24.574]             invokeRestart <- base::invokeRestart
[10:26:24.574]             length <- base::length
[10:26:24.574]             list <- base::list
[10:26:24.574]             seq.int <- base::seq.int
[10:26:24.574]             signalCondition <- base::signalCondition
[10:26:24.574]             sys.calls <- base::sys.calls
[10:26:24.574]             `[[` <- base::`[[`
[10:26:24.574]             `+` <- base::`+`
[10:26:24.574]             `<<-` <- base::`<<-`
[10:26:24.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.574]                   3L)]
[10:26:24.574]             }
[10:26:24.574]             function(cond) {
[10:26:24.574]                 is_error <- inherits(cond, "error")
[10:26:24.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.574]                   NULL)
[10:26:24.574]                 if (is_error) {
[10:26:24.574]                   sessionInformation <- function() {
[10:26:24.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.574]                       search = base::search(), system = base::Sys.info())
[10:26:24.574]                   }
[10:26:24.574]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.574]                     cond$call), session = sessionInformation(), 
[10:26:24.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.574]                   signalCondition(cond)
[10:26:24.574]                 }
[10:26:24.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.574]                 "immediateCondition"))) {
[10:26:24.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.574]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.574]                   if (TRUE && !signal) {
[10:26:24.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.574]                     {
[10:26:24.574]                       inherits <- base::inherits
[10:26:24.574]                       invokeRestart <- base::invokeRestart
[10:26:24.574]                       is.null <- base::is.null
[10:26:24.574]                       muffled <- FALSE
[10:26:24.574]                       if (inherits(cond, "message")) {
[10:26:24.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.574]                         if (muffled) 
[10:26:24.574]                           invokeRestart("muffleMessage")
[10:26:24.574]                       }
[10:26:24.574]                       else if (inherits(cond, "warning")) {
[10:26:24.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.574]                         if (muffled) 
[10:26:24.574]                           invokeRestart("muffleWarning")
[10:26:24.574]                       }
[10:26:24.574]                       else if (inherits(cond, "condition")) {
[10:26:24.574]                         if (!is.null(pattern)) {
[10:26:24.574]                           computeRestarts <- base::computeRestarts
[10:26:24.574]                           grepl <- base::grepl
[10:26:24.574]                           restarts <- computeRestarts(cond)
[10:26:24.574]                           for (restart in restarts) {
[10:26:24.574]                             name <- restart$name
[10:26:24.574]                             if (is.null(name)) 
[10:26:24.574]                               next
[10:26:24.574]                             if (!grepl(pattern, name)) 
[10:26:24.574]                               next
[10:26:24.574]                             invokeRestart(restart)
[10:26:24.574]                             muffled <- TRUE
[10:26:24.574]                             break
[10:26:24.574]                           }
[10:26:24.574]                         }
[10:26:24.574]                       }
[10:26:24.574]                       invisible(muffled)
[10:26:24.574]                     }
[10:26:24.574]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.574]                   }
[10:26:24.574]                 }
[10:26:24.574]                 else {
[10:26:24.574]                   if (TRUE) {
[10:26:24.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.574]                     {
[10:26:24.574]                       inherits <- base::inherits
[10:26:24.574]                       invokeRestart <- base::invokeRestart
[10:26:24.574]                       is.null <- base::is.null
[10:26:24.574]                       muffled <- FALSE
[10:26:24.574]                       if (inherits(cond, "message")) {
[10:26:24.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.574]                         if (muffled) 
[10:26:24.574]                           invokeRestart("muffleMessage")
[10:26:24.574]                       }
[10:26:24.574]                       else if (inherits(cond, "warning")) {
[10:26:24.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.574]                         if (muffled) 
[10:26:24.574]                           invokeRestart("muffleWarning")
[10:26:24.574]                       }
[10:26:24.574]                       else if (inherits(cond, "condition")) {
[10:26:24.574]                         if (!is.null(pattern)) {
[10:26:24.574]                           computeRestarts <- base::computeRestarts
[10:26:24.574]                           grepl <- base::grepl
[10:26:24.574]                           restarts <- computeRestarts(cond)
[10:26:24.574]                           for (restart in restarts) {
[10:26:24.574]                             name <- restart$name
[10:26:24.574]                             if (is.null(name)) 
[10:26:24.574]                               next
[10:26:24.574]                             if (!grepl(pattern, name)) 
[10:26:24.574]                               next
[10:26:24.574]                             invokeRestart(restart)
[10:26:24.574]                             muffled <- TRUE
[10:26:24.574]                             break
[10:26:24.574]                           }
[10:26:24.574]                         }
[10:26:24.574]                       }
[10:26:24.574]                       invisible(muffled)
[10:26:24.574]                     }
[10:26:24.574]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.574]                   }
[10:26:24.574]                 }
[10:26:24.574]             }
[10:26:24.574]         }))
[10:26:24.574]     }, error = function(ex) {
[10:26:24.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.574]                 ...future.rng), started = ...future.startTime, 
[10:26:24.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.574]             version = "1.8"), class = "FutureResult")
[10:26:24.574]     }, finally = {
[10:26:24.574]         if (!identical(...future.workdir, getwd())) 
[10:26:24.574]             setwd(...future.workdir)
[10:26:24.574]         {
[10:26:24.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.574]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.574]             }
[10:26:24.574]             base::options(...future.oldOptions)
[10:26:24.574]             if (.Platform$OS.type == "windows") {
[10:26:24.574]                 old_names <- names(...future.oldEnvVars)
[10:26:24.574]                 envs <- base::Sys.getenv()
[10:26:24.574]                 names <- names(envs)
[10:26:24.574]                 common <- intersect(names, old_names)
[10:26:24.574]                 added <- setdiff(names, old_names)
[10:26:24.574]                 removed <- setdiff(old_names, names)
[10:26:24.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.574]                   envs[common]]
[10:26:24.574]                 NAMES <- toupper(changed)
[10:26:24.574]                 args <- list()
[10:26:24.574]                 for (kk in seq_along(NAMES)) {
[10:26:24.574]                   name <- changed[[kk]]
[10:26:24.574]                   NAME <- NAMES[[kk]]
[10:26:24.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.574]                     next
[10:26:24.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.574]                 }
[10:26:24.574]                 NAMES <- toupper(added)
[10:26:24.574]                 for (kk in seq_along(NAMES)) {
[10:26:24.574]                   name <- added[[kk]]
[10:26:24.574]                   NAME <- NAMES[[kk]]
[10:26:24.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.574]                     next
[10:26:24.574]                   args[[name]] <- ""
[10:26:24.574]                 }
[10:26:24.574]                 NAMES <- toupper(removed)
[10:26:24.574]                 for (kk in seq_along(NAMES)) {
[10:26:24.574]                   name <- removed[[kk]]
[10:26:24.574]                   NAME <- NAMES[[kk]]
[10:26:24.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.574]                     next
[10:26:24.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.574]                 }
[10:26:24.574]                 if (length(args) > 0) 
[10:26:24.574]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.574]             }
[10:26:24.574]             else {
[10:26:24.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.574]             }
[10:26:24.574]             {
[10:26:24.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.574]                   0L) {
[10:26:24.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.574]                   base::options(opts)
[10:26:24.574]                 }
[10:26:24.574]                 {
[10:26:24.574]                   {
[10:26:24.574]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.574]                     NULL
[10:26:24.574]                   }
[10:26:24.574]                   options(future.plan = NULL)
[10:26:24.574]                   if (is.na(NA_character_)) 
[10:26:24.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.574]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.574]                     envir = parent.frame()) 
[10:26:24.574]                   {
[10:26:24.574]                     default_workers <- missing(workers)
[10:26:24.574]                     if (is.function(workers)) 
[10:26:24.574]                       workers <- workers()
[10:26:24.574]                     workers <- structure(as.integer(workers), 
[10:26:24.574]                       class = class(workers))
[10:26:24.574]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.574]                       1L)
[10:26:24.574]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.574]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.574]                       if (default_workers) 
[10:26:24.574]                         supportsMulticore(warn = TRUE)
[10:26:24.574]                       return(sequential(..., envir = envir))
[10:26:24.574]                     }
[10:26:24.574]                     oopts <- options(mc.cores = workers)
[10:26:24.574]                     on.exit(options(oopts))
[10:26:24.574]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.574]                       envir = envir)
[10:26:24.574]                     if (!future$lazy) 
[10:26:24.574]                       future <- run(future)
[10:26:24.574]                     invisible(future)
[10:26:24.574]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.574]                 }
[10:26:24.574]             }
[10:26:24.574]         }
[10:26:24.574]     })
[10:26:24.574]     if (TRUE) {
[10:26:24.574]         base::sink(type = "output", split = FALSE)
[10:26:24.574]         if (TRUE) {
[10:26:24.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.574]         }
[10:26:24.574]         else {
[10:26:24.574]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.574]         }
[10:26:24.574]         base::close(...future.stdout)
[10:26:24.574]         ...future.stdout <- NULL
[10:26:24.574]     }
[10:26:24.574]     ...future.result$conditions <- ...future.conditions
[10:26:24.574]     ...future.result$finished <- base::Sys.time()
[10:26:24.574]     ...future.result
[10:26:24.574] }
[10:26:24.577] requestCore(): workers = 2
[10:26:24.579] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.580] plan(): Setting new future strategy stack:
[10:26:24.580] List of future strategies:
[10:26:24.580] 1. sequential:
[10:26:24.580]    - args: function (..., envir = parent.frame())
[10:26:24.580]    - tweaked: FALSE
[10:26:24.580]    - call: NULL
[10:26:24.581] plan(): nbrOfWorkers() = 1
[10:26:24.583] plan(): Setting new future strategy stack:
[10:26:24.583] List of future strategies:
[10:26:24.583] 1. multicore:
[10:26:24.583]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.583]    - tweaked: FALSE
[10:26:24.583]    - call: plan(multicore)
[10:26:24.588] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.590] result() for MulticoreFuture ...
[10:26:24.593] result() for MulticoreFuture ...
[10:26:24.593] result() for MulticoreFuture ... done
[10:26:24.593] signalConditions() ...
[10:26:24.593]  - include = ‘immediateCondition’
[10:26:24.594]  - exclude = 
[10:26:24.594]  - resignal = FALSE
[10:26:24.594]  - Number of conditions: 1
[10:26:24.594] signalConditions() ... done
[10:26:24.594] result() for MulticoreFuture ... done
[10:26:24.594] result() for MulticoreFuture ...
[10:26:24.594] result() for MulticoreFuture ... done
[10:26:24.594] signalConditions() ...
[10:26:24.594]  - include = ‘immediateCondition’
[10:26:24.595]  - exclude = 
[10:26:24.595]  - resignal = FALSE
[10:26:24.595]  - Number of conditions: 1
[10:26:24.595] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.596] result() for MulticoreFuture ...
[10:26:24.596] result() for MulticoreFuture ... done
[10:26:24.596] result() for MulticoreFuture ...
[10:26:24.596] result() for MulticoreFuture ... done
[10:26:24.596] signalConditions() ...
[10:26:24.596]  - include = ‘immediateCondition’
[10:26:24.596]  - exclude = 
[10:26:24.597]  - resignal = FALSE
[10:26:24.597]  - Number of conditions: 1
[10:26:24.597] signalConditions() ... done
[10:26:24.597] Future state: ‘finished’
[10:26:24.597] result() for MulticoreFuture ...
[10:26:24.597] result() for MulticoreFuture ... done
[10:26:24.597] signalConditions() ...
[10:26:24.597]  - include = ‘condition’
[10:26:24.597]  - exclude = ‘immediateCondition’
[10:26:24.598]  - resignal = TRUE
[10:26:24.600]  - Number of conditions: 1
[10:26:24.601]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.601] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.602] result() for MulticoreFuture ...
[10:26:24.602] result() for MulticoreFuture ... done
[10:26:24.602] result() for MulticoreFuture ...
[10:26:24.602] result() for MulticoreFuture ... done
[10:26:24.602] signalConditions() ...
[10:26:24.603]  - include = ‘immediateCondition’
[10:26:24.603]  - exclude = 
[10:26:24.603]  - resignal = FALSE
[10:26:24.603]  - Number of conditions: 1
[10:26:24.603] signalConditions() ... done
[10:26:24.603] Future state: ‘finished’
[10:26:24.603] result() for MulticoreFuture ...
[10:26:24.604] result() for MulticoreFuture ... done
[10:26:24.604] signalConditions() ...
[10:26:24.604]  - include = ‘condition’
[10:26:24.604]  - exclude = ‘immediateCondition’
[10:26:24.604]  - resignal = TRUE
[10:26:24.604]  - Number of conditions: 1
[10:26:24.604]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.604] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.609] getGlobalsAndPackages() ...
[10:26:24.609] 
[10:26:24.610] - globals: [0] <none>
[10:26:24.610] getGlobalsAndPackages() ... DONE
[10:26:24.610] Packages needed by the future expression (n = 0): <none>
[10:26:24.610] Packages needed by future strategies (n = 0): <none>
[10:26:24.611] {
[10:26:24.611]     {
[10:26:24.611]         {
[10:26:24.611]             ...future.startTime <- base::Sys.time()
[10:26:24.611]             {
[10:26:24.611]                 {
[10:26:24.611]                   {
[10:26:24.611]                     {
[10:26:24.611]                       base::local({
[10:26:24.611]                         has_future <- base::requireNamespace("future", 
[10:26:24.611]                           quietly = TRUE)
[10:26:24.611]                         if (has_future) {
[10:26:24.611]                           ns <- base::getNamespace("future")
[10:26:24.611]                           version <- ns[[".package"]][["version"]]
[10:26:24.611]                           if (is.null(version)) 
[10:26:24.611]                             version <- utils::packageVersion("future")
[10:26:24.611]                         }
[10:26:24.611]                         else {
[10:26:24.611]                           version <- NULL
[10:26:24.611]                         }
[10:26:24.611]                         if (!has_future || version < "1.8.0") {
[10:26:24.611]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.611]                             "", base::R.version$version.string), 
[10:26:24.611]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.611]                               "release", "version")], collapse = " "), 
[10:26:24.611]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.611]                             info)
[10:26:24.611]                           info <- base::paste(info, collapse = "; ")
[10:26:24.611]                           if (!has_future) {
[10:26:24.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.611]                               info)
[10:26:24.611]                           }
[10:26:24.611]                           else {
[10:26:24.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.611]                               info, version)
[10:26:24.611]                           }
[10:26:24.611]                           base::stop(msg)
[10:26:24.611]                         }
[10:26:24.611]                       })
[10:26:24.611]                     }
[10:26:24.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.611]                     base::options(mc.cores = 1L)
[10:26:24.611]                   }
[10:26:24.611]                   options(future.plan = NULL)
[10:26:24.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.611]                 }
[10:26:24.611]                 ...future.workdir <- getwd()
[10:26:24.611]             }
[10:26:24.611]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.611]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.611]         }
[10:26:24.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.611]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.611]             base::names(...future.oldOptions))
[10:26:24.611]     }
[10:26:24.611]     if (FALSE) {
[10:26:24.611]     }
[10:26:24.611]     else {
[10:26:24.611]         if (TRUE) {
[10:26:24.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.611]                 open = "w")
[10:26:24.611]         }
[10:26:24.611]         else {
[10:26:24.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.611]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.611]         }
[10:26:24.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.611]             base::sink(type = "output", split = FALSE)
[10:26:24.611]             base::close(...future.stdout)
[10:26:24.611]         }, add = TRUE)
[10:26:24.611]     }
[10:26:24.611]     ...future.frame <- base::sys.nframe()
[10:26:24.611]     ...future.conditions <- base::list()
[10:26:24.611]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.611]     if (FALSE) {
[10:26:24.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.611]     }
[10:26:24.611]     ...future.result <- base::tryCatch({
[10:26:24.611]         base::withCallingHandlers({
[10:26:24.611]             ...future.value <- base::withVisible(base::local({
[10:26:24.611]                 withCallingHandlers({
[10:26:24.611]                   {
[10:26:24.611]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:24.611]                       "error", "condition")))
[10:26:24.611]                   }
[10:26:24.611]                 }, immediateCondition = function(cond) {
[10:26:24.611]                   save_rds <- function (object, pathname, ...) 
[10:26:24.611]                   {
[10:26:24.611]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.611]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.611]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.611]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.611]                         fi_tmp[["mtime"]])
[10:26:24.611]                     }
[10:26:24.611]                     tryCatch({
[10:26:24.611]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.611]                     }, error = function(ex) {
[10:26:24.611]                       msg <- conditionMessage(ex)
[10:26:24.611]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.611]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.611]                         fi_tmp[["mtime"]], msg)
[10:26:24.611]                       ex$message <- msg
[10:26:24.611]                       stop(ex)
[10:26:24.611]                     })
[10:26:24.611]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.611]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.611]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.611]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.611]                       fi <- file.info(pathname)
[10:26:24.611]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.611]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.611]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.611]                         fi[["size"]], fi[["mtime"]])
[10:26:24.611]                       stop(msg)
[10:26:24.611]                     }
[10:26:24.611]                     invisible(pathname)
[10:26:24.611]                   }
[10:26:24.611]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.611]                     rootPath = tempdir()) 
[10:26:24.611]                   {
[10:26:24.611]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.611]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.611]                       tmpdir = path, fileext = ".rds")
[10:26:24.611]                     save_rds(obj, file)
[10:26:24.611]                   }
[10:26:24.611]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.611]                   {
[10:26:24.611]                     inherits <- base::inherits
[10:26:24.611]                     invokeRestart <- base::invokeRestart
[10:26:24.611]                     is.null <- base::is.null
[10:26:24.611]                     muffled <- FALSE
[10:26:24.611]                     if (inherits(cond, "message")) {
[10:26:24.611]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.611]                       if (muffled) 
[10:26:24.611]                         invokeRestart("muffleMessage")
[10:26:24.611]                     }
[10:26:24.611]                     else if (inherits(cond, "warning")) {
[10:26:24.611]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.611]                       if (muffled) 
[10:26:24.611]                         invokeRestart("muffleWarning")
[10:26:24.611]                     }
[10:26:24.611]                     else if (inherits(cond, "condition")) {
[10:26:24.611]                       if (!is.null(pattern)) {
[10:26:24.611]                         computeRestarts <- base::computeRestarts
[10:26:24.611]                         grepl <- base::grepl
[10:26:24.611]                         restarts <- computeRestarts(cond)
[10:26:24.611]                         for (restart in restarts) {
[10:26:24.611]                           name <- restart$name
[10:26:24.611]                           if (is.null(name)) 
[10:26:24.611]                             next
[10:26:24.611]                           if (!grepl(pattern, name)) 
[10:26:24.611]                             next
[10:26:24.611]                           invokeRestart(restart)
[10:26:24.611]                           muffled <- TRUE
[10:26:24.611]                           break
[10:26:24.611]                         }
[10:26:24.611]                       }
[10:26:24.611]                     }
[10:26:24.611]                     invisible(muffled)
[10:26:24.611]                   }
[10:26:24.611]                   muffleCondition(cond)
[10:26:24.611]                 })
[10:26:24.611]             }))
[10:26:24.611]             future::FutureResult(value = ...future.value$value, 
[10:26:24.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.611]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.611]                     ...future.globalenv.names))
[10:26:24.611]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.611]         }, condition = base::local({
[10:26:24.611]             c <- base::c
[10:26:24.611]             inherits <- base::inherits
[10:26:24.611]             invokeRestart <- base::invokeRestart
[10:26:24.611]             length <- base::length
[10:26:24.611]             list <- base::list
[10:26:24.611]             seq.int <- base::seq.int
[10:26:24.611]             signalCondition <- base::signalCondition
[10:26:24.611]             sys.calls <- base::sys.calls
[10:26:24.611]             `[[` <- base::`[[`
[10:26:24.611]             `+` <- base::`+`
[10:26:24.611]             `<<-` <- base::`<<-`
[10:26:24.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.611]                   3L)]
[10:26:24.611]             }
[10:26:24.611]             function(cond) {
[10:26:24.611]                 is_error <- inherits(cond, "error")
[10:26:24.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.611]                   NULL)
[10:26:24.611]                 if (is_error) {
[10:26:24.611]                   sessionInformation <- function() {
[10:26:24.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.611]                       search = base::search(), system = base::Sys.info())
[10:26:24.611]                   }
[10:26:24.611]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.611]                     cond$call), session = sessionInformation(), 
[10:26:24.611]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.611]                   signalCondition(cond)
[10:26:24.611]                 }
[10:26:24.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.611]                 "immediateCondition"))) {
[10:26:24.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.611]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.611]                   if (TRUE && !signal) {
[10:26:24.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.611]                     {
[10:26:24.611]                       inherits <- base::inherits
[10:26:24.611]                       invokeRestart <- base::invokeRestart
[10:26:24.611]                       is.null <- base::is.null
[10:26:24.611]                       muffled <- FALSE
[10:26:24.611]                       if (inherits(cond, "message")) {
[10:26:24.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.611]                         if (muffled) 
[10:26:24.611]                           invokeRestart("muffleMessage")
[10:26:24.611]                       }
[10:26:24.611]                       else if (inherits(cond, "warning")) {
[10:26:24.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.611]                         if (muffled) 
[10:26:24.611]                           invokeRestart("muffleWarning")
[10:26:24.611]                       }
[10:26:24.611]                       else if (inherits(cond, "condition")) {
[10:26:24.611]                         if (!is.null(pattern)) {
[10:26:24.611]                           computeRestarts <- base::computeRestarts
[10:26:24.611]                           grepl <- base::grepl
[10:26:24.611]                           restarts <- computeRestarts(cond)
[10:26:24.611]                           for (restart in restarts) {
[10:26:24.611]                             name <- restart$name
[10:26:24.611]                             if (is.null(name)) 
[10:26:24.611]                               next
[10:26:24.611]                             if (!grepl(pattern, name)) 
[10:26:24.611]                               next
[10:26:24.611]                             invokeRestart(restart)
[10:26:24.611]                             muffled <- TRUE
[10:26:24.611]                             break
[10:26:24.611]                           }
[10:26:24.611]                         }
[10:26:24.611]                       }
[10:26:24.611]                       invisible(muffled)
[10:26:24.611]                     }
[10:26:24.611]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.611]                   }
[10:26:24.611]                 }
[10:26:24.611]                 else {
[10:26:24.611]                   if (TRUE) {
[10:26:24.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.611]                     {
[10:26:24.611]                       inherits <- base::inherits
[10:26:24.611]                       invokeRestart <- base::invokeRestart
[10:26:24.611]                       is.null <- base::is.null
[10:26:24.611]                       muffled <- FALSE
[10:26:24.611]                       if (inherits(cond, "message")) {
[10:26:24.611]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.611]                         if (muffled) 
[10:26:24.611]                           invokeRestart("muffleMessage")
[10:26:24.611]                       }
[10:26:24.611]                       else if (inherits(cond, "warning")) {
[10:26:24.611]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.611]                         if (muffled) 
[10:26:24.611]                           invokeRestart("muffleWarning")
[10:26:24.611]                       }
[10:26:24.611]                       else if (inherits(cond, "condition")) {
[10:26:24.611]                         if (!is.null(pattern)) {
[10:26:24.611]                           computeRestarts <- base::computeRestarts
[10:26:24.611]                           grepl <- base::grepl
[10:26:24.611]                           restarts <- computeRestarts(cond)
[10:26:24.611]                           for (restart in restarts) {
[10:26:24.611]                             name <- restart$name
[10:26:24.611]                             if (is.null(name)) 
[10:26:24.611]                               next
[10:26:24.611]                             if (!grepl(pattern, name)) 
[10:26:24.611]                               next
[10:26:24.611]                             invokeRestart(restart)
[10:26:24.611]                             muffled <- TRUE
[10:26:24.611]                             break
[10:26:24.611]                           }
[10:26:24.611]                         }
[10:26:24.611]                       }
[10:26:24.611]                       invisible(muffled)
[10:26:24.611]                     }
[10:26:24.611]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.611]                   }
[10:26:24.611]                 }
[10:26:24.611]             }
[10:26:24.611]         }))
[10:26:24.611]     }, error = function(ex) {
[10:26:24.611]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.611]                 ...future.rng), started = ...future.startTime, 
[10:26:24.611]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.611]             version = "1.8"), class = "FutureResult")
[10:26:24.611]     }, finally = {
[10:26:24.611]         if (!identical(...future.workdir, getwd())) 
[10:26:24.611]             setwd(...future.workdir)
[10:26:24.611]         {
[10:26:24.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.611]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.611]             }
[10:26:24.611]             base::options(...future.oldOptions)
[10:26:24.611]             if (.Platform$OS.type == "windows") {
[10:26:24.611]                 old_names <- names(...future.oldEnvVars)
[10:26:24.611]                 envs <- base::Sys.getenv()
[10:26:24.611]                 names <- names(envs)
[10:26:24.611]                 common <- intersect(names, old_names)
[10:26:24.611]                 added <- setdiff(names, old_names)
[10:26:24.611]                 removed <- setdiff(old_names, names)
[10:26:24.611]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.611]                   envs[common]]
[10:26:24.611]                 NAMES <- toupper(changed)
[10:26:24.611]                 args <- list()
[10:26:24.611]                 for (kk in seq_along(NAMES)) {
[10:26:24.611]                   name <- changed[[kk]]
[10:26:24.611]                   NAME <- NAMES[[kk]]
[10:26:24.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.611]                     next
[10:26:24.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.611]                 }
[10:26:24.611]                 NAMES <- toupper(added)
[10:26:24.611]                 for (kk in seq_along(NAMES)) {
[10:26:24.611]                   name <- added[[kk]]
[10:26:24.611]                   NAME <- NAMES[[kk]]
[10:26:24.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.611]                     next
[10:26:24.611]                   args[[name]] <- ""
[10:26:24.611]                 }
[10:26:24.611]                 NAMES <- toupper(removed)
[10:26:24.611]                 for (kk in seq_along(NAMES)) {
[10:26:24.611]                   name <- removed[[kk]]
[10:26:24.611]                   NAME <- NAMES[[kk]]
[10:26:24.611]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.611]                     next
[10:26:24.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.611]                 }
[10:26:24.611]                 if (length(args) > 0) 
[10:26:24.611]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.611]             }
[10:26:24.611]             else {
[10:26:24.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.611]             }
[10:26:24.611]             {
[10:26:24.611]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.611]                   0L) {
[10:26:24.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.611]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.611]                   base::options(opts)
[10:26:24.611]                 }
[10:26:24.611]                 {
[10:26:24.611]                   {
[10:26:24.611]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.611]                     NULL
[10:26:24.611]                   }
[10:26:24.611]                   options(future.plan = NULL)
[10:26:24.611]                   if (is.na(NA_character_)) 
[10:26:24.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.611]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.611]                     envir = parent.frame()) 
[10:26:24.611]                   {
[10:26:24.611]                     default_workers <- missing(workers)
[10:26:24.611]                     if (is.function(workers)) 
[10:26:24.611]                       workers <- workers()
[10:26:24.611]                     workers <- structure(as.integer(workers), 
[10:26:24.611]                       class = class(workers))
[10:26:24.611]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.611]                       1L)
[10:26:24.611]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.611]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.611]                       if (default_workers) 
[10:26:24.611]                         supportsMulticore(warn = TRUE)
[10:26:24.611]                       return(sequential(..., envir = envir))
[10:26:24.611]                     }
[10:26:24.611]                     oopts <- options(mc.cores = workers)
[10:26:24.611]                     on.exit(options(oopts))
[10:26:24.611]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.611]                       envir = envir)
[10:26:24.611]                     if (!future$lazy) 
[10:26:24.611]                       future <- run(future)
[10:26:24.611]                     invisible(future)
[10:26:24.611]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.611]                 }
[10:26:24.611]             }
[10:26:24.611]         }
[10:26:24.611]     })
[10:26:24.611]     if (TRUE) {
[10:26:24.611]         base::sink(type = "output", split = FALSE)
[10:26:24.611]         if (TRUE) {
[10:26:24.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.611]         }
[10:26:24.611]         else {
[10:26:24.611]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.611]         }
[10:26:24.611]         base::close(...future.stdout)
[10:26:24.611]         ...future.stdout <- NULL
[10:26:24.611]     }
[10:26:24.611]     ...future.result$conditions <- ...future.conditions
[10:26:24.611]     ...future.result$finished <- base::Sys.time()
[10:26:24.611]     ...future.result
[10:26:24.611] }
[10:26:24.614] requestCore(): workers = 2
[10:26:24.615] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.616] plan(): Setting new future strategy stack:
[10:26:24.617] List of future strategies:
[10:26:24.617] 1. sequential:
[10:26:24.617]    - args: function (..., envir = parent.frame())
[10:26:24.617]    - tweaked: FALSE
[10:26:24.617]    - call: NULL
[10:26:24.618] plan(): nbrOfWorkers() = 1
[10:26:24.620] plan(): Setting new future strategy stack:
[10:26:24.620] List of future strategies:
[10:26:24.620] 1. multicore:
[10:26:24.620]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.620]    - tweaked: FALSE
[10:26:24.620]    - call: plan(multicore)
[10:26:24.625] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.627] result() for MulticoreFuture ...
[10:26:24.630] result() for MulticoreFuture ...
[10:26:24.630] result() for MulticoreFuture ... done
[10:26:24.630] signalConditions() ...
[10:26:24.630]  - include = ‘immediateCondition’
[10:26:24.630]  - exclude = 
[10:26:24.631]  - resignal = FALSE
[10:26:24.631]  - Number of conditions: 1
[10:26:24.631] signalConditions() ... done
[10:26:24.631] result() for MulticoreFuture ... done
[10:26:24.631] result() for MulticoreFuture ...
[10:26:24.631] result() for MulticoreFuture ... done
[10:26:24.631] signalConditions() ...
[10:26:24.632]  - include = ‘immediateCondition’
[10:26:24.632]  - exclude = 
[10:26:24.632]  - resignal = FALSE
[10:26:24.632]  - Number of conditions: 1
[10:26:24.632] signalConditions() ... done
<MyError: boom>
[10:26:24.632] result() for MulticoreFuture ...
[10:26:24.633] result() for MulticoreFuture ... done
[10:26:24.633] result() for MulticoreFuture ...
[10:26:24.633] result() for MulticoreFuture ... done
[10:26:24.633] signalConditions() ...
[10:26:24.633]  - include = ‘immediateCondition’
[10:26:24.633]  - exclude = 
[10:26:24.633]  - resignal = FALSE
[10:26:24.633]  - Number of conditions: 1
[10:26:24.633] signalConditions() ... done
[10:26:24.634] Future state: ‘finished’
[10:26:24.634] result() for MulticoreFuture ...
[10:26:24.634] result() for MulticoreFuture ... done
[10:26:24.634] signalConditions() ...
[10:26:24.634]  - include = ‘condition’
[10:26:24.634]  - exclude = ‘immediateCondition’
[10:26:24.634]  - resignal = TRUE
[10:26:24.634]  - Number of conditions: 1
[10:26:24.635]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:24.635] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[10:26:24.639] getGlobalsAndPackages() ...
[10:26:24.639] Searching for globals...
[10:26:24.640] - globals found: [1] ‘{’
[10:26:24.640] Searching for globals ... DONE
[10:26:24.640] Resolving globals: FALSE
[10:26:24.640] 
[10:26:24.640] 
[10:26:24.641] getGlobalsAndPackages() ... DONE
[10:26:24.641] Packages needed by the future expression (n = 0): <none>
[10:26:24.641] Packages needed by future strategies (n = 0): <none>
[10:26:24.642] {
[10:26:24.642]     {
[10:26:24.642]         {
[10:26:24.642]             ...future.startTime <- base::Sys.time()
[10:26:24.642]             {
[10:26:24.642]                 {
[10:26:24.642]                   {
[10:26:24.642]                     {
[10:26:24.642]                       base::local({
[10:26:24.642]                         has_future <- base::requireNamespace("future", 
[10:26:24.642]                           quietly = TRUE)
[10:26:24.642]                         if (has_future) {
[10:26:24.642]                           ns <- base::getNamespace("future")
[10:26:24.642]                           version <- ns[[".package"]][["version"]]
[10:26:24.642]                           if (is.null(version)) 
[10:26:24.642]                             version <- utils::packageVersion("future")
[10:26:24.642]                         }
[10:26:24.642]                         else {
[10:26:24.642]                           version <- NULL
[10:26:24.642]                         }
[10:26:24.642]                         if (!has_future || version < "1.8.0") {
[10:26:24.642]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.642]                             "", base::R.version$version.string), 
[10:26:24.642]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.642]                               "release", "version")], collapse = " "), 
[10:26:24.642]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.642]                             info)
[10:26:24.642]                           info <- base::paste(info, collapse = "; ")
[10:26:24.642]                           if (!has_future) {
[10:26:24.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.642]                               info)
[10:26:24.642]                           }
[10:26:24.642]                           else {
[10:26:24.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.642]                               info, version)
[10:26:24.642]                           }
[10:26:24.642]                           base::stop(msg)
[10:26:24.642]                         }
[10:26:24.642]                       })
[10:26:24.642]                     }
[10:26:24.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.642]                     base::options(mc.cores = 1L)
[10:26:24.642]                   }
[10:26:24.642]                   options(future.plan = NULL)
[10:26:24.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.642]                 }
[10:26:24.642]                 ...future.workdir <- getwd()
[10:26:24.642]             }
[10:26:24.642]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.642]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.642]         }
[10:26:24.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.642]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.642]             base::names(...future.oldOptions))
[10:26:24.642]     }
[10:26:24.642]     if (FALSE) {
[10:26:24.642]     }
[10:26:24.642]     else {
[10:26:24.642]         if (TRUE) {
[10:26:24.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.642]                 open = "w")
[10:26:24.642]         }
[10:26:24.642]         else {
[10:26:24.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.642]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.642]         }
[10:26:24.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.642]             base::sink(type = "output", split = FALSE)
[10:26:24.642]             base::close(...future.stdout)
[10:26:24.642]         }, add = TRUE)
[10:26:24.642]     }
[10:26:24.642]     ...future.frame <- base::sys.nframe()
[10:26:24.642]     ...future.conditions <- base::list()
[10:26:24.642]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.642]     if (FALSE) {
[10:26:24.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.642]     }
[10:26:24.642]     ...future.result <- base::tryCatch({
[10:26:24.642]         base::withCallingHandlers({
[10:26:24.642]             ...future.value <- base::withVisible(base::local({
[10:26:24.642]                 withCallingHandlers({
[10:26:24.642]                   {
[10:26:24.642]                     42L
[10:26:24.642]                   }
[10:26:24.642]                 }, immediateCondition = function(cond) {
[10:26:24.642]                   save_rds <- function (object, pathname, ...) 
[10:26:24.642]                   {
[10:26:24.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.642]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.642]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.642]                         fi_tmp[["mtime"]])
[10:26:24.642]                     }
[10:26:24.642]                     tryCatch({
[10:26:24.642]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.642]                     }, error = function(ex) {
[10:26:24.642]                       msg <- conditionMessage(ex)
[10:26:24.642]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.642]                         fi_tmp[["mtime"]], msg)
[10:26:24.642]                       ex$message <- msg
[10:26:24.642]                       stop(ex)
[10:26:24.642]                     })
[10:26:24.642]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.642]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.642]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.642]                       fi <- file.info(pathname)
[10:26:24.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.642]                         fi[["size"]], fi[["mtime"]])
[10:26:24.642]                       stop(msg)
[10:26:24.642]                     }
[10:26:24.642]                     invisible(pathname)
[10:26:24.642]                   }
[10:26:24.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.642]                     rootPath = tempdir()) 
[10:26:24.642]                   {
[10:26:24.642]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.642]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.642]                       tmpdir = path, fileext = ".rds")
[10:26:24.642]                     save_rds(obj, file)
[10:26:24.642]                   }
[10:26:24.642]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.642]                   {
[10:26:24.642]                     inherits <- base::inherits
[10:26:24.642]                     invokeRestart <- base::invokeRestart
[10:26:24.642]                     is.null <- base::is.null
[10:26:24.642]                     muffled <- FALSE
[10:26:24.642]                     if (inherits(cond, "message")) {
[10:26:24.642]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.642]                       if (muffled) 
[10:26:24.642]                         invokeRestart("muffleMessage")
[10:26:24.642]                     }
[10:26:24.642]                     else if (inherits(cond, "warning")) {
[10:26:24.642]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.642]                       if (muffled) 
[10:26:24.642]                         invokeRestart("muffleWarning")
[10:26:24.642]                     }
[10:26:24.642]                     else if (inherits(cond, "condition")) {
[10:26:24.642]                       if (!is.null(pattern)) {
[10:26:24.642]                         computeRestarts <- base::computeRestarts
[10:26:24.642]                         grepl <- base::grepl
[10:26:24.642]                         restarts <- computeRestarts(cond)
[10:26:24.642]                         for (restart in restarts) {
[10:26:24.642]                           name <- restart$name
[10:26:24.642]                           if (is.null(name)) 
[10:26:24.642]                             next
[10:26:24.642]                           if (!grepl(pattern, name)) 
[10:26:24.642]                             next
[10:26:24.642]                           invokeRestart(restart)
[10:26:24.642]                           muffled <- TRUE
[10:26:24.642]                           break
[10:26:24.642]                         }
[10:26:24.642]                       }
[10:26:24.642]                     }
[10:26:24.642]                     invisible(muffled)
[10:26:24.642]                   }
[10:26:24.642]                   muffleCondition(cond)
[10:26:24.642]                 })
[10:26:24.642]             }))
[10:26:24.642]             future::FutureResult(value = ...future.value$value, 
[10:26:24.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.642]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.642]                     ...future.globalenv.names))
[10:26:24.642]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.642]         }, condition = base::local({
[10:26:24.642]             c <- base::c
[10:26:24.642]             inherits <- base::inherits
[10:26:24.642]             invokeRestart <- base::invokeRestart
[10:26:24.642]             length <- base::length
[10:26:24.642]             list <- base::list
[10:26:24.642]             seq.int <- base::seq.int
[10:26:24.642]             signalCondition <- base::signalCondition
[10:26:24.642]             sys.calls <- base::sys.calls
[10:26:24.642]             `[[` <- base::`[[`
[10:26:24.642]             `+` <- base::`+`
[10:26:24.642]             `<<-` <- base::`<<-`
[10:26:24.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.642]                   3L)]
[10:26:24.642]             }
[10:26:24.642]             function(cond) {
[10:26:24.642]                 is_error <- inherits(cond, "error")
[10:26:24.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.642]                   NULL)
[10:26:24.642]                 if (is_error) {
[10:26:24.642]                   sessionInformation <- function() {
[10:26:24.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.642]                       search = base::search(), system = base::Sys.info())
[10:26:24.642]                   }
[10:26:24.642]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.642]                     cond$call), session = sessionInformation(), 
[10:26:24.642]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.642]                   signalCondition(cond)
[10:26:24.642]                 }
[10:26:24.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.642]                 "immediateCondition"))) {
[10:26:24.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.642]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.642]                   if (TRUE && !signal) {
[10:26:24.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.642]                     {
[10:26:24.642]                       inherits <- base::inherits
[10:26:24.642]                       invokeRestart <- base::invokeRestart
[10:26:24.642]                       is.null <- base::is.null
[10:26:24.642]                       muffled <- FALSE
[10:26:24.642]                       if (inherits(cond, "message")) {
[10:26:24.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.642]                         if (muffled) 
[10:26:24.642]                           invokeRestart("muffleMessage")
[10:26:24.642]                       }
[10:26:24.642]                       else if (inherits(cond, "warning")) {
[10:26:24.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.642]                         if (muffled) 
[10:26:24.642]                           invokeRestart("muffleWarning")
[10:26:24.642]                       }
[10:26:24.642]                       else if (inherits(cond, "condition")) {
[10:26:24.642]                         if (!is.null(pattern)) {
[10:26:24.642]                           computeRestarts <- base::computeRestarts
[10:26:24.642]                           grepl <- base::grepl
[10:26:24.642]                           restarts <- computeRestarts(cond)
[10:26:24.642]                           for (restart in restarts) {
[10:26:24.642]                             name <- restart$name
[10:26:24.642]                             if (is.null(name)) 
[10:26:24.642]                               next
[10:26:24.642]                             if (!grepl(pattern, name)) 
[10:26:24.642]                               next
[10:26:24.642]                             invokeRestart(restart)
[10:26:24.642]                             muffled <- TRUE
[10:26:24.642]                             break
[10:26:24.642]                           }
[10:26:24.642]                         }
[10:26:24.642]                       }
[10:26:24.642]                       invisible(muffled)
[10:26:24.642]                     }
[10:26:24.642]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.642]                   }
[10:26:24.642]                 }
[10:26:24.642]                 else {
[10:26:24.642]                   if (TRUE) {
[10:26:24.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.642]                     {
[10:26:24.642]                       inherits <- base::inherits
[10:26:24.642]                       invokeRestart <- base::invokeRestart
[10:26:24.642]                       is.null <- base::is.null
[10:26:24.642]                       muffled <- FALSE
[10:26:24.642]                       if (inherits(cond, "message")) {
[10:26:24.642]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.642]                         if (muffled) 
[10:26:24.642]                           invokeRestart("muffleMessage")
[10:26:24.642]                       }
[10:26:24.642]                       else if (inherits(cond, "warning")) {
[10:26:24.642]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.642]                         if (muffled) 
[10:26:24.642]                           invokeRestart("muffleWarning")
[10:26:24.642]                       }
[10:26:24.642]                       else if (inherits(cond, "condition")) {
[10:26:24.642]                         if (!is.null(pattern)) {
[10:26:24.642]                           computeRestarts <- base::computeRestarts
[10:26:24.642]                           grepl <- base::grepl
[10:26:24.642]                           restarts <- computeRestarts(cond)
[10:26:24.642]                           for (restart in restarts) {
[10:26:24.642]                             name <- restart$name
[10:26:24.642]                             if (is.null(name)) 
[10:26:24.642]                               next
[10:26:24.642]                             if (!grepl(pattern, name)) 
[10:26:24.642]                               next
[10:26:24.642]                             invokeRestart(restart)
[10:26:24.642]                             muffled <- TRUE
[10:26:24.642]                             break
[10:26:24.642]                           }
[10:26:24.642]                         }
[10:26:24.642]                       }
[10:26:24.642]                       invisible(muffled)
[10:26:24.642]                     }
[10:26:24.642]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.642]                   }
[10:26:24.642]                 }
[10:26:24.642]             }
[10:26:24.642]         }))
[10:26:24.642]     }, error = function(ex) {
[10:26:24.642]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.642]                 ...future.rng), started = ...future.startTime, 
[10:26:24.642]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.642]             version = "1.8"), class = "FutureResult")
[10:26:24.642]     }, finally = {
[10:26:24.642]         if (!identical(...future.workdir, getwd())) 
[10:26:24.642]             setwd(...future.workdir)
[10:26:24.642]         {
[10:26:24.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.642]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.642]             }
[10:26:24.642]             base::options(...future.oldOptions)
[10:26:24.642]             if (.Platform$OS.type == "windows") {
[10:26:24.642]                 old_names <- names(...future.oldEnvVars)
[10:26:24.642]                 envs <- base::Sys.getenv()
[10:26:24.642]                 names <- names(envs)
[10:26:24.642]                 common <- intersect(names, old_names)
[10:26:24.642]                 added <- setdiff(names, old_names)
[10:26:24.642]                 removed <- setdiff(old_names, names)
[10:26:24.642]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.642]                   envs[common]]
[10:26:24.642]                 NAMES <- toupper(changed)
[10:26:24.642]                 args <- list()
[10:26:24.642]                 for (kk in seq_along(NAMES)) {
[10:26:24.642]                   name <- changed[[kk]]
[10:26:24.642]                   NAME <- NAMES[[kk]]
[10:26:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.642]                     next
[10:26:24.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.642]                 }
[10:26:24.642]                 NAMES <- toupper(added)
[10:26:24.642]                 for (kk in seq_along(NAMES)) {
[10:26:24.642]                   name <- added[[kk]]
[10:26:24.642]                   NAME <- NAMES[[kk]]
[10:26:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.642]                     next
[10:26:24.642]                   args[[name]] <- ""
[10:26:24.642]                 }
[10:26:24.642]                 NAMES <- toupper(removed)
[10:26:24.642]                 for (kk in seq_along(NAMES)) {
[10:26:24.642]                   name <- removed[[kk]]
[10:26:24.642]                   NAME <- NAMES[[kk]]
[10:26:24.642]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.642]                     next
[10:26:24.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.642]                 }
[10:26:24.642]                 if (length(args) > 0) 
[10:26:24.642]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.642]             }
[10:26:24.642]             else {
[10:26:24.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.642]             }
[10:26:24.642]             {
[10:26:24.642]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.642]                   0L) {
[10:26:24.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.642]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.642]                   base::options(opts)
[10:26:24.642]                 }
[10:26:24.642]                 {
[10:26:24.642]                   {
[10:26:24.642]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.642]                     NULL
[10:26:24.642]                   }
[10:26:24.642]                   options(future.plan = NULL)
[10:26:24.642]                   if (is.na(NA_character_)) 
[10:26:24.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.642]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.642]                     envir = parent.frame()) 
[10:26:24.642]                   {
[10:26:24.642]                     default_workers <- missing(workers)
[10:26:24.642]                     if (is.function(workers)) 
[10:26:24.642]                       workers <- workers()
[10:26:24.642]                     workers <- structure(as.integer(workers), 
[10:26:24.642]                       class = class(workers))
[10:26:24.642]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.642]                       1L)
[10:26:24.642]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.642]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.642]                       if (default_workers) 
[10:26:24.642]                         supportsMulticore(warn = TRUE)
[10:26:24.642]                       return(sequential(..., envir = envir))
[10:26:24.642]                     }
[10:26:24.642]                     oopts <- options(mc.cores = workers)
[10:26:24.642]                     on.exit(options(oopts))
[10:26:24.642]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.642]                       envir = envir)
[10:26:24.642]                     if (!future$lazy) 
[10:26:24.642]                       future <- run(future)
[10:26:24.642]                     invisible(future)
[10:26:24.642]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.642]                 }
[10:26:24.642]             }
[10:26:24.642]         }
[10:26:24.642]     })
[10:26:24.642]     if (TRUE) {
[10:26:24.642]         base::sink(type = "output", split = FALSE)
[10:26:24.642]         if (TRUE) {
[10:26:24.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.642]         }
[10:26:24.642]         else {
[10:26:24.642]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.642]         }
[10:26:24.642]         base::close(...future.stdout)
[10:26:24.642]         ...future.stdout <- NULL
[10:26:24.642]     }
[10:26:24.642]     ...future.result$conditions <- ...future.conditions
[10:26:24.642]     ...future.result$finished <- base::Sys.time()
[10:26:24.642]     ...future.result
[10:26:24.642] }
[10:26:24.645] requestCore(): workers = 2
[10:26:24.646] MulticoreFuture started
[10:26:24.647] plan(): Setting new future strategy stack:
[10:26:24.648] List of future strategies:
[10:26:24.648] 1. sequential:
[10:26:24.648]    - args: function (..., envir = parent.frame())
[10:26:24.648]    - tweaked: FALSE
[10:26:24.648]    - call: NULL
[10:26:24.648] plan(): nbrOfWorkers() = 1
[10:26:24.650] plan(): Setting new future strategy stack:
[10:26:24.650] List of future strategies:
[10:26:24.650] 1. multicore:
[10:26:24.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.650]    - tweaked: FALSE
[10:26:24.650]    - call: plan(multicore)
[10:26:24.656] plan(): nbrOfWorkers() = 2
[1] TRUE
[10:26:24.656] result() for MulticoreFuture ...
[10:26:24.657] result() for MulticoreFuture ...
[10:26:24.657] result() for MulticoreFuture ... done
[10:26:24.657] result() for MulticoreFuture ... done
[10:26:24.658] result() for MulticoreFuture ...
[10:26:24.658] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = TRUE) with globals
[10:26:24.662] getGlobalsAndPackages() ...
[10:26:24.662] Searching for globals...
[10:26:24.664] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:26:24.664] Searching for globals ... DONE
[10:26:24.665] Resolving globals: FALSE
[10:26:24.665] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.666] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[10:26:24.666] - globals: [1] ‘a’
[10:26:24.666] 
[10:26:24.666] getGlobalsAndPackages() ... DONE
[10:26:24.666] Packages needed by the future expression (n = 0): <none>
[10:26:24.667] Packages needed by future strategies (n = 0): <none>
[10:26:24.667] {
[10:26:24.667]     {
[10:26:24.667]         {
[10:26:24.667]             ...future.startTime <- base::Sys.time()
[10:26:24.667]             {
[10:26:24.667]                 {
[10:26:24.667]                   {
[10:26:24.667]                     {
[10:26:24.667]                       base::local({
[10:26:24.667]                         has_future <- base::requireNamespace("future", 
[10:26:24.667]                           quietly = TRUE)
[10:26:24.667]                         if (has_future) {
[10:26:24.667]                           ns <- base::getNamespace("future")
[10:26:24.667]                           version <- ns[[".package"]][["version"]]
[10:26:24.667]                           if (is.null(version)) 
[10:26:24.667]                             version <- utils::packageVersion("future")
[10:26:24.667]                         }
[10:26:24.667]                         else {
[10:26:24.667]                           version <- NULL
[10:26:24.667]                         }
[10:26:24.667]                         if (!has_future || version < "1.8.0") {
[10:26:24.667]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.667]                             "", base::R.version$version.string), 
[10:26:24.667]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.667]                               "release", "version")], collapse = " "), 
[10:26:24.667]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.667]                             info)
[10:26:24.667]                           info <- base::paste(info, collapse = "; ")
[10:26:24.667]                           if (!has_future) {
[10:26:24.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.667]                               info)
[10:26:24.667]                           }
[10:26:24.667]                           else {
[10:26:24.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.667]                               info, version)
[10:26:24.667]                           }
[10:26:24.667]                           base::stop(msg)
[10:26:24.667]                         }
[10:26:24.667]                       })
[10:26:24.667]                     }
[10:26:24.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.667]                     base::options(mc.cores = 1L)
[10:26:24.667]                   }
[10:26:24.667]                   options(future.plan = NULL)
[10:26:24.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.667]                 }
[10:26:24.667]                 ...future.workdir <- getwd()
[10:26:24.667]             }
[10:26:24.667]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.667]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.667]         }
[10:26:24.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.667]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.667]             base::names(...future.oldOptions))
[10:26:24.667]     }
[10:26:24.667]     if (FALSE) {
[10:26:24.667]     }
[10:26:24.667]     else {
[10:26:24.667]         if (TRUE) {
[10:26:24.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.667]                 open = "w")
[10:26:24.667]         }
[10:26:24.667]         else {
[10:26:24.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.667]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.667]         }
[10:26:24.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.667]             base::sink(type = "output", split = FALSE)
[10:26:24.667]             base::close(...future.stdout)
[10:26:24.667]         }, add = TRUE)
[10:26:24.667]     }
[10:26:24.667]     ...future.frame <- base::sys.nframe()
[10:26:24.667]     ...future.conditions <- base::list()
[10:26:24.667]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.667]     if (FALSE) {
[10:26:24.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.667]     }
[10:26:24.667]     ...future.result <- base::tryCatch({
[10:26:24.667]         base::withCallingHandlers({
[10:26:24.667]             ...future.value <- base::withVisible(base::local({
[10:26:24.667]                 withCallingHandlers({
[10:26:24.667]                   {
[10:26:24.667]                     b <- 3
[10:26:24.667]                     c <- 2
[10:26:24.667]                     a * b * c
[10:26:24.667]                   }
[10:26:24.667]                 }, immediateCondition = function(cond) {
[10:26:24.667]                   save_rds <- function (object, pathname, ...) 
[10:26:24.667]                   {
[10:26:24.667]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.667]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.667]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.667]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.667]                         fi_tmp[["mtime"]])
[10:26:24.667]                     }
[10:26:24.667]                     tryCatch({
[10:26:24.667]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.667]                     }, error = function(ex) {
[10:26:24.667]                       msg <- conditionMessage(ex)
[10:26:24.667]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.667]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.667]                         fi_tmp[["mtime"]], msg)
[10:26:24.667]                       ex$message <- msg
[10:26:24.667]                       stop(ex)
[10:26:24.667]                     })
[10:26:24.667]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.667]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.667]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.667]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.667]                       fi <- file.info(pathname)
[10:26:24.667]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.667]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.667]                         fi[["size"]], fi[["mtime"]])
[10:26:24.667]                       stop(msg)
[10:26:24.667]                     }
[10:26:24.667]                     invisible(pathname)
[10:26:24.667]                   }
[10:26:24.667]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.667]                     rootPath = tempdir()) 
[10:26:24.667]                   {
[10:26:24.667]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.667]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.667]                       tmpdir = path, fileext = ".rds")
[10:26:24.667]                     save_rds(obj, file)
[10:26:24.667]                   }
[10:26:24.667]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.667]                   {
[10:26:24.667]                     inherits <- base::inherits
[10:26:24.667]                     invokeRestart <- base::invokeRestart
[10:26:24.667]                     is.null <- base::is.null
[10:26:24.667]                     muffled <- FALSE
[10:26:24.667]                     if (inherits(cond, "message")) {
[10:26:24.667]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.667]                       if (muffled) 
[10:26:24.667]                         invokeRestart("muffleMessage")
[10:26:24.667]                     }
[10:26:24.667]                     else if (inherits(cond, "warning")) {
[10:26:24.667]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.667]                       if (muffled) 
[10:26:24.667]                         invokeRestart("muffleWarning")
[10:26:24.667]                     }
[10:26:24.667]                     else if (inherits(cond, "condition")) {
[10:26:24.667]                       if (!is.null(pattern)) {
[10:26:24.667]                         computeRestarts <- base::computeRestarts
[10:26:24.667]                         grepl <- base::grepl
[10:26:24.667]                         restarts <- computeRestarts(cond)
[10:26:24.667]                         for (restart in restarts) {
[10:26:24.667]                           name <- restart$name
[10:26:24.667]                           if (is.null(name)) 
[10:26:24.667]                             next
[10:26:24.667]                           if (!grepl(pattern, name)) 
[10:26:24.667]                             next
[10:26:24.667]                           invokeRestart(restart)
[10:26:24.667]                           muffled <- TRUE
[10:26:24.667]                           break
[10:26:24.667]                         }
[10:26:24.667]                       }
[10:26:24.667]                     }
[10:26:24.667]                     invisible(muffled)
[10:26:24.667]                   }
[10:26:24.667]                   muffleCondition(cond)
[10:26:24.667]                 })
[10:26:24.667]             }))
[10:26:24.667]             future::FutureResult(value = ...future.value$value, 
[10:26:24.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.667]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.667]                     ...future.globalenv.names))
[10:26:24.667]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.667]         }, condition = base::local({
[10:26:24.667]             c <- base::c
[10:26:24.667]             inherits <- base::inherits
[10:26:24.667]             invokeRestart <- base::invokeRestart
[10:26:24.667]             length <- base::length
[10:26:24.667]             list <- base::list
[10:26:24.667]             seq.int <- base::seq.int
[10:26:24.667]             signalCondition <- base::signalCondition
[10:26:24.667]             sys.calls <- base::sys.calls
[10:26:24.667]             `[[` <- base::`[[`
[10:26:24.667]             `+` <- base::`+`
[10:26:24.667]             `<<-` <- base::`<<-`
[10:26:24.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.667]                   3L)]
[10:26:24.667]             }
[10:26:24.667]             function(cond) {
[10:26:24.667]                 is_error <- inherits(cond, "error")
[10:26:24.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.667]                   NULL)
[10:26:24.667]                 if (is_error) {
[10:26:24.667]                   sessionInformation <- function() {
[10:26:24.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.667]                       search = base::search(), system = base::Sys.info())
[10:26:24.667]                   }
[10:26:24.667]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.667]                     cond$call), session = sessionInformation(), 
[10:26:24.667]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.667]                   signalCondition(cond)
[10:26:24.667]                 }
[10:26:24.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.667]                 "immediateCondition"))) {
[10:26:24.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.667]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.667]                   if (TRUE && !signal) {
[10:26:24.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.667]                     {
[10:26:24.667]                       inherits <- base::inherits
[10:26:24.667]                       invokeRestart <- base::invokeRestart
[10:26:24.667]                       is.null <- base::is.null
[10:26:24.667]                       muffled <- FALSE
[10:26:24.667]                       if (inherits(cond, "message")) {
[10:26:24.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.667]                         if (muffled) 
[10:26:24.667]                           invokeRestart("muffleMessage")
[10:26:24.667]                       }
[10:26:24.667]                       else if (inherits(cond, "warning")) {
[10:26:24.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.667]                         if (muffled) 
[10:26:24.667]                           invokeRestart("muffleWarning")
[10:26:24.667]                       }
[10:26:24.667]                       else if (inherits(cond, "condition")) {
[10:26:24.667]                         if (!is.null(pattern)) {
[10:26:24.667]                           computeRestarts <- base::computeRestarts
[10:26:24.667]                           grepl <- base::grepl
[10:26:24.667]                           restarts <- computeRestarts(cond)
[10:26:24.667]                           for (restart in restarts) {
[10:26:24.667]                             name <- restart$name
[10:26:24.667]                             if (is.null(name)) 
[10:26:24.667]                               next
[10:26:24.667]                             if (!grepl(pattern, name)) 
[10:26:24.667]                               next
[10:26:24.667]                             invokeRestart(restart)
[10:26:24.667]                             muffled <- TRUE
[10:26:24.667]                             break
[10:26:24.667]                           }
[10:26:24.667]                         }
[10:26:24.667]                       }
[10:26:24.667]                       invisible(muffled)
[10:26:24.667]                     }
[10:26:24.667]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.667]                   }
[10:26:24.667]                 }
[10:26:24.667]                 else {
[10:26:24.667]                   if (TRUE) {
[10:26:24.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.667]                     {
[10:26:24.667]                       inherits <- base::inherits
[10:26:24.667]                       invokeRestart <- base::invokeRestart
[10:26:24.667]                       is.null <- base::is.null
[10:26:24.667]                       muffled <- FALSE
[10:26:24.667]                       if (inherits(cond, "message")) {
[10:26:24.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.667]                         if (muffled) 
[10:26:24.667]                           invokeRestart("muffleMessage")
[10:26:24.667]                       }
[10:26:24.667]                       else if (inherits(cond, "warning")) {
[10:26:24.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.667]                         if (muffled) 
[10:26:24.667]                           invokeRestart("muffleWarning")
[10:26:24.667]                       }
[10:26:24.667]                       else if (inherits(cond, "condition")) {
[10:26:24.667]                         if (!is.null(pattern)) {
[10:26:24.667]                           computeRestarts <- base::computeRestarts
[10:26:24.667]                           grepl <- base::grepl
[10:26:24.667]                           restarts <- computeRestarts(cond)
[10:26:24.667]                           for (restart in restarts) {
[10:26:24.667]                             name <- restart$name
[10:26:24.667]                             if (is.null(name)) 
[10:26:24.667]                               next
[10:26:24.667]                             if (!grepl(pattern, name)) 
[10:26:24.667]                               next
[10:26:24.667]                             invokeRestart(restart)
[10:26:24.667]                             muffled <- TRUE
[10:26:24.667]                             break
[10:26:24.667]                           }
[10:26:24.667]                         }
[10:26:24.667]                       }
[10:26:24.667]                       invisible(muffled)
[10:26:24.667]                     }
[10:26:24.667]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.667]                   }
[10:26:24.667]                 }
[10:26:24.667]             }
[10:26:24.667]         }))
[10:26:24.667]     }, error = function(ex) {
[10:26:24.667]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.667]                 ...future.rng), started = ...future.startTime, 
[10:26:24.667]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.667]             version = "1.8"), class = "FutureResult")
[10:26:24.667]     }, finally = {
[10:26:24.667]         if (!identical(...future.workdir, getwd())) 
[10:26:24.667]             setwd(...future.workdir)
[10:26:24.667]         {
[10:26:24.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.667]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.667]             }
[10:26:24.667]             base::options(...future.oldOptions)
[10:26:24.667]             if (.Platform$OS.type == "windows") {
[10:26:24.667]                 old_names <- names(...future.oldEnvVars)
[10:26:24.667]                 envs <- base::Sys.getenv()
[10:26:24.667]                 names <- names(envs)
[10:26:24.667]                 common <- intersect(names, old_names)
[10:26:24.667]                 added <- setdiff(names, old_names)
[10:26:24.667]                 removed <- setdiff(old_names, names)
[10:26:24.667]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.667]                   envs[common]]
[10:26:24.667]                 NAMES <- toupper(changed)
[10:26:24.667]                 args <- list()
[10:26:24.667]                 for (kk in seq_along(NAMES)) {
[10:26:24.667]                   name <- changed[[kk]]
[10:26:24.667]                   NAME <- NAMES[[kk]]
[10:26:24.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.667]                     next
[10:26:24.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.667]                 }
[10:26:24.667]                 NAMES <- toupper(added)
[10:26:24.667]                 for (kk in seq_along(NAMES)) {
[10:26:24.667]                   name <- added[[kk]]
[10:26:24.667]                   NAME <- NAMES[[kk]]
[10:26:24.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.667]                     next
[10:26:24.667]                   args[[name]] <- ""
[10:26:24.667]                 }
[10:26:24.667]                 NAMES <- toupper(removed)
[10:26:24.667]                 for (kk in seq_along(NAMES)) {
[10:26:24.667]                   name <- removed[[kk]]
[10:26:24.667]                   NAME <- NAMES[[kk]]
[10:26:24.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.667]                     next
[10:26:24.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.667]                 }
[10:26:24.667]                 if (length(args) > 0) 
[10:26:24.667]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.667]             }
[10:26:24.667]             else {
[10:26:24.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.667]             }
[10:26:24.667]             {
[10:26:24.667]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.667]                   0L) {
[10:26:24.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.667]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.667]                   base::options(opts)
[10:26:24.667]                 }
[10:26:24.667]                 {
[10:26:24.667]                   {
[10:26:24.667]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.667]                     NULL
[10:26:24.667]                   }
[10:26:24.667]                   options(future.plan = NULL)
[10:26:24.667]                   if (is.na(NA_character_)) 
[10:26:24.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.667]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.667]                     envir = parent.frame()) 
[10:26:24.667]                   {
[10:26:24.667]                     default_workers <- missing(workers)
[10:26:24.667]                     if (is.function(workers)) 
[10:26:24.667]                       workers <- workers()
[10:26:24.667]                     workers <- structure(as.integer(workers), 
[10:26:24.667]                       class = class(workers))
[10:26:24.667]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.667]                       1L)
[10:26:24.667]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.667]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.667]                       if (default_workers) 
[10:26:24.667]                         supportsMulticore(warn = TRUE)
[10:26:24.667]                       return(sequential(..., envir = envir))
[10:26:24.667]                     }
[10:26:24.667]                     oopts <- options(mc.cores = workers)
[10:26:24.667]                     on.exit(options(oopts))
[10:26:24.667]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.667]                       envir = envir)
[10:26:24.667]                     if (!future$lazy) 
[10:26:24.667]                       future <- run(future)
[10:26:24.667]                     invisible(future)
[10:26:24.667]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.667]                 }
[10:26:24.667]             }
[10:26:24.667]         }
[10:26:24.667]     })
[10:26:24.667]     if (TRUE) {
[10:26:24.667]         base::sink(type = "output", split = FALSE)
[10:26:24.667]         if (TRUE) {
[10:26:24.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.667]         }
[10:26:24.667]         else {
[10:26:24.667]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.667]         }
[10:26:24.667]         base::close(...future.stdout)
[10:26:24.667]         ...future.stdout <- NULL
[10:26:24.667]     }
[10:26:24.667]     ...future.result$conditions <- ...future.conditions
[10:26:24.667]     ...future.result$finished <- base::Sys.time()
[10:26:24.667]     ...future.result
[10:26:24.667] }
[10:26:24.673] assign_globals() ...
[10:26:24.673] List of 1
[10:26:24.673]  $ a: num 0
[10:26:24.673]  - attr(*, "where")=List of 1
[10:26:24.673]   ..$ a:<environment: R_EmptyEnv> 
[10:26:24.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.673]  - attr(*, "resolved")= logi FALSE
[10:26:24.673]  - attr(*, "total_size")= num 56
[10:26:24.676] - copied ‘a’ to environment
[10:26:24.676] assign_globals() ... done
[10:26:24.677] requestCore(): workers = 2
[10:26:24.678] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:26:24.679] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.680] List of future strategies:
[10:26:24.680] 1. sequential:
[10:26:24.680]    - args: function (..., envir = parent.frame())
[10:26:24.680]    - tweaked: FALSE
[10:26:24.680]    - call: NULL
[10:26:24.680] plan(): nbrOfWorkers() = 1
[10:26:24.682] plan(): Setting new future strategy stack:
[10:26:24.683] List of future strategies:
[10:26:24.683] 1. multicore:
[10:26:24.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.683]    - tweaked: FALSE
[10:26:24.683]    - call: plan(multicore)
[10:26:24.688] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.688] result() for MulticoreFuture ...
[10:26:24.689] result() for MulticoreFuture ...
[10:26:24.690] result() for MulticoreFuture ... done
[10:26:24.690] result() for MulticoreFuture ... done
[10:26:24.690] result() for MulticoreFuture ...
[10:26:24.690] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[10:26:24.694] getGlobalsAndPackages() ...
[10:26:24.694] Searching for globals...
[10:26:24.695] - globals found: [2] ‘{’, ‘ii’
[10:26:24.695] Searching for globals ... DONE
[10:26:24.695] Resolving globals: FALSE
[10:26:24.696] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.696] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.696] - globals: [1] ‘ii’
[10:26:24.697] 
[10:26:24.697] getGlobalsAndPackages() ... DONE
[10:26:24.697] Packages needed by the future expression (n = 0): <none>
[10:26:24.697] Packages needed by future strategies (n = 0): <none>
[10:26:24.698] {
[10:26:24.698]     {
[10:26:24.698]         {
[10:26:24.698]             ...future.startTime <- base::Sys.time()
[10:26:24.698]             {
[10:26:24.698]                 {
[10:26:24.698]                   {
[10:26:24.698]                     {
[10:26:24.698]                       base::local({
[10:26:24.698]                         has_future <- base::requireNamespace("future", 
[10:26:24.698]                           quietly = TRUE)
[10:26:24.698]                         if (has_future) {
[10:26:24.698]                           ns <- base::getNamespace("future")
[10:26:24.698]                           version <- ns[[".package"]][["version"]]
[10:26:24.698]                           if (is.null(version)) 
[10:26:24.698]                             version <- utils::packageVersion("future")
[10:26:24.698]                         }
[10:26:24.698]                         else {
[10:26:24.698]                           version <- NULL
[10:26:24.698]                         }
[10:26:24.698]                         if (!has_future || version < "1.8.0") {
[10:26:24.698]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.698]                             "", base::R.version$version.string), 
[10:26:24.698]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.698]                               "release", "version")], collapse = " "), 
[10:26:24.698]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.698]                             info)
[10:26:24.698]                           info <- base::paste(info, collapse = "; ")
[10:26:24.698]                           if (!has_future) {
[10:26:24.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.698]                               info)
[10:26:24.698]                           }
[10:26:24.698]                           else {
[10:26:24.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.698]                               info, version)
[10:26:24.698]                           }
[10:26:24.698]                           base::stop(msg)
[10:26:24.698]                         }
[10:26:24.698]                       })
[10:26:24.698]                     }
[10:26:24.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.698]                     base::options(mc.cores = 1L)
[10:26:24.698]                   }
[10:26:24.698]                   options(future.plan = NULL)
[10:26:24.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.698]                 }
[10:26:24.698]                 ...future.workdir <- getwd()
[10:26:24.698]             }
[10:26:24.698]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.698]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.698]         }
[10:26:24.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.698]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.698]             base::names(...future.oldOptions))
[10:26:24.698]     }
[10:26:24.698]     if (FALSE) {
[10:26:24.698]     }
[10:26:24.698]     else {
[10:26:24.698]         if (TRUE) {
[10:26:24.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.698]                 open = "w")
[10:26:24.698]         }
[10:26:24.698]         else {
[10:26:24.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.698]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.698]         }
[10:26:24.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.698]             base::sink(type = "output", split = FALSE)
[10:26:24.698]             base::close(...future.stdout)
[10:26:24.698]         }, add = TRUE)
[10:26:24.698]     }
[10:26:24.698]     ...future.frame <- base::sys.nframe()
[10:26:24.698]     ...future.conditions <- base::list()
[10:26:24.698]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.698]     if (FALSE) {
[10:26:24.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.698]     }
[10:26:24.698]     ...future.result <- base::tryCatch({
[10:26:24.698]         base::withCallingHandlers({
[10:26:24.698]             ...future.value <- base::withVisible(base::local({
[10:26:24.698]                 withCallingHandlers({
[10:26:24.698]                   {
[10:26:24.698]                     ii
[10:26:24.698]                   }
[10:26:24.698]                 }, immediateCondition = function(cond) {
[10:26:24.698]                   save_rds <- function (object, pathname, ...) 
[10:26:24.698]                   {
[10:26:24.698]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.698]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.698]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.698]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.698]                         fi_tmp[["mtime"]])
[10:26:24.698]                     }
[10:26:24.698]                     tryCatch({
[10:26:24.698]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.698]                     }, error = function(ex) {
[10:26:24.698]                       msg <- conditionMessage(ex)
[10:26:24.698]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.698]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.698]                         fi_tmp[["mtime"]], msg)
[10:26:24.698]                       ex$message <- msg
[10:26:24.698]                       stop(ex)
[10:26:24.698]                     })
[10:26:24.698]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.698]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.698]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.698]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.698]                       fi <- file.info(pathname)
[10:26:24.698]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.698]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.698]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.698]                         fi[["size"]], fi[["mtime"]])
[10:26:24.698]                       stop(msg)
[10:26:24.698]                     }
[10:26:24.698]                     invisible(pathname)
[10:26:24.698]                   }
[10:26:24.698]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.698]                     rootPath = tempdir()) 
[10:26:24.698]                   {
[10:26:24.698]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.698]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.698]                       tmpdir = path, fileext = ".rds")
[10:26:24.698]                     save_rds(obj, file)
[10:26:24.698]                   }
[10:26:24.698]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.698]                   {
[10:26:24.698]                     inherits <- base::inherits
[10:26:24.698]                     invokeRestart <- base::invokeRestart
[10:26:24.698]                     is.null <- base::is.null
[10:26:24.698]                     muffled <- FALSE
[10:26:24.698]                     if (inherits(cond, "message")) {
[10:26:24.698]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.698]                       if (muffled) 
[10:26:24.698]                         invokeRestart("muffleMessage")
[10:26:24.698]                     }
[10:26:24.698]                     else if (inherits(cond, "warning")) {
[10:26:24.698]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.698]                       if (muffled) 
[10:26:24.698]                         invokeRestart("muffleWarning")
[10:26:24.698]                     }
[10:26:24.698]                     else if (inherits(cond, "condition")) {
[10:26:24.698]                       if (!is.null(pattern)) {
[10:26:24.698]                         computeRestarts <- base::computeRestarts
[10:26:24.698]                         grepl <- base::grepl
[10:26:24.698]                         restarts <- computeRestarts(cond)
[10:26:24.698]                         for (restart in restarts) {
[10:26:24.698]                           name <- restart$name
[10:26:24.698]                           if (is.null(name)) 
[10:26:24.698]                             next
[10:26:24.698]                           if (!grepl(pattern, name)) 
[10:26:24.698]                             next
[10:26:24.698]                           invokeRestart(restart)
[10:26:24.698]                           muffled <- TRUE
[10:26:24.698]                           break
[10:26:24.698]                         }
[10:26:24.698]                       }
[10:26:24.698]                     }
[10:26:24.698]                     invisible(muffled)
[10:26:24.698]                   }
[10:26:24.698]                   muffleCondition(cond)
[10:26:24.698]                 })
[10:26:24.698]             }))
[10:26:24.698]             future::FutureResult(value = ...future.value$value, 
[10:26:24.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.698]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.698]                     ...future.globalenv.names))
[10:26:24.698]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.698]         }, condition = base::local({
[10:26:24.698]             c <- base::c
[10:26:24.698]             inherits <- base::inherits
[10:26:24.698]             invokeRestart <- base::invokeRestart
[10:26:24.698]             length <- base::length
[10:26:24.698]             list <- base::list
[10:26:24.698]             seq.int <- base::seq.int
[10:26:24.698]             signalCondition <- base::signalCondition
[10:26:24.698]             sys.calls <- base::sys.calls
[10:26:24.698]             `[[` <- base::`[[`
[10:26:24.698]             `+` <- base::`+`
[10:26:24.698]             `<<-` <- base::`<<-`
[10:26:24.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.698]                   3L)]
[10:26:24.698]             }
[10:26:24.698]             function(cond) {
[10:26:24.698]                 is_error <- inherits(cond, "error")
[10:26:24.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.698]                   NULL)
[10:26:24.698]                 if (is_error) {
[10:26:24.698]                   sessionInformation <- function() {
[10:26:24.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.698]                       search = base::search(), system = base::Sys.info())
[10:26:24.698]                   }
[10:26:24.698]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.698]                     cond$call), session = sessionInformation(), 
[10:26:24.698]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.698]                   signalCondition(cond)
[10:26:24.698]                 }
[10:26:24.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.698]                 "immediateCondition"))) {
[10:26:24.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.698]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.698]                   if (TRUE && !signal) {
[10:26:24.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.698]                     {
[10:26:24.698]                       inherits <- base::inherits
[10:26:24.698]                       invokeRestart <- base::invokeRestart
[10:26:24.698]                       is.null <- base::is.null
[10:26:24.698]                       muffled <- FALSE
[10:26:24.698]                       if (inherits(cond, "message")) {
[10:26:24.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.698]                         if (muffled) 
[10:26:24.698]                           invokeRestart("muffleMessage")
[10:26:24.698]                       }
[10:26:24.698]                       else if (inherits(cond, "warning")) {
[10:26:24.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.698]                         if (muffled) 
[10:26:24.698]                           invokeRestart("muffleWarning")
[10:26:24.698]                       }
[10:26:24.698]                       else if (inherits(cond, "condition")) {
[10:26:24.698]                         if (!is.null(pattern)) {
[10:26:24.698]                           computeRestarts <- base::computeRestarts
[10:26:24.698]                           grepl <- base::grepl
[10:26:24.698]                           restarts <- computeRestarts(cond)
[10:26:24.698]                           for (restart in restarts) {
[10:26:24.698]                             name <- restart$name
[10:26:24.698]                             if (is.null(name)) 
[10:26:24.698]                               next
[10:26:24.698]                             if (!grepl(pattern, name)) 
[10:26:24.698]                               next
[10:26:24.698]                             invokeRestart(restart)
[10:26:24.698]                             muffled <- TRUE
[10:26:24.698]                             break
[10:26:24.698]                           }
[10:26:24.698]                         }
[10:26:24.698]                       }
[10:26:24.698]                       invisible(muffled)
[10:26:24.698]                     }
[10:26:24.698]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.698]                   }
[10:26:24.698]                 }
[10:26:24.698]                 else {
[10:26:24.698]                   if (TRUE) {
[10:26:24.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.698]                     {
[10:26:24.698]                       inherits <- base::inherits
[10:26:24.698]                       invokeRestart <- base::invokeRestart
[10:26:24.698]                       is.null <- base::is.null
[10:26:24.698]                       muffled <- FALSE
[10:26:24.698]                       if (inherits(cond, "message")) {
[10:26:24.698]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.698]                         if (muffled) 
[10:26:24.698]                           invokeRestart("muffleMessage")
[10:26:24.698]                       }
[10:26:24.698]                       else if (inherits(cond, "warning")) {
[10:26:24.698]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.698]                         if (muffled) 
[10:26:24.698]                           invokeRestart("muffleWarning")
[10:26:24.698]                       }
[10:26:24.698]                       else if (inherits(cond, "condition")) {
[10:26:24.698]                         if (!is.null(pattern)) {
[10:26:24.698]                           computeRestarts <- base::computeRestarts
[10:26:24.698]                           grepl <- base::grepl
[10:26:24.698]                           restarts <- computeRestarts(cond)
[10:26:24.698]                           for (restart in restarts) {
[10:26:24.698]                             name <- restart$name
[10:26:24.698]                             if (is.null(name)) 
[10:26:24.698]                               next
[10:26:24.698]                             if (!grepl(pattern, name)) 
[10:26:24.698]                               next
[10:26:24.698]                             invokeRestart(restart)
[10:26:24.698]                             muffled <- TRUE
[10:26:24.698]                             break
[10:26:24.698]                           }
[10:26:24.698]                         }
[10:26:24.698]                       }
[10:26:24.698]                       invisible(muffled)
[10:26:24.698]                     }
[10:26:24.698]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.698]                   }
[10:26:24.698]                 }
[10:26:24.698]             }
[10:26:24.698]         }))
[10:26:24.698]     }, error = function(ex) {
[10:26:24.698]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.698]                 ...future.rng), started = ...future.startTime, 
[10:26:24.698]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.698]             version = "1.8"), class = "FutureResult")
[10:26:24.698]     }, finally = {
[10:26:24.698]         if (!identical(...future.workdir, getwd())) 
[10:26:24.698]             setwd(...future.workdir)
[10:26:24.698]         {
[10:26:24.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.698]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.698]             }
[10:26:24.698]             base::options(...future.oldOptions)
[10:26:24.698]             if (.Platform$OS.type == "windows") {
[10:26:24.698]                 old_names <- names(...future.oldEnvVars)
[10:26:24.698]                 envs <- base::Sys.getenv()
[10:26:24.698]                 names <- names(envs)
[10:26:24.698]                 common <- intersect(names, old_names)
[10:26:24.698]                 added <- setdiff(names, old_names)
[10:26:24.698]                 removed <- setdiff(old_names, names)
[10:26:24.698]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.698]                   envs[common]]
[10:26:24.698]                 NAMES <- toupper(changed)
[10:26:24.698]                 args <- list()
[10:26:24.698]                 for (kk in seq_along(NAMES)) {
[10:26:24.698]                   name <- changed[[kk]]
[10:26:24.698]                   NAME <- NAMES[[kk]]
[10:26:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.698]                     next
[10:26:24.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.698]                 }
[10:26:24.698]                 NAMES <- toupper(added)
[10:26:24.698]                 for (kk in seq_along(NAMES)) {
[10:26:24.698]                   name <- added[[kk]]
[10:26:24.698]                   NAME <- NAMES[[kk]]
[10:26:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.698]                     next
[10:26:24.698]                   args[[name]] <- ""
[10:26:24.698]                 }
[10:26:24.698]                 NAMES <- toupper(removed)
[10:26:24.698]                 for (kk in seq_along(NAMES)) {
[10:26:24.698]                   name <- removed[[kk]]
[10:26:24.698]                   NAME <- NAMES[[kk]]
[10:26:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.698]                     next
[10:26:24.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.698]                 }
[10:26:24.698]                 if (length(args) > 0) 
[10:26:24.698]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.698]             }
[10:26:24.698]             else {
[10:26:24.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.698]             }
[10:26:24.698]             {
[10:26:24.698]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.698]                   0L) {
[10:26:24.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.698]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.698]                   base::options(opts)
[10:26:24.698]                 }
[10:26:24.698]                 {
[10:26:24.698]                   {
[10:26:24.698]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.698]                     NULL
[10:26:24.698]                   }
[10:26:24.698]                   options(future.plan = NULL)
[10:26:24.698]                   if (is.na(NA_character_)) 
[10:26:24.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.698]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.698]                     envir = parent.frame()) 
[10:26:24.698]                   {
[10:26:24.698]                     default_workers <- missing(workers)
[10:26:24.698]                     if (is.function(workers)) 
[10:26:24.698]                       workers <- workers()
[10:26:24.698]                     workers <- structure(as.integer(workers), 
[10:26:24.698]                       class = class(workers))
[10:26:24.698]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.698]                       1L)
[10:26:24.698]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.698]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.698]                       if (default_workers) 
[10:26:24.698]                         supportsMulticore(warn = TRUE)
[10:26:24.698]                       return(sequential(..., envir = envir))
[10:26:24.698]                     }
[10:26:24.698]                     oopts <- options(mc.cores = workers)
[10:26:24.698]                     on.exit(options(oopts))
[10:26:24.698]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.698]                       envir = envir)
[10:26:24.698]                     if (!future$lazy) 
[10:26:24.698]                       future <- run(future)
[10:26:24.698]                     invisible(future)
[10:26:24.698]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.698]                 }
[10:26:24.698]             }
[10:26:24.698]         }
[10:26:24.698]     })
[10:26:24.698]     if (TRUE) {
[10:26:24.698]         base::sink(type = "output", split = FALSE)
[10:26:24.698]         if (TRUE) {
[10:26:24.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.698]         }
[10:26:24.698]         else {
[10:26:24.698]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.698]         }
[10:26:24.698]         base::close(...future.stdout)
[10:26:24.698]         ...future.stdout <- NULL
[10:26:24.698]     }
[10:26:24.698]     ...future.result$conditions <- ...future.conditions
[10:26:24.698]     ...future.result$finished <- base::Sys.time()
[10:26:24.698]     ...future.result
[10:26:24.698] }
[10:26:24.701] assign_globals() ...
[10:26:24.701] List of 1
[10:26:24.701]  $ ii: int 1
[10:26:24.701]  - attr(*, "where")=List of 1
[10:26:24.701]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.701]  - attr(*, "resolved")= logi FALSE
[10:26:24.701]  - attr(*, "total_size")= num 56
[10:26:24.704] - copied ‘ii’ to environment
[10:26:24.704] assign_globals() ... done
[10:26:24.704] requestCore(): workers = 2
[10:26:24.706] MulticoreFuture started
 - Creating multicore future #2 ...
[10:26:24.707] plan(): Setting new future strategy stack:
[10:26:24.707] List of future strategies:
[10:26:24.707] 1. sequential:
[10:26:24.707]    - args: function (..., envir = parent.frame())
[10:26:24.707]    - tweaked: FALSE
[10:26:24.707]    - call: NULL
[10:26:24.708] plan(): nbrOfWorkers() = 1
[10:26:24.710] plan(): Setting new future strategy stack:
[10:26:24.710] List of future strategies:
[10:26:24.710] 1. multicore:
[10:26:24.710]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.710]    - tweaked: FALSE
[10:26:24.710]    - call: plan(multicore)
[10:26:24.711] getGlobalsAndPackages() ...
[10:26:24.711] Searching for globals...
[10:26:24.713] - globals found: [2] ‘{’, ‘ii’
[10:26:24.713] Searching for globals ... DONE
[10:26:24.713] Resolving globals: FALSE
[10:26:24.714] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.714] plan(): nbrOfWorkers() = 2
[10:26:24.714] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.714] - globals: [1] ‘ii’
[10:26:24.715] 
[10:26:24.715] getGlobalsAndPackages() ... DONE
[10:26:24.715] Packages needed by the future expression (n = 0): <none>
[10:26:24.716] Packages needed by future strategies (n = 0): <none>
[10:26:24.716] {
[10:26:24.716]     {
[10:26:24.716]         {
[10:26:24.716]             ...future.startTime <- base::Sys.time()
[10:26:24.716]             {
[10:26:24.716]                 {
[10:26:24.716]                   {
[10:26:24.716]                     {
[10:26:24.716]                       base::local({
[10:26:24.716]                         has_future <- base::requireNamespace("future", 
[10:26:24.716]                           quietly = TRUE)
[10:26:24.716]                         if (has_future) {
[10:26:24.716]                           ns <- base::getNamespace("future")
[10:26:24.716]                           version <- ns[[".package"]][["version"]]
[10:26:24.716]                           if (is.null(version)) 
[10:26:24.716]                             version <- utils::packageVersion("future")
[10:26:24.716]                         }
[10:26:24.716]                         else {
[10:26:24.716]                           version <- NULL
[10:26:24.716]                         }
[10:26:24.716]                         if (!has_future || version < "1.8.0") {
[10:26:24.716]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.716]                             "", base::R.version$version.string), 
[10:26:24.716]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.716]                               "release", "version")], collapse = " "), 
[10:26:24.716]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.716]                             info)
[10:26:24.716]                           info <- base::paste(info, collapse = "; ")
[10:26:24.716]                           if (!has_future) {
[10:26:24.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.716]                               info)
[10:26:24.716]                           }
[10:26:24.716]                           else {
[10:26:24.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.716]                               info, version)
[10:26:24.716]                           }
[10:26:24.716]                           base::stop(msg)
[10:26:24.716]                         }
[10:26:24.716]                       })
[10:26:24.716]                     }
[10:26:24.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.716]                     base::options(mc.cores = 1L)
[10:26:24.716]                   }
[10:26:24.716]                   options(future.plan = NULL)
[10:26:24.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.716]                 }
[10:26:24.716]                 ...future.workdir <- getwd()
[10:26:24.716]             }
[10:26:24.716]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.716]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.716]         }
[10:26:24.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.716]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.716]             base::names(...future.oldOptions))
[10:26:24.716]     }
[10:26:24.716]     if (FALSE) {
[10:26:24.716]     }
[10:26:24.716]     else {
[10:26:24.716]         if (TRUE) {
[10:26:24.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.716]                 open = "w")
[10:26:24.716]         }
[10:26:24.716]         else {
[10:26:24.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.716]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.716]         }
[10:26:24.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.716]             base::sink(type = "output", split = FALSE)
[10:26:24.716]             base::close(...future.stdout)
[10:26:24.716]         }, add = TRUE)
[10:26:24.716]     }
[10:26:24.716]     ...future.frame <- base::sys.nframe()
[10:26:24.716]     ...future.conditions <- base::list()
[10:26:24.716]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.716]     if (FALSE) {
[10:26:24.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.716]     }
[10:26:24.716]     ...future.result <- base::tryCatch({
[10:26:24.716]         base::withCallingHandlers({
[10:26:24.716]             ...future.value <- base::withVisible(base::local({
[10:26:24.716]                 withCallingHandlers({
[10:26:24.716]                   {
[10:26:24.716]                     ii
[10:26:24.716]                   }
[10:26:24.716]                 }, immediateCondition = function(cond) {
[10:26:24.716]                   save_rds <- function (object, pathname, ...) 
[10:26:24.716]                   {
[10:26:24.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.716]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.716]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.716]                         fi_tmp[["mtime"]])
[10:26:24.716]                     }
[10:26:24.716]                     tryCatch({
[10:26:24.716]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.716]                     }, error = function(ex) {
[10:26:24.716]                       msg <- conditionMessage(ex)
[10:26:24.716]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.716]                         fi_tmp[["mtime"]], msg)
[10:26:24.716]                       ex$message <- msg
[10:26:24.716]                       stop(ex)
[10:26:24.716]                     })
[10:26:24.716]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.716]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.716]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.716]                       fi <- file.info(pathname)
[10:26:24.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.716]                         fi[["size"]], fi[["mtime"]])
[10:26:24.716]                       stop(msg)
[10:26:24.716]                     }
[10:26:24.716]                     invisible(pathname)
[10:26:24.716]                   }
[10:26:24.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.716]                     rootPath = tempdir()) 
[10:26:24.716]                   {
[10:26:24.716]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.716]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.716]                       tmpdir = path, fileext = ".rds")
[10:26:24.716]                     save_rds(obj, file)
[10:26:24.716]                   }
[10:26:24.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.716]                   {
[10:26:24.716]                     inherits <- base::inherits
[10:26:24.716]                     invokeRestart <- base::invokeRestart
[10:26:24.716]                     is.null <- base::is.null
[10:26:24.716]                     muffled <- FALSE
[10:26:24.716]                     if (inherits(cond, "message")) {
[10:26:24.716]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.716]                       if (muffled) 
[10:26:24.716]                         invokeRestart("muffleMessage")
[10:26:24.716]                     }
[10:26:24.716]                     else if (inherits(cond, "warning")) {
[10:26:24.716]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.716]                       if (muffled) 
[10:26:24.716]                         invokeRestart("muffleWarning")
[10:26:24.716]                     }
[10:26:24.716]                     else if (inherits(cond, "condition")) {
[10:26:24.716]                       if (!is.null(pattern)) {
[10:26:24.716]                         computeRestarts <- base::computeRestarts
[10:26:24.716]                         grepl <- base::grepl
[10:26:24.716]                         restarts <- computeRestarts(cond)
[10:26:24.716]                         for (restart in restarts) {
[10:26:24.716]                           name <- restart$name
[10:26:24.716]                           if (is.null(name)) 
[10:26:24.716]                             next
[10:26:24.716]                           if (!grepl(pattern, name)) 
[10:26:24.716]                             next
[10:26:24.716]                           invokeRestart(restart)
[10:26:24.716]                           muffled <- TRUE
[10:26:24.716]                           break
[10:26:24.716]                         }
[10:26:24.716]                       }
[10:26:24.716]                     }
[10:26:24.716]                     invisible(muffled)
[10:26:24.716]                   }
[10:26:24.716]                   muffleCondition(cond)
[10:26:24.716]                 })
[10:26:24.716]             }))
[10:26:24.716]             future::FutureResult(value = ...future.value$value, 
[10:26:24.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.716]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.716]                     ...future.globalenv.names))
[10:26:24.716]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.716]         }, condition = base::local({
[10:26:24.716]             c <- base::c
[10:26:24.716]             inherits <- base::inherits
[10:26:24.716]             invokeRestart <- base::invokeRestart
[10:26:24.716]             length <- base::length
[10:26:24.716]             list <- base::list
[10:26:24.716]             seq.int <- base::seq.int
[10:26:24.716]             signalCondition <- base::signalCondition
[10:26:24.716]             sys.calls <- base::sys.calls
[10:26:24.716]             `[[` <- base::`[[`
[10:26:24.716]             `+` <- base::`+`
[10:26:24.716]             `<<-` <- base::`<<-`
[10:26:24.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.716]                   3L)]
[10:26:24.716]             }
[10:26:24.716]             function(cond) {
[10:26:24.716]                 is_error <- inherits(cond, "error")
[10:26:24.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.716]                   NULL)
[10:26:24.716]                 if (is_error) {
[10:26:24.716]                   sessionInformation <- function() {
[10:26:24.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.716]                       search = base::search(), system = base::Sys.info())
[10:26:24.716]                   }
[10:26:24.716]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.716]                     cond$call), session = sessionInformation(), 
[10:26:24.716]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.716]                   signalCondition(cond)
[10:26:24.716]                 }
[10:26:24.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.716]                 "immediateCondition"))) {
[10:26:24.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.716]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.716]                   if (TRUE && !signal) {
[10:26:24.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.716]                     {
[10:26:24.716]                       inherits <- base::inherits
[10:26:24.716]                       invokeRestart <- base::invokeRestart
[10:26:24.716]                       is.null <- base::is.null
[10:26:24.716]                       muffled <- FALSE
[10:26:24.716]                       if (inherits(cond, "message")) {
[10:26:24.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.716]                         if (muffled) 
[10:26:24.716]                           invokeRestart("muffleMessage")
[10:26:24.716]                       }
[10:26:24.716]                       else if (inherits(cond, "warning")) {
[10:26:24.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.716]                         if (muffled) 
[10:26:24.716]                           invokeRestart("muffleWarning")
[10:26:24.716]                       }
[10:26:24.716]                       else if (inherits(cond, "condition")) {
[10:26:24.716]                         if (!is.null(pattern)) {
[10:26:24.716]                           computeRestarts <- base::computeRestarts
[10:26:24.716]                           grepl <- base::grepl
[10:26:24.716]                           restarts <- computeRestarts(cond)
[10:26:24.716]                           for (restart in restarts) {
[10:26:24.716]                             name <- restart$name
[10:26:24.716]                             if (is.null(name)) 
[10:26:24.716]                               next
[10:26:24.716]                             if (!grepl(pattern, name)) 
[10:26:24.716]                               next
[10:26:24.716]                             invokeRestart(restart)
[10:26:24.716]                             muffled <- TRUE
[10:26:24.716]                             break
[10:26:24.716]                           }
[10:26:24.716]                         }
[10:26:24.716]                       }
[10:26:24.716]                       invisible(muffled)
[10:26:24.716]                     }
[10:26:24.716]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.716]                   }
[10:26:24.716]                 }
[10:26:24.716]                 else {
[10:26:24.716]                   if (TRUE) {
[10:26:24.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.716]                     {
[10:26:24.716]                       inherits <- base::inherits
[10:26:24.716]                       invokeRestart <- base::invokeRestart
[10:26:24.716]                       is.null <- base::is.null
[10:26:24.716]                       muffled <- FALSE
[10:26:24.716]                       if (inherits(cond, "message")) {
[10:26:24.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.716]                         if (muffled) 
[10:26:24.716]                           invokeRestart("muffleMessage")
[10:26:24.716]                       }
[10:26:24.716]                       else if (inherits(cond, "warning")) {
[10:26:24.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.716]                         if (muffled) 
[10:26:24.716]                           invokeRestart("muffleWarning")
[10:26:24.716]                       }
[10:26:24.716]                       else if (inherits(cond, "condition")) {
[10:26:24.716]                         if (!is.null(pattern)) {
[10:26:24.716]                           computeRestarts <- base::computeRestarts
[10:26:24.716]                           grepl <- base::grepl
[10:26:24.716]                           restarts <- computeRestarts(cond)
[10:26:24.716]                           for (restart in restarts) {
[10:26:24.716]                             name <- restart$name
[10:26:24.716]                             if (is.null(name)) 
[10:26:24.716]                               next
[10:26:24.716]                             if (!grepl(pattern, name)) 
[10:26:24.716]                               next
[10:26:24.716]                             invokeRestart(restart)
[10:26:24.716]                             muffled <- TRUE
[10:26:24.716]                             break
[10:26:24.716]                           }
[10:26:24.716]                         }
[10:26:24.716]                       }
[10:26:24.716]                       invisible(muffled)
[10:26:24.716]                     }
[10:26:24.716]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.716]                   }
[10:26:24.716]                 }
[10:26:24.716]             }
[10:26:24.716]         }))
[10:26:24.716]     }, error = function(ex) {
[10:26:24.716]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.716]                 ...future.rng), started = ...future.startTime, 
[10:26:24.716]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.716]             version = "1.8"), class = "FutureResult")
[10:26:24.716]     }, finally = {
[10:26:24.716]         if (!identical(...future.workdir, getwd())) 
[10:26:24.716]             setwd(...future.workdir)
[10:26:24.716]         {
[10:26:24.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.716]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.716]             }
[10:26:24.716]             base::options(...future.oldOptions)
[10:26:24.716]             if (.Platform$OS.type == "windows") {
[10:26:24.716]                 old_names <- names(...future.oldEnvVars)
[10:26:24.716]                 envs <- base::Sys.getenv()
[10:26:24.716]                 names <- names(envs)
[10:26:24.716]                 common <- intersect(names, old_names)
[10:26:24.716]                 added <- setdiff(names, old_names)
[10:26:24.716]                 removed <- setdiff(old_names, names)
[10:26:24.716]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.716]                   envs[common]]
[10:26:24.716]                 NAMES <- toupper(changed)
[10:26:24.716]                 args <- list()
[10:26:24.716]                 for (kk in seq_along(NAMES)) {
[10:26:24.716]                   name <- changed[[kk]]
[10:26:24.716]                   NAME <- NAMES[[kk]]
[10:26:24.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.716]                     next
[10:26:24.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.716]                 }
[10:26:24.716]                 NAMES <- toupper(added)
[10:26:24.716]                 for (kk in seq_along(NAMES)) {
[10:26:24.716]                   name <- added[[kk]]
[10:26:24.716]                   NAME <- NAMES[[kk]]
[10:26:24.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.716]                     next
[10:26:24.716]                   args[[name]] <- ""
[10:26:24.716]                 }
[10:26:24.716]                 NAMES <- toupper(removed)
[10:26:24.716]                 for (kk in seq_along(NAMES)) {
[10:26:24.716]                   name <- removed[[kk]]
[10:26:24.716]                   NAME <- NAMES[[kk]]
[10:26:24.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.716]                     next
[10:26:24.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.716]                 }
[10:26:24.716]                 if (length(args) > 0) 
[10:26:24.716]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.716]             }
[10:26:24.716]             else {
[10:26:24.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.716]             }
[10:26:24.716]             {
[10:26:24.716]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.716]                   0L) {
[10:26:24.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.716]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.716]                   base::options(opts)
[10:26:24.716]                 }
[10:26:24.716]                 {
[10:26:24.716]                   {
[10:26:24.716]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.716]                     NULL
[10:26:24.716]                   }
[10:26:24.716]                   options(future.plan = NULL)
[10:26:24.716]                   if (is.na(NA_character_)) 
[10:26:24.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.716]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.716]                     envir = parent.frame()) 
[10:26:24.716]                   {
[10:26:24.716]                     default_workers <- missing(workers)
[10:26:24.716]                     if (is.function(workers)) 
[10:26:24.716]                       workers <- workers()
[10:26:24.716]                     workers <- structure(as.integer(workers), 
[10:26:24.716]                       class = class(workers))
[10:26:24.716]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.716]                       1L)
[10:26:24.716]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.716]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.716]                       if (default_workers) 
[10:26:24.716]                         supportsMulticore(warn = TRUE)
[10:26:24.716]                       return(sequential(..., envir = envir))
[10:26:24.716]                     }
[10:26:24.716]                     oopts <- options(mc.cores = workers)
[10:26:24.716]                     on.exit(options(oopts))
[10:26:24.716]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.716]                       envir = envir)
[10:26:24.716]                     if (!future$lazy) 
[10:26:24.716]                       future <- run(future)
[10:26:24.716]                     invisible(future)
[10:26:24.716]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.716]                 }
[10:26:24.716]             }
[10:26:24.716]         }
[10:26:24.716]     })
[10:26:24.716]     if (TRUE) {
[10:26:24.716]         base::sink(type = "output", split = FALSE)
[10:26:24.716]         if (TRUE) {
[10:26:24.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.716]         }
[10:26:24.716]         else {
[10:26:24.716]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.716]         }
[10:26:24.716]         base::close(...future.stdout)
[10:26:24.716]         ...future.stdout <- NULL
[10:26:24.716]     }
[10:26:24.716]     ...future.result$conditions <- ...future.conditions
[10:26:24.716]     ...future.result$finished <- base::Sys.time()
[10:26:24.716]     ...future.result
[10:26:24.716] }
[10:26:24.720] assign_globals() ...
[10:26:24.720] List of 1
[10:26:24.720]  $ ii: int 2
[10:26:24.720]  - attr(*, "where")=List of 1
[10:26:24.720]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.720]  - attr(*, "resolved")= logi FALSE
[10:26:24.720]  - attr(*, "total_size")= num 56
[10:26:24.723] - copied ‘ii’ to environment
[10:26:24.724] assign_globals() ... done
[10:26:24.724] requestCore(): workers = 2
[10:26:24.726] MulticoreFuture started
 - Creating multicore future #3 ...
[10:26:24.727] plan(): Setting new future strategy stack:
[10:26:24.727] List of future strategies:
[10:26:24.727] 1. sequential:
[10:26:24.727]    - args: function (..., envir = parent.frame())
[10:26:24.727]    - tweaked: FALSE
[10:26:24.727]    - call: NULL
[10:26:24.728] plan(): nbrOfWorkers() = 1
[10:26:24.730] plan(): Setting new future strategy stack:
[10:26:24.730] List of future strategies:
[10:26:24.730] 1. multicore:
[10:26:24.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.730]    - tweaked: FALSE
[10:26:24.730]    - call: plan(multicore)
[10:26:24.731] getGlobalsAndPackages() ...
[10:26:24.732] Searching for globals...
[10:26:24.737] - globals found: [2] ‘{’, ‘ii’
[10:26:24.737] Searching for globals ... DONE
[10:26:24.738] Resolving globals: FALSE
[10:26:24.738] plan(): nbrOfWorkers() = 2
[10:26:24.738] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.739] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.739] - globals: [1] ‘ii’
[10:26:24.740] 
[10:26:24.740] getGlobalsAndPackages() ... DONE
[10:26:24.741] Packages needed by the future expression (n = 0): <none>
[10:26:24.741] Packages needed by future strategies (n = 0): <none>
[10:26:24.742] {
[10:26:24.742]     {
[10:26:24.742]         {
[10:26:24.742]             ...future.startTime <- base::Sys.time()
[10:26:24.742]             {
[10:26:24.742]                 {
[10:26:24.742]                   {
[10:26:24.742]                     {
[10:26:24.742]                       base::local({
[10:26:24.742]                         has_future <- base::requireNamespace("future", 
[10:26:24.742]                           quietly = TRUE)
[10:26:24.742]                         if (has_future) {
[10:26:24.742]                           ns <- base::getNamespace("future")
[10:26:24.742]                           version <- ns[[".package"]][["version"]]
[10:26:24.742]                           if (is.null(version)) 
[10:26:24.742]                             version <- utils::packageVersion("future")
[10:26:24.742]                         }
[10:26:24.742]                         else {
[10:26:24.742]                           version <- NULL
[10:26:24.742]                         }
[10:26:24.742]                         if (!has_future || version < "1.8.0") {
[10:26:24.742]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.742]                             "", base::R.version$version.string), 
[10:26:24.742]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.742]                               "release", "version")], collapse = " "), 
[10:26:24.742]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.742]                             info)
[10:26:24.742]                           info <- base::paste(info, collapse = "; ")
[10:26:24.742]                           if (!has_future) {
[10:26:24.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.742]                               info)
[10:26:24.742]                           }
[10:26:24.742]                           else {
[10:26:24.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.742]                               info, version)
[10:26:24.742]                           }
[10:26:24.742]                           base::stop(msg)
[10:26:24.742]                         }
[10:26:24.742]                       })
[10:26:24.742]                     }
[10:26:24.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.742]                     base::options(mc.cores = 1L)
[10:26:24.742]                   }
[10:26:24.742]                   options(future.plan = NULL)
[10:26:24.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.742]                 }
[10:26:24.742]                 ...future.workdir <- getwd()
[10:26:24.742]             }
[10:26:24.742]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.742]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.742]         }
[10:26:24.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.742]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.742]             base::names(...future.oldOptions))
[10:26:24.742]     }
[10:26:24.742]     if (FALSE) {
[10:26:24.742]     }
[10:26:24.742]     else {
[10:26:24.742]         if (TRUE) {
[10:26:24.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.742]                 open = "w")
[10:26:24.742]         }
[10:26:24.742]         else {
[10:26:24.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.742]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.742]         }
[10:26:24.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.742]             base::sink(type = "output", split = FALSE)
[10:26:24.742]             base::close(...future.stdout)
[10:26:24.742]         }, add = TRUE)
[10:26:24.742]     }
[10:26:24.742]     ...future.frame <- base::sys.nframe()
[10:26:24.742]     ...future.conditions <- base::list()
[10:26:24.742]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.742]     if (FALSE) {
[10:26:24.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.742]     }
[10:26:24.742]     ...future.result <- base::tryCatch({
[10:26:24.742]         base::withCallingHandlers({
[10:26:24.742]             ...future.value <- base::withVisible(base::local({
[10:26:24.742]                 withCallingHandlers({
[10:26:24.742]                   {
[10:26:24.742]                     ii
[10:26:24.742]                   }
[10:26:24.742]                 }, immediateCondition = function(cond) {
[10:26:24.742]                   save_rds <- function (object, pathname, ...) 
[10:26:24.742]                   {
[10:26:24.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.742]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.742]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.742]                         fi_tmp[["mtime"]])
[10:26:24.742]                     }
[10:26:24.742]                     tryCatch({
[10:26:24.742]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.742]                     }, error = function(ex) {
[10:26:24.742]                       msg <- conditionMessage(ex)
[10:26:24.742]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.742]                         fi_tmp[["mtime"]], msg)
[10:26:24.742]                       ex$message <- msg
[10:26:24.742]                       stop(ex)
[10:26:24.742]                     })
[10:26:24.742]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.742]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.742]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.742]                       fi <- file.info(pathname)
[10:26:24.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.742]                         fi[["size"]], fi[["mtime"]])
[10:26:24.742]                       stop(msg)
[10:26:24.742]                     }
[10:26:24.742]                     invisible(pathname)
[10:26:24.742]                   }
[10:26:24.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.742]                     rootPath = tempdir()) 
[10:26:24.742]                   {
[10:26:24.742]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.742]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.742]                       tmpdir = path, fileext = ".rds")
[10:26:24.742]                     save_rds(obj, file)
[10:26:24.742]                   }
[10:26:24.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.742]                   {
[10:26:24.742]                     inherits <- base::inherits
[10:26:24.742]                     invokeRestart <- base::invokeRestart
[10:26:24.742]                     is.null <- base::is.null
[10:26:24.742]                     muffled <- FALSE
[10:26:24.742]                     if (inherits(cond, "message")) {
[10:26:24.742]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.742]                       if (muffled) 
[10:26:24.742]                         invokeRestart("muffleMessage")
[10:26:24.742]                     }
[10:26:24.742]                     else if (inherits(cond, "warning")) {
[10:26:24.742]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.742]                       if (muffled) 
[10:26:24.742]                         invokeRestart("muffleWarning")
[10:26:24.742]                     }
[10:26:24.742]                     else if (inherits(cond, "condition")) {
[10:26:24.742]                       if (!is.null(pattern)) {
[10:26:24.742]                         computeRestarts <- base::computeRestarts
[10:26:24.742]                         grepl <- base::grepl
[10:26:24.742]                         restarts <- computeRestarts(cond)
[10:26:24.742]                         for (restart in restarts) {
[10:26:24.742]                           name <- restart$name
[10:26:24.742]                           if (is.null(name)) 
[10:26:24.742]                             next
[10:26:24.742]                           if (!grepl(pattern, name)) 
[10:26:24.742]                             next
[10:26:24.742]                           invokeRestart(restart)
[10:26:24.742]                           muffled <- TRUE
[10:26:24.742]                           break
[10:26:24.742]                         }
[10:26:24.742]                       }
[10:26:24.742]                     }
[10:26:24.742]                     invisible(muffled)
[10:26:24.742]                   }
[10:26:24.742]                   muffleCondition(cond)
[10:26:24.742]                 })
[10:26:24.742]             }))
[10:26:24.742]             future::FutureResult(value = ...future.value$value, 
[10:26:24.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.742]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.742]                     ...future.globalenv.names))
[10:26:24.742]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.742]         }, condition = base::local({
[10:26:24.742]             c <- base::c
[10:26:24.742]             inherits <- base::inherits
[10:26:24.742]             invokeRestart <- base::invokeRestart
[10:26:24.742]             length <- base::length
[10:26:24.742]             list <- base::list
[10:26:24.742]             seq.int <- base::seq.int
[10:26:24.742]             signalCondition <- base::signalCondition
[10:26:24.742]             sys.calls <- base::sys.calls
[10:26:24.742]             `[[` <- base::`[[`
[10:26:24.742]             `+` <- base::`+`
[10:26:24.742]             `<<-` <- base::`<<-`
[10:26:24.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.742]                   3L)]
[10:26:24.742]             }
[10:26:24.742]             function(cond) {
[10:26:24.742]                 is_error <- inherits(cond, "error")
[10:26:24.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.742]                   NULL)
[10:26:24.742]                 if (is_error) {
[10:26:24.742]                   sessionInformation <- function() {
[10:26:24.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.742]                       search = base::search(), system = base::Sys.info())
[10:26:24.742]                   }
[10:26:24.742]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.742]                     cond$call), session = sessionInformation(), 
[10:26:24.742]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.742]                   signalCondition(cond)
[10:26:24.742]                 }
[10:26:24.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.742]                 "immediateCondition"))) {
[10:26:24.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.742]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.742]                   if (TRUE && !signal) {
[10:26:24.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.742]                     {
[10:26:24.742]                       inherits <- base::inherits
[10:26:24.742]                       invokeRestart <- base::invokeRestart
[10:26:24.742]                       is.null <- base::is.null
[10:26:24.742]                       muffled <- FALSE
[10:26:24.742]                       if (inherits(cond, "message")) {
[10:26:24.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.742]                         if (muffled) 
[10:26:24.742]                           invokeRestart("muffleMessage")
[10:26:24.742]                       }
[10:26:24.742]                       else if (inherits(cond, "warning")) {
[10:26:24.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.742]                         if (muffled) 
[10:26:24.742]                           invokeRestart("muffleWarning")
[10:26:24.742]                       }
[10:26:24.742]                       else if (inherits(cond, "condition")) {
[10:26:24.742]                         if (!is.null(pattern)) {
[10:26:24.742]                           computeRestarts <- base::computeRestarts
[10:26:24.742]                           grepl <- base::grepl
[10:26:24.742]                           restarts <- computeRestarts(cond)
[10:26:24.742]                           for (restart in restarts) {
[10:26:24.742]                             name <- restart$name
[10:26:24.742]                             if (is.null(name)) 
[10:26:24.742]                               next
[10:26:24.742]                             if (!grepl(pattern, name)) 
[10:26:24.742]                               next
[10:26:24.742]                             invokeRestart(restart)
[10:26:24.742]                             muffled <- TRUE
[10:26:24.742]                             break
[10:26:24.742]                           }
[10:26:24.742]                         }
[10:26:24.742]                       }
[10:26:24.742]                       invisible(muffled)
[10:26:24.742]                     }
[10:26:24.742]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.742]                   }
[10:26:24.742]                 }
[10:26:24.742]                 else {
[10:26:24.742]                   if (TRUE) {
[10:26:24.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.742]                     {
[10:26:24.742]                       inherits <- base::inherits
[10:26:24.742]                       invokeRestart <- base::invokeRestart
[10:26:24.742]                       is.null <- base::is.null
[10:26:24.742]                       muffled <- FALSE
[10:26:24.742]                       if (inherits(cond, "message")) {
[10:26:24.742]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.742]                         if (muffled) 
[10:26:24.742]                           invokeRestart("muffleMessage")
[10:26:24.742]                       }
[10:26:24.742]                       else if (inherits(cond, "warning")) {
[10:26:24.742]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.742]                         if (muffled) 
[10:26:24.742]                           invokeRestart("muffleWarning")
[10:26:24.742]                       }
[10:26:24.742]                       else if (inherits(cond, "condition")) {
[10:26:24.742]                         if (!is.null(pattern)) {
[10:26:24.742]                           computeRestarts <- base::computeRestarts
[10:26:24.742]                           grepl <- base::grepl
[10:26:24.742]                           restarts <- computeRestarts(cond)
[10:26:24.742]                           for (restart in restarts) {
[10:26:24.742]                             name <- restart$name
[10:26:24.742]                             if (is.null(name)) 
[10:26:24.742]                               next
[10:26:24.742]                             if (!grepl(pattern, name)) 
[10:26:24.742]                               next
[10:26:24.742]                             invokeRestart(restart)
[10:26:24.742]                             muffled <- TRUE
[10:26:24.742]                             break
[10:26:24.742]                           }
[10:26:24.742]                         }
[10:26:24.742]                       }
[10:26:24.742]                       invisible(muffled)
[10:26:24.742]                     }
[10:26:24.742]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.742]                   }
[10:26:24.742]                 }
[10:26:24.742]             }
[10:26:24.742]         }))
[10:26:24.742]     }, error = function(ex) {
[10:26:24.742]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.742]                 ...future.rng), started = ...future.startTime, 
[10:26:24.742]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.742]             version = "1.8"), class = "FutureResult")
[10:26:24.742]     }, finally = {
[10:26:24.742]         if (!identical(...future.workdir, getwd())) 
[10:26:24.742]             setwd(...future.workdir)
[10:26:24.742]         {
[10:26:24.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.742]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.742]             }
[10:26:24.742]             base::options(...future.oldOptions)
[10:26:24.742]             if (.Platform$OS.type == "windows") {
[10:26:24.742]                 old_names <- names(...future.oldEnvVars)
[10:26:24.742]                 envs <- base::Sys.getenv()
[10:26:24.742]                 names <- names(envs)
[10:26:24.742]                 common <- intersect(names, old_names)
[10:26:24.742]                 added <- setdiff(names, old_names)
[10:26:24.742]                 removed <- setdiff(old_names, names)
[10:26:24.742]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.742]                   envs[common]]
[10:26:24.742]                 NAMES <- toupper(changed)
[10:26:24.742]                 args <- list()
[10:26:24.742]                 for (kk in seq_along(NAMES)) {
[10:26:24.742]                   name <- changed[[kk]]
[10:26:24.742]                   NAME <- NAMES[[kk]]
[10:26:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.742]                     next
[10:26:24.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.742]                 }
[10:26:24.742]                 NAMES <- toupper(added)
[10:26:24.742]                 for (kk in seq_along(NAMES)) {
[10:26:24.742]                   name <- added[[kk]]
[10:26:24.742]                   NAME <- NAMES[[kk]]
[10:26:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.742]                     next
[10:26:24.742]                   args[[name]] <- ""
[10:26:24.742]                 }
[10:26:24.742]                 NAMES <- toupper(removed)
[10:26:24.742]                 for (kk in seq_along(NAMES)) {
[10:26:24.742]                   name <- removed[[kk]]
[10:26:24.742]                   NAME <- NAMES[[kk]]
[10:26:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.742]                     next
[10:26:24.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.742]                 }
[10:26:24.742]                 if (length(args) > 0) 
[10:26:24.742]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.742]             }
[10:26:24.742]             else {
[10:26:24.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.742]             }
[10:26:24.742]             {
[10:26:24.742]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.742]                   0L) {
[10:26:24.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.742]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.742]                   base::options(opts)
[10:26:24.742]                 }
[10:26:24.742]                 {
[10:26:24.742]                   {
[10:26:24.742]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.742]                     NULL
[10:26:24.742]                   }
[10:26:24.742]                   options(future.plan = NULL)
[10:26:24.742]                   if (is.na(NA_character_)) 
[10:26:24.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.742]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.742]                     envir = parent.frame()) 
[10:26:24.742]                   {
[10:26:24.742]                     default_workers <- missing(workers)
[10:26:24.742]                     if (is.function(workers)) 
[10:26:24.742]                       workers <- workers()
[10:26:24.742]                     workers <- structure(as.integer(workers), 
[10:26:24.742]                       class = class(workers))
[10:26:24.742]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.742]                       1L)
[10:26:24.742]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.742]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.742]                       if (default_workers) 
[10:26:24.742]                         supportsMulticore(warn = TRUE)
[10:26:24.742]                       return(sequential(..., envir = envir))
[10:26:24.742]                     }
[10:26:24.742]                     oopts <- options(mc.cores = workers)
[10:26:24.742]                     on.exit(options(oopts))
[10:26:24.742]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.742]                       envir = envir)
[10:26:24.742]                     if (!future$lazy) 
[10:26:24.742]                       future <- run(future)
[10:26:24.742]                     invisible(future)
[10:26:24.742]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.742]                 }
[10:26:24.742]             }
[10:26:24.742]         }
[10:26:24.742]     })
[10:26:24.742]     if (TRUE) {
[10:26:24.742]         base::sink(type = "output", split = FALSE)
[10:26:24.742]         if (TRUE) {
[10:26:24.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.742]         }
[10:26:24.742]         else {
[10:26:24.742]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.742]         }
[10:26:24.742]         base::close(...future.stdout)
[10:26:24.742]         ...future.stdout <- NULL
[10:26:24.742]     }
[10:26:24.742]     ...future.result$conditions <- ...future.conditions
[10:26:24.742]     ...future.result$finished <- base::Sys.time()
[10:26:24.742]     ...future.result
[10:26:24.742] }
[10:26:24.745] assign_globals() ...
[10:26:24.745] List of 1
[10:26:24.745]  $ ii: int 3
[10:26:24.745]  - attr(*, "where")=List of 1
[10:26:24.745]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.745]  - attr(*, "resolved")= logi FALSE
[10:26:24.745]  - attr(*, "total_size")= num 56
[10:26:24.749] - copied ‘ii’ to environment
[10:26:24.749] assign_globals() ... done
[10:26:24.749] requestCore(): workers = 2
[10:26:24.749] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:24.760] result() for MulticoreFuture ...
[10:26:24.761] result() for MulticoreFuture ...
[10:26:24.761] result() for MulticoreFuture ... done
[10:26:24.761] result() for MulticoreFuture ... done
[10:26:24.761] result() for MulticoreFuture ...
[10:26:24.762] result() for MulticoreFuture ... done
[10:26:24.764] MulticoreFuture started
 - Creating multicore future #4 ...
[10:26:24.765] plan(): Setting new future strategy stack:
[10:26:24.766] List of future strategies:
[10:26:24.766] 1. sequential:
[10:26:24.766]    - args: function (..., envir = parent.frame())
[10:26:24.766]    - tweaked: FALSE
[10:26:24.766]    - call: NULL
[10:26:24.767] plan(): nbrOfWorkers() = 1
[10:26:24.769] plan(): Setting new future strategy stack:
[10:26:24.769] List of future strategies:
[10:26:24.769] 1. multicore:
[10:26:24.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.769]    - tweaked: FALSE
[10:26:24.769]    - call: plan(multicore)
[10:26:24.772] getGlobalsAndPackages() ...
[10:26:24.772] Searching for globals...
[10:26:24.774] - globals found: [2] ‘{’, ‘ii’
[10:26:24.774] Searching for globals ... DONE
[10:26:24.774] Resolving globals: FALSE
[10:26:24.775] The total size of the 1 globals is 56 bytes (56 bytes)
[10:26:24.775] plan(): nbrOfWorkers() = 2
[10:26:24.776] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[10:26:24.776] - globals: [1] ‘ii’
[10:26:24.776] 
[10:26:24.776] getGlobalsAndPackages() ... DONE
[10:26:24.777] Packages needed by the future expression (n = 0): <none>
[10:26:24.777] Packages needed by future strategies (n = 0): <none>
[10:26:24.778] {
[10:26:24.778]     {
[10:26:24.778]         {
[10:26:24.778]             ...future.startTime <- base::Sys.time()
[10:26:24.778]             {
[10:26:24.778]                 {
[10:26:24.778]                   {
[10:26:24.778]                     {
[10:26:24.778]                       base::local({
[10:26:24.778]                         has_future <- base::requireNamespace("future", 
[10:26:24.778]                           quietly = TRUE)
[10:26:24.778]                         if (has_future) {
[10:26:24.778]                           ns <- base::getNamespace("future")
[10:26:24.778]                           version <- ns[[".package"]][["version"]]
[10:26:24.778]                           if (is.null(version)) 
[10:26:24.778]                             version <- utils::packageVersion("future")
[10:26:24.778]                         }
[10:26:24.778]                         else {
[10:26:24.778]                           version <- NULL
[10:26:24.778]                         }
[10:26:24.778]                         if (!has_future || version < "1.8.0") {
[10:26:24.778]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.778]                             "", base::R.version$version.string), 
[10:26:24.778]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.778]                               "release", "version")], collapse = " "), 
[10:26:24.778]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.778]                             info)
[10:26:24.778]                           info <- base::paste(info, collapse = "; ")
[10:26:24.778]                           if (!has_future) {
[10:26:24.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.778]                               info)
[10:26:24.778]                           }
[10:26:24.778]                           else {
[10:26:24.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.778]                               info, version)
[10:26:24.778]                           }
[10:26:24.778]                           base::stop(msg)
[10:26:24.778]                         }
[10:26:24.778]                       })
[10:26:24.778]                     }
[10:26:24.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.778]                     base::options(mc.cores = 1L)
[10:26:24.778]                   }
[10:26:24.778]                   options(future.plan = NULL)
[10:26:24.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.778]                 }
[10:26:24.778]                 ...future.workdir <- getwd()
[10:26:24.778]             }
[10:26:24.778]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.778]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.778]         }
[10:26:24.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.778]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.778]             base::names(...future.oldOptions))
[10:26:24.778]     }
[10:26:24.778]     if (FALSE) {
[10:26:24.778]     }
[10:26:24.778]     else {
[10:26:24.778]         if (TRUE) {
[10:26:24.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.778]                 open = "w")
[10:26:24.778]         }
[10:26:24.778]         else {
[10:26:24.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.778]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.778]         }
[10:26:24.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.778]             base::sink(type = "output", split = FALSE)
[10:26:24.778]             base::close(...future.stdout)
[10:26:24.778]         }, add = TRUE)
[10:26:24.778]     }
[10:26:24.778]     ...future.frame <- base::sys.nframe()
[10:26:24.778]     ...future.conditions <- base::list()
[10:26:24.778]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.778]     if (FALSE) {
[10:26:24.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.778]     }
[10:26:24.778]     ...future.result <- base::tryCatch({
[10:26:24.778]         base::withCallingHandlers({
[10:26:24.778]             ...future.value <- base::withVisible(base::local({
[10:26:24.778]                 withCallingHandlers({
[10:26:24.778]                   {
[10:26:24.778]                     ii
[10:26:24.778]                   }
[10:26:24.778]                 }, immediateCondition = function(cond) {
[10:26:24.778]                   save_rds <- function (object, pathname, ...) 
[10:26:24.778]                   {
[10:26:24.778]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.778]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.778]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.778]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.778]                         fi_tmp[["mtime"]])
[10:26:24.778]                     }
[10:26:24.778]                     tryCatch({
[10:26:24.778]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.778]                     }, error = function(ex) {
[10:26:24.778]                       msg <- conditionMessage(ex)
[10:26:24.778]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.778]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.778]                         fi_tmp[["mtime"]], msg)
[10:26:24.778]                       ex$message <- msg
[10:26:24.778]                       stop(ex)
[10:26:24.778]                     })
[10:26:24.778]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.778]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.778]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.778]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.778]                       fi <- file.info(pathname)
[10:26:24.778]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.778]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.778]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.778]                         fi[["size"]], fi[["mtime"]])
[10:26:24.778]                       stop(msg)
[10:26:24.778]                     }
[10:26:24.778]                     invisible(pathname)
[10:26:24.778]                   }
[10:26:24.778]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.778]                     rootPath = tempdir()) 
[10:26:24.778]                   {
[10:26:24.778]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.778]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.778]                       tmpdir = path, fileext = ".rds")
[10:26:24.778]                     save_rds(obj, file)
[10:26:24.778]                   }
[10:26:24.778]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.778]                   {
[10:26:24.778]                     inherits <- base::inherits
[10:26:24.778]                     invokeRestart <- base::invokeRestart
[10:26:24.778]                     is.null <- base::is.null
[10:26:24.778]                     muffled <- FALSE
[10:26:24.778]                     if (inherits(cond, "message")) {
[10:26:24.778]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.778]                       if (muffled) 
[10:26:24.778]                         invokeRestart("muffleMessage")
[10:26:24.778]                     }
[10:26:24.778]                     else if (inherits(cond, "warning")) {
[10:26:24.778]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.778]                       if (muffled) 
[10:26:24.778]                         invokeRestart("muffleWarning")
[10:26:24.778]                     }
[10:26:24.778]                     else if (inherits(cond, "condition")) {
[10:26:24.778]                       if (!is.null(pattern)) {
[10:26:24.778]                         computeRestarts <- base::computeRestarts
[10:26:24.778]                         grepl <- base::grepl
[10:26:24.778]                         restarts <- computeRestarts(cond)
[10:26:24.778]                         for (restart in restarts) {
[10:26:24.778]                           name <- restart$name
[10:26:24.778]                           if (is.null(name)) 
[10:26:24.778]                             next
[10:26:24.778]                           if (!grepl(pattern, name)) 
[10:26:24.778]                             next
[10:26:24.778]                           invokeRestart(restart)
[10:26:24.778]                           muffled <- TRUE
[10:26:24.778]                           break
[10:26:24.778]                         }
[10:26:24.778]                       }
[10:26:24.778]                     }
[10:26:24.778]                     invisible(muffled)
[10:26:24.778]                   }
[10:26:24.778]                   muffleCondition(cond)
[10:26:24.778]                 })
[10:26:24.778]             }))
[10:26:24.778]             future::FutureResult(value = ...future.value$value, 
[10:26:24.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.778]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.778]                     ...future.globalenv.names))
[10:26:24.778]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.778]         }, condition = base::local({
[10:26:24.778]             c <- base::c
[10:26:24.778]             inherits <- base::inherits
[10:26:24.778]             invokeRestart <- base::invokeRestart
[10:26:24.778]             length <- base::length
[10:26:24.778]             list <- base::list
[10:26:24.778]             seq.int <- base::seq.int
[10:26:24.778]             signalCondition <- base::signalCondition
[10:26:24.778]             sys.calls <- base::sys.calls
[10:26:24.778]             `[[` <- base::`[[`
[10:26:24.778]             `+` <- base::`+`
[10:26:24.778]             `<<-` <- base::`<<-`
[10:26:24.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.778]                   3L)]
[10:26:24.778]             }
[10:26:24.778]             function(cond) {
[10:26:24.778]                 is_error <- inherits(cond, "error")
[10:26:24.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.778]                   NULL)
[10:26:24.778]                 if (is_error) {
[10:26:24.778]                   sessionInformation <- function() {
[10:26:24.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.778]                       search = base::search(), system = base::Sys.info())
[10:26:24.778]                   }
[10:26:24.778]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.778]                     cond$call), session = sessionInformation(), 
[10:26:24.778]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.778]                   signalCondition(cond)
[10:26:24.778]                 }
[10:26:24.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.778]                 "immediateCondition"))) {
[10:26:24.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.778]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.778]                   if (TRUE && !signal) {
[10:26:24.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.778]                     {
[10:26:24.778]                       inherits <- base::inherits
[10:26:24.778]                       invokeRestart <- base::invokeRestart
[10:26:24.778]                       is.null <- base::is.null
[10:26:24.778]                       muffled <- FALSE
[10:26:24.778]                       if (inherits(cond, "message")) {
[10:26:24.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.778]                         if (muffled) 
[10:26:24.778]                           invokeRestart("muffleMessage")
[10:26:24.778]                       }
[10:26:24.778]                       else if (inherits(cond, "warning")) {
[10:26:24.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.778]                         if (muffled) 
[10:26:24.778]                           invokeRestart("muffleWarning")
[10:26:24.778]                       }
[10:26:24.778]                       else if (inherits(cond, "condition")) {
[10:26:24.778]                         if (!is.null(pattern)) {
[10:26:24.778]                           computeRestarts <- base::computeRestarts
[10:26:24.778]                           grepl <- base::grepl
[10:26:24.778]                           restarts <- computeRestarts(cond)
[10:26:24.778]                           for (restart in restarts) {
[10:26:24.778]                             name <- restart$name
[10:26:24.778]                             if (is.null(name)) 
[10:26:24.778]                               next
[10:26:24.778]                             if (!grepl(pattern, name)) 
[10:26:24.778]                               next
[10:26:24.778]                             invokeRestart(restart)
[10:26:24.778]                             muffled <- TRUE
[10:26:24.778]                             break
[10:26:24.778]                           }
[10:26:24.778]                         }
[10:26:24.778]                       }
[10:26:24.778]                       invisible(muffled)
[10:26:24.778]                     }
[10:26:24.778]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.778]                   }
[10:26:24.778]                 }
[10:26:24.778]                 else {
[10:26:24.778]                   if (TRUE) {
[10:26:24.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.778]                     {
[10:26:24.778]                       inherits <- base::inherits
[10:26:24.778]                       invokeRestart <- base::invokeRestart
[10:26:24.778]                       is.null <- base::is.null
[10:26:24.778]                       muffled <- FALSE
[10:26:24.778]                       if (inherits(cond, "message")) {
[10:26:24.778]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.778]                         if (muffled) 
[10:26:24.778]                           invokeRestart("muffleMessage")
[10:26:24.778]                       }
[10:26:24.778]                       else if (inherits(cond, "warning")) {
[10:26:24.778]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.778]                         if (muffled) 
[10:26:24.778]                           invokeRestart("muffleWarning")
[10:26:24.778]                       }
[10:26:24.778]                       else if (inherits(cond, "condition")) {
[10:26:24.778]                         if (!is.null(pattern)) {
[10:26:24.778]                           computeRestarts <- base::computeRestarts
[10:26:24.778]                           grepl <- base::grepl
[10:26:24.778]                           restarts <- computeRestarts(cond)
[10:26:24.778]                           for (restart in restarts) {
[10:26:24.778]                             name <- restart$name
[10:26:24.778]                             if (is.null(name)) 
[10:26:24.778]                               next
[10:26:24.778]                             if (!grepl(pattern, name)) 
[10:26:24.778]                               next
[10:26:24.778]                             invokeRestart(restart)
[10:26:24.778]                             muffled <- TRUE
[10:26:24.778]                             break
[10:26:24.778]                           }
[10:26:24.778]                         }
[10:26:24.778]                       }
[10:26:24.778]                       invisible(muffled)
[10:26:24.778]                     }
[10:26:24.778]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.778]                   }
[10:26:24.778]                 }
[10:26:24.778]             }
[10:26:24.778]         }))
[10:26:24.778]     }, error = function(ex) {
[10:26:24.778]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.778]                 ...future.rng), started = ...future.startTime, 
[10:26:24.778]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.778]             version = "1.8"), class = "FutureResult")
[10:26:24.778]     }, finally = {
[10:26:24.778]         if (!identical(...future.workdir, getwd())) 
[10:26:24.778]             setwd(...future.workdir)
[10:26:24.778]         {
[10:26:24.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.778]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.778]             }
[10:26:24.778]             base::options(...future.oldOptions)
[10:26:24.778]             if (.Platform$OS.type == "windows") {
[10:26:24.778]                 old_names <- names(...future.oldEnvVars)
[10:26:24.778]                 envs <- base::Sys.getenv()
[10:26:24.778]                 names <- names(envs)
[10:26:24.778]                 common <- intersect(names, old_names)
[10:26:24.778]                 added <- setdiff(names, old_names)
[10:26:24.778]                 removed <- setdiff(old_names, names)
[10:26:24.778]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.778]                   envs[common]]
[10:26:24.778]                 NAMES <- toupper(changed)
[10:26:24.778]                 args <- list()
[10:26:24.778]                 for (kk in seq_along(NAMES)) {
[10:26:24.778]                   name <- changed[[kk]]
[10:26:24.778]                   NAME <- NAMES[[kk]]
[10:26:24.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.778]                     next
[10:26:24.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.778]                 }
[10:26:24.778]                 NAMES <- toupper(added)
[10:26:24.778]                 for (kk in seq_along(NAMES)) {
[10:26:24.778]                   name <- added[[kk]]
[10:26:24.778]                   NAME <- NAMES[[kk]]
[10:26:24.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.778]                     next
[10:26:24.778]                   args[[name]] <- ""
[10:26:24.778]                 }
[10:26:24.778]                 NAMES <- toupper(removed)
[10:26:24.778]                 for (kk in seq_along(NAMES)) {
[10:26:24.778]                   name <- removed[[kk]]
[10:26:24.778]                   NAME <- NAMES[[kk]]
[10:26:24.778]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.778]                     next
[10:26:24.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.778]                 }
[10:26:24.778]                 if (length(args) > 0) 
[10:26:24.778]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.778]             }
[10:26:24.778]             else {
[10:26:24.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.778]             }
[10:26:24.778]             {
[10:26:24.778]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.778]                   0L) {
[10:26:24.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.778]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.778]                   base::options(opts)
[10:26:24.778]                 }
[10:26:24.778]                 {
[10:26:24.778]                   {
[10:26:24.778]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.778]                     NULL
[10:26:24.778]                   }
[10:26:24.778]                   options(future.plan = NULL)
[10:26:24.778]                   if (is.na(NA_character_)) 
[10:26:24.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.778]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.778]                     envir = parent.frame()) 
[10:26:24.778]                   {
[10:26:24.778]                     default_workers <- missing(workers)
[10:26:24.778]                     if (is.function(workers)) 
[10:26:24.778]                       workers <- workers()
[10:26:24.778]                     workers <- structure(as.integer(workers), 
[10:26:24.778]                       class = class(workers))
[10:26:24.778]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.778]                       1L)
[10:26:24.778]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.778]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.778]                       if (default_workers) 
[10:26:24.778]                         supportsMulticore(warn = TRUE)
[10:26:24.778]                       return(sequential(..., envir = envir))
[10:26:24.778]                     }
[10:26:24.778]                     oopts <- options(mc.cores = workers)
[10:26:24.778]                     on.exit(options(oopts))
[10:26:24.778]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.778]                       envir = envir)
[10:26:24.778]                     if (!future$lazy) 
[10:26:24.778]                       future <- run(future)
[10:26:24.778]                     invisible(future)
[10:26:24.778]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.778]                 }
[10:26:24.778]             }
[10:26:24.778]         }
[10:26:24.778]     })
[10:26:24.778]     if (TRUE) {
[10:26:24.778]         base::sink(type = "output", split = FALSE)
[10:26:24.778]         if (TRUE) {
[10:26:24.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.778]         }
[10:26:24.778]         else {
[10:26:24.778]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.778]         }
[10:26:24.778]         base::close(...future.stdout)
[10:26:24.778]         ...future.stdout <- NULL
[10:26:24.778]     }
[10:26:24.778]     ...future.result$conditions <- ...future.conditions
[10:26:24.778]     ...future.result$finished <- base::Sys.time()
[10:26:24.778]     ...future.result
[10:26:24.778] }
[10:26:24.782] assign_globals() ...
[10:26:24.782] List of 1
[10:26:24.782]  $ ii: int 4
[10:26:24.782]  - attr(*, "where")=List of 1
[10:26:24.782]   ..$ ii:<environment: R_EmptyEnv> 
[10:26:24.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.782]  - attr(*, "resolved")= logi FALSE
[10:26:24.782]  - attr(*, "total_size")= num 56
[10:26:24.785] - copied ‘ii’ to environment
[10:26:24.786] assign_globals() ... done
[10:26:24.786] requestCore(): workers = 2
[10:26:24.786] Poll #1 (0): usedCores() = 2, workers = 2
[10:26:24.797] result() for MulticoreFuture ...
[10:26:24.798] result() for MulticoreFuture ...
[10:26:24.798] result() for MulticoreFuture ... done
[10:26:24.798] result() for MulticoreFuture ... done
[10:26:24.798] result() for MulticoreFuture ...
[10:26:24.798] result() for MulticoreFuture ... done
[10:26:24.801] MulticoreFuture started
 - Resolving 4 multicore futures
[10:26:24.802] result() for MulticoreFuture ...
[10:26:24.802] result() for MulticoreFuture ... done
[10:26:24.802] plan(): Setting new future strategy stack:
[10:26:24.802] result() for MulticoreFuture ...
[10:26:24.803] result() for MulticoreFuture ... done
[10:26:24.803] result() for MulticoreFuture ...
[10:26:24.803] result() for MulticoreFuture ... done
[10:26:24.802] List of future strategies:
[10:26:24.802] 1. sequential:
[10:26:24.802]    - args: function (..., envir = parent.frame())
[10:26:24.802]    - tweaked: FALSE
[10:26:24.802]    - call: NULL
[10:26:24.803] result() for MulticoreFuture ...
[10:26:24.803] plan(): nbrOfWorkers() = 1
[10:26:24.804] result() for MulticoreFuture ... done
[10:26:24.804] result() for MulticoreFuture ...
[10:26:24.806] result() for MulticoreFuture ...
[10:26:24.806] result() for MulticoreFuture ... done
[10:26:24.806] result() for MulticoreFuture ... done
[10:26:24.806] plan(): Setting new future strategy stack:
[10:26:24.806] result() for MulticoreFuture ...
[10:26:24.806] result() for MulticoreFuture ... done
[10:26:24.807] result() for MulticoreFuture ...
[10:26:24.806] List of future strategies:
[10:26:24.806] 1. multicore:
[10:26:24.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.806]    - tweaked: FALSE
[10:26:24.806]    - call: plan(multicore)
[10:26:24.811] plan(): nbrOfWorkers() = 2
[10:26:24.812] result() for MulticoreFuture ...
[10:26:24.812] result() for MulticoreFuture ... done
[10:26:24.812] result() for MulticoreFuture ... done
[10:26:24.812] result() for MulticoreFuture ...
[10:26:24.813] result() for MulticoreFuture ... done
*** multicore(..., globals = TRUE) and errors
[10:26:24.817] getGlobalsAndPackages() ...
[10:26:24.817] Searching for globals...
[10:26:24.818] - globals found: [2] ‘{’, ‘stop’
[10:26:24.818] Searching for globals ... DONE
[10:26:24.819] Resolving globals: FALSE
[10:26:24.822] 
[10:26:24.822] 
[10:26:24.822] getGlobalsAndPackages() ... DONE
[10:26:24.823] Packages needed by the future expression (n = 0): <none>
[10:26:24.823] Packages needed by future strategies (n = 0): <none>
[10:26:24.823] {
[10:26:24.823]     {
[10:26:24.823]         {
[10:26:24.823]             ...future.startTime <- base::Sys.time()
[10:26:24.823]             {
[10:26:24.823]                 {
[10:26:24.823]                   {
[10:26:24.823]                     {
[10:26:24.823]                       base::local({
[10:26:24.823]                         has_future <- base::requireNamespace("future", 
[10:26:24.823]                           quietly = TRUE)
[10:26:24.823]                         if (has_future) {
[10:26:24.823]                           ns <- base::getNamespace("future")
[10:26:24.823]                           version <- ns[[".package"]][["version"]]
[10:26:24.823]                           if (is.null(version)) 
[10:26:24.823]                             version <- utils::packageVersion("future")
[10:26:24.823]                         }
[10:26:24.823]                         else {
[10:26:24.823]                           version <- NULL
[10:26:24.823]                         }
[10:26:24.823]                         if (!has_future || version < "1.8.0") {
[10:26:24.823]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.823]                             "", base::R.version$version.string), 
[10:26:24.823]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.823]                               "release", "version")], collapse = " "), 
[10:26:24.823]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.823]                             info)
[10:26:24.823]                           info <- base::paste(info, collapse = "; ")
[10:26:24.823]                           if (!has_future) {
[10:26:24.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.823]                               info)
[10:26:24.823]                           }
[10:26:24.823]                           else {
[10:26:24.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.823]                               info, version)
[10:26:24.823]                           }
[10:26:24.823]                           base::stop(msg)
[10:26:24.823]                         }
[10:26:24.823]                       })
[10:26:24.823]                     }
[10:26:24.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.823]                     base::options(mc.cores = 1L)
[10:26:24.823]                   }
[10:26:24.823]                   options(future.plan = NULL)
[10:26:24.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.823]                 }
[10:26:24.823]                 ...future.workdir <- getwd()
[10:26:24.823]             }
[10:26:24.823]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.823]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.823]         }
[10:26:24.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.823]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.823]             base::names(...future.oldOptions))
[10:26:24.823]     }
[10:26:24.823]     if (FALSE) {
[10:26:24.823]     }
[10:26:24.823]     else {
[10:26:24.823]         if (TRUE) {
[10:26:24.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.823]                 open = "w")
[10:26:24.823]         }
[10:26:24.823]         else {
[10:26:24.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.823]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.823]         }
[10:26:24.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.823]             base::sink(type = "output", split = FALSE)
[10:26:24.823]             base::close(...future.stdout)
[10:26:24.823]         }, add = TRUE)
[10:26:24.823]     }
[10:26:24.823]     ...future.frame <- base::sys.nframe()
[10:26:24.823]     ...future.conditions <- base::list()
[10:26:24.823]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.823]     if (FALSE) {
[10:26:24.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.823]     }
[10:26:24.823]     ...future.result <- base::tryCatch({
[10:26:24.823]         base::withCallingHandlers({
[10:26:24.823]             ...future.value <- base::withVisible(base::local({
[10:26:24.823]                 withCallingHandlers({
[10:26:24.823]                   {
[10:26:24.823]                     stop("Whoops!")
[10:26:24.823]                     1
[10:26:24.823]                   }
[10:26:24.823]                 }, immediateCondition = function(cond) {
[10:26:24.823]                   save_rds <- function (object, pathname, ...) 
[10:26:24.823]                   {
[10:26:24.823]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.823]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.823]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.823]                         fi_tmp[["mtime"]])
[10:26:24.823]                     }
[10:26:24.823]                     tryCatch({
[10:26:24.823]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.823]                     }, error = function(ex) {
[10:26:24.823]                       msg <- conditionMessage(ex)
[10:26:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.823]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.823]                         fi_tmp[["mtime"]], msg)
[10:26:24.823]                       ex$message <- msg
[10:26:24.823]                       stop(ex)
[10:26:24.823]                     })
[10:26:24.823]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.823]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.823]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.823]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.823]                       fi <- file.info(pathname)
[10:26:24.823]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.823]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.823]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.823]                         fi[["size"]], fi[["mtime"]])
[10:26:24.823]                       stop(msg)
[10:26:24.823]                     }
[10:26:24.823]                     invisible(pathname)
[10:26:24.823]                   }
[10:26:24.823]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.823]                     rootPath = tempdir()) 
[10:26:24.823]                   {
[10:26:24.823]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.823]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.823]                       tmpdir = path, fileext = ".rds")
[10:26:24.823]                     save_rds(obj, file)
[10:26:24.823]                   }
[10:26:24.823]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.823]                   {
[10:26:24.823]                     inherits <- base::inherits
[10:26:24.823]                     invokeRestart <- base::invokeRestart
[10:26:24.823]                     is.null <- base::is.null
[10:26:24.823]                     muffled <- FALSE
[10:26:24.823]                     if (inherits(cond, "message")) {
[10:26:24.823]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.823]                       if (muffled) 
[10:26:24.823]                         invokeRestart("muffleMessage")
[10:26:24.823]                     }
[10:26:24.823]                     else if (inherits(cond, "warning")) {
[10:26:24.823]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.823]                       if (muffled) 
[10:26:24.823]                         invokeRestart("muffleWarning")
[10:26:24.823]                     }
[10:26:24.823]                     else if (inherits(cond, "condition")) {
[10:26:24.823]                       if (!is.null(pattern)) {
[10:26:24.823]                         computeRestarts <- base::computeRestarts
[10:26:24.823]                         grepl <- base::grepl
[10:26:24.823]                         restarts <- computeRestarts(cond)
[10:26:24.823]                         for (restart in restarts) {
[10:26:24.823]                           name <- restart$name
[10:26:24.823]                           if (is.null(name)) 
[10:26:24.823]                             next
[10:26:24.823]                           if (!grepl(pattern, name)) 
[10:26:24.823]                             next
[10:26:24.823]                           invokeRestart(restart)
[10:26:24.823]                           muffled <- TRUE
[10:26:24.823]                           break
[10:26:24.823]                         }
[10:26:24.823]                       }
[10:26:24.823]                     }
[10:26:24.823]                     invisible(muffled)
[10:26:24.823]                   }
[10:26:24.823]                   muffleCondition(cond)
[10:26:24.823]                 })
[10:26:24.823]             }))
[10:26:24.823]             future::FutureResult(value = ...future.value$value, 
[10:26:24.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.823]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.823]                     ...future.globalenv.names))
[10:26:24.823]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.823]         }, condition = base::local({
[10:26:24.823]             c <- base::c
[10:26:24.823]             inherits <- base::inherits
[10:26:24.823]             invokeRestart <- base::invokeRestart
[10:26:24.823]             length <- base::length
[10:26:24.823]             list <- base::list
[10:26:24.823]             seq.int <- base::seq.int
[10:26:24.823]             signalCondition <- base::signalCondition
[10:26:24.823]             sys.calls <- base::sys.calls
[10:26:24.823]             `[[` <- base::`[[`
[10:26:24.823]             `+` <- base::`+`
[10:26:24.823]             `<<-` <- base::`<<-`
[10:26:24.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.823]                   3L)]
[10:26:24.823]             }
[10:26:24.823]             function(cond) {
[10:26:24.823]                 is_error <- inherits(cond, "error")
[10:26:24.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.823]                   NULL)
[10:26:24.823]                 if (is_error) {
[10:26:24.823]                   sessionInformation <- function() {
[10:26:24.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.823]                       search = base::search(), system = base::Sys.info())
[10:26:24.823]                   }
[10:26:24.823]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.823]                     cond$call), session = sessionInformation(), 
[10:26:24.823]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.823]                   signalCondition(cond)
[10:26:24.823]                 }
[10:26:24.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.823]                 "immediateCondition"))) {
[10:26:24.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.823]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.823]                   if (TRUE && !signal) {
[10:26:24.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.823]                     {
[10:26:24.823]                       inherits <- base::inherits
[10:26:24.823]                       invokeRestart <- base::invokeRestart
[10:26:24.823]                       is.null <- base::is.null
[10:26:24.823]                       muffled <- FALSE
[10:26:24.823]                       if (inherits(cond, "message")) {
[10:26:24.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.823]                         if (muffled) 
[10:26:24.823]                           invokeRestart("muffleMessage")
[10:26:24.823]                       }
[10:26:24.823]                       else if (inherits(cond, "warning")) {
[10:26:24.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.823]                         if (muffled) 
[10:26:24.823]                           invokeRestart("muffleWarning")
[10:26:24.823]                       }
[10:26:24.823]                       else if (inherits(cond, "condition")) {
[10:26:24.823]                         if (!is.null(pattern)) {
[10:26:24.823]                           computeRestarts <- base::computeRestarts
[10:26:24.823]                           grepl <- base::grepl
[10:26:24.823]                           restarts <- computeRestarts(cond)
[10:26:24.823]                           for (restart in restarts) {
[10:26:24.823]                             name <- restart$name
[10:26:24.823]                             if (is.null(name)) 
[10:26:24.823]                               next
[10:26:24.823]                             if (!grepl(pattern, name)) 
[10:26:24.823]                               next
[10:26:24.823]                             invokeRestart(restart)
[10:26:24.823]                             muffled <- TRUE
[10:26:24.823]                             break
[10:26:24.823]                           }
[10:26:24.823]                         }
[10:26:24.823]                       }
[10:26:24.823]                       invisible(muffled)
[10:26:24.823]                     }
[10:26:24.823]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.823]                   }
[10:26:24.823]                 }
[10:26:24.823]                 else {
[10:26:24.823]                   if (TRUE) {
[10:26:24.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.823]                     {
[10:26:24.823]                       inherits <- base::inherits
[10:26:24.823]                       invokeRestart <- base::invokeRestart
[10:26:24.823]                       is.null <- base::is.null
[10:26:24.823]                       muffled <- FALSE
[10:26:24.823]                       if (inherits(cond, "message")) {
[10:26:24.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.823]                         if (muffled) 
[10:26:24.823]                           invokeRestart("muffleMessage")
[10:26:24.823]                       }
[10:26:24.823]                       else if (inherits(cond, "warning")) {
[10:26:24.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.823]                         if (muffled) 
[10:26:24.823]                           invokeRestart("muffleWarning")
[10:26:24.823]                       }
[10:26:24.823]                       else if (inherits(cond, "condition")) {
[10:26:24.823]                         if (!is.null(pattern)) {
[10:26:24.823]                           computeRestarts <- base::computeRestarts
[10:26:24.823]                           grepl <- base::grepl
[10:26:24.823]                           restarts <- computeRestarts(cond)
[10:26:24.823]                           for (restart in restarts) {
[10:26:24.823]                             name <- restart$name
[10:26:24.823]                             if (is.null(name)) 
[10:26:24.823]                               next
[10:26:24.823]                             if (!grepl(pattern, name)) 
[10:26:24.823]                               next
[10:26:24.823]                             invokeRestart(restart)
[10:26:24.823]                             muffled <- TRUE
[10:26:24.823]                             break
[10:26:24.823]                           }
[10:26:24.823]                         }
[10:26:24.823]                       }
[10:26:24.823]                       invisible(muffled)
[10:26:24.823]                     }
[10:26:24.823]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.823]                   }
[10:26:24.823]                 }
[10:26:24.823]             }
[10:26:24.823]         }))
[10:26:24.823]     }, error = function(ex) {
[10:26:24.823]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.823]                 ...future.rng), started = ...future.startTime, 
[10:26:24.823]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.823]             version = "1.8"), class = "FutureResult")
[10:26:24.823]     }, finally = {
[10:26:24.823]         if (!identical(...future.workdir, getwd())) 
[10:26:24.823]             setwd(...future.workdir)
[10:26:24.823]         {
[10:26:24.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.823]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.823]             }
[10:26:24.823]             base::options(...future.oldOptions)
[10:26:24.823]             if (.Platform$OS.type == "windows") {
[10:26:24.823]                 old_names <- names(...future.oldEnvVars)
[10:26:24.823]                 envs <- base::Sys.getenv()
[10:26:24.823]                 names <- names(envs)
[10:26:24.823]                 common <- intersect(names, old_names)
[10:26:24.823]                 added <- setdiff(names, old_names)
[10:26:24.823]                 removed <- setdiff(old_names, names)
[10:26:24.823]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.823]                   envs[common]]
[10:26:24.823]                 NAMES <- toupper(changed)
[10:26:24.823]                 args <- list()
[10:26:24.823]                 for (kk in seq_along(NAMES)) {
[10:26:24.823]                   name <- changed[[kk]]
[10:26:24.823]                   NAME <- NAMES[[kk]]
[10:26:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.823]                     next
[10:26:24.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.823]                 }
[10:26:24.823]                 NAMES <- toupper(added)
[10:26:24.823]                 for (kk in seq_along(NAMES)) {
[10:26:24.823]                   name <- added[[kk]]
[10:26:24.823]                   NAME <- NAMES[[kk]]
[10:26:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.823]                     next
[10:26:24.823]                   args[[name]] <- ""
[10:26:24.823]                 }
[10:26:24.823]                 NAMES <- toupper(removed)
[10:26:24.823]                 for (kk in seq_along(NAMES)) {
[10:26:24.823]                   name <- removed[[kk]]
[10:26:24.823]                   NAME <- NAMES[[kk]]
[10:26:24.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.823]                     next
[10:26:24.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.823]                 }
[10:26:24.823]                 if (length(args) > 0) 
[10:26:24.823]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.823]             }
[10:26:24.823]             else {
[10:26:24.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.823]             }
[10:26:24.823]             {
[10:26:24.823]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.823]                   0L) {
[10:26:24.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.823]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.823]                   base::options(opts)
[10:26:24.823]                 }
[10:26:24.823]                 {
[10:26:24.823]                   {
[10:26:24.823]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.823]                     NULL
[10:26:24.823]                   }
[10:26:24.823]                   options(future.plan = NULL)
[10:26:24.823]                   if (is.na(NA_character_)) 
[10:26:24.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.823]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.823]                     envir = parent.frame()) 
[10:26:24.823]                   {
[10:26:24.823]                     default_workers <- missing(workers)
[10:26:24.823]                     if (is.function(workers)) 
[10:26:24.823]                       workers <- workers()
[10:26:24.823]                     workers <- structure(as.integer(workers), 
[10:26:24.823]                       class = class(workers))
[10:26:24.823]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.823]                       1L)
[10:26:24.823]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.823]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.823]                       if (default_workers) 
[10:26:24.823]                         supportsMulticore(warn = TRUE)
[10:26:24.823]                       return(sequential(..., envir = envir))
[10:26:24.823]                     }
[10:26:24.823]                     oopts <- options(mc.cores = workers)
[10:26:24.823]                     on.exit(options(oopts))
[10:26:24.823]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.823]                       envir = envir)
[10:26:24.823]                     if (!future$lazy) 
[10:26:24.823]                       future <- run(future)
[10:26:24.823]                     invisible(future)
[10:26:24.823]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.823]                 }
[10:26:24.823]             }
[10:26:24.823]         }
[10:26:24.823]     })
[10:26:24.823]     if (TRUE) {
[10:26:24.823]         base::sink(type = "output", split = FALSE)
[10:26:24.823]         if (TRUE) {
[10:26:24.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.823]         }
[10:26:24.823]         else {
[10:26:24.823]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.823]         }
[10:26:24.823]         base::close(...future.stdout)
[10:26:24.823]         ...future.stdout <- NULL
[10:26:24.823]     }
[10:26:24.823]     ...future.result$conditions <- ...future.conditions
[10:26:24.823]     ...future.result$finished <- base::Sys.time()
[10:26:24.823]     ...future.result
[10:26:24.823] }
[10:26:24.826] requestCore(): workers = 2
[10:26:24.828] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.829] plan(): Setting new future strategy stack:
[10:26:24.829] List of future strategies:
[10:26:24.829] 1. sequential:
[10:26:24.829]    - args: function (..., envir = parent.frame())
[10:26:24.829]    - tweaked: FALSE
[10:26:24.829]    - call: NULL
[10:26:24.830] plan(): nbrOfWorkers() = 1
[10:26:24.832] plan(): Setting new future strategy stack:
[10:26:24.832] List of future strategies:
[10:26:24.832] 1. multicore:
[10:26:24.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.832]    - tweaked: FALSE
[10:26:24.832]    - call: plan(multicore)
[10:26:24.837] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.840] result() for MulticoreFuture ...
[10:26:24.843] result() for MulticoreFuture ...
[10:26:24.843] result() for MulticoreFuture ... done
[10:26:24.843] signalConditions() ...
[10:26:24.843]  - include = ‘immediateCondition’
[10:26:24.843]  - exclude = 
[10:26:24.843]  - resignal = FALSE
[10:26:24.843]  - Number of conditions: 1
[10:26:24.844] signalConditions() ... done
[10:26:24.844] result() for MulticoreFuture ... done
[10:26:24.844] result() for MulticoreFuture ...
[10:26:24.844] result() for MulticoreFuture ... done
[10:26:24.844] signalConditions() ...
[10:26:24.844]  - include = ‘immediateCondition’
[10:26:24.844]  - exclude = 
[10:26:24.844]  - resignal = FALSE
[10:26:24.845]  - Number of conditions: 1
[10:26:24.845] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.846] result() for MulticoreFuture ...
[10:26:24.846] result() for MulticoreFuture ... done
[10:26:24.846] result() for MulticoreFuture ...
[10:26:24.846] result() for MulticoreFuture ... done
[10:26:24.846] signalConditions() ...
[10:26:24.846]  - include = ‘immediateCondition’
[10:26:24.846]  - exclude = 
[10:26:24.846]  - resignal = FALSE
[10:26:24.846]  - Number of conditions: 1
[10:26:24.847] signalConditions() ... done
[10:26:24.847] Future state: ‘finished’
[10:26:24.847] result() for MulticoreFuture ...
[10:26:24.847] result() for MulticoreFuture ... done
[10:26:24.847] signalConditions() ...
[10:26:24.847]  - include = ‘condition’
[10:26:24.847]  - exclude = ‘immediateCondition’
[10:26:24.847]  - resignal = TRUE
[10:26:24.847]  - Number of conditions: 1
[10:26:24.848]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.848] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.849] result() for MulticoreFuture ...
[10:26:24.849] result() for MulticoreFuture ... done
[10:26:24.849] result() for MulticoreFuture ...
[10:26:24.849] result() for MulticoreFuture ... done
[10:26:24.849] signalConditions() ...
[10:26:24.849]  - include = ‘immediateCondition’
[10:26:24.849]  - exclude = 
[10:26:24.849]  - resignal = FALSE
[10:26:24.849]  - Number of conditions: 1
[10:26:24.850] signalConditions() ... done
[10:26:24.850] Future state: ‘finished’
[10:26:24.850] result() for MulticoreFuture ...
[10:26:24.850] result() for MulticoreFuture ... done
[10:26:24.850] signalConditions() ...
[10:26:24.850]  - include = ‘condition’
[10:26:24.850]  - exclude = ‘immediateCondition’
[10:26:24.850]  - resignal = TRUE
[10:26:24.850]  - Number of conditions: 1
[10:26:24.851]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:26:24.851] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:26:24.855] getGlobalsAndPackages() ...
[10:26:24.855] 
[10:26:24.856] - globals: [0] <none>
[10:26:24.856] getGlobalsAndPackages() ... DONE
[10:26:24.856] Packages needed by the future expression (n = 0): <none>
[10:26:24.856] Packages needed by future strategies (n = 0): <none>
[10:26:24.857] {
[10:26:24.857]     {
[10:26:24.857]         {
[10:26:24.857]             ...future.startTime <- base::Sys.time()
[10:26:24.857]             {
[10:26:24.857]                 {
[10:26:24.857]                   {
[10:26:24.857]                     {
[10:26:24.857]                       base::local({
[10:26:24.857]                         has_future <- base::requireNamespace("future", 
[10:26:24.857]                           quietly = TRUE)
[10:26:24.857]                         if (has_future) {
[10:26:24.857]                           ns <- base::getNamespace("future")
[10:26:24.857]                           version <- ns[[".package"]][["version"]]
[10:26:24.857]                           if (is.null(version)) 
[10:26:24.857]                             version <- utils::packageVersion("future")
[10:26:24.857]                         }
[10:26:24.857]                         else {
[10:26:24.857]                           version <- NULL
[10:26:24.857]                         }
[10:26:24.857]                         if (!has_future || version < "1.8.0") {
[10:26:24.857]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.857]                             "", base::R.version$version.string), 
[10:26:24.857]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:24.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.857]                               "release", "version")], collapse = " "), 
[10:26:24.857]                             hostname = base::Sys.info()[["nodename"]])
[10:26:24.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.857]                             info)
[10:26:24.857]                           info <- base::paste(info, collapse = "; ")
[10:26:24.857]                           if (!has_future) {
[10:26:24.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.857]                               info)
[10:26:24.857]                           }
[10:26:24.857]                           else {
[10:26:24.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.857]                               info, version)
[10:26:24.857]                           }
[10:26:24.857]                           base::stop(msg)
[10:26:24.857]                         }
[10:26:24.857]                       })
[10:26:24.857]                     }
[10:26:24.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:24.857]                     base::options(mc.cores = 1L)
[10:26:24.857]                   }
[10:26:24.857]                   options(future.plan = NULL)
[10:26:24.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.857]                 }
[10:26:24.857]                 ...future.workdir <- getwd()
[10:26:24.857]             }
[10:26:24.857]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.857]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.857]         }
[10:26:24.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.857]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.857]             base::names(...future.oldOptions))
[10:26:24.857]     }
[10:26:24.857]     if (FALSE) {
[10:26:24.857]     }
[10:26:24.857]     else {
[10:26:24.857]         if (TRUE) {
[10:26:24.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.857]                 open = "w")
[10:26:24.857]         }
[10:26:24.857]         else {
[10:26:24.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.857]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.857]         }
[10:26:24.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.857]             base::sink(type = "output", split = FALSE)
[10:26:24.857]             base::close(...future.stdout)
[10:26:24.857]         }, add = TRUE)
[10:26:24.857]     }
[10:26:24.857]     ...future.frame <- base::sys.nframe()
[10:26:24.857]     ...future.conditions <- base::list()
[10:26:24.857]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.857]     if (FALSE) {
[10:26:24.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.857]     }
[10:26:24.857]     ...future.result <- base::tryCatch({
[10:26:24.857]         base::withCallingHandlers({
[10:26:24.857]             ...future.value <- base::withVisible(base::local({
[10:26:24.857]                 withCallingHandlers({
[10:26:24.857]                   {
[10:26:24.857]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:26:24.857]                       "error", "condition")))
[10:26:24.857]                   }
[10:26:24.857]                 }, immediateCondition = function(cond) {
[10:26:24.857]                   save_rds <- function (object, pathname, ...) 
[10:26:24.857]                   {
[10:26:24.857]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:24.857]                     if (file_test("-f", pathname_tmp)) {
[10:26:24.857]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.857]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:24.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.857]                         fi_tmp[["mtime"]])
[10:26:24.857]                     }
[10:26:24.857]                     tryCatch({
[10:26:24.857]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:24.857]                     }, error = function(ex) {
[10:26:24.857]                       msg <- conditionMessage(ex)
[10:26:24.857]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.857]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:24.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.857]                         fi_tmp[["mtime"]], msg)
[10:26:24.857]                       ex$message <- msg
[10:26:24.857]                       stop(ex)
[10:26:24.857]                     })
[10:26:24.857]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:24.857]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:24.857]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:24.857]                       fi_tmp <- file.info(pathname_tmp)
[10:26:24.857]                       fi <- file.info(pathname)
[10:26:24.857]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:24.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:24.857]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:24.857]                         fi[["size"]], fi[["mtime"]])
[10:26:24.857]                       stop(msg)
[10:26:24.857]                     }
[10:26:24.857]                     invisible(pathname)
[10:26:24.857]                   }
[10:26:24.857]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:24.857]                     rootPath = tempdir()) 
[10:26:24.857]                   {
[10:26:24.857]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:24.857]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:24.857]                       tmpdir = path, fileext = ".rds")
[10:26:24.857]                     save_rds(obj, file)
[10:26:24.857]                   }
[10:26:24.857]                   saveImmediateCondition(cond, path = "/tmp/RtmpXUevyn/.future/immediateConditions")
[10:26:24.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.857]                   {
[10:26:24.857]                     inherits <- base::inherits
[10:26:24.857]                     invokeRestart <- base::invokeRestart
[10:26:24.857]                     is.null <- base::is.null
[10:26:24.857]                     muffled <- FALSE
[10:26:24.857]                     if (inherits(cond, "message")) {
[10:26:24.857]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:24.857]                       if (muffled) 
[10:26:24.857]                         invokeRestart("muffleMessage")
[10:26:24.857]                     }
[10:26:24.857]                     else if (inherits(cond, "warning")) {
[10:26:24.857]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:24.857]                       if (muffled) 
[10:26:24.857]                         invokeRestart("muffleWarning")
[10:26:24.857]                     }
[10:26:24.857]                     else if (inherits(cond, "condition")) {
[10:26:24.857]                       if (!is.null(pattern)) {
[10:26:24.857]                         computeRestarts <- base::computeRestarts
[10:26:24.857]                         grepl <- base::grepl
[10:26:24.857]                         restarts <- computeRestarts(cond)
[10:26:24.857]                         for (restart in restarts) {
[10:26:24.857]                           name <- restart$name
[10:26:24.857]                           if (is.null(name)) 
[10:26:24.857]                             next
[10:26:24.857]                           if (!grepl(pattern, name)) 
[10:26:24.857]                             next
[10:26:24.857]                           invokeRestart(restart)
[10:26:24.857]                           muffled <- TRUE
[10:26:24.857]                           break
[10:26:24.857]                         }
[10:26:24.857]                       }
[10:26:24.857]                     }
[10:26:24.857]                     invisible(muffled)
[10:26:24.857]                   }
[10:26:24.857]                   muffleCondition(cond)
[10:26:24.857]                 })
[10:26:24.857]             }))
[10:26:24.857]             future::FutureResult(value = ...future.value$value, 
[10:26:24.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.857]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.857]                     ...future.globalenv.names))
[10:26:24.857]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.857]         }, condition = base::local({
[10:26:24.857]             c <- base::c
[10:26:24.857]             inherits <- base::inherits
[10:26:24.857]             invokeRestart <- base::invokeRestart
[10:26:24.857]             length <- base::length
[10:26:24.857]             list <- base::list
[10:26:24.857]             seq.int <- base::seq.int
[10:26:24.857]             signalCondition <- base::signalCondition
[10:26:24.857]             sys.calls <- base::sys.calls
[10:26:24.857]             `[[` <- base::`[[`
[10:26:24.857]             `+` <- base::`+`
[10:26:24.857]             `<<-` <- base::`<<-`
[10:26:24.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.857]                   3L)]
[10:26:24.857]             }
[10:26:24.857]             function(cond) {
[10:26:24.857]                 is_error <- inherits(cond, "error")
[10:26:24.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.857]                   NULL)
[10:26:24.857]                 if (is_error) {
[10:26:24.857]                   sessionInformation <- function() {
[10:26:24.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.857]                       search = base::search(), system = base::Sys.info())
[10:26:24.857]                   }
[10:26:24.857]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.857]                     cond$call), session = sessionInformation(), 
[10:26:24.857]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.857]                   signalCondition(cond)
[10:26:24.857]                 }
[10:26:24.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.857]                 "immediateCondition"))) {
[10:26:24.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.857]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.857]                   if (TRUE && !signal) {
[10:26:24.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.857]                     {
[10:26:24.857]                       inherits <- base::inherits
[10:26:24.857]                       invokeRestart <- base::invokeRestart
[10:26:24.857]                       is.null <- base::is.null
[10:26:24.857]                       muffled <- FALSE
[10:26:24.857]                       if (inherits(cond, "message")) {
[10:26:24.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.857]                         if (muffled) 
[10:26:24.857]                           invokeRestart("muffleMessage")
[10:26:24.857]                       }
[10:26:24.857]                       else if (inherits(cond, "warning")) {
[10:26:24.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.857]                         if (muffled) 
[10:26:24.857]                           invokeRestart("muffleWarning")
[10:26:24.857]                       }
[10:26:24.857]                       else if (inherits(cond, "condition")) {
[10:26:24.857]                         if (!is.null(pattern)) {
[10:26:24.857]                           computeRestarts <- base::computeRestarts
[10:26:24.857]                           grepl <- base::grepl
[10:26:24.857]                           restarts <- computeRestarts(cond)
[10:26:24.857]                           for (restart in restarts) {
[10:26:24.857]                             name <- restart$name
[10:26:24.857]                             if (is.null(name)) 
[10:26:24.857]                               next
[10:26:24.857]                             if (!grepl(pattern, name)) 
[10:26:24.857]                               next
[10:26:24.857]                             invokeRestart(restart)
[10:26:24.857]                             muffled <- TRUE
[10:26:24.857]                             break
[10:26:24.857]                           }
[10:26:24.857]                         }
[10:26:24.857]                       }
[10:26:24.857]                       invisible(muffled)
[10:26:24.857]                     }
[10:26:24.857]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.857]                   }
[10:26:24.857]                 }
[10:26:24.857]                 else {
[10:26:24.857]                   if (TRUE) {
[10:26:24.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.857]                     {
[10:26:24.857]                       inherits <- base::inherits
[10:26:24.857]                       invokeRestart <- base::invokeRestart
[10:26:24.857]                       is.null <- base::is.null
[10:26:24.857]                       muffled <- FALSE
[10:26:24.857]                       if (inherits(cond, "message")) {
[10:26:24.857]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.857]                         if (muffled) 
[10:26:24.857]                           invokeRestart("muffleMessage")
[10:26:24.857]                       }
[10:26:24.857]                       else if (inherits(cond, "warning")) {
[10:26:24.857]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.857]                         if (muffled) 
[10:26:24.857]                           invokeRestart("muffleWarning")
[10:26:24.857]                       }
[10:26:24.857]                       else if (inherits(cond, "condition")) {
[10:26:24.857]                         if (!is.null(pattern)) {
[10:26:24.857]                           computeRestarts <- base::computeRestarts
[10:26:24.857]                           grepl <- base::grepl
[10:26:24.857]                           restarts <- computeRestarts(cond)
[10:26:24.857]                           for (restart in restarts) {
[10:26:24.857]                             name <- restart$name
[10:26:24.857]                             if (is.null(name)) 
[10:26:24.857]                               next
[10:26:24.857]                             if (!grepl(pattern, name)) 
[10:26:24.857]                               next
[10:26:24.857]                             invokeRestart(restart)
[10:26:24.857]                             muffled <- TRUE
[10:26:24.857]                             break
[10:26:24.857]                           }
[10:26:24.857]                         }
[10:26:24.857]                       }
[10:26:24.857]                       invisible(muffled)
[10:26:24.857]                     }
[10:26:24.857]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.857]                   }
[10:26:24.857]                 }
[10:26:24.857]             }
[10:26:24.857]         }))
[10:26:24.857]     }, error = function(ex) {
[10:26:24.857]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.857]                 ...future.rng), started = ...future.startTime, 
[10:26:24.857]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.857]             version = "1.8"), class = "FutureResult")
[10:26:24.857]     }, finally = {
[10:26:24.857]         if (!identical(...future.workdir, getwd())) 
[10:26:24.857]             setwd(...future.workdir)
[10:26:24.857]         {
[10:26:24.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.857]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.857]             }
[10:26:24.857]             base::options(...future.oldOptions)
[10:26:24.857]             if (.Platform$OS.type == "windows") {
[10:26:24.857]                 old_names <- names(...future.oldEnvVars)
[10:26:24.857]                 envs <- base::Sys.getenv()
[10:26:24.857]                 names <- names(envs)
[10:26:24.857]                 common <- intersect(names, old_names)
[10:26:24.857]                 added <- setdiff(names, old_names)
[10:26:24.857]                 removed <- setdiff(old_names, names)
[10:26:24.857]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.857]                   envs[common]]
[10:26:24.857]                 NAMES <- toupper(changed)
[10:26:24.857]                 args <- list()
[10:26:24.857]                 for (kk in seq_along(NAMES)) {
[10:26:24.857]                   name <- changed[[kk]]
[10:26:24.857]                   NAME <- NAMES[[kk]]
[10:26:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.857]                     next
[10:26:24.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.857]                 }
[10:26:24.857]                 NAMES <- toupper(added)
[10:26:24.857]                 for (kk in seq_along(NAMES)) {
[10:26:24.857]                   name <- added[[kk]]
[10:26:24.857]                   NAME <- NAMES[[kk]]
[10:26:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.857]                     next
[10:26:24.857]                   args[[name]] <- ""
[10:26:24.857]                 }
[10:26:24.857]                 NAMES <- toupper(removed)
[10:26:24.857]                 for (kk in seq_along(NAMES)) {
[10:26:24.857]                   name <- removed[[kk]]
[10:26:24.857]                   NAME <- NAMES[[kk]]
[10:26:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.857]                     next
[10:26:24.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.857]                 }
[10:26:24.857]                 if (length(args) > 0) 
[10:26:24.857]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.857]             }
[10:26:24.857]             else {
[10:26:24.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.857]             }
[10:26:24.857]             {
[10:26:24.857]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.857]                   0L) {
[10:26:24.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.857]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.857]                   base::options(opts)
[10:26:24.857]                 }
[10:26:24.857]                 {
[10:26:24.857]                   {
[10:26:24.857]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:24.857]                     NULL
[10:26:24.857]                   }
[10:26:24.857]                   options(future.plan = NULL)
[10:26:24.857]                   if (is.na(NA_character_)) 
[10:26:24.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.857]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.857]                     envir = parent.frame()) 
[10:26:24.857]                   {
[10:26:24.857]                     default_workers <- missing(workers)
[10:26:24.857]                     if (is.function(workers)) 
[10:26:24.857]                       workers <- workers()
[10:26:24.857]                     workers <- structure(as.integer(workers), 
[10:26:24.857]                       class = class(workers))
[10:26:24.857]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.857]                       1L)
[10:26:24.857]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.857]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.857]                       if (default_workers) 
[10:26:24.857]                         supportsMulticore(warn = TRUE)
[10:26:24.857]                       return(sequential(..., envir = envir))
[10:26:24.857]                     }
[10:26:24.857]                     oopts <- options(mc.cores = workers)
[10:26:24.857]                     on.exit(options(oopts))
[10:26:24.857]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.857]                       envir = envir)
[10:26:24.857]                     if (!future$lazy) 
[10:26:24.857]                       future <- run(future)
[10:26:24.857]                     invisible(future)
[10:26:24.857]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.857]                 }
[10:26:24.857]             }
[10:26:24.857]         }
[10:26:24.857]     })
[10:26:24.857]     if (TRUE) {
[10:26:24.857]         base::sink(type = "output", split = FALSE)
[10:26:24.857]         if (TRUE) {
[10:26:24.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.857]         }
[10:26:24.857]         else {
[10:26:24.857]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.857]         }
[10:26:24.857]         base::close(...future.stdout)
[10:26:24.857]         ...future.stdout <- NULL
[10:26:24.857]     }
[10:26:24.857]     ...future.result$conditions <- ...future.conditions
[10:26:24.857]     ...future.result$finished <- base::Sys.time()
[10:26:24.857]     ...future.result
[10:26:24.857] }
[10:26:24.860] requestCore(): workers = 2
[10:26:24.861] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:26:24.862] plan(): Setting new future strategy stack:
[10:26:24.863] List of future strategies:
[10:26:24.863] 1. sequential:
[10:26:24.863]    - args: function (..., envir = parent.frame())
[10:26:24.863]    - tweaked: FALSE
[10:26:24.863]    - call: NULL
[10:26:24.864] plan(): nbrOfWorkers() = 1
[10:26:24.865] plan(): Setting new future strategy stack:
[10:26:24.865] List of future strategies:
[10:26:24.865] 1. multicore:
[10:26:24.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.865]    - tweaked: FALSE
[10:26:24.865]    - call: plan(multicore)
[10:26:24.870] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 854e7b84-9758-5ebb-dd08-24fb0a48688e
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:24.873] result() for MulticoreFuture ...
[10:26:24.875] result() for MulticoreFuture ...
[10:26:24.875] result() for MulticoreFuture ... done
[10:26:24.875] signalConditions() ...
[10:26:24.876]  - include = ‘immediateCondition’
[10:26:24.876]  - exclude = 
[10:26:24.876]  - resignal = FALSE
[10:26:24.876]  - Number of conditions: 1
[10:26:24.876] signalConditions() ... done
[10:26:24.876] result() for MulticoreFuture ... done
[10:26:24.876] result() for MulticoreFuture ...
[10:26:24.876] result() for MulticoreFuture ... done
[10:26:24.876] signalConditions() ...
[10:26:24.877]  - include = ‘immediateCondition’
[10:26:24.877]  - exclude = 
[10:26:24.877]  - resignal = FALSE
[10:26:24.877]  - Number of conditions: 1
[10:26:24.877] signalConditions() ... done
<MyError: boom>
[10:26:24.877] result() for MulticoreFuture ...
[10:26:24.877] result() for MulticoreFuture ... done
[10:26:24.878] result() for MulticoreFuture ...
[10:26:24.878] result() for MulticoreFuture ... done
[10:26:24.878] signalConditions() ...
[10:26:24.878]  - include = ‘immediateCondition’
[10:26:24.878]  - exclude = 
[10:26:24.878]  - resignal = FALSE
[10:26:24.878]  - Number of conditions: 1
[10:26:24.878] signalConditions() ... done
[10:26:24.878] Future state: ‘finished’
[10:26:24.879] result() for MulticoreFuture ...
[10:26:24.879] result() for MulticoreFuture ... done
[10:26:24.879] signalConditions() ...
[10:26:24.879]  - include = ‘condition’
[10:26:24.879]  - exclude = ‘immediateCondition’
[10:26:24.879]  - resignal = TRUE
[10:26:24.879]  - Number of conditions: 1
[10:26:24.879]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:26:24.880] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[10:26:24.880] getGlobalsAndPackages() ...
[10:26:24.880] Searching for globals...
[10:26:24.881] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:26:24.881] Searching for globals ... DONE
[10:26:24.882] Resolving globals: FALSE
[10:26:24.882] The total size of the 2 globals is 112 bytes (112 bytes)
[10:26:24.886] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[10:26:24.886] - globals: [2] ‘a’, ‘b’
[10:26:24.886] 
[10:26:24.886] getGlobalsAndPackages() ... DONE
[10:26:24.887] Packages needed by the future expression (n = 0): <none>
[10:26:24.887] Packages needed by future strategies (n = 0): <none>
[10:26:24.888] {
[10:26:24.888]     {
[10:26:24.888]         {
[10:26:24.888]             ...future.startTime <- base::Sys.time()
[10:26:24.888]             {
[10:26:24.888]                 {
[10:26:24.888]                   {
[10:26:24.888]                     base::local({
[10:26:24.888]                       has_future <- base::requireNamespace("future", 
[10:26:24.888]                         quietly = TRUE)
[10:26:24.888]                       if (has_future) {
[10:26:24.888]                         ns <- base::getNamespace("future")
[10:26:24.888]                         version <- ns[[".package"]][["version"]]
[10:26:24.888]                         if (is.null(version)) 
[10:26:24.888]                           version <- utils::packageVersion("future")
[10:26:24.888]                       }
[10:26:24.888]                       else {
[10:26:24.888]                         version <- NULL
[10:26:24.888]                       }
[10:26:24.888]                       if (!has_future || version < "1.8.0") {
[10:26:24.888]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:24.888]                           "", base::R.version$version.string), 
[10:26:24.888]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:24.888]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:24.888]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:24.888]                             "release", "version")], collapse = " "), 
[10:26:24.888]                           hostname = base::Sys.info()[["nodename"]])
[10:26:24.888]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:24.888]                           info)
[10:26:24.888]                         info <- base::paste(info, collapse = "; ")
[10:26:24.888]                         if (!has_future) {
[10:26:24.888]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:24.888]                             info)
[10:26:24.888]                         }
[10:26:24.888]                         else {
[10:26:24.888]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:24.888]                             info, version)
[10:26:24.888]                         }
[10:26:24.888]                         base::stop(msg)
[10:26:24.888]                       }
[10:26:24.888]                     })
[10:26:24.888]                   }
[10:26:24.888]                   options(future.plan = NULL)
[10:26:24.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:24.888]                 }
[10:26:24.888]                 ...future.workdir <- getwd()
[10:26:24.888]             }
[10:26:24.888]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:24.888]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:24.888]         }
[10:26:24.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:24.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:24.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:24.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:24.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:24.888]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:24.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:24.888]             base::names(...future.oldOptions))
[10:26:24.888]     }
[10:26:24.888]     if (FALSE) {
[10:26:24.888]     }
[10:26:24.888]     else {
[10:26:24.888]         if (TRUE) {
[10:26:24.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:24.888]                 open = "w")
[10:26:24.888]         }
[10:26:24.888]         else {
[10:26:24.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:24.888]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:24.888]         }
[10:26:24.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:24.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:24.888]             base::sink(type = "output", split = FALSE)
[10:26:24.888]             base::close(...future.stdout)
[10:26:24.888]         }, add = TRUE)
[10:26:24.888]     }
[10:26:24.888]     ...future.frame <- base::sys.nframe()
[10:26:24.888]     ...future.conditions <- base::list()
[10:26:24.888]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:24.888]     if (FALSE) {
[10:26:24.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:24.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:24.888]     }
[10:26:24.888]     ...future.result <- base::tryCatch({
[10:26:24.888]         base::withCallingHandlers({
[10:26:24.888]             ...future.value <- base::withVisible(base::local({
[10:26:24.888]                 a * b
[10:26:24.888]             }))
[10:26:24.888]             future::FutureResult(value = ...future.value$value, 
[10:26:24.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.888]                   ...future.rng), globalenv = if (FALSE) 
[10:26:24.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:24.888]                     ...future.globalenv.names))
[10:26:24.888]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:24.888]         }, condition = base::local({
[10:26:24.888]             c <- base::c
[10:26:24.888]             inherits <- base::inherits
[10:26:24.888]             invokeRestart <- base::invokeRestart
[10:26:24.888]             length <- base::length
[10:26:24.888]             list <- base::list
[10:26:24.888]             seq.int <- base::seq.int
[10:26:24.888]             signalCondition <- base::signalCondition
[10:26:24.888]             sys.calls <- base::sys.calls
[10:26:24.888]             `[[` <- base::`[[`
[10:26:24.888]             `+` <- base::`+`
[10:26:24.888]             `<<-` <- base::`<<-`
[10:26:24.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:24.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:24.888]                   3L)]
[10:26:24.888]             }
[10:26:24.888]             function(cond) {
[10:26:24.888]                 is_error <- inherits(cond, "error")
[10:26:24.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:24.888]                   NULL)
[10:26:24.888]                 if (is_error) {
[10:26:24.888]                   sessionInformation <- function() {
[10:26:24.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:24.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:24.888]                       search = base::search(), system = base::Sys.info())
[10:26:24.888]                   }
[10:26:24.888]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:24.888]                     cond$call), session = sessionInformation(), 
[10:26:24.888]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:24.888]                   signalCondition(cond)
[10:26:24.888]                 }
[10:26:24.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:24.888]                 "immediateCondition"))) {
[10:26:24.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:24.888]                   ...future.conditions[[length(...future.conditions) + 
[10:26:24.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:24.888]                   if (TRUE && !signal) {
[10:26:24.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.888]                     {
[10:26:24.888]                       inherits <- base::inherits
[10:26:24.888]                       invokeRestart <- base::invokeRestart
[10:26:24.888]                       is.null <- base::is.null
[10:26:24.888]                       muffled <- FALSE
[10:26:24.888]                       if (inherits(cond, "message")) {
[10:26:24.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.888]                         if (muffled) 
[10:26:24.888]                           invokeRestart("muffleMessage")
[10:26:24.888]                       }
[10:26:24.888]                       else if (inherits(cond, "warning")) {
[10:26:24.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.888]                         if (muffled) 
[10:26:24.888]                           invokeRestart("muffleWarning")
[10:26:24.888]                       }
[10:26:24.888]                       else if (inherits(cond, "condition")) {
[10:26:24.888]                         if (!is.null(pattern)) {
[10:26:24.888]                           computeRestarts <- base::computeRestarts
[10:26:24.888]                           grepl <- base::grepl
[10:26:24.888]                           restarts <- computeRestarts(cond)
[10:26:24.888]                           for (restart in restarts) {
[10:26:24.888]                             name <- restart$name
[10:26:24.888]                             if (is.null(name)) 
[10:26:24.888]                               next
[10:26:24.888]                             if (!grepl(pattern, name)) 
[10:26:24.888]                               next
[10:26:24.888]                             invokeRestart(restart)
[10:26:24.888]                             muffled <- TRUE
[10:26:24.888]                             break
[10:26:24.888]                           }
[10:26:24.888]                         }
[10:26:24.888]                       }
[10:26:24.888]                       invisible(muffled)
[10:26:24.888]                     }
[10:26:24.888]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.888]                   }
[10:26:24.888]                 }
[10:26:24.888]                 else {
[10:26:24.888]                   if (TRUE) {
[10:26:24.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:24.888]                     {
[10:26:24.888]                       inherits <- base::inherits
[10:26:24.888]                       invokeRestart <- base::invokeRestart
[10:26:24.888]                       is.null <- base::is.null
[10:26:24.888]                       muffled <- FALSE
[10:26:24.888]                       if (inherits(cond, "message")) {
[10:26:24.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:24.888]                         if (muffled) 
[10:26:24.888]                           invokeRestart("muffleMessage")
[10:26:24.888]                       }
[10:26:24.888]                       else if (inherits(cond, "warning")) {
[10:26:24.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:24.888]                         if (muffled) 
[10:26:24.888]                           invokeRestart("muffleWarning")
[10:26:24.888]                       }
[10:26:24.888]                       else if (inherits(cond, "condition")) {
[10:26:24.888]                         if (!is.null(pattern)) {
[10:26:24.888]                           computeRestarts <- base::computeRestarts
[10:26:24.888]                           grepl <- base::grepl
[10:26:24.888]                           restarts <- computeRestarts(cond)
[10:26:24.888]                           for (restart in restarts) {
[10:26:24.888]                             name <- restart$name
[10:26:24.888]                             if (is.null(name)) 
[10:26:24.888]                               next
[10:26:24.888]                             if (!grepl(pattern, name)) 
[10:26:24.888]                               next
[10:26:24.888]                             invokeRestart(restart)
[10:26:24.888]                             muffled <- TRUE
[10:26:24.888]                             break
[10:26:24.888]                           }
[10:26:24.888]                         }
[10:26:24.888]                       }
[10:26:24.888]                       invisible(muffled)
[10:26:24.888]                     }
[10:26:24.888]                     muffleCondition(cond, pattern = "^muffle")
[10:26:24.888]                   }
[10:26:24.888]                 }
[10:26:24.888]             }
[10:26:24.888]         }))
[10:26:24.888]     }, error = function(ex) {
[10:26:24.888]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:24.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:24.888]                 ...future.rng), started = ...future.startTime, 
[10:26:24.888]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:24.888]             version = "1.8"), class = "FutureResult")
[10:26:24.888]     }, finally = {
[10:26:24.888]         if (!identical(...future.workdir, getwd())) 
[10:26:24.888]             setwd(...future.workdir)
[10:26:24.888]         {
[10:26:24.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:24.888]                 ...future.oldOptions$nwarnings <- NULL
[10:26:24.888]             }
[10:26:24.888]             base::options(...future.oldOptions)
[10:26:24.888]             if (.Platform$OS.type == "windows") {
[10:26:24.888]                 old_names <- names(...future.oldEnvVars)
[10:26:24.888]                 envs <- base::Sys.getenv()
[10:26:24.888]                 names <- names(envs)
[10:26:24.888]                 common <- intersect(names, old_names)
[10:26:24.888]                 added <- setdiff(names, old_names)
[10:26:24.888]                 removed <- setdiff(old_names, names)
[10:26:24.888]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:24.888]                   envs[common]]
[10:26:24.888]                 NAMES <- toupper(changed)
[10:26:24.888]                 args <- list()
[10:26:24.888]                 for (kk in seq_along(NAMES)) {
[10:26:24.888]                   name <- changed[[kk]]
[10:26:24.888]                   NAME <- NAMES[[kk]]
[10:26:24.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.888]                     next
[10:26:24.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.888]                 }
[10:26:24.888]                 NAMES <- toupper(added)
[10:26:24.888]                 for (kk in seq_along(NAMES)) {
[10:26:24.888]                   name <- added[[kk]]
[10:26:24.888]                   NAME <- NAMES[[kk]]
[10:26:24.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.888]                     next
[10:26:24.888]                   args[[name]] <- ""
[10:26:24.888]                 }
[10:26:24.888]                 NAMES <- toupper(removed)
[10:26:24.888]                 for (kk in seq_along(NAMES)) {
[10:26:24.888]                   name <- removed[[kk]]
[10:26:24.888]                   NAME <- NAMES[[kk]]
[10:26:24.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:24.888]                     next
[10:26:24.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:24.888]                 }
[10:26:24.888]                 if (length(args) > 0) 
[10:26:24.888]                   base::do.call(base::Sys.setenv, args = args)
[10:26:24.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:24.888]             }
[10:26:24.888]             else {
[10:26:24.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:24.888]             }
[10:26:24.888]             {
[10:26:24.888]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:24.888]                   0L) {
[10:26:24.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:24.888]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:24.888]                   base::options(opts)
[10:26:24.888]                 }
[10:26:24.888]                 {
[10:26:24.888]                   {
[10:26:24.888]                     NULL
[10:26:24.888]                     RNGkind("Mersenne-Twister")
[10:26:24.888]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:24.888]                       inherits = FALSE)
[10:26:24.888]                   }
[10:26:24.888]                   options(future.plan = NULL)
[10:26:24.888]                   if (is.na(NA_character_)) 
[10:26:24.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:24.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:24.888]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:26:24.888]                     envir = parent.frame()) 
[10:26:24.888]                   {
[10:26:24.888]                     default_workers <- missing(workers)
[10:26:24.888]                     if (is.function(workers)) 
[10:26:24.888]                       workers <- workers()
[10:26:24.888]                     workers <- structure(as.integer(workers), 
[10:26:24.888]                       class = class(workers))
[10:26:24.888]                     stop_if_not(is.finite(workers), workers >= 
[10:26:24.888]                       1L)
[10:26:24.888]                     if ((workers == 1L && !inherits(workers, 
[10:26:24.888]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:24.888]                       if (default_workers) 
[10:26:24.888]                         supportsMulticore(warn = TRUE)
[10:26:24.888]                       return(sequential(..., envir = envir))
[10:26:24.888]                     }
[10:26:24.888]                     oopts <- options(mc.cores = workers)
[10:26:24.888]                     on.exit(options(oopts))
[10:26:24.888]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:24.888]                       envir = envir)
[10:26:24.888]                     if (!future$lazy) 
[10:26:24.888]                       future <- run(future)
[10:26:24.888]                     invisible(future)
[10:26:24.888]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:24.888]                 }
[10:26:24.888]             }
[10:26:24.888]         }
[10:26:24.888]     })
[10:26:24.888]     if (TRUE) {
[10:26:24.888]         base::sink(type = "output", split = FALSE)
[10:26:24.888]         if (TRUE) {
[10:26:24.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:24.888]         }
[10:26:24.888]         else {
[10:26:24.888]             ...future.result["stdout"] <- base::list(NULL)
[10:26:24.888]         }
[10:26:24.888]         base::close(...future.stdout)
[10:26:24.888]         ...future.stdout <- NULL
[10:26:24.888]     }
[10:26:24.888]     ...future.result$conditions <- ...future.conditions
[10:26:24.888]     ...future.result$finished <- base::Sys.time()
[10:26:24.888]     ...future.result
[10:26:24.888] }
[10:26:24.890] assign_globals() ...
[10:26:24.890] List of 2
[10:26:24.890]  $ a: num 2
[10:26:24.890]  $ b: num 3
[10:26:24.890]  - attr(*, "where")=List of 2
[10:26:24.890]   ..$ a:<environment: R_EmptyEnv> 
[10:26:24.890]   ..$ b:<environment: R_EmptyEnv> 
[10:26:24.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:24.890]  - attr(*, "resolved")= logi FALSE
[10:26:24.890]  - attr(*, "total_size")= num 112
[10:26:24.893] - copied ‘a’ to environment
[10:26:24.893] - copied ‘b’ to environment
[10:26:24.894] assign_globals() ... done
[10:26:24.894] plan(): Setting new future strategy stack:
[10:26:24.894] List of future strategies:
[10:26:24.894] 1. sequential:
[10:26:24.894]    - args: function (..., envir = parent.frame())
[10:26:24.894]    - tweaked: FALSE
[10:26:24.894]    - call: NULL
[10:26:24.894] plan(): nbrOfWorkers() = 1
[10:26:24.895] plan(): Setting new future strategy stack:
[10:26:24.895] List of future strategies:
[10:26:24.895] 1. multicore:
[10:26:24.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:24.895]    - tweaked: FALSE
[10:26:24.895]    - call: plan(multicore)
[10:26:24.899] plan(): nbrOfWorkers() = 2
[10:26:24.899] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[10:26:24.900] plan(): Setting new future strategy stack:
[10:26:24.900] List of future strategies:
[10:26:24.900] 1. FutureStrategy:
[10:26:24.900]    - args: function (..., envir = parent.frame())
[10:26:24.900]    - tweaked: FALSE
[10:26:24.900]    - call: future::plan(oplan)
[10:26:24.901] plan(): nbrOfWorkers() = 1
> 
