
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:19.325] plan(): Setting new future strategy stack:
[16:05:19.326] List of future strategies:
[16:05:19.326] 1. sequential:
[16:05:19.326]    - args: function (..., envir = parent.frame())
[16:05:19.326]    - tweaked: FALSE
[16:05:19.326]    - call: future::plan("sequential")
[16:05:19.339] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[16:05:19.351] plan(): Setting new future strategy stack:
[16:05:19.351] List of future strategies:
[16:05:19.351] 1. multicore:
[16:05:19.351]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.351]    - tweaked: FALSE
[16:05:19.351]    - call: plan(multicore)
[16:05:19.365] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[16:05:19.421] getGlobalsAndPackages() ...
[16:05:19.421] Not searching for globals
[16:05:19.422] - globals: [0] <none>
[16:05:19.422] getGlobalsAndPackages() ... DONE
[16:05:19.423] Packages needed by the future expression (n = 0): <none>
[16:05:19.423] Packages needed by future strategies (n = 0): <none>
[16:05:19.424] {
[16:05:19.424]     {
[16:05:19.424]         {
[16:05:19.424]             ...future.startTime <- base::Sys.time()
[16:05:19.424]             {
[16:05:19.424]                 {
[16:05:19.424]                   {
[16:05:19.424]                     base::local({
[16:05:19.424]                       has_future <- base::requireNamespace("future", 
[16:05:19.424]                         quietly = TRUE)
[16:05:19.424]                       if (has_future) {
[16:05:19.424]                         ns <- base::getNamespace("future")
[16:05:19.424]                         version <- ns[[".package"]][["version"]]
[16:05:19.424]                         if (is.null(version)) 
[16:05:19.424]                           version <- utils::packageVersion("future")
[16:05:19.424]                       }
[16:05:19.424]                       else {
[16:05:19.424]                         version <- NULL
[16:05:19.424]                       }
[16:05:19.424]                       if (!has_future || version < "1.8.0") {
[16:05:19.424]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.424]                           "", base::R.version$version.string), 
[16:05:19.424]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.424]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.424]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.424]                             "release", "version")], collapse = " "), 
[16:05:19.424]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.424]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.424]                           info)
[16:05:19.424]                         info <- base::paste(info, collapse = "; ")
[16:05:19.424]                         if (!has_future) {
[16:05:19.424]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.424]                             info)
[16:05:19.424]                         }
[16:05:19.424]                         else {
[16:05:19.424]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.424]                             info, version)
[16:05:19.424]                         }
[16:05:19.424]                         base::stop(msg)
[16:05:19.424]                       }
[16:05:19.424]                     })
[16:05:19.424]                   }
[16:05:19.424]                   options(future.plan = NULL)
[16:05:19.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.424]                 }
[16:05:19.424]                 ...future.workdir <- getwd()
[16:05:19.424]             }
[16:05:19.424]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.424]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.424]         }
[16:05:19.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.424]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.424]             base::names(...future.oldOptions))
[16:05:19.424]     }
[16:05:19.424]     if (FALSE) {
[16:05:19.424]     }
[16:05:19.424]     else {
[16:05:19.424]         if (TRUE) {
[16:05:19.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.424]                 open = "w")
[16:05:19.424]         }
[16:05:19.424]         else {
[16:05:19.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.424]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.424]         }
[16:05:19.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.424]             base::sink(type = "output", split = FALSE)
[16:05:19.424]             base::close(...future.stdout)
[16:05:19.424]         }, add = TRUE)
[16:05:19.424]     }
[16:05:19.424]     ...future.frame <- base::sys.nframe()
[16:05:19.424]     ...future.conditions <- base::list()
[16:05:19.424]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.424]     if (FALSE) {
[16:05:19.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.424]     }
[16:05:19.424]     ...future.result <- base::tryCatch({
[16:05:19.424]         base::withCallingHandlers({
[16:05:19.424]             ...future.value <- base::withVisible(base::local({
[16:05:19.424]                 42L
[16:05:19.424]             }))
[16:05:19.424]             future::FutureResult(value = ...future.value$value, 
[16:05:19.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.424]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.424]                     ...future.globalenv.names))
[16:05:19.424]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.424]         }, condition = base::local({
[16:05:19.424]             c <- base::c
[16:05:19.424]             inherits <- base::inherits
[16:05:19.424]             invokeRestart <- base::invokeRestart
[16:05:19.424]             length <- base::length
[16:05:19.424]             list <- base::list
[16:05:19.424]             seq.int <- base::seq.int
[16:05:19.424]             signalCondition <- base::signalCondition
[16:05:19.424]             sys.calls <- base::sys.calls
[16:05:19.424]             `[[` <- base::`[[`
[16:05:19.424]             `+` <- base::`+`
[16:05:19.424]             `<<-` <- base::`<<-`
[16:05:19.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.424]                   3L)]
[16:05:19.424]             }
[16:05:19.424]             function(cond) {
[16:05:19.424]                 is_error <- inherits(cond, "error")
[16:05:19.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.424]                   NULL)
[16:05:19.424]                 if (is_error) {
[16:05:19.424]                   sessionInformation <- function() {
[16:05:19.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.424]                       search = base::search(), system = base::Sys.info())
[16:05:19.424]                   }
[16:05:19.424]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.424]                     cond$call), session = sessionInformation(), 
[16:05:19.424]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.424]                   signalCondition(cond)
[16:05:19.424]                 }
[16:05:19.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.424]                 "immediateCondition"))) {
[16:05:19.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.424]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.424]                   if (TRUE && !signal) {
[16:05:19.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.424]                     {
[16:05:19.424]                       inherits <- base::inherits
[16:05:19.424]                       invokeRestart <- base::invokeRestart
[16:05:19.424]                       is.null <- base::is.null
[16:05:19.424]                       muffled <- FALSE
[16:05:19.424]                       if (inherits(cond, "message")) {
[16:05:19.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.424]                         if (muffled) 
[16:05:19.424]                           invokeRestart("muffleMessage")
[16:05:19.424]                       }
[16:05:19.424]                       else if (inherits(cond, "warning")) {
[16:05:19.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.424]                         if (muffled) 
[16:05:19.424]                           invokeRestart("muffleWarning")
[16:05:19.424]                       }
[16:05:19.424]                       else if (inherits(cond, "condition")) {
[16:05:19.424]                         if (!is.null(pattern)) {
[16:05:19.424]                           computeRestarts <- base::computeRestarts
[16:05:19.424]                           grepl <- base::grepl
[16:05:19.424]                           restarts <- computeRestarts(cond)
[16:05:19.424]                           for (restart in restarts) {
[16:05:19.424]                             name <- restart$name
[16:05:19.424]                             if (is.null(name)) 
[16:05:19.424]                               next
[16:05:19.424]                             if (!grepl(pattern, name)) 
[16:05:19.424]                               next
[16:05:19.424]                             invokeRestart(restart)
[16:05:19.424]                             muffled <- TRUE
[16:05:19.424]                             break
[16:05:19.424]                           }
[16:05:19.424]                         }
[16:05:19.424]                       }
[16:05:19.424]                       invisible(muffled)
[16:05:19.424]                     }
[16:05:19.424]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.424]                   }
[16:05:19.424]                 }
[16:05:19.424]                 else {
[16:05:19.424]                   if (TRUE) {
[16:05:19.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.424]                     {
[16:05:19.424]                       inherits <- base::inherits
[16:05:19.424]                       invokeRestart <- base::invokeRestart
[16:05:19.424]                       is.null <- base::is.null
[16:05:19.424]                       muffled <- FALSE
[16:05:19.424]                       if (inherits(cond, "message")) {
[16:05:19.424]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.424]                         if (muffled) 
[16:05:19.424]                           invokeRestart("muffleMessage")
[16:05:19.424]                       }
[16:05:19.424]                       else if (inherits(cond, "warning")) {
[16:05:19.424]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.424]                         if (muffled) 
[16:05:19.424]                           invokeRestart("muffleWarning")
[16:05:19.424]                       }
[16:05:19.424]                       else if (inherits(cond, "condition")) {
[16:05:19.424]                         if (!is.null(pattern)) {
[16:05:19.424]                           computeRestarts <- base::computeRestarts
[16:05:19.424]                           grepl <- base::grepl
[16:05:19.424]                           restarts <- computeRestarts(cond)
[16:05:19.424]                           for (restart in restarts) {
[16:05:19.424]                             name <- restart$name
[16:05:19.424]                             if (is.null(name)) 
[16:05:19.424]                               next
[16:05:19.424]                             if (!grepl(pattern, name)) 
[16:05:19.424]                               next
[16:05:19.424]                             invokeRestart(restart)
[16:05:19.424]                             muffled <- TRUE
[16:05:19.424]                             break
[16:05:19.424]                           }
[16:05:19.424]                         }
[16:05:19.424]                       }
[16:05:19.424]                       invisible(muffled)
[16:05:19.424]                     }
[16:05:19.424]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.424]                   }
[16:05:19.424]                 }
[16:05:19.424]             }
[16:05:19.424]         }))
[16:05:19.424]     }, error = function(ex) {
[16:05:19.424]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.424]                 ...future.rng), started = ...future.startTime, 
[16:05:19.424]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.424]             version = "1.8"), class = "FutureResult")
[16:05:19.424]     }, finally = {
[16:05:19.424]         if (!identical(...future.workdir, getwd())) 
[16:05:19.424]             setwd(...future.workdir)
[16:05:19.424]         {
[16:05:19.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.424]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.424]             }
[16:05:19.424]             base::options(...future.oldOptions)
[16:05:19.424]             if (.Platform$OS.type == "windows") {
[16:05:19.424]                 old_names <- names(...future.oldEnvVars)
[16:05:19.424]                 envs <- base::Sys.getenv()
[16:05:19.424]                 names <- names(envs)
[16:05:19.424]                 common <- intersect(names, old_names)
[16:05:19.424]                 added <- setdiff(names, old_names)
[16:05:19.424]                 removed <- setdiff(old_names, names)
[16:05:19.424]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.424]                   envs[common]]
[16:05:19.424]                 NAMES <- toupper(changed)
[16:05:19.424]                 args <- list()
[16:05:19.424]                 for (kk in seq_along(NAMES)) {
[16:05:19.424]                   name <- changed[[kk]]
[16:05:19.424]                   NAME <- NAMES[[kk]]
[16:05:19.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.424]                     next
[16:05:19.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.424]                 }
[16:05:19.424]                 NAMES <- toupper(added)
[16:05:19.424]                 for (kk in seq_along(NAMES)) {
[16:05:19.424]                   name <- added[[kk]]
[16:05:19.424]                   NAME <- NAMES[[kk]]
[16:05:19.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.424]                     next
[16:05:19.424]                   args[[name]] <- ""
[16:05:19.424]                 }
[16:05:19.424]                 NAMES <- toupper(removed)
[16:05:19.424]                 for (kk in seq_along(NAMES)) {
[16:05:19.424]                   name <- removed[[kk]]
[16:05:19.424]                   NAME <- NAMES[[kk]]
[16:05:19.424]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.424]                     next
[16:05:19.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.424]                 }
[16:05:19.424]                 if (length(args) > 0) 
[16:05:19.424]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.424]             }
[16:05:19.424]             else {
[16:05:19.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.424]             }
[16:05:19.424]             {
[16:05:19.424]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.424]                   0L) {
[16:05:19.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.424]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.424]                   base::options(opts)
[16:05:19.424]                 }
[16:05:19.424]                 {
[16:05:19.424]                   {
[16:05:19.424]                     NULL
[16:05:19.424]                     RNGkind("Mersenne-Twister")
[16:05:19.424]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.424]                       inherits = FALSE)
[16:05:19.424]                   }
[16:05:19.424]                   options(future.plan = NULL)
[16:05:19.424]                   if (is.na(NA_character_)) 
[16:05:19.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.424]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.424]                     envir = parent.frame()) 
[16:05:19.424]                   {
[16:05:19.424]                     default_workers <- missing(workers)
[16:05:19.424]                     if (is.function(workers)) 
[16:05:19.424]                       workers <- workers()
[16:05:19.424]                     workers <- structure(as.integer(workers), 
[16:05:19.424]                       class = class(workers))
[16:05:19.424]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.424]                       1L)
[16:05:19.424]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.424]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.424]                       if (default_workers) 
[16:05:19.424]                         supportsMulticore(warn = TRUE)
[16:05:19.424]                       return(sequential(..., envir = envir))
[16:05:19.424]                     }
[16:05:19.424]                     oopts <- options(mc.cores = workers)
[16:05:19.424]                     on.exit(options(oopts))
[16:05:19.424]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.424]                       envir = envir)
[16:05:19.424]                     if (!future$lazy) 
[16:05:19.424]                       future <- run(future)
[16:05:19.424]                     invisible(future)
[16:05:19.424]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.424]                 }
[16:05:19.424]             }
[16:05:19.424]         }
[16:05:19.424]     })
[16:05:19.424]     if (TRUE) {
[16:05:19.424]         base::sink(type = "output", split = FALSE)
[16:05:19.424]         if (TRUE) {
[16:05:19.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.424]         }
[16:05:19.424]         else {
[16:05:19.424]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.424]         }
[16:05:19.424]         base::close(...future.stdout)
[16:05:19.424]         ...future.stdout <- NULL
[16:05:19.424]     }
[16:05:19.424]     ...future.result$conditions <- ...future.conditions
[16:05:19.424]     ...future.result$finished <- base::Sys.time()
[16:05:19.424]     ...future.result
[16:05:19.424] }
[16:05:19.426] plan(): Setting new future strategy stack:
[16:05:19.426] List of future strategies:
[16:05:19.426] 1. sequential:
[16:05:19.426]    - args: function (..., envir = parent.frame())
[16:05:19.426]    - tweaked: FALSE
[16:05:19.426]    - call: NULL
[16:05:19.426] plan(): nbrOfWorkers() = 1
[16:05:19.427] plan(): Setting new future strategy stack:
[16:05:19.427] List of future strategies:
[16:05:19.427] 1. multicore:
[16:05:19.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.427]    - tweaked: FALSE
[16:05:19.427]    - call: plan(multicore)
[16:05:19.431] plan(): nbrOfWorkers() = 1
[16:05:19.431] SequentialFuture started (and completed)
[16:05:19.432] resolved() for ‘SequentialFuture’ ...
[16:05:19.432] - state: ‘finished’
[16:05:19.432] - run: TRUE
[16:05:19.432] - result: ‘FutureResult’
[16:05:19.432] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[16:05:19.436] getGlobalsAndPackages() ...
[16:05:19.436] Not searching for globals
[16:05:19.436] - globals: [0] <none>
[16:05:19.436] getGlobalsAndPackages() ... DONE
[16:05:19.437] Packages needed by the future expression (n = 0): <none>
[16:05:19.437] Packages needed by future strategies (n = 0): <none>
[16:05:19.437] {
[16:05:19.437]     {
[16:05:19.437]         {
[16:05:19.437]             ...future.startTime <- base::Sys.time()
[16:05:19.437]             {
[16:05:19.437]                 {
[16:05:19.437]                   {
[16:05:19.437]                     base::local({
[16:05:19.437]                       has_future <- base::requireNamespace("future", 
[16:05:19.437]                         quietly = TRUE)
[16:05:19.437]                       if (has_future) {
[16:05:19.437]                         ns <- base::getNamespace("future")
[16:05:19.437]                         version <- ns[[".package"]][["version"]]
[16:05:19.437]                         if (is.null(version)) 
[16:05:19.437]                           version <- utils::packageVersion("future")
[16:05:19.437]                       }
[16:05:19.437]                       else {
[16:05:19.437]                         version <- NULL
[16:05:19.437]                       }
[16:05:19.437]                       if (!has_future || version < "1.8.0") {
[16:05:19.437]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.437]                           "", base::R.version$version.string), 
[16:05:19.437]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.437]                             "release", "version")], collapse = " "), 
[16:05:19.437]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.437]                           info)
[16:05:19.437]                         info <- base::paste(info, collapse = "; ")
[16:05:19.437]                         if (!has_future) {
[16:05:19.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.437]                             info)
[16:05:19.437]                         }
[16:05:19.437]                         else {
[16:05:19.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.437]                             info, version)
[16:05:19.437]                         }
[16:05:19.437]                         base::stop(msg)
[16:05:19.437]                       }
[16:05:19.437]                     })
[16:05:19.437]                   }
[16:05:19.437]                   options(future.plan = NULL)
[16:05:19.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.437]                 }
[16:05:19.437]                 ...future.workdir <- getwd()
[16:05:19.437]             }
[16:05:19.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.437]         }
[16:05:19.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.437]             base::names(...future.oldOptions))
[16:05:19.437]     }
[16:05:19.437]     if (FALSE) {
[16:05:19.437]     }
[16:05:19.437]     else {
[16:05:19.437]         if (TRUE) {
[16:05:19.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.437]                 open = "w")
[16:05:19.437]         }
[16:05:19.437]         else {
[16:05:19.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.437]         }
[16:05:19.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.437]             base::sink(type = "output", split = FALSE)
[16:05:19.437]             base::close(...future.stdout)
[16:05:19.437]         }, add = TRUE)
[16:05:19.437]     }
[16:05:19.437]     ...future.frame <- base::sys.nframe()
[16:05:19.437]     ...future.conditions <- base::list()
[16:05:19.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.437]     if (FALSE) {
[16:05:19.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.437]     }
[16:05:19.437]     ...future.result <- base::tryCatch({
[16:05:19.437]         base::withCallingHandlers({
[16:05:19.437]             ...future.value <- base::withVisible(base::local({
[16:05:19.437]                 b <- 3
[16:05:19.437]                 c <- 2
[16:05:19.437]                 a * b * c
[16:05:19.437]             }))
[16:05:19.437]             future::FutureResult(value = ...future.value$value, 
[16:05:19.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.437]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.437]                     ...future.globalenv.names))
[16:05:19.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.437]         }, condition = base::local({
[16:05:19.437]             c <- base::c
[16:05:19.437]             inherits <- base::inherits
[16:05:19.437]             invokeRestart <- base::invokeRestart
[16:05:19.437]             length <- base::length
[16:05:19.437]             list <- base::list
[16:05:19.437]             seq.int <- base::seq.int
[16:05:19.437]             signalCondition <- base::signalCondition
[16:05:19.437]             sys.calls <- base::sys.calls
[16:05:19.437]             `[[` <- base::`[[`
[16:05:19.437]             `+` <- base::`+`
[16:05:19.437]             `<<-` <- base::`<<-`
[16:05:19.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.437]                   3L)]
[16:05:19.437]             }
[16:05:19.437]             function(cond) {
[16:05:19.437]                 is_error <- inherits(cond, "error")
[16:05:19.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.437]                   NULL)
[16:05:19.437]                 if (is_error) {
[16:05:19.437]                   sessionInformation <- function() {
[16:05:19.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.437]                       search = base::search(), system = base::Sys.info())
[16:05:19.437]                   }
[16:05:19.437]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.437]                     cond$call), session = sessionInformation(), 
[16:05:19.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.437]                   signalCondition(cond)
[16:05:19.437]                 }
[16:05:19.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.437]                 "immediateCondition"))) {
[16:05:19.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.437]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.437]                   if (TRUE && !signal) {
[16:05:19.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.437]                     {
[16:05:19.437]                       inherits <- base::inherits
[16:05:19.437]                       invokeRestart <- base::invokeRestart
[16:05:19.437]                       is.null <- base::is.null
[16:05:19.437]                       muffled <- FALSE
[16:05:19.437]                       if (inherits(cond, "message")) {
[16:05:19.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.437]                         if (muffled) 
[16:05:19.437]                           invokeRestart("muffleMessage")
[16:05:19.437]                       }
[16:05:19.437]                       else if (inherits(cond, "warning")) {
[16:05:19.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.437]                         if (muffled) 
[16:05:19.437]                           invokeRestart("muffleWarning")
[16:05:19.437]                       }
[16:05:19.437]                       else if (inherits(cond, "condition")) {
[16:05:19.437]                         if (!is.null(pattern)) {
[16:05:19.437]                           computeRestarts <- base::computeRestarts
[16:05:19.437]                           grepl <- base::grepl
[16:05:19.437]                           restarts <- computeRestarts(cond)
[16:05:19.437]                           for (restart in restarts) {
[16:05:19.437]                             name <- restart$name
[16:05:19.437]                             if (is.null(name)) 
[16:05:19.437]                               next
[16:05:19.437]                             if (!grepl(pattern, name)) 
[16:05:19.437]                               next
[16:05:19.437]                             invokeRestart(restart)
[16:05:19.437]                             muffled <- TRUE
[16:05:19.437]                             break
[16:05:19.437]                           }
[16:05:19.437]                         }
[16:05:19.437]                       }
[16:05:19.437]                       invisible(muffled)
[16:05:19.437]                     }
[16:05:19.437]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.437]                   }
[16:05:19.437]                 }
[16:05:19.437]                 else {
[16:05:19.437]                   if (TRUE) {
[16:05:19.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.437]                     {
[16:05:19.437]                       inherits <- base::inherits
[16:05:19.437]                       invokeRestart <- base::invokeRestart
[16:05:19.437]                       is.null <- base::is.null
[16:05:19.437]                       muffled <- FALSE
[16:05:19.437]                       if (inherits(cond, "message")) {
[16:05:19.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.437]                         if (muffled) 
[16:05:19.437]                           invokeRestart("muffleMessage")
[16:05:19.437]                       }
[16:05:19.437]                       else if (inherits(cond, "warning")) {
[16:05:19.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.437]                         if (muffled) 
[16:05:19.437]                           invokeRestart("muffleWarning")
[16:05:19.437]                       }
[16:05:19.437]                       else if (inherits(cond, "condition")) {
[16:05:19.437]                         if (!is.null(pattern)) {
[16:05:19.437]                           computeRestarts <- base::computeRestarts
[16:05:19.437]                           grepl <- base::grepl
[16:05:19.437]                           restarts <- computeRestarts(cond)
[16:05:19.437]                           for (restart in restarts) {
[16:05:19.437]                             name <- restart$name
[16:05:19.437]                             if (is.null(name)) 
[16:05:19.437]                               next
[16:05:19.437]                             if (!grepl(pattern, name)) 
[16:05:19.437]                               next
[16:05:19.437]                             invokeRestart(restart)
[16:05:19.437]                             muffled <- TRUE
[16:05:19.437]                             break
[16:05:19.437]                           }
[16:05:19.437]                         }
[16:05:19.437]                       }
[16:05:19.437]                       invisible(muffled)
[16:05:19.437]                     }
[16:05:19.437]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.437]                   }
[16:05:19.437]                 }
[16:05:19.437]             }
[16:05:19.437]         }))
[16:05:19.437]     }, error = function(ex) {
[16:05:19.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.437]                 ...future.rng), started = ...future.startTime, 
[16:05:19.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.437]             version = "1.8"), class = "FutureResult")
[16:05:19.437]     }, finally = {
[16:05:19.437]         if (!identical(...future.workdir, getwd())) 
[16:05:19.437]             setwd(...future.workdir)
[16:05:19.437]         {
[16:05:19.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.437]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.437]             }
[16:05:19.437]             base::options(...future.oldOptions)
[16:05:19.437]             if (.Platform$OS.type == "windows") {
[16:05:19.437]                 old_names <- names(...future.oldEnvVars)
[16:05:19.437]                 envs <- base::Sys.getenv()
[16:05:19.437]                 names <- names(envs)
[16:05:19.437]                 common <- intersect(names, old_names)
[16:05:19.437]                 added <- setdiff(names, old_names)
[16:05:19.437]                 removed <- setdiff(old_names, names)
[16:05:19.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.437]                   envs[common]]
[16:05:19.437]                 NAMES <- toupper(changed)
[16:05:19.437]                 args <- list()
[16:05:19.437]                 for (kk in seq_along(NAMES)) {
[16:05:19.437]                   name <- changed[[kk]]
[16:05:19.437]                   NAME <- NAMES[[kk]]
[16:05:19.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.437]                     next
[16:05:19.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.437]                 }
[16:05:19.437]                 NAMES <- toupper(added)
[16:05:19.437]                 for (kk in seq_along(NAMES)) {
[16:05:19.437]                   name <- added[[kk]]
[16:05:19.437]                   NAME <- NAMES[[kk]]
[16:05:19.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.437]                     next
[16:05:19.437]                   args[[name]] <- ""
[16:05:19.437]                 }
[16:05:19.437]                 NAMES <- toupper(removed)
[16:05:19.437]                 for (kk in seq_along(NAMES)) {
[16:05:19.437]                   name <- removed[[kk]]
[16:05:19.437]                   NAME <- NAMES[[kk]]
[16:05:19.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.437]                     next
[16:05:19.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.437]                 }
[16:05:19.437]                 if (length(args) > 0) 
[16:05:19.437]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.437]             }
[16:05:19.437]             else {
[16:05:19.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.437]             }
[16:05:19.437]             {
[16:05:19.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.437]                   0L) {
[16:05:19.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.437]                   base::options(opts)
[16:05:19.437]                 }
[16:05:19.437]                 {
[16:05:19.437]                   {
[16:05:19.437]                     NULL
[16:05:19.437]                     RNGkind("Mersenne-Twister")
[16:05:19.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.437]                       inherits = FALSE)
[16:05:19.437]                   }
[16:05:19.437]                   options(future.plan = NULL)
[16:05:19.437]                   if (is.na(NA_character_)) 
[16:05:19.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.437]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.437]                     envir = parent.frame()) 
[16:05:19.437]                   {
[16:05:19.437]                     default_workers <- missing(workers)
[16:05:19.437]                     if (is.function(workers)) 
[16:05:19.437]                       workers <- workers()
[16:05:19.437]                     workers <- structure(as.integer(workers), 
[16:05:19.437]                       class = class(workers))
[16:05:19.437]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.437]                       1L)
[16:05:19.437]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.437]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.437]                       if (default_workers) 
[16:05:19.437]                         supportsMulticore(warn = TRUE)
[16:05:19.437]                       return(sequential(..., envir = envir))
[16:05:19.437]                     }
[16:05:19.437]                     oopts <- options(mc.cores = workers)
[16:05:19.437]                     on.exit(options(oopts))
[16:05:19.437]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.437]                       envir = envir)
[16:05:19.437]                     if (!future$lazy) 
[16:05:19.437]                       future <- run(future)
[16:05:19.437]                     invisible(future)
[16:05:19.437]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.437]                 }
[16:05:19.437]             }
[16:05:19.437]         }
[16:05:19.437]     })
[16:05:19.437]     if (TRUE) {
[16:05:19.437]         base::sink(type = "output", split = FALSE)
[16:05:19.437]         if (TRUE) {
[16:05:19.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.437]         }
[16:05:19.437]         else {
[16:05:19.437]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.437]         }
[16:05:19.437]         base::close(...future.stdout)
[16:05:19.437]         ...future.stdout <- NULL
[16:05:19.437]     }
[16:05:19.437]     ...future.result$conditions <- ...future.conditions
[16:05:19.437]     ...future.result$finished <- base::Sys.time()
[16:05:19.437]     ...future.result
[16:05:19.437] }
[16:05:19.439] plan(): Setting new future strategy stack:
[16:05:19.439] List of future strategies:
[16:05:19.439] 1. sequential:
[16:05:19.439]    - args: function (..., envir = parent.frame())
[16:05:19.439]    - tweaked: FALSE
[16:05:19.439]    - call: NULL
[16:05:19.439] plan(): nbrOfWorkers() = 1
[16:05:19.440] plan(): Setting new future strategy stack:
[16:05:19.440] List of future strategies:
[16:05:19.440] 1. multicore:
[16:05:19.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.440]    - tweaked: FALSE
[16:05:19.440]    - call: plan(multicore)
[16:05:19.444] plan(): nbrOfWorkers() = 1
[16:05:19.444] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[16:05:19.448] getGlobalsAndPackages() ...
[16:05:19.449] Not searching for globals
[16:05:19.449] - globals: [0] <none>
[16:05:19.449] getGlobalsAndPackages() ... DONE
[16:05:19.449] Packages needed by the future expression (n = 0): <none>
[16:05:19.449] Packages needed by future strategies (n = 0): <none>
[16:05:19.450] {
[16:05:19.450]     {
[16:05:19.450]         {
[16:05:19.450]             ...future.startTime <- base::Sys.time()
[16:05:19.450]             {
[16:05:19.450]                 {
[16:05:19.450]                   {
[16:05:19.450]                     base::local({
[16:05:19.450]                       has_future <- base::requireNamespace("future", 
[16:05:19.450]                         quietly = TRUE)
[16:05:19.450]                       if (has_future) {
[16:05:19.450]                         ns <- base::getNamespace("future")
[16:05:19.450]                         version <- ns[[".package"]][["version"]]
[16:05:19.450]                         if (is.null(version)) 
[16:05:19.450]                           version <- utils::packageVersion("future")
[16:05:19.450]                       }
[16:05:19.450]                       else {
[16:05:19.450]                         version <- NULL
[16:05:19.450]                       }
[16:05:19.450]                       if (!has_future || version < "1.8.0") {
[16:05:19.450]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.450]                           "", base::R.version$version.string), 
[16:05:19.450]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.450]                             "release", "version")], collapse = " "), 
[16:05:19.450]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.450]                           info)
[16:05:19.450]                         info <- base::paste(info, collapse = "; ")
[16:05:19.450]                         if (!has_future) {
[16:05:19.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.450]                             info)
[16:05:19.450]                         }
[16:05:19.450]                         else {
[16:05:19.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.450]                             info, version)
[16:05:19.450]                         }
[16:05:19.450]                         base::stop(msg)
[16:05:19.450]                       }
[16:05:19.450]                     })
[16:05:19.450]                   }
[16:05:19.450]                   options(future.plan = NULL)
[16:05:19.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.450]                 }
[16:05:19.450]                 ...future.workdir <- getwd()
[16:05:19.450]             }
[16:05:19.450]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.450]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.450]         }
[16:05:19.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.450]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.450]             base::names(...future.oldOptions))
[16:05:19.450]     }
[16:05:19.450]     if (FALSE) {
[16:05:19.450]     }
[16:05:19.450]     else {
[16:05:19.450]         if (TRUE) {
[16:05:19.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.450]                 open = "w")
[16:05:19.450]         }
[16:05:19.450]         else {
[16:05:19.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.450]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.450]         }
[16:05:19.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.450]             base::sink(type = "output", split = FALSE)
[16:05:19.450]             base::close(...future.stdout)
[16:05:19.450]         }, add = TRUE)
[16:05:19.450]     }
[16:05:19.450]     ...future.frame <- base::sys.nframe()
[16:05:19.450]     ...future.conditions <- base::list()
[16:05:19.450]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.450]     if (FALSE) {
[16:05:19.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.450]     }
[16:05:19.450]     ...future.result <- base::tryCatch({
[16:05:19.450]         base::withCallingHandlers({
[16:05:19.450]             ...future.value <- base::withVisible(base::local({
[16:05:19.450]                 ii
[16:05:19.450]             }))
[16:05:19.450]             future::FutureResult(value = ...future.value$value, 
[16:05:19.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.450]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.450]                     ...future.globalenv.names))
[16:05:19.450]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.450]         }, condition = base::local({
[16:05:19.450]             c <- base::c
[16:05:19.450]             inherits <- base::inherits
[16:05:19.450]             invokeRestart <- base::invokeRestart
[16:05:19.450]             length <- base::length
[16:05:19.450]             list <- base::list
[16:05:19.450]             seq.int <- base::seq.int
[16:05:19.450]             signalCondition <- base::signalCondition
[16:05:19.450]             sys.calls <- base::sys.calls
[16:05:19.450]             `[[` <- base::`[[`
[16:05:19.450]             `+` <- base::`+`
[16:05:19.450]             `<<-` <- base::`<<-`
[16:05:19.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.450]                   3L)]
[16:05:19.450]             }
[16:05:19.450]             function(cond) {
[16:05:19.450]                 is_error <- inherits(cond, "error")
[16:05:19.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.450]                   NULL)
[16:05:19.450]                 if (is_error) {
[16:05:19.450]                   sessionInformation <- function() {
[16:05:19.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.450]                       search = base::search(), system = base::Sys.info())
[16:05:19.450]                   }
[16:05:19.450]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.450]                     cond$call), session = sessionInformation(), 
[16:05:19.450]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.450]                   signalCondition(cond)
[16:05:19.450]                 }
[16:05:19.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.450]                 "immediateCondition"))) {
[16:05:19.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.450]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.450]                   if (TRUE && !signal) {
[16:05:19.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.450]                     {
[16:05:19.450]                       inherits <- base::inherits
[16:05:19.450]                       invokeRestart <- base::invokeRestart
[16:05:19.450]                       is.null <- base::is.null
[16:05:19.450]                       muffled <- FALSE
[16:05:19.450]                       if (inherits(cond, "message")) {
[16:05:19.450]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.450]                         if (muffled) 
[16:05:19.450]                           invokeRestart("muffleMessage")
[16:05:19.450]                       }
[16:05:19.450]                       else if (inherits(cond, "warning")) {
[16:05:19.450]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.450]                         if (muffled) 
[16:05:19.450]                           invokeRestart("muffleWarning")
[16:05:19.450]                       }
[16:05:19.450]                       else if (inherits(cond, "condition")) {
[16:05:19.450]                         if (!is.null(pattern)) {
[16:05:19.450]                           computeRestarts <- base::computeRestarts
[16:05:19.450]                           grepl <- base::grepl
[16:05:19.450]                           restarts <- computeRestarts(cond)
[16:05:19.450]                           for (restart in restarts) {
[16:05:19.450]                             name <- restart$name
[16:05:19.450]                             if (is.null(name)) 
[16:05:19.450]                               next
[16:05:19.450]                             if (!grepl(pattern, name)) 
[16:05:19.450]                               next
[16:05:19.450]                             invokeRestart(restart)
[16:05:19.450]                             muffled <- TRUE
[16:05:19.450]                             break
[16:05:19.450]                           }
[16:05:19.450]                         }
[16:05:19.450]                       }
[16:05:19.450]                       invisible(muffled)
[16:05:19.450]                     }
[16:05:19.450]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.450]                   }
[16:05:19.450]                 }
[16:05:19.450]                 else {
[16:05:19.450]                   if (TRUE) {
[16:05:19.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.450]                     {
[16:05:19.450]                       inherits <- base::inherits
[16:05:19.450]                       invokeRestart <- base::invokeRestart
[16:05:19.450]                       is.null <- base::is.null
[16:05:19.450]                       muffled <- FALSE
[16:05:19.450]                       if (inherits(cond, "message")) {
[16:05:19.450]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.450]                         if (muffled) 
[16:05:19.450]                           invokeRestart("muffleMessage")
[16:05:19.450]                       }
[16:05:19.450]                       else if (inherits(cond, "warning")) {
[16:05:19.450]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.450]                         if (muffled) 
[16:05:19.450]                           invokeRestart("muffleWarning")
[16:05:19.450]                       }
[16:05:19.450]                       else if (inherits(cond, "condition")) {
[16:05:19.450]                         if (!is.null(pattern)) {
[16:05:19.450]                           computeRestarts <- base::computeRestarts
[16:05:19.450]                           grepl <- base::grepl
[16:05:19.450]                           restarts <- computeRestarts(cond)
[16:05:19.450]                           for (restart in restarts) {
[16:05:19.450]                             name <- restart$name
[16:05:19.450]                             if (is.null(name)) 
[16:05:19.450]                               next
[16:05:19.450]                             if (!grepl(pattern, name)) 
[16:05:19.450]                               next
[16:05:19.450]                             invokeRestart(restart)
[16:05:19.450]                             muffled <- TRUE
[16:05:19.450]                             break
[16:05:19.450]                           }
[16:05:19.450]                         }
[16:05:19.450]                       }
[16:05:19.450]                       invisible(muffled)
[16:05:19.450]                     }
[16:05:19.450]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.450]                   }
[16:05:19.450]                 }
[16:05:19.450]             }
[16:05:19.450]         }))
[16:05:19.450]     }, error = function(ex) {
[16:05:19.450]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.450]                 ...future.rng), started = ...future.startTime, 
[16:05:19.450]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.450]             version = "1.8"), class = "FutureResult")
[16:05:19.450]     }, finally = {
[16:05:19.450]         if (!identical(...future.workdir, getwd())) 
[16:05:19.450]             setwd(...future.workdir)
[16:05:19.450]         {
[16:05:19.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.450]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.450]             }
[16:05:19.450]             base::options(...future.oldOptions)
[16:05:19.450]             if (.Platform$OS.type == "windows") {
[16:05:19.450]                 old_names <- names(...future.oldEnvVars)
[16:05:19.450]                 envs <- base::Sys.getenv()
[16:05:19.450]                 names <- names(envs)
[16:05:19.450]                 common <- intersect(names, old_names)
[16:05:19.450]                 added <- setdiff(names, old_names)
[16:05:19.450]                 removed <- setdiff(old_names, names)
[16:05:19.450]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.450]                   envs[common]]
[16:05:19.450]                 NAMES <- toupper(changed)
[16:05:19.450]                 args <- list()
[16:05:19.450]                 for (kk in seq_along(NAMES)) {
[16:05:19.450]                   name <- changed[[kk]]
[16:05:19.450]                   NAME <- NAMES[[kk]]
[16:05:19.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.450]                     next
[16:05:19.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.450]                 }
[16:05:19.450]                 NAMES <- toupper(added)
[16:05:19.450]                 for (kk in seq_along(NAMES)) {
[16:05:19.450]                   name <- added[[kk]]
[16:05:19.450]                   NAME <- NAMES[[kk]]
[16:05:19.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.450]                     next
[16:05:19.450]                   args[[name]] <- ""
[16:05:19.450]                 }
[16:05:19.450]                 NAMES <- toupper(removed)
[16:05:19.450]                 for (kk in seq_along(NAMES)) {
[16:05:19.450]                   name <- removed[[kk]]
[16:05:19.450]                   NAME <- NAMES[[kk]]
[16:05:19.450]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.450]                     next
[16:05:19.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.450]                 }
[16:05:19.450]                 if (length(args) > 0) 
[16:05:19.450]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.450]             }
[16:05:19.450]             else {
[16:05:19.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.450]             }
[16:05:19.450]             {
[16:05:19.450]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.450]                   0L) {
[16:05:19.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.450]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.450]                   base::options(opts)
[16:05:19.450]                 }
[16:05:19.450]                 {
[16:05:19.450]                   {
[16:05:19.450]                     NULL
[16:05:19.450]                     RNGkind("Mersenne-Twister")
[16:05:19.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.450]                       inherits = FALSE)
[16:05:19.450]                   }
[16:05:19.450]                   options(future.plan = NULL)
[16:05:19.450]                   if (is.na(NA_character_)) 
[16:05:19.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.450]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.450]                     envir = parent.frame()) 
[16:05:19.450]                   {
[16:05:19.450]                     default_workers <- missing(workers)
[16:05:19.450]                     if (is.function(workers)) 
[16:05:19.450]                       workers <- workers()
[16:05:19.450]                     workers <- structure(as.integer(workers), 
[16:05:19.450]                       class = class(workers))
[16:05:19.450]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.450]                       1L)
[16:05:19.450]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.450]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.450]                       if (default_workers) 
[16:05:19.450]                         supportsMulticore(warn = TRUE)
[16:05:19.450]                       return(sequential(..., envir = envir))
[16:05:19.450]                     }
[16:05:19.450]                     oopts <- options(mc.cores = workers)
[16:05:19.450]                     on.exit(options(oopts))
[16:05:19.450]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.450]                       envir = envir)
[16:05:19.450]                     if (!future$lazy) 
[16:05:19.450]                       future <- run(future)
[16:05:19.450]                     invisible(future)
[16:05:19.450]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.450]                 }
[16:05:19.450]             }
[16:05:19.450]         }
[16:05:19.450]     })
[16:05:19.450]     if (TRUE) {
[16:05:19.450]         base::sink(type = "output", split = FALSE)
[16:05:19.450]         if (TRUE) {
[16:05:19.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.450]         }
[16:05:19.450]         else {
[16:05:19.450]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.450]         }
[16:05:19.450]         base::close(...future.stdout)
[16:05:19.450]         ...future.stdout <- NULL
[16:05:19.450]     }
[16:05:19.450]     ...future.result$conditions <- ...future.conditions
[16:05:19.450]     ...future.result$finished <- base::Sys.time()
[16:05:19.450]     ...future.result
[16:05:19.450] }
[16:05:19.452] plan(): Setting new future strategy stack:
[16:05:19.452] List of future strategies:
[16:05:19.452] 1. sequential:
[16:05:19.452]    - args: function (..., envir = parent.frame())
[16:05:19.452]    - tweaked: FALSE
[16:05:19.452]    - call: NULL
[16:05:19.452] plan(): nbrOfWorkers() = 1
[16:05:19.453] plan(): Setting new future strategy stack:
[16:05:19.453] List of future strategies:
[16:05:19.453] 1. multicore:
[16:05:19.453]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.453]    - tweaked: FALSE
[16:05:19.453]    - call: plan(multicore)
[16:05:19.456] plan(): nbrOfWorkers() = 1
[16:05:19.457] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[16:05:19.463] getGlobalsAndPackages() ...
[16:05:19.463] Not searching for globals
[16:05:19.463] - globals: [0] <none>
[16:05:19.463] getGlobalsAndPackages() ... DONE
[16:05:19.463] Packages needed by the future expression (n = 0): <none>
[16:05:19.463] Packages needed by future strategies (n = 0): <none>
[16:05:19.464] {
[16:05:19.464]     {
[16:05:19.464]         {
[16:05:19.464]             ...future.startTime <- base::Sys.time()
[16:05:19.464]             {
[16:05:19.464]                 {
[16:05:19.464]                   {
[16:05:19.464]                     base::local({
[16:05:19.464]                       has_future <- base::requireNamespace("future", 
[16:05:19.464]                         quietly = TRUE)
[16:05:19.464]                       if (has_future) {
[16:05:19.464]                         ns <- base::getNamespace("future")
[16:05:19.464]                         version <- ns[[".package"]][["version"]]
[16:05:19.464]                         if (is.null(version)) 
[16:05:19.464]                           version <- utils::packageVersion("future")
[16:05:19.464]                       }
[16:05:19.464]                       else {
[16:05:19.464]                         version <- NULL
[16:05:19.464]                       }
[16:05:19.464]                       if (!has_future || version < "1.8.0") {
[16:05:19.464]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.464]                           "", base::R.version$version.string), 
[16:05:19.464]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.464]                             "release", "version")], collapse = " "), 
[16:05:19.464]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.464]                           info)
[16:05:19.464]                         info <- base::paste(info, collapse = "; ")
[16:05:19.464]                         if (!has_future) {
[16:05:19.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.464]                             info)
[16:05:19.464]                         }
[16:05:19.464]                         else {
[16:05:19.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.464]                             info, version)
[16:05:19.464]                         }
[16:05:19.464]                         base::stop(msg)
[16:05:19.464]                       }
[16:05:19.464]                     })
[16:05:19.464]                   }
[16:05:19.464]                   options(future.plan = NULL)
[16:05:19.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.464]                 }
[16:05:19.464]                 ...future.workdir <- getwd()
[16:05:19.464]             }
[16:05:19.464]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.464]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.464]         }
[16:05:19.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.464]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.464]             base::names(...future.oldOptions))
[16:05:19.464]     }
[16:05:19.464]     if (FALSE) {
[16:05:19.464]     }
[16:05:19.464]     else {
[16:05:19.464]         if (TRUE) {
[16:05:19.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.464]                 open = "w")
[16:05:19.464]         }
[16:05:19.464]         else {
[16:05:19.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.464]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.464]         }
[16:05:19.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.464]             base::sink(type = "output", split = FALSE)
[16:05:19.464]             base::close(...future.stdout)
[16:05:19.464]         }, add = TRUE)
[16:05:19.464]     }
[16:05:19.464]     ...future.frame <- base::sys.nframe()
[16:05:19.464]     ...future.conditions <- base::list()
[16:05:19.464]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.464]     if (FALSE) {
[16:05:19.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.464]     }
[16:05:19.464]     ...future.result <- base::tryCatch({
[16:05:19.464]         base::withCallingHandlers({
[16:05:19.464]             ...future.value <- base::withVisible(base::local({
[16:05:19.464]                 ii
[16:05:19.464]             }))
[16:05:19.464]             future::FutureResult(value = ...future.value$value, 
[16:05:19.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.464]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.464]                     ...future.globalenv.names))
[16:05:19.464]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.464]         }, condition = base::local({
[16:05:19.464]             c <- base::c
[16:05:19.464]             inherits <- base::inherits
[16:05:19.464]             invokeRestart <- base::invokeRestart
[16:05:19.464]             length <- base::length
[16:05:19.464]             list <- base::list
[16:05:19.464]             seq.int <- base::seq.int
[16:05:19.464]             signalCondition <- base::signalCondition
[16:05:19.464]             sys.calls <- base::sys.calls
[16:05:19.464]             `[[` <- base::`[[`
[16:05:19.464]             `+` <- base::`+`
[16:05:19.464]             `<<-` <- base::`<<-`
[16:05:19.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.464]                   3L)]
[16:05:19.464]             }
[16:05:19.464]             function(cond) {
[16:05:19.464]                 is_error <- inherits(cond, "error")
[16:05:19.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.464]                   NULL)
[16:05:19.464]                 if (is_error) {
[16:05:19.464]                   sessionInformation <- function() {
[16:05:19.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.464]                       search = base::search(), system = base::Sys.info())
[16:05:19.464]                   }
[16:05:19.464]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.464]                     cond$call), session = sessionInformation(), 
[16:05:19.464]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.464]                   signalCondition(cond)
[16:05:19.464]                 }
[16:05:19.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.464]                 "immediateCondition"))) {
[16:05:19.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.464]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.464]                   if (TRUE && !signal) {
[16:05:19.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.464]                     {
[16:05:19.464]                       inherits <- base::inherits
[16:05:19.464]                       invokeRestart <- base::invokeRestart
[16:05:19.464]                       is.null <- base::is.null
[16:05:19.464]                       muffled <- FALSE
[16:05:19.464]                       if (inherits(cond, "message")) {
[16:05:19.464]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.464]                         if (muffled) 
[16:05:19.464]                           invokeRestart("muffleMessage")
[16:05:19.464]                       }
[16:05:19.464]                       else if (inherits(cond, "warning")) {
[16:05:19.464]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.464]                         if (muffled) 
[16:05:19.464]                           invokeRestart("muffleWarning")
[16:05:19.464]                       }
[16:05:19.464]                       else if (inherits(cond, "condition")) {
[16:05:19.464]                         if (!is.null(pattern)) {
[16:05:19.464]                           computeRestarts <- base::computeRestarts
[16:05:19.464]                           grepl <- base::grepl
[16:05:19.464]                           restarts <- computeRestarts(cond)
[16:05:19.464]                           for (restart in restarts) {
[16:05:19.464]                             name <- restart$name
[16:05:19.464]                             if (is.null(name)) 
[16:05:19.464]                               next
[16:05:19.464]                             if (!grepl(pattern, name)) 
[16:05:19.464]                               next
[16:05:19.464]                             invokeRestart(restart)
[16:05:19.464]                             muffled <- TRUE
[16:05:19.464]                             break
[16:05:19.464]                           }
[16:05:19.464]                         }
[16:05:19.464]                       }
[16:05:19.464]                       invisible(muffled)
[16:05:19.464]                     }
[16:05:19.464]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.464]                   }
[16:05:19.464]                 }
[16:05:19.464]                 else {
[16:05:19.464]                   if (TRUE) {
[16:05:19.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.464]                     {
[16:05:19.464]                       inherits <- base::inherits
[16:05:19.464]                       invokeRestart <- base::invokeRestart
[16:05:19.464]                       is.null <- base::is.null
[16:05:19.464]                       muffled <- FALSE
[16:05:19.464]                       if (inherits(cond, "message")) {
[16:05:19.464]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.464]                         if (muffled) 
[16:05:19.464]                           invokeRestart("muffleMessage")
[16:05:19.464]                       }
[16:05:19.464]                       else if (inherits(cond, "warning")) {
[16:05:19.464]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.464]                         if (muffled) 
[16:05:19.464]                           invokeRestart("muffleWarning")
[16:05:19.464]                       }
[16:05:19.464]                       else if (inherits(cond, "condition")) {
[16:05:19.464]                         if (!is.null(pattern)) {
[16:05:19.464]                           computeRestarts <- base::computeRestarts
[16:05:19.464]                           grepl <- base::grepl
[16:05:19.464]                           restarts <- computeRestarts(cond)
[16:05:19.464]                           for (restart in restarts) {
[16:05:19.464]                             name <- restart$name
[16:05:19.464]                             if (is.null(name)) 
[16:05:19.464]                               next
[16:05:19.464]                             if (!grepl(pattern, name)) 
[16:05:19.464]                               next
[16:05:19.464]                             invokeRestart(restart)
[16:05:19.464]                             muffled <- TRUE
[16:05:19.464]                             break
[16:05:19.464]                           }
[16:05:19.464]                         }
[16:05:19.464]                       }
[16:05:19.464]                       invisible(muffled)
[16:05:19.464]                     }
[16:05:19.464]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.464]                   }
[16:05:19.464]                 }
[16:05:19.464]             }
[16:05:19.464]         }))
[16:05:19.464]     }, error = function(ex) {
[16:05:19.464]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.464]                 ...future.rng), started = ...future.startTime, 
[16:05:19.464]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.464]             version = "1.8"), class = "FutureResult")
[16:05:19.464]     }, finally = {
[16:05:19.464]         if (!identical(...future.workdir, getwd())) 
[16:05:19.464]             setwd(...future.workdir)
[16:05:19.464]         {
[16:05:19.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.464]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.464]             }
[16:05:19.464]             base::options(...future.oldOptions)
[16:05:19.464]             if (.Platform$OS.type == "windows") {
[16:05:19.464]                 old_names <- names(...future.oldEnvVars)
[16:05:19.464]                 envs <- base::Sys.getenv()
[16:05:19.464]                 names <- names(envs)
[16:05:19.464]                 common <- intersect(names, old_names)
[16:05:19.464]                 added <- setdiff(names, old_names)
[16:05:19.464]                 removed <- setdiff(old_names, names)
[16:05:19.464]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.464]                   envs[common]]
[16:05:19.464]                 NAMES <- toupper(changed)
[16:05:19.464]                 args <- list()
[16:05:19.464]                 for (kk in seq_along(NAMES)) {
[16:05:19.464]                   name <- changed[[kk]]
[16:05:19.464]                   NAME <- NAMES[[kk]]
[16:05:19.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.464]                     next
[16:05:19.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.464]                 }
[16:05:19.464]                 NAMES <- toupper(added)
[16:05:19.464]                 for (kk in seq_along(NAMES)) {
[16:05:19.464]                   name <- added[[kk]]
[16:05:19.464]                   NAME <- NAMES[[kk]]
[16:05:19.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.464]                     next
[16:05:19.464]                   args[[name]] <- ""
[16:05:19.464]                 }
[16:05:19.464]                 NAMES <- toupper(removed)
[16:05:19.464]                 for (kk in seq_along(NAMES)) {
[16:05:19.464]                   name <- removed[[kk]]
[16:05:19.464]                   NAME <- NAMES[[kk]]
[16:05:19.464]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.464]                     next
[16:05:19.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.464]                 }
[16:05:19.464]                 if (length(args) > 0) 
[16:05:19.464]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.464]             }
[16:05:19.464]             else {
[16:05:19.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.464]             }
[16:05:19.464]             {
[16:05:19.464]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.464]                   0L) {
[16:05:19.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.464]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.464]                   base::options(opts)
[16:05:19.464]                 }
[16:05:19.464]                 {
[16:05:19.464]                   {
[16:05:19.464]                     NULL
[16:05:19.464]                     RNGkind("Mersenne-Twister")
[16:05:19.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.464]                       inherits = FALSE)
[16:05:19.464]                   }
[16:05:19.464]                   options(future.plan = NULL)
[16:05:19.464]                   if (is.na(NA_character_)) 
[16:05:19.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.464]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.464]                     envir = parent.frame()) 
[16:05:19.464]                   {
[16:05:19.464]                     default_workers <- missing(workers)
[16:05:19.464]                     if (is.function(workers)) 
[16:05:19.464]                       workers <- workers()
[16:05:19.464]                     workers <- structure(as.integer(workers), 
[16:05:19.464]                       class = class(workers))
[16:05:19.464]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.464]                       1L)
[16:05:19.464]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.464]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.464]                       if (default_workers) 
[16:05:19.464]                         supportsMulticore(warn = TRUE)
[16:05:19.464]                       return(sequential(..., envir = envir))
[16:05:19.464]                     }
[16:05:19.464]                     oopts <- options(mc.cores = workers)
[16:05:19.464]                     on.exit(options(oopts))
[16:05:19.464]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.464]                       envir = envir)
[16:05:19.464]                     if (!future$lazy) 
[16:05:19.464]                       future <- run(future)
[16:05:19.464]                     invisible(future)
[16:05:19.464]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.464]                 }
[16:05:19.464]             }
[16:05:19.464]         }
[16:05:19.464]     })
[16:05:19.464]     if (TRUE) {
[16:05:19.464]         base::sink(type = "output", split = FALSE)
[16:05:19.464]         if (TRUE) {
[16:05:19.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.464]         }
[16:05:19.464]         else {
[16:05:19.464]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.464]         }
[16:05:19.464]         base::close(...future.stdout)
[16:05:19.464]         ...future.stdout <- NULL
[16:05:19.464]     }
[16:05:19.464]     ...future.result$conditions <- ...future.conditions
[16:05:19.464]     ...future.result$finished <- base::Sys.time()
[16:05:19.464]     ...future.result
[16:05:19.464] }
[16:05:19.466] plan(): Setting new future strategy stack:
[16:05:19.466] List of future strategies:
[16:05:19.466] 1. sequential:
[16:05:19.466]    - args: function (..., envir = parent.frame())
[16:05:19.466]    - tweaked: FALSE
[16:05:19.466]    - call: NULL
[16:05:19.466] plan(): nbrOfWorkers() = 1
[16:05:19.467] plan(): Setting new future strategy stack:
[16:05:19.467] List of future strategies:
[16:05:19.467] 1. multicore:
[16:05:19.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.467]    - tweaked: FALSE
[16:05:19.467]    - call: plan(multicore)
[16:05:19.470] plan(): nbrOfWorkers() = 1
[16:05:19.471] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[16:05:19.474] getGlobalsAndPackages() ...
[16:05:19.474] Not searching for globals
[16:05:19.474] - globals: [0] <none>
[16:05:19.474] getGlobalsAndPackages() ... DONE
[16:05:19.475] Packages needed by the future expression (n = 0): <none>
[16:05:19.475] Packages needed by future strategies (n = 0): <none>
[16:05:19.475] {
[16:05:19.475]     {
[16:05:19.475]         {
[16:05:19.475]             ...future.startTime <- base::Sys.time()
[16:05:19.475]             {
[16:05:19.475]                 {
[16:05:19.475]                   {
[16:05:19.475]                     base::local({
[16:05:19.475]                       has_future <- base::requireNamespace("future", 
[16:05:19.475]                         quietly = TRUE)
[16:05:19.475]                       if (has_future) {
[16:05:19.475]                         ns <- base::getNamespace("future")
[16:05:19.475]                         version <- ns[[".package"]][["version"]]
[16:05:19.475]                         if (is.null(version)) 
[16:05:19.475]                           version <- utils::packageVersion("future")
[16:05:19.475]                       }
[16:05:19.475]                       else {
[16:05:19.475]                         version <- NULL
[16:05:19.475]                       }
[16:05:19.475]                       if (!has_future || version < "1.8.0") {
[16:05:19.475]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.475]                           "", base::R.version$version.string), 
[16:05:19.475]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.475]                             "release", "version")], collapse = " "), 
[16:05:19.475]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.475]                           info)
[16:05:19.475]                         info <- base::paste(info, collapse = "; ")
[16:05:19.475]                         if (!has_future) {
[16:05:19.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.475]                             info)
[16:05:19.475]                         }
[16:05:19.475]                         else {
[16:05:19.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.475]                             info, version)
[16:05:19.475]                         }
[16:05:19.475]                         base::stop(msg)
[16:05:19.475]                       }
[16:05:19.475]                     })
[16:05:19.475]                   }
[16:05:19.475]                   options(future.plan = NULL)
[16:05:19.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.475]                 }
[16:05:19.475]                 ...future.workdir <- getwd()
[16:05:19.475]             }
[16:05:19.475]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.475]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.475]         }
[16:05:19.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.475]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.475]             base::names(...future.oldOptions))
[16:05:19.475]     }
[16:05:19.475]     if (FALSE) {
[16:05:19.475]     }
[16:05:19.475]     else {
[16:05:19.475]         if (TRUE) {
[16:05:19.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.475]                 open = "w")
[16:05:19.475]         }
[16:05:19.475]         else {
[16:05:19.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.475]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.475]         }
[16:05:19.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.475]             base::sink(type = "output", split = FALSE)
[16:05:19.475]             base::close(...future.stdout)
[16:05:19.475]         }, add = TRUE)
[16:05:19.475]     }
[16:05:19.475]     ...future.frame <- base::sys.nframe()
[16:05:19.475]     ...future.conditions <- base::list()
[16:05:19.475]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.475]     if (FALSE) {
[16:05:19.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.475]     }
[16:05:19.475]     ...future.result <- base::tryCatch({
[16:05:19.475]         base::withCallingHandlers({
[16:05:19.475]             ...future.value <- base::withVisible(base::local({
[16:05:19.475]                 ii
[16:05:19.475]             }))
[16:05:19.475]             future::FutureResult(value = ...future.value$value, 
[16:05:19.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.475]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.475]                     ...future.globalenv.names))
[16:05:19.475]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.475]         }, condition = base::local({
[16:05:19.475]             c <- base::c
[16:05:19.475]             inherits <- base::inherits
[16:05:19.475]             invokeRestart <- base::invokeRestart
[16:05:19.475]             length <- base::length
[16:05:19.475]             list <- base::list
[16:05:19.475]             seq.int <- base::seq.int
[16:05:19.475]             signalCondition <- base::signalCondition
[16:05:19.475]             sys.calls <- base::sys.calls
[16:05:19.475]             `[[` <- base::`[[`
[16:05:19.475]             `+` <- base::`+`
[16:05:19.475]             `<<-` <- base::`<<-`
[16:05:19.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.475]                   3L)]
[16:05:19.475]             }
[16:05:19.475]             function(cond) {
[16:05:19.475]                 is_error <- inherits(cond, "error")
[16:05:19.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.475]                   NULL)
[16:05:19.475]                 if (is_error) {
[16:05:19.475]                   sessionInformation <- function() {
[16:05:19.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.475]                       search = base::search(), system = base::Sys.info())
[16:05:19.475]                   }
[16:05:19.475]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.475]                     cond$call), session = sessionInformation(), 
[16:05:19.475]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.475]                   signalCondition(cond)
[16:05:19.475]                 }
[16:05:19.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.475]                 "immediateCondition"))) {
[16:05:19.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.475]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.475]                   if (TRUE && !signal) {
[16:05:19.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.475]                     {
[16:05:19.475]                       inherits <- base::inherits
[16:05:19.475]                       invokeRestart <- base::invokeRestart
[16:05:19.475]                       is.null <- base::is.null
[16:05:19.475]                       muffled <- FALSE
[16:05:19.475]                       if (inherits(cond, "message")) {
[16:05:19.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.475]                         if (muffled) 
[16:05:19.475]                           invokeRestart("muffleMessage")
[16:05:19.475]                       }
[16:05:19.475]                       else if (inherits(cond, "warning")) {
[16:05:19.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.475]                         if (muffled) 
[16:05:19.475]                           invokeRestart("muffleWarning")
[16:05:19.475]                       }
[16:05:19.475]                       else if (inherits(cond, "condition")) {
[16:05:19.475]                         if (!is.null(pattern)) {
[16:05:19.475]                           computeRestarts <- base::computeRestarts
[16:05:19.475]                           grepl <- base::grepl
[16:05:19.475]                           restarts <- computeRestarts(cond)
[16:05:19.475]                           for (restart in restarts) {
[16:05:19.475]                             name <- restart$name
[16:05:19.475]                             if (is.null(name)) 
[16:05:19.475]                               next
[16:05:19.475]                             if (!grepl(pattern, name)) 
[16:05:19.475]                               next
[16:05:19.475]                             invokeRestart(restart)
[16:05:19.475]                             muffled <- TRUE
[16:05:19.475]                             break
[16:05:19.475]                           }
[16:05:19.475]                         }
[16:05:19.475]                       }
[16:05:19.475]                       invisible(muffled)
[16:05:19.475]                     }
[16:05:19.475]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.475]                   }
[16:05:19.475]                 }
[16:05:19.475]                 else {
[16:05:19.475]                   if (TRUE) {
[16:05:19.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.475]                     {
[16:05:19.475]                       inherits <- base::inherits
[16:05:19.475]                       invokeRestart <- base::invokeRestart
[16:05:19.475]                       is.null <- base::is.null
[16:05:19.475]                       muffled <- FALSE
[16:05:19.475]                       if (inherits(cond, "message")) {
[16:05:19.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.475]                         if (muffled) 
[16:05:19.475]                           invokeRestart("muffleMessage")
[16:05:19.475]                       }
[16:05:19.475]                       else if (inherits(cond, "warning")) {
[16:05:19.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.475]                         if (muffled) 
[16:05:19.475]                           invokeRestart("muffleWarning")
[16:05:19.475]                       }
[16:05:19.475]                       else if (inherits(cond, "condition")) {
[16:05:19.475]                         if (!is.null(pattern)) {
[16:05:19.475]                           computeRestarts <- base::computeRestarts
[16:05:19.475]                           grepl <- base::grepl
[16:05:19.475]                           restarts <- computeRestarts(cond)
[16:05:19.475]                           for (restart in restarts) {
[16:05:19.475]                             name <- restart$name
[16:05:19.475]                             if (is.null(name)) 
[16:05:19.475]                               next
[16:05:19.475]                             if (!grepl(pattern, name)) 
[16:05:19.475]                               next
[16:05:19.475]                             invokeRestart(restart)
[16:05:19.475]                             muffled <- TRUE
[16:05:19.475]                             break
[16:05:19.475]                           }
[16:05:19.475]                         }
[16:05:19.475]                       }
[16:05:19.475]                       invisible(muffled)
[16:05:19.475]                     }
[16:05:19.475]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.475]                   }
[16:05:19.475]                 }
[16:05:19.475]             }
[16:05:19.475]         }))
[16:05:19.475]     }, error = function(ex) {
[16:05:19.475]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.475]                 ...future.rng), started = ...future.startTime, 
[16:05:19.475]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.475]             version = "1.8"), class = "FutureResult")
[16:05:19.475]     }, finally = {
[16:05:19.475]         if (!identical(...future.workdir, getwd())) 
[16:05:19.475]             setwd(...future.workdir)
[16:05:19.475]         {
[16:05:19.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.475]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.475]             }
[16:05:19.475]             base::options(...future.oldOptions)
[16:05:19.475]             if (.Platform$OS.type == "windows") {
[16:05:19.475]                 old_names <- names(...future.oldEnvVars)
[16:05:19.475]                 envs <- base::Sys.getenv()
[16:05:19.475]                 names <- names(envs)
[16:05:19.475]                 common <- intersect(names, old_names)
[16:05:19.475]                 added <- setdiff(names, old_names)
[16:05:19.475]                 removed <- setdiff(old_names, names)
[16:05:19.475]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.475]                   envs[common]]
[16:05:19.475]                 NAMES <- toupper(changed)
[16:05:19.475]                 args <- list()
[16:05:19.475]                 for (kk in seq_along(NAMES)) {
[16:05:19.475]                   name <- changed[[kk]]
[16:05:19.475]                   NAME <- NAMES[[kk]]
[16:05:19.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.475]                     next
[16:05:19.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.475]                 }
[16:05:19.475]                 NAMES <- toupper(added)
[16:05:19.475]                 for (kk in seq_along(NAMES)) {
[16:05:19.475]                   name <- added[[kk]]
[16:05:19.475]                   NAME <- NAMES[[kk]]
[16:05:19.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.475]                     next
[16:05:19.475]                   args[[name]] <- ""
[16:05:19.475]                 }
[16:05:19.475]                 NAMES <- toupper(removed)
[16:05:19.475]                 for (kk in seq_along(NAMES)) {
[16:05:19.475]                   name <- removed[[kk]]
[16:05:19.475]                   NAME <- NAMES[[kk]]
[16:05:19.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.475]                     next
[16:05:19.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.475]                 }
[16:05:19.475]                 if (length(args) > 0) 
[16:05:19.475]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.475]             }
[16:05:19.475]             else {
[16:05:19.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.475]             }
[16:05:19.475]             {
[16:05:19.475]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.475]                   0L) {
[16:05:19.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.475]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.475]                   base::options(opts)
[16:05:19.475]                 }
[16:05:19.475]                 {
[16:05:19.475]                   {
[16:05:19.475]                     NULL
[16:05:19.475]                     RNGkind("Mersenne-Twister")
[16:05:19.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.475]                       inherits = FALSE)
[16:05:19.475]                   }
[16:05:19.475]                   options(future.plan = NULL)
[16:05:19.475]                   if (is.na(NA_character_)) 
[16:05:19.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.475]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.475]                     envir = parent.frame()) 
[16:05:19.475]                   {
[16:05:19.475]                     default_workers <- missing(workers)
[16:05:19.475]                     if (is.function(workers)) 
[16:05:19.475]                       workers <- workers()
[16:05:19.475]                     workers <- structure(as.integer(workers), 
[16:05:19.475]                       class = class(workers))
[16:05:19.475]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.475]                       1L)
[16:05:19.475]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.475]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.475]                       if (default_workers) 
[16:05:19.475]                         supportsMulticore(warn = TRUE)
[16:05:19.475]                       return(sequential(..., envir = envir))
[16:05:19.475]                     }
[16:05:19.475]                     oopts <- options(mc.cores = workers)
[16:05:19.475]                     on.exit(options(oopts))
[16:05:19.475]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.475]                       envir = envir)
[16:05:19.475]                     if (!future$lazy) 
[16:05:19.475]                       future <- run(future)
[16:05:19.475]                     invisible(future)
[16:05:19.475]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.475]                 }
[16:05:19.475]             }
[16:05:19.475]         }
[16:05:19.475]     })
[16:05:19.475]     if (TRUE) {
[16:05:19.475]         base::sink(type = "output", split = FALSE)
[16:05:19.475]         if (TRUE) {
[16:05:19.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.475]         }
[16:05:19.475]         else {
[16:05:19.475]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.475]         }
[16:05:19.475]         base::close(...future.stdout)
[16:05:19.475]         ...future.stdout <- NULL
[16:05:19.475]     }
[16:05:19.475]     ...future.result$conditions <- ...future.conditions
[16:05:19.475]     ...future.result$finished <- base::Sys.time()
[16:05:19.475]     ...future.result
[16:05:19.475] }
[16:05:19.477] plan(): Setting new future strategy stack:
[16:05:19.477] List of future strategies:
[16:05:19.477] 1. sequential:
[16:05:19.477]    - args: function (..., envir = parent.frame())
[16:05:19.477]    - tweaked: FALSE
[16:05:19.477]    - call: NULL
[16:05:19.478] plan(): nbrOfWorkers() = 1
[16:05:19.478] plan(): Setting new future strategy stack:
[16:05:19.478] List of future strategies:
[16:05:19.478] 1. multicore:
[16:05:19.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.478]    - tweaked: FALSE
[16:05:19.478]    - call: plan(multicore)
[16:05:19.482] plan(): nbrOfWorkers() = 1
[16:05:19.482] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[16:05:19.485] getGlobalsAndPackages() ...
[16:05:19.486] Not searching for globals
[16:05:19.486] - globals: [0] <none>
[16:05:19.486] getGlobalsAndPackages() ... DONE
[16:05:19.486] Packages needed by the future expression (n = 0): <none>
[16:05:19.486] Packages needed by future strategies (n = 0): <none>
[16:05:19.487] {
[16:05:19.487]     {
[16:05:19.487]         {
[16:05:19.487]             ...future.startTime <- base::Sys.time()
[16:05:19.487]             {
[16:05:19.487]                 {
[16:05:19.487]                   {
[16:05:19.487]                     base::local({
[16:05:19.487]                       has_future <- base::requireNamespace("future", 
[16:05:19.487]                         quietly = TRUE)
[16:05:19.487]                       if (has_future) {
[16:05:19.487]                         ns <- base::getNamespace("future")
[16:05:19.487]                         version <- ns[[".package"]][["version"]]
[16:05:19.487]                         if (is.null(version)) 
[16:05:19.487]                           version <- utils::packageVersion("future")
[16:05:19.487]                       }
[16:05:19.487]                       else {
[16:05:19.487]                         version <- NULL
[16:05:19.487]                       }
[16:05:19.487]                       if (!has_future || version < "1.8.0") {
[16:05:19.487]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.487]                           "", base::R.version$version.string), 
[16:05:19.487]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.487]                             "release", "version")], collapse = " "), 
[16:05:19.487]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.487]                           info)
[16:05:19.487]                         info <- base::paste(info, collapse = "; ")
[16:05:19.487]                         if (!has_future) {
[16:05:19.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.487]                             info)
[16:05:19.487]                         }
[16:05:19.487]                         else {
[16:05:19.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.487]                             info, version)
[16:05:19.487]                         }
[16:05:19.487]                         base::stop(msg)
[16:05:19.487]                       }
[16:05:19.487]                     })
[16:05:19.487]                   }
[16:05:19.487]                   options(future.plan = NULL)
[16:05:19.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.487]                 }
[16:05:19.487]                 ...future.workdir <- getwd()
[16:05:19.487]             }
[16:05:19.487]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.487]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.487]         }
[16:05:19.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.487]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.487]             base::names(...future.oldOptions))
[16:05:19.487]     }
[16:05:19.487]     if (FALSE) {
[16:05:19.487]     }
[16:05:19.487]     else {
[16:05:19.487]         if (TRUE) {
[16:05:19.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.487]                 open = "w")
[16:05:19.487]         }
[16:05:19.487]         else {
[16:05:19.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.487]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.487]         }
[16:05:19.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.487]             base::sink(type = "output", split = FALSE)
[16:05:19.487]             base::close(...future.stdout)
[16:05:19.487]         }, add = TRUE)
[16:05:19.487]     }
[16:05:19.487]     ...future.frame <- base::sys.nframe()
[16:05:19.487]     ...future.conditions <- base::list()
[16:05:19.487]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.487]     if (FALSE) {
[16:05:19.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.487]     }
[16:05:19.487]     ...future.result <- base::tryCatch({
[16:05:19.487]         base::withCallingHandlers({
[16:05:19.487]             ...future.value <- base::withVisible(base::local({
[16:05:19.487]                 ii
[16:05:19.487]             }))
[16:05:19.487]             future::FutureResult(value = ...future.value$value, 
[16:05:19.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.487]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.487]                     ...future.globalenv.names))
[16:05:19.487]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.487]         }, condition = base::local({
[16:05:19.487]             c <- base::c
[16:05:19.487]             inherits <- base::inherits
[16:05:19.487]             invokeRestart <- base::invokeRestart
[16:05:19.487]             length <- base::length
[16:05:19.487]             list <- base::list
[16:05:19.487]             seq.int <- base::seq.int
[16:05:19.487]             signalCondition <- base::signalCondition
[16:05:19.487]             sys.calls <- base::sys.calls
[16:05:19.487]             `[[` <- base::`[[`
[16:05:19.487]             `+` <- base::`+`
[16:05:19.487]             `<<-` <- base::`<<-`
[16:05:19.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.487]                   3L)]
[16:05:19.487]             }
[16:05:19.487]             function(cond) {
[16:05:19.487]                 is_error <- inherits(cond, "error")
[16:05:19.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.487]                   NULL)
[16:05:19.487]                 if (is_error) {
[16:05:19.487]                   sessionInformation <- function() {
[16:05:19.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.487]                       search = base::search(), system = base::Sys.info())
[16:05:19.487]                   }
[16:05:19.487]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.487]                     cond$call), session = sessionInformation(), 
[16:05:19.487]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.487]                   signalCondition(cond)
[16:05:19.487]                 }
[16:05:19.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.487]                 "immediateCondition"))) {
[16:05:19.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.487]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.487]                   if (TRUE && !signal) {
[16:05:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.487]                     {
[16:05:19.487]                       inherits <- base::inherits
[16:05:19.487]                       invokeRestart <- base::invokeRestart
[16:05:19.487]                       is.null <- base::is.null
[16:05:19.487]                       muffled <- FALSE
[16:05:19.487]                       if (inherits(cond, "message")) {
[16:05:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.487]                         if (muffled) 
[16:05:19.487]                           invokeRestart("muffleMessage")
[16:05:19.487]                       }
[16:05:19.487]                       else if (inherits(cond, "warning")) {
[16:05:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.487]                         if (muffled) 
[16:05:19.487]                           invokeRestart("muffleWarning")
[16:05:19.487]                       }
[16:05:19.487]                       else if (inherits(cond, "condition")) {
[16:05:19.487]                         if (!is.null(pattern)) {
[16:05:19.487]                           computeRestarts <- base::computeRestarts
[16:05:19.487]                           grepl <- base::grepl
[16:05:19.487]                           restarts <- computeRestarts(cond)
[16:05:19.487]                           for (restart in restarts) {
[16:05:19.487]                             name <- restart$name
[16:05:19.487]                             if (is.null(name)) 
[16:05:19.487]                               next
[16:05:19.487]                             if (!grepl(pattern, name)) 
[16:05:19.487]                               next
[16:05:19.487]                             invokeRestart(restart)
[16:05:19.487]                             muffled <- TRUE
[16:05:19.487]                             break
[16:05:19.487]                           }
[16:05:19.487]                         }
[16:05:19.487]                       }
[16:05:19.487]                       invisible(muffled)
[16:05:19.487]                     }
[16:05:19.487]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.487]                   }
[16:05:19.487]                 }
[16:05:19.487]                 else {
[16:05:19.487]                   if (TRUE) {
[16:05:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.487]                     {
[16:05:19.487]                       inherits <- base::inherits
[16:05:19.487]                       invokeRestart <- base::invokeRestart
[16:05:19.487]                       is.null <- base::is.null
[16:05:19.487]                       muffled <- FALSE
[16:05:19.487]                       if (inherits(cond, "message")) {
[16:05:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.487]                         if (muffled) 
[16:05:19.487]                           invokeRestart("muffleMessage")
[16:05:19.487]                       }
[16:05:19.487]                       else if (inherits(cond, "warning")) {
[16:05:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.487]                         if (muffled) 
[16:05:19.487]                           invokeRestart("muffleWarning")
[16:05:19.487]                       }
[16:05:19.487]                       else if (inherits(cond, "condition")) {
[16:05:19.487]                         if (!is.null(pattern)) {
[16:05:19.487]                           computeRestarts <- base::computeRestarts
[16:05:19.487]                           grepl <- base::grepl
[16:05:19.487]                           restarts <- computeRestarts(cond)
[16:05:19.487]                           for (restart in restarts) {
[16:05:19.487]                             name <- restart$name
[16:05:19.487]                             if (is.null(name)) 
[16:05:19.487]                               next
[16:05:19.487]                             if (!grepl(pattern, name)) 
[16:05:19.487]                               next
[16:05:19.487]                             invokeRestart(restart)
[16:05:19.487]                             muffled <- TRUE
[16:05:19.487]                             break
[16:05:19.487]                           }
[16:05:19.487]                         }
[16:05:19.487]                       }
[16:05:19.487]                       invisible(muffled)
[16:05:19.487]                     }
[16:05:19.487]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.487]                   }
[16:05:19.487]                 }
[16:05:19.487]             }
[16:05:19.487]         }))
[16:05:19.487]     }, error = function(ex) {
[16:05:19.487]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.487]                 ...future.rng), started = ...future.startTime, 
[16:05:19.487]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.487]             version = "1.8"), class = "FutureResult")
[16:05:19.487]     }, finally = {
[16:05:19.487]         if (!identical(...future.workdir, getwd())) 
[16:05:19.487]             setwd(...future.workdir)
[16:05:19.487]         {
[16:05:19.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.487]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.487]             }
[16:05:19.487]             base::options(...future.oldOptions)
[16:05:19.487]             if (.Platform$OS.type == "windows") {
[16:05:19.487]                 old_names <- names(...future.oldEnvVars)
[16:05:19.487]                 envs <- base::Sys.getenv()
[16:05:19.487]                 names <- names(envs)
[16:05:19.487]                 common <- intersect(names, old_names)
[16:05:19.487]                 added <- setdiff(names, old_names)
[16:05:19.487]                 removed <- setdiff(old_names, names)
[16:05:19.487]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.487]                   envs[common]]
[16:05:19.487]                 NAMES <- toupper(changed)
[16:05:19.487]                 args <- list()
[16:05:19.487]                 for (kk in seq_along(NAMES)) {
[16:05:19.487]                   name <- changed[[kk]]
[16:05:19.487]                   NAME <- NAMES[[kk]]
[16:05:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.487]                     next
[16:05:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.487]                 }
[16:05:19.487]                 NAMES <- toupper(added)
[16:05:19.487]                 for (kk in seq_along(NAMES)) {
[16:05:19.487]                   name <- added[[kk]]
[16:05:19.487]                   NAME <- NAMES[[kk]]
[16:05:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.487]                     next
[16:05:19.487]                   args[[name]] <- ""
[16:05:19.487]                 }
[16:05:19.487]                 NAMES <- toupper(removed)
[16:05:19.487]                 for (kk in seq_along(NAMES)) {
[16:05:19.487]                   name <- removed[[kk]]
[16:05:19.487]                   NAME <- NAMES[[kk]]
[16:05:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.487]                     next
[16:05:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.487]                 }
[16:05:19.487]                 if (length(args) > 0) 
[16:05:19.487]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.487]             }
[16:05:19.487]             else {
[16:05:19.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.487]             }
[16:05:19.487]             {
[16:05:19.487]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.487]                   0L) {
[16:05:19.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.487]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.487]                   base::options(opts)
[16:05:19.487]                 }
[16:05:19.487]                 {
[16:05:19.487]                   {
[16:05:19.487]                     NULL
[16:05:19.487]                     RNGkind("Mersenne-Twister")
[16:05:19.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.487]                       inherits = FALSE)
[16:05:19.487]                   }
[16:05:19.487]                   options(future.plan = NULL)
[16:05:19.487]                   if (is.na(NA_character_)) 
[16:05:19.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.487]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.487]                     envir = parent.frame()) 
[16:05:19.487]                   {
[16:05:19.487]                     default_workers <- missing(workers)
[16:05:19.487]                     if (is.function(workers)) 
[16:05:19.487]                       workers <- workers()
[16:05:19.487]                     workers <- structure(as.integer(workers), 
[16:05:19.487]                       class = class(workers))
[16:05:19.487]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.487]                       1L)
[16:05:19.487]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.487]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.487]                       if (default_workers) 
[16:05:19.487]                         supportsMulticore(warn = TRUE)
[16:05:19.487]                       return(sequential(..., envir = envir))
[16:05:19.487]                     }
[16:05:19.487]                     oopts <- options(mc.cores = workers)
[16:05:19.487]                     on.exit(options(oopts))
[16:05:19.487]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.487]                       envir = envir)
[16:05:19.487]                     if (!future$lazy) 
[16:05:19.487]                       future <- run(future)
[16:05:19.487]                     invisible(future)
[16:05:19.487]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.487]                 }
[16:05:19.487]             }
[16:05:19.487]         }
[16:05:19.487]     })
[16:05:19.487]     if (TRUE) {
[16:05:19.487]         base::sink(type = "output", split = FALSE)
[16:05:19.487]         if (TRUE) {
[16:05:19.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.487]         }
[16:05:19.487]         else {
[16:05:19.487]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.487]         }
[16:05:19.487]         base::close(...future.stdout)
[16:05:19.487]         ...future.stdout <- NULL
[16:05:19.487]     }
[16:05:19.487]     ...future.result$conditions <- ...future.conditions
[16:05:19.487]     ...future.result$finished <- base::Sys.time()
[16:05:19.487]     ...future.result
[16:05:19.487] }
[16:05:19.489] plan(): Setting new future strategy stack:
[16:05:19.489] List of future strategies:
[16:05:19.489] 1. sequential:
[16:05:19.489]    - args: function (..., envir = parent.frame())
[16:05:19.489]    - tweaked: FALSE
[16:05:19.489]    - call: NULL
[16:05:19.489] plan(): nbrOfWorkers() = 1
[16:05:19.490] plan(): Setting new future strategy stack:
[16:05:19.490] List of future strategies:
[16:05:19.490] 1. multicore:
[16:05:19.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.490]    - tweaked: FALSE
[16:05:19.490]    - call: plan(multicore)
[16:05:19.493] plan(): nbrOfWorkers() = 1
[16:05:19.493] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[16:05:19.497] getGlobalsAndPackages() ...
[16:05:19.498] Not searching for globals
[16:05:19.498] - globals: [0] <none>
[16:05:19.498] getGlobalsAndPackages() ... DONE
[16:05:19.498] Packages needed by the future expression (n = 0): <none>
[16:05:19.498] Packages needed by future strategies (n = 0): <none>
[16:05:19.499] {
[16:05:19.499]     {
[16:05:19.499]         {
[16:05:19.499]             ...future.startTime <- base::Sys.time()
[16:05:19.499]             {
[16:05:19.499]                 {
[16:05:19.499]                   {
[16:05:19.499]                     base::local({
[16:05:19.499]                       has_future <- base::requireNamespace("future", 
[16:05:19.499]                         quietly = TRUE)
[16:05:19.499]                       if (has_future) {
[16:05:19.499]                         ns <- base::getNamespace("future")
[16:05:19.499]                         version <- ns[[".package"]][["version"]]
[16:05:19.499]                         if (is.null(version)) 
[16:05:19.499]                           version <- utils::packageVersion("future")
[16:05:19.499]                       }
[16:05:19.499]                       else {
[16:05:19.499]                         version <- NULL
[16:05:19.499]                       }
[16:05:19.499]                       if (!has_future || version < "1.8.0") {
[16:05:19.499]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.499]                           "", base::R.version$version.string), 
[16:05:19.499]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.499]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.499]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.499]                             "release", "version")], collapse = " "), 
[16:05:19.499]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.499]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.499]                           info)
[16:05:19.499]                         info <- base::paste(info, collapse = "; ")
[16:05:19.499]                         if (!has_future) {
[16:05:19.499]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.499]                             info)
[16:05:19.499]                         }
[16:05:19.499]                         else {
[16:05:19.499]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.499]                             info, version)
[16:05:19.499]                         }
[16:05:19.499]                         base::stop(msg)
[16:05:19.499]                       }
[16:05:19.499]                     })
[16:05:19.499]                   }
[16:05:19.499]                   options(future.plan = NULL)
[16:05:19.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.499]                 }
[16:05:19.499]                 ...future.workdir <- getwd()
[16:05:19.499]             }
[16:05:19.499]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.499]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.499]         }
[16:05:19.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.499]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.499]             base::names(...future.oldOptions))
[16:05:19.499]     }
[16:05:19.499]     if (FALSE) {
[16:05:19.499]     }
[16:05:19.499]     else {
[16:05:19.499]         if (TRUE) {
[16:05:19.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.499]                 open = "w")
[16:05:19.499]         }
[16:05:19.499]         else {
[16:05:19.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.499]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.499]         }
[16:05:19.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.499]             base::sink(type = "output", split = FALSE)
[16:05:19.499]             base::close(...future.stdout)
[16:05:19.499]         }, add = TRUE)
[16:05:19.499]     }
[16:05:19.499]     ...future.frame <- base::sys.nframe()
[16:05:19.499]     ...future.conditions <- base::list()
[16:05:19.499]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.499]     if (FALSE) {
[16:05:19.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.499]     }
[16:05:19.499]     ...future.result <- base::tryCatch({
[16:05:19.499]         base::withCallingHandlers({
[16:05:19.499]             ...future.value <- base::withVisible(base::local({
[16:05:19.499]                 stop("Whoops!")
[16:05:19.499]                 1
[16:05:19.499]             }))
[16:05:19.499]             future::FutureResult(value = ...future.value$value, 
[16:05:19.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.499]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.499]                     ...future.globalenv.names))
[16:05:19.499]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.499]         }, condition = base::local({
[16:05:19.499]             c <- base::c
[16:05:19.499]             inherits <- base::inherits
[16:05:19.499]             invokeRestart <- base::invokeRestart
[16:05:19.499]             length <- base::length
[16:05:19.499]             list <- base::list
[16:05:19.499]             seq.int <- base::seq.int
[16:05:19.499]             signalCondition <- base::signalCondition
[16:05:19.499]             sys.calls <- base::sys.calls
[16:05:19.499]             `[[` <- base::`[[`
[16:05:19.499]             `+` <- base::`+`
[16:05:19.499]             `<<-` <- base::`<<-`
[16:05:19.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.499]                   3L)]
[16:05:19.499]             }
[16:05:19.499]             function(cond) {
[16:05:19.499]                 is_error <- inherits(cond, "error")
[16:05:19.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.499]                   NULL)
[16:05:19.499]                 if (is_error) {
[16:05:19.499]                   sessionInformation <- function() {
[16:05:19.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.499]                       search = base::search(), system = base::Sys.info())
[16:05:19.499]                   }
[16:05:19.499]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.499]                     cond$call), session = sessionInformation(), 
[16:05:19.499]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.499]                   signalCondition(cond)
[16:05:19.499]                 }
[16:05:19.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.499]                 "immediateCondition"))) {
[16:05:19.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.499]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.499]                   if (TRUE && !signal) {
[16:05:19.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.499]                     {
[16:05:19.499]                       inherits <- base::inherits
[16:05:19.499]                       invokeRestart <- base::invokeRestart
[16:05:19.499]                       is.null <- base::is.null
[16:05:19.499]                       muffled <- FALSE
[16:05:19.499]                       if (inherits(cond, "message")) {
[16:05:19.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.499]                         if (muffled) 
[16:05:19.499]                           invokeRestart("muffleMessage")
[16:05:19.499]                       }
[16:05:19.499]                       else if (inherits(cond, "warning")) {
[16:05:19.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.499]                         if (muffled) 
[16:05:19.499]                           invokeRestart("muffleWarning")
[16:05:19.499]                       }
[16:05:19.499]                       else if (inherits(cond, "condition")) {
[16:05:19.499]                         if (!is.null(pattern)) {
[16:05:19.499]                           computeRestarts <- base::computeRestarts
[16:05:19.499]                           grepl <- base::grepl
[16:05:19.499]                           restarts <- computeRestarts(cond)
[16:05:19.499]                           for (restart in restarts) {
[16:05:19.499]                             name <- restart$name
[16:05:19.499]                             if (is.null(name)) 
[16:05:19.499]                               next
[16:05:19.499]                             if (!grepl(pattern, name)) 
[16:05:19.499]                               next
[16:05:19.499]                             invokeRestart(restart)
[16:05:19.499]                             muffled <- TRUE
[16:05:19.499]                             break
[16:05:19.499]                           }
[16:05:19.499]                         }
[16:05:19.499]                       }
[16:05:19.499]                       invisible(muffled)
[16:05:19.499]                     }
[16:05:19.499]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.499]                   }
[16:05:19.499]                 }
[16:05:19.499]                 else {
[16:05:19.499]                   if (TRUE) {
[16:05:19.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.499]                     {
[16:05:19.499]                       inherits <- base::inherits
[16:05:19.499]                       invokeRestart <- base::invokeRestart
[16:05:19.499]                       is.null <- base::is.null
[16:05:19.499]                       muffled <- FALSE
[16:05:19.499]                       if (inherits(cond, "message")) {
[16:05:19.499]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.499]                         if (muffled) 
[16:05:19.499]                           invokeRestart("muffleMessage")
[16:05:19.499]                       }
[16:05:19.499]                       else if (inherits(cond, "warning")) {
[16:05:19.499]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.499]                         if (muffled) 
[16:05:19.499]                           invokeRestart("muffleWarning")
[16:05:19.499]                       }
[16:05:19.499]                       else if (inherits(cond, "condition")) {
[16:05:19.499]                         if (!is.null(pattern)) {
[16:05:19.499]                           computeRestarts <- base::computeRestarts
[16:05:19.499]                           grepl <- base::grepl
[16:05:19.499]                           restarts <- computeRestarts(cond)
[16:05:19.499]                           for (restart in restarts) {
[16:05:19.499]                             name <- restart$name
[16:05:19.499]                             if (is.null(name)) 
[16:05:19.499]                               next
[16:05:19.499]                             if (!grepl(pattern, name)) 
[16:05:19.499]                               next
[16:05:19.499]                             invokeRestart(restart)
[16:05:19.499]                             muffled <- TRUE
[16:05:19.499]                             break
[16:05:19.499]                           }
[16:05:19.499]                         }
[16:05:19.499]                       }
[16:05:19.499]                       invisible(muffled)
[16:05:19.499]                     }
[16:05:19.499]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.499]                   }
[16:05:19.499]                 }
[16:05:19.499]             }
[16:05:19.499]         }))
[16:05:19.499]     }, error = function(ex) {
[16:05:19.499]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.499]                 ...future.rng), started = ...future.startTime, 
[16:05:19.499]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.499]             version = "1.8"), class = "FutureResult")
[16:05:19.499]     }, finally = {
[16:05:19.499]         if (!identical(...future.workdir, getwd())) 
[16:05:19.499]             setwd(...future.workdir)
[16:05:19.499]         {
[16:05:19.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.499]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.499]             }
[16:05:19.499]             base::options(...future.oldOptions)
[16:05:19.499]             if (.Platform$OS.type == "windows") {
[16:05:19.499]                 old_names <- names(...future.oldEnvVars)
[16:05:19.499]                 envs <- base::Sys.getenv()
[16:05:19.499]                 names <- names(envs)
[16:05:19.499]                 common <- intersect(names, old_names)
[16:05:19.499]                 added <- setdiff(names, old_names)
[16:05:19.499]                 removed <- setdiff(old_names, names)
[16:05:19.499]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.499]                   envs[common]]
[16:05:19.499]                 NAMES <- toupper(changed)
[16:05:19.499]                 args <- list()
[16:05:19.499]                 for (kk in seq_along(NAMES)) {
[16:05:19.499]                   name <- changed[[kk]]
[16:05:19.499]                   NAME <- NAMES[[kk]]
[16:05:19.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.499]                     next
[16:05:19.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.499]                 }
[16:05:19.499]                 NAMES <- toupper(added)
[16:05:19.499]                 for (kk in seq_along(NAMES)) {
[16:05:19.499]                   name <- added[[kk]]
[16:05:19.499]                   NAME <- NAMES[[kk]]
[16:05:19.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.499]                     next
[16:05:19.499]                   args[[name]] <- ""
[16:05:19.499]                 }
[16:05:19.499]                 NAMES <- toupper(removed)
[16:05:19.499]                 for (kk in seq_along(NAMES)) {
[16:05:19.499]                   name <- removed[[kk]]
[16:05:19.499]                   NAME <- NAMES[[kk]]
[16:05:19.499]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.499]                     next
[16:05:19.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.499]                 }
[16:05:19.499]                 if (length(args) > 0) 
[16:05:19.499]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.499]             }
[16:05:19.499]             else {
[16:05:19.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.499]             }
[16:05:19.499]             {
[16:05:19.499]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.499]                   0L) {
[16:05:19.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.499]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.499]                   base::options(opts)
[16:05:19.499]                 }
[16:05:19.499]                 {
[16:05:19.499]                   {
[16:05:19.499]                     NULL
[16:05:19.499]                     RNGkind("Mersenne-Twister")
[16:05:19.499]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.499]                       inherits = FALSE)
[16:05:19.499]                   }
[16:05:19.499]                   options(future.plan = NULL)
[16:05:19.499]                   if (is.na(NA_character_)) 
[16:05:19.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.499]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.499]                     envir = parent.frame()) 
[16:05:19.499]                   {
[16:05:19.499]                     default_workers <- missing(workers)
[16:05:19.499]                     if (is.function(workers)) 
[16:05:19.499]                       workers <- workers()
[16:05:19.499]                     workers <- structure(as.integer(workers), 
[16:05:19.499]                       class = class(workers))
[16:05:19.499]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.499]                       1L)
[16:05:19.499]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.499]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.499]                       if (default_workers) 
[16:05:19.499]                         supportsMulticore(warn = TRUE)
[16:05:19.499]                       return(sequential(..., envir = envir))
[16:05:19.499]                     }
[16:05:19.499]                     oopts <- options(mc.cores = workers)
[16:05:19.499]                     on.exit(options(oopts))
[16:05:19.499]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.499]                       envir = envir)
[16:05:19.499]                     if (!future$lazy) 
[16:05:19.499]                       future <- run(future)
[16:05:19.499]                     invisible(future)
[16:05:19.499]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.499]                 }
[16:05:19.499]             }
[16:05:19.499]         }
[16:05:19.499]     })
[16:05:19.499]     if (TRUE) {
[16:05:19.499]         base::sink(type = "output", split = FALSE)
[16:05:19.499]         if (TRUE) {
[16:05:19.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.499]         }
[16:05:19.499]         else {
[16:05:19.499]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.499]         }
[16:05:19.499]         base::close(...future.stdout)
[16:05:19.499]         ...future.stdout <- NULL
[16:05:19.499]     }
[16:05:19.499]     ...future.result$conditions <- ...future.conditions
[16:05:19.499]     ...future.result$finished <- base::Sys.time()
[16:05:19.499]     ...future.result
[16:05:19.499] }
[16:05:19.501] plan(): Setting new future strategy stack:
[16:05:19.501] List of future strategies:
[16:05:19.501] 1. sequential:
[16:05:19.501]    - args: function (..., envir = parent.frame())
[16:05:19.501]    - tweaked: FALSE
[16:05:19.501]    - call: NULL
[16:05:19.501] plan(): nbrOfWorkers() = 1
[16:05:19.502] plan(): Setting new future strategy stack:
[16:05:19.502] List of future strategies:
[16:05:19.502] 1. multicore:
[16:05:19.502]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.502]    - tweaked: FALSE
[16:05:19.502]    - call: plan(multicore)
[16:05:19.506] plan(): nbrOfWorkers() = 1
[16:05:19.506] SequentialFuture started (and completed)
[16:05:19.506] signalConditions() ...
[16:05:19.506]  - include = ‘immediateCondition’
[16:05:19.506]  - exclude = 
[16:05:19.506]  - resignal = FALSE
[16:05:19.506]  - Number of conditions: 1
[16:05:19.506] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:19.507] signalConditions() ...
[16:05:19.507]  - include = ‘immediateCondition’
[16:05:19.507]  - exclude = 
[16:05:19.507]  - resignal = FALSE
[16:05:19.507]  - Number of conditions: 1
[16:05:19.507] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.508] signalConditions() ...
[16:05:19.508]  - include = ‘immediateCondition’
[16:05:19.508]  - exclude = 
[16:05:19.508]  - resignal = FALSE
[16:05:19.508]  - Number of conditions: 1
[16:05:19.508] signalConditions() ... done
[16:05:19.508] Future state: ‘finished’
[16:05:19.508] signalConditions() ...
[16:05:19.509]  - include = ‘condition’
[16:05:19.509]  - exclude = ‘immediateCondition’
[16:05:19.509]  - resignal = TRUE
[16:05:19.509]  - Number of conditions: 1
[16:05:19.509]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.509] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.509] signalConditions() ...
[16:05:19.509]  - include = ‘immediateCondition’
[16:05:19.510]  - exclude = 
[16:05:19.510]  - resignal = FALSE
[16:05:19.510]  - Number of conditions: 1
[16:05:19.510] signalConditions() ... done
[16:05:19.510] Future state: ‘finished’
[16:05:19.510] signalConditions() ...
[16:05:19.510]  - include = ‘condition’
[16:05:19.510]  - exclude = ‘immediateCondition’
[16:05:19.510]  - resignal = TRUE
[16:05:19.510]  - Number of conditions: 1
[16:05:19.510]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.511] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.514] getGlobalsAndPackages() ...
[16:05:19.514] Searching for globals...
[16:05:19.524] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[16:05:19.524] Searching for globals ... DONE
[16:05:19.524] Resolving globals: FALSE
[16:05:19.524] 
[16:05:19.525] 
[16:05:19.525] getGlobalsAndPackages() ... DONE
[16:05:19.525] Packages needed by the future expression (n = 0): <none>
[16:05:19.525] Packages needed by future strategies (n = 0): <none>
[16:05:19.526] {
[16:05:19.526]     {
[16:05:19.526]         {
[16:05:19.526]             ...future.startTime <- base::Sys.time()
[16:05:19.526]             {
[16:05:19.526]                 {
[16:05:19.526]                   {
[16:05:19.526]                     base::local({
[16:05:19.526]                       has_future <- base::requireNamespace("future", 
[16:05:19.526]                         quietly = TRUE)
[16:05:19.526]                       if (has_future) {
[16:05:19.526]                         ns <- base::getNamespace("future")
[16:05:19.526]                         version <- ns[[".package"]][["version"]]
[16:05:19.526]                         if (is.null(version)) 
[16:05:19.526]                           version <- utils::packageVersion("future")
[16:05:19.526]                       }
[16:05:19.526]                       else {
[16:05:19.526]                         version <- NULL
[16:05:19.526]                       }
[16:05:19.526]                       if (!has_future || version < "1.8.0") {
[16:05:19.526]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.526]                           "", base::R.version$version.string), 
[16:05:19.526]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.526]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.526]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.526]                             "release", "version")], collapse = " "), 
[16:05:19.526]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.526]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.526]                           info)
[16:05:19.526]                         info <- base::paste(info, collapse = "; ")
[16:05:19.526]                         if (!has_future) {
[16:05:19.526]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.526]                             info)
[16:05:19.526]                         }
[16:05:19.526]                         else {
[16:05:19.526]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.526]                             info, version)
[16:05:19.526]                         }
[16:05:19.526]                         base::stop(msg)
[16:05:19.526]                       }
[16:05:19.526]                     })
[16:05:19.526]                   }
[16:05:19.526]                   options(future.plan = NULL)
[16:05:19.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.526]                 }
[16:05:19.526]                 ...future.workdir <- getwd()
[16:05:19.526]             }
[16:05:19.526]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.526]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.526]         }
[16:05:19.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.526]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.526]             base::names(...future.oldOptions))
[16:05:19.526]     }
[16:05:19.526]     if (FALSE) {
[16:05:19.526]     }
[16:05:19.526]     else {
[16:05:19.526]         if (TRUE) {
[16:05:19.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.526]                 open = "w")
[16:05:19.526]         }
[16:05:19.526]         else {
[16:05:19.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.526]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.526]         }
[16:05:19.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.526]             base::sink(type = "output", split = FALSE)
[16:05:19.526]             base::close(...future.stdout)
[16:05:19.526]         }, add = TRUE)
[16:05:19.526]     }
[16:05:19.526]     ...future.frame <- base::sys.nframe()
[16:05:19.526]     ...future.conditions <- base::list()
[16:05:19.526]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.526]     if (FALSE) {
[16:05:19.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.526]     }
[16:05:19.526]     ...future.result <- base::tryCatch({
[16:05:19.526]         base::withCallingHandlers({
[16:05:19.526]             ...future.value <- base::withVisible(base::local({
[16:05:19.526]                 stop(structure(list(message = "boom"), class = c("MyError", 
[16:05:19.526]                   "error", "condition")))
[16:05:19.526]             }))
[16:05:19.526]             future::FutureResult(value = ...future.value$value, 
[16:05:19.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.526]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.526]                     ...future.globalenv.names))
[16:05:19.526]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.526]         }, condition = base::local({
[16:05:19.526]             c <- base::c
[16:05:19.526]             inherits <- base::inherits
[16:05:19.526]             invokeRestart <- base::invokeRestart
[16:05:19.526]             length <- base::length
[16:05:19.526]             list <- base::list
[16:05:19.526]             seq.int <- base::seq.int
[16:05:19.526]             signalCondition <- base::signalCondition
[16:05:19.526]             sys.calls <- base::sys.calls
[16:05:19.526]             `[[` <- base::`[[`
[16:05:19.526]             `+` <- base::`+`
[16:05:19.526]             `<<-` <- base::`<<-`
[16:05:19.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.526]                   3L)]
[16:05:19.526]             }
[16:05:19.526]             function(cond) {
[16:05:19.526]                 is_error <- inherits(cond, "error")
[16:05:19.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.526]                   NULL)
[16:05:19.526]                 if (is_error) {
[16:05:19.526]                   sessionInformation <- function() {
[16:05:19.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.526]                       search = base::search(), system = base::Sys.info())
[16:05:19.526]                   }
[16:05:19.526]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.526]                     cond$call), session = sessionInformation(), 
[16:05:19.526]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.526]                   signalCondition(cond)
[16:05:19.526]                 }
[16:05:19.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.526]                 "immediateCondition"))) {
[16:05:19.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.526]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.526]                   if (TRUE && !signal) {
[16:05:19.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.526]                     {
[16:05:19.526]                       inherits <- base::inherits
[16:05:19.526]                       invokeRestart <- base::invokeRestart
[16:05:19.526]                       is.null <- base::is.null
[16:05:19.526]                       muffled <- FALSE
[16:05:19.526]                       if (inherits(cond, "message")) {
[16:05:19.526]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.526]                         if (muffled) 
[16:05:19.526]                           invokeRestart("muffleMessage")
[16:05:19.526]                       }
[16:05:19.526]                       else if (inherits(cond, "warning")) {
[16:05:19.526]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.526]                         if (muffled) 
[16:05:19.526]                           invokeRestart("muffleWarning")
[16:05:19.526]                       }
[16:05:19.526]                       else if (inherits(cond, "condition")) {
[16:05:19.526]                         if (!is.null(pattern)) {
[16:05:19.526]                           computeRestarts <- base::computeRestarts
[16:05:19.526]                           grepl <- base::grepl
[16:05:19.526]                           restarts <- computeRestarts(cond)
[16:05:19.526]                           for (restart in restarts) {
[16:05:19.526]                             name <- restart$name
[16:05:19.526]                             if (is.null(name)) 
[16:05:19.526]                               next
[16:05:19.526]                             if (!grepl(pattern, name)) 
[16:05:19.526]                               next
[16:05:19.526]                             invokeRestart(restart)
[16:05:19.526]                             muffled <- TRUE
[16:05:19.526]                             break
[16:05:19.526]                           }
[16:05:19.526]                         }
[16:05:19.526]                       }
[16:05:19.526]                       invisible(muffled)
[16:05:19.526]                     }
[16:05:19.526]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.526]                   }
[16:05:19.526]                 }
[16:05:19.526]                 else {
[16:05:19.526]                   if (TRUE) {
[16:05:19.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.526]                     {
[16:05:19.526]                       inherits <- base::inherits
[16:05:19.526]                       invokeRestart <- base::invokeRestart
[16:05:19.526]                       is.null <- base::is.null
[16:05:19.526]                       muffled <- FALSE
[16:05:19.526]                       if (inherits(cond, "message")) {
[16:05:19.526]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.526]                         if (muffled) 
[16:05:19.526]                           invokeRestart("muffleMessage")
[16:05:19.526]                       }
[16:05:19.526]                       else if (inherits(cond, "warning")) {
[16:05:19.526]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.526]                         if (muffled) 
[16:05:19.526]                           invokeRestart("muffleWarning")
[16:05:19.526]                       }
[16:05:19.526]                       else if (inherits(cond, "condition")) {
[16:05:19.526]                         if (!is.null(pattern)) {
[16:05:19.526]                           computeRestarts <- base::computeRestarts
[16:05:19.526]                           grepl <- base::grepl
[16:05:19.526]                           restarts <- computeRestarts(cond)
[16:05:19.526]                           for (restart in restarts) {
[16:05:19.526]                             name <- restart$name
[16:05:19.526]                             if (is.null(name)) 
[16:05:19.526]                               next
[16:05:19.526]                             if (!grepl(pattern, name)) 
[16:05:19.526]                               next
[16:05:19.526]                             invokeRestart(restart)
[16:05:19.526]                             muffled <- TRUE
[16:05:19.526]                             break
[16:05:19.526]                           }
[16:05:19.526]                         }
[16:05:19.526]                       }
[16:05:19.526]                       invisible(muffled)
[16:05:19.526]                     }
[16:05:19.526]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.526]                   }
[16:05:19.526]                 }
[16:05:19.526]             }
[16:05:19.526]         }))
[16:05:19.526]     }, error = function(ex) {
[16:05:19.526]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.526]                 ...future.rng), started = ...future.startTime, 
[16:05:19.526]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.526]             version = "1.8"), class = "FutureResult")
[16:05:19.526]     }, finally = {
[16:05:19.526]         if (!identical(...future.workdir, getwd())) 
[16:05:19.526]             setwd(...future.workdir)
[16:05:19.526]         {
[16:05:19.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.526]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.526]             }
[16:05:19.526]             base::options(...future.oldOptions)
[16:05:19.526]             if (.Platform$OS.type == "windows") {
[16:05:19.526]                 old_names <- names(...future.oldEnvVars)
[16:05:19.526]                 envs <- base::Sys.getenv()
[16:05:19.526]                 names <- names(envs)
[16:05:19.526]                 common <- intersect(names, old_names)
[16:05:19.526]                 added <- setdiff(names, old_names)
[16:05:19.526]                 removed <- setdiff(old_names, names)
[16:05:19.526]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.526]                   envs[common]]
[16:05:19.526]                 NAMES <- toupper(changed)
[16:05:19.526]                 args <- list()
[16:05:19.526]                 for (kk in seq_along(NAMES)) {
[16:05:19.526]                   name <- changed[[kk]]
[16:05:19.526]                   NAME <- NAMES[[kk]]
[16:05:19.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.526]                     next
[16:05:19.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.526]                 }
[16:05:19.526]                 NAMES <- toupper(added)
[16:05:19.526]                 for (kk in seq_along(NAMES)) {
[16:05:19.526]                   name <- added[[kk]]
[16:05:19.526]                   NAME <- NAMES[[kk]]
[16:05:19.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.526]                     next
[16:05:19.526]                   args[[name]] <- ""
[16:05:19.526]                 }
[16:05:19.526]                 NAMES <- toupper(removed)
[16:05:19.526]                 for (kk in seq_along(NAMES)) {
[16:05:19.526]                   name <- removed[[kk]]
[16:05:19.526]                   NAME <- NAMES[[kk]]
[16:05:19.526]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.526]                     next
[16:05:19.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.526]                 }
[16:05:19.526]                 if (length(args) > 0) 
[16:05:19.526]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.526]             }
[16:05:19.526]             else {
[16:05:19.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.526]             }
[16:05:19.526]             {
[16:05:19.526]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.526]                   0L) {
[16:05:19.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.526]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.526]                   base::options(opts)
[16:05:19.526]                 }
[16:05:19.526]                 {
[16:05:19.526]                   {
[16:05:19.526]                     NULL
[16:05:19.526]                     RNGkind("Mersenne-Twister")
[16:05:19.526]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.526]                       inherits = FALSE)
[16:05:19.526]                   }
[16:05:19.526]                   options(future.plan = NULL)
[16:05:19.526]                   if (is.na(NA_character_)) 
[16:05:19.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.526]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.526]                     envir = parent.frame()) 
[16:05:19.526]                   {
[16:05:19.526]                     default_workers <- missing(workers)
[16:05:19.526]                     if (is.function(workers)) 
[16:05:19.526]                       workers <- workers()
[16:05:19.526]                     workers <- structure(as.integer(workers), 
[16:05:19.526]                       class = class(workers))
[16:05:19.526]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.526]                       1L)
[16:05:19.526]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.526]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.526]                       if (default_workers) 
[16:05:19.526]                         supportsMulticore(warn = TRUE)
[16:05:19.526]                       return(sequential(..., envir = envir))
[16:05:19.526]                     }
[16:05:19.526]                     oopts <- options(mc.cores = workers)
[16:05:19.526]                     on.exit(options(oopts))
[16:05:19.526]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.526]                       envir = envir)
[16:05:19.526]                     if (!future$lazy) 
[16:05:19.526]                       future <- run(future)
[16:05:19.526]                     invisible(future)
[16:05:19.526]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.526]                 }
[16:05:19.526]             }
[16:05:19.526]         }
[16:05:19.526]     })
[16:05:19.526]     if (TRUE) {
[16:05:19.526]         base::sink(type = "output", split = FALSE)
[16:05:19.526]         if (TRUE) {
[16:05:19.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.526]         }
[16:05:19.526]         else {
[16:05:19.526]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.526]         }
[16:05:19.526]         base::close(...future.stdout)
[16:05:19.526]         ...future.stdout <- NULL
[16:05:19.526]     }
[16:05:19.526]     ...future.result$conditions <- ...future.conditions
[16:05:19.526]     ...future.result$finished <- base::Sys.time()
[16:05:19.526]     ...future.result
[16:05:19.526] }
[16:05:19.527] plan(): Setting new future strategy stack:
[16:05:19.528] List of future strategies:
[16:05:19.528] 1. sequential:
[16:05:19.528]    - args: function (..., envir = parent.frame())
[16:05:19.528]    - tweaked: FALSE
[16:05:19.528]    - call: NULL
[16:05:19.528] plan(): nbrOfWorkers() = 1
[16:05:19.529] plan(): Setting new future strategy stack:
[16:05:19.529] List of future strategies:
[16:05:19.529] 1. multicore:
[16:05:19.529]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.529]    - tweaked: FALSE
[16:05:19.529]    - call: plan(multicore)
[16:05:19.532] plan(): nbrOfWorkers() = 1
[16:05:19.533] SequentialFuture started (and completed)
[16:05:19.533] signalConditions() ...
[16:05:19.533]  - include = ‘immediateCondition’
[16:05:19.533]  - exclude = 
[16:05:19.533]  - resignal = FALSE
[16:05:19.533]  - Number of conditions: 1
[16:05:19.533] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:19.534] signalConditions() ...
[16:05:19.534]  - include = ‘immediateCondition’
[16:05:19.534]  - exclude = 
[16:05:19.534]  - resignal = FALSE
[16:05:19.534]  - Number of conditions: 1
[16:05:19.534] signalConditions() ... done
<MyError: boom>
[16:05:19.534] signalConditions() ...
[16:05:19.534]  - include = ‘immediateCondition’
[16:05:19.535]  - exclude = 
[16:05:19.535]  - resignal = FALSE
[16:05:19.535]  - Number of conditions: 1
[16:05:19.535] signalConditions() ... done
[16:05:19.535] Future state: ‘finished’
[16:05:19.535] signalConditions() ...
[16:05:19.535]  - include = ‘condition’
[16:05:19.535]  - exclude = ‘immediateCondition’
[16:05:19.535]  - resignal = TRUE
[16:05:19.535]  - Number of conditions: 1
[16:05:19.536]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:05:19.536] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[16:05:19.539] getGlobalsAndPackages() ...
[16:05:19.539] Searching for globals...
[16:05:19.540] - globals found: [1] ‘{’
[16:05:19.540] Searching for globals ... DONE
[16:05:19.540] Resolving globals: FALSE
[16:05:19.540] 
[16:05:19.540] 
[16:05:19.540] getGlobalsAndPackages() ... DONE
[16:05:19.541] Packages needed by the future expression (n = 0): <none>
[16:05:19.541] Packages needed by future strategies (n = 0): <none>
[16:05:19.541] {
[16:05:19.541]     {
[16:05:19.541]         {
[16:05:19.541]             ...future.startTime <- base::Sys.time()
[16:05:19.541]             {
[16:05:19.541]                 {
[16:05:19.541]                   {
[16:05:19.541]                     base::local({
[16:05:19.541]                       has_future <- base::requireNamespace("future", 
[16:05:19.541]                         quietly = TRUE)
[16:05:19.541]                       if (has_future) {
[16:05:19.541]                         ns <- base::getNamespace("future")
[16:05:19.541]                         version <- ns[[".package"]][["version"]]
[16:05:19.541]                         if (is.null(version)) 
[16:05:19.541]                           version <- utils::packageVersion("future")
[16:05:19.541]                       }
[16:05:19.541]                       else {
[16:05:19.541]                         version <- NULL
[16:05:19.541]                       }
[16:05:19.541]                       if (!has_future || version < "1.8.0") {
[16:05:19.541]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.541]                           "", base::R.version$version.string), 
[16:05:19.541]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.541]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.541]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.541]                             "release", "version")], collapse = " "), 
[16:05:19.541]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.541]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.541]                           info)
[16:05:19.541]                         info <- base::paste(info, collapse = "; ")
[16:05:19.541]                         if (!has_future) {
[16:05:19.541]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.541]                             info)
[16:05:19.541]                         }
[16:05:19.541]                         else {
[16:05:19.541]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.541]                             info, version)
[16:05:19.541]                         }
[16:05:19.541]                         base::stop(msg)
[16:05:19.541]                       }
[16:05:19.541]                     })
[16:05:19.541]                   }
[16:05:19.541]                   options(future.plan = NULL)
[16:05:19.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.541]                 }
[16:05:19.541]                 ...future.workdir <- getwd()
[16:05:19.541]             }
[16:05:19.541]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.541]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.541]         }
[16:05:19.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.541]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.541]             base::names(...future.oldOptions))
[16:05:19.541]     }
[16:05:19.541]     if (FALSE) {
[16:05:19.541]     }
[16:05:19.541]     else {
[16:05:19.541]         if (TRUE) {
[16:05:19.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.541]                 open = "w")
[16:05:19.541]         }
[16:05:19.541]         else {
[16:05:19.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.541]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.541]         }
[16:05:19.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.541]             base::sink(type = "output", split = FALSE)
[16:05:19.541]             base::close(...future.stdout)
[16:05:19.541]         }, add = TRUE)
[16:05:19.541]     }
[16:05:19.541]     ...future.frame <- base::sys.nframe()
[16:05:19.541]     ...future.conditions <- base::list()
[16:05:19.541]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.541]     if (FALSE) {
[16:05:19.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.541]     }
[16:05:19.541]     ...future.result <- base::tryCatch({
[16:05:19.541]         base::withCallingHandlers({
[16:05:19.541]             ...future.value <- base::withVisible(base::local({
[16:05:19.541]                 42L
[16:05:19.541]             }))
[16:05:19.541]             future::FutureResult(value = ...future.value$value, 
[16:05:19.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.541]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.541]                     ...future.globalenv.names))
[16:05:19.541]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.541]         }, condition = base::local({
[16:05:19.541]             c <- base::c
[16:05:19.541]             inherits <- base::inherits
[16:05:19.541]             invokeRestart <- base::invokeRestart
[16:05:19.541]             length <- base::length
[16:05:19.541]             list <- base::list
[16:05:19.541]             seq.int <- base::seq.int
[16:05:19.541]             signalCondition <- base::signalCondition
[16:05:19.541]             sys.calls <- base::sys.calls
[16:05:19.541]             `[[` <- base::`[[`
[16:05:19.541]             `+` <- base::`+`
[16:05:19.541]             `<<-` <- base::`<<-`
[16:05:19.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.541]                   3L)]
[16:05:19.541]             }
[16:05:19.541]             function(cond) {
[16:05:19.541]                 is_error <- inherits(cond, "error")
[16:05:19.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.541]                   NULL)
[16:05:19.541]                 if (is_error) {
[16:05:19.541]                   sessionInformation <- function() {
[16:05:19.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.541]                       search = base::search(), system = base::Sys.info())
[16:05:19.541]                   }
[16:05:19.541]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.541]                     cond$call), session = sessionInformation(), 
[16:05:19.541]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.541]                   signalCondition(cond)
[16:05:19.541]                 }
[16:05:19.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.541]                 "immediateCondition"))) {
[16:05:19.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.541]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.541]                   if (TRUE && !signal) {
[16:05:19.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.541]                     {
[16:05:19.541]                       inherits <- base::inherits
[16:05:19.541]                       invokeRestart <- base::invokeRestart
[16:05:19.541]                       is.null <- base::is.null
[16:05:19.541]                       muffled <- FALSE
[16:05:19.541]                       if (inherits(cond, "message")) {
[16:05:19.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.541]                         if (muffled) 
[16:05:19.541]                           invokeRestart("muffleMessage")
[16:05:19.541]                       }
[16:05:19.541]                       else if (inherits(cond, "warning")) {
[16:05:19.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.541]                         if (muffled) 
[16:05:19.541]                           invokeRestart("muffleWarning")
[16:05:19.541]                       }
[16:05:19.541]                       else if (inherits(cond, "condition")) {
[16:05:19.541]                         if (!is.null(pattern)) {
[16:05:19.541]                           computeRestarts <- base::computeRestarts
[16:05:19.541]                           grepl <- base::grepl
[16:05:19.541]                           restarts <- computeRestarts(cond)
[16:05:19.541]                           for (restart in restarts) {
[16:05:19.541]                             name <- restart$name
[16:05:19.541]                             if (is.null(name)) 
[16:05:19.541]                               next
[16:05:19.541]                             if (!grepl(pattern, name)) 
[16:05:19.541]                               next
[16:05:19.541]                             invokeRestart(restart)
[16:05:19.541]                             muffled <- TRUE
[16:05:19.541]                             break
[16:05:19.541]                           }
[16:05:19.541]                         }
[16:05:19.541]                       }
[16:05:19.541]                       invisible(muffled)
[16:05:19.541]                     }
[16:05:19.541]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.541]                   }
[16:05:19.541]                 }
[16:05:19.541]                 else {
[16:05:19.541]                   if (TRUE) {
[16:05:19.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.541]                     {
[16:05:19.541]                       inherits <- base::inherits
[16:05:19.541]                       invokeRestart <- base::invokeRestart
[16:05:19.541]                       is.null <- base::is.null
[16:05:19.541]                       muffled <- FALSE
[16:05:19.541]                       if (inherits(cond, "message")) {
[16:05:19.541]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.541]                         if (muffled) 
[16:05:19.541]                           invokeRestart("muffleMessage")
[16:05:19.541]                       }
[16:05:19.541]                       else if (inherits(cond, "warning")) {
[16:05:19.541]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.541]                         if (muffled) 
[16:05:19.541]                           invokeRestart("muffleWarning")
[16:05:19.541]                       }
[16:05:19.541]                       else if (inherits(cond, "condition")) {
[16:05:19.541]                         if (!is.null(pattern)) {
[16:05:19.541]                           computeRestarts <- base::computeRestarts
[16:05:19.541]                           grepl <- base::grepl
[16:05:19.541]                           restarts <- computeRestarts(cond)
[16:05:19.541]                           for (restart in restarts) {
[16:05:19.541]                             name <- restart$name
[16:05:19.541]                             if (is.null(name)) 
[16:05:19.541]                               next
[16:05:19.541]                             if (!grepl(pattern, name)) 
[16:05:19.541]                               next
[16:05:19.541]                             invokeRestart(restart)
[16:05:19.541]                             muffled <- TRUE
[16:05:19.541]                             break
[16:05:19.541]                           }
[16:05:19.541]                         }
[16:05:19.541]                       }
[16:05:19.541]                       invisible(muffled)
[16:05:19.541]                     }
[16:05:19.541]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.541]                   }
[16:05:19.541]                 }
[16:05:19.541]             }
[16:05:19.541]         }))
[16:05:19.541]     }, error = function(ex) {
[16:05:19.541]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.541]                 ...future.rng), started = ...future.startTime, 
[16:05:19.541]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.541]             version = "1.8"), class = "FutureResult")
[16:05:19.541]     }, finally = {
[16:05:19.541]         if (!identical(...future.workdir, getwd())) 
[16:05:19.541]             setwd(...future.workdir)
[16:05:19.541]         {
[16:05:19.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.541]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.541]             }
[16:05:19.541]             base::options(...future.oldOptions)
[16:05:19.541]             if (.Platform$OS.type == "windows") {
[16:05:19.541]                 old_names <- names(...future.oldEnvVars)
[16:05:19.541]                 envs <- base::Sys.getenv()
[16:05:19.541]                 names <- names(envs)
[16:05:19.541]                 common <- intersect(names, old_names)
[16:05:19.541]                 added <- setdiff(names, old_names)
[16:05:19.541]                 removed <- setdiff(old_names, names)
[16:05:19.541]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.541]                   envs[common]]
[16:05:19.541]                 NAMES <- toupper(changed)
[16:05:19.541]                 args <- list()
[16:05:19.541]                 for (kk in seq_along(NAMES)) {
[16:05:19.541]                   name <- changed[[kk]]
[16:05:19.541]                   NAME <- NAMES[[kk]]
[16:05:19.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.541]                     next
[16:05:19.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.541]                 }
[16:05:19.541]                 NAMES <- toupper(added)
[16:05:19.541]                 for (kk in seq_along(NAMES)) {
[16:05:19.541]                   name <- added[[kk]]
[16:05:19.541]                   NAME <- NAMES[[kk]]
[16:05:19.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.541]                     next
[16:05:19.541]                   args[[name]] <- ""
[16:05:19.541]                 }
[16:05:19.541]                 NAMES <- toupper(removed)
[16:05:19.541]                 for (kk in seq_along(NAMES)) {
[16:05:19.541]                   name <- removed[[kk]]
[16:05:19.541]                   NAME <- NAMES[[kk]]
[16:05:19.541]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.541]                     next
[16:05:19.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.541]                 }
[16:05:19.541]                 if (length(args) > 0) 
[16:05:19.541]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.541]             }
[16:05:19.541]             else {
[16:05:19.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.541]             }
[16:05:19.541]             {
[16:05:19.541]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.541]                   0L) {
[16:05:19.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.541]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.541]                   base::options(opts)
[16:05:19.541]                 }
[16:05:19.541]                 {
[16:05:19.541]                   {
[16:05:19.541]                     NULL
[16:05:19.541]                     RNGkind("Mersenne-Twister")
[16:05:19.541]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.541]                       inherits = FALSE)
[16:05:19.541]                   }
[16:05:19.541]                   options(future.plan = NULL)
[16:05:19.541]                   if (is.na(NA_character_)) 
[16:05:19.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.541]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.541]                     envir = parent.frame()) 
[16:05:19.541]                   {
[16:05:19.541]                     default_workers <- missing(workers)
[16:05:19.541]                     if (is.function(workers)) 
[16:05:19.541]                       workers <- workers()
[16:05:19.541]                     workers <- structure(as.integer(workers), 
[16:05:19.541]                       class = class(workers))
[16:05:19.541]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.541]                       1L)
[16:05:19.541]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.541]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.541]                       if (default_workers) 
[16:05:19.541]                         supportsMulticore(warn = TRUE)
[16:05:19.541]                       return(sequential(..., envir = envir))
[16:05:19.541]                     }
[16:05:19.541]                     oopts <- options(mc.cores = workers)
[16:05:19.541]                     on.exit(options(oopts))
[16:05:19.541]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.541]                       envir = envir)
[16:05:19.541]                     if (!future$lazy) 
[16:05:19.541]                       future <- run(future)
[16:05:19.541]                     invisible(future)
[16:05:19.541]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.541]                 }
[16:05:19.541]             }
[16:05:19.541]         }
[16:05:19.541]     })
[16:05:19.541]     if (TRUE) {
[16:05:19.541]         base::sink(type = "output", split = FALSE)
[16:05:19.541]         if (TRUE) {
[16:05:19.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.541]         }
[16:05:19.541]         else {
[16:05:19.541]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.541]         }
[16:05:19.541]         base::close(...future.stdout)
[16:05:19.541]         ...future.stdout <- NULL
[16:05:19.541]     }
[16:05:19.541]     ...future.result$conditions <- ...future.conditions
[16:05:19.541]     ...future.result$finished <- base::Sys.time()
[16:05:19.541]     ...future.result
[16:05:19.541] }
[16:05:19.543] plan(): Setting new future strategy stack:
[16:05:19.543] List of future strategies:
[16:05:19.543] 1. sequential:
[16:05:19.543]    - args: function (..., envir = parent.frame())
[16:05:19.543]    - tweaked: FALSE
[16:05:19.543]    - call: NULL
[16:05:19.543] plan(): nbrOfWorkers() = 1
[16:05:19.544] plan(): Setting new future strategy stack:
[16:05:19.544] List of future strategies:
[16:05:19.544] 1. multicore:
[16:05:19.544]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.544]    - tweaked: FALSE
[16:05:19.544]    - call: plan(multicore)
[16:05:19.548] plan(): nbrOfWorkers() = 1
[16:05:19.548] SequentialFuture started (and completed)
[16:05:19.548] resolved() for ‘SequentialFuture’ ...
[16:05:19.548] - state: ‘finished’
[16:05:19.548] - run: TRUE
[16:05:19.548] - result: ‘FutureResult’
[16:05:19.548] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[16:05:19.552] getGlobalsAndPackages() ...
[16:05:19.552] Searching for globals...
[16:05:19.554] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:05:19.554] Searching for globals ... DONE
[16:05:19.554] Resolving globals: FALSE
[16:05:19.554] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.555] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:19.555] - globals: [1] ‘a’
[16:05:19.555] 
[16:05:19.555] getGlobalsAndPackages() ... DONE
[16:05:19.556] Packages needed by the future expression (n = 0): <none>
[16:05:19.556] Packages needed by future strategies (n = 0): <none>
[16:05:19.556] {
[16:05:19.556]     {
[16:05:19.556]         {
[16:05:19.556]             ...future.startTime <- base::Sys.time()
[16:05:19.556]             {
[16:05:19.556]                 {
[16:05:19.556]                   {
[16:05:19.556]                     base::local({
[16:05:19.556]                       has_future <- base::requireNamespace("future", 
[16:05:19.556]                         quietly = TRUE)
[16:05:19.556]                       if (has_future) {
[16:05:19.556]                         ns <- base::getNamespace("future")
[16:05:19.556]                         version <- ns[[".package"]][["version"]]
[16:05:19.556]                         if (is.null(version)) 
[16:05:19.556]                           version <- utils::packageVersion("future")
[16:05:19.556]                       }
[16:05:19.556]                       else {
[16:05:19.556]                         version <- NULL
[16:05:19.556]                       }
[16:05:19.556]                       if (!has_future || version < "1.8.0") {
[16:05:19.556]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.556]                           "", base::R.version$version.string), 
[16:05:19.556]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.556]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.556]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.556]                             "release", "version")], collapse = " "), 
[16:05:19.556]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.556]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.556]                           info)
[16:05:19.556]                         info <- base::paste(info, collapse = "; ")
[16:05:19.556]                         if (!has_future) {
[16:05:19.556]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.556]                             info)
[16:05:19.556]                         }
[16:05:19.556]                         else {
[16:05:19.556]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.556]                             info, version)
[16:05:19.556]                         }
[16:05:19.556]                         base::stop(msg)
[16:05:19.556]                       }
[16:05:19.556]                     })
[16:05:19.556]                   }
[16:05:19.556]                   options(future.plan = NULL)
[16:05:19.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.556]                 }
[16:05:19.556]                 ...future.workdir <- getwd()
[16:05:19.556]             }
[16:05:19.556]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.556]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.556]         }
[16:05:19.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.556]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.556]             base::names(...future.oldOptions))
[16:05:19.556]     }
[16:05:19.556]     if (FALSE) {
[16:05:19.556]     }
[16:05:19.556]     else {
[16:05:19.556]         if (TRUE) {
[16:05:19.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.556]                 open = "w")
[16:05:19.556]         }
[16:05:19.556]         else {
[16:05:19.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.556]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.556]         }
[16:05:19.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.556]             base::sink(type = "output", split = FALSE)
[16:05:19.556]             base::close(...future.stdout)
[16:05:19.556]         }, add = TRUE)
[16:05:19.556]     }
[16:05:19.556]     ...future.frame <- base::sys.nframe()
[16:05:19.556]     ...future.conditions <- base::list()
[16:05:19.556]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.556]     if (FALSE) {
[16:05:19.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.556]     }
[16:05:19.556]     ...future.result <- base::tryCatch({
[16:05:19.556]         base::withCallingHandlers({
[16:05:19.556]             ...future.value <- base::withVisible(base::local({
[16:05:19.556]                 b <- 3
[16:05:19.556]                 c <- 2
[16:05:19.556]                 a * b * c
[16:05:19.556]             }))
[16:05:19.556]             future::FutureResult(value = ...future.value$value, 
[16:05:19.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.556]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.556]                     ...future.globalenv.names))
[16:05:19.556]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.556]         }, condition = base::local({
[16:05:19.556]             c <- base::c
[16:05:19.556]             inherits <- base::inherits
[16:05:19.556]             invokeRestart <- base::invokeRestart
[16:05:19.556]             length <- base::length
[16:05:19.556]             list <- base::list
[16:05:19.556]             seq.int <- base::seq.int
[16:05:19.556]             signalCondition <- base::signalCondition
[16:05:19.556]             sys.calls <- base::sys.calls
[16:05:19.556]             `[[` <- base::`[[`
[16:05:19.556]             `+` <- base::`+`
[16:05:19.556]             `<<-` <- base::`<<-`
[16:05:19.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.556]                   3L)]
[16:05:19.556]             }
[16:05:19.556]             function(cond) {
[16:05:19.556]                 is_error <- inherits(cond, "error")
[16:05:19.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.556]                   NULL)
[16:05:19.556]                 if (is_error) {
[16:05:19.556]                   sessionInformation <- function() {
[16:05:19.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.556]                       search = base::search(), system = base::Sys.info())
[16:05:19.556]                   }
[16:05:19.556]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.556]                     cond$call), session = sessionInformation(), 
[16:05:19.556]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.556]                   signalCondition(cond)
[16:05:19.556]                 }
[16:05:19.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.556]                 "immediateCondition"))) {
[16:05:19.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.556]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.556]                   if (TRUE && !signal) {
[16:05:19.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.556]                     {
[16:05:19.556]                       inherits <- base::inherits
[16:05:19.556]                       invokeRestart <- base::invokeRestart
[16:05:19.556]                       is.null <- base::is.null
[16:05:19.556]                       muffled <- FALSE
[16:05:19.556]                       if (inherits(cond, "message")) {
[16:05:19.556]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.556]                         if (muffled) 
[16:05:19.556]                           invokeRestart("muffleMessage")
[16:05:19.556]                       }
[16:05:19.556]                       else if (inherits(cond, "warning")) {
[16:05:19.556]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.556]                         if (muffled) 
[16:05:19.556]                           invokeRestart("muffleWarning")
[16:05:19.556]                       }
[16:05:19.556]                       else if (inherits(cond, "condition")) {
[16:05:19.556]                         if (!is.null(pattern)) {
[16:05:19.556]                           computeRestarts <- base::computeRestarts
[16:05:19.556]                           grepl <- base::grepl
[16:05:19.556]                           restarts <- computeRestarts(cond)
[16:05:19.556]                           for (restart in restarts) {
[16:05:19.556]                             name <- restart$name
[16:05:19.556]                             if (is.null(name)) 
[16:05:19.556]                               next
[16:05:19.556]                             if (!grepl(pattern, name)) 
[16:05:19.556]                               next
[16:05:19.556]                             invokeRestart(restart)
[16:05:19.556]                             muffled <- TRUE
[16:05:19.556]                             break
[16:05:19.556]                           }
[16:05:19.556]                         }
[16:05:19.556]                       }
[16:05:19.556]                       invisible(muffled)
[16:05:19.556]                     }
[16:05:19.556]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.556]                   }
[16:05:19.556]                 }
[16:05:19.556]                 else {
[16:05:19.556]                   if (TRUE) {
[16:05:19.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.556]                     {
[16:05:19.556]                       inherits <- base::inherits
[16:05:19.556]                       invokeRestart <- base::invokeRestart
[16:05:19.556]                       is.null <- base::is.null
[16:05:19.556]                       muffled <- FALSE
[16:05:19.556]                       if (inherits(cond, "message")) {
[16:05:19.556]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.556]                         if (muffled) 
[16:05:19.556]                           invokeRestart("muffleMessage")
[16:05:19.556]                       }
[16:05:19.556]                       else if (inherits(cond, "warning")) {
[16:05:19.556]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.556]                         if (muffled) 
[16:05:19.556]                           invokeRestart("muffleWarning")
[16:05:19.556]                       }
[16:05:19.556]                       else if (inherits(cond, "condition")) {
[16:05:19.556]                         if (!is.null(pattern)) {
[16:05:19.556]                           computeRestarts <- base::computeRestarts
[16:05:19.556]                           grepl <- base::grepl
[16:05:19.556]                           restarts <- computeRestarts(cond)
[16:05:19.556]                           for (restart in restarts) {
[16:05:19.556]                             name <- restart$name
[16:05:19.556]                             if (is.null(name)) 
[16:05:19.556]                               next
[16:05:19.556]                             if (!grepl(pattern, name)) 
[16:05:19.556]                               next
[16:05:19.556]                             invokeRestart(restart)
[16:05:19.556]                             muffled <- TRUE
[16:05:19.556]                             break
[16:05:19.556]                           }
[16:05:19.556]                         }
[16:05:19.556]                       }
[16:05:19.556]                       invisible(muffled)
[16:05:19.556]                     }
[16:05:19.556]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.556]                   }
[16:05:19.556]                 }
[16:05:19.556]             }
[16:05:19.556]         }))
[16:05:19.556]     }, error = function(ex) {
[16:05:19.556]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.556]                 ...future.rng), started = ...future.startTime, 
[16:05:19.556]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.556]             version = "1.8"), class = "FutureResult")
[16:05:19.556]     }, finally = {
[16:05:19.556]         if (!identical(...future.workdir, getwd())) 
[16:05:19.556]             setwd(...future.workdir)
[16:05:19.556]         {
[16:05:19.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.556]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.556]             }
[16:05:19.556]             base::options(...future.oldOptions)
[16:05:19.556]             if (.Platform$OS.type == "windows") {
[16:05:19.556]                 old_names <- names(...future.oldEnvVars)
[16:05:19.556]                 envs <- base::Sys.getenv()
[16:05:19.556]                 names <- names(envs)
[16:05:19.556]                 common <- intersect(names, old_names)
[16:05:19.556]                 added <- setdiff(names, old_names)
[16:05:19.556]                 removed <- setdiff(old_names, names)
[16:05:19.556]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.556]                   envs[common]]
[16:05:19.556]                 NAMES <- toupper(changed)
[16:05:19.556]                 args <- list()
[16:05:19.556]                 for (kk in seq_along(NAMES)) {
[16:05:19.556]                   name <- changed[[kk]]
[16:05:19.556]                   NAME <- NAMES[[kk]]
[16:05:19.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.556]                     next
[16:05:19.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.556]                 }
[16:05:19.556]                 NAMES <- toupper(added)
[16:05:19.556]                 for (kk in seq_along(NAMES)) {
[16:05:19.556]                   name <- added[[kk]]
[16:05:19.556]                   NAME <- NAMES[[kk]]
[16:05:19.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.556]                     next
[16:05:19.556]                   args[[name]] <- ""
[16:05:19.556]                 }
[16:05:19.556]                 NAMES <- toupper(removed)
[16:05:19.556]                 for (kk in seq_along(NAMES)) {
[16:05:19.556]                   name <- removed[[kk]]
[16:05:19.556]                   NAME <- NAMES[[kk]]
[16:05:19.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.556]                     next
[16:05:19.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.556]                 }
[16:05:19.556]                 if (length(args) > 0) 
[16:05:19.556]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.556]             }
[16:05:19.556]             else {
[16:05:19.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.556]             }
[16:05:19.556]             {
[16:05:19.556]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.556]                   0L) {
[16:05:19.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.556]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.556]                   base::options(opts)
[16:05:19.556]                 }
[16:05:19.556]                 {
[16:05:19.556]                   {
[16:05:19.556]                     NULL
[16:05:19.556]                     RNGkind("Mersenne-Twister")
[16:05:19.556]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.556]                       inherits = FALSE)
[16:05:19.556]                   }
[16:05:19.556]                   options(future.plan = NULL)
[16:05:19.556]                   if (is.na(NA_character_)) 
[16:05:19.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.556]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.556]                     envir = parent.frame()) 
[16:05:19.556]                   {
[16:05:19.556]                     default_workers <- missing(workers)
[16:05:19.556]                     if (is.function(workers)) 
[16:05:19.556]                       workers <- workers()
[16:05:19.556]                     workers <- structure(as.integer(workers), 
[16:05:19.556]                       class = class(workers))
[16:05:19.556]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.556]                       1L)
[16:05:19.556]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.556]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.556]                       if (default_workers) 
[16:05:19.556]                         supportsMulticore(warn = TRUE)
[16:05:19.556]                       return(sequential(..., envir = envir))
[16:05:19.556]                     }
[16:05:19.556]                     oopts <- options(mc.cores = workers)
[16:05:19.556]                     on.exit(options(oopts))
[16:05:19.556]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.556]                       envir = envir)
[16:05:19.556]                     if (!future$lazy) 
[16:05:19.556]                       future <- run(future)
[16:05:19.556]                     invisible(future)
[16:05:19.556]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.556]                 }
[16:05:19.556]             }
[16:05:19.556]         }
[16:05:19.556]     })
[16:05:19.556]     if (TRUE) {
[16:05:19.556]         base::sink(type = "output", split = FALSE)
[16:05:19.556]         if (TRUE) {
[16:05:19.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.556]         }
[16:05:19.556]         else {
[16:05:19.556]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.556]         }
[16:05:19.556]         base::close(...future.stdout)
[16:05:19.556]         ...future.stdout <- NULL
[16:05:19.556]     }
[16:05:19.556]     ...future.result$conditions <- ...future.conditions
[16:05:19.556]     ...future.result$finished <- base::Sys.time()
[16:05:19.556]     ...future.result
[16:05:19.556] }
[16:05:19.558] assign_globals() ...
[16:05:19.558] List of 1
[16:05:19.558]  $ a: num 0
[16:05:19.558]  - attr(*, "where")=List of 1
[16:05:19.558]   ..$ a:<environment: R_EmptyEnv> 
[16:05:19.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.558]  - attr(*, "resolved")= logi FALSE
[16:05:19.558]  - attr(*, "total_size")= num 56
[16:05:19.564] - copied ‘a’ to environment
[16:05:19.564] assign_globals() ... done
[16:05:19.565] plan(): Setting new future strategy stack:
[16:05:19.565] List of future strategies:
[16:05:19.565] 1. sequential:
[16:05:19.565]    - args: function (..., envir = parent.frame())
[16:05:19.565]    - tweaked: FALSE
[16:05:19.565]    - call: NULL
[16:05:19.565] plan(): nbrOfWorkers() = 1
[16:05:19.566] plan(): Setting new future strategy stack:
[16:05:19.566] List of future strategies:
[16:05:19.566] 1. multicore:
[16:05:19.566]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.566]    - tweaked: FALSE
[16:05:19.566]    - call: plan(multicore)
[16:05:19.569] plan(): nbrOfWorkers() = 1
[16:05:19.570] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[16:05:19.574] getGlobalsAndPackages() ...
[16:05:19.574] Searching for globals...
[16:05:19.574] - globals found: [2] ‘{’, ‘ii’
[16:05:19.575] Searching for globals ... DONE
[16:05:19.575] Resolving globals: FALSE
[16:05:19.575] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.575] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.576] - globals: [1] ‘ii’
[16:05:19.576] 
[16:05:19.576] getGlobalsAndPackages() ... DONE
[16:05:19.576] Packages needed by the future expression (n = 0): <none>
[16:05:19.576] Packages needed by future strategies (n = 0): <none>
[16:05:19.577] {
[16:05:19.577]     {
[16:05:19.577]         {
[16:05:19.577]             ...future.startTime <- base::Sys.time()
[16:05:19.577]             {
[16:05:19.577]                 {
[16:05:19.577]                   {
[16:05:19.577]                     base::local({
[16:05:19.577]                       has_future <- base::requireNamespace("future", 
[16:05:19.577]                         quietly = TRUE)
[16:05:19.577]                       if (has_future) {
[16:05:19.577]                         ns <- base::getNamespace("future")
[16:05:19.577]                         version <- ns[[".package"]][["version"]]
[16:05:19.577]                         if (is.null(version)) 
[16:05:19.577]                           version <- utils::packageVersion("future")
[16:05:19.577]                       }
[16:05:19.577]                       else {
[16:05:19.577]                         version <- NULL
[16:05:19.577]                       }
[16:05:19.577]                       if (!has_future || version < "1.8.0") {
[16:05:19.577]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.577]                           "", base::R.version$version.string), 
[16:05:19.577]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.577]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.577]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.577]                             "release", "version")], collapse = " "), 
[16:05:19.577]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.577]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.577]                           info)
[16:05:19.577]                         info <- base::paste(info, collapse = "; ")
[16:05:19.577]                         if (!has_future) {
[16:05:19.577]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.577]                             info)
[16:05:19.577]                         }
[16:05:19.577]                         else {
[16:05:19.577]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.577]                             info, version)
[16:05:19.577]                         }
[16:05:19.577]                         base::stop(msg)
[16:05:19.577]                       }
[16:05:19.577]                     })
[16:05:19.577]                   }
[16:05:19.577]                   options(future.plan = NULL)
[16:05:19.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.577]                 }
[16:05:19.577]                 ...future.workdir <- getwd()
[16:05:19.577]             }
[16:05:19.577]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.577]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.577]         }
[16:05:19.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.577]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.577]             base::names(...future.oldOptions))
[16:05:19.577]     }
[16:05:19.577]     if (FALSE) {
[16:05:19.577]     }
[16:05:19.577]     else {
[16:05:19.577]         if (TRUE) {
[16:05:19.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.577]                 open = "w")
[16:05:19.577]         }
[16:05:19.577]         else {
[16:05:19.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.577]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.577]         }
[16:05:19.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.577]             base::sink(type = "output", split = FALSE)
[16:05:19.577]             base::close(...future.stdout)
[16:05:19.577]         }, add = TRUE)
[16:05:19.577]     }
[16:05:19.577]     ...future.frame <- base::sys.nframe()
[16:05:19.577]     ...future.conditions <- base::list()
[16:05:19.577]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.577]     if (FALSE) {
[16:05:19.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.577]     }
[16:05:19.577]     ...future.result <- base::tryCatch({
[16:05:19.577]         base::withCallingHandlers({
[16:05:19.577]             ...future.value <- base::withVisible(base::local({
[16:05:19.577]                 ii
[16:05:19.577]             }))
[16:05:19.577]             future::FutureResult(value = ...future.value$value, 
[16:05:19.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.577]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.577]                     ...future.globalenv.names))
[16:05:19.577]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.577]         }, condition = base::local({
[16:05:19.577]             c <- base::c
[16:05:19.577]             inherits <- base::inherits
[16:05:19.577]             invokeRestart <- base::invokeRestart
[16:05:19.577]             length <- base::length
[16:05:19.577]             list <- base::list
[16:05:19.577]             seq.int <- base::seq.int
[16:05:19.577]             signalCondition <- base::signalCondition
[16:05:19.577]             sys.calls <- base::sys.calls
[16:05:19.577]             `[[` <- base::`[[`
[16:05:19.577]             `+` <- base::`+`
[16:05:19.577]             `<<-` <- base::`<<-`
[16:05:19.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.577]                   3L)]
[16:05:19.577]             }
[16:05:19.577]             function(cond) {
[16:05:19.577]                 is_error <- inherits(cond, "error")
[16:05:19.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.577]                   NULL)
[16:05:19.577]                 if (is_error) {
[16:05:19.577]                   sessionInformation <- function() {
[16:05:19.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.577]                       search = base::search(), system = base::Sys.info())
[16:05:19.577]                   }
[16:05:19.577]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.577]                     cond$call), session = sessionInformation(), 
[16:05:19.577]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.577]                   signalCondition(cond)
[16:05:19.577]                 }
[16:05:19.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.577]                 "immediateCondition"))) {
[16:05:19.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.577]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.577]                   if (TRUE && !signal) {
[16:05:19.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.577]                     {
[16:05:19.577]                       inherits <- base::inherits
[16:05:19.577]                       invokeRestart <- base::invokeRestart
[16:05:19.577]                       is.null <- base::is.null
[16:05:19.577]                       muffled <- FALSE
[16:05:19.577]                       if (inherits(cond, "message")) {
[16:05:19.577]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.577]                         if (muffled) 
[16:05:19.577]                           invokeRestart("muffleMessage")
[16:05:19.577]                       }
[16:05:19.577]                       else if (inherits(cond, "warning")) {
[16:05:19.577]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.577]                         if (muffled) 
[16:05:19.577]                           invokeRestart("muffleWarning")
[16:05:19.577]                       }
[16:05:19.577]                       else if (inherits(cond, "condition")) {
[16:05:19.577]                         if (!is.null(pattern)) {
[16:05:19.577]                           computeRestarts <- base::computeRestarts
[16:05:19.577]                           grepl <- base::grepl
[16:05:19.577]                           restarts <- computeRestarts(cond)
[16:05:19.577]                           for (restart in restarts) {
[16:05:19.577]                             name <- restart$name
[16:05:19.577]                             if (is.null(name)) 
[16:05:19.577]                               next
[16:05:19.577]                             if (!grepl(pattern, name)) 
[16:05:19.577]                               next
[16:05:19.577]                             invokeRestart(restart)
[16:05:19.577]                             muffled <- TRUE
[16:05:19.577]                             break
[16:05:19.577]                           }
[16:05:19.577]                         }
[16:05:19.577]                       }
[16:05:19.577]                       invisible(muffled)
[16:05:19.577]                     }
[16:05:19.577]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.577]                   }
[16:05:19.577]                 }
[16:05:19.577]                 else {
[16:05:19.577]                   if (TRUE) {
[16:05:19.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.577]                     {
[16:05:19.577]                       inherits <- base::inherits
[16:05:19.577]                       invokeRestart <- base::invokeRestart
[16:05:19.577]                       is.null <- base::is.null
[16:05:19.577]                       muffled <- FALSE
[16:05:19.577]                       if (inherits(cond, "message")) {
[16:05:19.577]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.577]                         if (muffled) 
[16:05:19.577]                           invokeRestart("muffleMessage")
[16:05:19.577]                       }
[16:05:19.577]                       else if (inherits(cond, "warning")) {
[16:05:19.577]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.577]                         if (muffled) 
[16:05:19.577]                           invokeRestart("muffleWarning")
[16:05:19.577]                       }
[16:05:19.577]                       else if (inherits(cond, "condition")) {
[16:05:19.577]                         if (!is.null(pattern)) {
[16:05:19.577]                           computeRestarts <- base::computeRestarts
[16:05:19.577]                           grepl <- base::grepl
[16:05:19.577]                           restarts <- computeRestarts(cond)
[16:05:19.577]                           for (restart in restarts) {
[16:05:19.577]                             name <- restart$name
[16:05:19.577]                             if (is.null(name)) 
[16:05:19.577]                               next
[16:05:19.577]                             if (!grepl(pattern, name)) 
[16:05:19.577]                               next
[16:05:19.577]                             invokeRestart(restart)
[16:05:19.577]                             muffled <- TRUE
[16:05:19.577]                             break
[16:05:19.577]                           }
[16:05:19.577]                         }
[16:05:19.577]                       }
[16:05:19.577]                       invisible(muffled)
[16:05:19.577]                     }
[16:05:19.577]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.577]                   }
[16:05:19.577]                 }
[16:05:19.577]             }
[16:05:19.577]         }))
[16:05:19.577]     }, error = function(ex) {
[16:05:19.577]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.577]                 ...future.rng), started = ...future.startTime, 
[16:05:19.577]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.577]             version = "1.8"), class = "FutureResult")
[16:05:19.577]     }, finally = {
[16:05:19.577]         if (!identical(...future.workdir, getwd())) 
[16:05:19.577]             setwd(...future.workdir)
[16:05:19.577]         {
[16:05:19.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.577]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.577]             }
[16:05:19.577]             base::options(...future.oldOptions)
[16:05:19.577]             if (.Platform$OS.type == "windows") {
[16:05:19.577]                 old_names <- names(...future.oldEnvVars)
[16:05:19.577]                 envs <- base::Sys.getenv()
[16:05:19.577]                 names <- names(envs)
[16:05:19.577]                 common <- intersect(names, old_names)
[16:05:19.577]                 added <- setdiff(names, old_names)
[16:05:19.577]                 removed <- setdiff(old_names, names)
[16:05:19.577]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.577]                   envs[common]]
[16:05:19.577]                 NAMES <- toupper(changed)
[16:05:19.577]                 args <- list()
[16:05:19.577]                 for (kk in seq_along(NAMES)) {
[16:05:19.577]                   name <- changed[[kk]]
[16:05:19.577]                   NAME <- NAMES[[kk]]
[16:05:19.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.577]                     next
[16:05:19.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.577]                 }
[16:05:19.577]                 NAMES <- toupper(added)
[16:05:19.577]                 for (kk in seq_along(NAMES)) {
[16:05:19.577]                   name <- added[[kk]]
[16:05:19.577]                   NAME <- NAMES[[kk]]
[16:05:19.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.577]                     next
[16:05:19.577]                   args[[name]] <- ""
[16:05:19.577]                 }
[16:05:19.577]                 NAMES <- toupper(removed)
[16:05:19.577]                 for (kk in seq_along(NAMES)) {
[16:05:19.577]                   name <- removed[[kk]]
[16:05:19.577]                   NAME <- NAMES[[kk]]
[16:05:19.577]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.577]                     next
[16:05:19.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.577]                 }
[16:05:19.577]                 if (length(args) > 0) 
[16:05:19.577]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.577]             }
[16:05:19.577]             else {
[16:05:19.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.577]             }
[16:05:19.577]             {
[16:05:19.577]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.577]                   0L) {
[16:05:19.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.577]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.577]                   base::options(opts)
[16:05:19.577]                 }
[16:05:19.577]                 {
[16:05:19.577]                   {
[16:05:19.577]                     NULL
[16:05:19.577]                     RNGkind("Mersenne-Twister")
[16:05:19.577]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.577]                       inherits = FALSE)
[16:05:19.577]                   }
[16:05:19.577]                   options(future.plan = NULL)
[16:05:19.577]                   if (is.na(NA_character_)) 
[16:05:19.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.577]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.577]                     envir = parent.frame()) 
[16:05:19.577]                   {
[16:05:19.577]                     default_workers <- missing(workers)
[16:05:19.577]                     if (is.function(workers)) 
[16:05:19.577]                       workers <- workers()
[16:05:19.577]                     workers <- structure(as.integer(workers), 
[16:05:19.577]                       class = class(workers))
[16:05:19.577]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.577]                       1L)
[16:05:19.577]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.577]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.577]                       if (default_workers) 
[16:05:19.577]                         supportsMulticore(warn = TRUE)
[16:05:19.577]                       return(sequential(..., envir = envir))
[16:05:19.577]                     }
[16:05:19.577]                     oopts <- options(mc.cores = workers)
[16:05:19.577]                     on.exit(options(oopts))
[16:05:19.577]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.577]                       envir = envir)
[16:05:19.577]                     if (!future$lazy) 
[16:05:19.577]                       future <- run(future)
[16:05:19.577]                     invisible(future)
[16:05:19.577]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.577]                 }
[16:05:19.577]             }
[16:05:19.577]         }
[16:05:19.577]     })
[16:05:19.577]     if (TRUE) {
[16:05:19.577]         base::sink(type = "output", split = FALSE)
[16:05:19.577]         if (TRUE) {
[16:05:19.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.577]         }
[16:05:19.577]         else {
[16:05:19.577]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.577]         }
[16:05:19.577]         base::close(...future.stdout)
[16:05:19.577]         ...future.stdout <- NULL
[16:05:19.577]     }
[16:05:19.577]     ...future.result$conditions <- ...future.conditions
[16:05:19.577]     ...future.result$finished <- base::Sys.time()
[16:05:19.577]     ...future.result
[16:05:19.577] }
[16:05:19.578] assign_globals() ...
[16:05:19.578] List of 1
[16:05:19.578]  $ ii: int 1
[16:05:19.578]  - attr(*, "where")=List of 1
[16:05:19.578]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.578]  - attr(*, "resolved")= logi FALSE
[16:05:19.578]  - attr(*, "total_size")= num 56
[16:05:19.580] - copied ‘ii’ to environment
[16:05:19.580] assign_globals() ... done
[16:05:19.581] plan(): Setting new future strategy stack:
[16:05:19.581] List of future strategies:
[16:05:19.581] 1. sequential:
[16:05:19.581]    - args: function (..., envir = parent.frame())
[16:05:19.581]    - tweaked: FALSE
[16:05:19.581]    - call: NULL
[16:05:19.581] plan(): nbrOfWorkers() = 1
[16:05:19.582] plan(): Setting new future strategy stack:
[16:05:19.582] List of future strategies:
[16:05:19.582] 1. multicore:
[16:05:19.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.582]    - tweaked: FALSE
[16:05:19.582]    - call: plan(multicore)
[16:05:19.585] plan(): nbrOfWorkers() = 1
[16:05:19.585] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[16:05:19.589] getGlobalsAndPackages() ...
[16:05:19.589] Searching for globals...
[16:05:19.589] - globals found: [2] ‘{’, ‘ii’
[16:05:19.590] Searching for globals ... DONE
[16:05:19.590] Resolving globals: FALSE
[16:05:19.590] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.590] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.590] - globals: [1] ‘ii’
[16:05:19.591] 
[16:05:19.591] getGlobalsAndPackages() ... DONE
[16:05:19.591] Packages needed by the future expression (n = 0): <none>
[16:05:19.591] Packages needed by future strategies (n = 0): <none>
[16:05:19.592] {
[16:05:19.592]     {
[16:05:19.592]         {
[16:05:19.592]             ...future.startTime <- base::Sys.time()
[16:05:19.592]             {
[16:05:19.592]                 {
[16:05:19.592]                   {
[16:05:19.592]                     base::local({
[16:05:19.592]                       has_future <- base::requireNamespace("future", 
[16:05:19.592]                         quietly = TRUE)
[16:05:19.592]                       if (has_future) {
[16:05:19.592]                         ns <- base::getNamespace("future")
[16:05:19.592]                         version <- ns[[".package"]][["version"]]
[16:05:19.592]                         if (is.null(version)) 
[16:05:19.592]                           version <- utils::packageVersion("future")
[16:05:19.592]                       }
[16:05:19.592]                       else {
[16:05:19.592]                         version <- NULL
[16:05:19.592]                       }
[16:05:19.592]                       if (!has_future || version < "1.8.0") {
[16:05:19.592]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.592]                           "", base::R.version$version.string), 
[16:05:19.592]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.592]                             "release", "version")], collapse = " "), 
[16:05:19.592]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.592]                           info)
[16:05:19.592]                         info <- base::paste(info, collapse = "; ")
[16:05:19.592]                         if (!has_future) {
[16:05:19.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.592]                             info)
[16:05:19.592]                         }
[16:05:19.592]                         else {
[16:05:19.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.592]                             info, version)
[16:05:19.592]                         }
[16:05:19.592]                         base::stop(msg)
[16:05:19.592]                       }
[16:05:19.592]                     })
[16:05:19.592]                   }
[16:05:19.592]                   options(future.plan = NULL)
[16:05:19.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.592]                 }
[16:05:19.592]                 ...future.workdir <- getwd()
[16:05:19.592]             }
[16:05:19.592]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.592]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.592]         }
[16:05:19.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.592]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.592]             base::names(...future.oldOptions))
[16:05:19.592]     }
[16:05:19.592]     if (FALSE) {
[16:05:19.592]     }
[16:05:19.592]     else {
[16:05:19.592]         if (TRUE) {
[16:05:19.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.592]                 open = "w")
[16:05:19.592]         }
[16:05:19.592]         else {
[16:05:19.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.592]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.592]         }
[16:05:19.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.592]             base::sink(type = "output", split = FALSE)
[16:05:19.592]             base::close(...future.stdout)
[16:05:19.592]         }, add = TRUE)
[16:05:19.592]     }
[16:05:19.592]     ...future.frame <- base::sys.nframe()
[16:05:19.592]     ...future.conditions <- base::list()
[16:05:19.592]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.592]     if (FALSE) {
[16:05:19.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.592]     }
[16:05:19.592]     ...future.result <- base::tryCatch({
[16:05:19.592]         base::withCallingHandlers({
[16:05:19.592]             ...future.value <- base::withVisible(base::local({
[16:05:19.592]                 ii
[16:05:19.592]             }))
[16:05:19.592]             future::FutureResult(value = ...future.value$value, 
[16:05:19.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.592]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.592]                     ...future.globalenv.names))
[16:05:19.592]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.592]         }, condition = base::local({
[16:05:19.592]             c <- base::c
[16:05:19.592]             inherits <- base::inherits
[16:05:19.592]             invokeRestart <- base::invokeRestart
[16:05:19.592]             length <- base::length
[16:05:19.592]             list <- base::list
[16:05:19.592]             seq.int <- base::seq.int
[16:05:19.592]             signalCondition <- base::signalCondition
[16:05:19.592]             sys.calls <- base::sys.calls
[16:05:19.592]             `[[` <- base::`[[`
[16:05:19.592]             `+` <- base::`+`
[16:05:19.592]             `<<-` <- base::`<<-`
[16:05:19.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.592]                   3L)]
[16:05:19.592]             }
[16:05:19.592]             function(cond) {
[16:05:19.592]                 is_error <- inherits(cond, "error")
[16:05:19.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.592]                   NULL)
[16:05:19.592]                 if (is_error) {
[16:05:19.592]                   sessionInformation <- function() {
[16:05:19.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.592]                       search = base::search(), system = base::Sys.info())
[16:05:19.592]                   }
[16:05:19.592]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.592]                     cond$call), session = sessionInformation(), 
[16:05:19.592]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.592]                   signalCondition(cond)
[16:05:19.592]                 }
[16:05:19.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.592]                 "immediateCondition"))) {
[16:05:19.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.592]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.592]                   if (TRUE && !signal) {
[16:05:19.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.592]                     {
[16:05:19.592]                       inherits <- base::inherits
[16:05:19.592]                       invokeRestart <- base::invokeRestart
[16:05:19.592]                       is.null <- base::is.null
[16:05:19.592]                       muffled <- FALSE
[16:05:19.592]                       if (inherits(cond, "message")) {
[16:05:19.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.592]                         if (muffled) 
[16:05:19.592]                           invokeRestart("muffleMessage")
[16:05:19.592]                       }
[16:05:19.592]                       else if (inherits(cond, "warning")) {
[16:05:19.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.592]                         if (muffled) 
[16:05:19.592]                           invokeRestart("muffleWarning")
[16:05:19.592]                       }
[16:05:19.592]                       else if (inherits(cond, "condition")) {
[16:05:19.592]                         if (!is.null(pattern)) {
[16:05:19.592]                           computeRestarts <- base::computeRestarts
[16:05:19.592]                           grepl <- base::grepl
[16:05:19.592]                           restarts <- computeRestarts(cond)
[16:05:19.592]                           for (restart in restarts) {
[16:05:19.592]                             name <- restart$name
[16:05:19.592]                             if (is.null(name)) 
[16:05:19.592]                               next
[16:05:19.592]                             if (!grepl(pattern, name)) 
[16:05:19.592]                               next
[16:05:19.592]                             invokeRestart(restart)
[16:05:19.592]                             muffled <- TRUE
[16:05:19.592]                             break
[16:05:19.592]                           }
[16:05:19.592]                         }
[16:05:19.592]                       }
[16:05:19.592]                       invisible(muffled)
[16:05:19.592]                     }
[16:05:19.592]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.592]                   }
[16:05:19.592]                 }
[16:05:19.592]                 else {
[16:05:19.592]                   if (TRUE) {
[16:05:19.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.592]                     {
[16:05:19.592]                       inherits <- base::inherits
[16:05:19.592]                       invokeRestart <- base::invokeRestart
[16:05:19.592]                       is.null <- base::is.null
[16:05:19.592]                       muffled <- FALSE
[16:05:19.592]                       if (inherits(cond, "message")) {
[16:05:19.592]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.592]                         if (muffled) 
[16:05:19.592]                           invokeRestart("muffleMessage")
[16:05:19.592]                       }
[16:05:19.592]                       else if (inherits(cond, "warning")) {
[16:05:19.592]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.592]                         if (muffled) 
[16:05:19.592]                           invokeRestart("muffleWarning")
[16:05:19.592]                       }
[16:05:19.592]                       else if (inherits(cond, "condition")) {
[16:05:19.592]                         if (!is.null(pattern)) {
[16:05:19.592]                           computeRestarts <- base::computeRestarts
[16:05:19.592]                           grepl <- base::grepl
[16:05:19.592]                           restarts <- computeRestarts(cond)
[16:05:19.592]                           for (restart in restarts) {
[16:05:19.592]                             name <- restart$name
[16:05:19.592]                             if (is.null(name)) 
[16:05:19.592]                               next
[16:05:19.592]                             if (!grepl(pattern, name)) 
[16:05:19.592]                               next
[16:05:19.592]                             invokeRestart(restart)
[16:05:19.592]                             muffled <- TRUE
[16:05:19.592]                             break
[16:05:19.592]                           }
[16:05:19.592]                         }
[16:05:19.592]                       }
[16:05:19.592]                       invisible(muffled)
[16:05:19.592]                     }
[16:05:19.592]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.592]                   }
[16:05:19.592]                 }
[16:05:19.592]             }
[16:05:19.592]         }))
[16:05:19.592]     }, error = function(ex) {
[16:05:19.592]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.592]                 ...future.rng), started = ...future.startTime, 
[16:05:19.592]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.592]             version = "1.8"), class = "FutureResult")
[16:05:19.592]     }, finally = {
[16:05:19.592]         if (!identical(...future.workdir, getwd())) 
[16:05:19.592]             setwd(...future.workdir)
[16:05:19.592]         {
[16:05:19.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.592]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.592]             }
[16:05:19.592]             base::options(...future.oldOptions)
[16:05:19.592]             if (.Platform$OS.type == "windows") {
[16:05:19.592]                 old_names <- names(...future.oldEnvVars)
[16:05:19.592]                 envs <- base::Sys.getenv()
[16:05:19.592]                 names <- names(envs)
[16:05:19.592]                 common <- intersect(names, old_names)
[16:05:19.592]                 added <- setdiff(names, old_names)
[16:05:19.592]                 removed <- setdiff(old_names, names)
[16:05:19.592]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.592]                   envs[common]]
[16:05:19.592]                 NAMES <- toupper(changed)
[16:05:19.592]                 args <- list()
[16:05:19.592]                 for (kk in seq_along(NAMES)) {
[16:05:19.592]                   name <- changed[[kk]]
[16:05:19.592]                   NAME <- NAMES[[kk]]
[16:05:19.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.592]                     next
[16:05:19.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.592]                 }
[16:05:19.592]                 NAMES <- toupper(added)
[16:05:19.592]                 for (kk in seq_along(NAMES)) {
[16:05:19.592]                   name <- added[[kk]]
[16:05:19.592]                   NAME <- NAMES[[kk]]
[16:05:19.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.592]                     next
[16:05:19.592]                   args[[name]] <- ""
[16:05:19.592]                 }
[16:05:19.592]                 NAMES <- toupper(removed)
[16:05:19.592]                 for (kk in seq_along(NAMES)) {
[16:05:19.592]                   name <- removed[[kk]]
[16:05:19.592]                   NAME <- NAMES[[kk]]
[16:05:19.592]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.592]                     next
[16:05:19.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.592]                 }
[16:05:19.592]                 if (length(args) > 0) 
[16:05:19.592]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.592]             }
[16:05:19.592]             else {
[16:05:19.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.592]             }
[16:05:19.592]             {
[16:05:19.592]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.592]                   0L) {
[16:05:19.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.592]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.592]                   base::options(opts)
[16:05:19.592]                 }
[16:05:19.592]                 {
[16:05:19.592]                   {
[16:05:19.592]                     NULL
[16:05:19.592]                     RNGkind("Mersenne-Twister")
[16:05:19.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.592]                       inherits = FALSE)
[16:05:19.592]                   }
[16:05:19.592]                   options(future.plan = NULL)
[16:05:19.592]                   if (is.na(NA_character_)) 
[16:05:19.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.592]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.592]                     envir = parent.frame()) 
[16:05:19.592]                   {
[16:05:19.592]                     default_workers <- missing(workers)
[16:05:19.592]                     if (is.function(workers)) 
[16:05:19.592]                       workers <- workers()
[16:05:19.592]                     workers <- structure(as.integer(workers), 
[16:05:19.592]                       class = class(workers))
[16:05:19.592]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.592]                       1L)
[16:05:19.592]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.592]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.592]                       if (default_workers) 
[16:05:19.592]                         supportsMulticore(warn = TRUE)
[16:05:19.592]                       return(sequential(..., envir = envir))
[16:05:19.592]                     }
[16:05:19.592]                     oopts <- options(mc.cores = workers)
[16:05:19.592]                     on.exit(options(oopts))
[16:05:19.592]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.592]                       envir = envir)
[16:05:19.592]                     if (!future$lazy) 
[16:05:19.592]                       future <- run(future)
[16:05:19.592]                     invisible(future)
[16:05:19.592]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.592]                 }
[16:05:19.592]             }
[16:05:19.592]         }
[16:05:19.592]     })
[16:05:19.592]     if (TRUE) {
[16:05:19.592]         base::sink(type = "output", split = FALSE)
[16:05:19.592]         if (TRUE) {
[16:05:19.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.592]         }
[16:05:19.592]         else {
[16:05:19.592]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.592]         }
[16:05:19.592]         base::close(...future.stdout)
[16:05:19.592]         ...future.stdout <- NULL
[16:05:19.592]     }
[16:05:19.592]     ...future.result$conditions <- ...future.conditions
[16:05:19.592]     ...future.result$finished <- base::Sys.time()
[16:05:19.592]     ...future.result
[16:05:19.592] }
[16:05:19.593] assign_globals() ...
[16:05:19.593] List of 1
[16:05:19.593]  $ ii: int 2
[16:05:19.593]  - attr(*, "where")=List of 1
[16:05:19.593]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.593]  - attr(*, "resolved")= logi FALSE
[16:05:19.593]  - attr(*, "total_size")= num 56
[16:05:19.595] - copied ‘ii’ to environment
[16:05:19.595] assign_globals() ... done
[16:05:19.596] plan(): Setting new future strategy stack:
[16:05:19.596] List of future strategies:
[16:05:19.596] 1. sequential:
[16:05:19.596]    - args: function (..., envir = parent.frame())
[16:05:19.596]    - tweaked: FALSE
[16:05:19.596]    - call: NULL
[16:05:19.596] plan(): nbrOfWorkers() = 1
[16:05:19.597] plan(): Setting new future strategy stack:
[16:05:19.597] List of future strategies:
[16:05:19.597] 1. multicore:
[16:05:19.597]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.597]    - tweaked: FALSE
[16:05:19.597]    - call: plan(multicore)
[16:05:19.600] plan(): nbrOfWorkers() = 1
[16:05:19.600] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[16:05:19.604] getGlobalsAndPackages() ...
[16:05:19.604] Searching for globals...
[16:05:19.604] - globals found: [2] ‘{’, ‘ii’
[16:05:19.605] Searching for globals ... DONE
[16:05:19.605] Resolving globals: FALSE
[16:05:19.605] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.607] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.607] - globals: [1] ‘ii’
[16:05:19.607] 
[16:05:19.607] getGlobalsAndPackages() ... DONE
[16:05:19.608] Packages needed by the future expression (n = 0): <none>
[16:05:19.608] Packages needed by future strategies (n = 0): <none>
[16:05:19.608] {
[16:05:19.608]     {
[16:05:19.608]         {
[16:05:19.608]             ...future.startTime <- base::Sys.time()
[16:05:19.608]             {
[16:05:19.608]                 {
[16:05:19.608]                   {
[16:05:19.608]                     base::local({
[16:05:19.608]                       has_future <- base::requireNamespace("future", 
[16:05:19.608]                         quietly = TRUE)
[16:05:19.608]                       if (has_future) {
[16:05:19.608]                         ns <- base::getNamespace("future")
[16:05:19.608]                         version <- ns[[".package"]][["version"]]
[16:05:19.608]                         if (is.null(version)) 
[16:05:19.608]                           version <- utils::packageVersion("future")
[16:05:19.608]                       }
[16:05:19.608]                       else {
[16:05:19.608]                         version <- NULL
[16:05:19.608]                       }
[16:05:19.608]                       if (!has_future || version < "1.8.0") {
[16:05:19.608]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.608]                           "", base::R.version$version.string), 
[16:05:19.608]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.608]                             "release", "version")], collapse = " "), 
[16:05:19.608]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.608]                           info)
[16:05:19.608]                         info <- base::paste(info, collapse = "; ")
[16:05:19.608]                         if (!has_future) {
[16:05:19.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.608]                             info)
[16:05:19.608]                         }
[16:05:19.608]                         else {
[16:05:19.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.608]                             info, version)
[16:05:19.608]                         }
[16:05:19.608]                         base::stop(msg)
[16:05:19.608]                       }
[16:05:19.608]                     })
[16:05:19.608]                   }
[16:05:19.608]                   options(future.plan = NULL)
[16:05:19.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.608]                 }
[16:05:19.608]                 ...future.workdir <- getwd()
[16:05:19.608]             }
[16:05:19.608]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.608]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.608]         }
[16:05:19.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.608]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.608]             base::names(...future.oldOptions))
[16:05:19.608]     }
[16:05:19.608]     if (FALSE) {
[16:05:19.608]     }
[16:05:19.608]     else {
[16:05:19.608]         if (TRUE) {
[16:05:19.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.608]                 open = "w")
[16:05:19.608]         }
[16:05:19.608]         else {
[16:05:19.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.608]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.608]         }
[16:05:19.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.608]             base::sink(type = "output", split = FALSE)
[16:05:19.608]             base::close(...future.stdout)
[16:05:19.608]         }, add = TRUE)
[16:05:19.608]     }
[16:05:19.608]     ...future.frame <- base::sys.nframe()
[16:05:19.608]     ...future.conditions <- base::list()
[16:05:19.608]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.608]     if (FALSE) {
[16:05:19.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.608]     }
[16:05:19.608]     ...future.result <- base::tryCatch({
[16:05:19.608]         base::withCallingHandlers({
[16:05:19.608]             ...future.value <- base::withVisible(base::local({
[16:05:19.608]                 ii
[16:05:19.608]             }))
[16:05:19.608]             future::FutureResult(value = ...future.value$value, 
[16:05:19.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.608]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.608]                     ...future.globalenv.names))
[16:05:19.608]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.608]         }, condition = base::local({
[16:05:19.608]             c <- base::c
[16:05:19.608]             inherits <- base::inherits
[16:05:19.608]             invokeRestart <- base::invokeRestart
[16:05:19.608]             length <- base::length
[16:05:19.608]             list <- base::list
[16:05:19.608]             seq.int <- base::seq.int
[16:05:19.608]             signalCondition <- base::signalCondition
[16:05:19.608]             sys.calls <- base::sys.calls
[16:05:19.608]             `[[` <- base::`[[`
[16:05:19.608]             `+` <- base::`+`
[16:05:19.608]             `<<-` <- base::`<<-`
[16:05:19.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.608]                   3L)]
[16:05:19.608]             }
[16:05:19.608]             function(cond) {
[16:05:19.608]                 is_error <- inherits(cond, "error")
[16:05:19.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.608]                   NULL)
[16:05:19.608]                 if (is_error) {
[16:05:19.608]                   sessionInformation <- function() {
[16:05:19.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.608]                       search = base::search(), system = base::Sys.info())
[16:05:19.608]                   }
[16:05:19.608]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.608]                     cond$call), session = sessionInformation(), 
[16:05:19.608]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.608]                   signalCondition(cond)
[16:05:19.608]                 }
[16:05:19.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.608]                 "immediateCondition"))) {
[16:05:19.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.608]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.608]                   if (TRUE && !signal) {
[16:05:19.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.608]                     {
[16:05:19.608]                       inherits <- base::inherits
[16:05:19.608]                       invokeRestart <- base::invokeRestart
[16:05:19.608]                       is.null <- base::is.null
[16:05:19.608]                       muffled <- FALSE
[16:05:19.608]                       if (inherits(cond, "message")) {
[16:05:19.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.608]                         if (muffled) 
[16:05:19.608]                           invokeRestart("muffleMessage")
[16:05:19.608]                       }
[16:05:19.608]                       else if (inherits(cond, "warning")) {
[16:05:19.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.608]                         if (muffled) 
[16:05:19.608]                           invokeRestart("muffleWarning")
[16:05:19.608]                       }
[16:05:19.608]                       else if (inherits(cond, "condition")) {
[16:05:19.608]                         if (!is.null(pattern)) {
[16:05:19.608]                           computeRestarts <- base::computeRestarts
[16:05:19.608]                           grepl <- base::grepl
[16:05:19.608]                           restarts <- computeRestarts(cond)
[16:05:19.608]                           for (restart in restarts) {
[16:05:19.608]                             name <- restart$name
[16:05:19.608]                             if (is.null(name)) 
[16:05:19.608]                               next
[16:05:19.608]                             if (!grepl(pattern, name)) 
[16:05:19.608]                               next
[16:05:19.608]                             invokeRestart(restart)
[16:05:19.608]                             muffled <- TRUE
[16:05:19.608]                             break
[16:05:19.608]                           }
[16:05:19.608]                         }
[16:05:19.608]                       }
[16:05:19.608]                       invisible(muffled)
[16:05:19.608]                     }
[16:05:19.608]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.608]                   }
[16:05:19.608]                 }
[16:05:19.608]                 else {
[16:05:19.608]                   if (TRUE) {
[16:05:19.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.608]                     {
[16:05:19.608]                       inherits <- base::inherits
[16:05:19.608]                       invokeRestart <- base::invokeRestart
[16:05:19.608]                       is.null <- base::is.null
[16:05:19.608]                       muffled <- FALSE
[16:05:19.608]                       if (inherits(cond, "message")) {
[16:05:19.608]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.608]                         if (muffled) 
[16:05:19.608]                           invokeRestart("muffleMessage")
[16:05:19.608]                       }
[16:05:19.608]                       else if (inherits(cond, "warning")) {
[16:05:19.608]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.608]                         if (muffled) 
[16:05:19.608]                           invokeRestart("muffleWarning")
[16:05:19.608]                       }
[16:05:19.608]                       else if (inherits(cond, "condition")) {
[16:05:19.608]                         if (!is.null(pattern)) {
[16:05:19.608]                           computeRestarts <- base::computeRestarts
[16:05:19.608]                           grepl <- base::grepl
[16:05:19.608]                           restarts <- computeRestarts(cond)
[16:05:19.608]                           for (restart in restarts) {
[16:05:19.608]                             name <- restart$name
[16:05:19.608]                             if (is.null(name)) 
[16:05:19.608]                               next
[16:05:19.608]                             if (!grepl(pattern, name)) 
[16:05:19.608]                               next
[16:05:19.608]                             invokeRestart(restart)
[16:05:19.608]                             muffled <- TRUE
[16:05:19.608]                             break
[16:05:19.608]                           }
[16:05:19.608]                         }
[16:05:19.608]                       }
[16:05:19.608]                       invisible(muffled)
[16:05:19.608]                     }
[16:05:19.608]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.608]                   }
[16:05:19.608]                 }
[16:05:19.608]             }
[16:05:19.608]         }))
[16:05:19.608]     }, error = function(ex) {
[16:05:19.608]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.608]                 ...future.rng), started = ...future.startTime, 
[16:05:19.608]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.608]             version = "1.8"), class = "FutureResult")
[16:05:19.608]     }, finally = {
[16:05:19.608]         if (!identical(...future.workdir, getwd())) 
[16:05:19.608]             setwd(...future.workdir)
[16:05:19.608]         {
[16:05:19.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.608]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.608]             }
[16:05:19.608]             base::options(...future.oldOptions)
[16:05:19.608]             if (.Platform$OS.type == "windows") {
[16:05:19.608]                 old_names <- names(...future.oldEnvVars)
[16:05:19.608]                 envs <- base::Sys.getenv()
[16:05:19.608]                 names <- names(envs)
[16:05:19.608]                 common <- intersect(names, old_names)
[16:05:19.608]                 added <- setdiff(names, old_names)
[16:05:19.608]                 removed <- setdiff(old_names, names)
[16:05:19.608]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.608]                   envs[common]]
[16:05:19.608]                 NAMES <- toupper(changed)
[16:05:19.608]                 args <- list()
[16:05:19.608]                 for (kk in seq_along(NAMES)) {
[16:05:19.608]                   name <- changed[[kk]]
[16:05:19.608]                   NAME <- NAMES[[kk]]
[16:05:19.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.608]                     next
[16:05:19.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.608]                 }
[16:05:19.608]                 NAMES <- toupper(added)
[16:05:19.608]                 for (kk in seq_along(NAMES)) {
[16:05:19.608]                   name <- added[[kk]]
[16:05:19.608]                   NAME <- NAMES[[kk]]
[16:05:19.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.608]                     next
[16:05:19.608]                   args[[name]] <- ""
[16:05:19.608]                 }
[16:05:19.608]                 NAMES <- toupper(removed)
[16:05:19.608]                 for (kk in seq_along(NAMES)) {
[16:05:19.608]                   name <- removed[[kk]]
[16:05:19.608]                   NAME <- NAMES[[kk]]
[16:05:19.608]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.608]                     next
[16:05:19.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.608]                 }
[16:05:19.608]                 if (length(args) > 0) 
[16:05:19.608]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.608]             }
[16:05:19.608]             else {
[16:05:19.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.608]             }
[16:05:19.608]             {
[16:05:19.608]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.608]                   0L) {
[16:05:19.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.608]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.608]                   base::options(opts)
[16:05:19.608]                 }
[16:05:19.608]                 {
[16:05:19.608]                   {
[16:05:19.608]                     NULL
[16:05:19.608]                     RNGkind("Mersenne-Twister")
[16:05:19.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.608]                       inherits = FALSE)
[16:05:19.608]                   }
[16:05:19.608]                   options(future.plan = NULL)
[16:05:19.608]                   if (is.na(NA_character_)) 
[16:05:19.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.608]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.608]                     envir = parent.frame()) 
[16:05:19.608]                   {
[16:05:19.608]                     default_workers <- missing(workers)
[16:05:19.608]                     if (is.function(workers)) 
[16:05:19.608]                       workers <- workers()
[16:05:19.608]                     workers <- structure(as.integer(workers), 
[16:05:19.608]                       class = class(workers))
[16:05:19.608]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.608]                       1L)
[16:05:19.608]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.608]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.608]                       if (default_workers) 
[16:05:19.608]                         supportsMulticore(warn = TRUE)
[16:05:19.608]                       return(sequential(..., envir = envir))
[16:05:19.608]                     }
[16:05:19.608]                     oopts <- options(mc.cores = workers)
[16:05:19.608]                     on.exit(options(oopts))
[16:05:19.608]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.608]                       envir = envir)
[16:05:19.608]                     if (!future$lazy) 
[16:05:19.608]                       future <- run(future)
[16:05:19.608]                     invisible(future)
[16:05:19.608]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.608]                 }
[16:05:19.608]             }
[16:05:19.608]         }
[16:05:19.608]     })
[16:05:19.608]     if (TRUE) {
[16:05:19.608]         base::sink(type = "output", split = FALSE)
[16:05:19.608]         if (TRUE) {
[16:05:19.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.608]         }
[16:05:19.608]         else {
[16:05:19.608]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.608]         }
[16:05:19.608]         base::close(...future.stdout)
[16:05:19.608]         ...future.stdout <- NULL
[16:05:19.608]     }
[16:05:19.608]     ...future.result$conditions <- ...future.conditions
[16:05:19.608]     ...future.result$finished <- base::Sys.time()
[16:05:19.608]     ...future.result
[16:05:19.608] }
[16:05:19.610] assign_globals() ...
[16:05:19.610] List of 1
[16:05:19.610]  $ ii: int 3
[16:05:19.610]  - attr(*, "where")=List of 1
[16:05:19.610]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.610]  - attr(*, "resolved")= logi FALSE
[16:05:19.610]  - attr(*, "total_size")= num 56
[16:05:19.612] - copied ‘ii’ to environment
[16:05:19.612] assign_globals() ... done
[16:05:19.612] plan(): Setting new future strategy stack:
[16:05:19.612] List of future strategies:
[16:05:19.612] 1. sequential:
[16:05:19.612]    - args: function (..., envir = parent.frame())
[16:05:19.612]    - tweaked: FALSE
[16:05:19.612]    - call: NULL
[16:05:19.613] plan(): nbrOfWorkers() = 1
[16:05:19.613] plan(): Setting new future strategy stack:
[16:05:19.614] List of future strategies:
[16:05:19.614] 1. multicore:
[16:05:19.614]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.614]    - tweaked: FALSE
[16:05:19.614]    - call: plan(multicore)
[16:05:19.617] plan(): nbrOfWorkers() = 1
[16:05:19.617] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[16:05:19.620] getGlobalsAndPackages() ...
[16:05:19.620] Searching for globals...
[16:05:19.621] - globals found: [2] ‘{’, ‘ii’
[16:05:19.621] Searching for globals ... DONE
[16:05:19.621] Resolving globals: FALSE
[16:05:19.622] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.622] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.622] - globals: [1] ‘ii’
[16:05:19.622] 
[16:05:19.622] getGlobalsAndPackages() ... DONE
[16:05:19.622] Packages needed by the future expression (n = 0): <none>
[16:05:19.623] Packages needed by future strategies (n = 0): <none>
[16:05:19.623] {
[16:05:19.623]     {
[16:05:19.623]         {
[16:05:19.623]             ...future.startTime <- base::Sys.time()
[16:05:19.623]             {
[16:05:19.623]                 {
[16:05:19.623]                   {
[16:05:19.623]                     base::local({
[16:05:19.623]                       has_future <- base::requireNamespace("future", 
[16:05:19.623]                         quietly = TRUE)
[16:05:19.623]                       if (has_future) {
[16:05:19.623]                         ns <- base::getNamespace("future")
[16:05:19.623]                         version <- ns[[".package"]][["version"]]
[16:05:19.623]                         if (is.null(version)) 
[16:05:19.623]                           version <- utils::packageVersion("future")
[16:05:19.623]                       }
[16:05:19.623]                       else {
[16:05:19.623]                         version <- NULL
[16:05:19.623]                       }
[16:05:19.623]                       if (!has_future || version < "1.8.0") {
[16:05:19.623]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.623]                           "", base::R.version$version.string), 
[16:05:19.623]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.623]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.623]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.623]                             "release", "version")], collapse = " "), 
[16:05:19.623]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.623]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.623]                           info)
[16:05:19.623]                         info <- base::paste(info, collapse = "; ")
[16:05:19.623]                         if (!has_future) {
[16:05:19.623]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.623]                             info)
[16:05:19.623]                         }
[16:05:19.623]                         else {
[16:05:19.623]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.623]                             info, version)
[16:05:19.623]                         }
[16:05:19.623]                         base::stop(msg)
[16:05:19.623]                       }
[16:05:19.623]                     })
[16:05:19.623]                   }
[16:05:19.623]                   options(future.plan = NULL)
[16:05:19.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.623]                 }
[16:05:19.623]                 ...future.workdir <- getwd()
[16:05:19.623]             }
[16:05:19.623]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.623]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.623]         }
[16:05:19.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.623]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.623]             base::names(...future.oldOptions))
[16:05:19.623]     }
[16:05:19.623]     if (FALSE) {
[16:05:19.623]     }
[16:05:19.623]     else {
[16:05:19.623]         if (TRUE) {
[16:05:19.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.623]                 open = "w")
[16:05:19.623]         }
[16:05:19.623]         else {
[16:05:19.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.623]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.623]         }
[16:05:19.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.623]             base::sink(type = "output", split = FALSE)
[16:05:19.623]             base::close(...future.stdout)
[16:05:19.623]         }, add = TRUE)
[16:05:19.623]     }
[16:05:19.623]     ...future.frame <- base::sys.nframe()
[16:05:19.623]     ...future.conditions <- base::list()
[16:05:19.623]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.623]     if (FALSE) {
[16:05:19.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.623]     }
[16:05:19.623]     ...future.result <- base::tryCatch({
[16:05:19.623]         base::withCallingHandlers({
[16:05:19.623]             ...future.value <- base::withVisible(base::local({
[16:05:19.623]                 ii
[16:05:19.623]             }))
[16:05:19.623]             future::FutureResult(value = ...future.value$value, 
[16:05:19.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.623]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.623]                     ...future.globalenv.names))
[16:05:19.623]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.623]         }, condition = base::local({
[16:05:19.623]             c <- base::c
[16:05:19.623]             inherits <- base::inherits
[16:05:19.623]             invokeRestart <- base::invokeRestart
[16:05:19.623]             length <- base::length
[16:05:19.623]             list <- base::list
[16:05:19.623]             seq.int <- base::seq.int
[16:05:19.623]             signalCondition <- base::signalCondition
[16:05:19.623]             sys.calls <- base::sys.calls
[16:05:19.623]             `[[` <- base::`[[`
[16:05:19.623]             `+` <- base::`+`
[16:05:19.623]             `<<-` <- base::`<<-`
[16:05:19.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.623]                   3L)]
[16:05:19.623]             }
[16:05:19.623]             function(cond) {
[16:05:19.623]                 is_error <- inherits(cond, "error")
[16:05:19.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.623]                   NULL)
[16:05:19.623]                 if (is_error) {
[16:05:19.623]                   sessionInformation <- function() {
[16:05:19.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.623]                       search = base::search(), system = base::Sys.info())
[16:05:19.623]                   }
[16:05:19.623]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.623]                     cond$call), session = sessionInformation(), 
[16:05:19.623]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.623]                   signalCondition(cond)
[16:05:19.623]                 }
[16:05:19.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.623]                 "immediateCondition"))) {
[16:05:19.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.623]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.623]                   if (TRUE && !signal) {
[16:05:19.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.623]                     {
[16:05:19.623]                       inherits <- base::inherits
[16:05:19.623]                       invokeRestart <- base::invokeRestart
[16:05:19.623]                       is.null <- base::is.null
[16:05:19.623]                       muffled <- FALSE
[16:05:19.623]                       if (inherits(cond, "message")) {
[16:05:19.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.623]                         if (muffled) 
[16:05:19.623]                           invokeRestart("muffleMessage")
[16:05:19.623]                       }
[16:05:19.623]                       else if (inherits(cond, "warning")) {
[16:05:19.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.623]                         if (muffled) 
[16:05:19.623]                           invokeRestart("muffleWarning")
[16:05:19.623]                       }
[16:05:19.623]                       else if (inherits(cond, "condition")) {
[16:05:19.623]                         if (!is.null(pattern)) {
[16:05:19.623]                           computeRestarts <- base::computeRestarts
[16:05:19.623]                           grepl <- base::grepl
[16:05:19.623]                           restarts <- computeRestarts(cond)
[16:05:19.623]                           for (restart in restarts) {
[16:05:19.623]                             name <- restart$name
[16:05:19.623]                             if (is.null(name)) 
[16:05:19.623]                               next
[16:05:19.623]                             if (!grepl(pattern, name)) 
[16:05:19.623]                               next
[16:05:19.623]                             invokeRestart(restart)
[16:05:19.623]                             muffled <- TRUE
[16:05:19.623]                             break
[16:05:19.623]                           }
[16:05:19.623]                         }
[16:05:19.623]                       }
[16:05:19.623]                       invisible(muffled)
[16:05:19.623]                     }
[16:05:19.623]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.623]                   }
[16:05:19.623]                 }
[16:05:19.623]                 else {
[16:05:19.623]                   if (TRUE) {
[16:05:19.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.623]                     {
[16:05:19.623]                       inherits <- base::inherits
[16:05:19.623]                       invokeRestart <- base::invokeRestart
[16:05:19.623]                       is.null <- base::is.null
[16:05:19.623]                       muffled <- FALSE
[16:05:19.623]                       if (inherits(cond, "message")) {
[16:05:19.623]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.623]                         if (muffled) 
[16:05:19.623]                           invokeRestart("muffleMessage")
[16:05:19.623]                       }
[16:05:19.623]                       else if (inherits(cond, "warning")) {
[16:05:19.623]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.623]                         if (muffled) 
[16:05:19.623]                           invokeRestart("muffleWarning")
[16:05:19.623]                       }
[16:05:19.623]                       else if (inherits(cond, "condition")) {
[16:05:19.623]                         if (!is.null(pattern)) {
[16:05:19.623]                           computeRestarts <- base::computeRestarts
[16:05:19.623]                           grepl <- base::grepl
[16:05:19.623]                           restarts <- computeRestarts(cond)
[16:05:19.623]                           for (restart in restarts) {
[16:05:19.623]                             name <- restart$name
[16:05:19.623]                             if (is.null(name)) 
[16:05:19.623]                               next
[16:05:19.623]                             if (!grepl(pattern, name)) 
[16:05:19.623]                               next
[16:05:19.623]                             invokeRestart(restart)
[16:05:19.623]                             muffled <- TRUE
[16:05:19.623]                             break
[16:05:19.623]                           }
[16:05:19.623]                         }
[16:05:19.623]                       }
[16:05:19.623]                       invisible(muffled)
[16:05:19.623]                     }
[16:05:19.623]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.623]                   }
[16:05:19.623]                 }
[16:05:19.623]             }
[16:05:19.623]         }))
[16:05:19.623]     }, error = function(ex) {
[16:05:19.623]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.623]                 ...future.rng), started = ...future.startTime, 
[16:05:19.623]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.623]             version = "1.8"), class = "FutureResult")
[16:05:19.623]     }, finally = {
[16:05:19.623]         if (!identical(...future.workdir, getwd())) 
[16:05:19.623]             setwd(...future.workdir)
[16:05:19.623]         {
[16:05:19.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.623]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.623]             }
[16:05:19.623]             base::options(...future.oldOptions)
[16:05:19.623]             if (.Platform$OS.type == "windows") {
[16:05:19.623]                 old_names <- names(...future.oldEnvVars)
[16:05:19.623]                 envs <- base::Sys.getenv()
[16:05:19.623]                 names <- names(envs)
[16:05:19.623]                 common <- intersect(names, old_names)
[16:05:19.623]                 added <- setdiff(names, old_names)
[16:05:19.623]                 removed <- setdiff(old_names, names)
[16:05:19.623]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.623]                   envs[common]]
[16:05:19.623]                 NAMES <- toupper(changed)
[16:05:19.623]                 args <- list()
[16:05:19.623]                 for (kk in seq_along(NAMES)) {
[16:05:19.623]                   name <- changed[[kk]]
[16:05:19.623]                   NAME <- NAMES[[kk]]
[16:05:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.623]                     next
[16:05:19.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.623]                 }
[16:05:19.623]                 NAMES <- toupper(added)
[16:05:19.623]                 for (kk in seq_along(NAMES)) {
[16:05:19.623]                   name <- added[[kk]]
[16:05:19.623]                   NAME <- NAMES[[kk]]
[16:05:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.623]                     next
[16:05:19.623]                   args[[name]] <- ""
[16:05:19.623]                 }
[16:05:19.623]                 NAMES <- toupper(removed)
[16:05:19.623]                 for (kk in seq_along(NAMES)) {
[16:05:19.623]                   name <- removed[[kk]]
[16:05:19.623]                   NAME <- NAMES[[kk]]
[16:05:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.623]                     next
[16:05:19.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.623]                 }
[16:05:19.623]                 if (length(args) > 0) 
[16:05:19.623]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.623]             }
[16:05:19.623]             else {
[16:05:19.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.623]             }
[16:05:19.623]             {
[16:05:19.623]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.623]                   0L) {
[16:05:19.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.623]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.623]                   base::options(opts)
[16:05:19.623]                 }
[16:05:19.623]                 {
[16:05:19.623]                   {
[16:05:19.623]                     NULL
[16:05:19.623]                     RNGkind("Mersenne-Twister")
[16:05:19.623]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.623]                       inherits = FALSE)
[16:05:19.623]                   }
[16:05:19.623]                   options(future.plan = NULL)
[16:05:19.623]                   if (is.na(NA_character_)) 
[16:05:19.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.623]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.623]                     envir = parent.frame()) 
[16:05:19.623]                   {
[16:05:19.623]                     default_workers <- missing(workers)
[16:05:19.623]                     if (is.function(workers)) 
[16:05:19.623]                       workers <- workers()
[16:05:19.623]                     workers <- structure(as.integer(workers), 
[16:05:19.623]                       class = class(workers))
[16:05:19.623]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.623]                       1L)
[16:05:19.623]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.623]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.623]                       if (default_workers) 
[16:05:19.623]                         supportsMulticore(warn = TRUE)
[16:05:19.623]                       return(sequential(..., envir = envir))
[16:05:19.623]                     }
[16:05:19.623]                     oopts <- options(mc.cores = workers)
[16:05:19.623]                     on.exit(options(oopts))
[16:05:19.623]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.623]                       envir = envir)
[16:05:19.623]                     if (!future$lazy) 
[16:05:19.623]                       future <- run(future)
[16:05:19.623]                     invisible(future)
[16:05:19.623]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.623]                 }
[16:05:19.623]             }
[16:05:19.623]         }
[16:05:19.623]     })
[16:05:19.623]     if (TRUE) {
[16:05:19.623]         base::sink(type = "output", split = FALSE)
[16:05:19.623]         if (TRUE) {
[16:05:19.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.623]         }
[16:05:19.623]         else {
[16:05:19.623]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.623]         }
[16:05:19.623]         base::close(...future.stdout)
[16:05:19.623]         ...future.stdout <- NULL
[16:05:19.623]     }
[16:05:19.623]     ...future.result$conditions <- ...future.conditions
[16:05:19.623]     ...future.result$finished <- base::Sys.time()
[16:05:19.623]     ...future.result
[16:05:19.623] }
[16:05:19.625] assign_globals() ...
[16:05:19.625] List of 1
[16:05:19.625]  $ ii: int 4
[16:05:19.625]  - attr(*, "where")=List of 1
[16:05:19.625]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.625]  - attr(*, "resolved")= logi FALSE
[16:05:19.625]  - attr(*, "total_size")= num 56
[16:05:19.627] - copied ‘ii’ to environment
[16:05:19.627] assign_globals() ... done
[16:05:19.627] plan(): Setting new future strategy stack:
[16:05:19.627] List of future strategies:
[16:05:19.627] 1. sequential:
[16:05:19.627]    - args: function (..., envir = parent.frame())
[16:05:19.627]    - tweaked: FALSE
[16:05:19.627]    - call: NULL
[16:05:19.628] plan(): nbrOfWorkers() = 1
[16:05:19.628] plan(): Setting new future strategy stack:
[16:05:19.628] List of future strategies:
[16:05:19.628] 1. multicore:
[16:05:19.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.628]    - tweaked: FALSE
[16:05:19.628]    - call: plan(multicore)
[16:05:19.632] plan(): nbrOfWorkers() = 1
[16:05:19.632] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[16:05:19.636] getGlobalsAndPackages() ...
[16:05:19.636] Searching for globals...
[16:05:19.637] - globals found: [2] ‘{’, ‘stop’
[16:05:19.637] Searching for globals ... DONE
[16:05:19.637] Resolving globals: FALSE
[16:05:19.637] 
[16:05:19.637] 
[16:05:19.637] getGlobalsAndPackages() ... DONE
[16:05:19.638] Packages needed by the future expression (n = 0): <none>
[16:05:19.638] Packages needed by future strategies (n = 0): <none>
[16:05:19.638] {
[16:05:19.638]     {
[16:05:19.638]         {
[16:05:19.638]             ...future.startTime <- base::Sys.time()
[16:05:19.638]             {
[16:05:19.638]                 {
[16:05:19.638]                   {
[16:05:19.638]                     base::local({
[16:05:19.638]                       has_future <- base::requireNamespace("future", 
[16:05:19.638]                         quietly = TRUE)
[16:05:19.638]                       if (has_future) {
[16:05:19.638]                         ns <- base::getNamespace("future")
[16:05:19.638]                         version <- ns[[".package"]][["version"]]
[16:05:19.638]                         if (is.null(version)) 
[16:05:19.638]                           version <- utils::packageVersion("future")
[16:05:19.638]                       }
[16:05:19.638]                       else {
[16:05:19.638]                         version <- NULL
[16:05:19.638]                       }
[16:05:19.638]                       if (!has_future || version < "1.8.0") {
[16:05:19.638]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.638]                           "", base::R.version$version.string), 
[16:05:19.638]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.638]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.638]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.638]                             "release", "version")], collapse = " "), 
[16:05:19.638]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.638]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.638]                           info)
[16:05:19.638]                         info <- base::paste(info, collapse = "; ")
[16:05:19.638]                         if (!has_future) {
[16:05:19.638]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.638]                             info)
[16:05:19.638]                         }
[16:05:19.638]                         else {
[16:05:19.638]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.638]                             info, version)
[16:05:19.638]                         }
[16:05:19.638]                         base::stop(msg)
[16:05:19.638]                       }
[16:05:19.638]                     })
[16:05:19.638]                   }
[16:05:19.638]                   options(future.plan = NULL)
[16:05:19.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.638]                 }
[16:05:19.638]                 ...future.workdir <- getwd()
[16:05:19.638]             }
[16:05:19.638]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.638]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.638]         }
[16:05:19.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.638]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.638]             base::names(...future.oldOptions))
[16:05:19.638]     }
[16:05:19.638]     if (FALSE) {
[16:05:19.638]     }
[16:05:19.638]     else {
[16:05:19.638]         if (TRUE) {
[16:05:19.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.638]                 open = "w")
[16:05:19.638]         }
[16:05:19.638]         else {
[16:05:19.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.638]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.638]         }
[16:05:19.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.638]             base::sink(type = "output", split = FALSE)
[16:05:19.638]             base::close(...future.stdout)
[16:05:19.638]         }, add = TRUE)
[16:05:19.638]     }
[16:05:19.638]     ...future.frame <- base::sys.nframe()
[16:05:19.638]     ...future.conditions <- base::list()
[16:05:19.638]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.638]     if (FALSE) {
[16:05:19.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.638]     }
[16:05:19.638]     ...future.result <- base::tryCatch({
[16:05:19.638]         base::withCallingHandlers({
[16:05:19.638]             ...future.value <- base::withVisible(base::local({
[16:05:19.638]                 stop("Whoops!")
[16:05:19.638]                 1
[16:05:19.638]             }))
[16:05:19.638]             future::FutureResult(value = ...future.value$value, 
[16:05:19.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.638]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.638]                     ...future.globalenv.names))
[16:05:19.638]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.638]         }, condition = base::local({
[16:05:19.638]             c <- base::c
[16:05:19.638]             inherits <- base::inherits
[16:05:19.638]             invokeRestart <- base::invokeRestart
[16:05:19.638]             length <- base::length
[16:05:19.638]             list <- base::list
[16:05:19.638]             seq.int <- base::seq.int
[16:05:19.638]             signalCondition <- base::signalCondition
[16:05:19.638]             sys.calls <- base::sys.calls
[16:05:19.638]             `[[` <- base::`[[`
[16:05:19.638]             `+` <- base::`+`
[16:05:19.638]             `<<-` <- base::`<<-`
[16:05:19.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.638]                   3L)]
[16:05:19.638]             }
[16:05:19.638]             function(cond) {
[16:05:19.638]                 is_error <- inherits(cond, "error")
[16:05:19.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.638]                   NULL)
[16:05:19.638]                 if (is_error) {
[16:05:19.638]                   sessionInformation <- function() {
[16:05:19.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.638]                       search = base::search(), system = base::Sys.info())
[16:05:19.638]                   }
[16:05:19.638]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.638]                     cond$call), session = sessionInformation(), 
[16:05:19.638]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.638]                   signalCondition(cond)
[16:05:19.638]                 }
[16:05:19.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.638]                 "immediateCondition"))) {
[16:05:19.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.638]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.638]                   if (TRUE && !signal) {
[16:05:19.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.638]                     {
[16:05:19.638]                       inherits <- base::inherits
[16:05:19.638]                       invokeRestart <- base::invokeRestart
[16:05:19.638]                       is.null <- base::is.null
[16:05:19.638]                       muffled <- FALSE
[16:05:19.638]                       if (inherits(cond, "message")) {
[16:05:19.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.638]                         if (muffled) 
[16:05:19.638]                           invokeRestart("muffleMessage")
[16:05:19.638]                       }
[16:05:19.638]                       else if (inherits(cond, "warning")) {
[16:05:19.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.638]                         if (muffled) 
[16:05:19.638]                           invokeRestart("muffleWarning")
[16:05:19.638]                       }
[16:05:19.638]                       else if (inherits(cond, "condition")) {
[16:05:19.638]                         if (!is.null(pattern)) {
[16:05:19.638]                           computeRestarts <- base::computeRestarts
[16:05:19.638]                           grepl <- base::grepl
[16:05:19.638]                           restarts <- computeRestarts(cond)
[16:05:19.638]                           for (restart in restarts) {
[16:05:19.638]                             name <- restart$name
[16:05:19.638]                             if (is.null(name)) 
[16:05:19.638]                               next
[16:05:19.638]                             if (!grepl(pattern, name)) 
[16:05:19.638]                               next
[16:05:19.638]                             invokeRestart(restart)
[16:05:19.638]                             muffled <- TRUE
[16:05:19.638]                             break
[16:05:19.638]                           }
[16:05:19.638]                         }
[16:05:19.638]                       }
[16:05:19.638]                       invisible(muffled)
[16:05:19.638]                     }
[16:05:19.638]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.638]                   }
[16:05:19.638]                 }
[16:05:19.638]                 else {
[16:05:19.638]                   if (TRUE) {
[16:05:19.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.638]                     {
[16:05:19.638]                       inherits <- base::inherits
[16:05:19.638]                       invokeRestart <- base::invokeRestart
[16:05:19.638]                       is.null <- base::is.null
[16:05:19.638]                       muffled <- FALSE
[16:05:19.638]                       if (inherits(cond, "message")) {
[16:05:19.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.638]                         if (muffled) 
[16:05:19.638]                           invokeRestart("muffleMessage")
[16:05:19.638]                       }
[16:05:19.638]                       else if (inherits(cond, "warning")) {
[16:05:19.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.638]                         if (muffled) 
[16:05:19.638]                           invokeRestart("muffleWarning")
[16:05:19.638]                       }
[16:05:19.638]                       else if (inherits(cond, "condition")) {
[16:05:19.638]                         if (!is.null(pattern)) {
[16:05:19.638]                           computeRestarts <- base::computeRestarts
[16:05:19.638]                           grepl <- base::grepl
[16:05:19.638]                           restarts <- computeRestarts(cond)
[16:05:19.638]                           for (restart in restarts) {
[16:05:19.638]                             name <- restart$name
[16:05:19.638]                             if (is.null(name)) 
[16:05:19.638]                               next
[16:05:19.638]                             if (!grepl(pattern, name)) 
[16:05:19.638]                               next
[16:05:19.638]                             invokeRestart(restart)
[16:05:19.638]                             muffled <- TRUE
[16:05:19.638]                             break
[16:05:19.638]                           }
[16:05:19.638]                         }
[16:05:19.638]                       }
[16:05:19.638]                       invisible(muffled)
[16:05:19.638]                     }
[16:05:19.638]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.638]                   }
[16:05:19.638]                 }
[16:05:19.638]             }
[16:05:19.638]         }))
[16:05:19.638]     }, error = function(ex) {
[16:05:19.638]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.638]                 ...future.rng), started = ...future.startTime, 
[16:05:19.638]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.638]             version = "1.8"), class = "FutureResult")
[16:05:19.638]     }, finally = {
[16:05:19.638]         if (!identical(...future.workdir, getwd())) 
[16:05:19.638]             setwd(...future.workdir)
[16:05:19.638]         {
[16:05:19.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.638]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.638]             }
[16:05:19.638]             base::options(...future.oldOptions)
[16:05:19.638]             if (.Platform$OS.type == "windows") {
[16:05:19.638]                 old_names <- names(...future.oldEnvVars)
[16:05:19.638]                 envs <- base::Sys.getenv()
[16:05:19.638]                 names <- names(envs)
[16:05:19.638]                 common <- intersect(names, old_names)
[16:05:19.638]                 added <- setdiff(names, old_names)
[16:05:19.638]                 removed <- setdiff(old_names, names)
[16:05:19.638]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.638]                   envs[common]]
[16:05:19.638]                 NAMES <- toupper(changed)
[16:05:19.638]                 args <- list()
[16:05:19.638]                 for (kk in seq_along(NAMES)) {
[16:05:19.638]                   name <- changed[[kk]]
[16:05:19.638]                   NAME <- NAMES[[kk]]
[16:05:19.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.638]                     next
[16:05:19.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.638]                 }
[16:05:19.638]                 NAMES <- toupper(added)
[16:05:19.638]                 for (kk in seq_along(NAMES)) {
[16:05:19.638]                   name <- added[[kk]]
[16:05:19.638]                   NAME <- NAMES[[kk]]
[16:05:19.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.638]                     next
[16:05:19.638]                   args[[name]] <- ""
[16:05:19.638]                 }
[16:05:19.638]                 NAMES <- toupper(removed)
[16:05:19.638]                 for (kk in seq_along(NAMES)) {
[16:05:19.638]                   name <- removed[[kk]]
[16:05:19.638]                   NAME <- NAMES[[kk]]
[16:05:19.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.638]                     next
[16:05:19.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.638]                 }
[16:05:19.638]                 if (length(args) > 0) 
[16:05:19.638]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.638]             }
[16:05:19.638]             else {
[16:05:19.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.638]             }
[16:05:19.638]             {
[16:05:19.638]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.638]                   0L) {
[16:05:19.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.638]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.638]                   base::options(opts)
[16:05:19.638]                 }
[16:05:19.638]                 {
[16:05:19.638]                   {
[16:05:19.638]                     NULL
[16:05:19.638]                     RNGkind("Mersenne-Twister")
[16:05:19.638]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.638]                       inherits = FALSE)
[16:05:19.638]                   }
[16:05:19.638]                   options(future.plan = NULL)
[16:05:19.638]                   if (is.na(NA_character_)) 
[16:05:19.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.638]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.638]                     envir = parent.frame()) 
[16:05:19.638]                   {
[16:05:19.638]                     default_workers <- missing(workers)
[16:05:19.638]                     if (is.function(workers)) 
[16:05:19.638]                       workers <- workers()
[16:05:19.638]                     workers <- structure(as.integer(workers), 
[16:05:19.638]                       class = class(workers))
[16:05:19.638]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.638]                       1L)
[16:05:19.638]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.638]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.638]                       if (default_workers) 
[16:05:19.638]                         supportsMulticore(warn = TRUE)
[16:05:19.638]                       return(sequential(..., envir = envir))
[16:05:19.638]                     }
[16:05:19.638]                     oopts <- options(mc.cores = workers)
[16:05:19.638]                     on.exit(options(oopts))
[16:05:19.638]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.638]                       envir = envir)
[16:05:19.638]                     if (!future$lazy) 
[16:05:19.638]                       future <- run(future)
[16:05:19.638]                     invisible(future)
[16:05:19.638]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.638]                 }
[16:05:19.638]             }
[16:05:19.638]         }
[16:05:19.638]     })
[16:05:19.638]     if (TRUE) {
[16:05:19.638]         base::sink(type = "output", split = FALSE)
[16:05:19.638]         if (TRUE) {
[16:05:19.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.638]         }
[16:05:19.638]         else {
[16:05:19.638]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.638]         }
[16:05:19.638]         base::close(...future.stdout)
[16:05:19.638]         ...future.stdout <- NULL
[16:05:19.638]     }
[16:05:19.638]     ...future.result$conditions <- ...future.conditions
[16:05:19.638]     ...future.result$finished <- base::Sys.time()
[16:05:19.638]     ...future.result
[16:05:19.638] }
[16:05:19.640] plan(): Setting new future strategy stack:
[16:05:19.640] List of future strategies:
[16:05:19.640] 1. sequential:
[16:05:19.640]    - args: function (..., envir = parent.frame())
[16:05:19.640]    - tweaked: FALSE
[16:05:19.640]    - call: NULL
[16:05:19.640] plan(): nbrOfWorkers() = 1
[16:05:19.641] plan(): Setting new future strategy stack:
[16:05:19.641] List of future strategies:
[16:05:19.641] 1. multicore:
[16:05:19.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.641]    - tweaked: FALSE
[16:05:19.641]    - call: plan(multicore)
[16:05:19.644] plan(): nbrOfWorkers() = 1
[16:05:19.645] SequentialFuture started (and completed)
[16:05:19.645] signalConditions() ...
[16:05:19.645]  - include = ‘immediateCondition’
[16:05:19.645]  - exclude = 
[16:05:19.645]  - resignal = FALSE
[16:05:19.645]  - Number of conditions: 1
[16:05:19.645] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:19.646] signalConditions() ...
[16:05:19.646]  - include = ‘immediateCondition’
[16:05:19.646]  - exclude = 
[16:05:19.646]  - resignal = FALSE
[16:05:19.646]  - Number of conditions: 1
[16:05:19.646] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.647] signalConditions() ...
[16:05:19.648]  - include = ‘immediateCondition’
[16:05:19.648]  - exclude = 
[16:05:19.648]  - resignal = FALSE
[16:05:19.649]  - Number of conditions: 1
[16:05:19.649] signalConditions() ... done
[16:05:19.649] Future state: ‘finished’
[16:05:19.649] signalConditions() ...
[16:05:19.649]  - include = ‘condition’
[16:05:19.649]  - exclude = ‘immediateCondition’
[16:05:19.649]  - resignal = TRUE
[16:05:19.649]  - Number of conditions: 1
[16:05:19.649]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.649] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.650] signalConditions() ...
[16:05:19.650]  - include = ‘immediateCondition’
[16:05:19.650]  - exclude = 
[16:05:19.650]  - resignal = FALSE
[16:05:19.650]  - Number of conditions: 1
[16:05:19.650] signalConditions() ... done
[16:05:19.650] Future state: ‘finished’
[16:05:19.651] signalConditions() ...
[16:05:19.651]  - include = ‘condition’
[16:05:19.651]  - exclude = ‘immediateCondition’
[16:05:19.651]  - resignal = TRUE
[16:05:19.651]  - Number of conditions: 1
[16:05:19.651]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.651] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[16:05:19.654] getGlobalsAndPackages() ...
[16:05:19.655] Searching for globals...
[16:05:19.656] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[16:05:19.656] Searching for globals ... DONE
[16:05:19.656] Resolving globals: FALSE
[16:05:19.656] 
[16:05:19.656] 
[16:05:19.656] getGlobalsAndPackages() ... DONE
[16:05:19.657] Packages needed by the future expression (n = 0): <none>
[16:05:19.657] Packages needed by future strategies (n = 0): <none>
[16:05:19.657] {
[16:05:19.657]     {
[16:05:19.657]         {
[16:05:19.657]             ...future.startTime <- base::Sys.time()
[16:05:19.657]             {
[16:05:19.657]                 {
[16:05:19.657]                   {
[16:05:19.657]                     base::local({
[16:05:19.657]                       has_future <- base::requireNamespace("future", 
[16:05:19.657]                         quietly = TRUE)
[16:05:19.657]                       if (has_future) {
[16:05:19.657]                         ns <- base::getNamespace("future")
[16:05:19.657]                         version <- ns[[".package"]][["version"]]
[16:05:19.657]                         if (is.null(version)) 
[16:05:19.657]                           version <- utils::packageVersion("future")
[16:05:19.657]                       }
[16:05:19.657]                       else {
[16:05:19.657]                         version <- NULL
[16:05:19.657]                       }
[16:05:19.657]                       if (!has_future || version < "1.8.0") {
[16:05:19.657]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.657]                           "", base::R.version$version.string), 
[16:05:19.657]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.657]                             "release", "version")], collapse = " "), 
[16:05:19.657]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.657]                           info)
[16:05:19.657]                         info <- base::paste(info, collapse = "; ")
[16:05:19.657]                         if (!has_future) {
[16:05:19.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.657]                             info)
[16:05:19.657]                         }
[16:05:19.657]                         else {
[16:05:19.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.657]                             info, version)
[16:05:19.657]                         }
[16:05:19.657]                         base::stop(msg)
[16:05:19.657]                       }
[16:05:19.657]                     })
[16:05:19.657]                   }
[16:05:19.657]                   options(future.plan = NULL)
[16:05:19.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.657]                 }
[16:05:19.657]                 ...future.workdir <- getwd()
[16:05:19.657]             }
[16:05:19.657]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.657]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.657]         }
[16:05:19.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.657]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.657]             base::names(...future.oldOptions))
[16:05:19.657]     }
[16:05:19.657]     if (FALSE) {
[16:05:19.657]     }
[16:05:19.657]     else {
[16:05:19.657]         if (TRUE) {
[16:05:19.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.657]                 open = "w")
[16:05:19.657]         }
[16:05:19.657]         else {
[16:05:19.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.657]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.657]         }
[16:05:19.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.657]             base::sink(type = "output", split = FALSE)
[16:05:19.657]             base::close(...future.stdout)
[16:05:19.657]         }, add = TRUE)
[16:05:19.657]     }
[16:05:19.657]     ...future.frame <- base::sys.nframe()
[16:05:19.657]     ...future.conditions <- base::list()
[16:05:19.657]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.657]     if (FALSE) {
[16:05:19.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.657]     }
[16:05:19.657]     ...future.result <- base::tryCatch({
[16:05:19.657]         base::withCallingHandlers({
[16:05:19.657]             ...future.value <- base::withVisible(base::local({
[16:05:19.657]                 stop(structure(list(message = "boom"), class = c("MyError", 
[16:05:19.657]                   "error", "condition")))
[16:05:19.657]             }))
[16:05:19.657]             future::FutureResult(value = ...future.value$value, 
[16:05:19.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.657]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.657]                     ...future.globalenv.names))
[16:05:19.657]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.657]         }, condition = base::local({
[16:05:19.657]             c <- base::c
[16:05:19.657]             inherits <- base::inherits
[16:05:19.657]             invokeRestart <- base::invokeRestart
[16:05:19.657]             length <- base::length
[16:05:19.657]             list <- base::list
[16:05:19.657]             seq.int <- base::seq.int
[16:05:19.657]             signalCondition <- base::signalCondition
[16:05:19.657]             sys.calls <- base::sys.calls
[16:05:19.657]             `[[` <- base::`[[`
[16:05:19.657]             `+` <- base::`+`
[16:05:19.657]             `<<-` <- base::`<<-`
[16:05:19.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.657]                   3L)]
[16:05:19.657]             }
[16:05:19.657]             function(cond) {
[16:05:19.657]                 is_error <- inherits(cond, "error")
[16:05:19.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.657]                   NULL)
[16:05:19.657]                 if (is_error) {
[16:05:19.657]                   sessionInformation <- function() {
[16:05:19.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.657]                       search = base::search(), system = base::Sys.info())
[16:05:19.657]                   }
[16:05:19.657]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.657]                     cond$call), session = sessionInformation(), 
[16:05:19.657]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.657]                   signalCondition(cond)
[16:05:19.657]                 }
[16:05:19.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.657]                 "immediateCondition"))) {
[16:05:19.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.657]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.657]                   if (TRUE && !signal) {
[16:05:19.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.657]                     {
[16:05:19.657]                       inherits <- base::inherits
[16:05:19.657]                       invokeRestart <- base::invokeRestart
[16:05:19.657]                       is.null <- base::is.null
[16:05:19.657]                       muffled <- FALSE
[16:05:19.657]                       if (inherits(cond, "message")) {
[16:05:19.657]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.657]                         if (muffled) 
[16:05:19.657]                           invokeRestart("muffleMessage")
[16:05:19.657]                       }
[16:05:19.657]                       else if (inherits(cond, "warning")) {
[16:05:19.657]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.657]                         if (muffled) 
[16:05:19.657]                           invokeRestart("muffleWarning")
[16:05:19.657]                       }
[16:05:19.657]                       else if (inherits(cond, "condition")) {
[16:05:19.657]                         if (!is.null(pattern)) {
[16:05:19.657]                           computeRestarts <- base::computeRestarts
[16:05:19.657]                           grepl <- base::grepl
[16:05:19.657]                           restarts <- computeRestarts(cond)
[16:05:19.657]                           for (restart in restarts) {
[16:05:19.657]                             name <- restart$name
[16:05:19.657]                             if (is.null(name)) 
[16:05:19.657]                               next
[16:05:19.657]                             if (!grepl(pattern, name)) 
[16:05:19.657]                               next
[16:05:19.657]                             invokeRestart(restart)
[16:05:19.657]                             muffled <- TRUE
[16:05:19.657]                             break
[16:05:19.657]                           }
[16:05:19.657]                         }
[16:05:19.657]                       }
[16:05:19.657]                       invisible(muffled)
[16:05:19.657]                     }
[16:05:19.657]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.657]                   }
[16:05:19.657]                 }
[16:05:19.657]                 else {
[16:05:19.657]                   if (TRUE) {
[16:05:19.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.657]                     {
[16:05:19.657]                       inherits <- base::inherits
[16:05:19.657]                       invokeRestart <- base::invokeRestart
[16:05:19.657]                       is.null <- base::is.null
[16:05:19.657]                       muffled <- FALSE
[16:05:19.657]                       if (inherits(cond, "message")) {
[16:05:19.657]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.657]                         if (muffled) 
[16:05:19.657]                           invokeRestart("muffleMessage")
[16:05:19.657]                       }
[16:05:19.657]                       else if (inherits(cond, "warning")) {
[16:05:19.657]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.657]                         if (muffled) 
[16:05:19.657]                           invokeRestart("muffleWarning")
[16:05:19.657]                       }
[16:05:19.657]                       else if (inherits(cond, "condition")) {
[16:05:19.657]                         if (!is.null(pattern)) {
[16:05:19.657]                           computeRestarts <- base::computeRestarts
[16:05:19.657]                           grepl <- base::grepl
[16:05:19.657]                           restarts <- computeRestarts(cond)
[16:05:19.657]                           for (restart in restarts) {
[16:05:19.657]                             name <- restart$name
[16:05:19.657]                             if (is.null(name)) 
[16:05:19.657]                               next
[16:05:19.657]                             if (!grepl(pattern, name)) 
[16:05:19.657]                               next
[16:05:19.657]                             invokeRestart(restart)
[16:05:19.657]                             muffled <- TRUE
[16:05:19.657]                             break
[16:05:19.657]                           }
[16:05:19.657]                         }
[16:05:19.657]                       }
[16:05:19.657]                       invisible(muffled)
[16:05:19.657]                     }
[16:05:19.657]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.657]                   }
[16:05:19.657]                 }
[16:05:19.657]             }
[16:05:19.657]         }))
[16:05:19.657]     }, error = function(ex) {
[16:05:19.657]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.657]                 ...future.rng), started = ...future.startTime, 
[16:05:19.657]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.657]             version = "1.8"), class = "FutureResult")
[16:05:19.657]     }, finally = {
[16:05:19.657]         if (!identical(...future.workdir, getwd())) 
[16:05:19.657]             setwd(...future.workdir)
[16:05:19.657]         {
[16:05:19.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.657]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.657]             }
[16:05:19.657]             base::options(...future.oldOptions)
[16:05:19.657]             if (.Platform$OS.type == "windows") {
[16:05:19.657]                 old_names <- names(...future.oldEnvVars)
[16:05:19.657]                 envs <- base::Sys.getenv()
[16:05:19.657]                 names <- names(envs)
[16:05:19.657]                 common <- intersect(names, old_names)
[16:05:19.657]                 added <- setdiff(names, old_names)
[16:05:19.657]                 removed <- setdiff(old_names, names)
[16:05:19.657]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.657]                   envs[common]]
[16:05:19.657]                 NAMES <- toupper(changed)
[16:05:19.657]                 args <- list()
[16:05:19.657]                 for (kk in seq_along(NAMES)) {
[16:05:19.657]                   name <- changed[[kk]]
[16:05:19.657]                   NAME <- NAMES[[kk]]
[16:05:19.657]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.657]                     next
[16:05:19.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.657]                 }
[16:05:19.657]                 NAMES <- toupper(added)
[16:05:19.657]                 for (kk in seq_along(NAMES)) {
[16:05:19.657]                   name <- added[[kk]]
[16:05:19.657]                   NAME <- NAMES[[kk]]
[16:05:19.657]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.657]                     next
[16:05:19.657]                   args[[name]] <- ""
[16:05:19.657]                 }
[16:05:19.657]                 NAMES <- toupper(removed)
[16:05:19.657]                 for (kk in seq_along(NAMES)) {
[16:05:19.657]                   name <- removed[[kk]]
[16:05:19.657]                   NAME <- NAMES[[kk]]
[16:05:19.657]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.657]                     next
[16:05:19.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.657]                 }
[16:05:19.657]                 if (length(args) > 0) 
[16:05:19.657]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.657]             }
[16:05:19.657]             else {
[16:05:19.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.657]             }
[16:05:19.657]             {
[16:05:19.657]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.657]                   0L) {
[16:05:19.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.657]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.657]                   base::options(opts)
[16:05:19.657]                 }
[16:05:19.657]                 {
[16:05:19.657]                   {
[16:05:19.657]                     NULL
[16:05:19.657]                     RNGkind("Mersenne-Twister")
[16:05:19.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.657]                       inherits = FALSE)
[16:05:19.657]                   }
[16:05:19.657]                   options(future.plan = NULL)
[16:05:19.657]                   if (is.na(NA_character_)) 
[16:05:19.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.657]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.657]                     envir = parent.frame()) 
[16:05:19.657]                   {
[16:05:19.657]                     default_workers <- missing(workers)
[16:05:19.657]                     if (is.function(workers)) 
[16:05:19.657]                       workers <- workers()
[16:05:19.657]                     workers <- structure(as.integer(workers), 
[16:05:19.657]                       class = class(workers))
[16:05:19.657]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.657]                       1L)
[16:05:19.657]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.657]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.657]                       if (default_workers) 
[16:05:19.657]                         supportsMulticore(warn = TRUE)
[16:05:19.657]                       return(sequential(..., envir = envir))
[16:05:19.657]                     }
[16:05:19.657]                     oopts <- options(mc.cores = workers)
[16:05:19.657]                     on.exit(options(oopts))
[16:05:19.657]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.657]                       envir = envir)
[16:05:19.657]                     if (!future$lazy) 
[16:05:19.657]                       future <- run(future)
[16:05:19.657]                     invisible(future)
[16:05:19.657]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.657]                 }
[16:05:19.657]             }
[16:05:19.657]         }
[16:05:19.657]     })
[16:05:19.657]     if (TRUE) {
[16:05:19.657]         base::sink(type = "output", split = FALSE)
[16:05:19.657]         if (TRUE) {
[16:05:19.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.657]         }
[16:05:19.657]         else {
[16:05:19.657]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.657]         }
[16:05:19.657]         base::close(...future.stdout)
[16:05:19.657]         ...future.stdout <- NULL
[16:05:19.657]     }
[16:05:19.657]     ...future.result$conditions <- ...future.conditions
[16:05:19.657]     ...future.result$finished <- base::Sys.time()
[16:05:19.657]     ...future.result
[16:05:19.657] }
[16:05:19.659] plan(): Setting new future strategy stack:
[16:05:19.659] List of future strategies:
[16:05:19.659] 1. sequential:
[16:05:19.659]    - args: function (..., envir = parent.frame())
[16:05:19.659]    - tweaked: FALSE
[16:05:19.659]    - call: NULL
[16:05:19.660] plan(): nbrOfWorkers() = 1
[16:05:19.660] plan(): Setting new future strategy stack:
[16:05:19.660] List of future strategies:
[16:05:19.660] 1. multicore:
[16:05:19.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.660]    - tweaked: FALSE
[16:05:19.660]    - call: plan(multicore)
[16:05:19.664] plan(): nbrOfWorkers() = 1
[16:05:19.664] SequentialFuture started (and completed)
[16:05:19.664] signalConditions() ...
[16:05:19.664]  - include = ‘immediateCondition’
[16:05:19.664]  - exclude = 
[16:05:19.664]  - resignal = FALSE
[16:05:19.664]  - Number of conditions: 1
[16:05:19.665] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:19.665] signalConditions() ...
[16:05:19.665]  - include = ‘immediateCondition’
[16:05:19.665]  - exclude = 
[16:05:19.665]  - resignal = FALSE
[16:05:19.665]  - Number of conditions: 1
[16:05:19.666] signalConditions() ... done
<MyError: boom>
[16:05:19.666] signalConditions() ...
[16:05:19.666]  - include = ‘immediateCondition’
[16:05:19.666]  - exclude = 
[16:05:19.666]  - resignal = FALSE
[16:05:19.666]  - Number of conditions: 1
[16:05:19.666] signalConditions() ... done
[16:05:19.666] Future state: ‘finished’
[16:05:19.666] signalConditions() ...
[16:05:19.667]  - include = ‘condition’
[16:05:19.667]  - exclude = ‘immediateCondition’
[16:05:19.667]  - resignal = TRUE
[16:05:19.667]  - Number of conditions: 1
[16:05:19.667]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:05:19.667] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[16:05:19.667] getGlobalsAndPackages() ...
[16:05:19.667] Searching for globals...
[16:05:19.668] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:05:19.668] Searching for globals ... DONE
[16:05:19.668] Resolving globals: FALSE
[16:05:19.669] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:19.669] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[16:05:19.669] - globals: [2] ‘a’, ‘b’
[16:05:19.669] 
[16:05:19.669] getGlobalsAndPackages() ... DONE
[16:05:19.670] Packages needed by the future expression (n = 0): <none>
[16:05:19.670] Packages needed by future strategies (n = 0): <none>
[16:05:19.670] {
[16:05:19.670]     {
[16:05:19.670]         {
[16:05:19.670]             ...future.startTime <- base::Sys.time()
[16:05:19.670]             {
[16:05:19.670]                 {
[16:05:19.670]                   {
[16:05:19.670]                     base::local({
[16:05:19.670]                       has_future <- base::requireNamespace("future", 
[16:05:19.670]                         quietly = TRUE)
[16:05:19.670]                       if (has_future) {
[16:05:19.670]                         ns <- base::getNamespace("future")
[16:05:19.670]                         version <- ns[[".package"]][["version"]]
[16:05:19.670]                         if (is.null(version)) 
[16:05:19.670]                           version <- utils::packageVersion("future")
[16:05:19.670]                       }
[16:05:19.670]                       else {
[16:05:19.670]                         version <- NULL
[16:05:19.670]                       }
[16:05:19.670]                       if (!has_future || version < "1.8.0") {
[16:05:19.670]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.670]                           "", base::R.version$version.string), 
[16:05:19.670]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:19.670]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.670]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.670]                             "release", "version")], collapse = " "), 
[16:05:19.670]                           hostname = base::Sys.info()[["nodename"]])
[16:05:19.670]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.670]                           info)
[16:05:19.670]                         info <- base::paste(info, collapse = "; ")
[16:05:19.670]                         if (!has_future) {
[16:05:19.670]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.670]                             info)
[16:05:19.670]                         }
[16:05:19.670]                         else {
[16:05:19.670]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.670]                             info, version)
[16:05:19.670]                         }
[16:05:19.670]                         base::stop(msg)
[16:05:19.670]                       }
[16:05:19.670]                     })
[16:05:19.670]                   }
[16:05:19.670]                   options(future.plan = NULL)
[16:05:19.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.670]                 }
[16:05:19.670]                 ...future.workdir <- getwd()
[16:05:19.670]             }
[16:05:19.670]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.670]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.670]         }
[16:05:19.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.670]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.670]             base::names(...future.oldOptions))
[16:05:19.670]     }
[16:05:19.670]     if (FALSE) {
[16:05:19.670]     }
[16:05:19.670]     else {
[16:05:19.670]         if (TRUE) {
[16:05:19.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.670]                 open = "w")
[16:05:19.670]         }
[16:05:19.670]         else {
[16:05:19.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.670]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.670]         }
[16:05:19.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.670]             base::sink(type = "output", split = FALSE)
[16:05:19.670]             base::close(...future.stdout)
[16:05:19.670]         }, add = TRUE)
[16:05:19.670]     }
[16:05:19.670]     ...future.frame <- base::sys.nframe()
[16:05:19.670]     ...future.conditions <- base::list()
[16:05:19.670]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.670]     if (FALSE) {
[16:05:19.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.670]     }
[16:05:19.670]     ...future.result <- base::tryCatch({
[16:05:19.670]         base::withCallingHandlers({
[16:05:19.670]             ...future.value <- base::withVisible(base::local({
[16:05:19.670]                 a * b
[16:05:19.670]             }))
[16:05:19.670]             future::FutureResult(value = ...future.value$value, 
[16:05:19.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.670]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.670]                     ...future.globalenv.names))
[16:05:19.670]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.670]         }, condition = base::local({
[16:05:19.670]             c <- base::c
[16:05:19.670]             inherits <- base::inherits
[16:05:19.670]             invokeRestart <- base::invokeRestart
[16:05:19.670]             length <- base::length
[16:05:19.670]             list <- base::list
[16:05:19.670]             seq.int <- base::seq.int
[16:05:19.670]             signalCondition <- base::signalCondition
[16:05:19.670]             sys.calls <- base::sys.calls
[16:05:19.670]             `[[` <- base::`[[`
[16:05:19.670]             `+` <- base::`+`
[16:05:19.670]             `<<-` <- base::`<<-`
[16:05:19.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.670]                   3L)]
[16:05:19.670]             }
[16:05:19.670]             function(cond) {
[16:05:19.670]                 is_error <- inherits(cond, "error")
[16:05:19.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.670]                   NULL)
[16:05:19.670]                 if (is_error) {
[16:05:19.670]                   sessionInformation <- function() {
[16:05:19.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.670]                       search = base::search(), system = base::Sys.info())
[16:05:19.670]                   }
[16:05:19.670]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.670]                     cond$call), session = sessionInformation(), 
[16:05:19.670]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.670]                   signalCondition(cond)
[16:05:19.670]                 }
[16:05:19.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.670]                 "immediateCondition"))) {
[16:05:19.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.670]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.670]                   if (TRUE && !signal) {
[16:05:19.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.670]                     {
[16:05:19.670]                       inherits <- base::inherits
[16:05:19.670]                       invokeRestart <- base::invokeRestart
[16:05:19.670]                       is.null <- base::is.null
[16:05:19.670]                       muffled <- FALSE
[16:05:19.670]                       if (inherits(cond, "message")) {
[16:05:19.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.670]                         if (muffled) 
[16:05:19.670]                           invokeRestart("muffleMessage")
[16:05:19.670]                       }
[16:05:19.670]                       else if (inherits(cond, "warning")) {
[16:05:19.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.670]                         if (muffled) 
[16:05:19.670]                           invokeRestart("muffleWarning")
[16:05:19.670]                       }
[16:05:19.670]                       else if (inherits(cond, "condition")) {
[16:05:19.670]                         if (!is.null(pattern)) {
[16:05:19.670]                           computeRestarts <- base::computeRestarts
[16:05:19.670]                           grepl <- base::grepl
[16:05:19.670]                           restarts <- computeRestarts(cond)
[16:05:19.670]                           for (restart in restarts) {
[16:05:19.670]                             name <- restart$name
[16:05:19.670]                             if (is.null(name)) 
[16:05:19.670]                               next
[16:05:19.670]                             if (!grepl(pattern, name)) 
[16:05:19.670]                               next
[16:05:19.670]                             invokeRestart(restart)
[16:05:19.670]                             muffled <- TRUE
[16:05:19.670]                             break
[16:05:19.670]                           }
[16:05:19.670]                         }
[16:05:19.670]                       }
[16:05:19.670]                       invisible(muffled)
[16:05:19.670]                     }
[16:05:19.670]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.670]                   }
[16:05:19.670]                 }
[16:05:19.670]                 else {
[16:05:19.670]                   if (TRUE) {
[16:05:19.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.670]                     {
[16:05:19.670]                       inherits <- base::inherits
[16:05:19.670]                       invokeRestart <- base::invokeRestart
[16:05:19.670]                       is.null <- base::is.null
[16:05:19.670]                       muffled <- FALSE
[16:05:19.670]                       if (inherits(cond, "message")) {
[16:05:19.670]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.670]                         if (muffled) 
[16:05:19.670]                           invokeRestart("muffleMessage")
[16:05:19.670]                       }
[16:05:19.670]                       else if (inherits(cond, "warning")) {
[16:05:19.670]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.670]                         if (muffled) 
[16:05:19.670]                           invokeRestart("muffleWarning")
[16:05:19.670]                       }
[16:05:19.670]                       else if (inherits(cond, "condition")) {
[16:05:19.670]                         if (!is.null(pattern)) {
[16:05:19.670]                           computeRestarts <- base::computeRestarts
[16:05:19.670]                           grepl <- base::grepl
[16:05:19.670]                           restarts <- computeRestarts(cond)
[16:05:19.670]                           for (restart in restarts) {
[16:05:19.670]                             name <- restart$name
[16:05:19.670]                             if (is.null(name)) 
[16:05:19.670]                               next
[16:05:19.670]                             if (!grepl(pattern, name)) 
[16:05:19.670]                               next
[16:05:19.670]                             invokeRestart(restart)
[16:05:19.670]                             muffled <- TRUE
[16:05:19.670]                             break
[16:05:19.670]                           }
[16:05:19.670]                         }
[16:05:19.670]                       }
[16:05:19.670]                       invisible(muffled)
[16:05:19.670]                     }
[16:05:19.670]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.670]                   }
[16:05:19.670]                 }
[16:05:19.670]             }
[16:05:19.670]         }))
[16:05:19.670]     }, error = function(ex) {
[16:05:19.670]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.670]                 ...future.rng), started = ...future.startTime, 
[16:05:19.670]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.670]             version = "1.8"), class = "FutureResult")
[16:05:19.670]     }, finally = {
[16:05:19.670]         if (!identical(...future.workdir, getwd())) 
[16:05:19.670]             setwd(...future.workdir)
[16:05:19.670]         {
[16:05:19.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.670]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.670]             }
[16:05:19.670]             base::options(...future.oldOptions)
[16:05:19.670]             if (.Platform$OS.type == "windows") {
[16:05:19.670]                 old_names <- names(...future.oldEnvVars)
[16:05:19.670]                 envs <- base::Sys.getenv()
[16:05:19.670]                 names <- names(envs)
[16:05:19.670]                 common <- intersect(names, old_names)
[16:05:19.670]                 added <- setdiff(names, old_names)
[16:05:19.670]                 removed <- setdiff(old_names, names)
[16:05:19.670]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.670]                   envs[common]]
[16:05:19.670]                 NAMES <- toupper(changed)
[16:05:19.670]                 args <- list()
[16:05:19.670]                 for (kk in seq_along(NAMES)) {
[16:05:19.670]                   name <- changed[[kk]]
[16:05:19.670]                   NAME <- NAMES[[kk]]
[16:05:19.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.670]                     next
[16:05:19.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.670]                 }
[16:05:19.670]                 NAMES <- toupper(added)
[16:05:19.670]                 for (kk in seq_along(NAMES)) {
[16:05:19.670]                   name <- added[[kk]]
[16:05:19.670]                   NAME <- NAMES[[kk]]
[16:05:19.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.670]                     next
[16:05:19.670]                   args[[name]] <- ""
[16:05:19.670]                 }
[16:05:19.670]                 NAMES <- toupper(removed)
[16:05:19.670]                 for (kk in seq_along(NAMES)) {
[16:05:19.670]                   name <- removed[[kk]]
[16:05:19.670]                   NAME <- NAMES[[kk]]
[16:05:19.670]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.670]                     next
[16:05:19.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.670]                 }
[16:05:19.670]                 if (length(args) > 0) 
[16:05:19.670]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.670]             }
[16:05:19.670]             else {
[16:05:19.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.670]             }
[16:05:19.670]             {
[16:05:19.670]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.670]                   0L) {
[16:05:19.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.670]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.670]                   base::options(opts)
[16:05:19.670]                 }
[16:05:19.670]                 {
[16:05:19.670]                   {
[16:05:19.670]                     NULL
[16:05:19.670]                     RNGkind("Mersenne-Twister")
[16:05:19.670]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:19.670]                       inherits = FALSE)
[16:05:19.670]                   }
[16:05:19.670]                   options(future.plan = NULL)
[16:05:19.670]                   if (is.na(NA_character_)) 
[16:05:19.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.670]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.670]                     envir = parent.frame()) 
[16:05:19.670]                   {
[16:05:19.670]                     default_workers <- missing(workers)
[16:05:19.670]                     if (is.function(workers)) 
[16:05:19.670]                       workers <- workers()
[16:05:19.670]                     workers <- structure(as.integer(workers), 
[16:05:19.670]                       class = class(workers))
[16:05:19.670]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.670]                       1L)
[16:05:19.670]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.670]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.670]                       if (default_workers) 
[16:05:19.670]                         supportsMulticore(warn = TRUE)
[16:05:19.670]                       return(sequential(..., envir = envir))
[16:05:19.670]                     }
[16:05:19.670]                     oopts <- options(mc.cores = workers)
[16:05:19.670]                     on.exit(options(oopts))
[16:05:19.670]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.670]                       envir = envir)
[16:05:19.670]                     if (!future$lazy) 
[16:05:19.670]                       future <- run(future)
[16:05:19.670]                     invisible(future)
[16:05:19.670]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.670]                 }
[16:05:19.670]             }
[16:05:19.670]         }
[16:05:19.670]     })
[16:05:19.670]     if (TRUE) {
[16:05:19.670]         base::sink(type = "output", split = FALSE)
[16:05:19.670]         if (TRUE) {
[16:05:19.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.670]         }
[16:05:19.670]         else {
[16:05:19.670]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.670]         }
[16:05:19.670]         base::close(...future.stdout)
[16:05:19.670]         ...future.stdout <- NULL
[16:05:19.670]     }
[16:05:19.670]     ...future.result$conditions <- ...future.conditions
[16:05:19.670]     ...future.result$finished <- base::Sys.time()
[16:05:19.670]     ...future.result
[16:05:19.670] }
[16:05:19.672] assign_globals() ...
[16:05:19.672] List of 2
[16:05:19.672]  $ a: num 2
[16:05:19.672]  $ b: num 3
[16:05:19.672]  - attr(*, "where")=List of 2
[16:05:19.672]   ..$ a:<environment: R_EmptyEnv> 
[16:05:19.672]   ..$ b:<environment: R_EmptyEnv> 
[16:05:19.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.672]  - attr(*, "resolved")= logi FALSE
[16:05:19.672]  - attr(*, "total_size")= num 112
[16:05:19.675] - copied ‘a’ to environment
[16:05:19.675] - copied ‘b’ to environment
[16:05:19.675] assign_globals() ... done
[16:05:19.675] plan(): Setting new future strategy stack:
[16:05:19.675] List of future strategies:
[16:05:19.675] 1. sequential:
[16:05:19.675]    - args: function (..., envir = parent.frame())
[16:05:19.675]    - tweaked: FALSE
[16:05:19.675]    - call: NULL
[16:05:19.676] plan(): nbrOfWorkers() = 1
[16:05:19.676] plan(): Setting new future strategy stack:
[16:05:19.676] List of future strategies:
[16:05:19.676] 1. multicore:
[16:05:19.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.676]    - tweaked: FALSE
[16:05:19.676]    - call: plan(multicore)
[16:05:19.680] plan(): nbrOfWorkers() = 1
[16:05:19.680] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[16:05:19.688] getGlobalsAndPackages() ...
[16:05:19.688] Not searching for globals
[16:05:19.688] - globals: [0] <none>
[16:05:19.689] getGlobalsAndPackages() ... DONE
[16:05:19.690] Packages needed by the future expression (n = 0): <none>
[16:05:19.690] Packages needed by future strategies (n = 0): <none>
[16:05:19.690] {
[16:05:19.690]     {
[16:05:19.690]         {
[16:05:19.690]             ...future.startTime <- base::Sys.time()
[16:05:19.690]             {
[16:05:19.690]                 {
[16:05:19.690]                   {
[16:05:19.690]                     {
[16:05:19.690]                       base::local({
[16:05:19.690]                         has_future <- base::requireNamespace("future", 
[16:05:19.690]                           quietly = TRUE)
[16:05:19.690]                         if (has_future) {
[16:05:19.690]                           ns <- base::getNamespace("future")
[16:05:19.690]                           version <- ns[[".package"]][["version"]]
[16:05:19.690]                           if (is.null(version)) 
[16:05:19.690]                             version <- utils::packageVersion("future")
[16:05:19.690]                         }
[16:05:19.690]                         else {
[16:05:19.690]                           version <- NULL
[16:05:19.690]                         }
[16:05:19.690]                         if (!has_future || version < "1.8.0") {
[16:05:19.690]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.690]                             "", base::R.version$version.string), 
[16:05:19.690]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.690]                               "release", "version")], collapse = " "), 
[16:05:19.690]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.690]                             info)
[16:05:19.690]                           info <- base::paste(info, collapse = "; ")
[16:05:19.690]                           if (!has_future) {
[16:05:19.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.690]                               info)
[16:05:19.690]                           }
[16:05:19.690]                           else {
[16:05:19.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.690]                               info, version)
[16:05:19.690]                           }
[16:05:19.690]                           base::stop(msg)
[16:05:19.690]                         }
[16:05:19.690]                       })
[16:05:19.690]                     }
[16:05:19.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.690]                     base::options(mc.cores = 1L)
[16:05:19.690]                   }
[16:05:19.690]                   options(future.plan = NULL)
[16:05:19.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.690]                 }
[16:05:19.690]                 ...future.workdir <- getwd()
[16:05:19.690]             }
[16:05:19.690]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.690]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.690]         }
[16:05:19.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.690]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.690]             base::names(...future.oldOptions))
[16:05:19.690]     }
[16:05:19.690]     if (FALSE) {
[16:05:19.690]     }
[16:05:19.690]     else {
[16:05:19.690]         if (TRUE) {
[16:05:19.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.690]                 open = "w")
[16:05:19.690]         }
[16:05:19.690]         else {
[16:05:19.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.690]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.690]         }
[16:05:19.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.690]             base::sink(type = "output", split = FALSE)
[16:05:19.690]             base::close(...future.stdout)
[16:05:19.690]         }, add = TRUE)
[16:05:19.690]     }
[16:05:19.690]     ...future.frame <- base::sys.nframe()
[16:05:19.690]     ...future.conditions <- base::list()
[16:05:19.690]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.690]     if (FALSE) {
[16:05:19.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.690]     }
[16:05:19.690]     ...future.result <- base::tryCatch({
[16:05:19.690]         base::withCallingHandlers({
[16:05:19.690]             ...future.value <- base::withVisible(base::local({
[16:05:19.690]                 withCallingHandlers({
[16:05:19.690]                   {
[16:05:19.690]                     42L
[16:05:19.690]                   }
[16:05:19.690]                 }, immediateCondition = function(cond) {
[16:05:19.690]                   save_rds <- function (object, pathname, ...) 
[16:05:19.690]                   {
[16:05:19.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.690]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.690]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.690]                         fi_tmp[["mtime"]])
[16:05:19.690]                     }
[16:05:19.690]                     tryCatch({
[16:05:19.690]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.690]                     }, error = function(ex) {
[16:05:19.690]                       msg <- conditionMessage(ex)
[16:05:19.690]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.690]                         fi_tmp[["mtime"]], msg)
[16:05:19.690]                       ex$message <- msg
[16:05:19.690]                       stop(ex)
[16:05:19.690]                     })
[16:05:19.690]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.690]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.690]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.690]                       fi <- file.info(pathname)
[16:05:19.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.690]                         fi[["size"]], fi[["mtime"]])
[16:05:19.690]                       stop(msg)
[16:05:19.690]                     }
[16:05:19.690]                     invisible(pathname)
[16:05:19.690]                   }
[16:05:19.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.690]                     rootPath = tempdir()) 
[16:05:19.690]                   {
[16:05:19.690]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.690]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.690]                       tmpdir = path, fileext = ".rds")
[16:05:19.690]                     save_rds(obj, file)
[16:05:19.690]                   }
[16:05:19.690]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.690]                   {
[16:05:19.690]                     inherits <- base::inherits
[16:05:19.690]                     invokeRestart <- base::invokeRestart
[16:05:19.690]                     is.null <- base::is.null
[16:05:19.690]                     muffled <- FALSE
[16:05:19.690]                     if (inherits(cond, "message")) {
[16:05:19.690]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.690]                       if (muffled) 
[16:05:19.690]                         invokeRestart("muffleMessage")
[16:05:19.690]                     }
[16:05:19.690]                     else if (inherits(cond, "warning")) {
[16:05:19.690]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.690]                       if (muffled) 
[16:05:19.690]                         invokeRestart("muffleWarning")
[16:05:19.690]                     }
[16:05:19.690]                     else if (inherits(cond, "condition")) {
[16:05:19.690]                       if (!is.null(pattern)) {
[16:05:19.690]                         computeRestarts <- base::computeRestarts
[16:05:19.690]                         grepl <- base::grepl
[16:05:19.690]                         restarts <- computeRestarts(cond)
[16:05:19.690]                         for (restart in restarts) {
[16:05:19.690]                           name <- restart$name
[16:05:19.690]                           if (is.null(name)) 
[16:05:19.690]                             next
[16:05:19.690]                           if (!grepl(pattern, name)) 
[16:05:19.690]                             next
[16:05:19.690]                           invokeRestart(restart)
[16:05:19.690]                           muffled <- TRUE
[16:05:19.690]                           break
[16:05:19.690]                         }
[16:05:19.690]                       }
[16:05:19.690]                     }
[16:05:19.690]                     invisible(muffled)
[16:05:19.690]                   }
[16:05:19.690]                   muffleCondition(cond)
[16:05:19.690]                 })
[16:05:19.690]             }))
[16:05:19.690]             future::FutureResult(value = ...future.value$value, 
[16:05:19.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.690]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.690]                     ...future.globalenv.names))
[16:05:19.690]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.690]         }, condition = base::local({
[16:05:19.690]             c <- base::c
[16:05:19.690]             inherits <- base::inherits
[16:05:19.690]             invokeRestart <- base::invokeRestart
[16:05:19.690]             length <- base::length
[16:05:19.690]             list <- base::list
[16:05:19.690]             seq.int <- base::seq.int
[16:05:19.690]             signalCondition <- base::signalCondition
[16:05:19.690]             sys.calls <- base::sys.calls
[16:05:19.690]             `[[` <- base::`[[`
[16:05:19.690]             `+` <- base::`+`
[16:05:19.690]             `<<-` <- base::`<<-`
[16:05:19.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.690]                   3L)]
[16:05:19.690]             }
[16:05:19.690]             function(cond) {
[16:05:19.690]                 is_error <- inherits(cond, "error")
[16:05:19.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.690]                   NULL)
[16:05:19.690]                 if (is_error) {
[16:05:19.690]                   sessionInformation <- function() {
[16:05:19.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.690]                       search = base::search(), system = base::Sys.info())
[16:05:19.690]                   }
[16:05:19.690]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.690]                     cond$call), session = sessionInformation(), 
[16:05:19.690]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.690]                   signalCondition(cond)
[16:05:19.690]                 }
[16:05:19.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.690]                 "immediateCondition"))) {
[16:05:19.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.690]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.690]                   if (TRUE && !signal) {
[16:05:19.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.690]                     {
[16:05:19.690]                       inherits <- base::inherits
[16:05:19.690]                       invokeRestart <- base::invokeRestart
[16:05:19.690]                       is.null <- base::is.null
[16:05:19.690]                       muffled <- FALSE
[16:05:19.690]                       if (inherits(cond, "message")) {
[16:05:19.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.690]                         if (muffled) 
[16:05:19.690]                           invokeRestart("muffleMessage")
[16:05:19.690]                       }
[16:05:19.690]                       else if (inherits(cond, "warning")) {
[16:05:19.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.690]                         if (muffled) 
[16:05:19.690]                           invokeRestart("muffleWarning")
[16:05:19.690]                       }
[16:05:19.690]                       else if (inherits(cond, "condition")) {
[16:05:19.690]                         if (!is.null(pattern)) {
[16:05:19.690]                           computeRestarts <- base::computeRestarts
[16:05:19.690]                           grepl <- base::grepl
[16:05:19.690]                           restarts <- computeRestarts(cond)
[16:05:19.690]                           for (restart in restarts) {
[16:05:19.690]                             name <- restart$name
[16:05:19.690]                             if (is.null(name)) 
[16:05:19.690]                               next
[16:05:19.690]                             if (!grepl(pattern, name)) 
[16:05:19.690]                               next
[16:05:19.690]                             invokeRestart(restart)
[16:05:19.690]                             muffled <- TRUE
[16:05:19.690]                             break
[16:05:19.690]                           }
[16:05:19.690]                         }
[16:05:19.690]                       }
[16:05:19.690]                       invisible(muffled)
[16:05:19.690]                     }
[16:05:19.690]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.690]                   }
[16:05:19.690]                 }
[16:05:19.690]                 else {
[16:05:19.690]                   if (TRUE) {
[16:05:19.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.690]                     {
[16:05:19.690]                       inherits <- base::inherits
[16:05:19.690]                       invokeRestart <- base::invokeRestart
[16:05:19.690]                       is.null <- base::is.null
[16:05:19.690]                       muffled <- FALSE
[16:05:19.690]                       if (inherits(cond, "message")) {
[16:05:19.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.690]                         if (muffled) 
[16:05:19.690]                           invokeRestart("muffleMessage")
[16:05:19.690]                       }
[16:05:19.690]                       else if (inherits(cond, "warning")) {
[16:05:19.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.690]                         if (muffled) 
[16:05:19.690]                           invokeRestart("muffleWarning")
[16:05:19.690]                       }
[16:05:19.690]                       else if (inherits(cond, "condition")) {
[16:05:19.690]                         if (!is.null(pattern)) {
[16:05:19.690]                           computeRestarts <- base::computeRestarts
[16:05:19.690]                           grepl <- base::grepl
[16:05:19.690]                           restarts <- computeRestarts(cond)
[16:05:19.690]                           for (restart in restarts) {
[16:05:19.690]                             name <- restart$name
[16:05:19.690]                             if (is.null(name)) 
[16:05:19.690]                               next
[16:05:19.690]                             if (!grepl(pattern, name)) 
[16:05:19.690]                               next
[16:05:19.690]                             invokeRestart(restart)
[16:05:19.690]                             muffled <- TRUE
[16:05:19.690]                             break
[16:05:19.690]                           }
[16:05:19.690]                         }
[16:05:19.690]                       }
[16:05:19.690]                       invisible(muffled)
[16:05:19.690]                     }
[16:05:19.690]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.690]                   }
[16:05:19.690]                 }
[16:05:19.690]             }
[16:05:19.690]         }))
[16:05:19.690]     }, error = function(ex) {
[16:05:19.690]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.690]                 ...future.rng), started = ...future.startTime, 
[16:05:19.690]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.690]             version = "1.8"), class = "FutureResult")
[16:05:19.690]     }, finally = {
[16:05:19.690]         if (!identical(...future.workdir, getwd())) 
[16:05:19.690]             setwd(...future.workdir)
[16:05:19.690]         {
[16:05:19.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.690]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.690]             }
[16:05:19.690]             base::options(...future.oldOptions)
[16:05:19.690]             if (.Platform$OS.type == "windows") {
[16:05:19.690]                 old_names <- names(...future.oldEnvVars)
[16:05:19.690]                 envs <- base::Sys.getenv()
[16:05:19.690]                 names <- names(envs)
[16:05:19.690]                 common <- intersect(names, old_names)
[16:05:19.690]                 added <- setdiff(names, old_names)
[16:05:19.690]                 removed <- setdiff(old_names, names)
[16:05:19.690]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.690]                   envs[common]]
[16:05:19.690]                 NAMES <- toupper(changed)
[16:05:19.690]                 args <- list()
[16:05:19.690]                 for (kk in seq_along(NAMES)) {
[16:05:19.690]                   name <- changed[[kk]]
[16:05:19.690]                   NAME <- NAMES[[kk]]
[16:05:19.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.690]                     next
[16:05:19.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.690]                 }
[16:05:19.690]                 NAMES <- toupper(added)
[16:05:19.690]                 for (kk in seq_along(NAMES)) {
[16:05:19.690]                   name <- added[[kk]]
[16:05:19.690]                   NAME <- NAMES[[kk]]
[16:05:19.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.690]                     next
[16:05:19.690]                   args[[name]] <- ""
[16:05:19.690]                 }
[16:05:19.690]                 NAMES <- toupper(removed)
[16:05:19.690]                 for (kk in seq_along(NAMES)) {
[16:05:19.690]                   name <- removed[[kk]]
[16:05:19.690]                   NAME <- NAMES[[kk]]
[16:05:19.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.690]                     next
[16:05:19.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.690]                 }
[16:05:19.690]                 if (length(args) > 0) 
[16:05:19.690]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.690]             }
[16:05:19.690]             else {
[16:05:19.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.690]             }
[16:05:19.690]             {
[16:05:19.690]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.690]                   0L) {
[16:05:19.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.690]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.690]                   base::options(opts)
[16:05:19.690]                 }
[16:05:19.690]                 {
[16:05:19.690]                   {
[16:05:19.690]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.690]                     NULL
[16:05:19.690]                   }
[16:05:19.690]                   options(future.plan = NULL)
[16:05:19.690]                   if (is.na(NA_character_)) 
[16:05:19.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.690]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.690]                     envir = parent.frame()) 
[16:05:19.690]                   {
[16:05:19.690]                     default_workers <- missing(workers)
[16:05:19.690]                     if (is.function(workers)) 
[16:05:19.690]                       workers <- workers()
[16:05:19.690]                     workers <- structure(as.integer(workers), 
[16:05:19.690]                       class = class(workers))
[16:05:19.690]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.690]                       1L)
[16:05:19.690]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.690]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.690]                       if (default_workers) 
[16:05:19.690]                         supportsMulticore(warn = TRUE)
[16:05:19.690]                       return(sequential(..., envir = envir))
[16:05:19.690]                     }
[16:05:19.690]                     oopts <- options(mc.cores = workers)
[16:05:19.690]                     on.exit(options(oopts))
[16:05:19.690]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.690]                       envir = envir)
[16:05:19.690]                     if (!future$lazy) 
[16:05:19.690]                       future <- run(future)
[16:05:19.690]                     invisible(future)
[16:05:19.690]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.690]                 }
[16:05:19.690]             }
[16:05:19.690]         }
[16:05:19.690]     })
[16:05:19.690]     if (TRUE) {
[16:05:19.690]         base::sink(type = "output", split = FALSE)
[16:05:19.690]         if (TRUE) {
[16:05:19.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.690]         }
[16:05:19.690]         else {
[16:05:19.690]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.690]         }
[16:05:19.690]         base::close(...future.stdout)
[16:05:19.690]         ...future.stdout <- NULL
[16:05:19.690]     }
[16:05:19.690]     ...future.result$conditions <- ...future.conditions
[16:05:19.690]     ...future.result$finished <- base::Sys.time()
[16:05:19.690]     ...future.result
[16:05:19.690] }
[16:05:19.693] requestCore(): workers = 2
[16:05:19.695] MulticoreFuture started
[16:05:19.696] plan(): Setting new future strategy stack:
[16:05:19.696] List of future strategies:
[16:05:19.696] 1. sequential:
[16:05:19.696]    - args: function (..., envir = parent.frame())
[16:05:19.696]    - tweaked: FALSE
[16:05:19.696]    - call: NULL
[16:05:19.697] plan(): nbrOfWorkers() = 1
[16:05:19.699] plan(): Setting new future strategy stack:
[16:05:19.699] List of future strategies:
[16:05:19.699] 1. multicore:
[16:05:19.699]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.699]    - tweaked: FALSE
[16:05:19.699]    - call: plan(multicore)
[16:05:19.704] plan(): nbrOfWorkers() = 2
[1] TRUE
[16:05:19.706] result() for MulticoreFuture ...
[16:05:19.711] result() for MulticoreFuture ...
[16:05:19.711] result() for MulticoreFuture ... done
[16:05:19.711] result() for MulticoreFuture ... done
[16:05:19.711] result() for MulticoreFuture ...
[16:05:19.712] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = FALSE) with globals
[16:05:19.715] getGlobalsAndPackages() ...
[16:05:19.716] Not searching for globals
[16:05:19.716] - globals: [0] <none>
[16:05:19.716] getGlobalsAndPackages() ... DONE
[16:05:19.716] Packages needed by the future expression (n = 0): <none>
[16:05:19.716] Packages needed by future strategies (n = 0): <none>
[16:05:19.717] {
[16:05:19.717]     {
[16:05:19.717]         {
[16:05:19.717]             ...future.startTime <- base::Sys.time()
[16:05:19.717]             {
[16:05:19.717]                 {
[16:05:19.717]                   {
[16:05:19.717]                     {
[16:05:19.717]                       base::local({
[16:05:19.717]                         has_future <- base::requireNamespace("future", 
[16:05:19.717]                           quietly = TRUE)
[16:05:19.717]                         if (has_future) {
[16:05:19.717]                           ns <- base::getNamespace("future")
[16:05:19.717]                           version <- ns[[".package"]][["version"]]
[16:05:19.717]                           if (is.null(version)) 
[16:05:19.717]                             version <- utils::packageVersion("future")
[16:05:19.717]                         }
[16:05:19.717]                         else {
[16:05:19.717]                           version <- NULL
[16:05:19.717]                         }
[16:05:19.717]                         if (!has_future || version < "1.8.0") {
[16:05:19.717]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.717]                             "", base::R.version$version.string), 
[16:05:19.717]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.717]                               "release", "version")], collapse = " "), 
[16:05:19.717]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.717]                             info)
[16:05:19.717]                           info <- base::paste(info, collapse = "; ")
[16:05:19.717]                           if (!has_future) {
[16:05:19.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.717]                               info)
[16:05:19.717]                           }
[16:05:19.717]                           else {
[16:05:19.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.717]                               info, version)
[16:05:19.717]                           }
[16:05:19.717]                           base::stop(msg)
[16:05:19.717]                         }
[16:05:19.717]                       })
[16:05:19.717]                     }
[16:05:19.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.717]                     base::options(mc.cores = 1L)
[16:05:19.717]                   }
[16:05:19.717]                   options(future.plan = NULL)
[16:05:19.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.717]                 }
[16:05:19.717]                 ...future.workdir <- getwd()
[16:05:19.717]             }
[16:05:19.717]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.717]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.717]         }
[16:05:19.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.717]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.717]             base::names(...future.oldOptions))
[16:05:19.717]     }
[16:05:19.717]     if (FALSE) {
[16:05:19.717]     }
[16:05:19.717]     else {
[16:05:19.717]         if (TRUE) {
[16:05:19.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.717]                 open = "w")
[16:05:19.717]         }
[16:05:19.717]         else {
[16:05:19.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.717]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.717]         }
[16:05:19.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.717]             base::sink(type = "output", split = FALSE)
[16:05:19.717]             base::close(...future.stdout)
[16:05:19.717]         }, add = TRUE)
[16:05:19.717]     }
[16:05:19.717]     ...future.frame <- base::sys.nframe()
[16:05:19.717]     ...future.conditions <- base::list()
[16:05:19.717]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.717]     if (FALSE) {
[16:05:19.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.717]     }
[16:05:19.717]     ...future.result <- base::tryCatch({
[16:05:19.717]         base::withCallingHandlers({
[16:05:19.717]             ...future.value <- base::withVisible(base::local({
[16:05:19.717]                 withCallingHandlers({
[16:05:19.717]                   {
[16:05:19.717]                     b <- 3
[16:05:19.717]                     c <- 2
[16:05:19.717]                     a * b * c
[16:05:19.717]                   }
[16:05:19.717]                 }, immediateCondition = function(cond) {
[16:05:19.717]                   save_rds <- function (object, pathname, ...) 
[16:05:19.717]                   {
[16:05:19.717]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.717]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.717]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.717]                         fi_tmp[["mtime"]])
[16:05:19.717]                     }
[16:05:19.717]                     tryCatch({
[16:05:19.717]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.717]                     }, error = function(ex) {
[16:05:19.717]                       msg <- conditionMessage(ex)
[16:05:19.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.717]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.717]                         fi_tmp[["mtime"]], msg)
[16:05:19.717]                       ex$message <- msg
[16:05:19.717]                       stop(ex)
[16:05:19.717]                     })
[16:05:19.717]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.717]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.717]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.717]                       fi <- file.info(pathname)
[16:05:19.717]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.717]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.717]                         fi[["size"]], fi[["mtime"]])
[16:05:19.717]                       stop(msg)
[16:05:19.717]                     }
[16:05:19.717]                     invisible(pathname)
[16:05:19.717]                   }
[16:05:19.717]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.717]                     rootPath = tempdir()) 
[16:05:19.717]                   {
[16:05:19.717]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.717]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.717]                       tmpdir = path, fileext = ".rds")
[16:05:19.717]                     save_rds(obj, file)
[16:05:19.717]                   }
[16:05:19.717]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.717]                   {
[16:05:19.717]                     inherits <- base::inherits
[16:05:19.717]                     invokeRestart <- base::invokeRestart
[16:05:19.717]                     is.null <- base::is.null
[16:05:19.717]                     muffled <- FALSE
[16:05:19.717]                     if (inherits(cond, "message")) {
[16:05:19.717]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.717]                       if (muffled) 
[16:05:19.717]                         invokeRestart("muffleMessage")
[16:05:19.717]                     }
[16:05:19.717]                     else if (inherits(cond, "warning")) {
[16:05:19.717]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.717]                       if (muffled) 
[16:05:19.717]                         invokeRestart("muffleWarning")
[16:05:19.717]                     }
[16:05:19.717]                     else if (inherits(cond, "condition")) {
[16:05:19.717]                       if (!is.null(pattern)) {
[16:05:19.717]                         computeRestarts <- base::computeRestarts
[16:05:19.717]                         grepl <- base::grepl
[16:05:19.717]                         restarts <- computeRestarts(cond)
[16:05:19.717]                         for (restart in restarts) {
[16:05:19.717]                           name <- restart$name
[16:05:19.717]                           if (is.null(name)) 
[16:05:19.717]                             next
[16:05:19.717]                           if (!grepl(pattern, name)) 
[16:05:19.717]                             next
[16:05:19.717]                           invokeRestart(restart)
[16:05:19.717]                           muffled <- TRUE
[16:05:19.717]                           break
[16:05:19.717]                         }
[16:05:19.717]                       }
[16:05:19.717]                     }
[16:05:19.717]                     invisible(muffled)
[16:05:19.717]                   }
[16:05:19.717]                   muffleCondition(cond)
[16:05:19.717]                 })
[16:05:19.717]             }))
[16:05:19.717]             future::FutureResult(value = ...future.value$value, 
[16:05:19.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.717]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.717]                     ...future.globalenv.names))
[16:05:19.717]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.717]         }, condition = base::local({
[16:05:19.717]             c <- base::c
[16:05:19.717]             inherits <- base::inherits
[16:05:19.717]             invokeRestart <- base::invokeRestart
[16:05:19.717]             length <- base::length
[16:05:19.717]             list <- base::list
[16:05:19.717]             seq.int <- base::seq.int
[16:05:19.717]             signalCondition <- base::signalCondition
[16:05:19.717]             sys.calls <- base::sys.calls
[16:05:19.717]             `[[` <- base::`[[`
[16:05:19.717]             `+` <- base::`+`
[16:05:19.717]             `<<-` <- base::`<<-`
[16:05:19.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.717]                   3L)]
[16:05:19.717]             }
[16:05:19.717]             function(cond) {
[16:05:19.717]                 is_error <- inherits(cond, "error")
[16:05:19.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.717]                   NULL)
[16:05:19.717]                 if (is_error) {
[16:05:19.717]                   sessionInformation <- function() {
[16:05:19.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.717]                       search = base::search(), system = base::Sys.info())
[16:05:19.717]                   }
[16:05:19.717]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.717]                     cond$call), session = sessionInformation(), 
[16:05:19.717]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.717]                   signalCondition(cond)
[16:05:19.717]                 }
[16:05:19.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.717]                 "immediateCondition"))) {
[16:05:19.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.717]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.717]                   if (TRUE && !signal) {
[16:05:19.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.717]                     {
[16:05:19.717]                       inherits <- base::inherits
[16:05:19.717]                       invokeRestart <- base::invokeRestart
[16:05:19.717]                       is.null <- base::is.null
[16:05:19.717]                       muffled <- FALSE
[16:05:19.717]                       if (inherits(cond, "message")) {
[16:05:19.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.717]                         if (muffled) 
[16:05:19.717]                           invokeRestart("muffleMessage")
[16:05:19.717]                       }
[16:05:19.717]                       else if (inherits(cond, "warning")) {
[16:05:19.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.717]                         if (muffled) 
[16:05:19.717]                           invokeRestart("muffleWarning")
[16:05:19.717]                       }
[16:05:19.717]                       else if (inherits(cond, "condition")) {
[16:05:19.717]                         if (!is.null(pattern)) {
[16:05:19.717]                           computeRestarts <- base::computeRestarts
[16:05:19.717]                           grepl <- base::grepl
[16:05:19.717]                           restarts <- computeRestarts(cond)
[16:05:19.717]                           for (restart in restarts) {
[16:05:19.717]                             name <- restart$name
[16:05:19.717]                             if (is.null(name)) 
[16:05:19.717]                               next
[16:05:19.717]                             if (!grepl(pattern, name)) 
[16:05:19.717]                               next
[16:05:19.717]                             invokeRestart(restart)
[16:05:19.717]                             muffled <- TRUE
[16:05:19.717]                             break
[16:05:19.717]                           }
[16:05:19.717]                         }
[16:05:19.717]                       }
[16:05:19.717]                       invisible(muffled)
[16:05:19.717]                     }
[16:05:19.717]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.717]                   }
[16:05:19.717]                 }
[16:05:19.717]                 else {
[16:05:19.717]                   if (TRUE) {
[16:05:19.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.717]                     {
[16:05:19.717]                       inherits <- base::inherits
[16:05:19.717]                       invokeRestart <- base::invokeRestart
[16:05:19.717]                       is.null <- base::is.null
[16:05:19.717]                       muffled <- FALSE
[16:05:19.717]                       if (inherits(cond, "message")) {
[16:05:19.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.717]                         if (muffled) 
[16:05:19.717]                           invokeRestart("muffleMessage")
[16:05:19.717]                       }
[16:05:19.717]                       else if (inherits(cond, "warning")) {
[16:05:19.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.717]                         if (muffled) 
[16:05:19.717]                           invokeRestart("muffleWarning")
[16:05:19.717]                       }
[16:05:19.717]                       else if (inherits(cond, "condition")) {
[16:05:19.717]                         if (!is.null(pattern)) {
[16:05:19.717]                           computeRestarts <- base::computeRestarts
[16:05:19.717]                           grepl <- base::grepl
[16:05:19.717]                           restarts <- computeRestarts(cond)
[16:05:19.717]                           for (restart in restarts) {
[16:05:19.717]                             name <- restart$name
[16:05:19.717]                             if (is.null(name)) 
[16:05:19.717]                               next
[16:05:19.717]                             if (!grepl(pattern, name)) 
[16:05:19.717]                               next
[16:05:19.717]                             invokeRestart(restart)
[16:05:19.717]                             muffled <- TRUE
[16:05:19.717]                             break
[16:05:19.717]                           }
[16:05:19.717]                         }
[16:05:19.717]                       }
[16:05:19.717]                       invisible(muffled)
[16:05:19.717]                     }
[16:05:19.717]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.717]                   }
[16:05:19.717]                 }
[16:05:19.717]             }
[16:05:19.717]         }))
[16:05:19.717]     }, error = function(ex) {
[16:05:19.717]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.717]                 ...future.rng), started = ...future.startTime, 
[16:05:19.717]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.717]             version = "1.8"), class = "FutureResult")
[16:05:19.717]     }, finally = {
[16:05:19.717]         if (!identical(...future.workdir, getwd())) 
[16:05:19.717]             setwd(...future.workdir)
[16:05:19.717]         {
[16:05:19.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.717]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.717]             }
[16:05:19.717]             base::options(...future.oldOptions)
[16:05:19.717]             if (.Platform$OS.type == "windows") {
[16:05:19.717]                 old_names <- names(...future.oldEnvVars)
[16:05:19.717]                 envs <- base::Sys.getenv()
[16:05:19.717]                 names <- names(envs)
[16:05:19.717]                 common <- intersect(names, old_names)
[16:05:19.717]                 added <- setdiff(names, old_names)
[16:05:19.717]                 removed <- setdiff(old_names, names)
[16:05:19.717]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.717]                   envs[common]]
[16:05:19.717]                 NAMES <- toupper(changed)
[16:05:19.717]                 args <- list()
[16:05:19.717]                 for (kk in seq_along(NAMES)) {
[16:05:19.717]                   name <- changed[[kk]]
[16:05:19.717]                   NAME <- NAMES[[kk]]
[16:05:19.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.717]                     next
[16:05:19.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.717]                 }
[16:05:19.717]                 NAMES <- toupper(added)
[16:05:19.717]                 for (kk in seq_along(NAMES)) {
[16:05:19.717]                   name <- added[[kk]]
[16:05:19.717]                   NAME <- NAMES[[kk]]
[16:05:19.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.717]                     next
[16:05:19.717]                   args[[name]] <- ""
[16:05:19.717]                 }
[16:05:19.717]                 NAMES <- toupper(removed)
[16:05:19.717]                 for (kk in seq_along(NAMES)) {
[16:05:19.717]                   name <- removed[[kk]]
[16:05:19.717]                   NAME <- NAMES[[kk]]
[16:05:19.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.717]                     next
[16:05:19.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.717]                 }
[16:05:19.717]                 if (length(args) > 0) 
[16:05:19.717]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.717]             }
[16:05:19.717]             else {
[16:05:19.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.717]             }
[16:05:19.717]             {
[16:05:19.717]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.717]                   0L) {
[16:05:19.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.717]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.717]                   base::options(opts)
[16:05:19.717]                 }
[16:05:19.717]                 {
[16:05:19.717]                   {
[16:05:19.717]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.717]                     NULL
[16:05:19.717]                   }
[16:05:19.717]                   options(future.plan = NULL)
[16:05:19.717]                   if (is.na(NA_character_)) 
[16:05:19.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.717]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.717]                     envir = parent.frame()) 
[16:05:19.717]                   {
[16:05:19.717]                     default_workers <- missing(workers)
[16:05:19.717]                     if (is.function(workers)) 
[16:05:19.717]                       workers <- workers()
[16:05:19.717]                     workers <- structure(as.integer(workers), 
[16:05:19.717]                       class = class(workers))
[16:05:19.717]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.717]                       1L)
[16:05:19.717]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.717]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.717]                       if (default_workers) 
[16:05:19.717]                         supportsMulticore(warn = TRUE)
[16:05:19.717]                       return(sequential(..., envir = envir))
[16:05:19.717]                     }
[16:05:19.717]                     oopts <- options(mc.cores = workers)
[16:05:19.717]                     on.exit(options(oopts))
[16:05:19.717]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.717]                       envir = envir)
[16:05:19.717]                     if (!future$lazy) 
[16:05:19.717]                       future <- run(future)
[16:05:19.717]                     invisible(future)
[16:05:19.717]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.717]                 }
[16:05:19.717]             }
[16:05:19.717]         }
[16:05:19.717]     })
[16:05:19.717]     if (TRUE) {
[16:05:19.717]         base::sink(type = "output", split = FALSE)
[16:05:19.717]         if (TRUE) {
[16:05:19.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.717]         }
[16:05:19.717]         else {
[16:05:19.717]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.717]         }
[16:05:19.717]         base::close(...future.stdout)
[16:05:19.717]         ...future.stdout <- NULL
[16:05:19.717]     }
[16:05:19.717]     ...future.result$conditions <- ...future.conditions
[16:05:19.717]     ...future.result$finished <- base::Sys.time()
[16:05:19.717]     ...future.result
[16:05:19.717] }
[16:05:19.720] requestCore(): workers = 2
[16:05:19.722] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:19.723] plan(): Setting new future strategy stack:
[16:05:19.723] List of future strategies:
[16:05:19.723] 1. sequential:
[16:05:19.723]    - args: function (..., envir = parent.frame())
[16:05:19.723]    - tweaked: FALSE
[16:05:19.723]    - call: NULL
[16:05:19.724] plan(): nbrOfWorkers() = 1
[16:05:19.726] plan(): Setting new future strategy stack:
[16:05:19.726] List of future strategies:
[16:05:19.726] 1. multicore:
[16:05:19.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.726]    - tweaked: FALSE
[16:05:19.726]    - call: plan(multicore)
[16:05:19.731] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:19.732] result() for MulticoreFuture ...
[16:05:19.733] result() for MulticoreFuture ...
[16:05:19.733] result() for MulticoreFuture ... done
[16:05:19.733] result() for MulticoreFuture ... done
[16:05:19.733] result() for MulticoreFuture ...
[16:05:19.733] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[16:05:19.737] getGlobalsAndPackages() ...
[16:05:19.737] Not searching for globals
[16:05:19.738] - globals: [0] <none>
[16:05:19.738] getGlobalsAndPackages() ... DONE
[16:05:19.738] Packages needed by the future expression (n = 0): <none>
[16:05:19.738] Packages needed by future strategies (n = 0): <none>
[16:05:19.739] {
[16:05:19.739]     {
[16:05:19.739]         {
[16:05:19.739]             ...future.startTime <- base::Sys.time()
[16:05:19.739]             {
[16:05:19.739]                 {
[16:05:19.739]                   {
[16:05:19.739]                     {
[16:05:19.739]                       base::local({
[16:05:19.739]                         has_future <- base::requireNamespace("future", 
[16:05:19.739]                           quietly = TRUE)
[16:05:19.739]                         if (has_future) {
[16:05:19.739]                           ns <- base::getNamespace("future")
[16:05:19.739]                           version <- ns[[".package"]][["version"]]
[16:05:19.739]                           if (is.null(version)) 
[16:05:19.739]                             version <- utils::packageVersion("future")
[16:05:19.739]                         }
[16:05:19.739]                         else {
[16:05:19.739]                           version <- NULL
[16:05:19.739]                         }
[16:05:19.739]                         if (!has_future || version < "1.8.0") {
[16:05:19.739]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.739]                             "", base::R.version$version.string), 
[16:05:19.739]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.739]                               "release", "version")], collapse = " "), 
[16:05:19.739]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.739]                             info)
[16:05:19.739]                           info <- base::paste(info, collapse = "; ")
[16:05:19.739]                           if (!has_future) {
[16:05:19.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.739]                               info)
[16:05:19.739]                           }
[16:05:19.739]                           else {
[16:05:19.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.739]                               info, version)
[16:05:19.739]                           }
[16:05:19.739]                           base::stop(msg)
[16:05:19.739]                         }
[16:05:19.739]                       })
[16:05:19.739]                     }
[16:05:19.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.739]                     base::options(mc.cores = 1L)
[16:05:19.739]                   }
[16:05:19.739]                   options(future.plan = NULL)
[16:05:19.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.739]                 }
[16:05:19.739]                 ...future.workdir <- getwd()
[16:05:19.739]             }
[16:05:19.739]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.739]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.739]         }
[16:05:19.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.739]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.739]             base::names(...future.oldOptions))
[16:05:19.739]     }
[16:05:19.739]     if (FALSE) {
[16:05:19.739]     }
[16:05:19.739]     else {
[16:05:19.739]         if (TRUE) {
[16:05:19.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.739]                 open = "w")
[16:05:19.739]         }
[16:05:19.739]         else {
[16:05:19.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.739]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.739]         }
[16:05:19.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.739]             base::sink(type = "output", split = FALSE)
[16:05:19.739]             base::close(...future.stdout)
[16:05:19.739]         }, add = TRUE)
[16:05:19.739]     }
[16:05:19.739]     ...future.frame <- base::sys.nframe()
[16:05:19.739]     ...future.conditions <- base::list()
[16:05:19.739]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.739]     if (FALSE) {
[16:05:19.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.739]     }
[16:05:19.739]     ...future.result <- base::tryCatch({
[16:05:19.739]         base::withCallingHandlers({
[16:05:19.739]             ...future.value <- base::withVisible(base::local({
[16:05:19.739]                 withCallingHandlers({
[16:05:19.739]                   {
[16:05:19.739]                     ii
[16:05:19.739]                   }
[16:05:19.739]                 }, immediateCondition = function(cond) {
[16:05:19.739]                   save_rds <- function (object, pathname, ...) 
[16:05:19.739]                   {
[16:05:19.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.739]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.739]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.739]                         fi_tmp[["mtime"]])
[16:05:19.739]                     }
[16:05:19.739]                     tryCatch({
[16:05:19.739]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.739]                     }, error = function(ex) {
[16:05:19.739]                       msg <- conditionMessage(ex)
[16:05:19.739]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.739]                         fi_tmp[["mtime"]], msg)
[16:05:19.739]                       ex$message <- msg
[16:05:19.739]                       stop(ex)
[16:05:19.739]                     })
[16:05:19.739]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.739]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.739]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.739]                       fi <- file.info(pathname)
[16:05:19.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.739]                         fi[["size"]], fi[["mtime"]])
[16:05:19.739]                       stop(msg)
[16:05:19.739]                     }
[16:05:19.739]                     invisible(pathname)
[16:05:19.739]                   }
[16:05:19.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.739]                     rootPath = tempdir()) 
[16:05:19.739]                   {
[16:05:19.739]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.739]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.739]                       tmpdir = path, fileext = ".rds")
[16:05:19.739]                     save_rds(obj, file)
[16:05:19.739]                   }
[16:05:19.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.739]                   {
[16:05:19.739]                     inherits <- base::inherits
[16:05:19.739]                     invokeRestart <- base::invokeRestart
[16:05:19.739]                     is.null <- base::is.null
[16:05:19.739]                     muffled <- FALSE
[16:05:19.739]                     if (inherits(cond, "message")) {
[16:05:19.739]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.739]                       if (muffled) 
[16:05:19.739]                         invokeRestart("muffleMessage")
[16:05:19.739]                     }
[16:05:19.739]                     else if (inherits(cond, "warning")) {
[16:05:19.739]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.739]                       if (muffled) 
[16:05:19.739]                         invokeRestart("muffleWarning")
[16:05:19.739]                     }
[16:05:19.739]                     else if (inherits(cond, "condition")) {
[16:05:19.739]                       if (!is.null(pattern)) {
[16:05:19.739]                         computeRestarts <- base::computeRestarts
[16:05:19.739]                         grepl <- base::grepl
[16:05:19.739]                         restarts <- computeRestarts(cond)
[16:05:19.739]                         for (restart in restarts) {
[16:05:19.739]                           name <- restart$name
[16:05:19.739]                           if (is.null(name)) 
[16:05:19.739]                             next
[16:05:19.739]                           if (!grepl(pattern, name)) 
[16:05:19.739]                             next
[16:05:19.739]                           invokeRestart(restart)
[16:05:19.739]                           muffled <- TRUE
[16:05:19.739]                           break
[16:05:19.739]                         }
[16:05:19.739]                       }
[16:05:19.739]                     }
[16:05:19.739]                     invisible(muffled)
[16:05:19.739]                   }
[16:05:19.739]                   muffleCondition(cond)
[16:05:19.739]                 })
[16:05:19.739]             }))
[16:05:19.739]             future::FutureResult(value = ...future.value$value, 
[16:05:19.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.739]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.739]                     ...future.globalenv.names))
[16:05:19.739]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.739]         }, condition = base::local({
[16:05:19.739]             c <- base::c
[16:05:19.739]             inherits <- base::inherits
[16:05:19.739]             invokeRestart <- base::invokeRestart
[16:05:19.739]             length <- base::length
[16:05:19.739]             list <- base::list
[16:05:19.739]             seq.int <- base::seq.int
[16:05:19.739]             signalCondition <- base::signalCondition
[16:05:19.739]             sys.calls <- base::sys.calls
[16:05:19.739]             `[[` <- base::`[[`
[16:05:19.739]             `+` <- base::`+`
[16:05:19.739]             `<<-` <- base::`<<-`
[16:05:19.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.739]                   3L)]
[16:05:19.739]             }
[16:05:19.739]             function(cond) {
[16:05:19.739]                 is_error <- inherits(cond, "error")
[16:05:19.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.739]                   NULL)
[16:05:19.739]                 if (is_error) {
[16:05:19.739]                   sessionInformation <- function() {
[16:05:19.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.739]                       search = base::search(), system = base::Sys.info())
[16:05:19.739]                   }
[16:05:19.739]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.739]                     cond$call), session = sessionInformation(), 
[16:05:19.739]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.739]                   signalCondition(cond)
[16:05:19.739]                 }
[16:05:19.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.739]                 "immediateCondition"))) {
[16:05:19.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.739]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.739]                   if (TRUE && !signal) {
[16:05:19.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.739]                     {
[16:05:19.739]                       inherits <- base::inherits
[16:05:19.739]                       invokeRestart <- base::invokeRestart
[16:05:19.739]                       is.null <- base::is.null
[16:05:19.739]                       muffled <- FALSE
[16:05:19.739]                       if (inherits(cond, "message")) {
[16:05:19.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.739]                         if (muffled) 
[16:05:19.739]                           invokeRestart("muffleMessage")
[16:05:19.739]                       }
[16:05:19.739]                       else if (inherits(cond, "warning")) {
[16:05:19.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.739]                         if (muffled) 
[16:05:19.739]                           invokeRestart("muffleWarning")
[16:05:19.739]                       }
[16:05:19.739]                       else if (inherits(cond, "condition")) {
[16:05:19.739]                         if (!is.null(pattern)) {
[16:05:19.739]                           computeRestarts <- base::computeRestarts
[16:05:19.739]                           grepl <- base::grepl
[16:05:19.739]                           restarts <- computeRestarts(cond)
[16:05:19.739]                           for (restart in restarts) {
[16:05:19.739]                             name <- restart$name
[16:05:19.739]                             if (is.null(name)) 
[16:05:19.739]                               next
[16:05:19.739]                             if (!grepl(pattern, name)) 
[16:05:19.739]                               next
[16:05:19.739]                             invokeRestart(restart)
[16:05:19.739]                             muffled <- TRUE
[16:05:19.739]                             break
[16:05:19.739]                           }
[16:05:19.739]                         }
[16:05:19.739]                       }
[16:05:19.739]                       invisible(muffled)
[16:05:19.739]                     }
[16:05:19.739]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.739]                   }
[16:05:19.739]                 }
[16:05:19.739]                 else {
[16:05:19.739]                   if (TRUE) {
[16:05:19.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.739]                     {
[16:05:19.739]                       inherits <- base::inherits
[16:05:19.739]                       invokeRestart <- base::invokeRestart
[16:05:19.739]                       is.null <- base::is.null
[16:05:19.739]                       muffled <- FALSE
[16:05:19.739]                       if (inherits(cond, "message")) {
[16:05:19.739]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.739]                         if (muffled) 
[16:05:19.739]                           invokeRestart("muffleMessage")
[16:05:19.739]                       }
[16:05:19.739]                       else if (inherits(cond, "warning")) {
[16:05:19.739]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.739]                         if (muffled) 
[16:05:19.739]                           invokeRestart("muffleWarning")
[16:05:19.739]                       }
[16:05:19.739]                       else if (inherits(cond, "condition")) {
[16:05:19.739]                         if (!is.null(pattern)) {
[16:05:19.739]                           computeRestarts <- base::computeRestarts
[16:05:19.739]                           grepl <- base::grepl
[16:05:19.739]                           restarts <- computeRestarts(cond)
[16:05:19.739]                           for (restart in restarts) {
[16:05:19.739]                             name <- restart$name
[16:05:19.739]                             if (is.null(name)) 
[16:05:19.739]                               next
[16:05:19.739]                             if (!grepl(pattern, name)) 
[16:05:19.739]                               next
[16:05:19.739]                             invokeRestart(restart)
[16:05:19.739]                             muffled <- TRUE
[16:05:19.739]                             break
[16:05:19.739]                           }
[16:05:19.739]                         }
[16:05:19.739]                       }
[16:05:19.739]                       invisible(muffled)
[16:05:19.739]                     }
[16:05:19.739]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.739]                   }
[16:05:19.739]                 }
[16:05:19.739]             }
[16:05:19.739]         }))
[16:05:19.739]     }, error = function(ex) {
[16:05:19.739]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.739]                 ...future.rng), started = ...future.startTime, 
[16:05:19.739]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.739]             version = "1.8"), class = "FutureResult")
[16:05:19.739]     }, finally = {
[16:05:19.739]         if (!identical(...future.workdir, getwd())) 
[16:05:19.739]             setwd(...future.workdir)
[16:05:19.739]         {
[16:05:19.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.739]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.739]             }
[16:05:19.739]             base::options(...future.oldOptions)
[16:05:19.739]             if (.Platform$OS.type == "windows") {
[16:05:19.739]                 old_names <- names(...future.oldEnvVars)
[16:05:19.739]                 envs <- base::Sys.getenv()
[16:05:19.739]                 names <- names(envs)
[16:05:19.739]                 common <- intersect(names, old_names)
[16:05:19.739]                 added <- setdiff(names, old_names)
[16:05:19.739]                 removed <- setdiff(old_names, names)
[16:05:19.739]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.739]                   envs[common]]
[16:05:19.739]                 NAMES <- toupper(changed)
[16:05:19.739]                 args <- list()
[16:05:19.739]                 for (kk in seq_along(NAMES)) {
[16:05:19.739]                   name <- changed[[kk]]
[16:05:19.739]                   NAME <- NAMES[[kk]]
[16:05:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.739]                     next
[16:05:19.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.739]                 }
[16:05:19.739]                 NAMES <- toupper(added)
[16:05:19.739]                 for (kk in seq_along(NAMES)) {
[16:05:19.739]                   name <- added[[kk]]
[16:05:19.739]                   NAME <- NAMES[[kk]]
[16:05:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.739]                     next
[16:05:19.739]                   args[[name]] <- ""
[16:05:19.739]                 }
[16:05:19.739]                 NAMES <- toupper(removed)
[16:05:19.739]                 for (kk in seq_along(NAMES)) {
[16:05:19.739]                   name <- removed[[kk]]
[16:05:19.739]                   NAME <- NAMES[[kk]]
[16:05:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.739]                     next
[16:05:19.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.739]                 }
[16:05:19.739]                 if (length(args) > 0) 
[16:05:19.739]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.739]             }
[16:05:19.739]             else {
[16:05:19.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.739]             }
[16:05:19.739]             {
[16:05:19.739]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.739]                   0L) {
[16:05:19.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.739]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.739]                   base::options(opts)
[16:05:19.739]                 }
[16:05:19.739]                 {
[16:05:19.739]                   {
[16:05:19.739]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.739]                     NULL
[16:05:19.739]                   }
[16:05:19.739]                   options(future.plan = NULL)
[16:05:19.739]                   if (is.na(NA_character_)) 
[16:05:19.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.739]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.739]                     envir = parent.frame()) 
[16:05:19.739]                   {
[16:05:19.739]                     default_workers <- missing(workers)
[16:05:19.739]                     if (is.function(workers)) 
[16:05:19.739]                       workers <- workers()
[16:05:19.739]                     workers <- structure(as.integer(workers), 
[16:05:19.739]                       class = class(workers))
[16:05:19.739]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.739]                       1L)
[16:05:19.739]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.739]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.739]                       if (default_workers) 
[16:05:19.739]                         supportsMulticore(warn = TRUE)
[16:05:19.739]                       return(sequential(..., envir = envir))
[16:05:19.739]                     }
[16:05:19.739]                     oopts <- options(mc.cores = workers)
[16:05:19.739]                     on.exit(options(oopts))
[16:05:19.739]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.739]                       envir = envir)
[16:05:19.739]                     if (!future$lazy) 
[16:05:19.739]                       future <- run(future)
[16:05:19.739]                     invisible(future)
[16:05:19.739]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.739]                 }
[16:05:19.739]             }
[16:05:19.739]         }
[16:05:19.739]     })
[16:05:19.739]     if (TRUE) {
[16:05:19.739]         base::sink(type = "output", split = FALSE)
[16:05:19.739]         if (TRUE) {
[16:05:19.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.739]         }
[16:05:19.739]         else {
[16:05:19.739]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.739]         }
[16:05:19.739]         base::close(...future.stdout)
[16:05:19.739]         ...future.stdout <- NULL
[16:05:19.739]     }
[16:05:19.739]     ...future.result$conditions <- ...future.conditions
[16:05:19.739]     ...future.result$finished <- base::Sys.time()
[16:05:19.739]     ...future.result
[16:05:19.739] }
[16:05:19.742] requestCore(): workers = 2
[16:05:19.743] MulticoreFuture started
 - Creating multicore future #2 ...
[16:05:19.745] plan(): Setting new future strategy stack:
[16:05:19.745] List of future strategies:
[16:05:19.745] 1. sequential:
[16:05:19.745]    - args: function (..., envir = parent.frame())
[16:05:19.745]    - tweaked: FALSE
[16:05:19.745]    - call: NULL
[16:05:19.746] plan(): nbrOfWorkers() = 1
[16:05:19.747] plan(): Setting new future strategy stack:
[16:05:19.748] List of future strategies:
[16:05:19.748] 1. multicore:
[16:05:19.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.748]    - tweaked: FALSE
[16:05:19.748]    - call: plan(multicore)
[16:05:19.749] getGlobalsAndPackages() ...
[16:05:19.749] Not searching for globals
[16:05:19.749] - globals: [0] <none>
[16:05:19.749] getGlobalsAndPackages() ... DONE
[16:05:19.750] Packages needed by the future expression (n = 0): <none>
[16:05:19.750] Packages needed by future strategies (n = 0): <none>
[16:05:19.752] plan(): nbrOfWorkers() = 2
[16:05:19.751] {
[16:05:19.751]     {
[16:05:19.751]         {
[16:05:19.751]             ...future.startTime <- base::Sys.time()
[16:05:19.751]             {
[16:05:19.751]                 {
[16:05:19.751]                   {
[16:05:19.751]                     {
[16:05:19.751]                       base::local({
[16:05:19.751]                         has_future <- base::requireNamespace("future", 
[16:05:19.751]                           quietly = TRUE)
[16:05:19.751]                         if (has_future) {
[16:05:19.751]                           ns <- base::getNamespace("future")
[16:05:19.751]                           version <- ns[[".package"]][["version"]]
[16:05:19.751]                           if (is.null(version)) 
[16:05:19.751]                             version <- utils::packageVersion("future")
[16:05:19.751]                         }
[16:05:19.751]                         else {
[16:05:19.751]                           version <- NULL
[16:05:19.751]                         }
[16:05:19.751]                         if (!has_future || version < "1.8.0") {
[16:05:19.751]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.751]                             "", base::R.version$version.string), 
[16:05:19.751]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.751]                               "release", "version")], collapse = " "), 
[16:05:19.751]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.751]                             info)
[16:05:19.751]                           info <- base::paste(info, collapse = "; ")
[16:05:19.751]                           if (!has_future) {
[16:05:19.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.751]                               info)
[16:05:19.751]                           }
[16:05:19.751]                           else {
[16:05:19.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.751]                               info, version)
[16:05:19.751]                           }
[16:05:19.751]                           base::stop(msg)
[16:05:19.751]                         }
[16:05:19.751]                       })
[16:05:19.751]                     }
[16:05:19.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.751]                     base::options(mc.cores = 1L)
[16:05:19.751]                   }
[16:05:19.751]                   options(future.plan = NULL)
[16:05:19.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.751]                 }
[16:05:19.751]                 ...future.workdir <- getwd()
[16:05:19.751]             }
[16:05:19.751]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.751]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.751]         }
[16:05:19.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.751]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.751]             base::names(...future.oldOptions))
[16:05:19.751]     }
[16:05:19.751]     if (FALSE) {
[16:05:19.751]     }
[16:05:19.751]     else {
[16:05:19.751]         if (TRUE) {
[16:05:19.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.751]                 open = "w")
[16:05:19.751]         }
[16:05:19.751]         else {
[16:05:19.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.751]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.751]         }
[16:05:19.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.751]             base::sink(type = "output", split = FALSE)
[16:05:19.751]             base::close(...future.stdout)
[16:05:19.751]         }, add = TRUE)
[16:05:19.751]     }
[16:05:19.751]     ...future.frame <- base::sys.nframe()
[16:05:19.751]     ...future.conditions <- base::list()
[16:05:19.751]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.751]     if (FALSE) {
[16:05:19.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.751]     }
[16:05:19.751]     ...future.result <- base::tryCatch({
[16:05:19.751]         base::withCallingHandlers({
[16:05:19.751]             ...future.value <- base::withVisible(base::local({
[16:05:19.751]                 withCallingHandlers({
[16:05:19.751]                   {
[16:05:19.751]                     ii
[16:05:19.751]                   }
[16:05:19.751]                 }, immediateCondition = function(cond) {
[16:05:19.751]                   save_rds <- function (object, pathname, ...) 
[16:05:19.751]                   {
[16:05:19.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.751]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.751]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.751]                         fi_tmp[["mtime"]])
[16:05:19.751]                     }
[16:05:19.751]                     tryCatch({
[16:05:19.751]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.751]                     }, error = function(ex) {
[16:05:19.751]                       msg <- conditionMessage(ex)
[16:05:19.751]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.751]                         fi_tmp[["mtime"]], msg)
[16:05:19.751]                       ex$message <- msg
[16:05:19.751]                       stop(ex)
[16:05:19.751]                     })
[16:05:19.751]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.751]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.751]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.751]                       fi <- file.info(pathname)
[16:05:19.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.751]                         fi[["size"]], fi[["mtime"]])
[16:05:19.751]                       stop(msg)
[16:05:19.751]                     }
[16:05:19.751]                     invisible(pathname)
[16:05:19.751]                   }
[16:05:19.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.751]                     rootPath = tempdir()) 
[16:05:19.751]                   {
[16:05:19.751]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.751]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.751]                       tmpdir = path, fileext = ".rds")
[16:05:19.751]                     save_rds(obj, file)
[16:05:19.751]                   }
[16:05:19.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.751]                   {
[16:05:19.751]                     inherits <- base::inherits
[16:05:19.751]                     invokeRestart <- base::invokeRestart
[16:05:19.751]                     is.null <- base::is.null
[16:05:19.751]                     muffled <- FALSE
[16:05:19.751]                     if (inherits(cond, "message")) {
[16:05:19.751]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.751]                       if (muffled) 
[16:05:19.751]                         invokeRestart("muffleMessage")
[16:05:19.751]                     }
[16:05:19.751]                     else if (inherits(cond, "warning")) {
[16:05:19.751]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.751]                       if (muffled) 
[16:05:19.751]                         invokeRestart("muffleWarning")
[16:05:19.751]                     }
[16:05:19.751]                     else if (inherits(cond, "condition")) {
[16:05:19.751]                       if (!is.null(pattern)) {
[16:05:19.751]                         computeRestarts <- base::computeRestarts
[16:05:19.751]                         grepl <- base::grepl
[16:05:19.751]                         restarts <- computeRestarts(cond)
[16:05:19.751]                         for (restart in restarts) {
[16:05:19.751]                           name <- restart$name
[16:05:19.751]                           if (is.null(name)) 
[16:05:19.751]                             next
[16:05:19.751]                           if (!grepl(pattern, name)) 
[16:05:19.751]                             next
[16:05:19.751]                           invokeRestart(restart)
[16:05:19.751]                           muffled <- TRUE
[16:05:19.751]                           break
[16:05:19.751]                         }
[16:05:19.751]                       }
[16:05:19.751]                     }
[16:05:19.751]                     invisible(muffled)
[16:05:19.751]                   }
[16:05:19.751]                   muffleCondition(cond)
[16:05:19.751]                 })
[16:05:19.751]             }))
[16:05:19.751]             future::FutureResult(value = ...future.value$value, 
[16:05:19.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.751]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.751]                     ...future.globalenv.names))
[16:05:19.751]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.751]         }, condition = base::local({
[16:05:19.751]             c <- base::c
[16:05:19.751]             inherits <- base::inherits
[16:05:19.751]             invokeRestart <- base::invokeRestart
[16:05:19.751]             length <- base::length
[16:05:19.751]             list <- base::list
[16:05:19.751]             seq.int <- base::seq.int
[16:05:19.751]             signalCondition <- base::signalCondition
[16:05:19.751]             sys.calls <- base::sys.calls
[16:05:19.751]             `[[` <- base::`[[`
[16:05:19.751]             `+` <- base::`+`
[16:05:19.751]             `<<-` <- base::`<<-`
[16:05:19.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.751]                   3L)]
[16:05:19.751]             }
[16:05:19.751]             function(cond) {
[16:05:19.751]                 is_error <- inherits(cond, "error")
[16:05:19.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.751]                   NULL)
[16:05:19.751]                 if (is_error) {
[16:05:19.751]                   sessionInformation <- function() {
[16:05:19.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.751]                       search = base::search(), system = base::Sys.info())
[16:05:19.751]                   }
[16:05:19.751]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.751]                     cond$call), session = sessionInformation(), 
[16:05:19.751]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.751]                   signalCondition(cond)
[16:05:19.751]                 }
[16:05:19.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.751]                 "immediateCondition"))) {
[16:05:19.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.751]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.751]                   if (TRUE && !signal) {
[16:05:19.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.751]                     {
[16:05:19.751]                       inherits <- base::inherits
[16:05:19.751]                       invokeRestart <- base::invokeRestart
[16:05:19.751]                       is.null <- base::is.null
[16:05:19.751]                       muffled <- FALSE
[16:05:19.751]                       if (inherits(cond, "message")) {
[16:05:19.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.751]                         if (muffled) 
[16:05:19.751]                           invokeRestart("muffleMessage")
[16:05:19.751]                       }
[16:05:19.751]                       else if (inherits(cond, "warning")) {
[16:05:19.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.751]                         if (muffled) 
[16:05:19.751]                           invokeRestart("muffleWarning")
[16:05:19.751]                       }
[16:05:19.751]                       else if (inherits(cond, "condition")) {
[16:05:19.751]                         if (!is.null(pattern)) {
[16:05:19.751]                           computeRestarts <- base::computeRestarts
[16:05:19.751]                           grepl <- base::grepl
[16:05:19.751]                           restarts <- computeRestarts(cond)
[16:05:19.751]                           for (restart in restarts) {
[16:05:19.751]                             name <- restart$name
[16:05:19.751]                             if (is.null(name)) 
[16:05:19.751]                               next
[16:05:19.751]                             if (!grepl(pattern, name)) 
[16:05:19.751]                               next
[16:05:19.751]                             invokeRestart(restart)
[16:05:19.751]                             muffled <- TRUE
[16:05:19.751]                             break
[16:05:19.751]                           }
[16:05:19.751]                         }
[16:05:19.751]                       }
[16:05:19.751]                       invisible(muffled)
[16:05:19.751]                     }
[16:05:19.751]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.751]                   }
[16:05:19.751]                 }
[16:05:19.751]                 else {
[16:05:19.751]                   if (TRUE) {
[16:05:19.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.751]                     {
[16:05:19.751]                       inherits <- base::inherits
[16:05:19.751]                       invokeRestart <- base::invokeRestart
[16:05:19.751]                       is.null <- base::is.null
[16:05:19.751]                       muffled <- FALSE
[16:05:19.751]                       if (inherits(cond, "message")) {
[16:05:19.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.751]                         if (muffled) 
[16:05:19.751]                           invokeRestart("muffleMessage")
[16:05:19.751]                       }
[16:05:19.751]                       else if (inherits(cond, "warning")) {
[16:05:19.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.751]                         if (muffled) 
[16:05:19.751]                           invokeRestart("muffleWarning")
[16:05:19.751]                       }
[16:05:19.751]                       else if (inherits(cond, "condition")) {
[16:05:19.751]                         if (!is.null(pattern)) {
[16:05:19.751]                           computeRestarts <- base::computeRestarts
[16:05:19.751]                           grepl <- base::grepl
[16:05:19.751]                           restarts <- computeRestarts(cond)
[16:05:19.751]                           for (restart in restarts) {
[16:05:19.751]                             name <- restart$name
[16:05:19.751]                             if (is.null(name)) 
[16:05:19.751]                               next
[16:05:19.751]                             if (!grepl(pattern, name)) 
[16:05:19.751]                               next
[16:05:19.751]                             invokeRestart(restart)
[16:05:19.751]                             muffled <- TRUE
[16:05:19.751]                             break
[16:05:19.751]                           }
[16:05:19.751]                         }
[16:05:19.751]                       }
[16:05:19.751]                       invisible(muffled)
[16:05:19.751]                     }
[16:05:19.751]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.751]                   }
[16:05:19.751]                 }
[16:05:19.751]             }
[16:05:19.751]         }))
[16:05:19.751]     }, error = function(ex) {
[16:05:19.751]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.751]                 ...future.rng), started = ...future.startTime, 
[16:05:19.751]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.751]             version = "1.8"), class = "FutureResult")
[16:05:19.751]     }, finally = {
[16:05:19.751]         if (!identical(...future.workdir, getwd())) 
[16:05:19.751]             setwd(...future.workdir)
[16:05:19.751]         {
[16:05:19.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.751]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.751]             }
[16:05:19.751]             base::options(...future.oldOptions)
[16:05:19.751]             if (.Platform$OS.type == "windows") {
[16:05:19.751]                 old_names <- names(...future.oldEnvVars)
[16:05:19.751]                 envs <- base::Sys.getenv()
[16:05:19.751]                 names <- names(envs)
[16:05:19.751]                 common <- intersect(names, old_names)
[16:05:19.751]                 added <- setdiff(names, old_names)
[16:05:19.751]                 removed <- setdiff(old_names, names)
[16:05:19.751]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.751]                   envs[common]]
[16:05:19.751]                 NAMES <- toupper(changed)
[16:05:19.751]                 args <- list()
[16:05:19.751]                 for (kk in seq_along(NAMES)) {
[16:05:19.751]                   name <- changed[[kk]]
[16:05:19.751]                   NAME <- NAMES[[kk]]
[16:05:19.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.751]                     next
[16:05:19.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.751]                 }
[16:05:19.751]                 NAMES <- toupper(added)
[16:05:19.751]                 for (kk in seq_along(NAMES)) {
[16:05:19.751]                   name <- added[[kk]]
[16:05:19.751]                   NAME <- NAMES[[kk]]
[16:05:19.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.751]                     next
[16:05:19.751]                   args[[name]] <- ""
[16:05:19.751]                 }
[16:05:19.751]                 NAMES <- toupper(removed)
[16:05:19.751]                 for (kk in seq_along(NAMES)) {
[16:05:19.751]                   name <- removed[[kk]]
[16:05:19.751]                   NAME <- NAMES[[kk]]
[16:05:19.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.751]                     next
[16:05:19.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.751]                 }
[16:05:19.751]                 if (length(args) > 0) 
[16:05:19.751]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.751]             }
[16:05:19.751]             else {
[16:05:19.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.751]             }
[16:05:19.751]             {
[16:05:19.751]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.751]                   0L) {
[16:05:19.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.751]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.751]                   base::options(opts)
[16:05:19.751]                 }
[16:05:19.751]                 {
[16:05:19.751]                   {
[16:05:19.751]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.751]                     NULL
[16:05:19.751]                   }
[16:05:19.751]                   options(future.plan = NULL)
[16:05:19.751]                   if (is.na(NA_character_)) 
[16:05:19.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.751]                     envir = parent.frame()) 
[16:05:19.751]                   {
[16:05:19.751]                     default_workers <- missing(workers)
[16:05:19.751]                     if (is.function(workers)) 
[16:05:19.751]                       workers <- workers()
[16:05:19.751]                     workers <- structure(as.integer(workers), 
[16:05:19.751]                       class = class(workers))
[16:05:19.751]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.751]                       1L)
[16:05:19.751]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.751]                       if (default_workers) 
[16:05:19.751]                         supportsMulticore(warn = TRUE)
[16:05:19.751]                       return(sequential(..., envir = envir))
[16:05:19.751]                     }
[16:05:19.751]                     oopts <- options(mc.cores = workers)
[16:05:19.751]                     on.exit(options(oopts))
[16:05:19.751]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.751]                       envir = envir)
[16:05:19.751]                     if (!future$lazy) 
[16:05:19.751]                       future <- run(future)
[16:05:19.751]                     invisible(future)
[16:05:19.751]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.751]                 }
[16:05:19.751]             }
[16:05:19.751]         }
[16:05:19.751]     })
[16:05:19.751]     if (TRUE) {
[16:05:19.751]         base::sink(type = "output", split = FALSE)
[16:05:19.751]         if (TRUE) {
[16:05:19.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.751]         }
[16:05:19.751]         else {
[16:05:19.751]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.751]         }
[16:05:19.751]         base::close(...future.stdout)
[16:05:19.751]         ...future.stdout <- NULL
[16:05:19.751]     }
[16:05:19.751]     ...future.result$conditions <- ...future.conditions
[16:05:19.751]     ...future.result$finished <- base::Sys.time()
[16:05:19.751]     ...future.result
[16:05:19.751] }
[16:05:19.754] requestCore(): workers = 2
[16:05:19.756] MulticoreFuture started
 - Creating multicore future #3 ...
[16:05:19.757] plan(): Setting new future strategy stack:
[16:05:19.757] List of future strategies:
[16:05:19.757] 1. sequential:
[16:05:19.757]    - args: function (..., envir = parent.frame())
[16:05:19.757]    - tweaked: FALSE
[16:05:19.757]    - call: NULL
[16:05:19.758] plan(): nbrOfWorkers() = 1
[16:05:19.760] plan(): Setting new future strategy stack:
[16:05:19.760] List of future strategies:
[16:05:19.760] 1. multicore:
[16:05:19.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.760]    - tweaked: FALSE
[16:05:19.760]    - call: plan(multicore)
[16:05:19.761] getGlobalsAndPackages() ...
[16:05:19.762] Not searching for globals
[16:05:19.762] - globals: [0] <none>
[16:05:19.762] getGlobalsAndPackages() ... DONE
[16:05:19.763] Packages needed by the future expression (n = 0): <none>
[16:05:19.763] Packages needed by future strategies (n = 0): <none>
[16:05:19.764] plan(): nbrOfWorkers() = 2
[16:05:19.764] {
[16:05:19.764]     {
[16:05:19.764]         {
[16:05:19.764]             ...future.startTime <- base::Sys.time()
[16:05:19.764]             {
[16:05:19.764]                 {
[16:05:19.764]                   {
[16:05:19.764]                     {
[16:05:19.764]                       base::local({
[16:05:19.764]                         has_future <- base::requireNamespace("future", 
[16:05:19.764]                           quietly = TRUE)
[16:05:19.764]                         if (has_future) {
[16:05:19.764]                           ns <- base::getNamespace("future")
[16:05:19.764]                           version <- ns[[".package"]][["version"]]
[16:05:19.764]                           if (is.null(version)) 
[16:05:19.764]                             version <- utils::packageVersion("future")
[16:05:19.764]                         }
[16:05:19.764]                         else {
[16:05:19.764]                           version <- NULL
[16:05:19.764]                         }
[16:05:19.764]                         if (!has_future || version < "1.8.0") {
[16:05:19.764]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.764]                             "", base::R.version$version.string), 
[16:05:19.764]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.764]                               "release", "version")], collapse = " "), 
[16:05:19.764]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.764]                             info)
[16:05:19.764]                           info <- base::paste(info, collapse = "; ")
[16:05:19.764]                           if (!has_future) {
[16:05:19.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.764]                               info)
[16:05:19.764]                           }
[16:05:19.764]                           else {
[16:05:19.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.764]                               info, version)
[16:05:19.764]                           }
[16:05:19.764]                           base::stop(msg)
[16:05:19.764]                         }
[16:05:19.764]                       })
[16:05:19.764]                     }
[16:05:19.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.764]                     base::options(mc.cores = 1L)
[16:05:19.764]                   }
[16:05:19.764]                   options(future.plan = NULL)
[16:05:19.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.764]                 }
[16:05:19.764]                 ...future.workdir <- getwd()
[16:05:19.764]             }
[16:05:19.764]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.764]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.764]         }
[16:05:19.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.764]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.764]             base::names(...future.oldOptions))
[16:05:19.764]     }
[16:05:19.764]     if (FALSE) {
[16:05:19.764]     }
[16:05:19.764]     else {
[16:05:19.764]         if (TRUE) {
[16:05:19.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.764]                 open = "w")
[16:05:19.764]         }
[16:05:19.764]         else {
[16:05:19.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.764]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.764]         }
[16:05:19.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.764]             base::sink(type = "output", split = FALSE)
[16:05:19.764]             base::close(...future.stdout)
[16:05:19.764]         }, add = TRUE)
[16:05:19.764]     }
[16:05:19.764]     ...future.frame <- base::sys.nframe()
[16:05:19.764]     ...future.conditions <- base::list()
[16:05:19.764]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.764]     if (FALSE) {
[16:05:19.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.764]     }
[16:05:19.764]     ...future.result <- base::tryCatch({
[16:05:19.764]         base::withCallingHandlers({
[16:05:19.764]             ...future.value <- base::withVisible(base::local({
[16:05:19.764]                 withCallingHandlers({
[16:05:19.764]                   {
[16:05:19.764]                     ii
[16:05:19.764]                   }
[16:05:19.764]                 }, immediateCondition = function(cond) {
[16:05:19.764]                   save_rds <- function (object, pathname, ...) 
[16:05:19.764]                   {
[16:05:19.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.764]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.764]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.764]                         fi_tmp[["mtime"]])
[16:05:19.764]                     }
[16:05:19.764]                     tryCatch({
[16:05:19.764]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.764]                     }, error = function(ex) {
[16:05:19.764]                       msg <- conditionMessage(ex)
[16:05:19.764]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.764]                         fi_tmp[["mtime"]], msg)
[16:05:19.764]                       ex$message <- msg
[16:05:19.764]                       stop(ex)
[16:05:19.764]                     })
[16:05:19.764]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.764]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.764]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.764]                       fi <- file.info(pathname)
[16:05:19.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.764]                         fi[["size"]], fi[["mtime"]])
[16:05:19.764]                       stop(msg)
[16:05:19.764]                     }
[16:05:19.764]                     invisible(pathname)
[16:05:19.764]                   }
[16:05:19.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.764]                     rootPath = tempdir()) 
[16:05:19.764]                   {
[16:05:19.764]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.764]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.764]                       tmpdir = path, fileext = ".rds")
[16:05:19.764]                     save_rds(obj, file)
[16:05:19.764]                   }
[16:05:19.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.764]                   {
[16:05:19.764]                     inherits <- base::inherits
[16:05:19.764]                     invokeRestart <- base::invokeRestart
[16:05:19.764]                     is.null <- base::is.null
[16:05:19.764]                     muffled <- FALSE
[16:05:19.764]                     if (inherits(cond, "message")) {
[16:05:19.764]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.764]                       if (muffled) 
[16:05:19.764]                         invokeRestart("muffleMessage")
[16:05:19.764]                     }
[16:05:19.764]                     else if (inherits(cond, "warning")) {
[16:05:19.764]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.764]                       if (muffled) 
[16:05:19.764]                         invokeRestart("muffleWarning")
[16:05:19.764]                     }
[16:05:19.764]                     else if (inherits(cond, "condition")) {
[16:05:19.764]                       if (!is.null(pattern)) {
[16:05:19.764]                         computeRestarts <- base::computeRestarts
[16:05:19.764]                         grepl <- base::grepl
[16:05:19.764]                         restarts <- computeRestarts(cond)
[16:05:19.764]                         for (restart in restarts) {
[16:05:19.764]                           name <- restart$name
[16:05:19.764]                           if (is.null(name)) 
[16:05:19.764]                             next
[16:05:19.764]                           if (!grepl(pattern, name)) 
[16:05:19.764]                             next
[16:05:19.764]                           invokeRestart(restart)
[16:05:19.764]                           muffled <- TRUE
[16:05:19.764]                           break
[16:05:19.764]                         }
[16:05:19.764]                       }
[16:05:19.764]                     }
[16:05:19.764]                     invisible(muffled)
[16:05:19.764]                   }
[16:05:19.764]                   muffleCondition(cond)
[16:05:19.764]                 })
[16:05:19.764]             }))
[16:05:19.764]             future::FutureResult(value = ...future.value$value, 
[16:05:19.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.764]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.764]                     ...future.globalenv.names))
[16:05:19.764]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.764]         }, condition = base::local({
[16:05:19.764]             c <- base::c
[16:05:19.764]             inherits <- base::inherits
[16:05:19.764]             invokeRestart <- base::invokeRestart
[16:05:19.764]             length <- base::length
[16:05:19.764]             list <- base::list
[16:05:19.764]             seq.int <- base::seq.int
[16:05:19.764]             signalCondition <- base::signalCondition
[16:05:19.764]             sys.calls <- base::sys.calls
[16:05:19.764]             `[[` <- base::`[[`
[16:05:19.764]             `+` <- base::`+`
[16:05:19.764]             `<<-` <- base::`<<-`
[16:05:19.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.764]                   3L)]
[16:05:19.764]             }
[16:05:19.764]             function(cond) {
[16:05:19.764]                 is_error <- inherits(cond, "error")
[16:05:19.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.764]                   NULL)
[16:05:19.764]                 if (is_error) {
[16:05:19.764]                   sessionInformation <- function() {
[16:05:19.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.764]                       search = base::search(), system = base::Sys.info())
[16:05:19.764]                   }
[16:05:19.764]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.764]                     cond$call), session = sessionInformation(), 
[16:05:19.764]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.764]                   signalCondition(cond)
[16:05:19.764]                 }
[16:05:19.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.764]                 "immediateCondition"))) {
[16:05:19.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.764]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.764]                   if (TRUE && !signal) {
[16:05:19.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.764]                     {
[16:05:19.764]                       inherits <- base::inherits
[16:05:19.764]                       invokeRestart <- base::invokeRestart
[16:05:19.764]                       is.null <- base::is.null
[16:05:19.764]                       muffled <- FALSE
[16:05:19.764]                       if (inherits(cond, "message")) {
[16:05:19.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.764]                         if (muffled) 
[16:05:19.764]                           invokeRestart("muffleMessage")
[16:05:19.764]                       }
[16:05:19.764]                       else if (inherits(cond, "warning")) {
[16:05:19.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.764]                         if (muffled) 
[16:05:19.764]                           invokeRestart("muffleWarning")
[16:05:19.764]                       }
[16:05:19.764]                       else if (inherits(cond, "condition")) {
[16:05:19.764]                         if (!is.null(pattern)) {
[16:05:19.764]                           computeRestarts <- base::computeRestarts
[16:05:19.764]                           grepl <- base::grepl
[16:05:19.764]                           restarts <- computeRestarts(cond)
[16:05:19.764]                           for (restart in restarts) {
[16:05:19.764]                             name <- restart$name
[16:05:19.764]                             if (is.null(name)) 
[16:05:19.764]                               next
[16:05:19.764]                             if (!grepl(pattern, name)) 
[16:05:19.764]                               next
[16:05:19.764]                             invokeRestart(restart)
[16:05:19.764]                             muffled <- TRUE
[16:05:19.764]                             break
[16:05:19.764]                           }
[16:05:19.764]                         }
[16:05:19.764]                       }
[16:05:19.764]                       invisible(muffled)
[16:05:19.764]                     }
[16:05:19.764]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.764]                   }
[16:05:19.764]                 }
[16:05:19.764]                 else {
[16:05:19.764]                   if (TRUE) {
[16:05:19.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.764]                     {
[16:05:19.764]                       inherits <- base::inherits
[16:05:19.764]                       invokeRestart <- base::invokeRestart
[16:05:19.764]                       is.null <- base::is.null
[16:05:19.764]                       muffled <- FALSE
[16:05:19.764]                       if (inherits(cond, "message")) {
[16:05:19.764]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.764]                         if (muffled) 
[16:05:19.764]                           invokeRestart("muffleMessage")
[16:05:19.764]                       }
[16:05:19.764]                       else if (inherits(cond, "warning")) {
[16:05:19.764]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.764]                         if (muffled) 
[16:05:19.764]                           invokeRestart("muffleWarning")
[16:05:19.764]                       }
[16:05:19.764]                       else if (inherits(cond, "condition")) {
[16:05:19.764]                         if (!is.null(pattern)) {
[16:05:19.764]                           computeRestarts <- base::computeRestarts
[16:05:19.764]                           grepl <- base::grepl
[16:05:19.764]                           restarts <- computeRestarts(cond)
[16:05:19.764]                           for (restart in restarts) {
[16:05:19.764]                             name <- restart$name
[16:05:19.764]                             if (is.null(name)) 
[16:05:19.764]                               next
[16:05:19.764]                             if (!grepl(pattern, name)) 
[16:05:19.764]                               next
[16:05:19.764]                             invokeRestart(restart)
[16:05:19.764]                             muffled <- TRUE
[16:05:19.764]                             break
[16:05:19.764]                           }
[16:05:19.764]                         }
[16:05:19.764]                       }
[16:05:19.764]                       invisible(muffled)
[16:05:19.764]                     }
[16:05:19.764]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.764]                   }
[16:05:19.764]                 }
[16:05:19.764]             }
[16:05:19.764]         }))
[16:05:19.764]     }, error = function(ex) {
[16:05:19.764]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.764]                 ...future.rng), started = ...future.startTime, 
[16:05:19.764]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.764]             version = "1.8"), class = "FutureResult")
[16:05:19.764]     }, finally = {
[16:05:19.764]         if (!identical(...future.workdir, getwd())) 
[16:05:19.764]             setwd(...future.workdir)
[16:05:19.764]         {
[16:05:19.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.764]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.764]             }
[16:05:19.764]             base::options(...future.oldOptions)
[16:05:19.764]             if (.Platform$OS.type == "windows") {
[16:05:19.764]                 old_names <- names(...future.oldEnvVars)
[16:05:19.764]                 envs <- base::Sys.getenv()
[16:05:19.764]                 names <- names(envs)
[16:05:19.764]                 common <- intersect(names, old_names)
[16:05:19.764]                 added <- setdiff(names, old_names)
[16:05:19.764]                 removed <- setdiff(old_names, names)
[16:05:19.764]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.764]                   envs[common]]
[16:05:19.764]                 NAMES <- toupper(changed)
[16:05:19.764]                 args <- list()
[16:05:19.764]                 for (kk in seq_along(NAMES)) {
[16:05:19.764]                   name <- changed[[kk]]
[16:05:19.764]                   NAME <- NAMES[[kk]]
[16:05:19.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.764]                     next
[16:05:19.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.764]                 }
[16:05:19.764]                 NAMES <- toupper(added)
[16:05:19.764]                 for (kk in seq_along(NAMES)) {
[16:05:19.764]                   name <- added[[kk]]
[16:05:19.764]                   NAME <- NAMES[[kk]]
[16:05:19.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.764]                     next
[16:05:19.764]                   args[[name]] <- ""
[16:05:19.764]                 }
[16:05:19.764]                 NAMES <- toupper(removed)
[16:05:19.764]                 for (kk in seq_along(NAMES)) {
[16:05:19.764]                   name <- removed[[kk]]
[16:05:19.764]                   NAME <- NAMES[[kk]]
[16:05:19.764]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.764]                     next
[16:05:19.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.764]                 }
[16:05:19.764]                 if (length(args) > 0) 
[16:05:19.764]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.764]             }
[16:05:19.764]             else {
[16:05:19.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.764]             }
[16:05:19.764]             {
[16:05:19.764]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.764]                   0L) {
[16:05:19.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.764]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.764]                   base::options(opts)
[16:05:19.764]                 }
[16:05:19.764]                 {
[16:05:19.764]                   {
[16:05:19.764]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.764]                     NULL
[16:05:19.764]                   }
[16:05:19.764]                   options(future.plan = NULL)
[16:05:19.764]                   if (is.na(NA_character_)) 
[16:05:19.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.764]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.764]                     envir = parent.frame()) 
[16:05:19.764]                   {
[16:05:19.764]                     default_workers <- missing(workers)
[16:05:19.764]                     if (is.function(workers)) 
[16:05:19.764]                       workers <- workers()
[16:05:19.764]                     workers <- structure(as.integer(workers), 
[16:05:19.764]                       class = class(workers))
[16:05:19.764]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.764]                       1L)
[16:05:19.764]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.764]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.764]                       if (default_workers) 
[16:05:19.764]                         supportsMulticore(warn = TRUE)
[16:05:19.764]                       return(sequential(..., envir = envir))
[16:05:19.764]                     }
[16:05:19.764]                     oopts <- options(mc.cores = workers)
[16:05:19.764]                     on.exit(options(oopts))
[16:05:19.764]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.764]                       envir = envir)
[16:05:19.764]                     if (!future$lazy) 
[16:05:19.764]                       future <- run(future)
[16:05:19.764]                     invisible(future)
[16:05:19.764]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.764]                 }
[16:05:19.764]             }
[16:05:19.764]         }
[16:05:19.764]     })
[16:05:19.764]     if (TRUE) {
[16:05:19.764]         base::sink(type = "output", split = FALSE)
[16:05:19.764]         if (TRUE) {
[16:05:19.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.764]         }
[16:05:19.764]         else {
[16:05:19.764]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.764]         }
[16:05:19.764]         base::close(...future.stdout)
[16:05:19.764]         ...future.stdout <- NULL
[16:05:19.764]     }
[16:05:19.764]     ...future.result$conditions <- ...future.conditions
[16:05:19.764]     ...future.result$finished <- base::Sys.time()
[16:05:19.764]     ...future.result
[16:05:19.764] }
[16:05:19.767] requestCore(): workers = 2
[16:05:19.767] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:19.778] result() for MulticoreFuture ...
[16:05:19.779] result() for MulticoreFuture ...
[16:05:19.779] result() for MulticoreFuture ... done
[16:05:19.779] result() for MulticoreFuture ... done
[16:05:19.779] result() for MulticoreFuture ...
[16:05:19.779] result() for MulticoreFuture ... done
[16:05:19.782] MulticoreFuture started
 - Creating multicore future #4 ...
[16:05:19.783] plan(): Setting new future strategy stack:
[16:05:19.783] List of future strategies:
[16:05:19.783] 1. sequential:
[16:05:19.783]    - args: function (..., envir = parent.frame())
[16:05:19.783]    - tweaked: FALSE
[16:05:19.783]    - call: NULL
[16:05:19.784] plan(): nbrOfWorkers() = 1
[16:05:19.786] plan(): Setting new future strategy stack:
[16:05:19.786] List of future strategies:
[16:05:19.786] 1. multicore:
[16:05:19.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.786]    - tweaked: FALSE
[16:05:19.786]    - call: plan(multicore)
[16:05:19.787] getGlobalsAndPackages() ...
[16:05:19.787] Not searching for globals
[16:05:19.788] - globals: [0] <none>
[16:05:19.788] getGlobalsAndPackages() ... DONE
[16:05:19.789] Packages needed by the future expression (n = 0): <none>
[16:05:19.789] Packages needed by future strategies (n = 0): <none>
[16:05:19.790] plan(): nbrOfWorkers() = 2
[16:05:19.789] {
[16:05:19.789]     {
[16:05:19.789]         {
[16:05:19.789]             ...future.startTime <- base::Sys.time()
[16:05:19.789]             {
[16:05:19.789]                 {
[16:05:19.789]                   {
[16:05:19.789]                     {
[16:05:19.789]                       base::local({
[16:05:19.789]                         has_future <- base::requireNamespace("future", 
[16:05:19.789]                           quietly = TRUE)
[16:05:19.789]                         if (has_future) {
[16:05:19.789]                           ns <- base::getNamespace("future")
[16:05:19.789]                           version <- ns[[".package"]][["version"]]
[16:05:19.789]                           if (is.null(version)) 
[16:05:19.789]                             version <- utils::packageVersion("future")
[16:05:19.789]                         }
[16:05:19.789]                         else {
[16:05:19.789]                           version <- NULL
[16:05:19.789]                         }
[16:05:19.789]                         if (!has_future || version < "1.8.0") {
[16:05:19.789]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.789]                             "", base::R.version$version.string), 
[16:05:19.789]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.789]                               "release", "version")], collapse = " "), 
[16:05:19.789]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.789]                             info)
[16:05:19.789]                           info <- base::paste(info, collapse = "; ")
[16:05:19.789]                           if (!has_future) {
[16:05:19.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.789]                               info)
[16:05:19.789]                           }
[16:05:19.789]                           else {
[16:05:19.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.789]                               info, version)
[16:05:19.789]                           }
[16:05:19.789]                           base::stop(msg)
[16:05:19.789]                         }
[16:05:19.789]                       })
[16:05:19.789]                     }
[16:05:19.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.789]                     base::options(mc.cores = 1L)
[16:05:19.789]                   }
[16:05:19.789]                   options(future.plan = NULL)
[16:05:19.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.789]                 }
[16:05:19.789]                 ...future.workdir <- getwd()
[16:05:19.789]             }
[16:05:19.789]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.789]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.789]         }
[16:05:19.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.789]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.789]             base::names(...future.oldOptions))
[16:05:19.789]     }
[16:05:19.789]     if (FALSE) {
[16:05:19.789]     }
[16:05:19.789]     else {
[16:05:19.789]         if (TRUE) {
[16:05:19.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.789]                 open = "w")
[16:05:19.789]         }
[16:05:19.789]         else {
[16:05:19.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.789]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.789]         }
[16:05:19.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.789]             base::sink(type = "output", split = FALSE)
[16:05:19.789]             base::close(...future.stdout)
[16:05:19.789]         }, add = TRUE)
[16:05:19.789]     }
[16:05:19.789]     ...future.frame <- base::sys.nframe()
[16:05:19.789]     ...future.conditions <- base::list()
[16:05:19.789]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.789]     if (FALSE) {
[16:05:19.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.789]     }
[16:05:19.789]     ...future.result <- base::tryCatch({
[16:05:19.789]         base::withCallingHandlers({
[16:05:19.789]             ...future.value <- base::withVisible(base::local({
[16:05:19.789]                 withCallingHandlers({
[16:05:19.789]                   {
[16:05:19.789]                     ii
[16:05:19.789]                   }
[16:05:19.789]                 }, immediateCondition = function(cond) {
[16:05:19.789]                   save_rds <- function (object, pathname, ...) 
[16:05:19.789]                   {
[16:05:19.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.789]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.789]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.789]                         fi_tmp[["mtime"]])
[16:05:19.789]                     }
[16:05:19.789]                     tryCatch({
[16:05:19.789]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.789]                     }, error = function(ex) {
[16:05:19.789]                       msg <- conditionMessage(ex)
[16:05:19.789]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.789]                         fi_tmp[["mtime"]], msg)
[16:05:19.789]                       ex$message <- msg
[16:05:19.789]                       stop(ex)
[16:05:19.789]                     })
[16:05:19.789]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.789]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.789]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.789]                       fi <- file.info(pathname)
[16:05:19.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.789]                         fi[["size"]], fi[["mtime"]])
[16:05:19.789]                       stop(msg)
[16:05:19.789]                     }
[16:05:19.789]                     invisible(pathname)
[16:05:19.789]                   }
[16:05:19.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.789]                     rootPath = tempdir()) 
[16:05:19.789]                   {
[16:05:19.789]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.789]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.789]                       tmpdir = path, fileext = ".rds")
[16:05:19.789]                     save_rds(obj, file)
[16:05:19.789]                   }
[16:05:19.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.789]                   {
[16:05:19.789]                     inherits <- base::inherits
[16:05:19.789]                     invokeRestart <- base::invokeRestart
[16:05:19.789]                     is.null <- base::is.null
[16:05:19.789]                     muffled <- FALSE
[16:05:19.789]                     if (inherits(cond, "message")) {
[16:05:19.789]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.789]                       if (muffled) 
[16:05:19.789]                         invokeRestart("muffleMessage")
[16:05:19.789]                     }
[16:05:19.789]                     else if (inherits(cond, "warning")) {
[16:05:19.789]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.789]                       if (muffled) 
[16:05:19.789]                         invokeRestart("muffleWarning")
[16:05:19.789]                     }
[16:05:19.789]                     else if (inherits(cond, "condition")) {
[16:05:19.789]                       if (!is.null(pattern)) {
[16:05:19.789]                         computeRestarts <- base::computeRestarts
[16:05:19.789]                         grepl <- base::grepl
[16:05:19.789]                         restarts <- computeRestarts(cond)
[16:05:19.789]                         for (restart in restarts) {
[16:05:19.789]                           name <- restart$name
[16:05:19.789]                           if (is.null(name)) 
[16:05:19.789]                             next
[16:05:19.789]                           if (!grepl(pattern, name)) 
[16:05:19.789]                             next
[16:05:19.789]                           invokeRestart(restart)
[16:05:19.789]                           muffled <- TRUE
[16:05:19.789]                           break
[16:05:19.789]                         }
[16:05:19.789]                       }
[16:05:19.789]                     }
[16:05:19.789]                     invisible(muffled)
[16:05:19.789]                   }
[16:05:19.789]                   muffleCondition(cond)
[16:05:19.789]                 })
[16:05:19.789]             }))
[16:05:19.789]             future::FutureResult(value = ...future.value$value, 
[16:05:19.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.789]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.789]                     ...future.globalenv.names))
[16:05:19.789]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.789]         }, condition = base::local({
[16:05:19.789]             c <- base::c
[16:05:19.789]             inherits <- base::inherits
[16:05:19.789]             invokeRestart <- base::invokeRestart
[16:05:19.789]             length <- base::length
[16:05:19.789]             list <- base::list
[16:05:19.789]             seq.int <- base::seq.int
[16:05:19.789]             signalCondition <- base::signalCondition
[16:05:19.789]             sys.calls <- base::sys.calls
[16:05:19.789]             `[[` <- base::`[[`
[16:05:19.789]             `+` <- base::`+`
[16:05:19.789]             `<<-` <- base::`<<-`
[16:05:19.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.789]                   3L)]
[16:05:19.789]             }
[16:05:19.789]             function(cond) {
[16:05:19.789]                 is_error <- inherits(cond, "error")
[16:05:19.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.789]                   NULL)
[16:05:19.789]                 if (is_error) {
[16:05:19.789]                   sessionInformation <- function() {
[16:05:19.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.789]                       search = base::search(), system = base::Sys.info())
[16:05:19.789]                   }
[16:05:19.789]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.789]                     cond$call), session = sessionInformation(), 
[16:05:19.789]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.789]                   signalCondition(cond)
[16:05:19.789]                 }
[16:05:19.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.789]                 "immediateCondition"))) {
[16:05:19.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.789]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.789]                   if (TRUE && !signal) {
[16:05:19.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.789]                     {
[16:05:19.789]                       inherits <- base::inherits
[16:05:19.789]                       invokeRestart <- base::invokeRestart
[16:05:19.789]                       is.null <- base::is.null
[16:05:19.789]                       muffled <- FALSE
[16:05:19.789]                       if (inherits(cond, "message")) {
[16:05:19.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.789]                         if (muffled) 
[16:05:19.789]                           invokeRestart("muffleMessage")
[16:05:19.789]                       }
[16:05:19.789]                       else if (inherits(cond, "warning")) {
[16:05:19.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.789]                         if (muffled) 
[16:05:19.789]                           invokeRestart("muffleWarning")
[16:05:19.789]                       }
[16:05:19.789]                       else if (inherits(cond, "condition")) {
[16:05:19.789]                         if (!is.null(pattern)) {
[16:05:19.789]                           computeRestarts <- base::computeRestarts
[16:05:19.789]                           grepl <- base::grepl
[16:05:19.789]                           restarts <- computeRestarts(cond)
[16:05:19.789]                           for (restart in restarts) {
[16:05:19.789]                             name <- restart$name
[16:05:19.789]                             if (is.null(name)) 
[16:05:19.789]                               next
[16:05:19.789]                             if (!grepl(pattern, name)) 
[16:05:19.789]                               next
[16:05:19.789]                             invokeRestart(restart)
[16:05:19.789]                             muffled <- TRUE
[16:05:19.789]                             break
[16:05:19.789]                           }
[16:05:19.789]                         }
[16:05:19.789]                       }
[16:05:19.789]                       invisible(muffled)
[16:05:19.789]                     }
[16:05:19.789]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.789]                   }
[16:05:19.789]                 }
[16:05:19.789]                 else {
[16:05:19.789]                   if (TRUE) {
[16:05:19.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.789]                     {
[16:05:19.789]                       inherits <- base::inherits
[16:05:19.789]                       invokeRestart <- base::invokeRestart
[16:05:19.789]                       is.null <- base::is.null
[16:05:19.789]                       muffled <- FALSE
[16:05:19.789]                       if (inherits(cond, "message")) {
[16:05:19.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.789]                         if (muffled) 
[16:05:19.789]                           invokeRestart("muffleMessage")
[16:05:19.789]                       }
[16:05:19.789]                       else if (inherits(cond, "warning")) {
[16:05:19.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.789]                         if (muffled) 
[16:05:19.789]                           invokeRestart("muffleWarning")
[16:05:19.789]                       }
[16:05:19.789]                       else if (inherits(cond, "condition")) {
[16:05:19.789]                         if (!is.null(pattern)) {
[16:05:19.789]                           computeRestarts <- base::computeRestarts
[16:05:19.789]                           grepl <- base::grepl
[16:05:19.789]                           restarts <- computeRestarts(cond)
[16:05:19.789]                           for (restart in restarts) {
[16:05:19.789]                             name <- restart$name
[16:05:19.789]                             if (is.null(name)) 
[16:05:19.789]                               next
[16:05:19.789]                             if (!grepl(pattern, name)) 
[16:05:19.789]                               next
[16:05:19.789]                             invokeRestart(restart)
[16:05:19.789]                             muffled <- TRUE
[16:05:19.789]                             break
[16:05:19.789]                           }
[16:05:19.789]                         }
[16:05:19.789]                       }
[16:05:19.789]                       invisible(muffled)
[16:05:19.789]                     }
[16:05:19.789]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.789]                   }
[16:05:19.789]                 }
[16:05:19.789]             }
[16:05:19.789]         }))
[16:05:19.789]     }, error = function(ex) {
[16:05:19.789]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.789]                 ...future.rng), started = ...future.startTime, 
[16:05:19.789]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.789]             version = "1.8"), class = "FutureResult")
[16:05:19.789]     }, finally = {
[16:05:19.789]         if (!identical(...future.workdir, getwd())) 
[16:05:19.789]             setwd(...future.workdir)
[16:05:19.789]         {
[16:05:19.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.789]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.789]             }
[16:05:19.789]             base::options(...future.oldOptions)
[16:05:19.789]             if (.Platform$OS.type == "windows") {
[16:05:19.789]                 old_names <- names(...future.oldEnvVars)
[16:05:19.789]                 envs <- base::Sys.getenv()
[16:05:19.789]                 names <- names(envs)
[16:05:19.789]                 common <- intersect(names, old_names)
[16:05:19.789]                 added <- setdiff(names, old_names)
[16:05:19.789]                 removed <- setdiff(old_names, names)
[16:05:19.789]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.789]                   envs[common]]
[16:05:19.789]                 NAMES <- toupper(changed)
[16:05:19.789]                 args <- list()
[16:05:19.789]                 for (kk in seq_along(NAMES)) {
[16:05:19.789]                   name <- changed[[kk]]
[16:05:19.789]                   NAME <- NAMES[[kk]]
[16:05:19.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.789]                     next
[16:05:19.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.789]                 }
[16:05:19.789]                 NAMES <- toupper(added)
[16:05:19.789]                 for (kk in seq_along(NAMES)) {
[16:05:19.789]                   name <- added[[kk]]
[16:05:19.789]                   NAME <- NAMES[[kk]]
[16:05:19.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.789]                     next
[16:05:19.789]                   args[[name]] <- ""
[16:05:19.789]                 }
[16:05:19.789]                 NAMES <- toupper(removed)
[16:05:19.789]                 for (kk in seq_along(NAMES)) {
[16:05:19.789]                   name <- removed[[kk]]
[16:05:19.789]                   NAME <- NAMES[[kk]]
[16:05:19.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.789]                     next
[16:05:19.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.789]                 }
[16:05:19.789]                 if (length(args) > 0) 
[16:05:19.789]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.789]             }
[16:05:19.789]             else {
[16:05:19.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.789]             }
[16:05:19.789]             {
[16:05:19.789]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.789]                   0L) {
[16:05:19.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.789]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.789]                   base::options(opts)
[16:05:19.789]                 }
[16:05:19.789]                 {
[16:05:19.789]                   {
[16:05:19.789]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.789]                     NULL
[16:05:19.789]                   }
[16:05:19.789]                   options(future.plan = NULL)
[16:05:19.789]                   if (is.na(NA_character_)) 
[16:05:19.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.789]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.789]                     envir = parent.frame()) 
[16:05:19.789]                   {
[16:05:19.789]                     default_workers <- missing(workers)
[16:05:19.789]                     if (is.function(workers)) 
[16:05:19.789]                       workers <- workers()
[16:05:19.789]                     workers <- structure(as.integer(workers), 
[16:05:19.789]                       class = class(workers))
[16:05:19.789]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.789]                       1L)
[16:05:19.789]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.789]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.789]                       if (default_workers) 
[16:05:19.789]                         supportsMulticore(warn = TRUE)
[16:05:19.789]                       return(sequential(..., envir = envir))
[16:05:19.789]                     }
[16:05:19.789]                     oopts <- options(mc.cores = workers)
[16:05:19.789]                     on.exit(options(oopts))
[16:05:19.789]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.789]                       envir = envir)
[16:05:19.789]                     if (!future$lazy) 
[16:05:19.789]                       future <- run(future)
[16:05:19.789]                     invisible(future)
[16:05:19.789]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.789]                 }
[16:05:19.789]             }
[16:05:19.789]         }
[16:05:19.789]     })
[16:05:19.789]     if (TRUE) {
[16:05:19.789]         base::sink(type = "output", split = FALSE)
[16:05:19.789]         if (TRUE) {
[16:05:19.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.789]         }
[16:05:19.789]         else {
[16:05:19.789]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.789]         }
[16:05:19.789]         base::close(...future.stdout)
[16:05:19.789]         ...future.stdout <- NULL
[16:05:19.789]     }
[16:05:19.789]     ...future.result$conditions <- ...future.conditions
[16:05:19.789]     ...future.result$finished <- base::Sys.time()
[16:05:19.789]     ...future.result
[16:05:19.789] }
[16:05:19.799] requestCore(): workers = 2
[16:05:19.799] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:19.823] result() for MulticoreFuture ...
[16:05:19.824] result() for MulticoreFuture ...
[16:05:19.824] result() for MulticoreFuture ... done
[16:05:19.824] result() for MulticoreFuture ... done
[16:05:19.824] result() for MulticoreFuture ...
[16:05:19.824] result() for MulticoreFuture ... done
[16:05:19.826] MulticoreFuture started
 - Resolving 4 multicore futures
[16:05:19.827] result() for MulticoreFuture ...
[16:05:19.828] result() for MulticoreFuture ... done
[16:05:19.828] plan(): Setting new future strategy stack:
[16:05:19.828] result() for MulticoreFuture ...
[16:05:19.828] result() for MulticoreFuture ... done
[16:05:19.828] result() for MulticoreFuture ...
[16:05:19.829] result() for MulticoreFuture ... done
[16:05:19.828] List of future strategies:
[16:05:19.828] 1. sequential:
[16:05:19.828]    - args: function (..., envir = parent.frame())
[16:05:19.828]    - tweaked: FALSE
[16:05:19.828]    - call: NULL
[16:05:19.829] result() for MulticoreFuture ...
[16:05:19.829] result() for MulticoreFuture ... done
[16:05:19.829] plan(): nbrOfWorkers() = 1
[16:05:19.829] result() for MulticoreFuture ...
[16:05:19.831] result() for MulticoreFuture ...
[16:05:19.831] result() for MulticoreFuture ... done
[16:05:19.831] result() for MulticoreFuture ... done
[16:05:19.832] result() for MulticoreFuture ...
[16:05:19.832] plan(): Setting new future strategy stack:
[16:05:19.832] result() for MulticoreFuture ... done
[16:05:19.832] result() for MulticoreFuture ...
[16:05:19.832] List of future strategies:
[16:05:19.832] 1. multicore:
[16:05:19.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.832]    - tweaked: FALSE
[16:05:19.832]    - call: plan(multicore)
[16:05:19.837] plan(): nbrOfWorkers() = 2
[16:05:19.838] result() for MulticoreFuture ...
[16:05:19.838] result() for MulticoreFuture ... done
[16:05:19.838] result() for MulticoreFuture ... done
[16:05:19.838] result() for MulticoreFuture ...
[16:05:19.838] result() for MulticoreFuture ... done
*** multicore(..., globals = FALSE) and errors
[16:05:19.843] getGlobalsAndPackages() ...
[16:05:19.843] Not searching for globals
[16:05:19.843] - globals: [0] <none>
[16:05:19.843] getGlobalsAndPackages() ... DONE
[16:05:19.844] Packages needed by the future expression (n = 0): <none>
[16:05:19.844] Packages needed by future strategies (n = 0): <none>
[16:05:19.844] {
[16:05:19.844]     {
[16:05:19.844]         {
[16:05:19.844]             ...future.startTime <- base::Sys.time()
[16:05:19.844]             {
[16:05:19.844]                 {
[16:05:19.844]                   {
[16:05:19.844]                     {
[16:05:19.844]                       base::local({
[16:05:19.844]                         has_future <- base::requireNamespace("future", 
[16:05:19.844]                           quietly = TRUE)
[16:05:19.844]                         if (has_future) {
[16:05:19.844]                           ns <- base::getNamespace("future")
[16:05:19.844]                           version <- ns[[".package"]][["version"]]
[16:05:19.844]                           if (is.null(version)) 
[16:05:19.844]                             version <- utils::packageVersion("future")
[16:05:19.844]                         }
[16:05:19.844]                         else {
[16:05:19.844]                           version <- NULL
[16:05:19.844]                         }
[16:05:19.844]                         if (!has_future || version < "1.8.0") {
[16:05:19.844]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.844]                             "", base::R.version$version.string), 
[16:05:19.844]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.844]                               "release", "version")], collapse = " "), 
[16:05:19.844]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.844]                             info)
[16:05:19.844]                           info <- base::paste(info, collapse = "; ")
[16:05:19.844]                           if (!has_future) {
[16:05:19.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.844]                               info)
[16:05:19.844]                           }
[16:05:19.844]                           else {
[16:05:19.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.844]                               info, version)
[16:05:19.844]                           }
[16:05:19.844]                           base::stop(msg)
[16:05:19.844]                         }
[16:05:19.844]                       })
[16:05:19.844]                     }
[16:05:19.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.844]                     base::options(mc.cores = 1L)
[16:05:19.844]                   }
[16:05:19.844]                   options(future.plan = NULL)
[16:05:19.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.844]                 }
[16:05:19.844]                 ...future.workdir <- getwd()
[16:05:19.844]             }
[16:05:19.844]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.844]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.844]         }
[16:05:19.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.844]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.844]             base::names(...future.oldOptions))
[16:05:19.844]     }
[16:05:19.844]     if (FALSE) {
[16:05:19.844]     }
[16:05:19.844]     else {
[16:05:19.844]         if (TRUE) {
[16:05:19.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.844]                 open = "w")
[16:05:19.844]         }
[16:05:19.844]         else {
[16:05:19.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.844]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.844]         }
[16:05:19.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.844]             base::sink(type = "output", split = FALSE)
[16:05:19.844]             base::close(...future.stdout)
[16:05:19.844]         }, add = TRUE)
[16:05:19.844]     }
[16:05:19.844]     ...future.frame <- base::sys.nframe()
[16:05:19.844]     ...future.conditions <- base::list()
[16:05:19.844]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.844]     if (FALSE) {
[16:05:19.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.844]     }
[16:05:19.844]     ...future.result <- base::tryCatch({
[16:05:19.844]         base::withCallingHandlers({
[16:05:19.844]             ...future.value <- base::withVisible(base::local({
[16:05:19.844]                 withCallingHandlers({
[16:05:19.844]                   {
[16:05:19.844]                     stop("Whoops!")
[16:05:19.844]                     1
[16:05:19.844]                   }
[16:05:19.844]                 }, immediateCondition = function(cond) {
[16:05:19.844]                   save_rds <- function (object, pathname, ...) 
[16:05:19.844]                   {
[16:05:19.844]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.844]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.844]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.844]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.844]                         fi_tmp[["mtime"]])
[16:05:19.844]                     }
[16:05:19.844]                     tryCatch({
[16:05:19.844]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.844]                     }, error = function(ex) {
[16:05:19.844]                       msg <- conditionMessage(ex)
[16:05:19.844]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.844]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.844]                         fi_tmp[["mtime"]], msg)
[16:05:19.844]                       ex$message <- msg
[16:05:19.844]                       stop(ex)
[16:05:19.844]                     })
[16:05:19.844]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.844]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.844]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.844]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.844]                       fi <- file.info(pathname)
[16:05:19.844]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.844]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.844]                         fi[["size"]], fi[["mtime"]])
[16:05:19.844]                       stop(msg)
[16:05:19.844]                     }
[16:05:19.844]                     invisible(pathname)
[16:05:19.844]                   }
[16:05:19.844]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.844]                     rootPath = tempdir()) 
[16:05:19.844]                   {
[16:05:19.844]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.844]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.844]                       tmpdir = path, fileext = ".rds")
[16:05:19.844]                     save_rds(obj, file)
[16:05:19.844]                   }
[16:05:19.844]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.844]                   {
[16:05:19.844]                     inherits <- base::inherits
[16:05:19.844]                     invokeRestart <- base::invokeRestart
[16:05:19.844]                     is.null <- base::is.null
[16:05:19.844]                     muffled <- FALSE
[16:05:19.844]                     if (inherits(cond, "message")) {
[16:05:19.844]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.844]                       if (muffled) 
[16:05:19.844]                         invokeRestart("muffleMessage")
[16:05:19.844]                     }
[16:05:19.844]                     else if (inherits(cond, "warning")) {
[16:05:19.844]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.844]                       if (muffled) 
[16:05:19.844]                         invokeRestart("muffleWarning")
[16:05:19.844]                     }
[16:05:19.844]                     else if (inherits(cond, "condition")) {
[16:05:19.844]                       if (!is.null(pattern)) {
[16:05:19.844]                         computeRestarts <- base::computeRestarts
[16:05:19.844]                         grepl <- base::grepl
[16:05:19.844]                         restarts <- computeRestarts(cond)
[16:05:19.844]                         for (restart in restarts) {
[16:05:19.844]                           name <- restart$name
[16:05:19.844]                           if (is.null(name)) 
[16:05:19.844]                             next
[16:05:19.844]                           if (!grepl(pattern, name)) 
[16:05:19.844]                             next
[16:05:19.844]                           invokeRestart(restart)
[16:05:19.844]                           muffled <- TRUE
[16:05:19.844]                           break
[16:05:19.844]                         }
[16:05:19.844]                       }
[16:05:19.844]                     }
[16:05:19.844]                     invisible(muffled)
[16:05:19.844]                   }
[16:05:19.844]                   muffleCondition(cond)
[16:05:19.844]                 })
[16:05:19.844]             }))
[16:05:19.844]             future::FutureResult(value = ...future.value$value, 
[16:05:19.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.844]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.844]                     ...future.globalenv.names))
[16:05:19.844]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.844]         }, condition = base::local({
[16:05:19.844]             c <- base::c
[16:05:19.844]             inherits <- base::inherits
[16:05:19.844]             invokeRestart <- base::invokeRestart
[16:05:19.844]             length <- base::length
[16:05:19.844]             list <- base::list
[16:05:19.844]             seq.int <- base::seq.int
[16:05:19.844]             signalCondition <- base::signalCondition
[16:05:19.844]             sys.calls <- base::sys.calls
[16:05:19.844]             `[[` <- base::`[[`
[16:05:19.844]             `+` <- base::`+`
[16:05:19.844]             `<<-` <- base::`<<-`
[16:05:19.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.844]                   3L)]
[16:05:19.844]             }
[16:05:19.844]             function(cond) {
[16:05:19.844]                 is_error <- inherits(cond, "error")
[16:05:19.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.844]                   NULL)
[16:05:19.844]                 if (is_error) {
[16:05:19.844]                   sessionInformation <- function() {
[16:05:19.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.844]                       search = base::search(), system = base::Sys.info())
[16:05:19.844]                   }
[16:05:19.844]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.844]                     cond$call), session = sessionInformation(), 
[16:05:19.844]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.844]                   signalCondition(cond)
[16:05:19.844]                 }
[16:05:19.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.844]                 "immediateCondition"))) {
[16:05:19.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.844]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.844]                   if (TRUE && !signal) {
[16:05:19.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.844]                     {
[16:05:19.844]                       inherits <- base::inherits
[16:05:19.844]                       invokeRestart <- base::invokeRestart
[16:05:19.844]                       is.null <- base::is.null
[16:05:19.844]                       muffled <- FALSE
[16:05:19.844]                       if (inherits(cond, "message")) {
[16:05:19.844]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.844]                         if (muffled) 
[16:05:19.844]                           invokeRestart("muffleMessage")
[16:05:19.844]                       }
[16:05:19.844]                       else if (inherits(cond, "warning")) {
[16:05:19.844]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.844]                         if (muffled) 
[16:05:19.844]                           invokeRestart("muffleWarning")
[16:05:19.844]                       }
[16:05:19.844]                       else if (inherits(cond, "condition")) {
[16:05:19.844]                         if (!is.null(pattern)) {
[16:05:19.844]                           computeRestarts <- base::computeRestarts
[16:05:19.844]                           grepl <- base::grepl
[16:05:19.844]                           restarts <- computeRestarts(cond)
[16:05:19.844]                           for (restart in restarts) {
[16:05:19.844]                             name <- restart$name
[16:05:19.844]                             if (is.null(name)) 
[16:05:19.844]                               next
[16:05:19.844]                             if (!grepl(pattern, name)) 
[16:05:19.844]                               next
[16:05:19.844]                             invokeRestart(restart)
[16:05:19.844]                             muffled <- TRUE
[16:05:19.844]                             break
[16:05:19.844]                           }
[16:05:19.844]                         }
[16:05:19.844]                       }
[16:05:19.844]                       invisible(muffled)
[16:05:19.844]                     }
[16:05:19.844]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.844]                   }
[16:05:19.844]                 }
[16:05:19.844]                 else {
[16:05:19.844]                   if (TRUE) {
[16:05:19.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.844]                     {
[16:05:19.844]                       inherits <- base::inherits
[16:05:19.844]                       invokeRestart <- base::invokeRestart
[16:05:19.844]                       is.null <- base::is.null
[16:05:19.844]                       muffled <- FALSE
[16:05:19.844]                       if (inherits(cond, "message")) {
[16:05:19.844]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.844]                         if (muffled) 
[16:05:19.844]                           invokeRestart("muffleMessage")
[16:05:19.844]                       }
[16:05:19.844]                       else if (inherits(cond, "warning")) {
[16:05:19.844]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.844]                         if (muffled) 
[16:05:19.844]                           invokeRestart("muffleWarning")
[16:05:19.844]                       }
[16:05:19.844]                       else if (inherits(cond, "condition")) {
[16:05:19.844]                         if (!is.null(pattern)) {
[16:05:19.844]                           computeRestarts <- base::computeRestarts
[16:05:19.844]                           grepl <- base::grepl
[16:05:19.844]                           restarts <- computeRestarts(cond)
[16:05:19.844]                           for (restart in restarts) {
[16:05:19.844]                             name <- restart$name
[16:05:19.844]                             if (is.null(name)) 
[16:05:19.844]                               next
[16:05:19.844]                             if (!grepl(pattern, name)) 
[16:05:19.844]                               next
[16:05:19.844]                             invokeRestart(restart)
[16:05:19.844]                             muffled <- TRUE
[16:05:19.844]                             break
[16:05:19.844]                           }
[16:05:19.844]                         }
[16:05:19.844]                       }
[16:05:19.844]                       invisible(muffled)
[16:05:19.844]                     }
[16:05:19.844]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.844]                   }
[16:05:19.844]                 }
[16:05:19.844]             }
[16:05:19.844]         }))
[16:05:19.844]     }, error = function(ex) {
[16:05:19.844]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.844]                 ...future.rng), started = ...future.startTime, 
[16:05:19.844]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.844]             version = "1.8"), class = "FutureResult")
[16:05:19.844]     }, finally = {
[16:05:19.844]         if (!identical(...future.workdir, getwd())) 
[16:05:19.844]             setwd(...future.workdir)
[16:05:19.844]         {
[16:05:19.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.844]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.844]             }
[16:05:19.844]             base::options(...future.oldOptions)
[16:05:19.844]             if (.Platform$OS.type == "windows") {
[16:05:19.844]                 old_names <- names(...future.oldEnvVars)
[16:05:19.844]                 envs <- base::Sys.getenv()
[16:05:19.844]                 names <- names(envs)
[16:05:19.844]                 common <- intersect(names, old_names)
[16:05:19.844]                 added <- setdiff(names, old_names)
[16:05:19.844]                 removed <- setdiff(old_names, names)
[16:05:19.844]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.844]                   envs[common]]
[16:05:19.844]                 NAMES <- toupper(changed)
[16:05:19.844]                 args <- list()
[16:05:19.844]                 for (kk in seq_along(NAMES)) {
[16:05:19.844]                   name <- changed[[kk]]
[16:05:19.844]                   NAME <- NAMES[[kk]]
[16:05:19.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.844]                     next
[16:05:19.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.844]                 }
[16:05:19.844]                 NAMES <- toupper(added)
[16:05:19.844]                 for (kk in seq_along(NAMES)) {
[16:05:19.844]                   name <- added[[kk]]
[16:05:19.844]                   NAME <- NAMES[[kk]]
[16:05:19.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.844]                     next
[16:05:19.844]                   args[[name]] <- ""
[16:05:19.844]                 }
[16:05:19.844]                 NAMES <- toupper(removed)
[16:05:19.844]                 for (kk in seq_along(NAMES)) {
[16:05:19.844]                   name <- removed[[kk]]
[16:05:19.844]                   NAME <- NAMES[[kk]]
[16:05:19.844]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.844]                     next
[16:05:19.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.844]                 }
[16:05:19.844]                 if (length(args) > 0) 
[16:05:19.844]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.844]             }
[16:05:19.844]             else {
[16:05:19.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.844]             }
[16:05:19.844]             {
[16:05:19.844]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.844]                   0L) {
[16:05:19.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.844]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.844]                   base::options(opts)
[16:05:19.844]                 }
[16:05:19.844]                 {
[16:05:19.844]                   {
[16:05:19.844]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.844]                     NULL
[16:05:19.844]                   }
[16:05:19.844]                   options(future.plan = NULL)
[16:05:19.844]                   if (is.na(NA_character_)) 
[16:05:19.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.844]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.844]                     envir = parent.frame()) 
[16:05:19.844]                   {
[16:05:19.844]                     default_workers <- missing(workers)
[16:05:19.844]                     if (is.function(workers)) 
[16:05:19.844]                       workers <- workers()
[16:05:19.844]                     workers <- structure(as.integer(workers), 
[16:05:19.844]                       class = class(workers))
[16:05:19.844]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.844]                       1L)
[16:05:19.844]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.844]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.844]                       if (default_workers) 
[16:05:19.844]                         supportsMulticore(warn = TRUE)
[16:05:19.844]                       return(sequential(..., envir = envir))
[16:05:19.844]                     }
[16:05:19.844]                     oopts <- options(mc.cores = workers)
[16:05:19.844]                     on.exit(options(oopts))
[16:05:19.844]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.844]                       envir = envir)
[16:05:19.844]                     if (!future$lazy) 
[16:05:19.844]                       future <- run(future)
[16:05:19.844]                     invisible(future)
[16:05:19.844]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.844]                 }
[16:05:19.844]             }
[16:05:19.844]         }
[16:05:19.844]     })
[16:05:19.844]     if (TRUE) {
[16:05:19.844]         base::sink(type = "output", split = FALSE)
[16:05:19.844]         if (TRUE) {
[16:05:19.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.844]         }
[16:05:19.844]         else {
[16:05:19.844]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.844]         }
[16:05:19.844]         base::close(...future.stdout)
[16:05:19.844]         ...future.stdout <- NULL
[16:05:19.844]     }
[16:05:19.844]     ...future.result$conditions <- ...future.conditions
[16:05:19.844]     ...future.result$finished <- base::Sys.time()
[16:05:19.844]     ...future.result
[16:05:19.844] }
[16:05:19.847] requestCore(): workers = 2
[16:05:19.849] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:19.850] plan(): Setting new future strategy stack:
[16:05:19.850] List of future strategies:
[16:05:19.850] 1. sequential:
[16:05:19.850]    - args: function (..., envir = parent.frame())
[16:05:19.850]    - tweaked: FALSE
[16:05:19.850]    - call: NULL
[16:05:19.851] plan(): nbrOfWorkers() = 1
[16:05:19.853] plan(): Setting new future strategy stack:
[16:05:19.853] List of future strategies:
[16:05:19.853] 1. multicore:
[16:05:19.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.853]    - tweaked: FALSE
[16:05:19.853]    - call: plan(multicore)
[16:05:19.858] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:19.861] result() for MulticoreFuture ...
[16:05:19.863] result() for MulticoreFuture ...
[16:05:19.864] result() for MulticoreFuture ... done
[16:05:19.864] signalConditions() ...
[16:05:19.864]  - include = ‘immediateCondition’
[16:05:19.864]  - exclude = 
[16:05:19.864]  - resignal = FALSE
[16:05:19.864]  - Number of conditions: 1
[16:05:19.864] signalConditions() ... done
[16:05:19.864] result() for MulticoreFuture ... done
[16:05:19.864] result() for MulticoreFuture ...
[16:05:19.865] result() for MulticoreFuture ... done
[16:05:19.865] signalConditions() ...
[16:05:19.865]  - include = ‘immediateCondition’
[16:05:19.865]  - exclude = 
[16:05:19.865]  - resignal = FALSE
[16:05:19.865]  - Number of conditions: 1
[16:05:19.865] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:19.866] result() for MulticoreFuture ...
[16:05:19.866] result() for MulticoreFuture ... done
[16:05:19.866] result() for MulticoreFuture ...
[16:05:19.866] result() for MulticoreFuture ... done
[16:05:19.867] signalConditions() ...
[16:05:19.867]  - include = ‘immediateCondition’
[16:05:19.867]  - exclude = 
[16:05:19.867]  - resignal = FALSE
[16:05:19.867]  - Number of conditions: 1
[16:05:19.867] signalConditions() ... done
[16:05:19.867] Future state: ‘finished’
[16:05:19.867] result() for MulticoreFuture ...
[16:05:19.867] result() for MulticoreFuture ... done
[16:05:19.868] signalConditions() ...
[16:05:19.868]  - include = ‘condition’
[16:05:19.868]  - exclude = ‘immediateCondition’
[16:05:19.868]  - resignal = TRUE
[16:05:19.870]  - Number of conditions: 1
[16:05:19.870]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.871] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:19.872] result() for MulticoreFuture ...
[16:05:19.872] result() for MulticoreFuture ... done
[16:05:19.872] result() for MulticoreFuture ...
[16:05:19.872] result() for MulticoreFuture ... done
[16:05:19.872] signalConditions() ...
[16:05:19.872]  - include = ‘immediateCondition’
[16:05:19.872]  - exclude = 
[16:05:19.873]  - resignal = FALSE
[16:05:19.873]  - Number of conditions: 1
[16:05:19.873] signalConditions() ... done
[16:05:19.873] Future state: ‘finished’
[16:05:19.873] result() for MulticoreFuture ...
[16:05:19.873] result() for MulticoreFuture ... done
[16:05:19.873] signalConditions() ...
[16:05:19.874]  - include = ‘condition’
[16:05:19.874]  - exclude = ‘immediateCondition’
[16:05:19.874]  - resignal = TRUE
[16:05:19.874]  - Number of conditions: 1
[16:05:19.874]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:19.874] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:19.878] getGlobalsAndPackages() ...
[16:05:19.879] 
[16:05:19.879] - globals: [0] <none>
[16:05:19.879] getGlobalsAndPackages() ... DONE
[16:05:19.880] Packages needed by the future expression (n = 0): <none>
[16:05:19.880] Packages needed by future strategies (n = 0): <none>
[16:05:19.880] {
[16:05:19.880]     {
[16:05:19.880]         {
[16:05:19.880]             ...future.startTime <- base::Sys.time()
[16:05:19.880]             {
[16:05:19.880]                 {
[16:05:19.880]                   {
[16:05:19.880]                     {
[16:05:19.880]                       base::local({
[16:05:19.880]                         has_future <- base::requireNamespace("future", 
[16:05:19.880]                           quietly = TRUE)
[16:05:19.880]                         if (has_future) {
[16:05:19.880]                           ns <- base::getNamespace("future")
[16:05:19.880]                           version <- ns[[".package"]][["version"]]
[16:05:19.880]                           if (is.null(version)) 
[16:05:19.880]                             version <- utils::packageVersion("future")
[16:05:19.880]                         }
[16:05:19.880]                         else {
[16:05:19.880]                           version <- NULL
[16:05:19.880]                         }
[16:05:19.880]                         if (!has_future || version < "1.8.0") {
[16:05:19.880]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.880]                             "", base::R.version$version.string), 
[16:05:19.880]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.880]                               "release", "version")], collapse = " "), 
[16:05:19.880]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.880]                             info)
[16:05:19.880]                           info <- base::paste(info, collapse = "; ")
[16:05:19.880]                           if (!has_future) {
[16:05:19.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.880]                               info)
[16:05:19.880]                           }
[16:05:19.880]                           else {
[16:05:19.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.880]                               info, version)
[16:05:19.880]                           }
[16:05:19.880]                           base::stop(msg)
[16:05:19.880]                         }
[16:05:19.880]                       })
[16:05:19.880]                     }
[16:05:19.880]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.880]                     base::options(mc.cores = 1L)
[16:05:19.880]                   }
[16:05:19.880]                   options(future.plan = NULL)
[16:05:19.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.880]                 }
[16:05:19.880]                 ...future.workdir <- getwd()
[16:05:19.880]             }
[16:05:19.880]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.880]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.880]         }
[16:05:19.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.880]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.880]             base::names(...future.oldOptions))
[16:05:19.880]     }
[16:05:19.880]     if (FALSE) {
[16:05:19.880]     }
[16:05:19.880]     else {
[16:05:19.880]         if (TRUE) {
[16:05:19.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.880]                 open = "w")
[16:05:19.880]         }
[16:05:19.880]         else {
[16:05:19.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.880]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.880]         }
[16:05:19.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.880]             base::sink(type = "output", split = FALSE)
[16:05:19.880]             base::close(...future.stdout)
[16:05:19.880]         }, add = TRUE)
[16:05:19.880]     }
[16:05:19.880]     ...future.frame <- base::sys.nframe()
[16:05:19.880]     ...future.conditions <- base::list()
[16:05:19.880]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.880]     if (FALSE) {
[16:05:19.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.880]     }
[16:05:19.880]     ...future.result <- base::tryCatch({
[16:05:19.880]         base::withCallingHandlers({
[16:05:19.880]             ...future.value <- base::withVisible(base::local({
[16:05:19.880]                 withCallingHandlers({
[16:05:19.880]                   {
[16:05:19.880]                     stop(structure(list(message = "boom"), class = c("MyError", 
[16:05:19.880]                       "error", "condition")))
[16:05:19.880]                   }
[16:05:19.880]                 }, immediateCondition = function(cond) {
[16:05:19.880]                   save_rds <- function (object, pathname, ...) 
[16:05:19.880]                   {
[16:05:19.880]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.880]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.880]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.880]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.880]                         fi_tmp[["mtime"]])
[16:05:19.880]                     }
[16:05:19.880]                     tryCatch({
[16:05:19.880]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.880]                     }, error = function(ex) {
[16:05:19.880]                       msg <- conditionMessage(ex)
[16:05:19.880]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.880]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.880]                         fi_tmp[["mtime"]], msg)
[16:05:19.880]                       ex$message <- msg
[16:05:19.880]                       stop(ex)
[16:05:19.880]                     })
[16:05:19.880]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.880]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.880]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.880]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.880]                       fi <- file.info(pathname)
[16:05:19.880]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.880]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.880]                         fi[["size"]], fi[["mtime"]])
[16:05:19.880]                       stop(msg)
[16:05:19.880]                     }
[16:05:19.880]                     invisible(pathname)
[16:05:19.880]                   }
[16:05:19.880]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.880]                     rootPath = tempdir()) 
[16:05:19.880]                   {
[16:05:19.880]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.880]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.880]                       tmpdir = path, fileext = ".rds")
[16:05:19.880]                     save_rds(obj, file)
[16:05:19.880]                   }
[16:05:19.880]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.880]                   {
[16:05:19.880]                     inherits <- base::inherits
[16:05:19.880]                     invokeRestart <- base::invokeRestart
[16:05:19.880]                     is.null <- base::is.null
[16:05:19.880]                     muffled <- FALSE
[16:05:19.880]                     if (inherits(cond, "message")) {
[16:05:19.880]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.880]                       if (muffled) 
[16:05:19.880]                         invokeRestart("muffleMessage")
[16:05:19.880]                     }
[16:05:19.880]                     else if (inherits(cond, "warning")) {
[16:05:19.880]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.880]                       if (muffled) 
[16:05:19.880]                         invokeRestart("muffleWarning")
[16:05:19.880]                     }
[16:05:19.880]                     else if (inherits(cond, "condition")) {
[16:05:19.880]                       if (!is.null(pattern)) {
[16:05:19.880]                         computeRestarts <- base::computeRestarts
[16:05:19.880]                         grepl <- base::grepl
[16:05:19.880]                         restarts <- computeRestarts(cond)
[16:05:19.880]                         for (restart in restarts) {
[16:05:19.880]                           name <- restart$name
[16:05:19.880]                           if (is.null(name)) 
[16:05:19.880]                             next
[16:05:19.880]                           if (!grepl(pattern, name)) 
[16:05:19.880]                             next
[16:05:19.880]                           invokeRestart(restart)
[16:05:19.880]                           muffled <- TRUE
[16:05:19.880]                           break
[16:05:19.880]                         }
[16:05:19.880]                       }
[16:05:19.880]                     }
[16:05:19.880]                     invisible(muffled)
[16:05:19.880]                   }
[16:05:19.880]                   muffleCondition(cond)
[16:05:19.880]                 })
[16:05:19.880]             }))
[16:05:19.880]             future::FutureResult(value = ...future.value$value, 
[16:05:19.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.880]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.880]                     ...future.globalenv.names))
[16:05:19.880]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.880]         }, condition = base::local({
[16:05:19.880]             c <- base::c
[16:05:19.880]             inherits <- base::inherits
[16:05:19.880]             invokeRestart <- base::invokeRestart
[16:05:19.880]             length <- base::length
[16:05:19.880]             list <- base::list
[16:05:19.880]             seq.int <- base::seq.int
[16:05:19.880]             signalCondition <- base::signalCondition
[16:05:19.880]             sys.calls <- base::sys.calls
[16:05:19.880]             `[[` <- base::`[[`
[16:05:19.880]             `+` <- base::`+`
[16:05:19.880]             `<<-` <- base::`<<-`
[16:05:19.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.880]                   3L)]
[16:05:19.880]             }
[16:05:19.880]             function(cond) {
[16:05:19.880]                 is_error <- inherits(cond, "error")
[16:05:19.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.880]                   NULL)
[16:05:19.880]                 if (is_error) {
[16:05:19.880]                   sessionInformation <- function() {
[16:05:19.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.880]                       search = base::search(), system = base::Sys.info())
[16:05:19.880]                   }
[16:05:19.880]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.880]                     cond$call), session = sessionInformation(), 
[16:05:19.880]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.880]                   signalCondition(cond)
[16:05:19.880]                 }
[16:05:19.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.880]                 "immediateCondition"))) {
[16:05:19.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.880]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.880]                   if (TRUE && !signal) {
[16:05:19.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.880]                     {
[16:05:19.880]                       inherits <- base::inherits
[16:05:19.880]                       invokeRestart <- base::invokeRestart
[16:05:19.880]                       is.null <- base::is.null
[16:05:19.880]                       muffled <- FALSE
[16:05:19.880]                       if (inherits(cond, "message")) {
[16:05:19.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.880]                         if (muffled) 
[16:05:19.880]                           invokeRestart("muffleMessage")
[16:05:19.880]                       }
[16:05:19.880]                       else if (inherits(cond, "warning")) {
[16:05:19.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.880]                         if (muffled) 
[16:05:19.880]                           invokeRestart("muffleWarning")
[16:05:19.880]                       }
[16:05:19.880]                       else if (inherits(cond, "condition")) {
[16:05:19.880]                         if (!is.null(pattern)) {
[16:05:19.880]                           computeRestarts <- base::computeRestarts
[16:05:19.880]                           grepl <- base::grepl
[16:05:19.880]                           restarts <- computeRestarts(cond)
[16:05:19.880]                           for (restart in restarts) {
[16:05:19.880]                             name <- restart$name
[16:05:19.880]                             if (is.null(name)) 
[16:05:19.880]                               next
[16:05:19.880]                             if (!grepl(pattern, name)) 
[16:05:19.880]                               next
[16:05:19.880]                             invokeRestart(restart)
[16:05:19.880]                             muffled <- TRUE
[16:05:19.880]                             break
[16:05:19.880]                           }
[16:05:19.880]                         }
[16:05:19.880]                       }
[16:05:19.880]                       invisible(muffled)
[16:05:19.880]                     }
[16:05:19.880]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.880]                   }
[16:05:19.880]                 }
[16:05:19.880]                 else {
[16:05:19.880]                   if (TRUE) {
[16:05:19.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.880]                     {
[16:05:19.880]                       inherits <- base::inherits
[16:05:19.880]                       invokeRestart <- base::invokeRestart
[16:05:19.880]                       is.null <- base::is.null
[16:05:19.880]                       muffled <- FALSE
[16:05:19.880]                       if (inherits(cond, "message")) {
[16:05:19.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.880]                         if (muffled) 
[16:05:19.880]                           invokeRestart("muffleMessage")
[16:05:19.880]                       }
[16:05:19.880]                       else if (inherits(cond, "warning")) {
[16:05:19.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.880]                         if (muffled) 
[16:05:19.880]                           invokeRestart("muffleWarning")
[16:05:19.880]                       }
[16:05:19.880]                       else if (inherits(cond, "condition")) {
[16:05:19.880]                         if (!is.null(pattern)) {
[16:05:19.880]                           computeRestarts <- base::computeRestarts
[16:05:19.880]                           grepl <- base::grepl
[16:05:19.880]                           restarts <- computeRestarts(cond)
[16:05:19.880]                           for (restart in restarts) {
[16:05:19.880]                             name <- restart$name
[16:05:19.880]                             if (is.null(name)) 
[16:05:19.880]                               next
[16:05:19.880]                             if (!grepl(pattern, name)) 
[16:05:19.880]                               next
[16:05:19.880]                             invokeRestart(restart)
[16:05:19.880]                             muffled <- TRUE
[16:05:19.880]                             break
[16:05:19.880]                           }
[16:05:19.880]                         }
[16:05:19.880]                       }
[16:05:19.880]                       invisible(muffled)
[16:05:19.880]                     }
[16:05:19.880]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.880]                   }
[16:05:19.880]                 }
[16:05:19.880]             }
[16:05:19.880]         }))
[16:05:19.880]     }, error = function(ex) {
[16:05:19.880]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.880]                 ...future.rng), started = ...future.startTime, 
[16:05:19.880]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.880]             version = "1.8"), class = "FutureResult")
[16:05:19.880]     }, finally = {
[16:05:19.880]         if (!identical(...future.workdir, getwd())) 
[16:05:19.880]             setwd(...future.workdir)
[16:05:19.880]         {
[16:05:19.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.880]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.880]             }
[16:05:19.880]             base::options(...future.oldOptions)
[16:05:19.880]             if (.Platform$OS.type == "windows") {
[16:05:19.880]                 old_names <- names(...future.oldEnvVars)
[16:05:19.880]                 envs <- base::Sys.getenv()
[16:05:19.880]                 names <- names(envs)
[16:05:19.880]                 common <- intersect(names, old_names)
[16:05:19.880]                 added <- setdiff(names, old_names)
[16:05:19.880]                 removed <- setdiff(old_names, names)
[16:05:19.880]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.880]                   envs[common]]
[16:05:19.880]                 NAMES <- toupper(changed)
[16:05:19.880]                 args <- list()
[16:05:19.880]                 for (kk in seq_along(NAMES)) {
[16:05:19.880]                   name <- changed[[kk]]
[16:05:19.880]                   NAME <- NAMES[[kk]]
[16:05:19.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.880]                     next
[16:05:19.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.880]                 }
[16:05:19.880]                 NAMES <- toupper(added)
[16:05:19.880]                 for (kk in seq_along(NAMES)) {
[16:05:19.880]                   name <- added[[kk]]
[16:05:19.880]                   NAME <- NAMES[[kk]]
[16:05:19.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.880]                     next
[16:05:19.880]                   args[[name]] <- ""
[16:05:19.880]                 }
[16:05:19.880]                 NAMES <- toupper(removed)
[16:05:19.880]                 for (kk in seq_along(NAMES)) {
[16:05:19.880]                   name <- removed[[kk]]
[16:05:19.880]                   NAME <- NAMES[[kk]]
[16:05:19.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.880]                     next
[16:05:19.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.880]                 }
[16:05:19.880]                 if (length(args) > 0) 
[16:05:19.880]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.880]             }
[16:05:19.880]             else {
[16:05:19.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.880]             }
[16:05:19.880]             {
[16:05:19.880]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.880]                   0L) {
[16:05:19.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.880]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.880]                   base::options(opts)
[16:05:19.880]                 }
[16:05:19.880]                 {
[16:05:19.880]                   {
[16:05:19.880]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.880]                     NULL
[16:05:19.880]                   }
[16:05:19.880]                   options(future.plan = NULL)
[16:05:19.880]                   if (is.na(NA_character_)) 
[16:05:19.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.880]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.880]                     envir = parent.frame()) 
[16:05:19.880]                   {
[16:05:19.880]                     default_workers <- missing(workers)
[16:05:19.880]                     if (is.function(workers)) 
[16:05:19.880]                       workers <- workers()
[16:05:19.880]                     workers <- structure(as.integer(workers), 
[16:05:19.880]                       class = class(workers))
[16:05:19.880]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.880]                       1L)
[16:05:19.880]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.880]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.880]                       if (default_workers) 
[16:05:19.880]                         supportsMulticore(warn = TRUE)
[16:05:19.880]                       return(sequential(..., envir = envir))
[16:05:19.880]                     }
[16:05:19.880]                     oopts <- options(mc.cores = workers)
[16:05:19.880]                     on.exit(options(oopts))
[16:05:19.880]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.880]                       envir = envir)
[16:05:19.880]                     if (!future$lazy) 
[16:05:19.880]                       future <- run(future)
[16:05:19.880]                     invisible(future)
[16:05:19.880]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.880]                 }
[16:05:19.880]             }
[16:05:19.880]         }
[16:05:19.880]     })
[16:05:19.880]     if (TRUE) {
[16:05:19.880]         base::sink(type = "output", split = FALSE)
[16:05:19.880]         if (TRUE) {
[16:05:19.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.880]         }
[16:05:19.880]         else {
[16:05:19.880]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.880]         }
[16:05:19.880]         base::close(...future.stdout)
[16:05:19.880]         ...future.stdout <- NULL
[16:05:19.880]     }
[16:05:19.880]     ...future.result$conditions <- ...future.conditions
[16:05:19.880]     ...future.result$finished <- base::Sys.time()
[16:05:19.880]     ...future.result
[16:05:19.880] }
[16:05:19.883] requestCore(): workers = 2
[16:05:19.884] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:19.885] plan(): Setting new future strategy stack:
[16:05:19.886] List of future strategies:
[16:05:19.886] 1. sequential:
[16:05:19.886]    - args: function (..., envir = parent.frame())
[16:05:19.886]    - tweaked: FALSE
[16:05:19.886]    - call: NULL
[16:05:19.887] plan(): nbrOfWorkers() = 1
[16:05:19.888] plan(): Setting new future strategy stack:
[16:05:19.889] List of future strategies:
[16:05:19.889] 1. multicore:
[16:05:19.889]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.889]    - tweaked: FALSE
[16:05:19.889]    - call: plan(multicore)
[16:05:19.894] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:19.896] result() for MulticoreFuture ...
[16:05:19.898] result() for MulticoreFuture ...
[16:05:19.899] result() for MulticoreFuture ... done
[16:05:19.899] signalConditions() ...
[16:05:19.899]  - include = ‘immediateCondition’
[16:05:19.899]  - exclude = 
[16:05:19.899]  - resignal = FALSE
[16:05:19.899]  - Number of conditions: 1
[16:05:19.899] signalConditions() ... done
[16:05:19.899] result() for MulticoreFuture ... done
[16:05:19.900] result() for MulticoreFuture ...
[16:05:19.900] result() for MulticoreFuture ... done
[16:05:19.900] signalConditions() ...
[16:05:19.900]  - include = ‘immediateCondition’
[16:05:19.900]  - exclude = 
[16:05:19.900]  - resignal = FALSE
[16:05:19.900]  - Number of conditions: 1
[16:05:19.900] signalConditions() ... done
<MyError: boom>
[16:05:19.901] result() for MulticoreFuture ...
[16:05:19.901] result() for MulticoreFuture ... done
[16:05:19.901] result() for MulticoreFuture ...
[16:05:19.901] result() for MulticoreFuture ... done
[16:05:19.901] signalConditions() ...
[16:05:19.901]  - include = ‘immediateCondition’
[16:05:19.901]  - exclude = 
[16:05:19.901]  - resignal = FALSE
[16:05:19.902]  - Number of conditions: 1
[16:05:19.902] signalConditions() ... done
[16:05:19.902] Future state: ‘finished’
[16:05:19.902] result() for MulticoreFuture ...
[16:05:19.902] result() for MulticoreFuture ... done
[16:05:19.902] signalConditions() ...
[16:05:19.902]  - include = ‘condition’
[16:05:19.902]  - exclude = ‘immediateCondition’
[16:05:19.902]  - resignal = TRUE
[16:05:19.903]  - Number of conditions: 1
[16:05:19.903]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:05:19.903] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[16:05:19.907] getGlobalsAndPackages() ...
[16:05:19.907] Searching for globals...
[16:05:19.908] - globals found: [1] ‘{’
[16:05:19.908] Searching for globals ... DONE
[16:05:19.908] Resolving globals: FALSE
[16:05:19.908] 
[16:05:19.908] 
[16:05:19.909] getGlobalsAndPackages() ... DONE
[16:05:19.909] Packages needed by the future expression (n = 0): <none>
[16:05:19.909] Packages needed by future strategies (n = 0): <none>
[16:05:19.910] {
[16:05:19.910]     {
[16:05:19.910]         {
[16:05:19.910]             ...future.startTime <- base::Sys.time()
[16:05:19.910]             {
[16:05:19.910]                 {
[16:05:19.910]                   {
[16:05:19.910]                     {
[16:05:19.910]                       base::local({
[16:05:19.910]                         has_future <- base::requireNamespace("future", 
[16:05:19.910]                           quietly = TRUE)
[16:05:19.910]                         if (has_future) {
[16:05:19.910]                           ns <- base::getNamespace("future")
[16:05:19.910]                           version <- ns[[".package"]][["version"]]
[16:05:19.910]                           if (is.null(version)) 
[16:05:19.910]                             version <- utils::packageVersion("future")
[16:05:19.910]                         }
[16:05:19.910]                         else {
[16:05:19.910]                           version <- NULL
[16:05:19.910]                         }
[16:05:19.910]                         if (!has_future || version < "1.8.0") {
[16:05:19.910]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.910]                             "", base::R.version$version.string), 
[16:05:19.910]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.910]                               "release", "version")], collapse = " "), 
[16:05:19.910]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.910]                             info)
[16:05:19.910]                           info <- base::paste(info, collapse = "; ")
[16:05:19.910]                           if (!has_future) {
[16:05:19.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.910]                               info)
[16:05:19.910]                           }
[16:05:19.910]                           else {
[16:05:19.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.910]                               info, version)
[16:05:19.910]                           }
[16:05:19.910]                           base::stop(msg)
[16:05:19.910]                         }
[16:05:19.910]                       })
[16:05:19.910]                     }
[16:05:19.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.910]                     base::options(mc.cores = 1L)
[16:05:19.910]                   }
[16:05:19.910]                   options(future.plan = NULL)
[16:05:19.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.910]                 }
[16:05:19.910]                 ...future.workdir <- getwd()
[16:05:19.910]             }
[16:05:19.910]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.910]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.910]         }
[16:05:19.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.910]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.910]             base::names(...future.oldOptions))
[16:05:19.910]     }
[16:05:19.910]     if (FALSE) {
[16:05:19.910]     }
[16:05:19.910]     else {
[16:05:19.910]         if (TRUE) {
[16:05:19.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.910]                 open = "w")
[16:05:19.910]         }
[16:05:19.910]         else {
[16:05:19.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.910]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.910]         }
[16:05:19.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.910]             base::sink(type = "output", split = FALSE)
[16:05:19.910]             base::close(...future.stdout)
[16:05:19.910]         }, add = TRUE)
[16:05:19.910]     }
[16:05:19.910]     ...future.frame <- base::sys.nframe()
[16:05:19.910]     ...future.conditions <- base::list()
[16:05:19.910]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.910]     if (FALSE) {
[16:05:19.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.910]     }
[16:05:19.910]     ...future.result <- base::tryCatch({
[16:05:19.910]         base::withCallingHandlers({
[16:05:19.910]             ...future.value <- base::withVisible(base::local({
[16:05:19.910]                 withCallingHandlers({
[16:05:19.910]                   {
[16:05:19.910]                     42L
[16:05:19.910]                   }
[16:05:19.910]                 }, immediateCondition = function(cond) {
[16:05:19.910]                   save_rds <- function (object, pathname, ...) 
[16:05:19.910]                   {
[16:05:19.910]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.910]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.910]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.910]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.910]                         fi_tmp[["mtime"]])
[16:05:19.910]                     }
[16:05:19.910]                     tryCatch({
[16:05:19.910]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.910]                     }, error = function(ex) {
[16:05:19.910]                       msg <- conditionMessage(ex)
[16:05:19.910]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.910]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.910]                         fi_tmp[["mtime"]], msg)
[16:05:19.910]                       ex$message <- msg
[16:05:19.910]                       stop(ex)
[16:05:19.910]                     })
[16:05:19.910]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.910]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.910]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.910]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.910]                       fi <- file.info(pathname)
[16:05:19.910]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.910]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.910]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.910]                         fi[["size"]], fi[["mtime"]])
[16:05:19.910]                       stop(msg)
[16:05:19.910]                     }
[16:05:19.910]                     invisible(pathname)
[16:05:19.910]                   }
[16:05:19.910]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.910]                     rootPath = tempdir()) 
[16:05:19.910]                   {
[16:05:19.910]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.910]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.910]                       tmpdir = path, fileext = ".rds")
[16:05:19.910]                     save_rds(obj, file)
[16:05:19.910]                   }
[16:05:19.910]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.910]                   {
[16:05:19.910]                     inherits <- base::inherits
[16:05:19.910]                     invokeRestart <- base::invokeRestart
[16:05:19.910]                     is.null <- base::is.null
[16:05:19.910]                     muffled <- FALSE
[16:05:19.910]                     if (inherits(cond, "message")) {
[16:05:19.910]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.910]                       if (muffled) 
[16:05:19.910]                         invokeRestart("muffleMessage")
[16:05:19.910]                     }
[16:05:19.910]                     else if (inherits(cond, "warning")) {
[16:05:19.910]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.910]                       if (muffled) 
[16:05:19.910]                         invokeRestart("muffleWarning")
[16:05:19.910]                     }
[16:05:19.910]                     else if (inherits(cond, "condition")) {
[16:05:19.910]                       if (!is.null(pattern)) {
[16:05:19.910]                         computeRestarts <- base::computeRestarts
[16:05:19.910]                         grepl <- base::grepl
[16:05:19.910]                         restarts <- computeRestarts(cond)
[16:05:19.910]                         for (restart in restarts) {
[16:05:19.910]                           name <- restart$name
[16:05:19.910]                           if (is.null(name)) 
[16:05:19.910]                             next
[16:05:19.910]                           if (!grepl(pattern, name)) 
[16:05:19.910]                             next
[16:05:19.910]                           invokeRestart(restart)
[16:05:19.910]                           muffled <- TRUE
[16:05:19.910]                           break
[16:05:19.910]                         }
[16:05:19.910]                       }
[16:05:19.910]                     }
[16:05:19.910]                     invisible(muffled)
[16:05:19.910]                   }
[16:05:19.910]                   muffleCondition(cond)
[16:05:19.910]                 })
[16:05:19.910]             }))
[16:05:19.910]             future::FutureResult(value = ...future.value$value, 
[16:05:19.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.910]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.910]                     ...future.globalenv.names))
[16:05:19.910]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.910]         }, condition = base::local({
[16:05:19.910]             c <- base::c
[16:05:19.910]             inherits <- base::inherits
[16:05:19.910]             invokeRestart <- base::invokeRestart
[16:05:19.910]             length <- base::length
[16:05:19.910]             list <- base::list
[16:05:19.910]             seq.int <- base::seq.int
[16:05:19.910]             signalCondition <- base::signalCondition
[16:05:19.910]             sys.calls <- base::sys.calls
[16:05:19.910]             `[[` <- base::`[[`
[16:05:19.910]             `+` <- base::`+`
[16:05:19.910]             `<<-` <- base::`<<-`
[16:05:19.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.910]                   3L)]
[16:05:19.910]             }
[16:05:19.910]             function(cond) {
[16:05:19.910]                 is_error <- inherits(cond, "error")
[16:05:19.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.910]                   NULL)
[16:05:19.910]                 if (is_error) {
[16:05:19.910]                   sessionInformation <- function() {
[16:05:19.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.910]                       search = base::search(), system = base::Sys.info())
[16:05:19.910]                   }
[16:05:19.910]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.910]                     cond$call), session = sessionInformation(), 
[16:05:19.910]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.910]                   signalCondition(cond)
[16:05:19.910]                 }
[16:05:19.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.910]                 "immediateCondition"))) {
[16:05:19.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.910]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.910]                   if (TRUE && !signal) {
[16:05:19.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.910]                     {
[16:05:19.910]                       inherits <- base::inherits
[16:05:19.910]                       invokeRestart <- base::invokeRestart
[16:05:19.910]                       is.null <- base::is.null
[16:05:19.910]                       muffled <- FALSE
[16:05:19.910]                       if (inherits(cond, "message")) {
[16:05:19.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.910]                         if (muffled) 
[16:05:19.910]                           invokeRestart("muffleMessage")
[16:05:19.910]                       }
[16:05:19.910]                       else if (inherits(cond, "warning")) {
[16:05:19.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.910]                         if (muffled) 
[16:05:19.910]                           invokeRestart("muffleWarning")
[16:05:19.910]                       }
[16:05:19.910]                       else if (inherits(cond, "condition")) {
[16:05:19.910]                         if (!is.null(pattern)) {
[16:05:19.910]                           computeRestarts <- base::computeRestarts
[16:05:19.910]                           grepl <- base::grepl
[16:05:19.910]                           restarts <- computeRestarts(cond)
[16:05:19.910]                           for (restart in restarts) {
[16:05:19.910]                             name <- restart$name
[16:05:19.910]                             if (is.null(name)) 
[16:05:19.910]                               next
[16:05:19.910]                             if (!grepl(pattern, name)) 
[16:05:19.910]                               next
[16:05:19.910]                             invokeRestart(restart)
[16:05:19.910]                             muffled <- TRUE
[16:05:19.910]                             break
[16:05:19.910]                           }
[16:05:19.910]                         }
[16:05:19.910]                       }
[16:05:19.910]                       invisible(muffled)
[16:05:19.910]                     }
[16:05:19.910]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.910]                   }
[16:05:19.910]                 }
[16:05:19.910]                 else {
[16:05:19.910]                   if (TRUE) {
[16:05:19.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.910]                     {
[16:05:19.910]                       inherits <- base::inherits
[16:05:19.910]                       invokeRestart <- base::invokeRestart
[16:05:19.910]                       is.null <- base::is.null
[16:05:19.910]                       muffled <- FALSE
[16:05:19.910]                       if (inherits(cond, "message")) {
[16:05:19.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.910]                         if (muffled) 
[16:05:19.910]                           invokeRestart("muffleMessage")
[16:05:19.910]                       }
[16:05:19.910]                       else if (inherits(cond, "warning")) {
[16:05:19.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.910]                         if (muffled) 
[16:05:19.910]                           invokeRestart("muffleWarning")
[16:05:19.910]                       }
[16:05:19.910]                       else if (inherits(cond, "condition")) {
[16:05:19.910]                         if (!is.null(pattern)) {
[16:05:19.910]                           computeRestarts <- base::computeRestarts
[16:05:19.910]                           grepl <- base::grepl
[16:05:19.910]                           restarts <- computeRestarts(cond)
[16:05:19.910]                           for (restart in restarts) {
[16:05:19.910]                             name <- restart$name
[16:05:19.910]                             if (is.null(name)) 
[16:05:19.910]                               next
[16:05:19.910]                             if (!grepl(pattern, name)) 
[16:05:19.910]                               next
[16:05:19.910]                             invokeRestart(restart)
[16:05:19.910]                             muffled <- TRUE
[16:05:19.910]                             break
[16:05:19.910]                           }
[16:05:19.910]                         }
[16:05:19.910]                       }
[16:05:19.910]                       invisible(muffled)
[16:05:19.910]                     }
[16:05:19.910]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.910]                   }
[16:05:19.910]                 }
[16:05:19.910]             }
[16:05:19.910]         }))
[16:05:19.910]     }, error = function(ex) {
[16:05:19.910]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.910]                 ...future.rng), started = ...future.startTime, 
[16:05:19.910]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.910]             version = "1.8"), class = "FutureResult")
[16:05:19.910]     }, finally = {
[16:05:19.910]         if (!identical(...future.workdir, getwd())) 
[16:05:19.910]             setwd(...future.workdir)
[16:05:19.910]         {
[16:05:19.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.910]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.910]             }
[16:05:19.910]             base::options(...future.oldOptions)
[16:05:19.910]             if (.Platform$OS.type == "windows") {
[16:05:19.910]                 old_names <- names(...future.oldEnvVars)
[16:05:19.910]                 envs <- base::Sys.getenv()
[16:05:19.910]                 names <- names(envs)
[16:05:19.910]                 common <- intersect(names, old_names)
[16:05:19.910]                 added <- setdiff(names, old_names)
[16:05:19.910]                 removed <- setdiff(old_names, names)
[16:05:19.910]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.910]                   envs[common]]
[16:05:19.910]                 NAMES <- toupper(changed)
[16:05:19.910]                 args <- list()
[16:05:19.910]                 for (kk in seq_along(NAMES)) {
[16:05:19.910]                   name <- changed[[kk]]
[16:05:19.910]                   NAME <- NAMES[[kk]]
[16:05:19.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.910]                     next
[16:05:19.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.910]                 }
[16:05:19.910]                 NAMES <- toupper(added)
[16:05:19.910]                 for (kk in seq_along(NAMES)) {
[16:05:19.910]                   name <- added[[kk]]
[16:05:19.910]                   NAME <- NAMES[[kk]]
[16:05:19.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.910]                     next
[16:05:19.910]                   args[[name]] <- ""
[16:05:19.910]                 }
[16:05:19.910]                 NAMES <- toupper(removed)
[16:05:19.910]                 for (kk in seq_along(NAMES)) {
[16:05:19.910]                   name <- removed[[kk]]
[16:05:19.910]                   NAME <- NAMES[[kk]]
[16:05:19.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.910]                     next
[16:05:19.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.910]                 }
[16:05:19.910]                 if (length(args) > 0) 
[16:05:19.910]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.910]             }
[16:05:19.910]             else {
[16:05:19.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.910]             }
[16:05:19.910]             {
[16:05:19.910]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.910]                   0L) {
[16:05:19.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.910]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.910]                   base::options(opts)
[16:05:19.910]                 }
[16:05:19.910]                 {
[16:05:19.910]                   {
[16:05:19.910]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.910]                     NULL
[16:05:19.910]                   }
[16:05:19.910]                   options(future.plan = NULL)
[16:05:19.910]                   if (is.na(NA_character_)) 
[16:05:19.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.910]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.910]                     envir = parent.frame()) 
[16:05:19.910]                   {
[16:05:19.910]                     default_workers <- missing(workers)
[16:05:19.910]                     if (is.function(workers)) 
[16:05:19.910]                       workers <- workers()
[16:05:19.910]                     workers <- structure(as.integer(workers), 
[16:05:19.910]                       class = class(workers))
[16:05:19.910]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.910]                       1L)
[16:05:19.910]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.910]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.910]                       if (default_workers) 
[16:05:19.910]                         supportsMulticore(warn = TRUE)
[16:05:19.910]                       return(sequential(..., envir = envir))
[16:05:19.910]                     }
[16:05:19.910]                     oopts <- options(mc.cores = workers)
[16:05:19.910]                     on.exit(options(oopts))
[16:05:19.910]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.910]                       envir = envir)
[16:05:19.910]                     if (!future$lazy) 
[16:05:19.910]                       future <- run(future)
[16:05:19.910]                     invisible(future)
[16:05:19.910]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.910]                 }
[16:05:19.910]             }
[16:05:19.910]         }
[16:05:19.910]     })
[16:05:19.910]     if (TRUE) {
[16:05:19.910]         base::sink(type = "output", split = FALSE)
[16:05:19.910]         if (TRUE) {
[16:05:19.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.910]         }
[16:05:19.910]         else {
[16:05:19.910]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.910]         }
[16:05:19.910]         base::close(...future.stdout)
[16:05:19.910]         ...future.stdout <- NULL
[16:05:19.910]     }
[16:05:19.910]     ...future.result$conditions <- ...future.conditions
[16:05:19.910]     ...future.result$finished <- base::Sys.time()
[16:05:19.910]     ...future.result
[16:05:19.910] }
[16:05:19.912] requestCore(): workers = 2
[16:05:19.914] MulticoreFuture started
[16:05:19.915] plan(): Setting new future strategy stack:
[16:05:19.916] List of future strategies:
[16:05:19.916] 1. sequential:
[16:05:19.916]    - args: function (..., envir = parent.frame())
[16:05:19.916]    - tweaked: FALSE
[16:05:19.916]    - call: NULL
[16:05:19.917] plan(): nbrOfWorkers() = 1
[16:05:19.918] plan(): Setting new future strategy stack:
[16:05:19.919] List of future strategies:
[16:05:19.919] 1. multicore:
[16:05:19.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.919]    - tweaked: FALSE
[16:05:19.919]    - call: plan(multicore)
[16:05:19.924] plan(): nbrOfWorkers() = 2
[1] TRUE
[16:05:19.924] result() for MulticoreFuture ...
[16:05:19.925] result() for MulticoreFuture ...
[16:05:19.926] result() for MulticoreFuture ... done
[16:05:19.926] result() for MulticoreFuture ... done
[16:05:19.926] result() for MulticoreFuture ...
[16:05:19.926] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = TRUE) with globals
[16:05:19.930] getGlobalsAndPackages() ...
[16:05:19.930] Searching for globals...
[16:05:19.933] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[16:05:19.933] Searching for globals ... DONE
[16:05:19.933] Resolving globals: FALSE
[16:05:19.934] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.934] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[16:05:19.934] - globals: [1] ‘a’
[16:05:19.934] 
[16:05:19.934] getGlobalsAndPackages() ... DONE
[16:05:19.935] Packages needed by the future expression (n = 0): <none>
[16:05:19.935] Packages needed by future strategies (n = 0): <none>
[16:05:19.936] {
[16:05:19.936]     {
[16:05:19.936]         {
[16:05:19.936]             ...future.startTime <- base::Sys.time()
[16:05:19.936]             {
[16:05:19.936]                 {
[16:05:19.936]                   {
[16:05:19.936]                     {
[16:05:19.936]                       base::local({
[16:05:19.936]                         has_future <- base::requireNamespace("future", 
[16:05:19.936]                           quietly = TRUE)
[16:05:19.936]                         if (has_future) {
[16:05:19.936]                           ns <- base::getNamespace("future")
[16:05:19.936]                           version <- ns[[".package"]][["version"]]
[16:05:19.936]                           if (is.null(version)) 
[16:05:19.936]                             version <- utils::packageVersion("future")
[16:05:19.936]                         }
[16:05:19.936]                         else {
[16:05:19.936]                           version <- NULL
[16:05:19.936]                         }
[16:05:19.936]                         if (!has_future || version < "1.8.0") {
[16:05:19.936]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.936]                             "", base::R.version$version.string), 
[16:05:19.936]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.936]                               "release", "version")], collapse = " "), 
[16:05:19.936]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.936]                             info)
[16:05:19.936]                           info <- base::paste(info, collapse = "; ")
[16:05:19.936]                           if (!has_future) {
[16:05:19.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.936]                               info)
[16:05:19.936]                           }
[16:05:19.936]                           else {
[16:05:19.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.936]                               info, version)
[16:05:19.936]                           }
[16:05:19.936]                           base::stop(msg)
[16:05:19.936]                         }
[16:05:19.936]                       })
[16:05:19.936]                     }
[16:05:19.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.936]                     base::options(mc.cores = 1L)
[16:05:19.936]                   }
[16:05:19.936]                   options(future.plan = NULL)
[16:05:19.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.936]                 }
[16:05:19.936]                 ...future.workdir <- getwd()
[16:05:19.936]             }
[16:05:19.936]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.936]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.936]         }
[16:05:19.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.936]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.936]             base::names(...future.oldOptions))
[16:05:19.936]     }
[16:05:19.936]     if (FALSE) {
[16:05:19.936]     }
[16:05:19.936]     else {
[16:05:19.936]         if (TRUE) {
[16:05:19.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.936]                 open = "w")
[16:05:19.936]         }
[16:05:19.936]         else {
[16:05:19.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.936]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.936]         }
[16:05:19.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.936]             base::sink(type = "output", split = FALSE)
[16:05:19.936]             base::close(...future.stdout)
[16:05:19.936]         }, add = TRUE)
[16:05:19.936]     }
[16:05:19.936]     ...future.frame <- base::sys.nframe()
[16:05:19.936]     ...future.conditions <- base::list()
[16:05:19.936]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.936]     if (FALSE) {
[16:05:19.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.936]     }
[16:05:19.936]     ...future.result <- base::tryCatch({
[16:05:19.936]         base::withCallingHandlers({
[16:05:19.936]             ...future.value <- base::withVisible(base::local({
[16:05:19.936]                 withCallingHandlers({
[16:05:19.936]                   {
[16:05:19.936]                     b <- 3
[16:05:19.936]                     c <- 2
[16:05:19.936]                     a * b * c
[16:05:19.936]                   }
[16:05:19.936]                 }, immediateCondition = function(cond) {
[16:05:19.936]                   save_rds <- function (object, pathname, ...) 
[16:05:19.936]                   {
[16:05:19.936]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.936]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.936]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.936]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.936]                         fi_tmp[["mtime"]])
[16:05:19.936]                     }
[16:05:19.936]                     tryCatch({
[16:05:19.936]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.936]                     }, error = function(ex) {
[16:05:19.936]                       msg <- conditionMessage(ex)
[16:05:19.936]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.936]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.936]                         fi_tmp[["mtime"]], msg)
[16:05:19.936]                       ex$message <- msg
[16:05:19.936]                       stop(ex)
[16:05:19.936]                     })
[16:05:19.936]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.936]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.936]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.936]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.936]                       fi <- file.info(pathname)
[16:05:19.936]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.936]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.936]                         fi[["size"]], fi[["mtime"]])
[16:05:19.936]                       stop(msg)
[16:05:19.936]                     }
[16:05:19.936]                     invisible(pathname)
[16:05:19.936]                   }
[16:05:19.936]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.936]                     rootPath = tempdir()) 
[16:05:19.936]                   {
[16:05:19.936]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.936]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.936]                       tmpdir = path, fileext = ".rds")
[16:05:19.936]                     save_rds(obj, file)
[16:05:19.936]                   }
[16:05:19.936]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.936]                   {
[16:05:19.936]                     inherits <- base::inherits
[16:05:19.936]                     invokeRestart <- base::invokeRestart
[16:05:19.936]                     is.null <- base::is.null
[16:05:19.936]                     muffled <- FALSE
[16:05:19.936]                     if (inherits(cond, "message")) {
[16:05:19.936]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.936]                       if (muffled) 
[16:05:19.936]                         invokeRestart("muffleMessage")
[16:05:19.936]                     }
[16:05:19.936]                     else if (inherits(cond, "warning")) {
[16:05:19.936]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.936]                       if (muffled) 
[16:05:19.936]                         invokeRestart("muffleWarning")
[16:05:19.936]                     }
[16:05:19.936]                     else if (inherits(cond, "condition")) {
[16:05:19.936]                       if (!is.null(pattern)) {
[16:05:19.936]                         computeRestarts <- base::computeRestarts
[16:05:19.936]                         grepl <- base::grepl
[16:05:19.936]                         restarts <- computeRestarts(cond)
[16:05:19.936]                         for (restart in restarts) {
[16:05:19.936]                           name <- restart$name
[16:05:19.936]                           if (is.null(name)) 
[16:05:19.936]                             next
[16:05:19.936]                           if (!grepl(pattern, name)) 
[16:05:19.936]                             next
[16:05:19.936]                           invokeRestart(restart)
[16:05:19.936]                           muffled <- TRUE
[16:05:19.936]                           break
[16:05:19.936]                         }
[16:05:19.936]                       }
[16:05:19.936]                     }
[16:05:19.936]                     invisible(muffled)
[16:05:19.936]                   }
[16:05:19.936]                   muffleCondition(cond)
[16:05:19.936]                 })
[16:05:19.936]             }))
[16:05:19.936]             future::FutureResult(value = ...future.value$value, 
[16:05:19.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.936]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.936]                     ...future.globalenv.names))
[16:05:19.936]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.936]         }, condition = base::local({
[16:05:19.936]             c <- base::c
[16:05:19.936]             inherits <- base::inherits
[16:05:19.936]             invokeRestart <- base::invokeRestart
[16:05:19.936]             length <- base::length
[16:05:19.936]             list <- base::list
[16:05:19.936]             seq.int <- base::seq.int
[16:05:19.936]             signalCondition <- base::signalCondition
[16:05:19.936]             sys.calls <- base::sys.calls
[16:05:19.936]             `[[` <- base::`[[`
[16:05:19.936]             `+` <- base::`+`
[16:05:19.936]             `<<-` <- base::`<<-`
[16:05:19.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.936]                   3L)]
[16:05:19.936]             }
[16:05:19.936]             function(cond) {
[16:05:19.936]                 is_error <- inherits(cond, "error")
[16:05:19.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.936]                   NULL)
[16:05:19.936]                 if (is_error) {
[16:05:19.936]                   sessionInformation <- function() {
[16:05:19.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.936]                       search = base::search(), system = base::Sys.info())
[16:05:19.936]                   }
[16:05:19.936]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.936]                     cond$call), session = sessionInformation(), 
[16:05:19.936]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.936]                   signalCondition(cond)
[16:05:19.936]                 }
[16:05:19.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.936]                 "immediateCondition"))) {
[16:05:19.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.936]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.936]                   if (TRUE && !signal) {
[16:05:19.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.936]                     {
[16:05:19.936]                       inherits <- base::inherits
[16:05:19.936]                       invokeRestart <- base::invokeRestart
[16:05:19.936]                       is.null <- base::is.null
[16:05:19.936]                       muffled <- FALSE
[16:05:19.936]                       if (inherits(cond, "message")) {
[16:05:19.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.936]                         if (muffled) 
[16:05:19.936]                           invokeRestart("muffleMessage")
[16:05:19.936]                       }
[16:05:19.936]                       else if (inherits(cond, "warning")) {
[16:05:19.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.936]                         if (muffled) 
[16:05:19.936]                           invokeRestart("muffleWarning")
[16:05:19.936]                       }
[16:05:19.936]                       else if (inherits(cond, "condition")) {
[16:05:19.936]                         if (!is.null(pattern)) {
[16:05:19.936]                           computeRestarts <- base::computeRestarts
[16:05:19.936]                           grepl <- base::grepl
[16:05:19.936]                           restarts <- computeRestarts(cond)
[16:05:19.936]                           for (restart in restarts) {
[16:05:19.936]                             name <- restart$name
[16:05:19.936]                             if (is.null(name)) 
[16:05:19.936]                               next
[16:05:19.936]                             if (!grepl(pattern, name)) 
[16:05:19.936]                               next
[16:05:19.936]                             invokeRestart(restart)
[16:05:19.936]                             muffled <- TRUE
[16:05:19.936]                             break
[16:05:19.936]                           }
[16:05:19.936]                         }
[16:05:19.936]                       }
[16:05:19.936]                       invisible(muffled)
[16:05:19.936]                     }
[16:05:19.936]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.936]                   }
[16:05:19.936]                 }
[16:05:19.936]                 else {
[16:05:19.936]                   if (TRUE) {
[16:05:19.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.936]                     {
[16:05:19.936]                       inherits <- base::inherits
[16:05:19.936]                       invokeRestart <- base::invokeRestart
[16:05:19.936]                       is.null <- base::is.null
[16:05:19.936]                       muffled <- FALSE
[16:05:19.936]                       if (inherits(cond, "message")) {
[16:05:19.936]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.936]                         if (muffled) 
[16:05:19.936]                           invokeRestart("muffleMessage")
[16:05:19.936]                       }
[16:05:19.936]                       else if (inherits(cond, "warning")) {
[16:05:19.936]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.936]                         if (muffled) 
[16:05:19.936]                           invokeRestart("muffleWarning")
[16:05:19.936]                       }
[16:05:19.936]                       else if (inherits(cond, "condition")) {
[16:05:19.936]                         if (!is.null(pattern)) {
[16:05:19.936]                           computeRestarts <- base::computeRestarts
[16:05:19.936]                           grepl <- base::grepl
[16:05:19.936]                           restarts <- computeRestarts(cond)
[16:05:19.936]                           for (restart in restarts) {
[16:05:19.936]                             name <- restart$name
[16:05:19.936]                             if (is.null(name)) 
[16:05:19.936]                               next
[16:05:19.936]                             if (!grepl(pattern, name)) 
[16:05:19.936]                               next
[16:05:19.936]                             invokeRestart(restart)
[16:05:19.936]                             muffled <- TRUE
[16:05:19.936]                             break
[16:05:19.936]                           }
[16:05:19.936]                         }
[16:05:19.936]                       }
[16:05:19.936]                       invisible(muffled)
[16:05:19.936]                     }
[16:05:19.936]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.936]                   }
[16:05:19.936]                 }
[16:05:19.936]             }
[16:05:19.936]         }))
[16:05:19.936]     }, error = function(ex) {
[16:05:19.936]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.936]                 ...future.rng), started = ...future.startTime, 
[16:05:19.936]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.936]             version = "1.8"), class = "FutureResult")
[16:05:19.936]     }, finally = {
[16:05:19.936]         if (!identical(...future.workdir, getwd())) 
[16:05:19.936]             setwd(...future.workdir)
[16:05:19.936]         {
[16:05:19.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.936]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.936]             }
[16:05:19.936]             base::options(...future.oldOptions)
[16:05:19.936]             if (.Platform$OS.type == "windows") {
[16:05:19.936]                 old_names <- names(...future.oldEnvVars)
[16:05:19.936]                 envs <- base::Sys.getenv()
[16:05:19.936]                 names <- names(envs)
[16:05:19.936]                 common <- intersect(names, old_names)
[16:05:19.936]                 added <- setdiff(names, old_names)
[16:05:19.936]                 removed <- setdiff(old_names, names)
[16:05:19.936]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.936]                   envs[common]]
[16:05:19.936]                 NAMES <- toupper(changed)
[16:05:19.936]                 args <- list()
[16:05:19.936]                 for (kk in seq_along(NAMES)) {
[16:05:19.936]                   name <- changed[[kk]]
[16:05:19.936]                   NAME <- NAMES[[kk]]
[16:05:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.936]                     next
[16:05:19.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.936]                 }
[16:05:19.936]                 NAMES <- toupper(added)
[16:05:19.936]                 for (kk in seq_along(NAMES)) {
[16:05:19.936]                   name <- added[[kk]]
[16:05:19.936]                   NAME <- NAMES[[kk]]
[16:05:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.936]                     next
[16:05:19.936]                   args[[name]] <- ""
[16:05:19.936]                 }
[16:05:19.936]                 NAMES <- toupper(removed)
[16:05:19.936]                 for (kk in seq_along(NAMES)) {
[16:05:19.936]                   name <- removed[[kk]]
[16:05:19.936]                   NAME <- NAMES[[kk]]
[16:05:19.936]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.936]                     next
[16:05:19.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.936]                 }
[16:05:19.936]                 if (length(args) > 0) 
[16:05:19.936]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.936]             }
[16:05:19.936]             else {
[16:05:19.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.936]             }
[16:05:19.936]             {
[16:05:19.936]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.936]                   0L) {
[16:05:19.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.936]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.936]                   base::options(opts)
[16:05:19.936]                 }
[16:05:19.936]                 {
[16:05:19.936]                   {
[16:05:19.936]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.936]                     NULL
[16:05:19.936]                   }
[16:05:19.936]                   options(future.plan = NULL)
[16:05:19.936]                   if (is.na(NA_character_)) 
[16:05:19.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.936]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.936]                     envir = parent.frame()) 
[16:05:19.936]                   {
[16:05:19.936]                     default_workers <- missing(workers)
[16:05:19.936]                     if (is.function(workers)) 
[16:05:19.936]                       workers <- workers()
[16:05:19.936]                     workers <- structure(as.integer(workers), 
[16:05:19.936]                       class = class(workers))
[16:05:19.936]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.936]                       1L)
[16:05:19.936]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.936]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.936]                       if (default_workers) 
[16:05:19.936]                         supportsMulticore(warn = TRUE)
[16:05:19.936]                       return(sequential(..., envir = envir))
[16:05:19.936]                     }
[16:05:19.936]                     oopts <- options(mc.cores = workers)
[16:05:19.936]                     on.exit(options(oopts))
[16:05:19.936]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.936]                       envir = envir)
[16:05:19.936]                     if (!future$lazy) 
[16:05:19.936]                       future <- run(future)
[16:05:19.936]                     invisible(future)
[16:05:19.936]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.936]                 }
[16:05:19.936]             }
[16:05:19.936]         }
[16:05:19.936]     })
[16:05:19.936]     if (TRUE) {
[16:05:19.936]         base::sink(type = "output", split = FALSE)
[16:05:19.936]         if (TRUE) {
[16:05:19.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.936]         }
[16:05:19.936]         else {
[16:05:19.936]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.936]         }
[16:05:19.936]         base::close(...future.stdout)
[16:05:19.936]         ...future.stdout <- NULL
[16:05:19.936]     }
[16:05:19.936]     ...future.result$conditions <- ...future.conditions
[16:05:19.936]     ...future.result$finished <- base::Sys.time()
[16:05:19.936]     ...future.result
[16:05:19.936] }
[16:05:19.941] assign_globals() ...
[16:05:19.941] List of 1
[16:05:19.941]  $ a: num 0
[16:05:19.941]  - attr(*, "where")=List of 1
[16:05:19.941]   ..$ a:<environment: R_EmptyEnv> 
[16:05:19.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.941]  - attr(*, "resolved")= logi FALSE
[16:05:19.941]  - attr(*, "total_size")= num 56
[16:05:19.944] - copied ‘a’ to environment
[16:05:19.944] assign_globals() ... done
[16:05:19.945] requestCore(): workers = 2
[16:05:19.946] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
[16:05:19.948] plan(): Setting new future strategy stack:
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:19.948] List of future strategies:
[16:05:19.948] 1. sequential:
[16:05:19.948]    - args: function (..., envir = parent.frame())
[16:05:19.948]    - tweaked: FALSE
[16:05:19.948]    - call: NULL
[16:05:19.949] plan(): nbrOfWorkers() = 1
[16:05:19.950] plan(): Setting new future strategy stack:
[16:05:19.951] List of future strategies:
[16:05:19.951] 1. multicore:
[16:05:19.951]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.951]    - tweaked: FALSE
[16:05:19.951]    - call: plan(multicore)
[16:05:19.956] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:19.957] result() for MulticoreFuture ...
[16:05:19.957] result() for MulticoreFuture ...
[16:05:19.958] result() for MulticoreFuture ... done
[16:05:19.958] result() for MulticoreFuture ... done
[16:05:19.958] result() for MulticoreFuture ...
[16:05:19.958] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[16:05:19.963] getGlobalsAndPackages() ...
[16:05:19.963] Searching for globals...
[16:05:19.964] - globals found: [2] ‘{’, ‘ii’
[16:05:19.964] Searching for globals ... DONE
[16:05:19.964] Resolving globals: FALSE
[16:05:19.964] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.965] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.965] - globals: [1] ‘ii’
[16:05:19.965] 
[16:05:19.965] getGlobalsAndPackages() ... DONE
[16:05:19.966] Packages needed by the future expression (n = 0): <none>
[16:05:19.966] Packages needed by future strategies (n = 0): <none>
[16:05:19.967] {
[16:05:19.967]     {
[16:05:19.967]         {
[16:05:19.967]             ...future.startTime <- base::Sys.time()
[16:05:19.967]             {
[16:05:19.967]                 {
[16:05:19.967]                   {
[16:05:19.967]                     {
[16:05:19.967]                       base::local({
[16:05:19.967]                         has_future <- base::requireNamespace("future", 
[16:05:19.967]                           quietly = TRUE)
[16:05:19.967]                         if (has_future) {
[16:05:19.967]                           ns <- base::getNamespace("future")
[16:05:19.967]                           version <- ns[[".package"]][["version"]]
[16:05:19.967]                           if (is.null(version)) 
[16:05:19.967]                             version <- utils::packageVersion("future")
[16:05:19.967]                         }
[16:05:19.967]                         else {
[16:05:19.967]                           version <- NULL
[16:05:19.967]                         }
[16:05:19.967]                         if (!has_future || version < "1.8.0") {
[16:05:19.967]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.967]                             "", base::R.version$version.string), 
[16:05:19.967]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.967]                               "release", "version")], collapse = " "), 
[16:05:19.967]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.967]                             info)
[16:05:19.967]                           info <- base::paste(info, collapse = "; ")
[16:05:19.967]                           if (!has_future) {
[16:05:19.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.967]                               info)
[16:05:19.967]                           }
[16:05:19.967]                           else {
[16:05:19.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.967]                               info, version)
[16:05:19.967]                           }
[16:05:19.967]                           base::stop(msg)
[16:05:19.967]                         }
[16:05:19.967]                       })
[16:05:19.967]                     }
[16:05:19.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.967]                     base::options(mc.cores = 1L)
[16:05:19.967]                   }
[16:05:19.967]                   options(future.plan = NULL)
[16:05:19.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.967]                 }
[16:05:19.967]                 ...future.workdir <- getwd()
[16:05:19.967]             }
[16:05:19.967]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.967]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.967]         }
[16:05:19.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.967]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.967]             base::names(...future.oldOptions))
[16:05:19.967]     }
[16:05:19.967]     if (FALSE) {
[16:05:19.967]     }
[16:05:19.967]     else {
[16:05:19.967]         if (TRUE) {
[16:05:19.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.967]                 open = "w")
[16:05:19.967]         }
[16:05:19.967]         else {
[16:05:19.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.967]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.967]         }
[16:05:19.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.967]             base::sink(type = "output", split = FALSE)
[16:05:19.967]             base::close(...future.stdout)
[16:05:19.967]         }, add = TRUE)
[16:05:19.967]     }
[16:05:19.967]     ...future.frame <- base::sys.nframe()
[16:05:19.967]     ...future.conditions <- base::list()
[16:05:19.967]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.967]     if (FALSE) {
[16:05:19.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.967]     }
[16:05:19.967]     ...future.result <- base::tryCatch({
[16:05:19.967]         base::withCallingHandlers({
[16:05:19.967]             ...future.value <- base::withVisible(base::local({
[16:05:19.967]                 withCallingHandlers({
[16:05:19.967]                   {
[16:05:19.967]                     ii
[16:05:19.967]                   }
[16:05:19.967]                 }, immediateCondition = function(cond) {
[16:05:19.967]                   save_rds <- function (object, pathname, ...) 
[16:05:19.967]                   {
[16:05:19.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.967]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.967]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.967]                         fi_tmp[["mtime"]])
[16:05:19.967]                     }
[16:05:19.967]                     tryCatch({
[16:05:19.967]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.967]                     }, error = function(ex) {
[16:05:19.967]                       msg <- conditionMessage(ex)
[16:05:19.967]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.967]                         fi_tmp[["mtime"]], msg)
[16:05:19.967]                       ex$message <- msg
[16:05:19.967]                       stop(ex)
[16:05:19.967]                     })
[16:05:19.967]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.967]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.967]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.967]                       fi <- file.info(pathname)
[16:05:19.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.967]                         fi[["size"]], fi[["mtime"]])
[16:05:19.967]                       stop(msg)
[16:05:19.967]                     }
[16:05:19.967]                     invisible(pathname)
[16:05:19.967]                   }
[16:05:19.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.967]                     rootPath = tempdir()) 
[16:05:19.967]                   {
[16:05:19.967]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.967]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.967]                       tmpdir = path, fileext = ".rds")
[16:05:19.967]                     save_rds(obj, file)
[16:05:19.967]                   }
[16:05:19.967]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.967]                   {
[16:05:19.967]                     inherits <- base::inherits
[16:05:19.967]                     invokeRestart <- base::invokeRestart
[16:05:19.967]                     is.null <- base::is.null
[16:05:19.967]                     muffled <- FALSE
[16:05:19.967]                     if (inherits(cond, "message")) {
[16:05:19.967]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.967]                       if (muffled) 
[16:05:19.967]                         invokeRestart("muffleMessage")
[16:05:19.967]                     }
[16:05:19.967]                     else if (inherits(cond, "warning")) {
[16:05:19.967]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.967]                       if (muffled) 
[16:05:19.967]                         invokeRestart("muffleWarning")
[16:05:19.967]                     }
[16:05:19.967]                     else if (inherits(cond, "condition")) {
[16:05:19.967]                       if (!is.null(pattern)) {
[16:05:19.967]                         computeRestarts <- base::computeRestarts
[16:05:19.967]                         grepl <- base::grepl
[16:05:19.967]                         restarts <- computeRestarts(cond)
[16:05:19.967]                         for (restart in restarts) {
[16:05:19.967]                           name <- restart$name
[16:05:19.967]                           if (is.null(name)) 
[16:05:19.967]                             next
[16:05:19.967]                           if (!grepl(pattern, name)) 
[16:05:19.967]                             next
[16:05:19.967]                           invokeRestart(restart)
[16:05:19.967]                           muffled <- TRUE
[16:05:19.967]                           break
[16:05:19.967]                         }
[16:05:19.967]                       }
[16:05:19.967]                     }
[16:05:19.967]                     invisible(muffled)
[16:05:19.967]                   }
[16:05:19.967]                   muffleCondition(cond)
[16:05:19.967]                 })
[16:05:19.967]             }))
[16:05:19.967]             future::FutureResult(value = ...future.value$value, 
[16:05:19.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.967]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.967]                     ...future.globalenv.names))
[16:05:19.967]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.967]         }, condition = base::local({
[16:05:19.967]             c <- base::c
[16:05:19.967]             inherits <- base::inherits
[16:05:19.967]             invokeRestart <- base::invokeRestart
[16:05:19.967]             length <- base::length
[16:05:19.967]             list <- base::list
[16:05:19.967]             seq.int <- base::seq.int
[16:05:19.967]             signalCondition <- base::signalCondition
[16:05:19.967]             sys.calls <- base::sys.calls
[16:05:19.967]             `[[` <- base::`[[`
[16:05:19.967]             `+` <- base::`+`
[16:05:19.967]             `<<-` <- base::`<<-`
[16:05:19.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.967]                   3L)]
[16:05:19.967]             }
[16:05:19.967]             function(cond) {
[16:05:19.967]                 is_error <- inherits(cond, "error")
[16:05:19.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.967]                   NULL)
[16:05:19.967]                 if (is_error) {
[16:05:19.967]                   sessionInformation <- function() {
[16:05:19.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.967]                       search = base::search(), system = base::Sys.info())
[16:05:19.967]                   }
[16:05:19.967]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.967]                     cond$call), session = sessionInformation(), 
[16:05:19.967]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.967]                   signalCondition(cond)
[16:05:19.967]                 }
[16:05:19.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.967]                 "immediateCondition"))) {
[16:05:19.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.967]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.967]                   if (TRUE && !signal) {
[16:05:19.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.967]                     {
[16:05:19.967]                       inherits <- base::inherits
[16:05:19.967]                       invokeRestart <- base::invokeRestart
[16:05:19.967]                       is.null <- base::is.null
[16:05:19.967]                       muffled <- FALSE
[16:05:19.967]                       if (inherits(cond, "message")) {
[16:05:19.967]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.967]                         if (muffled) 
[16:05:19.967]                           invokeRestart("muffleMessage")
[16:05:19.967]                       }
[16:05:19.967]                       else if (inherits(cond, "warning")) {
[16:05:19.967]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.967]                         if (muffled) 
[16:05:19.967]                           invokeRestart("muffleWarning")
[16:05:19.967]                       }
[16:05:19.967]                       else if (inherits(cond, "condition")) {
[16:05:19.967]                         if (!is.null(pattern)) {
[16:05:19.967]                           computeRestarts <- base::computeRestarts
[16:05:19.967]                           grepl <- base::grepl
[16:05:19.967]                           restarts <- computeRestarts(cond)
[16:05:19.967]                           for (restart in restarts) {
[16:05:19.967]                             name <- restart$name
[16:05:19.967]                             if (is.null(name)) 
[16:05:19.967]                               next
[16:05:19.967]                             if (!grepl(pattern, name)) 
[16:05:19.967]                               next
[16:05:19.967]                             invokeRestart(restart)
[16:05:19.967]                             muffled <- TRUE
[16:05:19.967]                             break
[16:05:19.967]                           }
[16:05:19.967]                         }
[16:05:19.967]                       }
[16:05:19.967]                       invisible(muffled)
[16:05:19.967]                     }
[16:05:19.967]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.967]                   }
[16:05:19.967]                 }
[16:05:19.967]                 else {
[16:05:19.967]                   if (TRUE) {
[16:05:19.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.967]                     {
[16:05:19.967]                       inherits <- base::inherits
[16:05:19.967]                       invokeRestart <- base::invokeRestart
[16:05:19.967]                       is.null <- base::is.null
[16:05:19.967]                       muffled <- FALSE
[16:05:19.967]                       if (inherits(cond, "message")) {
[16:05:19.967]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.967]                         if (muffled) 
[16:05:19.967]                           invokeRestart("muffleMessage")
[16:05:19.967]                       }
[16:05:19.967]                       else if (inherits(cond, "warning")) {
[16:05:19.967]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.967]                         if (muffled) 
[16:05:19.967]                           invokeRestart("muffleWarning")
[16:05:19.967]                       }
[16:05:19.967]                       else if (inherits(cond, "condition")) {
[16:05:19.967]                         if (!is.null(pattern)) {
[16:05:19.967]                           computeRestarts <- base::computeRestarts
[16:05:19.967]                           grepl <- base::grepl
[16:05:19.967]                           restarts <- computeRestarts(cond)
[16:05:19.967]                           for (restart in restarts) {
[16:05:19.967]                             name <- restart$name
[16:05:19.967]                             if (is.null(name)) 
[16:05:19.967]                               next
[16:05:19.967]                             if (!grepl(pattern, name)) 
[16:05:19.967]                               next
[16:05:19.967]                             invokeRestart(restart)
[16:05:19.967]                             muffled <- TRUE
[16:05:19.967]                             break
[16:05:19.967]                           }
[16:05:19.967]                         }
[16:05:19.967]                       }
[16:05:19.967]                       invisible(muffled)
[16:05:19.967]                     }
[16:05:19.967]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.967]                   }
[16:05:19.967]                 }
[16:05:19.967]             }
[16:05:19.967]         }))
[16:05:19.967]     }, error = function(ex) {
[16:05:19.967]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.967]                 ...future.rng), started = ...future.startTime, 
[16:05:19.967]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.967]             version = "1.8"), class = "FutureResult")
[16:05:19.967]     }, finally = {
[16:05:19.967]         if (!identical(...future.workdir, getwd())) 
[16:05:19.967]             setwd(...future.workdir)
[16:05:19.967]         {
[16:05:19.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.967]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.967]             }
[16:05:19.967]             base::options(...future.oldOptions)
[16:05:19.967]             if (.Platform$OS.type == "windows") {
[16:05:19.967]                 old_names <- names(...future.oldEnvVars)
[16:05:19.967]                 envs <- base::Sys.getenv()
[16:05:19.967]                 names <- names(envs)
[16:05:19.967]                 common <- intersect(names, old_names)
[16:05:19.967]                 added <- setdiff(names, old_names)
[16:05:19.967]                 removed <- setdiff(old_names, names)
[16:05:19.967]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.967]                   envs[common]]
[16:05:19.967]                 NAMES <- toupper(changed)
[16:05:19.967]                 args <- list()
[16:05:19.967]                 for (kk in seq_along(NAMES)) {
[16:05:19.967]                   name <- changed[[kk]]
[16:05:19.967]                   NAME <- NAMES[[kk]]
[16:05:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.967]                     next
[16:05:19.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.967]                 }
[16:05:19.967]                 NAMES <- toupper(added)
[16:05:19.967]                 for (kk in seq_along(NAMES)) {
[16:05:19.967]                   name <- added[[kk]]
[16:05:19.967]                   NAME <- NAMES[[kk]]
[16:05:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.967]                     next
[16:05:19.967]                   args[[name]] <- ""
[16:05:19.967]                 }
[16:05:19.967]                 NAMES <- toupper(removed)
[16:05:19.967]                 for (kk in seq_along(NAMES)) {
[16:05:19.967]                   name <- removed[[kk]]
[16:05:19.967]                   NAME <- NAMES[[kk]]
[16:05:19.967]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.967]                     next
[16:05:19.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.967]                 }
[16:05:19.967]                 if (length(args) > 0) 
[16:05:19.967]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.967]             }
[16:05:19.967]             else {
[16:05:19.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.967]             }
[16:05:19.967]             {
[16:05:19.967]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.967]                   0L) {
[16:05:19.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.967]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.967]                   base::options(opts)
[16:05:19.967]                 }
[16:05:19.967]                 {
[16:05:19.967]                   {
[16:05:19.967]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.967]                     NULL
[16:05:19.967]                   }
[16:05:19.967]                   options(future.plan = NULL)
[16:05:19.967]                   if (is.na(NA_character_)) 
[16:05:19.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.967]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.967]                     envir = parent.frame()) 
[16:05:19.967]                   {
[16:05:19.967]                     default_workers <- missing(workers)
[16:05:19.967]                     if (is.function(workers)) 
[16:05:19.967]                       workers <- workers()
[16:05:19.967]                     workers <- structure(as.integer(workers), 
[16:05:19.967]                       class = class(workers))
[16:05:19.967]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.967]                       1L)
[16:05:19.967]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.967]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.967]                       if (default_workers) 
[16:05:19.967]                         supportsMulticore(warn = TRUE)
[16:05:19.967]                       return(sequential(..., envir = envir))
[16:05:19.967]                     }
[16:05:19.967]                     oopts <- options(mc.cores = workers)
[16:05:19.967]                     on.exit(options(oopts))
[16:05:19.967]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.967]                       envir = envir)
[16:05:19.967]                     if (!future$lazy) 
[16:05:19.967]                       future <- run(future)
[16:05:19.967]                     invisible(future)
[16:05:19.967]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.967]                 }
[16:05:19.967]             }
[16:05:19.967]         }
[16:05:19.967]     })
[16:05:19.967]     if (TRUE) {
[16:05:19.967]         base::sink(type = "output", split = FALSE)
[16:05:19.967]         if (TRUE) {
[16:05:19.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.967]         }
[16:05:19.967]         else {
[16:05:19.967]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.967]         }
[16:05:19.967]         base::close(...future.stdout)
[16:05:19.967]         ...future.stdout <- NULL
[16:05:19.967]     }
[16:05:19.967]     ...future.result$conditions <- ...future.conditions
[16:05:19.967]     ...future.result$finished <- base::Sys.time()
[16:05:19.967]     ...future.result
[16:05:19.967] }
[16:05:19.969] assign_globals() ...
[16:05:19.969] List of 1
[16:05:19.969]  $ ii: int 1
[16:05:19.969]  - attr(*, "where")=List of 1
[16:05:19.969]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.969]  - attr(*, "resolved")= logi FALSE
[16:05:19.969]  - attr(*, "total_size")= num 56
[16:05:19.972] - copied ‘ii’ to environment
[16:05:19.972] assign_globals() ... done
[16:05:19.973] requestCore(): workers = 2
[16:05:19.974] MulticoreFuture started
 - Creating multicore future #2 ...
[16:05:19.975] plan(): Setting new future strategy stack:
[16:05:19.976] List of future strategies:
[16:05:19.976] 1. sequential:
[16:05:19.976]    - args: function (..., envir = parent.frame())
[16:05:19.976]    - tweaked: FALSE
[16:05:19.976]    - call: NULL
[16:05:19.976] plan(): nbrOfWorkers() = 1
[16:05:19.978] plan(): Setting new future strategy stack:
[16:05:19.978] List of future strategies:
[16:05:19.978] 1. multicore:
[16:05:19.978]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:19.978]    - tweaked: FALSE
[16:05:19.978]    - call: plan(multicore)
[16:05:19.979] getGlobalsAndPackages() ...
[16:05:19.980] Searching for globals...
[16:05:19.981] - globals found: [2] ‘{’, ‘ii’
[16:05:19.981] Searching for globals ... DONE
[16:05:19.981] Resolving globals: FALSE
[16:05:19.982] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:19.983] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:19.983] plan(): nbrOfWorkers() = 2
[16:05:19.983] - globals: [1] ‘ii’
[16:05:19.983] 
[16:05:19.983] getGlobalsAndPackages() ... DONE
[16:05:19.984] Packages needed by the future expression (n = 0): <none>
[16:05:19.984] Packages needed by future strategies (n = 0): <none>
[16:05:19.985] {
[16:05:19.985]     {
[16:05:19.985]         {
[16:05:19.985]             ...future.startTime <- base::Sys.time()
[16:05:19.985]             {
[16:05:19.985]                 {
[16:05:19.985]                   {
[16:05:19.985]                     {
[16:05:19.985]                       base::local({
[16:05:19.985]                         has_future <- base::requireNamespace("future", 
[16:05:19.985]                           quietly = TRUE)
[16:05:19.985]                         if (has_future) {
[16:05:19.985]                           ns <- base::getNamespace("future")
[16:05:19.985]                           version <- ns[[".package"]][["version"]]
[16:05:19.985]                           if (is.null(version)) 
[16:05:19.985]                             version <- utils::packageVersion("future")
[16:05:19.985]                         }
[16:05:19.985]                         else {
[16:05:19.985]                           version <- NULL
[16:05:19.985]                         }
[16:05:19.985]                         if (!has_future || version < "1.8.0") {
[16:05:19.985]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:19.985]                             "", base::R.version$version.string), 
[16:05:19.985]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:19.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:19.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:19.985]                               "release", "version")], collapse = " "), 
[16:05:19.985]                             hostname = base::Sys.info()[["nodename"]])
[16:05:19.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:19.985]                             info)
[16:05:19.985]                           info <- base::paste(info, collapse = "; ")
[16:05:19.985]                           if (!has_future) {
[16:05:19.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:19.985]                               info)
[16:05:19.985]                           }
[16:05:19.985]                           else {
[16:05:19.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:19.985]                               info, version)
[16:05:19.985]                           }
[16:05:19.985]                           base::stop(msg)
[16:05:19.985]                         }
[16:05:19.985]                       })
[16:05:19.985]                     }
[16:05:19.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:19.985]                     base::options(mc.cores = 1L)
[16:05:19.985]                   }
[16:05:19.985]                   options(future.plan = NULL)
[16:05:19.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:19.985]                 }
[16:05:19.985]                 ...future.workdir <- getwd()
[16:05:19.985]             }
[16:05:19.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:19.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:19.985]         }
[16:05:19.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:19.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:19.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:19.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:19.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:19.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:19.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:19.985]             base::names(...future.oldOptions))
[16:05:19.985]     }
[16:05:19.985]     if (FALSE) {
[16:05:19.985]     }
[16:05:19.985]     else {
[16:05:19.985]         if (TRUE) {
[16:05:19.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:19.985]                 open = "w")
[16:05:19.985]         }
[16:05:19.985]         else {
[16:05:19.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:19.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:19.985]         }
[16:05:19.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:19.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:19.985]             base::sink(type = "output", split = FALSE)
[16:05:19.985]             base::close(...future.stdout)
[16:05:19.985]         }, add = TRUE)
[16:05:19.985]     }
[16:05:19.985]     ...future.frame <- base::sys.nframe()
[16:05:19.985]     ...future.conditions <- base::list()
[16:05:19.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:19.985]     if (FALSE) {
[16:05:19.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:19.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:19.985]     }
[16:05:19.985]     ...future.result <- base::tryCatch({
[16:05:19.985]         base::withCallingHandlers({
[16:05:19.985]             ...future.value <- base::withVisible(base::local({
[16:05:19.985]                 withCallingHandlers({
[16:05:19.985]                   {
[16:05:19.985]                     ii
[16:05:19.985]                   }
[16:05:19.985]                 }, immediateCondition = function(cond) {
[16:05:19.985]                   save_rds <- function (object, pathname, ...) 
[16:05:19.985]                   {
[16:05:19.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:19.985]                     if (file_test("-f", pathname_tmp)) {
[16:05:19.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:19.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.985]                         fi_tmp[["mtime"]])
[16:05:19.985]                     }
[16:05:19.985]                     tryCatch({
[16:05:19.985]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:19.985]                     }, error = function(ex) {
[16:05:19.985]                       msg <- conditionMessage(ex)
[16:05:19.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:19.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.985]                         fi_tmp[["mtime"]], msg)
[16:05:19.985]                       ex$message <- msg
[16:05:19.985]                       stop(ex)
[16:05:19.985]                     })
[16:05:19.985]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:19.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:19.985]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:19.985]                       fi_tmp <- file.info(pathname_tmp)
[16:05:19.985]                       fi <- file.info(pathname)
[16:05:19.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:19.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:19.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:19.985]                         fi[["size"]], fi[["mtime"]])
[16:05:19.985]                       stop(msg)
[16:05:19.985]                     }
[16:05:19.985]                     invisible(pathname)
[16:05:19.985]                   }
[16:05:19.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:19.985]                     rootPath = tempdir()) 
[16:05:19.985]                   {
[16:05:19.985]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:19.985]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:19.985]                       tmpdir = path, fileext = ".rds")
[16:05:19.985]                     save_rds(obj, file)
[16:05:19.985]                   }
[16:05:19.985]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:19.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.985]                   {
[16:05:19.985]                     inherits <- base::inherits
[16:05:19.985]                     invokeRestart <- base::invokeRestart
[16:05:19.985]                     is.null <- base::is.null
[16:05:19.985]                     muffled <- FALSE
[16:05:19.985]                     if (inherits(cond, "message")) {
[16:05:19.985]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:19.985]                       if (muffled) 
[16:05:19.985]                         invokeRestart("muffleMessage")
[16:05:19.985]                     }
[16:05:19.985]                     else if (inherits(cond, "warning")) {
[16:05:19.985]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:19.985]                       if (muffled) 
[16:05:19.985]                         invokeRestart("muffleWarning")
[16:05:19.985]                     }
[16:05:19.985]                     else if (inherits(cond, "condition")) {
[16:05:19.985]                       if (!is.null(pattern)) {
[16:05:19.985]                         computeRestarts <- base::computeRestarts
[16:05:19.985]                         grepl <- base::grepl
[16:05:19.985]                         restarts <- computeRestarts(cond)
[16:05:19.985]                         for (restart in restarts) {
[16:05:19.985]                           name <- restart$name
[16:05:19.985]                           if (is.null(name)) 
[16:05:19.985]                             next
[16:05:19.985]                           if (!grepl(pattern, name)) 
[16:05:19.985]                             next
[16:05:19.985]                           invokeRestart(restart)
[16:05:19.985]                           muffled <- TRUE
[16:05:19.985]                           break
[16:05:19.985]                         }
[16:05:19.985]                       }
[16:05:19.985]                     }
[16:05:19.985]                     invisible(muffled)
[16:05:19.985]                   }
[16:05:19.985]                   muffleCondition(cond)
[16:05:19.985]                 })
[16:05:19.985]             }))
[16:05:19.985]             future::FutureResult(value = ...future.value$value, 
[16:05:19.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.985]                   ...future.rng), globalenv = if (FALSE) 
[16:05:19.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:19.985]                     ...future.globalenv.names))
[16:05:19.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:19.985]         }, condition = base::local({
[16:05:19.985]             c <- base::c
[16:05:19.985]             inherits <- base::inherits
[16:05:19.985]             invokeRestart <- base::invokeRestart
[16:05:19.985]             length <- base::length
[16:05:19.985]             list <- base::list
[16:05:19.985]             seq.int <- base::seq.int
[16:05:19.985]             signalCondition <- base::signalCondition
[16:05:19.985]             sys.calls <- base::sys.calls
[16:05:19.985]             `[[` <- base::`[[`
[16:05:19.985]             `+` <- base::`+`
[16:05:19.985]             `<<-` <- base::`<<-`
[16:05:19.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:19.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:19.985]                   3L)]
[16:05:19.985]             }
[16:05:19.985]             function(cond) {
[16:05:19.985]                 is_error <- inherits(cond, "error")
[16:05:19.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:19.985]                   NULL)
[16:05:19.985]                 if (is_error) {
[16:05:19.985]                   sessionInformation <- function() {
[16:05:19.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:19.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:19.985]                       search = base::search(), system = base::Sys.info())
[16:05:19.985]                   }
[16:05:19.985]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:19.985]                     cond$call), session = sessionInformation(), 
[16:05:19.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:19.985]                   signalCondition(cond)
[16:05:19.985]                 }
[16:05:19.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:19.985]                 "immediateCondition"))) {
[16:05:19.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:19.985]                   ...future.conditions[[length(...future.conditions) + 
[16:05:19.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:19.985]                   if (TRUE && !signal) {
[16:05:19.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.985]                     {
[16:05:19.985]                       inherits <- base::inherits
[16:05:19.985]                       invokeRestart <- base::invokeRestart
[16:05:19.985]                       is.null <- base::is.null
[16:05:19.985]                       muffled <- FALSE
[16:05:19.985]                       if (inherits(cond, "message")) {
[16:05:19.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.985]                         if (muffled) 
[16:05:19.985]                           invokeRestart("muffleMessage")
[16:05:19.985]                       }
[16:05:19.985]                       else if (inherits(cond, "warning")) {
[16:05:19.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.985]                         if (muffled) 
[16:05:19.985]                           invokeRestart("muffleWarning")
[16:05:19.985]                       }
[16:05:19.985]                       else if (inherits(cond, "condition")) {
[16:05:19.985]                         if (!is.null(pattern)) {
[16:05:19.985]                           computeRestarts <- base::computeRestarts
[16:05:19.985]                           grepl <- base::grepl
[16:05:19.985]                           restarts <- computeRestarts(cond)
[16:05:19.985]                           for (restart in restarts) {
[16:05:19.985]                             name <- restart$name
[16:05:19.985]                             if (is.null(name)) 
[16:05:19.985]                               next
[16:05:19.985]                             if (!grepl(pattern, name)) 
[16:05:19.985]                               next
[16:05:19.985]                             invokeRestart(restart)
[16:05:19.985]                             muffled <- TRUE
[16:05:19.985]                             break
[16:05:19.985]                           }
[16:05:19.985]                         }
[16:05:19.985]                       }
[16:05:19.985]                       invisible(muffled)
[16:05:19.985]                     }
[16:05:19.985]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.985]                   }
[16:05:19.985]                 }
[16:05:19.985]                 else {
[16:05:19.985]                   if (TRUE) {
[16:05:19.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:19.985]                     {
[16:05:19.985]                       inherits <- base::inherits
[16:05:19.985]                       invokeRestart <- base::invokeRestart
[16:05:19.985]                       is.null <- base::is.null
[16:05:19.985]                       muffled <- FALSE
[16:05:19.985]                       if (inherits(cond, "message")) {
[16:05:19.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:19.985]                         if (muffled) 
[16:05:19.985]                           invokeRestart("muffleMessage")
[16:05:19.985]                       }
[16:05:19.985]                       else if (inherits(cond, "warning")) {
[16:05:19.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:19.985]                         if (muffled) 
[16:05:19.985]                           invokeRestart("muffleWarning")
[16:05:19.985]                       }
[16:05:19.985]                       else if (inherits(cond, "condition")) {
[16:05:19.985]                         if (!is.null(pattern)) {
[16:05:19.985]                           computeRestarts <- base::computeRestarts
[16:05:19.985]                           grepl <- base::grepl
[16:05:19.985]                           restarts <- computeRestarts(cond)
[16:05:19.985]                           for (restart in restarts) {
[16:05:19.985]                             name <- restart$name
[16:05:19.985]                             if (is.null(name)) 
[16:05:19.985]                               next
[16:05:19.985]                             if (!grepl(pattern, name)) 
[16:05:19.985]                               next
[16:05:19.985]                             invokeRestart(restart)
[16:05:19.985]                             muffled <- TRUE
[16:05:19.985]                             break
[16:05:19.985]                           }
[16:05:19.985]                         }
[16:05:19.985]                       }
[16:05:19.985]                       invisible(muffled)
[16:05:19.985]                     }
[16:05:19.985]                     muffleCondition(cond, pattern = "^muffle")
[16:05:19.985]                   }
[16:05:19.985]                 }
[16:05:19.985]             }
[16:05:19.985]         }))
[16:05:19.985]     }, error = function(ex) {
[16:05:19.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:19.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:19.985]                 ...future.rng), started = ...future.startTime, 
[16:05:19.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:19.985]             version = "1.8"), class = "FutureResult")
[16:05:19.985]     }, finally = {
[16:05:19.985]         if (!identical(...future.workdir, getwd())) 
[16:05:19.985]             setwd(...future.workdir)
[16:05:19.985]         {
[16:05:19.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:19.985]                 ...future.oldOptions$nwarnings <- NULL
[16:05:19.985]             }
[16:05:19.985]             base::options(...future.oldOptions)
[16:05:19.985]             if (.Platform$OS.type == "windows") {
[16:05:19.985]                 old_names <- names(...future.oldEnvVars)
[16:05:19.985]                 envs <- base::Sys.getenv()
[16:05:19.985]                 names <- names(envs)
[16:05:19.985]                 common <- intersect(names, old_names)
[16:05:19.985]                 added <- setdiff(names, old_names)
[16:05:19.985]                 removed <- setdiff(old_names, names)
[16:05:19.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:19.985]                   envs[common]]
[16:05:19.985]                 NAMES <- toupper(changed)
[16:05:19.985]                 args <- list()
[16:05:19.985]                 for (kk in seq_along(NAMES)) {
[16:05:19.985]                   name <- changed[[kk]]
[16:05:19.985]                   NAME <- NAMES[[kk]]
[16:05:19.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.985]                     next
[16:05:19.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.985]                 }
[16:05:19.985]                 NAMES <- toupper(added)
[16:05:19.985]                 for (kk in seq_along(NAMES)) {
[16:05:19.985]                   name <- added[[kk]]
[16:05:19.985]                   NAME <- NAMES[[kk]]
[16:05:19.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.985]                     next
[16:05:19.985]                   args[[name]] <- ""
[16:05:19.985]                 }
[16:05:19.985]                 NAMES <- toupper(removed)
[16:05:19.985]                 for (kk in seq_along(NAMES)) {
[16:05:19.985]                   name <- removed[[kk]]
[16:05:19.985]                   NAME <- NAMES[[kk]]
[16:05:19.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:19.985]                     next
[16:05:19.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:19.985]                 }
[16:05:19.985]                 if (length(args) > 0) 
[16:05:19.985]                   base::do.call(base::Sys.setenv, args = args)
[16:05:19.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:19.985]             }
[16:05:19.985]             else {
[16:05:19.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:19.985]             }
[16:05:19.985]             {
[16:05:19.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:19.985]                   0L) {
[16:05:19.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:19.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:19.985]                   base::options(opts)
[16:05:19.985]                 }
[16:05:19.985]                 {
[16:05:19.985]                   {
[16:05:19.985]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:19.985]                     NULL
[16:05:19.985]                   }
[16:05:19.985]                   options(future.plan = NULL)
[16:05:19.985]                   if (is.na(NA_character_)) 
[16:05:19.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:19.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:19.985]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:19.985]                     envir = parent.frame()) 
[16:05:19.985]                   {
[16:05:19.985]                     default_workers <- missing(workers)
[16:05:19.985]                     if (is.function(workers)) 
[16:05:19.985]                       workers <- workers()
[16:05:19.985]                     workers <- structure(as.integer(workers), 
[16:05:19.985]                       class = class(workers))
[16:05:19.985]                     stop_if_not(is.finite(workers), workers >= 
[16:05:19.985]                       1L)
[16:05:19.985]                     if ((workers == 1L && !inherits(workers, 
[16:05:19.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:19.985]                       if (default_workers) 
[16:05:19.985]                         supportsMulticore(warn = TRUE)
[16:05:19.985]                       return(sequential(..., envir = envir))
[16:05:19.985]                     }
[16:05:19.985]                     oopts <- options(mc.cores = workers)
[16:05:19.985]                     on.exit(options(oopts))
[16:05:19.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:19.985]                       envir = envir)
[16:05:19.985]                     if (!future$lazy) 
[16:05:19.985]                       future <- run(future)
[16:05:19.985]                     invisible(future)
[16:05:19.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:19.985]                 }
[16:05:19.985]             }
[16:05:19.985]         }
[16:05:19.985]     })
[16:05:19.985]     if (TRUE) {
[16:05:19.985]         base::sink(type = "output", split = FALSE)
[16:05:19.985]         if (TRUE) {
[16:05:19.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:19.985]         }
[16:05:19.985]         else {
[16:05:19.985]             ...future.result["stdout"] <- base::list(NULL)
[16:05:19.985]         }
[16:05:19.985]         base::close(...future.stdout)
[16:05:19.985]         ...future.stdout <- NULL
[16:05:19.985]     }
[16:05:19.985]     ...future.result$conditions <- ...future.conditions
[16:05:19.985]     ...future.result$finished <- base::Sys.time()
[16:05:19.985]     ...future.result
[16:05:19.985] }
[16:05:19.989] assign_globals() ...
[16:05:19.989] List of 1
[16:05:19.989]  $ ii: int 2
[16:05:19.989]  - attr(*, "where")=List of 1
[16:05:19.989]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:19.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:19.989]  - attr(*, "resolved")= logi FALSE
[16:05:19.989]  - attr(*, "total_size")= num 56
[16:05:19.993] - copied ‘ii’ to environment
[16:05:19.993] assign_globals() ... done
[16:05:19.993] requestCore(): workers = 2
[16:05:19.996] MulticoreFuture started
 - Creating multicore future #3 ...
[16:05:19.997] plan(): Setting new future strategy stack:
[16:05:19.997] List of future strategies:
[16:05:19.997] 1. sequential:
[16:05:19.997]    - args: function (..., envir = parent.frame())
[16:05:19.997]    - tweaked: FALSE
[16:05:19.997]    - call: NULL
[16:05:19.998] plan(): nbrOfWorkers() = 1
[16:05:20.000] plan(): Setting new future strategy stack:
[16:05:20.000] List of future strategies:
[16:05:20.000] 1. multicore:
[16:05:20.000]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.000]    - tweaked: FALSE
[16:05:20.000]    - call: plan(multicore)
[16:05:20.003] getGlobalsAndPackages() ...
[16:05:20.003] Searching for globals...
[16:05:20.009] - globals found: [2] ‘{’, ‘ii’
[16:05:20.010] Searching for globals ... DONE
[16:05:20.010] Resolving globals: FALSE
[16:05:20.011] plan(): nbrOfWorkers() = 2
[16:05:20.011] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:20.012] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:20.012] - globals: [1] ‘ii’
[16:05:20.013] 
[16:05:20.013] getGlobalsAndPackages() ... DONE
[16:05:20.014] Packages needed by the future expression (n = 0): <none>
[16:05:20.014] Packages needed by future strategies (n = 0): <none>
[16:05:20.015] {
[16:05:20.015]     {
[16:05:20.015]         {
[16:05:20.015]             ...future.startTime <- base::Sys.time()
[16:05:20.015]             {
[16:05:20.015]                 {
[16:05:20.015]                   {
[16:05:20.015]                     {
[16:05:20.015]                       base::local({
[16:05:20.015]                         has_future <- base::requireNamespace("future", 
[16:05:20.015]                           quietly = TRUE)
[16:05:20.015]                         if (has_future) {
[16:05:20.015]                           ns <- base::getNamespace("future")
[16:05:20.015]                           version <- ns[[".package"]][["version"]]
[16:05:20.015]                           if (is.null(version)) 
[16:05:20.015]                             version <- utils::packageVersion("future")
[16:05:20.015]                         }
[16:05:20.015]                         else {
[16:05:20.015]                           version <- NULL
[16:05:20.015]                         }
[16:05:20.015]                         if (!has_future || version < "1.8.0") {
[16:05:20.015]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:20.015]                             "", base::R.version$version.string), 
[16:05:20.015]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:20.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:20.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:20.015]                               "release", "version")], collapse = " "), 
[16:05:20.015]                             hostname = base::Sys.info()[["nodename"]])
[16:05:20.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:20.015]                             info)
[16:05:20.015]                           info <- base::paste(info, collapse = "; ")
[16:05:20.015]                           if (!has_future) {
[16:05:20.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:20.015]                               info)
[16:05:20.015]                           }
[16:05:20.015]                           else {
[16:05:20.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:20.015]                               info, version)
[16:05:20.015]                           }
[16:05:20.015]                           base::stop(msg)
[16:05:20.015]                         }
[16:05:20.015]                       })
[16:05:20.015]                     }
[16:05:20.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:20.015]                     base::options(mc.cores = 1L)
[16:05:20.015]                   }
[16:05:20.015]                   options(future.plan = NULL)
[16:05:20.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:20.015]                 }
[16:05:20.015]                 ...future.workdir <- getwd()
[16:05:20.015]             }
[16:05:20.015]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:20.015]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:20.015]         }
[16:05:20.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:20.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:20.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:20.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:20.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:20.015]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:20.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:20.015]             base::names(...future.oldOptions))
[16:05:20.015]     }
[16:05:20.015]     if (FALSE) {
[16:05:20.015]     }
[16:05:20.015]     else {
[16:05:20.015]         if (TRUE) {
[16:05:20.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:20.015]                 open = "w")
[16:05:20.015]         }
[16:05:20.015]         else {
[16:05:20.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:20.015]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:20.015]         }
[16:05:20.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:20.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:20.015]             base::sink(type = "output", split = FALSE)
[16:05:20.015]             base::close(...future.stdout)
[16:05:20.015]         }, add = TRUE)
[16:05:20.015]     }
[16:05:20.015]     ...future.frame <- base::sys.nframe()
[16:05:20.015]     ...future.conditions <- base::list()
[16:05:20.015]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:20.015]     if (FALSE) {
[16:05:20.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:20.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:20.015]     }
[16:05:20.015]     ...future.result <- base::tryCatch({
[16:05:20.015]         base::withCallingHandlers({
[16:05:20.015]             ...future.value <- base::withVisible(base::local({
[16:05:20.015]                 withCallingHandlers({
[16:05:20.015]                   {
[16:05:20.015]                     ii
[16:05:20.015]                   }
[16:05:20.015]                 }, immediateCondition = function(cond) {
[16:05:20.015]                   save_rds <- function (object, pathname, ...) 
[16:05:20.015]                   {
[16:05:20.015]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:20.015]                     if (file_test("-f", pathname_tmp)) {
[16:05:20.015]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.015]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:20.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.015]                         fi_tmp[["mtime"]])
[16:05:20.015]                     }
[16:05:20.015]                     tryCatch({
[16:05:20.015]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:20.015]                     }, error = function(ex) {
[16:05:20.015]                       msg <- conditionMessage(ex)
[16:05:20.015]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.015]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:20.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.015]                         fi_tmp[["mtime"]], msg)
[16:05:20.015]                       ex$message <- msg
[16:05:20.015]                       stop(ex)
[16:05:20.015]                     })
[16:05:20.015]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:20.015]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:20.015]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:20.015]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.015]                       fi <- file.info(pathname)
[16:05:20.015]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:20.015]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.015]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:20.015]                         fi[["size"]], fi[["mtime"]])
[16:05:20.015]                       stop(msg)
[16:05:20.015]                     }
[16:05:20.015]                     invisible(pathname)
[16:05:20.015]                   }
[16:05:20.015]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:20.015]                     rootPath = tempdir()) 
[16:05:20.015]                   {
[16:05:20.015]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:20.015]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:20.015]                       tmpdir = path, fileext = ".rds")
[16:05:20.015]                     save_rds(obj, file)
[16:05:20.015]                   }
[16:05:20.015]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:20.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.015]                   {
[16:05:20.015]                     inherits <- base::inherits
[16:05:20.015]                     invokeRestart <- base::invokeRestart
[16:05:20.015]                     is.null <- base::is.null
[16:05:20.015]                     muffled <- FALSE
[16:05:20.015]                     if (inherits(cond, "message")) {
[16:05:20.015]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:20.015]                       if (muffled) 
[16:05:20.015]                         invokeRestart("muffleMessage")
[16:05:20.015]                     }
[16:05:20.015]                     else if (inherits(cond, "warning")) {
[16:05:20.015]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:20.015]                       if (muffled) 
[16:05:20.015]                         invokeRestart("muffleWarning")
[16:05:20.015]                     }
[16:05:20.015]                     else if (inherits(cond, "condition")) {
[16:05:20.015]                       if (!is.null(pattern)) {
[16:05:20.015]                         computeRestarts <- base::computeRestarts
[16:05:20.015]                         grepl <- base::grepl
[16:05:20.015]                         restarts <- computeRestarts(cond)
[16:05:20.015]                         for (restart in restarts) {
[16:05:20.015]                           name <- restart$name
[16:05:20.015]                           if (is.null(name)) 
[16:05:20.015]                             next
[16:05:20.015]                           if (!grepl(pattern, name)) 
[16:05:20.015]                             next
[16:05:20.015]                           invokeRestart(restart)
[16:05:20.015]                           muffled <- TRUE
[16:05:20.015]                           break
[16:05:20.015]                         }
[16:05:20.015]                       }
[16:05:20.015]                     }
[16:05:20.015]                     invisible(muffled)
[16:05:20.015]                   }
[16:05:20.015]                   muffleCondition(cond)
[16:05:20.015]                 })
[16:05:20.015]             }))
[16:05:20.015]             future::FutureResult(value = ...future.value$value, 
[16:05:20.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.015]                   ...future.rng), globalenv = if (FALSE) 
[16:05:20.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:20.015]                     ...future.globalenv.names))
[16:05:20.015]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:20.015]         }, condition = base::local({
[16:05:20.015]             c <- base::c
[16:05:20.015]             inherits <- base::inherits
[16:05:20.015]             invokeRestart <- base::invokeRestart
[16:05:20.015]             length <- base::length
[16:05:20.015]             list <- base::list
[16:05:20.015]             seq.int <- base::seq.int
[16:05:20.015]             signalCondition <- base::signalCondition
[16:05:20.015]             sys.calls <- base::sys.calls
[16:05:20.015]             `[[` <- base::`[[`
[16:05:20.015]             `+` <- base::`+`
[16:05:20.015]             `<<-` <- base::`<<-`
[16:05:20.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:20.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:20.015]                   3L)]
[16:05:20.015]             }
[16:05:20.015]             function(cond) {
[16:05:20.015]                 is_error <- inherits(cond, "error")
[16:05:20.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:20.015]                   NULL)
[16:05:20.015]                 if (is_error) {
[16:05:20.015]                   sessionInformation <- function() {
[16:05:20.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:20.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:20.015]                       search = base::search(), system = base::Sys.info())
[16:05:20.015]                   }
[16:05:20.015]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:20.015]                     cond$call), session = sessionInformation(), 
[16:05:20.015]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:20.015]                   signalCondition(cond)
[16:05:20.015]                 }
[16:05:20.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:20.015]                 "immediateCondition"))) {
[16:05:20.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:20.015]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:20.015]                   if (TRUE && !signal) {
[16:05:20.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.015]                     {
[16:05:20.015]                       inherits <- base::inherits
[16:05:20.015]                       invokeRestart <- base::invokeRestart
[16:05:20.015]                       is.null <- base::is.null
[16:05:20.015]                       muffled <- FALSE
[16:05:20.015]                       if (inherits(cond, "message")) {
[16:05:20.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.015]                         if (muffled) 
[16:05:20.015]                           invokeRestart("muffleMessage")
[16:05:20.015]                       }
[16:05:20.015]                       else if (inherits(cond, "warning")) {
[16:05:20.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.015]                         if (muffled) 
[16:05:20.015]                           invokeRestart("muffleWarning")
[16:05:20.015]                       }
[16:05:20.015]                       else if (inherits(cond, "condition")) {
[16:05:20.015]                         if (!is.null(pattern)) {
[16:05:20.015]                           computeRestarts <- base::computeRestarts
[16:05:20.015]                           grepl <- base::grepl
[16:05:20.015]                           restarts <- computeRestarts(cond)
[16:05:20.015]                           for (restart in restarts) {
[16:05:20.015]                             name <- restart$name
[16:05:20.015]                             if (is.null(name)) 
[16:05:20.015]                               next
[16:05:20.015]                             if (!grepl(pattern, name)) 
[16:05:20.015]                               next
[16:05:20.015]                             invokeRestart(restart)
[16:05:20.015]                             muffled <- TRUE
[16:05:20.015]                             break
[16:05:20.015]                           }
[16:05:20.015]                         }
[16:05:20.015]                       }
[16:05:20.015]                       invisible(muffled)
[16:05:20.015]                     }
[16:05:20.015]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.015]                   }
[16:05:20.015]                 }
[16:05:20.015]                 else {
[16:05:20.015]                   if (TRUE) {
[16:05:20.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.015]                     {
[16:05:20.015]                       inherits <- base::inherits
[16:05:20.015]                       invokeRestart <- base::invokeRestart
[16:05:20.015]                       is.null <- base::is.null
[16:05:20.015]                       muffled <- FALSE
[16:05:20.015]                       if (inherits(cond, "message")) {
[16:05:20.015]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.015]                         if (muffled) 
[16:05:20.015]                           invokeRestart("muffleMessage")
[16:05:20.015]                       }
[16:05:20.015]                       else if (inherits(cond, "warning")) {
[16:05:20.015]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.015]                         if (muffled) 
[16:05:20.015]                           invokeRestart("muffleWarning")
[16:05:20.015]                       }
[16:05:20.015]                       else if (inherits(cond, "condition")) {
[16:05:20.015]                         if (!is.null(pattern)) {
[16:05:20.015]                           computeRestarts <- base::computeRestarts
[16:05:20.015]                           grepl <- base::grepl
[16:05:20.015]                           restarts <- computeRestarts(cond)
[16:05:20.015]                           for (restart in restarts) {
[16:05:20.015]                             name <- restart$name
[16:05:20.015]                             if (is.null(name)) 
[16:05:20.015]                               next
[16:05:20.015]                             if (!grepl(pattern, name)) 
[16:05:20.015]                               next
[16:05:20.015]                             invokeRestart(restart)
[16:05:20.015]                             muffled <- TRUE
[16:05:20.015]                             break
[16:05:20.015]                           }
[16:05:20.015]                         }
[16:05:20.015]                       }
[16:05:20.015]                       invisible(muffled)
[16:05:20.015]                     }
[16:05:20.015]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.015]                   }
[16:05:20.015]                 }
[16:05:20.015]             }
[16:05:20.015]         }))
[16:05:20.015]     }, error = function(ex) {
[16:05:20.015]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:20.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.015]                 ...future.rng), started = ...future.startTime, 
[16:05:20.015]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:20.015]             version = "1.8"), class = "FutureResult")
[16:05:20.015]     }, finally = {
[16:05:20.015]         if (!identical(...future.workdir, getwd())) 
[16:05:20.015]             setwd(...future.workdir)
[16:05:20.015]         {
[16:05:20.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:20.015]                 ...future.oldOptions$nwarnings <- NULL
[16:05:20.015]             }
[16:05:20.015]             base::options(...future.oldOptions)
[16:05:20.015]             if (.Platform$OS.type == "windows") {
[16:05:20.015]                 old_names <- names(...future.oldEnvVars)
[16:05:20.015]                 envs <- base::Sys.getenv()
[16:05:20.015]                 names <- names(envs)
[16:05:20.015]                 common <- intersect(names, old_names)
[16:05:20.015]                 added <- setdiff(names, old_names)
[16:05:20.015]                 removed <- setdiff(old_names, names)
[16:05:20.015]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:20.015]                   envs[common]]
[16:05:20.015]                 NAMES <- toupper(changed)
[16:05:20.015]                 args <- list()
[16:05:20.015]                 for (kk in seq_along(NAMES)) {
[16:05:20.015]                   name <- changed[[kk]]
[16:05:20.015]                   NAME <- NAMES[[kk]]
[16:05:20.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.015]                     next
[16:05:20.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.015]                 }
[16:05:20.015]                 NAMES <- toupper(added)
[16:05:20.015]                 for (kk in seq_along(NAMES)) {
[16:05:20.015]                   name <- added[[kk]]
[16:05:20.015]                   NAME <- NAMES[[kk]]
[16:05:20.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.015]                     next
[16:05:20.015]                   args[[name]] <- ""
[16:05:20.015]                 }
[16:05:20.015]                 NAMES <- toupper(removed)
[16:05:20.015]                 for (kk in seq_along(NAMES)) {
[16:05:20.015]                   name <- removed[[kk]]
[16:05:20.015]                   NAME <- NAMES[[kk]]
[16:05:20.015]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.015]                     next
[16:05:20.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.015]                 }
[16:05:20.015]                 if (length(args) > 0) 
[16:05:20.015]                   base::do.call(base::Sys.setenv, args = args)
[16:05:20.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:20.015]             }
[16:05:20.015]             else {
[16:05:20.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:20.015]             }
[16:05:20.015]             {
[16:05:20.015]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:20.015]                   0L) {
[16:05:20.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:20.015]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:20.015]                   base::options(opts)
[16:05:20.015]                 }
[16:05:20.015]                 {
[16:05:20.015]                   {
[16:05:20.015]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:20.015]                     NULL
[16:05:20.015]                   }
[16:05:20.015]                   options(future.plan = NULL)
[16:05:20.015]                   if (is.na(NA_character_)) 
[16:05:20.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:20.015]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:20.015]                     envir = parent.frame()) 
[16:05:20.015]                   {
[16:05:20.015]                     default_workers <- missing(workers)
[16:05:20.015]                     if (is.function(workers)) 
[16:05:20.015]                       workers <- workers()
[16:05:20.015]                     workers <- structure(as.integer(workers), 
[16:05:20.015]                       class = class(workers))
[16:05:20.015]                     stop_if_not(is.finite(workers), workers >= 
[16:05:20.015]                       1L)
[16:05:20.015]                     if ((workers == 1L && !inherits(workers, 
[16:05:20.015]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:20.015]                       if (default_workers) 
[16:05:20.015]                         supportsMulticore(warn = TRUE)
[16:05:20.015]                       return(sequential(..., envir = envir))
[16:05:20.015]                     }
[16:05:20.015]                     oopts <- options(mc.cores = workers)
[16:05:20.015]                     on.exit(options(oopts))
[16:05:20.015]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:20.015]                       envir = envir)
[16:05:20.015]                     if (!future$lazy) 
[16:05:20.015]                       future <- run(future)
[16:05:20.015]                     invisible(future)
[16:05:20.015]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:20.015]                 }
[16:05:20.015]             }
[16:05:20.015]         }
[16:05:20.015]     })
[16:05:20.015]     if (TRUE) {
[16:05:20.015]         base::sink(type = "output", split = FALSE)
[16:05:20.015]         if (TRUE) {
[16:05:20.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:20.015]         }
[16:05:20.015]         else {
[16:05:20.015]             ...future.result["stdout"] <- base::list(NULL)
[16:05:20.015]         }
[16:05:20.015]         base::close(...future.stdout)
[16:05:20.015]         ...future.stdout <- NULL
[16:05:20.015]     }
[16:05:20.015]     ...future.result$conditions <- ...future.conditions
[16:05:20.015]     ...future.result$finished <- base::Sys.time()
[16:05:20.015]     ...future.result
[16:05:20.015] }
[16:05:20.018] assign_globals() ...
[16:05:20.018] List of 1
[16:05:20.018]  $ ii: int 3
[16:05:20.018]  - attr(*, "where")=List of 1
[16:05:20.018]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:20.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:20.018]  - attr(*, "resolved")= logi FALSE
[16:05:20.018]  - attr(*, "total_size")= num 56
[16:05:20.021] - copied ‘ii’ to environment
[16:05:20.021] assign_globals() ... done
[16:05:20.022] requestCore(): workers = 2
[16:05:20.022] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:20.033] result() for MulticoreFuture ...
[16:05:20.034] result() for MulticoreFuture ...
[16:05:20.034] result() for MulticoreFuture ... done
[16:05:20.034] result() for MulticoreFuture ... done
[16:05:20.034] result() for MulticoreFuture ...
[16:05:20.034] result() for MulticoreFuture ... done
[16:05:20.037] MulticoreFuture started
 - Creating multicore future #4 ...
[16:05:20.038] plan(): Setting new future strategy stack:
[16:05:20.038] List of future strategies:
[16:05:20.038] 1. sequential:
[16:05:20.038]    - args: function (..., envir = parent.frame())
[16:05:20.038]    - tweaked: FALSE
[16:05:20.038]    - call: NULL
[16:05:20.039] plan(): nbrOfWorkers() = 1
[16:05:20.041] plan(): Setting new future strategy stack:
[16:05:20.041] List of future strategies:
[16:05:20.041] 1. multicore:
[16:05:20.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.041]    - tweaked: FALSE
[16:05:20.041]    - call: plan(multicore)
[16:05:20.043] getGlobalsAndPackages() ...
[16:05:20.044] Searching for globals...
[16:05:20.045] - globals found: [2] ‘{’, ‘ii’
[16:05:20.046] Searching for globals ... DONE
[16:05:20.046] Resolving globals: FALSE
[16:05:20.047] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:20.047] plan(): nbrOfWorkers() = 2
[16:05:20.048] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[16:05:20.048] - globals: [1] ‘ii’
[16:05:20.048] 
[16:05:20.048] getGlobalsAndPackages() ... DONE
[16:05:20.049] Packages needed by the future expression (n = 0): <none>
[16:05:20.049] Packages needed by future strategies (n = 0): <none>
[16:05:20.050] {
[16:05:20.050]     {
[16:05:20.050]         {
[16:05:20.050]             ...future.startTime <- base::Sys.time()
[16:05:20.050]             {
[16:05:20.050]                 {
[16:05:20.050]                   {
[16:05:20.050]                     {
[16:05:20.050]                       base::local({
[16:05:20.050]                         has_future <- base::requireNamespace("future", 
[16:05:20.050]                           quietly = TRUE)
[16:05:20.050]                         if (has_future) {
[16:05:20.050]                           ns <- base::getNamespace("future")
[16:05:20.050]                           version <- ns[[".package"]][["version"]]
[16:05:20.050]                           if (is.null(version)) 
[16:05:20.050]                             version <- utils::packageVersion("future")
[16:05:20.050]                         }
[16:05:20.050]                         else {
[16:05:20.050]                           version <- NULL
[16:05:20.050]                         }
[16:05:20.050]                         if (!has_future || version < "1.8.0") {
[16:05:20.050]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:20.050]                             "", base::R.version$version.string), 
[16:05:20.050]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:20.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:20.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:20.050]                               "release", "version")], collapse = " "), 
[16:05:20.050]                             hostname = base::Sys.info()[["nodename"]])
[16:05:20.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:20.050]                             info)
[16:05:20.050]                           info <- base::paste(info, collapse = "; ")
[16:05:20.050]                           if (!has_future) {
[16:05:20.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:20.050]                               info)
[16:05:20.050]                           }
[16:05:20.050]                           else {
[16:05:20.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:20.050]                               info, version)
[16:05:20.050]                           }
[16:05:20.050]                           base::stop(msg)
[16:05:20.050]                         }
[16:05:20.050]                       })
[16:05:20.050]                     }
[16:05:20.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:20.050]                     base::options(mc.cores = 1L)
[16:05:20.050]                   }
[16:05:20.050]                   options(future.plan = NULL)
[16:05:20.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:20.050]                 }
[16:05:20.050]                 ...future.workdir <- getwd()
[16:05:20.050]             }
[16:05:20.050]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:20.050]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:20.050]         }
[16:05:20.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:20.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:20.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:20.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:20.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:20.050]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:20.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:20.050]             base::names(...future.oldOptions))
[16:05:20.050]     }
[16:05:20.050]     if (FALSE) {
[16:05:20.050]     }
[16:05:20.050]     else {
[16:05:20.050]         if (TRUE) {
[16:05:20.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:20.050]                 open = "w")
[16:05:20.050]         }
[16:05:20.050]         else {
[16:05:20.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:20.050]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:20.050]         }
[16:05:20.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:20.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:20.050]             base::sink(type = "output", split = FALSE)
[16:05:20.050]             base::close(...future.stdout)
[16:05:20.050]         }, add = TRUE)
[16:05:20.050]     }
[16:05:20.050]     ...future.frame <- base::sys.nframe()
[16:05:20.050]     ...future.conditions <- base::list()
[16:05:20.050]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:20.050]     if (FALSE) {
[16:05:20.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:20.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:20.050]     }
[16:05:20.050]     ...future.result <- base::tryCatch({
[16:05:20.050]         base::withCallingHandlers({
[16:05:20.050]             ...future.value <- base::withVisible(base::local({
[16:05:20.050]                 withCallingHandlers({
[16:05:20.050]                   {
[16:05:20.050]                     ii
[16:05:20.050]                   }
[16:05:20.050]                 }, immediateCondition = function(cond) {
[16:05:20.050]                   save_rds <- function (object, pathname, ...) 
[16:05:20.050]                   {
[16:05:20.050]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:20.050]                     if (file_test("-f", pathname_tmp)) {
[16:05:20.050]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.050]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:20.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.050]                         fi_tmp[["mtime"]])
[16:05:20.050]                     }
[16:05:20.050]                     tryCatch({
[16:05:20.050]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:20.050]                     }, error = function(ex) {
[16:05:20.050]                       msg <- conditionMessage(ex)
[16:05:20.050]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.050]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:20.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.050]                         fi_tmp[["mtime"]], msg)
[16:05:20.050]                       ex$message <- msg
[16:05:20.050]                       stop(ex)
[16:05:20.050]                     })
[16:05:20.050]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:20.050]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:20.050]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:20.050]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.050]                       fi <- file.info(pathname)
[16:05:20.050]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:20.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.050]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:20.050]                         fi[["size"]], fi[["mtime"]])
[16:05:20.050]                       stop(msg)
[16:05:20.050]                     }
[16:05:20.050]                     invisible(pathname)
[16:05:20.050]                   }
[16:05:20.050]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:20.050]                     rootPath = tempdir()) 
[16:05:20.050]                   {
[16:05:20.050]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:20.050]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:20.050]                       tmpdir = path, fileext = ".rds")
[16:05:20.050]                     save_rds(obj, file)
[16:05:20.050]                   }
[16:05:20.050]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:20.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.050]                   {
[16:05:20.050]                     inherits <- base::inherits
[16:05:20.050]                     invokeRestart <- base::invokeRestart
[16:05:20.050]                     is.null <- base::is.null
[16:05:20.050]                     muffled <- FALSE
[16:05:20.050]                     if (inherits(cond, "message")) {
[16:05:20.050]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:20.050]                       if (muffled) 
[16:05:20.050]                         invokeRestart("muffleMessage")
[16:05:20.050]                     }
[16:05:20.050]                     else if (inherits(cond, "warning")) {
[16:05:20.050]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:20.050]                       if (muffled) 
[16:05:20.050]                         invokeRestart("muffleWarning")
[16:05:20.050]                     }
[16:05:20.050]                     else if (inherits(cond, "condition")) {
[16:05:20.050]                       if (!is.null(pattern)) {
[16:05:20.050]                         computeRestarts <- base::computeRestarts
[16:05:20.050]                         grepl <- base::grepl
[16:05:20.050]                         restarts <- computeRestarts(cond)
[16:05:20.050]                         for (restart in restarts) {
[16:05:20.050]                           name <- restart$name
[16:05:20.050]                           if (is.null(name)) 
[16:05:20.050]                             next
[16:05:20.050]                           if (!grepl(pattern, name)) 
[16:05:20.050]                             next
[16:05:20.050]                           invokeRestart(restart)
[16:05:20.050]                           muffled <- TRUE
[16:05:20.050]                           break
[16:05:20.050]                         }
[16:05:20.050]                       }
[16:05:20.050]                     }
[16:05:20.050]                     invisible(muffled)
[16:05:20.050]                   }
[16:05:20.050]                   muffleCondition(cond)
[16:05:20.050]                 })
[16:05:20.050]             }))
[16:05:20.050]             future::FutureResult(value = ...future.value$value, 
[16:05:20.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.050]                   ...future.rng), globalenv = if (FALSE) 
[16:05:20.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:20.050]                     ...future.globalenv.names))
[16:05:20.050]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:20.050]         }, condition = base::local({
[16:05:20.050]             c <- base::c
[16:05:20.050]             inherits <- base::inherits
[16:05:20.050]             invokeRestart <- base::invokeRestart
[16:05:20.050]             length <- base::length
[16:05:20.050]             list <- base::list
[16:05:20.050]             seq.int <- base::seq.int
[16:05:20.050]             signalCondition <- base::signalCondition
[16:05:20.050]             sys.calls <- base::sys.calls
[16:05:20.050]             `[[` <- base::`[[`
[16:05:20.050]             `+` <- base::`+`
[16:05:20.050]             `<<-` <- base::`<<-`
[16:05:20.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:20.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:20.050]                   3L)]
[16:05:20.050]             }
[16:05:20.050]             function(cond) {
[16:05:20.050]                 is_error <- inherits(cond, "error")
[16:05:20.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:20.050]                   NULL)
[16:05:20.050]                 if (is_error) {
[16:05:20.050]                   sessionInformation <- function() {
[16:05:20.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:20.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:20.050]                       search = base::search(), system = base::Sys.info())
[16:05:20.050]                   }
[16:05:20.050]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:20.050]                     cond$call), session = sessionInformation(), 
[16:05:20.050]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:20.050]                   signalCondition(cond)
[16:05:20.050]                 }
[16:05:20.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:20.050]                 "immediateCondition"))) {
[16:05:20.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:20.050]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:20.050]                   if (TRUE && !signal) {
[16:05:20.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.050]                     {
[16:05:20.050]                       inherits <- base::inherits
[16:05:20.050]                       invokeRestart <- base::invokeRestart
[16:05:20.050]                       is.null <- base::is.null
[16:05:20.050]                       muffled <- FALSE
[16:05:20.050]                       if (inherits(cond, "message")) {
[16:05:20.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.050]                         if (muffled) 
[16:05:20.050]                           invokeRestart("muffleMessage")
[16:05:20.050]                       }
[16:05:20.050]                       else if (inherits(cond, "warning")) {
[16:05:20.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.050]                         if (muffled) 
[16:05:20.050]                           invokeRestart("muffleWarning")
[16:05:20.050]                       }
[16:05:20.050]                       else if (inherits(cond, "condition")) {
[16:05:20.050]                         if (!is.null(pattern)) {
[16:05:20.050]                           computeRestarts <- base::computeRestarts
[16:05:20.050]                           grepl <- base::grepl
[16:05:20.050]                           restarts <- computeRestarts(cond)
[16:05:20.050]                           for (restart in restarts) {
[16:05:20.050]                             name <- restart$name
[16:05:20.050]                             if (is.null(name)) 
[16:05:20.050]                               next
[16:05:20.050]                             if (!grepl(pattern, name)) 
[16:05:20.050]                               next
[16:05:20.050]                             invokeRestart(restart)
[16:05:20.050]                             muffled <- TRUE
[16:05:20.050]                             break
[16:05:20.050]                           }
[16:05:20.050]                         }
[16:05:20.050]                       }
[16:05:20.050]                       invisible(muffled)
[16:05:20.050]                     }
[16:05:20.050]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.050]                   }
[16:05:20.050]                 }
[16:05:20.050]                 else {
[16:05:20.050]                   if (TRUE) {
[16:05:20.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.050]                     {
[16:05:20.050]                       inherits <- base::inherits
[16:05:20.050]                       invokeRestart <- base::invokeRestart
[16:05:20.050]                       is.null <- base::is.null
[16:05:20.050]                       muffled <- FALSE
[16:05:20.050]                       if (inherits(cond, "message")) {
[16:05:20.050]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.050]                         if (muffled) 
[16:05:20.050]                           invokeRestart("muffleMessage")
[16:05:20.050]                       }
[16:05:20.050]                       else if (inherits(cond, "warning")) {
[16:05:20.050]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.050]                         if (muffled) 
[16:05:20.050]                           invokeRestart("muffleWarning")
[16:05:20.050]                       }
[16:05:20.050]                       else if (inherits(cond, "condition")) {
[16:05:20.050]                         if (!is.null(pattern)) {
[16:05:20.050]                           computeRestarts <- base::computeRestarts
[16:05:20.050]                           grepl <- base::grepl
[16:05:20.050]                           restarts <- computeRestarts(cond)
[16:05:20.050]                           for (restart in restarts) {
[16:05:20.050]                             name <- restart$name
[16:05:20.050]                             if (is.null(name)) 
[16:05:20.050]                               next
[16:05:20.050]                             if (!grepl(pattern, name)) 
[16:05:20.050]                               next
[16:05:20.050]                             invokeRestart(restart)
[16:05:20.050]                             muffled <- TRUE
[16:05:20.050]                             break
[16:05:20.050]                           }
[16:05:20.050]                         }
[16:05:20.050]                       }
[16:05:20.050]                       invisible(muffled)
[16:05:20.050]                     }
[16:05:20.050]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.050]                   }
[16:05:20.050]                 }
[16:05:20.050]             }
[16:05:20.050]         }))
[16:05:20.050]     }, error = function(ex) {
[16:05:20.050]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:20.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.050]                 ...future.rng), started = ...future.startTime, 
[16:05:20.050]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:20.050]             version = "1.8"), class = "FutureResult")
[16:05:20.050]     }, finally = {
[16:05:20.050]         if (!identical(...future.workdir, getwd())) 
[16:05:20.050]             setwd(...future.workdir)
[16:05:20.050]         {
[16:05:20.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:20.050]                 ...future.oldOptions$nwarnings <- NULL
[16:05:20.050]             }
[16:05:20.050]             base::options(...future.oldOptions)
[16:05:20.050]             if (.Platform$OS.type == "windows") {
[16:05:20.050]                 old_names <- names(...future.oldEnvVars)
[16:05:20.050]                 envs <- base::Sys.getenv()
[16:05:20.050]                 names <- names(envs)
[16:05:20.050]                 common <- intersect(names, old_names)
[16:05:20.050]                 added <- setdiff(names, old_names)
[16:05:20.050]                 removed <- setdiff(old_names, names)
[16:05:20.050]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:20.050]                   envs[common]]
[16:05:20.050]                 NAMES <- toupper(changed)
[16:05:20.050]                 args <- list()
[16:05:20.050]                 for (kk in seq_along(NAMES)) {
[16:05:20.050]                   name <- changed[[kk]]
[16:05:20.050]                   NAME <- NAMES[[kk]]
[16:05:20.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.050]                     next
[16:05:20.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.050]                 }
[16:05:20.050]                 NAMES <- toupper(added)
[16:05:20.050]                 for (kk in seq_along(NAMES)) {
[16:05:20.050]                   name <- added[[kk]]
[16:05:20.050]                   NAME <- NAMES[[kk]]
[16:05:20.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.050]                     next
[16:05:20.050]                   args[[name]] <- ""
[16:05:20.050]                 }
[16:05:20.050]                 NAMES <- toupper(removed)
[16:05:20.050]                 for (kk in seq_along(NAMES)) {
[16:05:20.050]                   name <- removed[[kk]]
[16:05:20.050]                   NAME <- NAMES[[kk]]
[16:05:20.050]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.050]                     next
[16:05:20.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.050]                 }
[16:05:20.050]                 if (length(args) > 0) 
[16:05:20.050]                   base::do.call(base::Sys.setenv, args = args)
[16:05:20.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:20.050]             }
[16:05:20.050]             else {
[16:05:20.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:20.050]             }
[16:05:20.050]             {
[16:05:20.050]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:20.050]                   0L) {
[16:05:20.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:20.050]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:20.050]                   base::options(opts)
[16:05:20.050]                 }
[16:05:20.050]                 {
[16:05:20.050]                   {
[16:05:20.050]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:20.050]                     NULL
[16:05:20.050]                   }
[16:05:20.050]                   options(future.plan = NULL)
[16:05:20.050]                   if (is.na(NA_character_)) 
[16:05:20.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:20.050]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:20.050]                     envir = parent.frame()) 
[16:05:20.050]                   {
[16:05:20.050]                     default_workers <- missing(workers)
[16:05:20.050]                     if (is.function(workers)) 
[16:05:20.050]                       workers <- workers()
[16:05:20.050]                     workers <- structure(as.integer(workers), 
[16:05:20.050]                       class = class(workers))
[16:05:20.050]                     stop_if_not(is.finite(workers), workers >= 
[16:05:20.050]                       1L)
[16:05:20.050]                     if ((workers == 1L && !inherits(workers, 
[16:05:20.050]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:20.050]                       if (default_workers) 
[16:05:20.050]                         supportsMulticore(warn = TRUE)
[16:05:20.050]                       return(sequential(..., envir = envir))
[16:05:20.050]                     }
[16:05:20.050]                     oopts <- options(mc.cores = workers)
[16:05:20.050]                     on.exit(options(oopts))
[16:05:20.050]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:20.050]                       envir = envir)
[16:05:20.050]                     if (!future$lazy) 
[16:05:20.050]                       future <- run(future)
[16:05:20.050]                     invisible(future)
[16:05:20.050]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:20.050]                 }
[16:05:20.050]             }
[16:05:20.050]         }
[16:05:20.050]     })
[16:05:20.050]     if (TRUE) {
[16:05:20.050]         base::sink(type = "output", split = FALSE)
[16:05:20.050]         if (TRUE) {
[16:05:20.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:20.050]         }
[16:05:20.050]         else {
[16:05:20.050]             ...future.result["stdout"] <- base::list(NULL)
[16:05:20.050]         }
[16:05:20.050]         base::close(...future.stdout)
[16:05:20.050]         ...future.stdout <- NULL
[16:05:20.050]     }
[16:05:20.050]     ...future.result$conditions <- ...future.conditions
[16:05:20.050]     ...future.result$finished <- base::Sys.time()
[16:05:20.050]     ...future.result
[16:05:20.050] }
[16:05:20.053] assign_globals() ...
[16:05:20.053] List of 1
[16:05:20.053]  $ ii: int 4
[16:05:20.053]  - attr(*, "where")=List of 1
[16:05:20.053]   ..$ ii:<environment: R_EmptyEnv> 
[16:05:20.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:20.053]  - attr(*, "resolved")= logi FALSE
[16:05:20.053]  - attr(*, "total_size")= num 56
[16:05:20.057] - copied ‘ii’ to environment
[16:05:20.057] assign_globals() ... done
[16:05:20.057] requestCore(): workers = 2
[16:05:20.057] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:20.068] result() for MulticoreFuture ...
[16:05:20.069] result() for MulticoreFuture ...
[16:05:20.069] result() for MulticoreFuture ... done
[16:05:20.069] result() for MulticoreFuture ... done
[16:05:20.070] result() for MulticoreFuture ...
[16:05:20.070] result() for MulticoreFuture ... done
[16:05:20.072] MulticoreFuture started
 - Resolving 4 multicore futures
[16:05:20.073] result() for MulticoreFuture ...
[16:05:20.073] result() for MulticoreFuture ... done
[16:05:20.073] plan(): Setting new future strategy stack:
[16:05:20.074] result() for MulticoreFuture ...
[16:05:20.074] result() for MulticoreFuture ... done
[16:05:20.074] result() for MulticoreFuture ...
[16:05:20.074] result() for MulticoreFuture ... done
[16:05:20.074] List of future strategies:
[16:05:20.074] 1. sequential:
[16:05:20.074]    - args: function (..., envir = parent.frame())
[16:05:20.074]    - tweaked: FALSE
[16:05:20.074]    - call: NULL
[16:05:20.075] result() for MulticoreFuture ...
[16:05:20.075] plan(): nbrOfWorkers() = 1
[16:05:20.075] result() for MulticoreFuture ... done
[16:05:20.075] result() for MulticoreFuture ...
[16:05:20.076] result() for MulticoreFuture ...
[16:05:20.077] result() for MulticoreFuture ... done
[16:05:20.077] result() for MulticoreFuture ... done
[16:05:20.077] result() for MulticoreFuture ...
[16:05:20.077] plan(): Setting new future strategy stack:
[16:05:20.077] result() for MulticoreFuture ... done
[16:05:20.078] result() for MulticoreFuture ...
[16:05:20.077] List of future strategies:
[16:05:20.077] 1. multicore:
[16:05:20.077]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.077]    - tweaked: FALSE
[16:05:20.077]    - call: plan(multicore)
[16:05:20.082] plan(): nbrOfWorkers() = 2
[16:05:20.083] result() for MulticoreFuture ...
[16:05:20.083] result() for MulticoreFuture ... done
[16:05:20.083] result() for MulticoreFuture ... done
[16:05:20.084] result() for MulticoreFuture ...
[16:05:20.084] result() for MulticoreFuture ... done
*** multicore(..., globals = TRUE) and errors
[16:05:20.088] getGlobalsAndPackages() ...
[16:05:20.088] Searching for globals...
[16:05:20.089] - globals found: [2] ‘{’, ‘stop’
[16:05:20.089] Searching for globals ... DONE
[16:05:20.090] Resolving globals: FALSE
[16:05:20.093] 
[16:05:20.093] 
[16:05:20.093] getGlobalsAndPackages() ... DONE
[16:05:20.093] Packages needed by the future expression (n = 0): <none>
[16:05:20.093] Packages needed by future strategies (n = 0): <none>
[16:05:20.094] {
[16:05:20.094]     {
[16:05:20.094]         {
[16:05:20.094]             ...future.startTime <- base::Sys.time()
[16:05:20.094]             {
[16:05:20.094]                 {
[16:05:20.094]                   {
[16:05:20.094]                     {
[16:05:20.094]                       base::local({
[16:05:20.094]                         has_future <- base::requireNamespace("future", 
[16:05:20.094]                           quietly = TRUE)
[16:05:20.094]                         if (has_future) {
[16:05:20.094]                           ns <- base::getNamespace("future")
[16:05:20.094]                           version <- ns[[".package"]][["version"]]
[16:05:20.094]                           if (is.null(version)) 
[16:05:20.094]                             version <- utils::packageVersion("future")
[16:05:20.094]                         }
[16:05:20.094]                         else {
[16:05:20.094]                           version <- NULL
[16:05:20.094]                         }
[16:05:20.094]                         if (!has_future || version < "1.8.0") {
[16:05:20.094]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:20.094]                             "", base::R.version$version.string), 
[16:05:20.094]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:20.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:20.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:20.094]                               "release", "version")], collapse = " "), 
[16:05:20.094]                             hostname = base::Sys.info()[["nodename"]])
[16:05:20.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:20.094]                             info)
[16:05:20.094]                           info <- base::paste(info, collapse = "; ")
[16:05:20.094]                           if (!has_future) {
[16:05:20.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:20.094]                               info)
[16:05:20.094]                           }
[16:05:20.094]                           else {
[16:05:20.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:20.094]                               info, version)
[16:05:20.094]                           }
[16:05:20.094]                           base::stop(msg)
[16:05:20.094]                         }
[16:05:20.094]                       })
[16:05:20.094]                     }
[16:05:20.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:20.094]                     base::options(mc.cores = 1L)
[16:05:20.094]                   }
[16:05:20.094]                   options(future.plan = NULL)
[16:05:20.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:20.094]                 }
[16:05:20.094]                 ...future.workdir <- getwd()
[16:05:20.094]             }
[16:05:20.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:20.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:20.094]         }
[16:05:20.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:20.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:20.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:20.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:20.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:20.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:20.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:20.094]             base::names(...future.oldOptions))
[16:05:20.094]     }
[16:05:20.094]     if (FALSE) {
[16:05:20.094]     }
[16:05:20.094]     else {
[16:05:20.094]         if (TRUE) {
[16:05:20.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:20.094]                 open = "w")
[16:05:20.094]         }
[16:05:20.094]         else {
[16:05:20.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:20.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:20.094]         }
[16:05:20.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:20.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:20.094]             base::sink(type = "output", split = FALSE)
[16:05:20.094]             base::close(...future.stdout)
[16:05:20.094]         }, add = TRUE)
[16:05:20.094]     }
[16:05:20.094]     ...future.frame <- base::sys.nframe()
[16:05:20.094]     ...future.conditions <- base::list()
[16:05:20.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:20.094]     if (FALSE) {
[16:05:20.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:20.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:20.094]     }
[16:05:20.094]     ...future.result <- base::tryCatch({
[16:05:20.094]         base::withCallingHandlers({
[16:05:20.094]             ...future.value <- base::withVisible(base::local({
[16:05:20.094]                 withCallingHandlers({
[16:05:20.094]                   {
[16:05:20.094]                     stop("Whoops!")
[16:05:20.094]                     1
[16:05:20.094]                   }
[16:05:20.094]                 }, immediateCondition = function(cond) {
[16:05:20.094]                   save_rds <- function (object, pathname, ...) 
[16:05:20.094]                   {
[16:05:20.094]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:20.094]                     if (file_test("-f", pathname_tmp)) {
[16:05:20.094]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.094]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:20.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.094]                         fi_tmp[["mtime"]])
[16:05:20.094]                     }
[16:05:20.094]                     tryCatch({
[16:05:20.094]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:20.094]                     }, error = function(ex) {
[16:05:20.094]                       msg <- conditionMessage(ex)
[16:05:20.094]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.094]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:20.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.094]                         fi_tmp[["mtime"]], msg)
[16:05:20.094]                       ex$message <- msg
[16:05:20.094]                       stop(ex)
[16:05:20.094]                     })
[16:05:20.094]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:20.094]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:20.094]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:20.094]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.094]                       fi <- file.info(pathname)
[16:05:20.094]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:20.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.094]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:20.094]                         fi[["size"]], fi[["mtime"]])
[16:05:20.094]                       stop(msg)
[16:05:20.094]                     }
[16:05:20.094]                     invisible(pathname)
[16:05:20.094]                   }
[16:05:20.094]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:20.094]                     rootPath = tempdir()) 
[16:05:20.094]                   {
[16:05:20.094]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:20.094]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:20.094]                       tmpdir = path, fileext = ".rds")
[16:05:20.094]                     save_rds(obj, file)
[16:05:20.094]                   }
[16:05:20.094]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:20.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.094]                   {
[16:05:20.094]                     inherits <- base::inherits
[16:05:20.094]                     invokeRestart <- base::invokeRestart
[16:05:20.094]                     is.null <- base::is.null
[16:05:20.094]                     muffled <- FALSE
[16:05:20.094]                     if (inherits(cond, "message")) {
[16:05:20.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:20.094]                       if (muffled) 
[16:05:20.094]                         invokeRestart("muffleMessage")
[16:05:20.094]                     }
[16:05:20.094]                     else if (inherits(cond, "warning")) {
[16:05:20.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:20.094]                       if (muffled) 
[16:05:20.094]                         invokeRestart("muffleWarning")
[16:05:20.094]                     }
[16:05:20.094]                     else if (inherits(cond, "condition")) {
[16:05:20.094]                       if (!is.null(pattern)) {
[16:05:20.094]                         computeRestarts <- base::computeRestarts
[16:05:20.094]                         grepl <- base::grepl
[16:05:20.094]                         restarts <- computeRestarts(cond)
[16:05:20.094]                         for (restart in restarts) {
[16:05:20.094]                           name <- restart$name
[16:05:20.094]                           if (is.null(name)) 
[16:05:20.094]                             next
[16:05:20.094]                           if (!grepl(pattern, name)) 
[16:05:20.094]                             next
[16:05:20.094]                           invokeRestart(restart)
[16:05:20.094]                           muffled <- TRUE
[16:05:20.094]                           break
[16:05:20.094]                         }
[16:05:20.094]                       }
[16:05:20.094]                     }
[16:05:20.094]                     invisible(muffled)
[16:05:20.094]                   }
[16:05:20.094]                   muffleCondition(cond)
[16:05:20.094]                 })
[16:05:20.094]             }))
[16:05:20.094]             future::FutureResult(value = ...future.value$value, 
[16:05:20.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.094]                   ...future.rng), globalenv = if (FALSE) 
[16:05:20.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:20.094]                     ...future.globalenv.names))
[16:05:20.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:20.094]         }, condition = base::local({
[16:05:20.094]             c <- base::c
[16:05:20.094]             inherits <- base::inherits
[16:05:20.094]             invokeRestart <- base::invokeRestart
[16:05:20.094]             length <- base::length
[16:05:20.094]             list <- base::list
[16:05:20.094]             seq.int <- base::seq.int
[16:05:20.094]             signalCondition <- base::signalCondition
[16:05:20.094]             sys.calls <- base::sys.calls
[16:05:20.094]             `[[` <- base::`[[`
[16:05:20.094]             `+` <- base::`+`
[16:05:20.094]             `<<-` <- base::`<<-`
[16:05:20.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:20.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:20.094]                   3L)]
[16:05:20.094]             }
[16:05:20.094]             function(cond) {
[16:05:20.094]                 is_error <- inherits(cond, "error")
[16:05:20.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:20.094]                   NULL)
[16:05:20.094]                 if (is_error) {
[16:05:20.094]                   sessionInformation <- function() {
[16:05:20.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:20.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:20.094]                       search = base::search(), system = base::Sys.info())
[16:05:20.094]                   }
[16:05:20.094]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:20.094]                     cond$call), session = sessionInformation(), 
[16:05:20.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:20.094]                   signalCondition(cond)
[16:05:20.094]                 }
[16:05:20.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:20.094]                 "immediateCondition"))) {
[16:05:20.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:20.094]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:20.094]                   if (TRUE && !signal) {
[16:05:20.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.094]                     {
[16:05:20.094]                       inherits <- base::inherits
[16:05:20.094]                       invokeRestart <- base::invokeRestart
[16:05:20.094]                       is.null <- base::is.null
[16:05:20.094]                       muffled <- FALSE
[16:05:20.094]                       if (inherits(cond, "message")) {
[16:05:20.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.094]                         if (muffled) 
[16:05:20.094]                           invokeRestart("muffleMessage")
[16:05:20.094]                       }
[16:05:20.094]                       else if (inherits(cond, "warning")) {
[16:05:20.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.094]                         if (muffled) 
[16:05:20.094]                           invokeRestart("muffleWarning")
[16:05:20.094]                       }
[16:05:20.094]                       else if (inherits(cond, "condition")) {
[16:05:20.094]                         if (!is.null(pattern)) {
[16:05:20.094]                           computeRestarts <- base::computeRestarts
[16:05:20.094]                           grepl <- base::grepl
[16:05:20.094]                           restarts <- computeRestarts(cond)
[16:05:20.094]                           for (restart in restarts) {
[16:05:20.094]                             name <- restart$name
[16:05:20.094]                             if (is.null(name)) 
[16:05:20.094]                               next
[16:05:20.094]                             if (!grepl(pattern, name)) 
[16:05:20.094]                               next
[16:05:20.094]                             invokeRestart(restart)
[16:05:20.094]                             muffled <- TRUE
[16:05:20.094]                             break
[16:05:20.094]                           }
[16:05:20.094]                         }
[16:05:20.094]                       }
[16:05:20.094]                       invisible(muffled)
[16:05:20.094]                     }
[16:05:20.094]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.094]                   }
[16:05:20.094]                 }
[16:05:20.094]                 else {
[16:05:20.094]                   if (TRUE) {
[16:05:20.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.094]                     {
[16:05:20.094]                       inherits <- base::inherits
[16:05:20.094]                       invokeRestart <- base::invokeRestart
[16:05:20.094]                       is.null <- base::is.null
[16:05:20.094]                       muffled <- FALSE
[16:05:20.094]                       if (inherits(cond, "message")) {
[16:05:20.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.094]                         if (muffled) 
[16:05:20.094]                           invokeRestart("muffleMessage")
[16:05:20.094]                       }
[16:05:20.094]                       else if (inherits(cond, "warning")) {
[16:05:20.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.094]                         if (muffled) 
[16:05:20.094]                           invokeRestart("muffleWarning")
[16:05:20.094]                       }
[16:05:20.094]                       else if (inherits(cond, "condition")) {
[16:05:20.094]                         if (!is.null(pattern)) {
[16:05:20.094]                           computeRestarts <- base::computeRestarts
[16:05:20.094]                           grepl <- base::grepl
[16:05:20.094]                           restarts <- computeRestarts(cond)
[16:05:20.094]                           for (restart in restarts) {
[16:05:20.094]                             name <- restart$name
[16:05:20.094]                             if (is.null(name)) 
[16:05:20.094]                               next
[16:05:20.094]                             if (!grepl(pattern, name)) 
[16:05:20.094]                               next
[16:05:20.094]                             invokeRestart(restart)
[16:05:20.094]                             muffled <- TRUE
[16:05:20.094]                             break
[16:05:20.094]                           }
[16:05:20.094]                         }
[16:05:20.094]                       }
[16:05:20.094]                       invisible(muffled)
[16:05:20.094]                     }
[16:05:20.094]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.094]                   }
[16:05:20.094]                 }
[16:05:20.094]             }
[16:05:20.094]         }))
[16:05:20.094]     }, error = function(ex) {
[16:05:20.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:20.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.094]                 ...future.rng), started = ...future.startTime, 
[16:05:20.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:20.094]             version = "1.8"), class = "FutureResult")
[16:05:20.094]     }, finally = {
[16:05:20.094]         if (!identical(...future.workdir, getwd())) 
[16:05:20.094]             setwd(...future.workdir)
[16:05:20.094]         {
[16:05:20.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:20.094]                 ...future.oldOptions$nwarnings <- NULL
[16:05:20.094]             }
[16:05:20.094]             base::options(...future.oldOptions)
[16:05:20.094]             if (.Platform$OS.type == "windows") {
[16:05:20.094]                 old_names <- names(...future.oldEnvVars)
[16:05:20.094]                 envs <- base::Sys.getenv()
[16:05:20.094]                 names <- names(envs)
[16:05:20.094]                 common <- intersect(names, old_names)
[16:05:20.094]                 added <- setdiff(names, old_names)
[16:05:20.094]                 removed <- setdiff(old_names, names)
[16:05:20.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:20.094]                   envs[common]]
[16:05:20.094]                 NAMES <- toupper(changed)
[16:05:20.094]                 args <- list()
[16:05:20.094]                 for (kk in seq_along(NAMES)) {
[16:05:20.094]                   name <- changed[[kk]]
[16:05:20.094]                   NAME <- NAMES[[kk]]
[16:05:20.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.094]                     next
[16:05:20.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.094]                 }
[16:05:20.094]                 NAMES <- toupper(added)
[16:05:20.094]                 for (kk in seq_along(NAMES)) {
[16:05:20.094]                   name <- added[[kk]]
[16:05:20.094]                   NAME <- NAMES[[kk]]
[16:05:20.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.094]                     next
[16:05:20.094]                   args[[name]] <- ""
[16:05:20.094]                 }
[16:05:20.094]                 NAMES <- toupper(removed)
[16:05:20.094]                 for (kk in seq_along(NAMES)) {
[16:05:20.094]                   name <- removed[[kk]]
[16:05:20.094]                   NAME <- NAMES[[kk]]
[16:05:20.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.094]                     next
[16:05:20.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.094]                 }
[16:05:20.094]                 if (length(args) > 0) 
[16:05:20.094]                   base::do.call(base::Sys.setenv, args = args)
[16:05:20.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:20.094]             }
[16:05:20.094]             else {
[16:05:20.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:20.094]             }
[16:05:20.094]             {
[16:05:20.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:20.094]                   0L) {
[16:05:20.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:20.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:20.094]                   base::options(opts)
[16:05:20.094]                 }
[16:05:20.094]                 {
[16:05:20.094]                   {
[16:05:20.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:20.094]                     NULL
[16:05:20.094]                   }
[16:05:20.094]                   options(future.plan = NULL)
[16:05:20.094]                   if (is.na(NA_character_)) 
[16:05:20.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:20.094]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:20.094]                     envir = parent.frame()) 
[16:05:20.094]                   {
[16:05:20.094]                     default_workers <- missing(workers)
[16:05:20.094]                     if (is.function(workers)) 
[16:05:20.094]                       workers <- workers()
[16:05:20.094]                     workers <- structure(as.integer(workers), 
[16:05:20.094]                       class = class(workers))
[16:05:20.094]                     stop_if_not(is.finite(workers), workers >= 
[16:05:20.094]                       1L)
[16:05:20.094]                     if ((workers == 1L && !inherits(workers, 
[16:05:20.094]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:20.094]                       if (default_workers) 
[16:05:20.094]                         supportsMulticore(warn = TRUE)
[16:05:20.094]                       return(sequential(..., envir = envir))
[16:05:20.094]                     }
[16:05:20.094]                     oopts <- options(mc.cores = workers)
[16:05:20.094]                     on.exit(options(oopts))
[16:05:20.094]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:20.094]                       envir = envir)
[16:05:20.094]                     if (!future$lazy) 
[16:05:20.094]                       future <- run(future)
[16:05:20.094]                     invisible(future)
[16:05:20.094]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:20.094]                 }
[16:05:20.094]             }
[16:05:20.094]         }
[16:05:20.094]     })
[16:05:20.094]     if (TRUE) {
[16:05:20.094]         base::sink(type = "output", split = FALSE)
[16:05:20.094]         if (TRUE) {
[16:05:20.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:20.094]         }
[16:05:20.094]         else {
[16:05:20.094]             ...future.result["stdout"] <- base::list(NULL)
[16:05:20.094]         }
[16:05:20.094]         base::close(...future.stdout)
[16:05:20.094]         ...future.stdout <- NULL
[16:05:20.094]     }
[16:05:20.094]     ...future.result$conditions <- ...future.conditions
[16:05:20.094]     ...future.result$finished <- base::Sys.time()
[16:05:20.094]     ...future.result
[16:05:20.094] }
[16:05:20.097] requestCore(): workers = 2
[16:05:20.099] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:20.100] plan(): Setting new future strategy stack:
[16:05:20.100] List of future strategies:
[16:05:20.100] 1. sequential:
[16:05:20.100]    - args: function (..., envir = parent.frame())
[16:05:20.100]    - tweaked: FALSE
[16:05:20.100]    - call: NULL
[16:05:20.101] plan(): nbrOfWorkers() = 1
[16:05:20.103] plan(): Setting new future strategy stack:
[16:05:20.103] List of future strategies:
[16:05:20.103] 1. multicore:
[16:05:20.103]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.103]    - tweaked: FALSE
[16:05:20.103]    - call: plan(multicore)
[16:05:20.108] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:20.110] result() for MulticoreFuture ...
[16:05:20.113] result() for MulticoreFuture ...
[16:05:20.114] result() for MulticoreFuture ... done
[16:05:20.114] signalConditions() ...
[16:05:20.114]  - include = ‘immediateCondition’
[16:05:20.114]  - exclude = 
[16:05:20.114]  - resignal = FALSE
[16:05:20.114]  - Number of conditions: 1
[16:05:20.114] signalConditions() ... done
[16:05:20.115] result() for MulticoreFuture ... done
[16:05:20.115] result() for MulticoreFuture ...
[16:05:20.115] result() for MulticoreFuture ... done
[16:05:20.115] signalConditions() ...
[16:05:20.115]  - include = ‘immediateCondition’
[16:05:20.115]  - exclude = 
[16:05:20.115]  - resignal = FALSE
[16:05:20.115]  - Number of conditions: 1
[16:05:20.116] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:20.116] result() for MulticoreFuture ...
[16:05:20.116] result() for MulticoreFuture ... done
[16:05:20.117] result() for MulticoreFuture ...
[16:05:20.117] result() for MulticoreFuture ... done
[16:05:20.117] signalConditions() ...
[16:05:20.117]  - include = ‘immediateCondition’
[16:05:20.117]  - exclude = 
[16:05:20.117]  - resignal = FALSE
[16:05:20.117]  - Number of conditions: 1
[16:05:20.117] signalConditions() ... done
[16:05:20.118] Future state: ‘finished’
[16:05:20.118] result() for MulticoreFuture ...
[16:05:20.118] result() for MulticoreFuture ... done
[16:05:20.118] signalConditions() ...
[16:05:20.118]  - include = ‘condition’
[16:05:20.118]  - exclude = ‘immediateCondition’
[16:05:20.118]  - resignal = TRUE
[16:05:20.118]  - Number of conditions: 1
[16:05:20.118]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:20.119] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:20.119] result() for MulticoreFuture ...
[16:05:20.120] result() for MulticoreFuture ... done
[16:05:20.120] result() for MulticoreFuture ...
[16:05:20.120] result() for MulticoreFuture ... done
[16:05:20.120] signalConditions() ...
[16:05:20.120]  - include = ‘immediateCondition’
[16:05:20.120]  - exclude = 
[16:05:20.120]  - resignal = FALSE
[16:05:20.120]  - Number of conditions: 1
[16:05:20.120] signalConditions() ... done
[16:05:20.121] Future state: ‘finished’
[16:05:20.121] result() for MulticoreFuture ...
[16:05:20.121] result() for MulticoreFuture ... done
[16:05:20.121] signalConditions() ...
[16:05:20.121]  - include = ‘condition’
[16:05:20.121]  - exclude = ‘immediateCondition’
[16:05:20.121]  - resignal = TRUE
[16:05:20.121]  - Number of conditions: 1
[16:05:20.121]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:05:20.122] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[16:05:20.126] getGlobalsAndPackages() ...
[16:05:20.126] 
[16:05:20.126] - globals: [0] <none>
[16:05:20.127] getGlobalsAndPackages() ... DONE
[16:05:20.127] Packages needed by the future expression (n = 0): <none>
[16:05:20.127] Packages needed by future strategies (n = 0): <none>
[16:05:20.128] {
[16:05:20.128]     {
[16:05:20.128]         {
[16:05:20.128]             ...future.startTime <- base::Sys.time()
[16:05:20.128]             {
[16:05:20.128]                 {
[16:05:20.128]                   {
[16:05:20.128]                     {
[16:05:20.128]                       base::local({
[16:05:20.128]                         has_future <- base::requireNamespace("future", 
[16:05:20.128]                           quietly = TRUE)
[16:05:20.128]                         if (has_future) {
[16:05:20.128]                           ns <- base::getNamespace("future")
[16:05:20.128]                           version <- ns[[".package"]][["version"]]
[16:05:20.128]                           if (is.null(version)) 
[16:05:20.128]                             version <- utils::packageVersion("future")
[16:05:20.128]                         }
[16:05:20.128]                         else {
[16:05:20.128]                           version <- NULL
[16:05:20.128]                         }
[16:05:20.128]                         if (!has_future || version < "1.8.0") {
[16:05:20.128]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:20.128]                             "", base::R.version$version.string), 
[16:05:20.128]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:20.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:20.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:20.128]                               "release", "version")], collapse = " "), 
[16:05:20.128]                             hostname = base::Sys.info()[["nodename"]])
[16:05:20.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:20.128]                             info)
[16:05:20.128]                           info <- base::paste(info, collapse = "; ")
[16:05:20.128]                           if (!has_future) {
[16:05:20.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:20.128]                               info)
[16:05:20.128]                           }
[16:05:20.128]                           else {
[16:05:20.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:20.128]                               info, version)
[16:05:20.128]                           }
[16:05:20.128]                           base::stop(msg)
[16:05:20.128]                         }
[16:05:20.128]                       })
[16:05:20.128]                     }
[16:05:20.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:20.128]                     base::options(mc.cores = 1L)
[16:05:20.128]                   }
[16:05:20.128]                   options(future.plan = NULL)
[16:05:20.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:20.128]                 }
[16:05:20.128]                 ...future.workdir <- getwd()
[16:05:20.128]             }
[16:05:20.128]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:20.128]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:20.128]         }
[16:05:20.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:20.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:20.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:20.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:20.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:20.128]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:20.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:20.128]             base::names(...future.oldOptions))
[16:05:20.128]     }
[16:05:20.128]     if (FALSE) {
[16:05:20.128]     }
[16:05:20.128]     else {
[16:05:20.128]         if (TRUE) {
[16:05:20.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:20.128]                 open = "w")
[16:05:20.128]         }
[16:05:20.128]         else {
[16:05:20.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:20.128]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:20.128]         }
[16:05:20.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:20.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:20.128]             base::sink(type = "output", split = FALSE)
[16:05:20.128]             base::close(...future.stdout)
[16:05:20.128]         }, add = TRUE)
[16:05:20.128]     }
[16:05:20.128]     ...future.frame <- base::sys.nframe()
[16:05:20.128]     ...future.conditions <- base::list()
[16:05:20.128]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:20.128]     if (FALSE) {
[16:05:20.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:20.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:20.128]     }
[16:05:20.128]     ...future.result <- base::tryCatch({
[16:05:20.128]         base::withCallingHandlers({
[16:05:20.128]             ...future.value <- base::withVisible(base::local({
[16:05:20.128]                 withCallingHandlers({
[16:05:20.128]                   {
[16:05:20.128]                     stop(structure(list(message = "boom"), class = c("MyError", 
[16:05:20.128]                       "error", "condition")))
[16:05:20.128]                   }
[16:05:20.128]                 }, immediateCondition = function(cond) {
[16:05:20.128]                   save_rds <- function (object, pathname, ...) 
[16:05:20.128]                   {
[16:05:20.128]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:20.128]                     if (file_test("-f", pathname_tmp)) {
[16:05:20.128]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.128]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:20.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.128]                         fi_tmp[["mtime"]])
[16:05:20.128]                     }
[16:05:20.128]                     tryCatch({
[16:05:20.128]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:20.128]                     }, error = function(ex) {
[16:05:20.128]                       msg <- conditionMessage(ex)
[16:05:20.128]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.128]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:20.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.128]                         fi_tmp[["mtime"]], msg)
[16:05:20.128]                       ex$message <- msg
[16:05:20.128]                       stop(ex)
[16:05:20.128]                     })
[16:05:20.128]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:20.128]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:20.128]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:20.128]                       fi_tmp <- file.info(pathname_tmp)
[16:05:20.128]                       fi <- file.info(pathname)
[16:05:20.128]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:20.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:20.128]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:20.128]                         fi[["size"]], fi[["mtime"]])
[16:05:20.128]                       stop(msg)
[16:05:20.128]                     }
[16:05:20.128]                     invisible(pathname)
[16:05:20.128]                   }
[16:05:20.128]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:20.128]                     rootPath = tempdir()) 
[16:05:20.128]                   {
[16:05:20.128]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:20.128]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:20.128]                       tmpdir = path, fileext = ".rds")
[16:05:20.128]                     save_rds(obj, file)
[16:05:20.128]                   }
[16:05:20.128]                   saveImmediateCondition(cond, path = "/tmp/RtmpMm7jpv/.future/immediateConditions")
[16:05:20.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.128]                   {
[16:05:20.128]                     inherits <- base::inherits
[16:05:20.128]                     invokeRestart <- base::invokeRestart
[16:05:20.128]                     is.null <- base::is.null
[16:05:20.128]                     muffled <- FALSE
[16:05:20.128]                     if (inherits(cond, "message")) {
[16:05:20.128]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:20.128]                       if (muffled) 
[16:05:20.128]                         invokeRestart("muffleMessage")
[16:05:20.128]                     }
[16:05:20.128]                     else if (inherits(cond, "warning")) {
[16:05:20.128]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:20.128]                       if (muffled) 
[16:05:20.128]                         invokeRestart("muffleWarning")
[16:05:20.128]                     }
[16:05:20.128]                     else if (inherits(cond, "condition")) {
[16:05:20.128]                       if (!is.null(pattern)) {
[16:05:20.128]                         computeRestarts <- base::computeRestarts
[16:05:20.128]                         grepl <- base::grepl
[16:05:20.128]                         restarts <- computeRestarts(cond)
[16:05:20.128]                         for (restart in restarts) {
[16:05:20.128]                           name <- restart$name
[16:05:20.128]                           if (is.null(name)) 
[16:05:20.128]                             next
[16:05:20.128]                           if (!grepl(pattern, name)) 
[16:05:20.128]                             next
[16:05:20.128]                           invokeRestart(restart)
[16:05:20.128]                           muffled <- TRUE
[16:05:20.128]                           break
[16:05:20.128]                         }
[16:05:20.128]                       }
[16:05:20.128]                     }
[16:05:20.128]                     invisible(muffled)
[16:05:20.128]                   }
[16:05:20.128]                   muffleCondition(cond)
[16:05:20.128]                 })
[16:05:20.128]             }))
[16:05:20.128]             future::FutureResult(value = ...future.value$value, 
[16:05:20.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.128]                   ...future.rng), globalenv = if (FALSE) 
[16:05:20.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:20.128]                     ...future.globalenv.names))
[16:05:20.128]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:20.128]         }, condition = base::local({
[16:05:20.128]             c <- base::c
[16:05:20.128]             inherits <- base::inherits
[16:05:20.128]             invokeRestart <- base::invokeRestart
[16:05:20.128]             length <- base::length
[16:05:20.128]             list <- base::list
[16:05:20.128]             seq.int <- base::seq.int
[16:05:20.128]             signalCondition <- base::signalCondition
[16:05:20.128]             sys.calls <- base::sys.calls
[16:05:20.128]             `[[` <- base::`[[`
[16:05:20.128]             `+` <- base::`+`
[16:05:20.128]             `<<-` <- base::`<<-`
[16:05:20.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:20.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:20.128]                   3L)]
[16:05:20.128]             }
[16:05:20.128]             function(cond) {
[16:05:20.128]                 is_error <- inherits(cond, "error")
[16:05:20.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:20.128]                   NULL)
[16:05:20.128]                 if (is_error) {
[16:05:20.128]                   sessionInformation <- function() {
[16:05:20.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:20.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:20.128]                       search = base::search(), system = base::Sys.info())
[16:05:20.128]                   }
[16:05:20.128]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:20.128]                     cond$call), session = sessionInformation(), 
[16:05:20.128]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:20.128]                   signalCondition(cond)
[16:05:20.128]                 }
[16:05:20.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:20.128]                 "immediateCondition"))) {
[16:05:20.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:20.128]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:20.128]                   if (TRUE && !signal) {
[16:05:20.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.128]                     {
[16:05:20.128]                       inherits <- base::inherits
[16:05:20.128]                       invokeRestart <- base::invokeRestart
[16:05:20.128]                       is.null <- base::is.null
[16:05:20.128]                       muffled <- FALSE
[16:05:20.128]                       if (inherits(cond, "message")) {
[16:05:20.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.128]                         if (muffled) 
[16:05:20.128]                           invokeRestart("muffleMessage")
[16:05:20.128]                       }
[16:05:20.128]                       else if (inherits(cond, "warning")) {
[16:05:20.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.128]                         if (muffled) 
[16:05:20.128]                           invokeRestart("muffleWarning")
[16:05:20.128]                       }
[16:05:20.128]                       else if (inherits(cond, "condition")) {
[16:05:20.128]                         if (!is.null(pattern)) {
[16:05:20.128]                           computeRestarts <- base::computeRestarts
[16:05:20.128]                           grepl <- base::grepl
[16:05:20.128]                           restarts <- computeRestarts(cond)
[16:05:20.128]                           for (restart in restarts) {
[16:05:20.128]                             name <- restart$name
[16:05:20.128]                             if (is.null(name)) 
[16:05:20.128]                               next
[16:05:20.128]                             if (!grepl(pattern, name)) 
[16:05:20.128]                               next
[16:05:20.128]                             invokeRestart(restart)
[16:05:20.128]                             muffled <- TRUE
[16:05:20.128]                             break
[16:05:20.128]                           }
[16:05:20.128]                         }
[16:05:20.128]                       }
[16:05:20.128]                       invisible(muffled)
[16:05:20.128]                     }
[16:05:20.128]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.128]                   }
[16:05:20.128]                 }
[16:05:20.128]                 else {
[16:05:20.128]                   if (TRUE) {
[16:05:20.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.128]                     {
[16:05:20.128]                       inherits <- base::inherits
[16:05:20.128]                       invokeRestart <- base::invokeRestart
[16:05:20.128]                       is.null <- base::is.null
[16:05:20.128]                       muffled <- FALSE
[16:05:20.128]                       if (inherits(cond, "message")) {
[16:05:20.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.128]                         if (muffled) 
[16:05:20.128]                           invokeRestart("muffleMessage")
[16:05:20.128]                       }
[16:05:20.128]                       else if (inherits(cond, "warning")) {
[16:05:20.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.128]                         if (muffled) 
[16:05:20.128]                           invokeRestart("muffleWarning")
[16:05:20.128]                       }
[16:05:20.128]                       else if (inherits(cond, "condition")) {
[16:05:20.128]                         if (!is.null(pattern)) {
[16:05:20.128]                           computeRestarts <- base::computeRestarts
[16:05:20.128]                           grepl <- base::grepl
[16:05:20.128]                           restarts <- computeRestarts(cond)
[16:05:20.128]                           for (restart in restarts) {
[16:05:20.128]                             name <- restart$name
[16:05:20.128]                             if (is.null(name)) 
[16:05:20.128]                               next
[16:05:20.128]                             if (!grepl(pattern, name)) 
[16:05:20.128]                               next
[16:05:20.128]                             invokeRestart(restart)
[16:05:20.128]                             muffled <- TRUE
[16:05:20.128]                             break
[16:05:20.128]                           }
[16:05:20.128]                         }
[16:05:20.128]                       }
[16:05:20.128]                       invisible(muffled)
[16:05:20.128]                     }
[16:05:20.128]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.128]                   }
[16:05:20.128]                 }
[16:05:20.128]             }
[16:05:20.128]         }))
[16:05:20.128]     }, error = function(ex) {
[16:05:20.128]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:20.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.128]                 ...future.rng), started = ...future.startTime, 
[16:05:20.128]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:20.128]             version = "1.8"), class = "FutureResult")
[16:05:20.128]     }, finally = {
[16:05:20.128]         if (!identical(...future.workdir, getwd())) 
[16:05:20.128]             setwd(...future.workdir)
[16:05:20.128]         {
[16:05:20.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:20.128]                 ...future.oldOptions$nwarnings <- NULL
[16:05:20.128]             }
[16:05:20.128]             base::options(...future.oldOptions)
[16:05:20.128]             if (.Platform$OS.type == "windows") {
[16:05:20.128]                 old_names <- names(...future.oldEnvVars)
[16:05:20.128]                 envs <- base::Sys.getenv()
[16:05:20.128]                 names <- names(envs)
[16:05:20.128]                 common <- intersect(names, old_names)
[16:05:20.128]                 added <- setdiff(names, old_names)
[16:05:20.128]                 removed <- setdiff(old_names, names)
[16:05:20.128]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:20.128]                   envs[common]]
[16:05:20.128]                 NAMES <- toupper(changed)
[16:05:20.128]                 args <- list()
[16:05:20.128]                 for (kk in seq_along(NAMES)) {
[16:05:20.128]                   name <- changed[[kk]]
[16:05:20.128]                   NAME <- NAMES[[kk]]
[16:05:20.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.128]                     next
[16:05:20.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.128]                 }
[16:05:20.128]                 NAMES <- toupper(added)
[16:05:20.128]                 for (kk in seq_along(NAMES)) {
[16:05:20.128]                   name <- added[[kk]]
[16:05:20.128]                   NAME <- NAMES[[kk]]
[16:05:20.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.128]                     next
[16:05:20.128]                   args[[name]] <- ""
[16:05:20.128]                 }
[16:05:20.128]                 NAMES <- toupper(removed)
[16:05:20.128]                 for (kk in seq_along(NAMES)) {
[16:05:20.128]                   name <- removed[[kk]]
[16:05:20.128]                   NAME <- NAMES[[kk]]
[16:05:20.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.128]                     next
[16:05:20.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.128]                 }
[16:05:20.128]                 if (length(args) > 0) 
[16:05:20.128]                   base::do.call(base::Sys.setenv, args = args)
[16:05:20.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:20.128]             }
[16:05:20.128]             else {
[16:05:20.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:20.128]             }
[16:05:20.128]             {
[16:05:20.128]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:20.128]                   0L) {
[16:05:20.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:20.128]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:20.128]                   base::options(opts)
[16:05:20.128]                 }
[16:05:20.128]                 {
[16:05:20.128]                   {
[16:05:20.128]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:20.128]                     NULL
[16:05:20.128]                   }
[16:05:20.128]                   options(future.plan = NULL)
[16:05:20.128]                   if (is.na(NA_character_)) 
[16:05:20.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:20.128]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:20.128]                     envir = parent.frame()) 
[16:05:20.128]                   {
[16:05:20.128]                     default_workers <- missing(workers)
[16:05:20.128]                     if (is.function(workers)) 
[16:05:20.128]                       workers <- workers()
[16:05:20.128]                     workers <- structure(as.integer(workers), 
[16:05:20.128]                       class = class(workers))
[16:05:20.128]                     stop_if_not(is.finite(workers), workers >= 
[16:05:20.128]                       1L)
[16:05:20.128]                     if ((workers == 1L && !inherits(workers, 
[16:05:20.128]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:20.128]                       if (default_workers) 
[16:05:20.128]                         supportsMulticore(warn = TRUE)
[16:05:20.128]                       return(sequential(..., envir = envir))
[16:05:20.128]                     }
[16:05:20.128]                     oopts <- options(mc.cores = workers)
[16:05:20.128]                     on.exit(options(oopts))
[16:05:20.128]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:20.128]                       envir = envir)
[16:05:20.128]                     if (!future$lazy) 
[16:05:20.128]                       future <- run(future)
[16:05:20.128]                     invisible(future)
[16:05:20.128]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:20.128]                 }
[16:05:20.128]             }
[16:05:20.128]         }
[16:05:20.128]     })
[16:05:20.128]     if (TRUE) {
[16:05:20.128]         base::sink(type = "output", split = FALSE)
[16:05:20.128]         if (TRUE) {
[16:05:20.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:20.128]         }
[16:05:20.128]         else {
[16:05:20.128]             ...future.result["stdout"] <- base::list(NULL)
[16:05:20.128]         }
[16:05:20.128]         base::close(...future.stdout)
[16:05:20.128]         ...future.stdout <- NULL
[16:05:20.128]     }
[16:05:20.128]     ...future.result$conditions <- ...future.conditions
[16:05:20.128]     ...future.result$finished <- base::Sys.time()
[16:05:20.128]     ...future.result
[16:05:20.128] }
[16:05:20.131] requestCore(): workers = 2
[16:05:20.132] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:05:20.134] plan(): Setting new future strategy stack:
[16:05:20.134] List of future strategies:
[16:05:20.134] 1. sequential:
[16:05:20.134]    - args: function (..., envir = parent.frame())
[16:05:20.134]    - tweaked: FALSE
[16:05:20.134]    - call: NULL
[16:05:20.135] plan(): nbrOfWorkers() = 1
[16:05:20.137] plan(): Setting new future strategy stack:
[16:05:20.137] List of future strategies:
[16:05:20.137] 1. multicore:
[16:05:20.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.137]    - tweaked: FALSE
[16:05:20.137]    - call: plan(multicore)
[16:05:20.142] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 6602cdc8-9c7a-3792-3342-1678246f87da
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:20.144] result() for MulticoreFuture ...
[16:05:20.146] result() for MulticoreFuture ...
[16:05:20.146] result() for MulticoreFuture ... done
[16:05:20.146] signalConditions() ...
[16:05:20.147]  - include = ‘immediateCondition’
[16:05:20.147]  - exclude = 
[16:05:20.147]  - resignal = FALSE
[16:05:20.147]  - Number of conditions: 1
[16:05:20.147] signalConditions() ... done
[16:05:20.147] result() for MulticoreFuture ... done
[16:05:20.147] result() for MulticoreFuture ...
[16:05:20.147] result() for MulticoreFuture ... done
[16:05:20.148] signalConditions() ...
[16:05:20.148]  - include = ‘immediateCondition’
[16:05:20.148]  - exclude = 
[16:05:20.148]  - resignal = FALSE
[16:05:20.148]  - Number of conditions: 1
[16:05:20.148] signalConditions() ... done
<MyError: boom>
[16:05:20.148] result() for MulticoreFuture ...
[16:05:20.148] result() for MulticoreFuture ... done
[16:05:20.149] result() for MulticoreFuture ...
[16:05:20.149] result() for MulticoreFuture ... done
[16:05:20.149] signalConditions() ...
[16:05:20.149]  - include = ‘immediateCondition’
[16:05:20.149]  - exclude = 
[16:05:20.149]  - resignal = FALSE
[16:05:20.149]  - Number of conditions: 1
[16:05:20.149] signalConditions() ... done
[16:05:20.149] Future state: ‘finished’
[16:05:20.150] result() for MulticoreFuture ...
[16:05:20.150] result() for MulticoreFuture ... done
[16:05:20.150] signalConditions() ...
[16:05:20.150]  - include = ‘condition’
[16:05:20.150]  - exclude = ‘immediateCondition’
[16:05:20.150]  - resignal = TRUE
[16:05:20.150]  - Number of conditions: 1
[16:05:20.150]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[16:05:20.150] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[16:05:20.151] getGlobalsAndPackages() ...
[16:05:20.151] Searching for globals...
[16:05:20.152] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[16:05:20.152] Searching for globals ... DONE
[16:05:20.152] Resolving globals: FALSE
[16:05:20.153] The total size of the 2 globals is 112 bytes (112 bytes)
[16:05:20.157] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[16:05:20.157] - globals: [2] ‘a’, ‘b’
[16:05:20.157] 
[16:05:20.157] getGlobalsAndPackages() ... DONE
[16:05:20.157] Packages needed by the future expression (n = 0): <none>
[16:05:20.158] Packages needed by future strategies (n = 0): <none>
[16:05:20.158] {
[16:05:20.158]     {
[16:05:20.158]         {
[16:05:20.158]             ...future.startTime <- base::Sys.time()
[16:05:20.158]             {
[16:05:20.158]                 {
[16:05:20.158]                   {
[16:05:20.158]                     base::local({
[16:05:20.158]                       has_future <- base::requireNamespace("future", 
[16:05:20.158]                         quietly = TRUE)
[16:05:20.158]                       if (has_future) {
[16:05:20.158]                         ns <- base::getNamespace("future")
[16:05:20.158]                         version <- ns[[".package"]][["version"]]
[16:05:20.158]                         if (is.null(version)) 
[16:05:20.158]                           version <- utils::packageVersion("future")
[16:05:20.158]                       }
[16:05:20.158]                       else {
[16:05:20.158]                         version <- NULL
[16:05:20.158]                       }
[16:05:20.158]                       if (!has_future || version < "1.8.0") {
[16:05:20.158]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:20.158]                           "", base::R.version$version.string), 
[16:05:20.158]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:20.158]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:20.158]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:20.158]                             "release", "version")], collapse = " "), 
[16:05:20.158]                           hostname = base::Sys.info()[["nodename"]])
[16:05:20.158]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:20.158]                           info)
[16:05:20.158]                         info <- base::paste(info, collapse = "; ")
[16:05:20.158]                         if (!has_future) {
[16:05:20.158]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:20.158]                             info)
[16:05:20.158]                         }
[16:05:20.158]                         else {
[16:05:20.158]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:20.158]                             info, version)
[16:05:20.158]                         }
[16:05:20.158]                         base::stop(msg)
[16:05:20.158]                       }
[16:05:20.158]                     })
[16:05:20.158]                   }
[16:05:20.158]                   options(future.plan = NULL)
[16:05:20.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:20.158]                 }
[16:05:20.158]                 ...future.workdir <- getwd()
[16:05:20.158]             }
[16:05:20.158]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:20.158]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:20.158]         }
[16:05:20.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:20.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:20.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:20.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:20.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:20.158]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:20.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:20.158]             base::names(...future.oldOptions))
[16:05:20.158]     }
[16:05:20.158]     if (FALSE) {
[16:05:20.158]     }
[16:05:20.158]     else {
[16:05:20.158]         if (TRUE) {
[16:05:20.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:20.158]                 open = "w")
[16:05:20.158]         }
[16:05:20.158]         else {
[16:05:20.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:20.158]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:20.158]         }
[16:05:20.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:20.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:20.158]             base::sink(type = "output", split = FALSE)
[16:05:20.158]             base::close(...future.stdout)
[16:05:20.158]         }, add = TRUE)
[16:05:20.158]     }
[16:05:20.158]     ...future.frame <- base::sys.nframe()
[16:05:20.158]     ...future.conditions <- base::list()
[16:05:20.158]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:20.158]     if (FALSE) {
[16:05:20.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:20.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:20.158]     }
[16:05:20.158]     ...future.result <- base::tryCatch({
[16:05:20.158]         base::withCallingHandlers({
[16:05:20.158]             ...future.value <- base::withVisible(base::local({
[16:05:20.158]                 a * b
[16:05:20.158]             }))
[16:05:20.158]             future::FutureResult(value = ...future.value$value, 
[16:05:20.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.158]                   ...future.rng), globalenv = if (FALSE) 
[16:05:20.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:20.158]                     ...future.globalenv.names))
[16:05:20.158]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:20.158]         }, condition = base::local({
[16:05:20.158]             c <- base::c
[16:05:20.158]             inherits <- base::inherits
[16:05:20.158]             invokeRestart <- base::invokeRestart
[16:05:20.158]             length <- base::length
[16:05:20.158]             list <- base::list
[16:05:20.158]             seq.int <- base::seq.int
[16:05:20.158]             signalCondition <- base::signalCondition
[16:05:20.158]             sys.calls <- base::sys.calls
[16:05:20.158]             `[[` <- base::`[[`
[16:05:20.158]             `+` <- base::`+`
[16:05:20.158]             `<<-` <- base::`<<-`
[16:05:20.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:20.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:20.158]                   3L)]
[16:05:20.158]             }
[16:05:20.158]             function(cond) {
[16:05:20.158]                 is_error <- inherits(cond, "error")
[16:05:20.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:20.158]                   NULL)
[16:05:20.158]                 if (is_error) {
[16:05:20.158]                   sessionInformation <- function() {
[16:05:20.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:20.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:20.158]                       search = base::search(), system = base::Sys.info())
[16:05:20.158]                   }
[16:05:20.158]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:20.158]                     cond$call), session = sessionInformation(), 
[16:05:20.158]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:20.158]                   signalCondition(cond)
[16:05:20.158]                 }
[16:05:20.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:20.158]                 "immediateCondition"))) {
[16:05:20.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:20.158]                   ...future.conditions[[length(...future.conditions) + 
[16:05:20.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:20.158]                   if (TRUE && !signal) {
[16:05:20.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.158]                     {
[16:05:20.158]                       inherits <- base::inherits
[16:05:20.158]                       invokeRestart <- base::invokeRestart
[16:05:20.158]                       is.null <- base::is.null
[16:05:20.158]                       muffled <- FALSE
[16:05:20.158]                       if (inherits(cond, "message")) {
[16:05:20.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.158]                         if (muffled) 
[16:05:20.158]                           invokeRestart("muffleMessage")
[16:05:20.158]                       }
[16:05:20.158]                       else if (inherits(cond, "warning")) {
[16:05:20.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.158]                         if (muffled) 
[16:05:20.158]                           invokeRestart("muffleWarning")
[16:05:20.158]                       }
[16:05:20.158]                       else if (inherits(cond, "condition")) {
[16:05:20.158]                         if (!is.null(pattern)) {
[16:05:20.158]                           computeRestarts <- base::computeRestarts
[16:05:20.158]                           grepl <- base::grepl
[16:05:20.158]                           restarts <- computeRestarts(cond)
[16:05:20.158]                           for (restart in restarts) {
[16:05:20.158]                             name <- restart$name
[16:05:20.158]                             if (is.null(name)) 
[16:05:20.158]                               next
[16:05:20.158]                             if (!grepl(pattern, name)) 
[16:05:20.158]                               next
[16:05:20.158]                             invokeRestart(restart)
[16:05:20.158]                             muffled <- TRUE
[16:05:20.158]                             break
[16:05:20.158]                           }
[16:05:20.158]                         }
[16:05:20.158]                       }
[16:05:20.158]                       invisible(muffled)
[16:05:20.158]                     }
[16:05:20.158]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.158]                   }
[16:05:20.158]                 }
[16:05:20.158]                 else {
[16:05:20.158]                   if (TRUE) {
[16:05:20.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:20.158]                     {
[16:05:20.158]                       inherits <- base::inherits
[16:05:20.158]                       invokeRestart <- base::invokeRestart
[16:05:20.158]                       is.null <- base::is.null
[16:05:20.158]                       muffled <- FALSE
[16:05:20.158]                       if (inherits(cond, "message")) {
[16:05:20.158]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:20.158]                         if (muffled) 
[16:05:20.158]                           invokeRestart("muffleMessage")
[16:05:20.158]                       }
[16:05:20.158]                       else if (inherits(cond, "warning")) {
[16:05:20.158]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:20.158]                         if (muffled) 
[16:05:20.158]                           invokeRestart("muffleWarning")
[16:05:20.158]                       }
[16:05:20.158]                       else if (inherits(cond, "condition")) {
[16:05:20.158]                         if (!is.null(pattern)) {
[16:05:20.158]                           computeRestarts <- base::computeRestarts
[16:05:20.158]                           grepl <- base::grepl
[16:05:20.158]                           restarts <- computeRestarts(cond)
[16:05:20.158]                           for (restart in restarts) {
[16:05:20.158]                             name <- restart$name
[16:05:20.158]                             if (is.null(name)) 
[16:05:20.158]                               next
[16:05:20.158]                             if (!grepl(pattern, name)) 
[16:05:20.158]                               next
[16:05:20.158]                             invokeRestart(restart)
[16:05:20.158]                             muffled <- TRUE
[16:05:20.158]                             break
[16:05:20.158]                           }
[16:05:20.158]                         }
[16:05:20.158]                       }
[16:05:20.158]                       invisible(muffled)
[16:05:20.158]                     }
[16:05:20.158]                     muffleCondition(cond, pattern = "^muffle")
[16:05:20.158]                   }
[16:05:20.158]                 }
[16:05:20.158]             }
[16:05:20.158]         }))
[16:05:20.158]     }, error = function(ex) {
[16:05:20.158]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:20.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:20.158]                 ...future.rng), started = ...future.startTime, 
[16:05:20.158]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:20.158]             version = "1.8"), class = "FutureResult")
[16:05:20.158]     }, finally = {
[16:05:20.158]         if (!identical(...future.workdir, getwd())) 
[16:05:20.158]             setwd(...future.workdir)
[16:05:20.158]         {
[16:05:20.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:20.158]                 ...future.oldOptions$nwarnings <- NULL
[16:05:20.158]             }
[16:05:20.158]             base::options(...future.oldOptions)
[16:05:20.158]             if (.Platform$OS.type == "windows") {
[16:05:20.158]                 old_names <- names(...future.oldEnvVars)
[16:05:20.158]                 envs <- base::Sys.getenv()
[16:05:20.158]                 names <- names(envs)
[16:05:20.158]                 common <- intersect(names, old_names)
[16:05:20.158]                 added <- setdiff(names, old_names)
[16:05:20.158]                 removed <- setdiff(old_names, names)
[16:05:20.158]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:20.158]                   envs[common]]
[16:05:20.158]                 NAMES <- toupper(changed)
[16:05:20.158]                 args <- list()
[16:05:20.158]                 for (kk in seq_along(NAMES)) {
[16:05:20.158]                   name <- changed[[kk]]
[16:05:20.158]                   NAME <- NAMES[[kk]]
[16:05:20.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.158]                     next
[16:05:20.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.158]                 }
[16:05:20.158]                 NAMES <- toupper(added)
[16:05:20.158]                 for (kk in seq_along(NAMES)) {
[16:05:20.158]                   name <- added[[kk]]
[16:05:20.158]                   NAME <- NAMES[[kk]]
[16:05:20.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.158]                     next
[16:05:20.158]                   args[[name]] <- ""
[16:05:20.158]                 }
[16:05:20.158]                 NAMES <- toupper(removed)
[16:05:20.158]                 for (kk in seq_along(NAMES)) {
[16:05:20.158]                   name <- removed[[kk]]
[16:05:20.158]                   NAME <- NAMES[[kk]]
[16:05:20.158]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:20.158]                     next
[16:05:20.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:20.158]                 }
[16:05:20.158]                 if (length(args) > 0) 
[16:05:20.158]                   base::do.call(base::Sys.setenv, args = args)
[16:05:20.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:20.158]             }
[16:05:20.158]             else {
[16:05:20.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:20.158]             }
[16:05:20.158]             {
[16:05:20.158]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:20.158]                   0L) {
[16:05:20.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:20.158]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:20.158]                   base::options(opts)
[16:05:20.158]                 }
[16:05:20.158]                 {
[16:05:20.158]                   {
[16:05:20.158]                     NULL
[16:05:20.158]                     RNGkind("Mersenne-Twister")
[16:05:20.158]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:20.158]                       inherits = FALSE)
[16:05:20.158]                   }
[16:05:20.158]                   options(future.plan = NULL)
[16:05:20.158]                   if (is.na(NA_character_)) 
[16:05:20.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:20.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:20.158]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:20.158]                     envir = parent.frame()) 
[16:05:20.158]                   {
[16:05:20.158]                     default_workers <- missing(workers)
[16:05:20.158]                     if (is.function(workers)) 
[16:05:20.158]                       workers <- workers()
[16:05:20.158]                     workers <- structure(as.integer(workers), 
[16:05:20.158]                       class = class(workers))
[16:05:20.158]                     stop_if_not(is.finite(workers), workers >= 
[16:05:20.158]                       1L)
[16:05:20.158]                     if ((workers == 1L && !inherits(workers, 
[16:05:20.158]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:20.158]                       if (default_workers) 
[16:05:20.158]                         supportsMulticore(warn = TRUE)
[16:05:20.158]                       return(sequential(..., envir = envir))
[16:05:20.158]                     }
[16:05:20.158]                     oopts <- options(mc.cores = workers)
[16:05:20.158]                     on.exit(options(oopts))
[16:05:20.158]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:20.158]                       envir = envir)
[16:05:20.158]                     if (!future$lazy) 
[16:05:20.158]                       future <- run(future)
[16:05:20.158]                     invisible(future)
[16:05:20.158]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:20.158]                 }
[16:05:20.158]             }
[16:05:20.158]         }
[16:05:20.158]     })
[16:05:20.158]     if (TRUE) {
[16:05:20.158]         base::sink(type = "output", split = FALSE)
[16:05:20.158]         if (TRUE) {
[16:05:20.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:20.158]         }
[16:05:20.158]         else {
[16:05:20.158]             ...future.result["stdout"] <- base::list(NULL)
[16:05:20.158]         }
[16:05:20.158]         base::close(...future.stdout)
[16:05:20.158]         ...future.stdout <- NULL
[16:05:20.158]     }
[16:05:20.158]     ...future.result$conditions <- ...future.conditions
[16:05:20.158]     ...future.result$finished <- base::Sys.time()
[16:05:20.158]     ...future.result
[16:05:20.158] }
[16:05:20.160] assign_globals() ...
[16:05:20.160] List of 2
[16:05:20.160]  $ a: num 2
[16:05:20.160]  $ b: num 3
[16:05:20.160]  - attr(*, "where")=List of 2
[16:05:20.160]   ..$ a:<environment: R_EmptyEnv> 
[16:05:20.160]   ..$ b:<environment: R_EmptyEnv> 
[16:05:20.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:20.160]  - attr(*, "resolved")= logi FALSE
[16:05:20.160]  - attr(*, "total_size")= num 112
[16:05:20.164] - copied ‘a’ to environment
[16:05:20.164] - copied ‘b’ to environment
[16:05:20.164] assign_globals() ... done
[16:05:20.164] plan(): Setting new future strategy stack:
[16:05:20.164] List of future strategies:
[16:05:20.164] 1. sequential:
[16:05:20.164]    - args: function (..., envir = parent.frame())
[16:05:20.164]    - tweaked: FALSE
[16:05:20.164]    - call: NULL
[16:05:20.165] plan(): nbrOfWorkers() = 1
[16:05:20.166] plan(): Setting new future strategy stack:
[16:05:20.166] List of future strategies:
[16:05:20.166] 1. multicore:
[16:05:20.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:20.166]    - tweaked: FALSE
[16:05:20.166]    - call: plan(multicore)
[16:05:20.170] plan(): nbrOfWorkers() = 2
[16:05:20.170] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[16:05:20.171] plan(): Setting new future strategy stack:
[16:05:20.171] List of future strategies:
[16:05:20.171] 1. FutureStrategy:
[16:05:20.171]    - args: function (..., envir = parent.frame())
[16:05:20.171]    - tweaked: FALSE
[16:05:20.171]    - call: future::plan(oplan)
[16:05:20.171] plan(): nbrOfWorkers() = 1
> 
