
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:23:45.218] plan(): Setting new future strategy stack:
[13:23:45.219] List of future strategies:
[13:23:45.219] 1. sequential:
[13:23:45.219]    - args: function (..., envir = parent.frame())
[13:23:45.219]    - tweaked: FALSE
[13:23:45.219]    - call: future::plan("sequential")
[13:23:45.234] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[13:23:45.247] plan(): Setting new future strategy stack:
[13:23:45.247] List of future strategies:
[13:23:45.247] 1. multicore:
[13:23:45.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.247]    - tweaked: FALSE
[13:23:45.247]    - call: plan(multicore)
[13:23:45.262] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[13:23:45.320] getGlobalsAndPackages() ...
[13:23:45.320] Not searching for globals
[13:23:45.320] - globals: [0] <none>
[13:23:45.320] getGlobalsAndPackages() ... DONE
[13:23:45.322] Packages needed by the future expression (n = 0): <none>
[13:23:45.322] Packages needed by future strategies (n = 0): <none>
[13:23:45.322] {
[13:23:45.322]     {
[13:23:45.322]         {
[13:23:45.322]             ...future.startTime <- base::Sys.time()
[13:23:45.322]             {
[13:23:45.322]                 {
[13:23:45.322]                   {
[13:23:45.322]                     base::local({
[13:23:45.322]                       has_future <- base::requireNamespace("future", 
[13:23:45.322]                         quietly = TRUE)
[13:23:45.322]                       if (has_future) {
[13:23:45.322]                         ns <- base::getNamespace("future")
[13:23:45.322]                         version <- ns[[".package"]][["version"]]
[13:23:45.322]                         if (is.null(version)) 
[13:23:45.322]                           version <- utils::packageVersion("future")
[13:23:45.322]                       }
[13:23:45.322]                       else {
[13:23:45.322]                         version <- NULL
[13:23:45.322]                       }
[13:23:45.322]                       if (!has_future || version < "1.8.0") {
[13:23:45.322]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.322]                           "", base::R.version$version.string), 
[13:23:45.322]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.322]                             "release", "version")], collapse = " "), 
[13:23:45.322]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.322]                           info)
[13:23:45.322]                         info <- base::paste(info, collapse = "; ")
[13:23:45.322]                         if (!has_future) {
[13:23:45.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.322]                             info)
[13:23:45.322]                         }
[13:23:45.322]                         else {
[13:23:45.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.322]                             info, version)
[13:23:45.322]                         }
[13:23:45.322]                         base::stop(msg)
[13:23:45.322]                       }
[13:23:45.322]                     })
[13:23:45.322]                   }
[13:23:45.322]                   options(future.plan = NULL)
[13:23:45.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.322]                 }
[13:23:45.322]                 ...future.workdir <- getwd()
[13:23:45.322]             }
[13:23:45.322]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.322]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.322]         }
[13:23:45.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.322]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.322]             base::names(...future.oldOptions))
[13:23:45.322]     }
[13:23:45.322]     if (FALSE) {
[13:23:45.322]     }
[13:23:45.322]     else {
[13:23:45.322]         if (TRUE) {
[13:23:45.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.322]                 open = "w")
[13:23:45.322]         }
[13:23:45.322]         else {
[13:23:45.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.322]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.322]         }
[13:23:45.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.322]             base::sink(type = "output", split = FALSE)
[13:23:45.322]             base::close(...future.stdout)
[13:23:45.322]         }, add = TRUE)
[13:23:45.322]     }
[13:23:45.322]     ...future.frame <- base::sys.nframe()
[13:23:45.322]     ...future.conditions <- base::list()
[13:23:45.322]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.322]     if (FALSE) {
[13:23:45.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.322]     }
[13:23:45.322]     ...future.result <- base::tryCatch({
[13:23:45.322]         base::withCallingHandlers({
[13:23:45.322]             ...future.value <- base::withVisible(base::local({
[13:23:45.322]                 42L
[13:23:45.322]             }))
[13:23:45.322]             future::FutureResult(value = ...future.value$value, 
[13:23:45.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.322]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.322]                     ...future.globalenv.names))
[13:23:45.322]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.322]         }, condition = base::local({
[13:23:45.322]             c <- base::c
[13:23:45.322]             inherits <- base::inherits
[13:23:45.322]             invokeRestart <- base::invokeRestart
[13:23:45.322]             length <- base::length
[13:23:45.322]             list <- base::list
[13:23:45.322]             seq.int <- base::seq.int
[13:23:45.322]             signalCondition <- base::signalCondition
[13:23:45.322]             sys.calls <- base::sys.calls
[13:23:45.322]             `[[` <- base::`[[`
[13:23:45.322]             `+` <- base::`+`
[13:23:45.322]             `<<-` <- base::`<<-`
[13:23:45.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.322]                   3L)]
[13:23:45.322]             }
[13:23:45.322]             function(cond) {
[13:23:45.322]                 is_error <- inherits(cond, "error")
[13:23:45.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.322]                   NULL)
[13:23:45.322]                 if (is_error) {
[13:23:45.322]                   sessionInformation <- function() {
[13:23:45.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.322]                       search = base::search(), system = base::Sys.info())
[13:23:45.322]                   }
[13:23:45.322]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.322]                     cond$call), session = sessionInformation(), 
[13:23:45.322]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.322]                   signalCondition(cond)
[13:23:45.322]                 }
[13:23:45.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.322]                 "immediateCondition"))) {
[13:23:45.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.322]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.322]                   if (TRUE && !signal) {
[13:23:45.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.322]                     {
[13:23:45.322]                       inherits <- base::inherits
[13:23:45.322]                       invokeRestart <- base::invokeRestart
[13:23:45.322]                       is.null <- base::is.null
[13:23:45.322]                       muffled <- FALSE
[13:23:45.322]                       if (inherits(cond, "message")) {
[13:23:45.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.322]                         if (muffled) 
[13:23:45.322]                           invokeRestart("muffleMessage")
[13:23:45.322]                       }
[13:23:45.322]                       else if (inherits(cond, "warning")) {
[13:23:45.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.322]                         if (muffled) 
[13:23:45.322]                           invokeRestart("muffleWarning")
[13:23:45.322]                       }
[13:23:45.322]                       else if (inherits(cond, "condition")) {
[13:23:45.322]                         if (!is.null(pattern)) {
[13:23:45.322]                           computeRestarts <- base::computeRestarts
[13:23:45.322]                           grepl <- base::grepl
[13:23:45.322]                           restarts <- computeRestarts(cond)
[13:23:45.322]                           for (restart in restarts) {
[13:23:45.322]                             name <- restart$name
[13:23:45.322]                             if (is.null(name)) 
[13:23:45.322]                               next
[13:23:45.322]                             if (!grepl(pattern, name)) 
[13:23:45.322]                               next
[13:23:45.322]                             invokeRestart(restart)
[13:23:45.322]                             muffled <- TRUE
[13:23:45.322]                             break
[13:23:45.322]                           }
[13:23:45.322]                         }
[13:23:45.322]                       }
[13:23:45.322]                       invisible(muffled)
[13:23:45.322]                     }
[13:23:45.322]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.322]                   }
[13:23:45.322]                 }
[13:23:45.322]                 else {
[13:23:45.322]                   if (TRUE) {
[13:23:45.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.322]                     {
[13:23:45.322]                       inherits <- base::inherits
[13:23:45.322]                       invokeRestart <- base::invokeRestart
[13:23:45.322]                       is.null <- base::is.null
[13:23:45.322]                       muffled <- FALSE
[13:23:45.322]                       if (inherits(cond, "message")) {
[13:23:45.322]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.322]                         if (muffled) 
[13:23:45.322]                           invokeRestart("muffleMessage")
[13:23:45.322]                       }
[13:23:45.322]                       else if (inherits(cond, "warning")) {
[13:23:45.322]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.322]                         if (muffled) 
[13:23:45.322]                           invokeRestart("muffleWarning")
[13:23:45.322]                       }
[13:23:45.322]                       else if (inherits(cond, "condition")) {
[13:23:45.322]                         if (!is.null(pattern)) {
[13:23:45.322]                           computeRestarts <- base::computeRestarts
[13:23:45.322]                           grepl <- base::grepl
[13:23:45.322]                           restarts <- computeRestarts(cond)
[13:23:45.322]                           for (restart in restarts) {
[13:23:45.322]                             name <- restart$name
[13:23:45.322]                             if (is.null(name)) 
[13:23:45.322]                               next
[13:23:45.322]                             if (!grepl(pattern, name)) 
[13:23:45.322]                               next
[13:23:45.322]                             invokeRestart(restart)
[13:23:45.322]                             muffled <- TRUE
[13:23:45.322]                             break
[13:23:45.322]                           }
[13:23:45.322]                         }
[13:23:45.322]                       }
[13:23:45.322]                       invisible(muffled)
[13:23:45.322]                     }
[13:23:45.322]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.322]                   }
[13:23:45.322]                 }
[13:23:45.322]             }
[13:23:45.322]         }))
[13:23:45.322]     }, error = function(ex) {
[13:23:45.322]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.322]                 ...future.rng), started = ...future.startTime, 
[13:23:45.322]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.322]             version = "1.8"), class = "FutureResult")
[13:23:45.322]     }, finally = {
[13:23:45.322]         if (!identical(...future.workdir, getwd())) 
[13:23:45.322]             setwd(...future.workdir)
[13:23:45.322]         {
[13:23:45.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.322]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.322]             }
[13:23:45.322]             base::options(...future.oldOptions)
[13:23:45.322]             if (.Platform$OS.type == "windows") {
[13:23:45.322]                 old_names <- names(...future.oldEnvVars)
[13:23:45.322]                 envs <- base::Sys.getenv()
[13:23:45.322]                 names <- names(envs)
[13:23:45.322]                 common <- intersect(names, old_names)
[13:23:45.322]                 added <- setdiff(names, old_names)
[13:23:45.322]                 removed <- setdiff(old_names, names)
[13:23:45.322]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.322]                   envs[common]]
[13:23:45.322]                 NAMES <- toupper(changed)
[13:23:45.322]                 args <- list()
[13:23:45.322]                 for (kk in seq_along(NAMES)) {
[13:23:45.322]                   name <- changed[[kk]]
[13:23:45.322]                   NAME <- NAMES[[kk]]
[13:23:45.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.322]                     next
[13:23:45.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.322]                 }
[13:23:45.322]                 NAMES <- toupper(added)
[13:23:45.322]                 for (kk in seq_along(NAMES)) {
[13:23:45.322]                   name <- added[[kk]]
[13:23:45.322]                   NAME <- NAMES[[kk]]
[13:23:45.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.322]                     next
[13:23:45.322]                   args[[name]] <- ""
[13:23:45.322]                 }
[13:23:45.322]                 NAMES <- toupper(removed)
[13:23:45.322]                 for (kk in seq_along(NAMES)) {
[13:23:45.322]                   name <- removed[[kk]]
[13:23:45.322]                   NAME <- NAMES[[kk]]
[13:23:45.322]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.322]                     next
[13:23:45.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.322]                 }
[13:23:45.322]                 if (length(args) > 0) 
[13:23:45.322]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.322]             }
[13:23:45.322]             else {
[13:23:45.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.322]             }
[13:23:45.322]             {
[13:23:45.322]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.322]                   0L) {
[13:23:45.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.322]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.322]                   base::options(opts)
[13:23:45.322]                 }
[13:23:45.322]                 {
[13:23:45.322]                   {
[13:23:45.322]                     NULL
[13:23:45.322]                     RNGkind("Mersenne-Twister")
[13:23:45.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.322]                       inherits = FALSE)
[13:23:45.322]                   }
[13:23:45.322]                   options(future.plan = NULL)
[13:23:45.322]                   if (is.na(NA_character_)) 
[13:23:45.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.322]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.322]                     envir = parent.frame()) 
[13:23:45.322]                   {
[13:23:45.322]                     default_workers <- missing(workers)
[13:23:45.322]                     if (is.function(workers)) 
[13:23:45.322]                       workers <- workers()
[13:23:45.322]                     workers <- structure(as.integer(workers), 
[13:23:45.322]                       class = class(workers))
[13:23:45.322]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.322]                       1L)
[13:23:45.322]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.322]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.322]                       if (default_workers) 
[13:23:45.322]                         supportsMulticore(warn = TRUE)
[13:23:45.322]                       return(sequential(..., envir = envir))
[13:23:45.322]                     }
[13:23:45.322]                     oopts <- options(mc.cores = workers)
[13:23:45.322]                     on.exit(options(oopts))
[13:23:45.322]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.322]                       envir = envir)
[13:23:45.322]                     if (!future$lazy) 
[13:23:45.322]                       future <- run(future)
[13:23:45.322]                     invisible(future)
[13:23:45.322]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.322]                 }
[13:23:45.322]             }
[13:23:45.322]         }
[13:23:45.322]     })
[13:23:45.322]     if (TRUE) {
[13:23:45.322]         base::sink(type = "output", split = FALSE)
[13:23:45.322]         if (TRUE) {
[13:23:45.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.322]         }
[13:23:45.322]         else {
[13:23:45.322]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.322]         }
[13:23:45.322]         base::close(...future.stdout)
[13:23:45.322]         ...future.stdout <- NULL
[13:23:45.322]     }
[13:23:45.322]     ...future.result$conditions <- ...future.conditions
[13:23:45.322]     ...future.result$finished <- base::Sys.time()
[13:23:45.322]     ...future.result
[13:23:45.322] }
[13:23:45.325] plan(): Setting new future strategy stack:
[13:23:45.325] List of future strategies:
[13:23:45.325] 1. sequential:
[13:23:45.325]    - args: function (..., envir = parent.frame())
[13:23:45.325]    - tweaked: FALSE
[13:23:45.325]    - call: NULL
[13:23:45.325] plan(): nbrOfWorkers() = 1
[13:23:45.326] plan(): Setting new future strategy stack:
[13:23:45.326] List of future strategies:
[13:23:45.326] 1. multicore:
[13:23:45.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.326]    - tweaked: FALSE
[13:23:45.326]    - call: plan(multicore)
[13:23:45.330] plan(): nbrOfWorkers() = 1
[13:23:45.330] SequentialFuture started (and completed)
[13:23:45.331] resolved() for ‘SequentialFuture’ ...
[13:23:45.331] - state: ‘finished’
[13:23:45.331] - run: TRUE
[13:23:45.331] - result: ‘FutureResult’
[13:23:45.331] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[13:23:45.335] getGlobalsAndPackages() ...
[13:23:45.335] Not searching for globals
[13:23:45.335] - globals: [0] <none>
[13:23:45.335] getGlobalsAndPackages() ... DONE
[13:23:45.336] Packages needed by the future expression (n = 0): <none>
[13:23:45.336] Packages needed by future strategies (n = 0): <none>
[13:23:45.336] {
[13:23:45.336]     {
[13:23:45.336]         {
[13:23:45.336]             ...future.startTime <- base::Sys.time()
[13:23:45.336]             {
[13:23:45.336]                 {
[13:23:45.336]                   {
[13:23:45.336]                     base::local({
[13:23:45.336]                       has_future <- base::requireNamespace("future", 
[13:23:45.336]                         quietly = TRUE)
[13:23:45.336]                       if (has_future) {
[13:23:45.336]                         ns <- base::getNamespace("future")
[13:23:45.336]                         version <- ns[[".package"]][["version"]]
[13:23:45.336]                         if (is.null(version)) 
[13:23:45.336]                           version <- utils::packageVersion("future")
[13:23:45.336]                       }
[13:23:45.336]                       else {
[13:23:45.336]                         version <- NULL
[13:23:45.336]                       }
[13:23:45.336]                       if (!has_future || version < "1.8.0") {
[13:23:45.336]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.336]                           "", base::R.version$version.string), 
[13:23:45.336]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.336]                             "release", "version")], collapse = " "), 
[13:23:45.336]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.336]                           info)
[13:23:45.336]                         info <- base::paste(info, collapse = "; ")
[13:23:45.336]                         if (!has_future) {
[13:23:45.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.336]                             info)
[13:23:45.336]                         }
[13:23:45.336]                         else {
[13:23:45.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.336]                             info, version)
[13:23:45.336]                         }
[13:23:45.336]                         base::stop(msg)
[13:23:45.336]                       }
[13:23:45.336]                     })
[13:23:45.336]                   }
[13:23:45.336]                   options(future.plan = NULL)
[13:23:45.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.336]                 }
[13:23:45.336]                 ...future.workdir <- getwd()
[13:23:45.336]             }
[13:23:45.336]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.336]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.336]         }
[13:23:45.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.336]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.336]             base::names(...future.oldOptions))
[13:23:45.336]     }
[13:23:45.336]     if (FALSE) {
[13:23:45.336]     }
[13:23:45.336]     else {
[13:23:45.336]         if (TRUE) {
[13:23:45.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.336]                 open = "w")
[13:23:45.336]         }
[13:23:45.336]         else {
[13:23:45.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.336]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.336]         }
[13:23:45.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.336]             base::sink(type = "output", split = FALSE)
[13:23:45.336]             base::close(...future.stdout)
[13:23:45.336]         }, add = TRUE)
[13:23:45.336]     }
[13:23:45.336]     ...future.frame <- base::sys.nframe()
[13:23:45.336]     ...future.conditions <- base::list()
[13:23:45.336]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.336]     if (FALSE) {
[13:23:45.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.336]     }
[13:23:45.336]     ...future.result <- base::tryCatch({
[13:23:45.336]         base::withCallingHandlers({
[13:23:45.336]             ...future.value <- base::withVisible(base::local({
[13:23:45.336]                 b <- 3
[13:23:45.336]                 c <- 2
[13:23:45.336]                 a * b * c
[13:23:45.336]             }))
[13:23:45.336]             future::FutureResult(value = ...future.value$value, 
[13:23:45.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.336]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.336]                     ...future.globalenv.names))
[13:23:45.336]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.336]         }, condition = base::local({
[13:23:45.336]             c <- base::c
[13:23:45.336]             inherits <- base::inherits
[13:23:45.336]             invokeRestart <- base::invokeRestart
[13:23:45.336]             length <- base::length
[13:23:45.336]             list <- base::list
[13:23:45.336]             seq.int <- base::seq.int
[13:23:45.336]             signalCondition <- base::signalCondition
[13:23:45.336]             sys.calls <- base::sys.calls
[13:23:45.336]             `[[` <- base::`[[`
[13:23:45.336]             `+` <- base::`+`
[13:23:45.336]             `<<-` <- base::`<<-`
[13:23:45.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.336]                   3L)]
[13:23:45.336]             }
[13:23:45.336]             function(cond) {
[13:23:45.336]                 is_error <- inherits(cond, "error")
[13:23:45.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.336]                   NULL)
[13:23:45.336]                 if (is_error) {
[13:23:45.336]                   sessionInformation <- function() {
[13:23:45.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.336]                       search = base::search(), system = base::Sys.info())
[13:23:45.336]                   }
[13:23:45.336]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.336]                     cond$call), session = sessionInformation(), 
[13:23:45.336]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.336]                   signalCondition(cond)
[13:23:45.336]                 }
[13:23:45.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.336]                 "immediateCondition"))) {
[13:23:45.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.336]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.336]                   if (TRUE && !signal) {
[13:23:45.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.336]                     {
[13:23:45.336]                       inherits <- base::inherits
[13:23:45.336]                       invokeRestart <- base::invokeRestart
[13:23:45.336]                       is.null <- base::is.null
[13:23:45.336]                       muffled <- FALSE
[13:23:45.336]                       if (inherits(cond, "message")) {
[13:23:45.336]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.336]                         if (muffled) 
[13:23:45.336]                           invokeRestart("muffleMessage")
[13:23:45.336]                       }
[13:23:45.336]                       else if (inherits(cond, "warning")) {
[13:23:45.336]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.336]                         if (muffled) 
[13:23:45.336]                           invokeRestart("muffleWarning")
[13:23:45.336]                       }
[13:23:45.336]                       else if (inherits(cond, "condition")) {
[13:23:45.336]                         if (!is.null(pattern)) {
[13:23:45.336]                           computeRestarts <- base::computeRestarts
[13:23:45.336]                           grepl <- base::grepl
[13:23:45.336]                           restarts <- computeRestarts(cond)
[13:23:45.336]                           for (restart in restarts) {
[13:23:45.336]                             name <- restart$name
[13:23:45.336]                             if (is.null(name)) 
[13:23:45.336]                               next
[13:23:45.336]                             if (!grepl(pattern, name)) 
[13:23:45.336]                               next
[13:23:45.336]                             invokeRestart(restart)
[13:23:45.336]                             muffled <- TRUE
[13:23:45.336]                             break
[13:23:45.336]                           }
[13:23:45.336]                         }
[13:23:45.336]                       }
[13:23:45.336]                       invisible(muffled)
[13:23:45.336]                     }
[13:23:45.336]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.336]                   }
[13:23:45.336]                 }
[13:23:45.336]                 else {
[13:23:45.336]                   if (TRUE) {
[13:23:45.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.336]                     {
[13:23:45.336]                       inherits <- base::inherits
[13:23:45.336]                       invokeRestart <- base::invokeRestart
[13:23:45.336]                       is.null <- base::is.null
[13:23:45.336]                       muffled <- FALSE
[13:23:45.336]                       if (inherits(cond, "message")) {
[13:23:45.336]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.336]                         if (muffled) 
[13:23:45.336]                           invokeRestart("muffleMessage")
[13:23:45.336]                       }
[13:23:45.336]                       else if (inherits(cond, "warning")) {
[13:23:45.336]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.336]                         if (muffled) 
[13:23:45.336]                           invokeRestart("muffleWarning")
[13:23:45.336]                       }
[13:23:45.336]                       else if (inherits(cond, "condition")) {
[13:23:45.336]                         if (!is.null(pattern)) {
[13:23:45.336]                           computeRestarts <- base::computeRestarts
[13:23:45.336]                           grepl <- base::grepl
[13:23:45.336]                           restarts <- computeRestarts(cond)
[13:23:45.336]                           for (restart in restarts) {
[13:23:45.336]                             name <- restart$name
[13:23:45.336]                             if (is.null(name)) 
[13:23:45.336]                               next
[13:23:45.336]                             if (!grepl(pattern, name)) 
[13:23:45.336]                               next
[13:23:45.336]                             invokeRestart(restart)
[13:23:45.336]                             muffled <- TRUE
[13:23:45.336]                             break
[13:23:45.336]                           }
[13:23:45.336]                         }
[13:23:45.336]                       }
[13:23:45.336]                       invisible(muffled)
[13:23:45.336]                     }
[13:23:45.336]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.336]                   }
[13:23:45.336]                 }
[13:23:45.336]             }
[13:23:45.336]         }))
[13:23:45.336]     }, error = function(ex) {
[13:23:45.336]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.336]                 ...future.rng), started = ...future.startTime, 
[13:23:45.336]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.336]             version = "1.8"), class = "FutureResult")
[13:23:45.336]     }, finally = {
[13:23:45.336]         if (!identical(...future.workdir, getwd())) 
[13:23:45.336]             setwd(...future.workdir)
[13:23:45.336]         {
[13:23:45.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.336]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.336]             }
[13:23:45.336]             base::options(...future.oldOptions)
[13:23:45.336]             if (.Platform$OS.type == "windows") {
[13:23:45.336]                 old_names <- names(...future.oldEnvVars)
[13:23:45.336]                 envs <- base::Sys.getenv()
[13:23:45.336]                 names <- names(envs)
[13:23:45.336]                 common <- intersect(names, old_names)
[13:23:45.336]                 added <- setdiff(names, old_names)
[13:23:45.336]                 removed <- setdiff(old_names, names)
[13:23:45.336]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.336]                   envs[common]]
[13:23:45.336]                 NAMES <- toupper(changed)
[13:23:45.336]                 args <- list()
[13:23:45.336]                 for (kk in seq_along(NAMES)) {
[13:23:45.336]                   name <- changed[[kk]]
[13:23:45.336]                   NAME <- NAMES[[kk]]
[13:23:45.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.336]                     next
[13:23:45.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.336]                 }
[13:23:45.336]                 NAMES <- toupper(added)
[13:23:45.336]                 for (kk in seq_along(NAMES)) {
[13:23:45.336]                   name <- added[[kk]]
[13:23:45.336]                   NAME <- NAMES[[kk]]
[13:23:45.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.336]                     next
[13:23:45.336]                   args[[name]] <- ""
[13:23:45.336]                 }
[13:23:45.336]                 NAMES <- toupper(removed)
[13:23:45.336]                 for (kk in seq_along(NAMES)) {
[13:23:45.336]                   name <- removed[[kk]]
[13:23:45.336]                   NAME <- NAMES[[kk]]
[13:23:45.336]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.336]                     next
[13:23:45.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.336]                 }
[13:23:45.336]                 if (length(args) > 0) 
[13:23:45.336]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.336]             }
[13:23:45.336]             else {
[13:23:45.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.336]             }
[13:23:45.336]             {
[13:23:45.336]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.336]                   0L) {
[13:23:45.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.336]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.336]                   base::options(opts)
[13:23:45.336]                 }
[13:23:45.336]                 {
[13:23:45.336]                   {
[13:23:45.336]                     NULL
[13:23:45.336]                     RNGkind("Mersenne-Twister")
[13:23:45.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.336]                       inherits = FALSE)
[13:23:45.336]                   }
[13:23:45.336]                   options(future.plan = NULL)
[13:23:45.336]                   if (is.na(NA_character_)) 
[13:23:45.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.336]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.336]                     envir = parent.frame()) 
[13:23:45.336]                   {
[13:23:45.336]                     default_workers <- missing(workers)
[13:23:45.336]                     if (is.function(workers)) 
[13:23:45.336]                       workers <- workers()
[13:23:45.336]                     workers <- structure(as.integer(workers), 
[13:23:45.336]                       class = class(workers))
[13:23:45.336]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.336]                       1L)
[13:23:45.336]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.336]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.336]                       if (default_workers) 
[13:23:45.336]                         supportsMulticore(warn = TRUE)
[13:23:45.336]                       return(sequential(..., envir = envir))
[13:23:45.336]                     }
[13:23:45.336]                     oopts <- options(mc.cores = workers)
[13:23:45.336]                     on.exit(options(oopts))
[13:23:45.336]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.336]                       envir = envir)
[13:23:45.336]                     if (!future$lazy) 
[13:23:45.336]                       future <- run(future)
[13:23:45.336]                     invisible(future)
[13:23:45.336]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.336]                 }
[13:23:45.336]             }
[13:23:45.336]         }
[13:23:45.336]     })
[13:23:45.336]     if (TRUE) {
[13:23:45.336]         base::sink(type = "output", split = FALSE)
[13:23:45.336]         if (TRUE) {
[13:23:45.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.336]         }
[13:23:45.336]         else {
[13:23:45.336]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.336]         }
[13:23:45.336]         base::close(...future.stdout)
[13:23:45.336]         ...future.stdout <- NULL
[13:23:45.336]     }
[13:23:45.336]     ...future.result$conditions <- ...future.conditions
[13:23:45.336]     ...future.result$finished <- base::Sys.time()
[13:23:45.336]     ...future.result
[13:23:45.336] }
[13:23:45.338] plan(): Setting new future strategy stack:
[13:23:45.338] List of future strategies:
[13:23:45.338] 1. sequential:
[13:23:45.338]    - args: function (..., envir = parent.frame())
[13:23:45.338]    - tweaked: FALSE
[13:23:45.338]    - call: NULL
[13:23:45.339] plan(): nbrOfWorkers() = 1
[13:23:45.339] plan(): Setting new future strategy stack:
[13:23:45.339] List of future strategies:
[13:23:45.339] 1. multicore:
[13:23:45.339]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.339]    - tweaked: FALSE
[13:23:45.339]    - call: plan(multicore)
[13:23:45.343] plan(): nbrOfWorkers() = 1
[13:23:45.343] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[13:23:45.348] getGlobalsAndPackages() ...
[13:23:45.348] Not searching for globals
[13:23:45.348] - globals: [0] <none>
[13:23:45.348] getGlobalsAndPackages() ... DONE
[13:23:45.348] Packages needed by the future expression (n = 0): <none>
[13:23:45.348] Packages needed by future strategies (n = 0): <none>
[13:23:45.349] {
[13:23:45.349]     {
[13:23:45.349]         {
[13:23:45.349]             ...future.startTime <- base::Sys.time()
[13:23:45.349]             {
[13:23:45.349]                 {
[13:23:45.349]                   {
[13:23:45.349]                     base::local({
[13:23:45.349]                       has_future <- base::requireNamespace("future", 
[13:23:45.349]                         quietly = TRUE)
[13:23:45.349]                       if (has_future) {
[13:23:45.349]                         ns <- base::getNamespace("future")
[13:23:45.349]                         version <- ns[[".package"]][["version"]]
[13:23:45.349]                         if (is.null(version)) 
[13:23:45.349]                           version <- utils::packageVersion("future")
[13:23:45.349]                       }
[13:23:45.349]                       else {
[13:23:45.349]                         version <- NULL
[13:23:45.349]                       }
[13:23:45.349]                       if (!has_future || version < "1.8.0") {
[13:23:45.349]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.349]                           "", base::R.version$version.string), 
[13:23:45.349]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.349]                             "release", "version")], collapse = " "), 
[13:23:45.349]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.349]                           info)
[13:23:45.349]                         info <- base::paste(info, collapse = "; ")
[13:23:45.349]                         if (!has_future) {
[13:23:45.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.349]                             info)
[13:23:45.349]                         }
[13:23:45.349]                         else {
[13:23:45.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.349]                             info, version)
[13:23:45.349]                         }
[13:23:45.349]                         base::stop(msg)
[13:23:45.349]                       }
[13:23:45.349]                     })
[13:23:45.349]                   }
[13:23:45.349]                   options(future.plan = NULL)
[13:23:45.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.349]                 }
[13:23:45.349]                 ...future.workdir <- getwd()
[13:23:45.349]             }
[13:23:45.349]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.349]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.349]         }
[13:23:45.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.349]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.349]             base::names(...future.oldOptions))
[13:23:45.349]     }
[13:23:45.349]     if (FALSE) {
[13:23:45.349]     }
[13:23:45.349]     else {
[13:23:45.349]         if (TRUE) {
[13:23:45.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.349]                 open = "w")
[13:23:45.349]         }
[13:23:45.349]         else {
[13:23:45.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.349]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.349]         }
[13:23:45.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.349]             base::sink(type = "output", split = FALSE)
[13:23:45.349]             base::close(...future.stdout)
[13:23:45.349]         }, add = TRUE)
[13:23:45.349]     }
[13:23:45.349]     ...future.frame <- base::sys.nframe()
[13:23:45.349]     ...future.conditions <- base::list()
[13:23:45.349]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.349]     if (FALSE) {
[13:23:45.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.349]     }
[13:23:45.349]     ...future.result <- base::tryCatch({
[13:23:45.349]         base::withCallingHandlers({
[13:23:45.349]             ...future.value <- base::withVisible(base::local({
[13:23:45.349]                 ii
[13:23:45.349]             }))
[13:23:45.349]             future::FutureResult(value = ...future.value$value, 
[13:23:45.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.349]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.349]                     ...future.globalenv.names))
[13:23:45.349]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.349]         }, condition = base::local({
[13:23:45.349]             c <- base::c
[13:23:45.349]             inherits <- base::inherits
[13:23:45.349]             invokeRestart <- base::invokeRestart
[13:23:45.349]             length <- base::length
[13:23:45.349]             list <- base::list
[13:23:45.349]             seq.int <- base::seq.int
[13:23:45.349]             signalCondition <- base::signalCondition
[13:23:45.349]             sys.calls <- base::sys.calls
[13:23:45.349]             `[[` <- base::`[[`
[13:23:45.349]             `+` <- base::`+`
[13:23:45.349]             `<<-` <- base::`<<-`
[13:23:45.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.349]                   3L)]
[13:23:45.349]             }
[13:23:45.349]             function(cond) {
[13:23:45.349]                 is_error <- inherits(cond, "error")
[13:23:45.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.349]                   NULL)
[13:23:45.349]                 if (is_error) {
[13:23:45.349]                   sessionInformation <- function() {
[13:23:45.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.349]                       search = base::search(), system = base::Sys.info())
[13:23:45.349]                   }
[13:23:45.349]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.349]                     cond$call), session = sessionInformation(), 
[13:23:45.349]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.349]                   signalCondition(cond)
[13:23:45.349]                 }
[13:23:45.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.349]                 "immediateCondition"))) {
[13:23:45.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.349]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.349]                   if (TRUE && !signal) {
[13:23:45.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.349]                     {
[13:23:45.349]                       inherits <- base::inherits
[13:23:45.349]                       invokeRestart <- base::invokeRestart
[13:23:45.349]                       is.null <- base::is.null
[13:23:45.349]                       muffled <- FALSE
[13:23:45.349]                       if (inherits(cond, "message")) {
[13:23:45.349]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.349]                         if (muffled) 
[13:23:45.349]                           invokeRestart("muffleMessage")
[13:23:45.349]                       }
[13:23:45.349]                       else if (inherits(cond, "warning")) {
[13:23:45.349]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.349]                         if (muffled) 
[13:23:45.349]                           invokeRestart("muffleWarning")
[13:23:45.349]                       }
[13:23:45.349]                       else if (inherits(cond, "condition")) {
[13:23:45.349]                         if (!is.null(pattern)) {
[13:23:45.349]                           computeRestarts <- base::computeRestarts
[13:23:45.349]                           grepl <- base::grepl
[13:23:45.349]                           restarts <- computeRestarts(cond)
[13:23:45.349]                           for (restart in restarts) {
[13:23:45.349]                             name <- restart$name
[13:23:45.349]                             if (is.null(name)) 
[13:23:45.349]                               next
[13:23:45.349]                             if (!grepl(pattern, name)) 
[13:23:45.349]                               next
[13:23:45.349]                             invokeRestart(restart)
[13:23:45.349]                             muffled <- TRUE
[13:23:45.349]                             break
[13:23:45.349]                           }
[13:23:45.349]                         }
[13:23:45.349]                       }
[13:23:45.349]                       invisible(muffled)
[13:23:45.349]                     }
[13:23:45.349]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.349]                   }
[13:23:45.349]                 }
[13:23:45.349]                 else {
[13:23:45.349]                   if (TRUE) {
[13:23:45.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.349]                     {
[13:23:45.349]                       inherits <- base::inherits
[13:23:45.349]                       invokeRestart <- base::invokeRestart
[13:23:45.349]                       is.null <- base::is.null
[13:23:45.349]                       muffled <- FALSE
[13:23:45.349]                       if (inherits(cond, "message")) {
[13:23:45.349]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.349]                         if (muffled) 
[13:23:45.349]                           invokeRestart("muffleMessage")
[13:23:45.349]                       }
[13:23:45.349]                       else if (inherits(cond, "warning")) {
[13:23:45.349]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.349]                         if (muffled) 
[13:23:45.349]                           invokeRestart("muffleWarning")
[13:23:45.349]                       }
[13:23:45.349]                       else if (inherits(cond, "condition")) {
[13:23:45.349]                         if (!is.null(pattern)) {
[13:23:45.349]                           computeRestarts <- base::computeRestarts
[13:23:45.349]                           grepl <- base::grepl
[13:23:45.349]                           restarts <- computeRestarts(cond)
[13:23:45.349]                           for (restart in restarts) {
[13:23:45.349]                             name <- restart$name
[13:23:45.349]                             if (is.null(name)) 
[13:23:45.349]                               next
[13:23:45.349]                             if (!grepl(pattern, name)) 
[13:23:45.349]                               next
[13:23:45.349]                             invokeRestart(restart)
[13:23:45.349]                             muffled <- TRUE
[13:23:45.349]                             break
[13:23:45.349]                           }
[13:23:45.349]                         }
[13:23:45.349]                       }
[13:23:45.349]                       invisible(muffled)
[13:23:45.349]                     }
[13:23:45.349]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.349]                   }
[13:23:45.349]                 }
[13:23:45.349]             }
[13:23:45.349]         }))
[13:23:45.349]     }, error = function(ex) {
[13:23:45.349]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.349]                 ...future.rng), started = ...future.startTime, 
[13:23:45.349]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.349]             version = "1.8"), class = "FutureResult")
[13:23:45.349]     }, finally = {
[13:23:45.349]         if (!identical(...future.workdir, getwd())) 
[13:23:45.349]             setwd(...future.workdir)
[13:23:45.349]         {
[13:23:45.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.349]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.349]             }
[13:23:45.349]             base::options(...future.oldOptions)
[13:23:45.349]             if (.Platform$OS.type == "windows") {
[13:23:45.349]                 old_names <- names(...future.oldEnvVars)
[13:23:45.349]                 envs <- base::Sys.getenv()
[13:23:45.349]                 names <- names(envs)
[13:23:45.349]                 common <- intersect(names, old_names)
[13:23:45.349]                 added <- setdiff(names, old_names)
[13:23:45.349]                 removed <- setdiff(old_names, names)
[13:23:45.349]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.349]                   envs[common]]
[13:23:45.349]                 NAMES <- toupper(changed)
[13:23:45.349]                 args <- list()
[13:23:45.349]                 for (kk in seq_along(NAMES)) {
[13:23:45.349]                   name <- changed[[kk]]
[13:23:45.349]                   NAME <- NAMES[[kk]]
[13:23:45.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.349]                     next
[13:23:45.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.349]                 }
[13:23:45.349]                 NAMES <- toupper(added)
[13:23:45.349]                 for (kk in seq_along(NAMES)) {
[13:23:45.349]                   name <- added[[kk]]
[13:23:45.349]                   NAME <- NAMES[[kk]]
[13:23:45.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.349]                     next
[13:23:45.349]                   args[[name]] <- ""
[13:23:45.349]                 }
[13:23:45.349]                 NAMES <- toupper(removed)
[13:23:45.349]                 for (kk in seq_along(NAMES)) {
[13:23:45.349]                   name <- removed[[kk]]
[13:23:45.349]                   NAME <- NAMES[[kk]]
[13:23:45.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.349]                     next
[13:23:45.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.349]                 }
[13:23:45.349]                 if (length(args) > 0) 
[13:23:45.349]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.349]             }
[13:23:45.349]             else {
[13:23:45.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.349]             }
[13:23:45.349]             {
[13:23:45.349]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.349]                   0L) {
[13:23:45.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.349]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.349]                   base::options(opts)
[13:23:45.349]                 }
[13:23:45.349]                 {
[13:23:45.349]                   {
[13:23:45.349]                     NULL
[13:23:45.349]                     RNGkind("Mersenne-Twister")
[13:23:45.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.349]                       inherits = FALSE)
[13:23:45.349]                   }
[13:23:45.349]                   options(future.plan = NULL)
[13:23:45.349]                   if (is.na(NA_character_)) 
[13:23:45.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.349]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.349]                     envir = parent.frame()) 
[13:23:45.349]                   {
[13:23:45.349]                     default_workers <- missing(workers)
[13:23:45.349]                     if (is.function(workers)) 
[13:23:45.349]                       workers <- workers()
[13:23:45.349]                     workers <- structure(as.integer(workers), 
[13:23:45.349]                       class = class(workers))
[13:23:45.349]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.349]                       1L)
[13:23:45.349]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.349]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.349]                       if (default_workers) 
[13:23:45.349]                         supportsMulticore(warn = TRUE)
[13:23:45.349]                       return(sequential(..., envir = envir))
[13:23:45.349]                     }
[13:23:45.349]                     oopts <- options(mc.cores = workers)
[13:23:45.349]                     on.exit(options(oopts))
[13:23:45.349]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.349]                       envir = envir)
[13:23:45.349]                     if (!future$lazy) 
[13:23:45.349]                       future <- run(future)
[13:23:45.349]                     invisible(future)
[13:23:45.349]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.349]                 }
[13:23:45.349]             }
[13:23:45.349]         }
[13:23:45.349]     })
[13:23:45.349]     if (TRUE) {
[13:23:45.349]         base::sink(type = "output", split = FALSE)
[13:23:45.349]         if (TRUE) {
[13:23:45.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.349]         }
[13:23:45.349]         else {
[13:23:45.349]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.349]         }
[13:23:45.349]         base::close(...future.stdout)
[13:23:45.349]         ...future.stdout <- NULL
[13:23:45.349]     }
[13:23:45.349]     ...future.result$conditions <- ...future.conditions
[13:23:45.349]     ...future.result$finished <- base::Sys.time()
[13:23:45.349]     ...future.result
[13:23:45.349] }
[13:23:45.351] plan(): Setting new future strategy stack:
[13:23:45.351] List of future strategies:
[13:23:45.351] 1. sequential:
[13:23:45.351]    - args: function (..., envir = parent.frame())
[13:23:45.351]    - tweaked: FALSE
[13:23:45.351]    - call: NULL
[13:23:45.351] plan(): nbrOfWorkers() = 1
[13:23:45.352] plan(): Setting new future strategy stack:
[13:23:45.352] List of future strategies:
[13:23:45.352] 1. multicore:
[13:23:45.352]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.352]    - tweaked: FALSE
[13:23:45.352]    - call: plan(multicore)
[13:23:45.355] plan(): nbrOfWorkers() = 1
[13:23:45.356] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[13:23:45.361] getGlobalsAndPackages() ...
[13:23:45.361] Not searching for globals
[13:23:45.362] - globals: [0] <none>
[13:23:45.362] getGlobalsAndPackages() ... DONE
[13:23:45.362] Packages needed by the future expression (n = 0): <none>
[13:23:45.362] Packages needed by future strategies (n = 0): <none>
[13:23:45.363] {
[13:23:45.363]     {
[13:23:45.363]         {
[13:23:45.363]             ...future.startTime <- base::Sys.time()
[13:23:45.363]             {
[13:23:45.363]                 {
[13:23:45.363]                   {
[13:23:45.363]                     base::local({
[13:23:45.363]                       has_future <- base::requireNamespace("future", 
[13:23:45.363]                         quietly = TRUE)
[13:23:45.363]                       if (has_future) {
[13:23:45.363]                         ns <- base::getNamespace("future")
[13:23:45.363]                         version <- ns[[".package"]][["version"]]
[13:23:45.363]                         if (is.null(version)) 
[13:23:45.363]                           version <- utils::packageVersion("future")
[13:23:45.363]                       }
[13:23:45.363]                       else {
[13:23:45.363]                         version <- NULL
[13:23:45.363]                       }
[13:23:45.363]                       if (!has_future || version < "1.8.0") {
[13:23:45.363]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.363]                           "", base::R.version$version.string), 
[13:23:45.363]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.363]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.363]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.363]                             "release", "version")], collapse = " "), 
[13:23:45.363]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.363]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.363]                           info)
[13:23:45.363]                         info <- base::paste(info, collapse = "; ")
[13:23:45.363]                         if (!has_future) {
[13:23:45.363]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.363]                             info)
[13:23:45.363]                         }
[13:23:45.363]                         else {
[13:23:45.363]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.363]                             info, version)
[13:23:45.363]                         }
[13:23:45.363]                         base::stop(msg)
[13:23:45.363]                       }
[13:23:45.363]                     })
[13:23:45.363]                   }
[13:23:45.363]                   options(future.plan = NULL)
[13:23:45.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.363]                 }
[13:23:45.363]                 ...future.workdir <- getwd()
[13:23:45.363]             }
[13:23:45.363]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.363]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.363]         }
[13:23:45.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.363]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.363]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.363]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.363]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.363]             base::names(...future.oldOptions))
[13:23:45.363]     }
[13:23:45.363]     if (FALSE) {
[13:23:45.363]     }
[13:23:45.363]     else {
[13:23:45.363]         if (TRUE) {
[13:23:45.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.363]                 open = "w")
[13:23:45.363]         }
[13:23:45.363]         else {
[13:23:45.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.363]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.363]         }
[13:23:45.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.363]             base::sink(type = "output", split = FALSE)
[13:23:45.363]             base::close(...future.stdout)
[13:23:45.363]         }, add = TRUE)
[13:23:45.363]     }
[13:23:45.363]     ...future.frame <- base::sys.nframe()
[13:23:45.363]     ...future.conditions <- base::list()
[13:23:45.363]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.363]     if (FALSE) {
[13:23:45.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.363]     }
[13:23:45.363]     ...future.result <- base::tryCatch({
[13:23:45.363]         base::withCallingHandlers({
[13:23:45.363]             ...future.value <- base::withVisible(base::local({
[13:23:45.363]                 ii
[13:23:45.363]             }))
[13:23:45.363]             future::FutureResult(value = ...future.value$value, 
[13:23:45.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.363]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.363]                     ...future.globalenv.names))
[13:23:45.363]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.363]         }, condition = base::local({
[13:23:45.363]             c <- base::c
[13:23:45.363]             inherits <- base::inherits
[13:23:45.363]             invokeRestart <- base::invokeRestart
[13:23:45.363]             length <- base::length
[13:23:45.363]             list <- base::list
[13:23:45.363]             seq.int <- base::seq.int
[13:23:45.363]             signalCondition <- base::signalCondition
[13:23:45.363]             sys.calls <- base::sys.calls
[13:23:45.363]             `[[` <- base::`[[`
[13:23:45.363]             `+` <- base::`+`
[13:23:45.363]             `<<-` <- base::`<<-`
[13:23:45.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.363]                   3L)]
[13:23:45.363]             }
[13:23:45.363]             function(cond) {
[13:23:45.363]                 is_error <- inherits(cond, "error")
[13:23:45.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.363]                   NULL)
[13:23:45.363]                 if (is_error) {
[13:23:45.363]                   sessionInformation <- function() {
[13:23:45.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.363]                       search = base::search(), system = base::Sys.info())
[13:23:45.363]                   }
[13:23:45.363]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.363]                     cond$call), session = sessionInformation(), 
[13:23:45.363]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.363]                   signalCondition(cond)
[13:23:45.363]                 }
[13:23:45.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.363]                 "immediateCondition"))) {
[13:23:45.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.363]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.363]                   if (TRUE && !signal) {
[13:23:45.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.363]                     {
[13:23:45.363]                       inherits <- base::inherits
[13:23:45.363]                       invokeRestart <- base::invokeRestart
[13:23:45.363]                       is.null <- base::is.null
[13:23:45.363]                       muffled <- FALSE
[13:23:45.363]                       if (inherits(cond, "message")) {
[13:23:45.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.363]                         if (muffled) 
[13:23:45.363]                           invokeRestart("muffleMessage")
[13:23:45.363]                       }
[13:23:45.363]                       else if (inherits(cond, "warning")) {
[13:23:45.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.363]                         if (muffled) 
[13:23:45.363]                           invokeRestart("muffleWarning")
[13:23:45.363]                       }
[13:23:45.363]                       else if (inherits(cond, "condition")) {
[13:23:45.363]                         if (!is.null(pattern)) {
[13:23:45.363]                           computeRestarts <- base::computeRestarts
[13:23:45.363]                           grepl <- base::grepl
[13:23:45.363]                           restarts <- computeRestarts(cond)
[13:23:45.363]                           for (restart in restarts) {
[13:23:45.363]                             name <- restart$name
[13:23:45.363]                             if (is.null(name)) 
[13:23:45.363]                               next
[13:23:45.363]                             if (!grepl(pattern, name)) 
[13:23:45.363]                               next
[13:23:45.363]                             invokeRestart(restart)
[13:23:45.363]                             muffled <- TRUE
[13:23:45.363]                             break
[13:23:45.363]                           }
[13:23:45.363]                         }
[13:23:45.363]                       }
[13:23:45.363]                       invisible(muffled)
[13:23:45.363]                     }
[13:23:45.363]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.363]                   }
[13:23:45.363]                 }
[13:23:45.363]                 else {
[13:23:45.363]                   if (TRUE) {
[13:23:45.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.363]                     {
[13:23:45.363]                       inherits <- base::inherits
[13:23:45.363]                       invokeRestart <- base::invokeRestart
[13:23:45.363]                       is.null <- base::is.null
[13:23:45.363]                       muffled <- FALSE
[13:23:45.363]                       if (inherits(cond, "message")) {
[13:23:45.363]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.363]                         if (muffled) 
[13:23:45.363]                           invokeRestart("muffleMessage")
[13:23:45.363]                       }
[13:23:45.363]                       else if (inherits(cond, "warning")) {
[13:23:45.363]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.363]                         if (muffled) 
[13:23:45.363]                           invokeRestart("muffleWarning")
[13:23:45.363]                       }
[13:23:45.363]                       else if (inherits(cond, "condition")) {
[13:23:45.363]                         if (!is.null(pattern)) {
[13:23:45.363]                           computeRestarts <- base::computeRestarts
[13:23:45.363]                           grepl <- base::grepl
[13:23:45.363]                           restarts <- computeRestarts(cond)
[13:23:45.363]                           for (restart in restarts) {
[13:23:45.363]                             name <- restart$name
[13:23:45.363]                             if (is.null(name)) 
[13:23:45.363]                               next
[13:23:45.363]                             if (!grepl(pattern, name)) 
[13:23:45.363]                               next
[13:23:45.363]                             invokeRestart(restart)
[13:23:45.363]                             muffled <- TRUE
[13:23:45.363]                             break
[13:23:45.363]                           }
[13:23:45.363]                         }
[13:23:45.363]                       }
[13:23:45.363]                       invisible(muffled)
[13:23:45.363]                     }
[13:23:45.363]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.363]                   }
[13:23:45.363]                 }
[13:23:45.363]             }
[13:23:45.363]         }))
[13:23:45.363]     }, error = function(ex) {
[13:23:45.363]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.363]                 ...future.rng), started = ...future.startTime, 
[13:23:45.363]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.363]             version = "1.8"), class = "FutureResult")
[13:23:45.363]     }, finally = {
[13:23:45.363]         if (!identical(...future.workdir, getwd())) 
[13:23:45.363]             setwd(...future.workdir)
[13:23:45.363]         {
[13:23:45.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.363]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.363]             }
[13:23:45.363]             base::options(...future.oldOptions)
[13:23:45.363]             if (.Platform$OS.type == "windows") {
[13:23:45.363]                 old_names <- names(...future.oldEnvVars)
[13:23:45.363]                 envs <- base::Sys.getenv()
[13:23:45.363]                 names <- names(envs)
[13:23:45.363]                 common <- intersect(names, old_names)
[13:23:45.363]                 added <- setdiff(names, old_names)
[13:23:45.363]                 removed <- setdiff(old_names, names)
[13:23:45.363]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.363]                   envs[common]]
[13:23:45.363]                 NAMES <- toupper(changed)
[13:23:45.363]                 args <- list()
[13:23:45.363]                 for (kk in seq_along(NAMES)) {
[13:23:45.363]                   name <- changed[[kk]]
[13:23:45.363]                   NAME <- NAMES[[kk]]
[13:23:45.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.363]                     next
[13:23:45.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.363]                 }
[13:23:45.363]                 NAMES <- toupper(added)
[13:23:45.363]                 for (kk in seq_along(NAMES)) {
[13:23:45.363]                   name <- added[[kk]]
[13:23:45.363]                   NAME <- NAMES[[kk]]
[13:23:45.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.363]                     next
[13:23:45.363]                   args[[name]] <- ""
[13:23:45.363]                 }
[13:23:45.363]                 NAMES <- toupper(removed)
[13:23:45.363]                 for (kk in seq_along(NAMES)) {
[13:23:45.363]                   name <- removed[[kk]]
[13:23:45.363]                   NAME <- NAMES[[kk]]
[13:23:45.363]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.363]                     next
[13:23:45.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.363]                 }
[13:23:45.363]                 if (length(args) > 0) 
[13:23:45.363]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.363]             }
[13:23:45.363]             else {
[13:23:45.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.363]             }
[13:23:45.363]             {
[13:23:45.363]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.363]                   0L) {
[13:23:45.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.363]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.363]                   base::options(opts)
[13:23:45.363]                 }
[13:23:45.363]                 {
[13:23:45.363]                   {
[13:23:45.363]                     NULL
[13:23:45.363]                     RNGkind("Mersenne-Twister")
[13:23:45.363]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.363]                       inherits = FALSE)
[13:23:45.363]                   }
[13:23:45.363]                   options(future.plan = NULL)
[13:23:45.363]                   if (is.na(NA_character_)) 
[13:23:45.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.363]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.363]                     envir = parent.frame()) 
[13:23:45.363]                   {
[13:23:45.363]                     default_workers <- missing(workers)
[13:23:45.363]                     if (is.function(workers)) 
[13:23:45.363]                       workers <- workers()
[13:23:45.363]                     workers <- structure(as.integer(workers), 
[13:23:45.363]                       class = class(workers))
[13:23:45.363]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.363]                       1L)
[13:23:45.363]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.363]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.363]                       if (default_workers) 
[13:23:45.363]                         supportsMulticore(warn = TRUE)
[13:23:45.363]                       return(sequential(..., envir = envir))
[13:23:45.363]                     }
[13:23:45.363]                     oopts <- options(mc.cores = workers)
[13:23:45.363]                     on.exit(options(oopts))
[13:23:45.363]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.363]                       envir = envir)
[13:23:45.363]                     if (!future$lazy) 
[13:23:45.363]                       future <- run(future)
[13:23:45.363]                     invisible(future)
[13:23:45.363]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.363]                 }
[13:23:45.363]             }
[13:23:45.363]         }
[13:23:45.363]     })
[13:23:45.363]     if (TRUE) {
[13:23:45.363]         base::sink(type = "output", split = FALSE)
[13:23:45.363]         if (TRUE) {
[13:23:45.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.363]         }
[13:23:45.363]         else {
[13:23:45.363]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.363]         }
[13:23:45.363]         base::close(...future.stdout)
[13:23:45.363]         ...future.stdout <- NULL
[13:23:45.363]     }
[13:23:45.363]     ...future.result$conditions <- ...future.conditions
[13:23:45.363]     ...future.result$finished <- base::Sys.time()
[13:23:45.363]     ...future.result
[13:23:45.363] }
[13:23:45.365] plan(): Setting new future strategy stack:
[13:23:45.365] List of future strategies:
[13:23:45.365] 1. sequential:
[13:23:45.365]    - args: function (..., envir = parent.frame())
[13:23:45.365]    - tweaked: FALSE
[13:23:45.365]    - call: NULL
[13:23:45.365] plan(): nbrOfWorkers() = 1
[13:23:45.366] plan(): Setting new future strategy stack:
[13:23:45.366] List of future strategies:
[13:23:45.366] 1. multicore:
[13:23:45.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.366]    - tweaked: FALSE
[13:23:45.366]    - call: plan(multicore)
[13:23:45.369] plan(): nbrOfWorkers() = 1
[13:23:45.369] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[13:23:45.373] getGlobalsAndPackages() ...
[13:23:45.373] Not searching for globals
[13:23:45.373] - globals: [0] <none>
[13:23:45.373] getGlobalsAndPackages() ... DONE
[13:23:45.373] Packages needed by the future expression (n = 0): <none>
[13:23:45.374] Packages needed by future strategies (n = 0): <none>
[13:23:45.374] {
[13:23:45.374]     {
[13:23:45.374]         {
[13:23:45.374]             ...future.startTime <- base::Sys.time()
[13:23:45.374]             {
[13:23:45.374]                 {
[13:23:45.374]                   {
[13:23:45.374]                     base::local({
[13:23:45.374]                       has_future <- base::requireNamespace("future", 
[13:23:45.374]                         quietly = TRUE)
[13:23:45.374]                       if (has_future) {
[13:23:45.374]                         ns <- base::getNamespace("future")
[13:23:45.374]                         version <- ns[[".package"]][["version"]]
[13:23:45.374]                         if (is.null(version)) 
[13:23:45.374]                           version <- utils::packageVersion("future")
[13:23:45.374]                       }
[13:23:45.374]                       else {
[13:23:45.374]                         version <- NULL
[13:23:45.374]                       }
[13:23:45.374]                       if (!has_future || version < "1.8.0") {
[13:23:45.374]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.374]                           "", base::R.version$version.string), 
[13:23:45.374]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.374]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.374]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.374]                             "release", "version")], collapse = " "), 
[13:23:45.374]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.374]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.374]                           info)
[13:23:45.374]                         info <- base::paste(info, collapse = "; ")
[13:23:45.374]                         if (!has_future) {
[13:23:45.374]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.374]                             info)
[13:23:45.374]                         }
[13:23:45.374]                         else {
[13:23:45.374]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.374]                             info, version)
[13:23:45.374]                         }
[13:23:45.374]                         base::stop(msg)
[13:23:45.374]                       }
[13:23:45.374]                     })
[13:23:45.374]                   }
[13:23:45.374]                   options(future.plan = NULL)
[13:23:45.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.374]                 }
[13:23:45.374]                 ...future.workdir <- getwd()
[13:23:45.374]             }
[13:23:45.374]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.374]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.374]         }
[13:23:45.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.374]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.374]             base::names(...future.oldOptions))
[13:23:45.374]     }
[13:23:45.374]     if (FALSE) {
[13:23:45.374]     }
[13:23:45.374]     else {
[13:23:45.374]         if (TRUE) {
[13:23:45.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.374]                 open = "w")
[13:23:45.374]         }
[13:23:45.374]         else {
[13:23:45.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.374]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.374]         }
[13:23:45.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.374]             base::sink(type = "output", split = FALSE)
[13:23:45.374]             base::close(...future.stdout)
[13:23:45.374]         }, add = TRUE)
[13:23:45.374]     }
[13:23:45.374]     ...future.frame <- base::sys.nframe()
[13:23:45.374]     ...future.conditions <- base::list()
[13:23:45.374]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.374]     if (FALSE) {
[13:23:45.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.374]     }
[13:23:45.374]     ...future.result <- base::tryCatch({
[13:23:45.374]         base::withCallingHandlers({
[13:23:45.374]             ...future.value <- base::withVisible(base::local({
[13:23:45.374]                 ii
[13:23:45.374]             }))
[13:23:45.374]             future::FutureResult(value = ...future.value$value, 
[13:23:45.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.374]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.374]                     ...future.globalenv.names))
[13:23:45.374]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.374]         }, condition = base::local({
[13:23:45.374]             c <- base::c
[13:23:45.374]             inherits <- base::inherits
[13:23:45.374]             invokeRestart <- base::invokeRestart
[13:23:45.374]             length <- base::length
[13:23:45.374]             list <- base::list
[13:23:45.374]             seq.int <- base::seq.int
[13:23:45.374]             signalCondition <- base::signalCondition
[13:23:45.374]             sys.calls <- base::sys.calls
[13:23:45.374]             `[[` <- base::`[[`
[13:23:45.374]             `+` <- base::`+`
[13:23:45.374]             `<<-` <- base::`<<-`
[13:23:45.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.374]                   3L)]
[13:23:45.374]             }
[13:23:45.374]             function(cond) {
[13:23:45.374]                 is_error <- inherits(cond, "error")
[13:23:45.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.374]                   NULL)
[13:23:45.374]                 if (is_error) {
[13:23:45.374]                   sessionInformation <- function() {
[13:23:45.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.374]                       search = base::search(), system = base::Sys.info())
[13:23:45.374]                   }
[13:23:45.374]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.374]                     cond$call), session = sessionInformation(), 
[13:23:45.374]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.374]                   signalCondition(cond)
[13:23:45.374]                 }
[13:23:45.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.374]                 "immediateCondition"))) {
[13:23:45.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.374]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.374]                   if (TRUE && !signal) {
[13:23:45.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.374]                     {
[13:23:45.374]                       inherits <- base::inherits
[13:23:45.374]                       invokeRestart <- base::invokeRestart
[13:23:45.374]                       is.null <- base::is.null
[13:23:45.374]                       muffled <- FALSE
[13:23:45.374]                       if (inherits(cond, "message")) {
[13:23:45.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.374]                         if (muffled) 
[13:23:45.374]                           invokeRestart("muffleMessage")
[13:23:45.374]                       }
[13:23:45.374]                       else if (inherits(cond, "warning")) {
[13:23:45.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.374]                         if (muffled) 
[13:23:45.374]                           invokeRestart("muffleWarning")
[13:23:45.374]                       }
[13:23:45.374]                       else if (inherits(cond, "condition")) {
[13:23:45.374]                         if (!is.null(pattern)) {
[13:23:45.374]                           computeRestarts <- base::computeRestarts
[13:23:45.374]                           grepl <- base::grepl
[13:23:45.374]                           restarts <- computeRestarts(cond)
[13:23:45.374]                           for (restart in restarts) {
[13:23:45.374]                             name <- restart$name
[13:23:45.374]                             if (is.null(name)) 
[13:23:45.374]                               next
[13:23:45.374]                             if (!grepl(pattern, name)) 
[13:23:45.374]                               next
[13:23:45.374]                             invokeRestart(restart)
[13:23:45.374]                             muffled <- TRUE
[13:23:45.374]                             break
[13:23:45.374]                           }
[13:23:45.374]                         }
[13:23:45.374]                       }
[13:23:45.374]                       invisible(muffled)
[13:23:45.374]                     }
[13:23:45.374]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.374]                   }
[13:23:45.374]                 }
[13:23:45.374]                 else {
[13:23:45.374]                   if (TRUE) {
[13:23:45.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.374]                     {
[13:23:45.374]                       inherits <- base::inherits
[13:23:45.374]                       invokeRestart <- base::invokeRestart
[13:23:45.374]                       is.null <- base::is.null
[13:23:45.374]                       muffled <- FALSE
[13:23:45.374]                       if (inherits(cond, "message")) {
[13:23:45.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.374]                         if (muffled) 
[13:23:45.374]                           invokeRestart("muffleMessage")
[13:23:45.374]                       }
[13:23:45.374]                       else if (inherits(cond, "warning")) {
[13:23:45.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.374]                         if (muffled) 
[13:23:45.374]                           invokeRestart("muffleWarning")
[13:23:45.374]                       }
[13:23:45.374]                       else if (inherits(cond, "condition")) {
[13:23:45.374]                         if (!is.null(pattern)) {
[13:23:45.374]                           computeRestarts <- base::computeRestarts
[13:23:45.374]                           grepl <- base::grepl
[13:23:45.374]                           restarts <- computeRestarts(cond)
[13:23:45.374]                           for (restart in restarts) {
[13:23:45.374]                             name <- restart$name
[13:23:45.374]                             if (is.null(name)) 
[13:23:45.374]                               next
[13:23:45.374]                             if (!grepl(pattern, name)) 
[13:23:45.374]                               next
[13:23:45.374]                             invokeRestart(restart)
[13:23:45.374]                             muffled <- TRUE
[13:23:45.374]                             break
[13:23:45.374]                           }
[13:23:45.374]                         }
[13:23:45.374]                       }
[13:23:45.374]                       invisible(muffled)
[13:23:45.374]                     }
[13:23:45.374]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.374]                   }
[13:23:45.374]                 }
[13:23:45.374]             }
[13:23:45.374]         }))
[13:23:45.374]     }, error = function(ex) {
[13:23:45.374]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.374]                 ...future.rng), started = ...future.startTime, 
[13:23:45.374]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.374]             version = "1.8"), class = "FutureResult")
[13:23:45.374]     }, finally = {
[13:23:45.374]         if (!identical(...future.workdir, getwd())) 
[13:23:45.374]             setwd(...future.workdir)
[13:23:45.374]         {
[13:23:45.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.374]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.374]             }
[13:23:45.374]             base::options(...future.oldOptions)
[13:23:45.374]             if (.Platform$OS.type == "windows") {
[13:23:45.374]                 old_names <- names(...future.oldEnvVars)
[13:23:45.374]                 envs <- base::Sys.getenv()
[13:23:45.374]                 names <- names(envs)
[13:23:45.374]                 common <- intersect(names, old_names)
[13:23:45.374]                 added <- setdiff(names, old_names)
[13:23:45.374]                 removed <- setdiff(old_names, names)
[13:23:45.374]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.374]                   envs[common]]
[13:23:45.374]                 NAMES <- toupper(changed)
[13:23:45.374]                 args <- list()
[13:23:45.374]                 for (kk in seq_along(NAMES)) {
[13:23:45.374]                   name <- changed[[kk]]
[13:23:45.374]                   NAME <- NAMES[[kk]]
[13:23:45.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.374]                     next
[13:23:45.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.374]                 }
[13:23:45.374]                 NAMES <- toupper(added)
[13:23:45.374]                 for (kk in seq_along(NAMES)) {
[13:23:45.374]                   name <- added[[kk]]
[13:23:45.374]                   NAME <- NAMES[[kk]]
[13:23:45.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.374]                     next
[13:23:45.374]                   args[[name]] <- ""
[13:23:45.374]                 }
[13:23:45.374]                 NAMES <- toupper(removed)
[13:23:45.374]                 for (kk in seq_along(NAMES)) {
[13:23:45.374]                   name <- removed[[kk]]
[13:23:45.374]                   NAME <- NAMES[[kk]]
[13:23:45.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.374]                     next
[13:23:45.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.374]                 }
[13:23:45.374]                 if (length(args) > 0) 
[13:23:45.374]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.374]             }
[13:23:45.374]             else {
[13:23:45.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.374]             }
[13:23:45.374]             {
[13:23:45.374]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.374]                   0L) {
[13:23:45.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.374]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.374]                   base::options(opts)
[13:23:45.374]                 }
[13:23:45.374]                 {
[13:23:45.374]                   {
[13:23:45.374]                     NULL
[13:23:45.374]                     RNGkind("Mersenne-Twister")
[13:23:45.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.374]                       inherits = FALSE)
[13:23:45.374]                   }
[13:23:45.374]                   options(future.plan = NULL)
[13:23:45.374]                   if (is.na(NA_character_)) 
[13:23:45.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.374]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.374]                     envir = parent.frame()) 
[13:23:45.374]                   {
[13:23:45.374]                     default_workers <- missing(workers)
[13:23:45.374]                     if (is.function(workers)) 
[13:23:45.374]                       workers <- workers()
[13:23:45.374]                     workers <- structure(as.integer(workers), 
[13:23:45.374]                       class = class(workers))
[13:23:45.374]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.374]                       1L)
[13:23:45.374]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.374]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.374]                       if (default_workers) 
[13:23:45.374]                         supportsMulticore(warn = TRUE)
[13:23:45.374]                       return(sequential(..., envir = envir))
[13:23:45.374]                     }
[13:23:45.374]                     oopts <- options(mc.cores = workers)
[13:23:45.374]                     on.exit(options(oopts))
[13:23:45.374]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.374]                       envir = envir)
[13:23:45.374]                     if (!future$lazy) 
[13:23:45.374]                       future <- run(future)
[13:23:45.374]                     invisible(future)
[13:23:45.374]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.374]                 }
[13:23:45.374]             }
[13:23:45.374]         }
[13:23:45.374]     })
[13:23:45.374]     if (TRUE) {
[13:23:45.374]         base::sink(type = "output", split = FALSE)
[13:23:45.374]         if (TRUE) {
[13:23:45.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.374]         }
[13:23:45.374]         else {
[13:23:45.374]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.374]         }
[13:23:45.374]         base::close(...future.stdout)
[13:23:45.374]         ...future.stdout <- NULL
[13:23:45.374]     }
[13:23:45.374]     ...future.result$conditions <- ...future.conditions
[13:23:45.374]     ...future.result$finished <- base::Sys.time()
[13:23:45.374]     ...future.result
[13:23:45.374] }
[13:23:45.376] plan(): Setting new future strategy stack:
[13:23:45.376] List of future strategies:
[13:23:45.376] 1. sequential:
[13:23:45.376]    - args: function (..., envir = parent.frame())
[13:23:45.376]    - tweaked: FALSE
[13:23:45.376]    - call: NULL
[13:23:45.376] plan(): nbrOfWorkers() = 1
[13:23:45.377] plan(): Setting new future strategy stack:
[13:23:45.377] List of future strategies:
[13:23:45.377] 1. multicore:
[13:23:45.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.377]    - tweaked: FALSE
[13:23:45.377]    - call: plan(multicore)
[13:23:45.381] plan(): nbrOfWorkers() = 1
[13:23:45.381] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[13:23:45.384] getGlobalsAndPackages() ...
[13:23:45.384] Not searching for globals
[13:23:45.384] - globals: [0] <none>
[13:23:45.384] getGlobalsAndPackages() ... DONE
[13:23:45.385] Packages needed by the future expression (n = 0): <none>
[13:23:45.385] Packages needed by future strategies (n = 0): <none>
[13:23:45.385] {
[13:23:45.385]     {
[13:23:45.385]         {
[13:23:45.385]             ...future.startTime <- base::Sys.time()
[13:23:45.385]             {
[13:23:45.385]                 {
[13:23:45.385]                   {
[13:23:45.385]                     base::local({
[13:23:45.385]                       has_future <- base::requireNamespace("future", 
[13:23:45.385]                         quietly = TRUE)
[13:23:45.385]                       if (has_future) {
[13:23:45.385]                         ns <- base::getNamespace("future")
[13:23:45.385]                         version <- ns[[".package"]][["version"]]
[13:23:45.385]                         if (is.null(version)) 
[13:23:45.385]                           version <- utils::packageVersion("future")
[13:23:45.385]                       }
[13:23:45.385]                       else {
[13:23:45.385]                         version <- NULL
[13:23:45.385]                       }
[13:23:45.385]                       if (!has_future || version < "1.8.0") {
[13:23:45.385]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.385]                           "", base::R.version$version.string), 
[13:23:45.385]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.385]                             "release", "version")], collapse = " "), 
[13:23:45.385]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.385]                           info)
[13:23:45.385]                         info <- base::paste(info, collapse = "; ")
[13:23:45.385]                         if (!has_future) {
[13:23:45.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.385]                             info)
[13:23:45.385]                         }
[13:23:45.385]                         else {
[13:23:45.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.385]                             info, version)
[13:23:45.385]                         }
[13:23:45.385]                         base::stop(msg)
[13:23:45.385]                       }
[13:23:45.385]                     })
[13:23:45.385]                   }
[13:23:45.385]                   options(future.plan = NULL)
[13:23:45.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.385]                 }
[13:23:45.385]                 ...future.workdir <- getwd()
[13:23:45.385]             }
[13:23:45.385]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.385]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.385]         }
[13:23:45.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.385]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.385]             base::names(...future.oldOptions))
[13:23:45.385]     }
[13:23:45.385]     if (FALSE) {
[13:23:45.385]     }
[13:23:45.385]     else {
[13:23:45.385]         if (TRUE) {
[13:23:45.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.385]                 open = "w")
[13:23:45.385]         }
[13:23:45.385]         else {
[13:23:45.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.385]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.385]         }
[13:23:45.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.385]             base::sink(type = "output", split = FALSE)
[13:23:45.385]             base::close(...future.stdout)
[13:23:45.385]         }, add = TRUE)
[13:23:45.385]     }
[13:23:45.385]     ...future.frame <- base::sys.nframe()
[13:23:45.385]     ...future.conditions <- base::list()
[13:23:45.385]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.385]     if (FALSE) {
[13:23:45.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.385]     }
[13:23:45.385]     ...future.result <- base::tryCatch({
[13:23:45.385]         base::withCallingHandlers({
[13:23:45.385]             ...future.value <- base::withVisible(base::local({
[13:23:45.385]                 ii
[13:23:45.385]             }))
[13:23:45.385]             future::FutureResult(value = ...future.value$value, 
[13:23:45.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.385]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.385]                     ...future.globalenv.names))
[13:23:45.385]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.385]         }, condition = base::local({
[13:23:45.385]             c <- base::c
[13:23:45.385]             inherits <- base::inherits
[13:23:45.385]             invokeRestart <- base::invokeRestart
[13:23:45.385]             length <- base::length
[13:23:45.385]             list <- base::list
[13:23:45.385]             seq.int <- base::seq.int
[13:23:45.385]             signalCondition <- base::signalCondition
[13:23:45.385]             sys.calls <- base::sys.calls
[13:23:45.385]             `[[` <- base::`[[`
[13:23:45.385]             `+` <- base::`+`
[13:23:45.385]             `<<-` <- base::`<<-`
[13:23:45.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.385]                   3L)]
[13:23:45.385]             }
[13:23:45.385]             function(cond) {
[13:23:45.385]                 is_error <- inherits(cond, "error")
[13:23:45.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.385]                   NULL)
[13:23:45.385]                 if (is_error) {
[13:23:45.385]                   sessionInformation <- function() {
[13:23:45.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.385]                       search = base::search(), system = base::Sys.info())
[13:23:45.385]                   }
[13:23:45.385]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.385]                     cond$call), session = sessionInformation(), 
[13:23:45.385]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.385]                   signalCondition(cond)
[13:23:45.385]                 }
[13:23:45.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.385]                 "immediateCondition"))) {
[13:23:45.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.385]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.385]                   if (TRUE && !signal) {
[13:23:45.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.385]                     {
[13:23:45.385]                       inherits <- base::inherits
[13:23:45.385]                       invokeRestart <- base::invokeRestart
[13:23:45.385]                       is.null <- base::is.null
[13:23:45.385]                       muffled <- FALSE
[13:23:45.385]                       if (inherits(cond, "message")) {
[13:23:45.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.385]                         if (muffled) 
[13:23:45.385]                           invokeRestart("muffleMessage")
[13:23:45.385]                       }
[13:23:45.385]                       else if (inherits(cond, "warning")) {
[13:23:45.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.385]                         if (muffled) 
[13:23:45.385]                           invokeRestart("muffleWarning")
[13:23:45.385]                       }
[13:23:45.385]                       else if (inherits(cond, "condition")) {
[13:23:45.385]                         if (!is.null(pattern)) {
[13:23:45.385]                           computeRestarts <- base::computeRestarts
[13:23:45.385]                           grepl <- base::grepl
[13:23:45.385]                           restarts <- computeRestarts(cond)
[13:23:45.385]                           for (restart in restarts) {
[13:23:45.385]                             name <- restart$name
[13:23:45.385]                             if (is.null(name)) 
[13:23:45.385]                               next
[13:23:45.385]                             if (!grepl(pattern, name)) 
[13:23:45.385]                               next
[13:23:45.385]                             invokeRestart(restart)
[13:23:45.385]                             muffled <- TRUE
[13:23:45.385]                             break
[13:23:45.385]                           }
[13:23:45.385]                         }
[13:23:45.385]                       }
[13:23:45.385]                       invisible(muffled)
[13:23:45.385]                     }
[13:23:45.385]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.385]                   }
[13:23:45.385]                 }
[13:23:45.385]                 else {
[13:23:45.385]                   if (TRUE) {
[13:23:45.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.385]                     {
[13:23:45.385]                       inherits <- base::inherits
[13:23:45.385]                       invokeRestart <- base::invokeRestart
[13:23:45.385]                       is.null <- base::is.null
[13:23:45.385]                       muffled <- FALSE
[13:23:45.385]                       if (inherits(cond, "message")) {
[13:23:45.385]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.385]                         if (muffled) 
[13:23:45.385]                           invokeRestart("muffleMessage")
[13:23:45.385]                       }
[13:23:45.385]                       else if (inherits(cond, "warning")) {
[13:23:45.385]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.385]                         if (muffled) 
[13:23:45.385]                           invokeRestart("muffleWarning")
[13:23:45.385]                       }
[13:23:45.385]                       else if (inherits(cond, "condition")) {
[13:23:45.385]                         if (!is.null(pattern)) {
[13:23:45.385]                           computeRestarts <- base::computeRestarts
[13:23:45.385]                           grepl <- base::grepl
[13:23:45.385]                           restarts <- computeRestarts(cond)
[13:23:45.385]                           for (restart in restarts) {
[13:23:45.385]                             name <- restart$name
[13:23:45.385]                             if (is.null(name)) 
[13:23:45.385]                               next
[13:23:45.385]                             if (!grepl(pattern, name)) 
[13:23:45.385]                               next
[13:23:45.385]                             invokeRestart(restart)
[13:23:45.385]                             muffled <- TRUE
[13:23:45.385]                             break
[13:23:45.385]                           }
[13:23:45.385]                         }
[13:23:45.385]                       }
[13:23:45.385]                       invisible(muffled)
[13:23:45.385]                     }
[13:23:45.385]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.385]                   }
[13:23:45.385]                 }
[13:23:45.385]             }
[13:23:45.385]         }))
[13:23:45.385]     }, error = function(ex) {
[13:23:45.385]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.385]                 ...future.rng), started = ...future.startTime, 
[13:23:45.385]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.385]             version = "1.8"), class = "FutureResult")
[13:23:45.385]     }, finally = {
[13:23:45.385]         if (!identical(...future.workdir, getwd())) 
[13:23:45.385]             setwd(...future.workdir)
[13:23:45.385]         {
[13:23:45.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.385]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.385]             }
[13:23:45.385]             base::options(...future.oldOptions)
[13:23:45.385]             if (.Platform$OS.type == "windows") {
[13:23:45.385]                 old_names <- names(...future.oldEnvVars)
[13:23:45.385]                 envs <- base::Sys.getenv()
[13:23:45.385]                 names <- names(envs)
[13:23:45.385]                 common <- intersect(names, old_names)
[13:23:45.385]                 added <- setdiff(names, old_names)
[13:23:45.385]                 removed <- setdiff(old_names, names)
[13:23:45.385]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.385]                   envs[common]]
[13:23:45.385]                 NAMES <- toupper(changed)
[13:23:45.385]                 args <- list()
[13:23:45.385]                 for (kk in seq_along(NAMES)) {
[13:23:45.385]                   name <- changed[[kk]]
[13:23:45.385]                   NAME <- NAMES[[kk]]
[13:23:45.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.385]                     next
[13:23:45.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.385]                 }
[13:23:45.385]                 NAMES <- toupper(added)
[13:23:45.385]                 for (kk in seq_along(NAMES)) {
[13:23:45.385]                   name <- added[[kk]]
[13:23:45.385]                   NAME <- NAMES[[kk]]
[13:23:45.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.385]                     next
[13:23:45.385]                   args[[name]] <- ""
[13:23:45.385]                 }
[13:23:45.385]                 NAMES <- toupper(removed)
[13:23:45.385]                 for (kk in seq_along(NAMES)) {
[13:23:45.385]                   name <- removed[[kk]]
[13:23:45.385]                   NAME <- NAMES[[kk]]
[13:23:45.385]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.385]                     next
[13:23:45.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.385]                 }
[13:23:45.385]                 if (length(args) > 0) 
[13:23:45.385]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.385]             }
[13:23:45.385]             else {
[13:23:45.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.385]             }
[13:23:45.385]             {
[13:23:45.385]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.385]                   0L) {
[13:23:45.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.385]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.385]                   base::options(opts)
[13:23:45.385]                 }
[13:23:45.385]                 {
[13:23:45.385]                   {
[13:23:45.385]                     NULL
[13:23:45.385]                     RNGkind("Mersenne-Twister")
[13:23:45.385]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.385]                       inherits = FALSE)
[13:23:45.385]                   }
[13:23:45.385]                   options(future.plan = NULL)
[13:23:45.385]                   if (is.na(NA_character_)) 
[13:23:45.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.385]                     envir = parent.frame()) 
[13:23:45.385]                   {
[13:23:45.385]                     default_workers <- missing(workers)
[13:23:45.385]                     if (is.function(workers)) 
[13:23:45.385]                       workers <- workers()
[13:23:45.385]                     workers <- structure(as.integer(workers), 
[13:23:45.385]                       class = class(workers))
[13:23:45.385]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.385]                       1L)
[13:23:45.385]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.385]                       if (default_workers) 
[13:23:45.385]                         supportsMulticore(warn = TRUE)
[13:23:45.385]                       return(sequential(..., envir = envir))
[13:23:45.385]                     }
[13:23:45.385]                     oopts <- options(mc.cores = workers)
[13:23:45.385]                     on.exit(options(oopts))
[13:23:45.385]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.385]                       envir = envir)
[13:23:45.385]                     if (!future$lazy) 
[13:23:45.385]                       future <- run(future)
[13:23:45.385]                     invisible(future)
[13:23:45.385]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.385]                 }
[13:23:45.385]             }
[13:23:45.385]         }
[13:23:45.385]     })
[13:23:45.385]     if (TRUE) {
[13:23:45.385]         base::sink(type = "output", split = FALSE)
[13:23:45.385]         if (TRUE) {
[13:23:45.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.385]         }
[13:23:45.385]         else {
[13:23:45.385]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.385]         }
[13:23:45.385]         base::close(...future.stdout)
[13:23:45.385]         ...future.stdout <- NULL
[13:23:45.385]     }
[13:23:45.385]     ...future.result$conditions <- ...future.conditions
[13:23:45.385]     ...future.result$finished <- base::Sys.time()
[13:23:45.385]     ...future.result
[13:23:45.385] }
[13:23:45.387] plan(): Setting new future strategy stack:
[13:23:45.387] List of future strategies:
[13:23:45.387] 1. sequential:
[13:23:45.387]    - args: function (..., envir = parent.frame())
[13:23:45.387]    - tweaked: FALSE
[13:23:45.387]    - call: NULL
[13:23:45.388] plan(): nbrOfWorkers() = 1
[13:23:45.388] plan(): Setting new future strategy stack:
[13:23:45.389] List of future strategies:
[13:23:45.389] 1. multicore:
[13:23:45.389]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.389]    - tweaked: FALSE
[13:23:45.389]    - call: plan(multicore)
[13:23:45.392] plan(): nbrOfWorkers() = 1
[13:23:45.392] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[13:23:45.396] getGlobalsAndPackages() ...
[13:23:45.396] Not searching for globals
[13:23:45.396] - globals: [0] <none>
[13:23:45.397] getGlobalsAndPackages() ... DONE
[13:23:45.397] Packages needed by the future expression (n = 0): <none>
[13:23:45.397] Packages needed by future strategies (n = 0): <none>
[13:23:45.397] {
[13:23:45.397]     {
[13:23:45.397]         {
[13:23:45.397]             ...future.startTime <- base::Sys.time()
[13:23:45.397]             {
[13:23:45.397]                 {
[13:23:45.397]                   {
[13:23:45.397]                     base::local({
[13:23:45.397]                       has_future <- base::requireNamespace("future", 
[13:23:45.397]                         quietly = TRUE)
[13:23:45.397]                       if (has_future) {
[13:23:45.397]                         ns <- base::getNamespace("future")
[13:23:45.397]                         version <- ns[[".package"]][["version"]]
[13:23:45.397]                         if (is.null(version)) 
[13:23:45.397]                           version <- utils::packageVersion("future")
[13:23:45.397]                       }
[13:23:45.397]                       else {
[13:23:45.397]                         version <- NULL
[13:23:45.397]                       }
[13:23:45.397]                       if (!has_future || version < "1.8.0") {
[13:23:45.397]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.397]                           "", base::R.version$version.string), 
[13:23:45.397]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.397]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.397]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.397]                             "release", "version")], collapse = " "), 
[13:23:45.397]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.397]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.397]                           info)
[13:23:45.397]                         info <- base::paste(info, collapse = "; ")
[13:23:45.397]                         if (!has_future) {
[13:23:45.397]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.397]                             info)
[13:23:45.397]                         }
[13:23:45.397]                         else {
[13:23:45.397]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.397]                             info, version)
[13:23:45.397]                         }
[13:23:45.397]                         base::stop(msg)
[13:23:45.397]                       }
[13:23:45.397]                     })
[13:23:45.397]                   }
[13:23:45.397]                   options(future.plan = NULL)
[13:23:45.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.397]                 }
[13:23:45.397]                 ...future.workdir <- getwd()
[13:23:45.397]             }
[13:23:45.397]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.397]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.397]         }
[13:23:45.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.397]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.397]             base::names(...future.oldOptions))
[13:23:45.397]     }
[13:23:45.397]     if (FALSE) {
[13:23:45.397]     }
[13:23:45.397]     else {
[13:23:45.397]         if (TRUE) {
[13:23:45.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.397]                 open = "w")
[13:23:45.397]         }
[13:23:45.397]         else {
[13:23:45.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.397]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.397]         }
[13:23:45.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.397]             base::sink(type = "output", split = FALSE)
[13:23:45.397]             base::close(...future.stdout)
[13:23:45.397]         }, add = TRUE)
[13:23:45.397]     }
[13:23:45.397]     ...future.frame <- base::sys.nframe()
[13:23:45.397]     ...future.conditions <- base::list()
[13:23:45.397]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.397]     if (FALSE) {
[13:23:45.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.397]     }
[13:23:45.397]     ...future.result <- base::tryCatch({
[13:23:45.397]         base::withCallingHandlers({
[13:23:45.397]             ...future.value <- base::withVisible(base::local({
[13:23:45.397]                 stop("Whoops!")
[13:23:45.397]                 1
[13:23:45.397]             }))
[13:23:45.397]             future::FutureResult(value = ...future.value$value, 
[13:23:45.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.397]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.397]                     ...future.globalenv.names))
[13:23:45.397]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.397]         }, condition = base::local({
[13:23:45.397]             c <- base::c
[13:23:45.397]             inherits <- base::inherits
[13:23:45.397]             invokeRestart <- base::invokeRestart
[13:23:45.397]             length <- base::length
[13:23:45.397]             list <- base::list
[13:23:45.397]             seq.int <- base::seq.int
[13:23:45.397]             signalCondition <- base::signalCondition
[13:23:45.397]             sys.calls <- base::sys.calls
[13:23:45.397]             `[[` <- base::`[[`
[13:23:45.397]             `+` <- base::`+`
[13:23:45.397]             `<<-` <- base::`<<-`
[13:23:45.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.397]                   3L)]
[13:23:45.397]             }
[13:23:45.397]             function(cond) {
[13:23:45.397]                 is_error <- inherits(cond, "error")
[13:23:45.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.397]                   NULL)
[13:23:45.397]                 if (is_error) {
[13:23:45.397]                   sessionInformation <- function() {
[13:23:45.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.397]                       search = base::search(), system = base::Sys.info())
[13:23:45.397]                   }
[13:23:45.397]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.397]                     cond$call), session = sessionInformation(), 
[13:23:45.397]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.397]                   signalCondition(cond)
[13:23:45.397]                 }
[13:23:45.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.397]                 "immediateCondition"))) {
[13:23:45.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.397]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.397]                   if (TRUE && !signal) {
[13:23:45.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.397]                     {
[13:23:45.397]                       inherits <- base::inherits
[13:23:45.397]                       invokeRestart <- base::invokeRestart
[13:23:45.397]                       is.null <- base::is.null
[13:23:45.397]                       muffled <- FALSE
[13:23:45.397]                       if (inherits(cond, "message")) {
[13:23:45.397]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.397]                         if (muffled) 
[13:23:45.397]                           invokeRestart("muffleMessage")
[13:23:45.397]                       }
[13:23:45.397]                       else if (inherits(cond, "warning")) {
[13:23:45.397]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.397]                         if (muffled) 
[13:23:45.397]                           invokeRestart("muffleWarning")
[13:23:45.397]                       }
[13:23:45.397]                       else if (inherits(cond, "condition")) {
[13:23:45.397]                         if (!is.null(pattern)) {
[13:23:45.397]                           computeRestarts <- base::computeRestarts
[13:23:45.397]                           grepl <- base::grepl
[13:23:45.397]                           restarts <- computeRestarts(cond)
[13:23:45.397]                           for (restart in restarts) {
[13:23:45.397]                             name <- restart$name
[13:23:45.397]                             if (is.null(name)) 
[13:23:45.397]                               next
[13:23:45.397]                             if (!grepl(pattern, name)) 
[13:23:45.397]                               next
[13:23:45.397]                             invokeRestart(restart)
[13:23:45.397]                             muffled <- TRUE
[13:23:45.397]                             break
[13:23:45.397]                           }
[13:23:45.397]                         }
[13:23:45.397]                       }
[13:23:45.397]                       invisible(muffled)
[13:23:45.397]                     }
[13:23:45.397]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.397]                   }
[13:23:45.397]                 }
[13:23:45.397]                 else {
[13:23:45.397]                   if (TRUE) {
[13:23:45.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.397]                     {
[13:23:45.397]                       inherits <- base::inherits
[13:23:45.397]                       invokeRestart <- base::invokeRestart
[13:23:45.397]                       is.null <- base::is.null
[13:23:45.397]                       muffled <- FALSE
[13:23:45.397]                       if (inherits(cond, "message")) {
[13:23:45.397]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.397]                         if (muffled) 
[13:23:45.397]                           invokeRestart("muffleMessage")
[13:23:45.397]                       }
[13:23:45.397]                       else if (inherits(cond, "warning")) {
[13:23:45.397]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.397]                         if (muffled) 
[13:23:45.397]                           invokeRestart("muffleWarning")
[13:23:45.397]                       }
[13:23:45.397]                       else if (inherits(cond, "condition")) {
[13:23:45.397]                         if (!is.null(pattern)) {
[13:23:45.397]                           computeRestarts <- base::computeRestarts
[13:23:45.397]                           grepl <- base::grepl
[13:23:45.397]                           restarts <- computeRestarts(cond)
[13:23:45.397]                           for (restart in restarts) {
[13:23:45.397]                             name <- restart$name
[13:23:45.397]                             if (is.null(name)) 
[13:23:45.397]                               next
[13:23:45.397]                             if (!grepl(pattern, name)) 
[13:23:45.397]                               next
[13:23:45.397]                             invokeRestart(restart)
[13:23:45.397]                             muffled <- TRUE
[13:23:45.397]                             break
[13:23:45.397]                           }
[13:23:45.397]                         }
[13:23:45.397]                       }
[13:23:45.397]                       invisible(muffled)
[13:23:45.397]                     }
[13:23:45.397]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.397]                   }
[13:23:45.397]                 }
[13:23:45.397]             }
[13:23:45.397]         }))
[13:23:45.397]     }, error = function(ex) {
[13:23:45.397]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.397]                 ...future.rng), started = ...future.startTime, 
[13:23:45.397]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.397]             version = "1.8"), class = "FutureResult")
[13:23:45.397]     }, finally = {
[13:23:45.397]         if (!identical(...future.workdir, getwd())) 
[13:23:45.397]             setwd(...future.workdir)
[13:23:45.397]         {
[13:23:45.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.397]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.397]             }
[13:23:45.397]             base::options(...future.oldOptions)
[13:23:45.397]             if (.Platform$OS.type == "windows") {
[13:23:45.397]                 old_names <- names(...future.oldEnvVars)
[13:23:45.397]                 envs <- base::Sys.getenv()
[13:23:45.397]                 names <- names(envs)
[13:23:45.397]                 common <- intersect(names, old_names)
[13:23:45.397]                 added <- setdiff(names, old_names)
[13:23:45.397]                 removed <- setdiff(old_names, names)
[13:23:45.397]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.397]                   envs[common]]
[13:23:45.397]                 NAMES <- toupper(changed)
[13:23:45.397]                 args <- list()
[13:23:45.397]                 for (kk in seq_along(NAMES)) {
[13:23:45.397]                   name <- changed[[kk]]
[13:23:45.397]                   NAME <- NAMES[[kk]]
[13:23:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.397]                     next
[13:23:45.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.397]                 }
[13:23:45.397]                 NAMES <- toupper(added)
[13:23:45.397]                 for (kk in seq_along(NAMES)) {
[13:23:45.397]                   name <- added[[kk]]
[13:23:45.397]                   NAME <- NAMES[[kk]]
[13:23:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.397]                     next
[13:23:45.397]                   args[[name]] <- ""
[13:23:45.397]                 }
[13:23:45.397]                 NAMES <- toupper(removed)
[13:23:45.397]                 for (kk in seq_along(NAMES)) {
[13:23:45.397]                   name <- removed[[kk]]
[13:23:45.397]                   NAME <- NAMES[[kk]]
[13:23:45.397]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.397]                     next
[13:23:45.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.397]                 }
[13:23:45.397]                 if (length(args) > 0) 
[13:23:45.397]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.397]             }
[13:23:45.397]             else {
[13:23:45.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.397]             }
[13:23:45.397]             {
[13:23:45.397]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.397]                   0L) {
[13:23:45.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.397]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.397]                   base::options(opts)
[13:23:45.397]                 }
[13:23:45.397]                 {
[13:23:45.397]                   {
[13:23:45.397]                     NULL
[13:23:45.397]                     RNGkind("Mersenne-Twister")
[13:23:45.397]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.397]                       inherits = FALSE)
[13:23:45.397]                   }
[13:23:45.397]                   options(future.plan = NULL)
[13:23:45.397]                   if (is.na(NA_character_)) 
[13:23:45.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.397]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.397]                     envir = parent.frame()) 
[13:23:45.397]                   {
[13:23:45.397]                     default_workers <- missing(workers)
[13:23:45.397]                     if (is.function(workers)) 
[13:23:45.397]                       workers <- workers()
[13:23:45.397]                     workers <- structure(as.integer(workers), 
[13:23:45.397]                       class = class(workers))
[13:23:45.397]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.397]                       1L)
[13:23:45.397]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.397]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.397]                       if (default_workers) 
[13:23:45.397]                         supportsMulticore(warn = TRUE)
[13:23:45.397]                       return(sequential(..., envir = envir))
[13:23:45.397]                     }
[13:23:45.397]                     oopts <- options(mc.cores = workers)
[13:23:45.397]                     on.exit(options(oopts))
[13:23:45.397]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.397]                       envir = envir)
[13:23:45.397]                     if (!future$lazy) 
[13:23:45.397]                       future <- run(future)
[13:23:45.397]                     invisible(future)
[13:23:45.397]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.397]                 }
[13:23:45.397]             }
[13:23:45.397]         }
[13:23:45.397]     })
[13:23:45.397]     if (TRUE) {
[13:23:45.397]         base::sink(type = "output", split = FALSE)
[13:23:45.397]         if (TRUE) {
[13:23:45.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.397]         }
[13:23:45.397]         else {
[13:23:45.397]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.397]         }
[13:23:45.397]         base::close(...future.stdout)
[13:23:45.397]         ...future.stdout <- NULL
[13:23:45.397]     }
[13:23:45.397]     ...future.result$conditions <- ...future.conditions
[13:23:45.397]     ...future.result$finished <- base::Sys.time()
[13:23:45.397]     ...future.result
[13:23:45.397] }
[13:23:45.399] plan(): Setting new future strategy stack:
[13:23:45.399] List of future strategies:
[13:23:45.399] 1. sequential:
[13:23:45.399]    - args: function (..., envir = parent.frame())
[13:23:45.399]    - tweaked: FALSE
[13:23:45.399]    - call: NULL
[13:23:45.400] plan(): nbrOfWorkers() = 1
[13:23:45.401] plan(): Setting new future strategy stack:
[13:23:45.401] List of future strategies:
[13:23:45.401] 1. multicore:
[13:23:45.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.401]    - tweaked: FALSE
[13:23:45.401]    - call: plan(multicore)
[13:23:45.404] plan(): nbrOfWorkers() = 1
[13:23:45.404] SequentialFuture started (and completed)
[13:23:45.404] signalConditions() ...
[13:23:45.405]  - include = ‘immediateCondition’
[13:23:45.405]  - exclude = 
[13:23:45.405]  - resignal = FALSE
[13:23:45.405]  - Number of conditions: 1
[13:23:45.405] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:45.406] signalConditions() ...
[13:23:45.406]  - include = ‘immediateCondition’
[13:23:45.406]  - exclude = 
[13:23:45.406]  - resignal = FALSE
[13:23:45.406]  - Number of conditions: 1
[13:23:45.406] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.406] signalConditions() ...
[13:23:45.406]  - include = ‘immediateCondition’
[13:23:45.407]  - exclude = 
[13:23:45.407]  - resignal = FALSE
[13:23:45.407]  - Number of conditions: 1
[13:23:45.407] signalConditions() ... done
[13:23:45.407] Future state: ‘finished’
[13:23:45.407] signalConditions() ...
[13:23:45.407]  - include = ‘condition’
[13:23:45.407]  - exclude = ‘immediateCondition’
[13:23:45.407]  - resignal = TRUE
[13:23:45.407]  - Number of conditions: 1
[13:23:45.407]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.408] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.408] signalConditions() ...
[13:23:45.408]  - include = ‘immediateCondition’
[13:23:45.408]  - exclude = 
[13:23:45.408]  - resignal = FALSE
[13:23:45.408]  - Number of conditions: 1
[13:23:45.408] signalConditions() ... done
[13:23:45.409] Future state: ‘finished’
[13:23:45.409] signalConditions() ...
[13:23:45.409]  - include = ‘condition’
[13:23:45.409]  - exclude = ‘immediateCondition’
[13:23:45.409]  - resignal = TRUE
[13:23:45.409]  - Number of conditions: 1
[13:23:45.409]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.409] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.413] getGlobalsAndPackages() ...
[13:23:45.413] Searching for globals...
[13:23:45.422] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[13:23:45.422] Searching for globals ... DONE
[13:23:45.422] Resolving globals: FALSE
[13:23:45.423] 
[13:23:45.423] 
[13:23:45.423] getGlobalsAndPackages() ... DONE
[13:23:45.423] Packages needed by the future expression (n = 0): <none>
[13:23:45.423] Packages needed by future strategies (n = 0): <none>
[13:23:45.424] {
[13:23:45.424]     {
[13:23:45.424]         {
[13:23:45.424]             ...future.startTime <- base::Sys.time()
[13:23:45.424]             {
[13:23:45.424]                 {
[13:23:45.424]                   {
[13:23:45.424]                     base::local({
[13:23:45.424]                       has_future <- base::requireNamespace("future", 
[13:23:45.424]                         quietly = TRUE)
[13:23:45.424]                       if (has_future) {
[13:23:45.424]                         ns <- base::getNamespace("future")
[13:23:45.424]                         version <- ns[[".package"]][["version"]]
[13:23:45.424]                         if (is.null(version)) 
[13:23:45.424]                           version <- utils::packageVersion("future")
[13:23:45.424]                       }
[13:23:45.424]                       else {
[13:23:45.424]                         version <- NULL
[13:23:45.424]                       }
[13:23:45.424]                       if (!has_future || version < "1.8.0") {
[13:23:45.424]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.424]                           "", base::R.version$version.string), 
[13:23:45.424]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.424]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.424]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.424]                             "release", "version")], collapse = " "), 
[13:23:45.424]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.424]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.424]                           info)
[13:23:45.424]                         info <- base::paste(info, collapse = "; ")
[13:23:45.424]                         if (!has_future) {
[13:23:45.424]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.424]                             info)
[13:23:45.424]                         }
[13:23:45.424]                         else {
[13:23:45.424]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.424]                             info, version)
[13:23:45.424]                         }
[13:23:45.424]                         base::stop(msg)
[13:23:45.424]                       }
[13:23:45.424]                     })
[13:23:45.424]                   }
[13:23:45.424]                   options(future.plan = NULL)
[13:23:45.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.424]                 }
[13:23:45.424]                 ...future.workdir <- getwd()
[13:23:45.424]             }
[13:23:45.424]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.424]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.424]         }
[13:23:45.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.424]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.424]             base::names(...future.oldOptions))
[13:23:45.424]     }
[13:23:45.424]     if (FALSE) {
[13:23:45.424]     }
[13:23:45.424]     else {
[13:23:45.424]         if (TRUE) {
[13:23:45.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.424]                 open = "w")
[13:23:45.424]         }
[13:23:45.424]         else {
[13:23:45.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.424]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.424]         }
[13:23:45.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.424]             base::sink(type = "output", split = FALSE)
[13:23:45.424]             base::close(...future.stdout)
[13:23:45.424]         }, add = TRUE)
[13:23:45.424]     }
[13:23:45.424]     ...future.frame <- base::sys.nframe()
[13:23:45.424]     ...future.conditions <- base::list()
[13:23:45.424]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.424]     if (FALSE) {
[13:23:45.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.424]     }
[13:23:45.424]     ...future.result <- base::tryCatch({
[13:23:45.424]         base::withCallingHandlers({
[13:23:45.424]             ...future.value <- base::withVisible(base::local({
[13:23:45.424]                 stop(structure(list(message = "boom"), class = c("MyError", 
[13:23:45.424]                   "error", "condition")))
[13:23:45.424]             }))
[13:23:45.424]             future::FutureResult(value = ...future.value$value, 
[13:23:45.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.424]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.424]                     ...future.globalenv.names))
[13:23:45.424]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.424]         }, condition = base::local({
[13:23:45.424]             c <- base::c
[13:23:45.424]             inherits <- base::inherits
[13:23:45.424]             invokeRestart <- base::invokeRestart
[13:23:45.424]             length <- base::length
[13:23:45.424]             list <- base::list
[13:23:45.424]             seq.int <- base::seq.int
[13:23:45.424]             signalCondition <- base::signalCondition
[13:23:45.424]             sys.calls <- base::sys.calls
[13:23:45.424]             `[[` <- base::`[[`
[13:23:45.424]             `+` <- base::`+`
[13:23:45.424]             `<<-` <- base::`<<-`
[13:23:45.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.424]                   3L)]
[13:23:45.424]             }
[13:23:45.424]             function(cond) {
[13:23:45.424]                 is_error <- inherits(cond, "error")
[13:23:45.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.424]                   NULL)
[13:23:45.424]                 if (is_error) {
[13:23:45.424]                   sessionInformation <- function() {
[13:23:45.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.424]                       search = base::search(), system = base::Sys.info())
[13:23:45.424]                   }
[13:23:45.424]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.424]                     cond$call), session = sessionInformation(), 
[13:23:45.424]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.424]                   signalCondition(cond)
[13:23:45.424]                 }
[13:23:45.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.424]                 "immediateCondition"))) {
[13:23:45.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.424]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.424]                   if (TRUE && !signal) {
[13:23:45.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.424]                     {
[13:23:45.424]                       inherits <- base::inherits
[13:23:45.424]                       invokeRestart <- base::invokeRestart
[13:23:45.424]                       is.null <- base::is.null
[13:23:45.424]                       muffled <- FALSE
[13:23:45.424]                       if (inherits(cond, "message")) {
[13:23:45.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.424]                         if (muffled) 
[13:23:45.424]                           invokeRestart("muffleMessage")
[13:23:45.424]                       }
[13:23:45.424]                       else if (inherits(cond, "warning")) {
[13:23:45.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.424]                         if (muffled) 
[13:23:45.424]                           invokeRestart("muffleWarning")
[13:23:45.424]                       }
[13:23:45.424]                       else if (inherits(cond, "condition")) {
[13:23:45.424]                         if (!is.null(pattern)) {
[13:23:45.424]                           computeRestarts <- base::computeRestarts
[13:23:45.424]                           grepl <- base::grepl
[13:23:45.424]                           restarts <- computeRestarts(cond)
[13:23:45.424]                           for (restart in restarts) {
[13:23:45.424]                             name <- restart$name
[13:23:45.424]                             if (is.null(name)) 
[13:23:45.424]                               next
[13:23:45.424]                             if (!grepl(pattern, name)) 
[13:23:45.424]                               next
[13:23:45.424]                             invokeRestart(restart)
[13:23:45.424]                             muffled <- TRUE
[13:23:45.424]                             break
[13:23:45.424]                           }
[13:23:45.424]                         }
[13:23:45.424]                       }
[13:23:45.424]                       invisible(muffled)
[13:23:45.424]                     }
[13:23:45.424]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.424]                   }
[13:23:45.424]                 }
[13:23:45.424]                 else {
[13:23:45.424]                   if (TRUE) {
[13:23:45.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.424]                     {
[13:23:45.424]                       inherits <- base::inherits
[13:23:45.424]                       invokeRestart <- base::invokeRestart
[13:23:45.424]                       is.null <- base::is.null
[13:23:45.424]                       muffled <- FALSE
[13:23:45.424]                       if (inherits(cond, "message")) {
[13:23:45.424]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.424]                         if (muffled) 
[13:23:45.424]                           invokeRestart("muffleMessage")
[13:23:45.424]                       }
[13:23:45.424]                       else if (inherits(cond, "warning")) {
[13:23:45.424]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.424]                         if (muffled) 
[13:23:45.424]                           invokeRestart("muffleWarning")
[13:23:45.424]                       }
[13:23:45.424]                       else if (inherits(cond, "condition")) {
[13:23:45.424]                         if (!is.null(pattern)) {
[13:23:45.424]                           computeRestarts <- base::computeRestarts
[13:23:45.424]                           grepl <- base::grepl
[13:23:45.424]                           restarts <- computeRestarts(cond)
[13:23:45.424]                           for (restart in restarts) {
[13:23:45.424]                             name <- restart$name
[13:23:45.424]                             if (is.null(name)) 
[13:23:45.424]                               next
[13:23:45.424]                             if (!grepl(pattern, name)) 
[13:23:45.424]                               next
[13:23:45.424]                             invokeRestart(restart)
[13:23:45.424]                             muffled <- TRUE
[13:23:45.424]                             break
[13:23:45.424]                           }
[13:23:45.424]                         }
[13:23:45.424]                       }
[13:23:45.424]                       invisible(muffled)
[13:23:45.424]                     }
[13:23:45.424]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.424]                   }
[13:23:45.424]                 }
[13:23:45.424]             }
[13:23:45.424]         }))
[13:23:45.424]     }, error = function(ex) {
[13:23:45.424]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.424]                 ...future.rng), started = ...future.startTime, 
[13:23:45.424]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.424]             version = "1.8"), class = "FutureResult")
[13:23:45.424]     }, finally = {
[13:23:45.424]         if (!identical(...future.workdir, getwd())) 
[13:23:45.424]             setwd(...future.workdir)
[13:23:45.424]         {
[13:23:45.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.424]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.424]             }
[13:23:45.424]             base::options(...future.oldOptions)
[13:23:45.424]             if (.Platform$OS.type == "windows") {
[13:23:45.424]                 old_names <- names(...future.oldEnvVars)
[13:23:45.424]                 envs <- base::Sys.getenv()
[13:23:45.424]                 names <- names(envs)
[13:23:45.424]                 common <- intersect(names, old_names)
[13:23:45.424]                 added <- setdiff(names, old_names)
[13:23:45.424]                 removed <- setdiff(old_names, names)
[13:23:45.424]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.424]                   envs[common]]
[13:23:45.424]                 NAMES <- toupper(changed)
[13:23:45.424]                 args <- list()
[13:23:45.424]                 for (kk in seq_along(NAMES)) {
[13:23:45.424]                   name <- changed[[kk]]
[13:23:45.424]                   NAME <- NAMES[[kk]]
[13:23:45.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.424]                     next
[13:23:45.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.424]                 }
[13:23:45.424]                 NAMES <- toupper(added)
[13:23:45.424]                 for (kk in seq_along(NAMES)) {
[13:23:45.424]                   name <- added[[kk]]
[13:23:45.424]                   NAME <- NAMES[[kk]]
[13:23:45.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.424]                     next
[13:23:45.424]                   args[[name]] <- ""
[13:23:45.424]                 }
[13:23:45.424]                 NAMES <- toupper(removed)
[13:23:45.424]                 for (kk in seq_along(NAMES)) {
[13:23:45.424]                   name <- removed[[kk]]
[13:23:45.424]                   NAME <- NAMES[[kk]]
[13:23:45.424]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.424]                     next
[13:23:45.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.424]                 }
[13:23:45.424]                 if (length(args) > 0) 
[13:23:45.424]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.424]             }
[13:23:45.424]             else {
[13:23:45.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.424]             }
[13:23:45.424]             {
[13:23:45.424]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.424]                   0L) {
[13:23:45.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.424]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.424]                   base::options(opts)
[13:23:45.424]                 }
[13:23:45.424]                 {
[13:23:45.424]                   {
[13:23:45.424]                     NULL
[13:23:45.424]                     RNGkind("Mersenne-Twister")
[13:23:45.424]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.424]                       inherits = FALSE)
[13:23:45.424]                   }
[13:23:45.424]                   options(future.plan = NULL)
[13:23:45.424]                   if (is.na(NA_character_)) 
[13:23:45.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.424]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.424]                     envir = parent.frame()) 
[13:23:45.424]                   {
[13:23:45.424]                     default_workers <- missing(workers)
[13:23:45.424]                     if (is.function(workers)) 
[13:23:45.424]                       workers <- workers()
[13:23:45.424]                     workers <- structure(as.integer(workers), 
[13:23:45.424]                       class = class(workers))
[13:23:45.424]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.424]                       1L)
[13:23:45.424]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.424]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.424]                       if (default_workers) 
[13:23:45.424]                         supportsMulticore(warn = TRUE)
[13:23:45.424]                       return(sequential(..., envir = envir))
[13:23:45.424]                     }
[13:23:45.424]                     oopts <- options(mc.cores = workers)
[13:23:45.424]                     on.exit(options(oopts))
[13:23:45.424]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.424]                       envir = envir)
[13:23:45.424]                     if (!future$lazy) 
[13:23:45.424]                       future <- run(future)
[13:23:45.424]                     invisible(future)
[13:23:45.424]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.424]                 }
[13:23:45.424]             }
[13:23:45.424]         }
[13:23:45.424]     })
[13:23:45.424]     if (TRUE) {
[13:23:45.424]         base::sink(type = "output", split = FALSE)
[13:23:45.424]         if (TRUE) {
[13:23:45.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.424]         }
[13:23:45.424]         else {
[13:23:45.424]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.424]         }
[13:23:45.424]         base::close(...future.stdout)
[13:23:45.424]         ...future.stdout <- NULL
[13:23:45.424]     }
[13:23:45.424]     ...future.result$conditions <- ...future.conditions
[13:23:45.424]     ...future.result$finished <- base::Sys.time()
[13:23:45.424]     ...future.result
[13:23:45.424] }
[13:23:45.426] plan(): Setting new future strategy stack:
[13:23:45.426] List of future strategies:
[13:23:45.426] 1. sequential:
[13:23:45.426]    - args: function (..., envir = parent.frame())
[13:23:45.426]    - tweaked: FALSE
[13:23:45.426]    - call: NULL
[13:23:45.426] plan(): nbrOfWorkers() = 1
[13:23:45.427] plan(): Setting new future strategy stack:
[13:23:45.427] List of future strategies:
[13:23:45.427] 1. multicore:
[13:23:45.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.427]    - tweaked: FALSE
[13:23:45.427]    - call: plan(multicore)
[13:23:45.431] plan(): nbrOfWorkers() = 1
[13:23:45.431] SequentialFuture started (and completed)
[13:23:45.431] signalConditions() ...
[13:23:45.431]  - include = ‘immediateCondition’
[13:23:45.431]  - exclude = 
[13:23:45.431]  - resignal = FALSE
[13:23:45.431]  - Number of conditions: 1
[13:23:45.431] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:45.432] signalConditions() ...
[13:23:45.432]  - include = ‘immediateCondition’
[13:23:45.432]  - exclude = 
[13:23:45.432]  - resignal = FALSE
[13:23:45.432]  - Number of conditions: 1
[13:23:45.433] signalConditions() ... done
<MyError: boom>
[13:23:45.433] signalConditions() ...
[13:23:45.433]  - include = ‘immediateCondition’
[13:23:45.433]  - exclude = 
[13:23:45.433]  - resignal = FALSE
[13:23:45.433]  - Number of conditions: 1
[13:23:45.433] signalConditions() ... done
[13:23:45.433] Future state: ‘finished’
[13:23:45.433] signalConditions() ...
[13:23:45.434]  - include = ‘condition’
[13:23:45.434]  - exclude = ‘immediateCondition’
[13:23:45.434]  - resignal = TRUE
[13:23:45.434]  - Number of conditions: 1
[13:23:45.434]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:23:45.434] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[13:23:45.437] getGlobalsAndPackages() ...
[13:23:45.438] Searching for globals...
[13:23:45.438] - globals found: [1] ‘{’
[13:23:45.438] Searching for globals ... DONE
[13:23:45.438] Resolving globals: FALSE
[13:23:45.439] 
[13:23:45.439] 
[13:23:45.439] getGlobalsAndPackages() ... DONE
[13:23:45.439] Packages needed by the future expression (n = 0): <none>
[13:23:45.439] Packages needed by future strategies (n = 0): <none>
[13:23:45.440] {
[13:23:45.440]     {
[13:23:45.440]         {
[13:23:45.440]             ...future.startTime <- base::Sys.time()
[13:23:45.440]             {
[13:23:45.440]                 {
[13:23:45.440]                   {
[13:23:45.440]                     base::local({
[13:23:45.440]                       has_future <- base::requireNamespace("future", 
[13:23:45.440]                         quietly = TRUE)
[13:23:45.440]                       if (has_future) {
[13:23:45.440]                         ns <- base::getNamespace("future")
[13:23:45.440]                         version <- ns[[".package"]][["version"]]
[13:23:45.440]                         if (is.null(version)) 
[13:23:45.440]                           version <- utils::packageVersion("future")
[13:23:45.440]                       }
[13:23:45.440]                       else {
[13:23:45.440]                         version <- NULL
[13:23:45.440]                       }
[13:23:45.440]                       if (!has_future || version < "1.8.0") {
[13:23:45.440]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.440]                           "", base::R.version$version.string), 
[13:23:45.440]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.440]                             "release", "version")], collapse = " "), 
[13:23:45.440]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.440]                           info)
[13:23:45.440]                         info <- base::paste(info, collapse = "; ")
[13:23:45.440]                         if (!has_future) {
[13:23:45.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.440]                             info)
[13:23:45.440]                         }
[13:23:45.440]                         else {
[13:23:45.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.440]                             info, version)
[13:23:45.440]                         }
[13:23:45.440]                         base::stop(msg)
[13:23:45.440]                       }
[13:23:45.440]                     })
[13:23:45.440]                   }
[13:23:45.440]                   options(future.plan = NULL)
[13:23:45.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.440]                 }
[13:23:45.440]                 ...future.workdir <- getwd()
[13:23:45.440]             }
[13:23:45.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.440]         }
[13:23:45.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.440]             base::names(...future.oldOptions))
[13:23:45.440]     }
[13:23:45.440]     if (FALSE) {
[13:23:45.440]     }
[13:23:45.440]     else {
[13:23:45.440]         if (TRUE) {
[13:23:45.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.440]                 open = "w")
[13:23:45.440]         }
[13:23:45.440]         else {
[13:23:45.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.440]         }
[13:23:45.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.440]             base::sink(type = "output", split = FALSE)
[13:23:45.440]             base::close(...future.stdout)
[13:23:45.440]         }, add = TRUE)
[13:23:45.440]     }
[13:23:45.440]     ...future.frame <- base::sys.nframe()
[13:23:45.440]     ...future.conditions <- base::list()
[13:23:45.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.440]     if (FALSE) {
[13:23:45.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.440]     }
[13:23:45.440]     ...future.result <- base::tryCatch({
[13:23:45.440]         base::withCallingHandlers({
[13:23:45.440]             ...future.value <- base::withVisible(base::local({
[13:23:45.440]                 42L
[13:23:45.440]             }))
[13:23:45.440]             future::FutureResult(value = ...future.value$value, 
[13:23:45.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.440]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.440]                     ...future.globalenv.names))
[13:23:45.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.440]         }, condition = base::local({
[13:23:45.440]             c <- base::c
[13:23:45.440]             inherits <- base::inherits
[13:23:45.440]             invokeRestart <- base::invokeRestart
[13:23:45.440]             length <- base::length
[13:23:45.440]             list <- base::list
[13:23:45.440]             seq.int <- base::seq.int
[13:23:45.440]             signalCondition <- base::signalCondition
[13:23:45.440]             sys.calls <- base::sys.calls
[13:23:45.440]             `[[` <- base::`[[`
[13:23:45.440]             `+` <- base::`+`
[13:23:45.440]             `<<-` <- base::`<<-`
[13:23:45.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.440]                   3L)]
[13:23:45.440]             }
[13:23:45.440]             function(cond) {
[13:23:45.440]                 is_error <- inherits(cond, "error")
[13:23:45.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.440]                   NULL)
[13:23:45.440]                 if (is_error) {
[13:23:45.440]                   sessionInformation <- function() {
[13:23:45.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.440]                       search = base::search(), system = base::Sys.info())
[13:23:45.440]                   }
[13:23:45.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.440]                     cond$call), session = sessionInformation(), 
[13:23:45.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.440]                   signalCondition(cond)
[13:23:45.440]                 }
[13:23:45.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.440]                 "immediateCondition"))) {
[13:23:45.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.440]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.440]                   if (TRUE && !signal) {
[13:23:45.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.440]                     {
[13:23:45.440]                       inherits <- base::inherits
[13:23:45.440]                       invokeRestart <- base::invokeRestart
[13:23:45.440]                       is.null <- base::is.null
[13:23:45.440]                       muffled <- FALSE
[13:23:45.440]                       if (inherits(cond, "message")) {
[13:23:45.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.440]                         if (muffled) 
[13:23:45.440]                           invokeRestart("muffleMessage")
[13:23:45.440]                       }
[13:23:45.440]                       else if (inherits(cond, "warning")) {
[13:23:45.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.440]                         if (muffled) 
[13:23:45.440]                           invokeRestart("muffleWarning")
[13:23:45.440]                       }
[13:23:45.440]                       else if (inherits(cond, "condition")) {
[13:23:45.440]                         if (!is.null(pattern)) {
[13:23:45.440]                           computeRestarts <- base::computeRestarts
[13:23:45.440]                           grepl <- base::grepl
[13:23:45.440]                           restarts <- computeRestarts(cond)
[13:23:45.440]                           for (restart in restarts) {
[13:23:45.440]                             name <- restart$name
[13:23:45.440]                             if (is.null(name)) 
[13:23:45.440]                               next
[13:23:45.440]                             if (!grepl(pattern, name)) 
[13:23:45.440]                               next
[13:23:45.440]                             invokeRestart(restart)
[13:23:45.440]                             muffled <- TRUE
[13:23:45.440]                             break
[13:23:45.440]                           }
[13:23:45.440]                         }
[13:23:45.440]                       }
[13:23:45.440]                       invisible(muffled)
[13:23:45.440]                     }
[13:23:45.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.440]                   }
[13:23:45.440]                 }
[13:23:45.440]                 else {
[13:23:45.440]                   if (TRUE) {
[13:23:45.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.440]                     {
[13:23:45.440]                       inherits <- base::inherits
[13:23:45.440]                       invokeRestart <- base::invokeRestart
[13:23:45.440]                       is.null <- base::is.null
[13:23:45.440]                       muffled <- FALSE
[13:23:45.440]                       if (inherits(cond, "message")) {
[13:23:45.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.440]                         if (muffled) 
[13:23:45.440]                           invokeRestart("muffleMessage")
[13:23:45.440]                       }
[13:23:45.440]                       else if (inherits(cond, "warning")) {
[13:23:45.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.440]                         if (muffled) 
[13:23:45.440]                           invokeRestart("muffleWarning")
[13:23:45.440]                       }
[13:23:45.440]                       else if (inherits(cond, "condition")) {
[13:23:45.440]                         if (!is.null(pattern)) {
[13:23:45.440]                           computeRestarts <- base::computeRestarts
[13:23:45.440]                           grepl <- base::grepl
[13:23:45.440]                           restarts <- computeRestarts(cond)
[13:23:45.440]                           for (restart in restarts) {
[13:23:45.440]                             name <- restart$name
[13:23:45.440]                             if (is.null(name)) 
[13:23:45.440]                               next
[13:23:45.440]                             if (!grepl(pattern, name)) 
[13:23:45.440]                               next
[13:23:45.440]                             invokeRestart(restart)
[13:23:45.440]                             muffled <- TRUE
[13:23:45.440]                             break
[13:23:45.440]                           }
[13:23:45.440]                         }
[13:23:45.440]                       }
[13:23:45.440]                       invisible(muffled)
[13:23:45.440]                     }
[13:23:45.440]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.440]                   }
[13:23:45.440]                 }
[13:23:45.440]             }
[13:23:45.440]         }))
[13:23:45.440]     }, error = function(ex) {
[13:23:45.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.440]                 ...future.rng), started = ...future.startTime, 
[13:23:45.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.440]             version = "1.8"), class = "FutureResult")
[13:23:45.440]     }, finally = {
[13:23:45.440]         if (!identical(...future.workdir, getwd())) 
[13:23:45.440]             setwd(...future.workdir)
[13:23:45.440]         {
[13:23:45.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.440]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.440]             }
[13:23:45.440]             base::options(...future.oldOptions)
[13:23:45.440]             if (.Platform$OS.type == "windows") {
[13:23:45.440]                 old_names <- names(...future.oldEnvVars)
[13:23:45.440]                 envs <- base::Sys.getenv()
[13:23:45.440]                 names <- names(envs)
[13:23:45.440]                 common <- intersect(names, old_names)
[13:23:45.440]                 added <- setdiff(names, old_names)
[13:23:45.440]                 removed <- setdiff(old_names, names)
[13:23:45.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.440]                   envs[common]]
[13:23:45.440]                 NAMES <- toupper(changed)
[13:23:45.440]                 args <- list()
[13:23:45.440]                 for (kk in seq_along(NAMES)) {
[13:23:45.440]                   name <- changed[[kk]]
[13:23:45.440]                   NAME <- NAMES[[kk]]
[13:23:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.440]                     next
[13:23:45.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.440]                 }
[13:23:45.440]                 NAMES <- toupper(added)
[13:23:45.440]                 for (kk in seq_along(NAMES)) {
[13:23:45.440]                   name <- added[[kk]]
[13:23:45.440]                   NAME <- NAMES[[kk]]
[13:23:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.440]                     next
[13:23:45.440]                   args[[name]] <- ""
[13:23:45.440]                 }
[13:23:45.440]                 NAMES <- toupper(removed)
[13:23:45.440]                 for (kk in seq_along(NAMES)) {
[13:23:45.440]                   name <- removed[[kk]]
[13:23:45.440]                   NAME <- NAMES[[kk]]
[13:23:45.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.440]                     next
[13:23:45.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.440]                 }
[13:23:45.440]                 if (length(args) > 0) 
[13:23:45.440]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.440]             }
[13:23:45.440]             else {
[13:23:45.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.440]             }
[13:23:45.440]             {
[13:23:45.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.440]                   0L) {
[13:23:45.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.440]                   base::options(opts)
[13:23:45.440]                 }
[13:23:45.440]                 {
[13:23:45.440]                   {
[13:23:45.440]                     NULL
[13:23:45.440]                     RNGkind("Mersenne-Twister")
[13:23:45.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.440]                       inherits = FALSE)
[13:23:45.440]                   }
[13:23:45.440]                   options(future.plan = NULL)
[13:23:45.440]                   if (is.na(NA_character_)) 
[13:23:45.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.440]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.440]                     envir = parent.frame()) 
[13:23:45.440]                   {
[13:23:45.440]                     default_workers <- missing(workers)
[13:23:45.440]                     if (is.function(workers)) 
[13:23:45.440]                       workers <- workers()
[13:23:45.440]                     workers <- structure(as.integer(workers), 
[13:23:45.440]                       class = class(workers))
[13:23:45.440]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.440]                       1L)
[13:23:45.440]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.440]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.440]                       if (default_workers) 
[13:23:45.440]                         supportsMulticore(warn = TRUE)
[13:23:45.440]                       return(sequential(..., envir = envir))
[13:23:45.440]                     }
[13:23:45.440]                     oopts <- options(mc.cores = workers)
[13:23:45.440]                     on.exit(options(oopts))
[13:23:45.440]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.440]                       envir = envir)
[13:23:45.440]                     if (!future$lazy) 
[13:23:45.440]                       future <- run(future)
[13:23:45.440]                     invisible(future)
[13:23:45.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.440]                 }
[13:23:45.440]             }
[13:23:45.440]         }
[13:23:45.440]     })
[13:23:45.440]     if (TRUE) {
[13:23:45.440]         base::sink(type = "output", split = FALSE)
[13:23:45.440]         if (TRUE) {
[13:23:45.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.440]         }
[13:23:45.440]         else {
[13:23:45.440]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.440]         }
[13:23:45.440]         base::close(...future.stdout)
[13:23:45.440]         ...future.stdout <- NULL
[13:23:45.440]     }
[13:23:45.440]     ...future.result$conditions <- ...future.conditions
[13:23:45.440]     ...future.result$finished <- base::Sys.time()
[13:23:45.440]     ...future.result
[13:23:45.440] }
[13:23:45.442] plan(): Setting new future strategy stack:
[13:23:45.442] List of future strategies:
[13:23:45.442] 1. sequential:
[13:23:45.442]    - args: function (..., envir = parent.frame())
[13:23:45.442]    - tweaked: FALSE
[13:23:45.442]    - call: NULL
[13:23:45.442] plan(): nbrOfWorkers() = 1
[13:23:45.443] plan(): Setting new future strategy stack:
[13:23:45.443] List of future strategies:
[13:23:45.443] 1. multicore:
[13:23:45.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.443]    - tweaked: FALSE
[13:23:45.443]    - call: plan(multicore)
[13:23:45.446] plan(): nbrOfWorkers() = 1
[13:23:45.447] SequentialFuture started (and completed)
[13:23:45.447] resolved() for ‘SequentialFuture’ ...
[13:23:45.447] - state: ‘finished’
[13:23:45.447] - run: TRUE
[13:23:45.447] - result: ‘FutureResult’
[13:23:45.447] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[13:23:45.451] getGlobalsAndPackages() ...
[13:23:45.451] Searching for globals...
[13:23:45.453] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[13:23:45.453] Searching for globals ... DONE
[13:23:45.453] Resolving globals: FALSE
[13:23:45.454] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.454] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:45.454] - globals: [1] ‘a’
[13:23:45.454] 
[13:23:45.454] getGlobalsAndPackages() ... DONE
[13:23:45.455] Packages needed by the future expression (n = 0): <none>
[13:23:45.455] Packages needed by future strategies (n = 0): <none>
[13:23:45.455] {
[13:23:45.455]     {
[13:23:45.455]         {
[13:23:45.455]             ...future.startTime <- base::Sys.time()
[13:23:45.455]             {
[13:23:45.455]                 {
[13:23:45.455]                   {
[13:23:45.455]                     base::local({
[13:23:45.455]                       has_future <- base::requireNamespace("future", 
[13:23:45.455]                         quietly = TRUE)
[13:23:45.455]                       if (has_future) {
[13:23:45.455]                         ns <- base::getNamespace("future")
[13:23:45.455]                         version <- ns[[".package"]][["version"]]
[13:23:45.455]                         if (is.null(version)) 
[13:23:45.455]                           version <- utils::packageVersion("future")
[13:23:45.455]                       }
[13:23:45.455]                       else {
[13:23:45.455]                         version <- NULL
[13:23:45.455]                       }
[13:23:45.455]                       if (!has_future || version < "1.8.0") {
[13:23:45.455]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.455]                           "", base::R.version$version.string), 
[13:23:45.455]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.455]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.455]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.455]                             "release", "version")], collapse = " "), 
[13:23:45.455]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.455]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.455]                           info)
[13:23:45.455]                         info <- base::paste(info, collapse = "; ")
[13:23:45.455]                         if (!has_future) {
[13:23:45.455]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.455]                             info)
[13:23:45.455]                         }
[13:23:45.455]                         else {
[13:23:45.455]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.455]                             info, version)
[13:23:45.455]                         }
[13:23:45.455]                         base::stop(msg)
[13:23:45.455]                       }
[13:23:45.455]                     })
[13:23:45.455]                   }
[13:23:45.455]                   options(future.plan = NULL)
[13:23:45.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.455]                 }
[13:23:45.455]                 ...future.workdir <- getwd()
[13:23:45.455]             }
[13:23:45.455]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.455]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.455]         }
[13:23:45.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.455]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.455]             base::names(...future.oldOptions))
[13:23:45.455]     }
[13:23:45.455]     if (FALSE) {
[13:23:45.455]     }
[13:23:45.455]     else {
[13:23:45.455]         if (TRUE) {
[13:23:45.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.455]                 open = "w")
[13:23:45.455]         }
[13:23:45.455]         else {
[13:23:45.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.455]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.455]         }
[13:23:45.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.455]             base::sink(type = "output", split = FALSE)
[13:23:45.455]             base::close(...future.stdout)
[13:23:45.455]         }, add = TRUE)
[13:23:45.455]     }
[13:23:45.455]     ...future.frame <- base::sys.nframe()
[13:23:45.455]     ...future.conditions <- base::list()
[13:23:45.455]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.455]     if (FALSE) {
[13:23:45.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.455]     }
[13:23:45.455]     ...future.result <- base::tryCatch({
[13:23:45.455]         base::withCallingHandlers({
[13:23:45.455]             ...future.value <- base::withVisible(base::local({
[13:23:45.455]                 b <- 3
[13:23:45.455]                 c <- 2
[13:23:45.455]                 a * b * c
[13:23:45.455]             }))
[13:23:45.455]             future::FutureResult(value = ...future.value$value, 
[13:23:45.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.455]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.455]                     ...future.globalenv.names))
[13:23:45.455]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.455]         }, condition = base::local({
[13:23:45.455]             c <- base::c
[13:23:45.455]             inherits <- base::inherits
[13:23:45.455]             invokeRestart <- base::invokeRestart
[13:23:45.455]             length <- base::length
[13:23:45.455]             list <- base::list
[13:23:45.455]             seq.int <- base::seq.int
[13:23:45.455]             signalCondition <- base::signalCondition
[13:23:45.455]             sys.calls <- base::sys.calls
[13:23:45.455]             `[[` <- base::`[[`
[13:23:45.455]             `+` <- base::`+`
[13:23:45.455]             `<<-` <- base::`<<-`
[13:23:45.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.455]                   3L)]
[13:23:45.455]             }
[13:23:45.455]             function(cond) {
[13:23:45.455]                 is_error <- inherits(cond, "error")
[13:23:45.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.455]                   NULL)
[13:23:45.455]                 if (is_error) {
[13:23:45.455]                   sessionInformation <- function() {
[13:23:45.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.455]                       search = base::search(), system = base::Sys.info())
[13:23:45.455]                   }
[13:23:45.455]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.455]                     cond$call), session = sessionInformation(), 
[13:23:45.455]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.455]                   signalCondition(cond)
[13:23:45.455]                 }
[13:23:45.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.455]                 "immediateCondition"))) {
[13:23:45.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.455]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.455]                   if (TRUE && !signal) {
[13:23:45.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.455]                     {
[13:23:45.455]                       inherits <- base::inherits
[13:23:45.455]                       invokeRestart <- base::invokeRestart
[13:23:45.455]                       is.null <- base::is.null
[13:23:45.455]                       muffled <- FALSE
[13:23:45.455]                       if (inherits(cond, "message")) {
[13:23:45.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.455]                         if (muffled) 
[13:23:45.455]                           invokeRestart("muffleMessage")
[13:23:45.455]                       }
[13:23:45.455]                       else if (inherits(cond, "warning")) {
[13:23:45.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.455]                         if (muffled) 
[13:23:45.455]                           invokeRestart("muffleWarning")
[13:23:45.455]                       }
[13:23:45.455]                       else if (inherits(cond, "condition")) {
[13:23:45.455]                         if (!is.null(pattern)) {
[13:23:45.455]                           computeRestarts <- base::computeRestarts
[13:23:45.455]                           grepl <- base::grepl
[13:23:45.455]                           restarts <- computeRestarts(cond)
[13:23:45.455]                           for (restart in restarts) {
[13:23:45.455]                             name <- restart$name
[13:23:45.455]                             if (is.null(name)) 
[13:23:45.455]                               next
[13:23:45.455]                             if (!grepl(pattern, name)) 
[13:23:45.455]                               next
[13:23:45.455]                             invokeRestart(restart)
[13:23:45.455]                             muffled <- TRUE
[13:23:45.455]                             break
[13:23:45.455]                           }
[13:23:45.455]                         }
[13:23:45.455]                       }
[13:23:45.455]                       invisible(muffled)
[13:23:45.455]                     }
[13:23:45.455]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.455]                   }
[13:23:45.455]                 }
[13:23:45.455]                 else {
[13:23:45.455]                   if (TRUE) {
[13:23:45.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.455]                     {
[13:23:45.455]                       inherits <- base::inherits
[13:23:45.455]                       invokeRestart <- base::invokeRestart
[13:23:45.455]                       is.null <- base::is.null
[13:23:45.455]                       muffled <- FALSE
[13:23:45.455]                       if (inherits(cond, "message")) {
[13:23:45.455]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.455]                         if (muffled) 
[13:23:45.455]                           invokeRestart("muffleMessage")
[13:23:45.455]                       }
[13:23:45.455]                       else if (inherits(cond, "warning")) {
[13:23:45.455]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.455]                         if (muffled) 
[13:23:45.455]                           invokeRestart("muffleWarning")
[13:23:45.455]                       }
[13:23:45.455]                       else if (inherits(cond, "condition")) {
[13:23:45.455]                         if (!is.null(pattern)) {
[13:23:45.455]                           computeRestarts <- base::computeRestarts
[13:23:45.455]                           grepl <- base::grepl
[13:23:45.455]                           restarts <- computeRestarts(cond)
[13:23:45.455]                           for (restart in restarts) {
[13:23:45.455]                             name <- restart$name
[13:23:45.455]                             if (is.null(name)) 
[13:23:45.455]                               next
[13:23:45.455]                             if (!grepl(pattern, name)) 
[13:23:45.455]                               next
[13:23:45.455]                             invokeRestart(restart)
[13:23:45.455]                             muffled <- TRUE
[13:23:45.455]                             break
[13:23:45.455]                           }
[13:23:45.455]                         }
[13:23:45.455]                       }
[13:23:45.455]                       invisible(muffled)
[13:23:45.455]                     }
[13:23:45.455]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.455]                   }
[13:23:45.455]                 }
[13:23:45.455]             }
[13:23:45.455]         }))
[13:23:45.455]     }, error = function(ex) {
[13:23:45.455]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.455]                 ...future.rng), started = ...future.startTime, 
[13:23:45.455]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.455]             version = "1.8"), class = "FutureResult")
[13:23:45.455]     }, finally = {
[13:23:45.455]         if (!identical(...future.workdir, getwd())) 
[13:23:45.455]             setwd(...future.workdir)
[13:23:45.455]         {
[13:23:45.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.455]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.455]             }
[13:23:45.455]             base::options(...future.oldOptions)
[13:23:45.455]             if (.Platform$OS.type == "windows") {
[13:23:45.455]                 old_names <- names(...future.oldEnvVars)
[13:23:45.455]                 envs <- base::Sys.getenv()
[13:23:45.455]                 names <- names(envs)
[13:23:45.455]                 common <- intersect(names, old_names)
[13:23:45.455]                 added <- setdiff(names, old_names)
[13:23:45.455]                 removed <- setdiff(old_names, names)
[13:23:45.455]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.455]                   envs[common]]
[13:23:45.455]                 NAMES <- toupper(changed)
[13:23:45.455]                 args <- list()
[13:23:45.455]                 for (kk in seq_along(NAMES)) {
[13:23:45.455]                   name <- changed[[kk]]
[13:23:45.455]                   NAME <- NAMES[[kk]]
[13:23:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.455]                     next
[13:23:45.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.455]                 }
[13:23:45.455]                 NAMES <- toupper(added)
[13:23:45.455]                 for (kk in seq_along(NAMES)) {
[13:23:45.455]                   name <- added[[kk]]
[13:23:45.455]                   NAME <- NAMES[[kk]]
[13:23:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.455]                     next
[13:23:45.455]                   args[[name]] <- ""
[13:23:45.455]                 }
[13:23:45.455]                 NAMES <- toupper(removed)
[13:23:45.455]                 for (kk in seq_along(NAMES)) {
[13:23:45.455]                   name <- removed[[kk]]
[13:23:45.455]                   NAME <- NAMES[[kk]]
[13:23:45.455]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.455]                     next
[13:23:45.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.455]                 }
[13:23:45.455]                 if (length(args) > 0) 
[13:23:45.455]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.455]             }
[13:23:45.455]             else {
[13:23:45.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.455]             }
[13:23:45.455]             {
[13:23:45.455]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.455]                   0L) {
[13:23:45.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.455]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.455]                   base::options(opts)
[13:23:45.455]                 }
[13:23:45.455]                 {
[13:23:45.455]                   {
[13:23:45.455]                     NULL
[13:23:45.455]                     RNGkind("Mersenne-Twister")
[13:23:45.455]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.455]                       inherits = FALSE)
[13:23:45.455]                   }
[13:23:45.455]                   options(future.plan = NULL)
[13:23:45.455]                   if (is.na(NA_character_)) 
[13:23:45.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.455]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.455]                     envir = parent.frame()) 
[13:23:45.455]                   {
[13:23:45.455]                     default_workers <- missing(workers)
[13:23:45.455]                     if (is.function(workers)) 
[13:23:45.455]                       workers <- workers()
[13:23:45.455]                     workers <- structure(as.integer(workers), 
[13:23:45.455]                       class = class(workers))
[13:23:45.455]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.455]                       1L)
[13:23:45.455]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.455]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.455]                       if (default_workers) 
[13:23:45.455]                         supportsMulticore(warn = TRUE)
[13:23:45.455]                       return(sequential(..., envir = envir))
[13:23:45.455]                     }
[13:23:45.455]                     oopts <- options(mc.cores = workers)
[13:23:45.455]                     on.exit(options(oopts))
[13:23:45.455]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.455]                       envir = envir)
[13:23:45.455]                     if (!future$lazy) 
[13:23:45.455]                       future <- run(future)
[13:23:45.455]                     invisible(future)
[13:23:45.455]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.455]                 }
[13:23:45.455]             }
[13:23:45.455]         }
[13:23:45.455]     })
[13:23:45.455]     if (TRUE) {
[13:23:45.455]         base::sink(type = "output", split = FALSE)
[13:23:45.455]         if (TRUE) {
[13:23:45.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.455]         }
[13:23:45.455]         else {
[13:23:45.455]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.455]         }
[13:23:45.455]         base::close(...future.stdout)
[13:23:45.455]         ...future.stdout <- NULL
[13:23:45.455]     }
[13:23:45.455]     ...future.result$conditions <- ...future.conditions
[13:23:45.455]     ...future.result$finished <- base::Sys.time()
[13:23:45.455]     ...future.result
[13:23:45.455] }
[13:23:45.457] assign_globals() ...
[13:23:45.457] List of 1
[13:23:45.457]  $ a: num 0
[13:23:45.457]  - attr(*, "where")=List of 1
[13:23:45.457]   ..$ a:<environment: R_EmptyEnv> 
[13:23:45.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.457]  - attr(*, "resolved")= logi FALSE
[13:23:45.457]  - attr(*, "total_size")= num 56
[13:23:45.464] - copied ‘a’ to environment
[13:23:45.464] assign_globals() ... done
[13:23:45.464] plan(): Setting new future strategy stack:
[13:23:45.464] List of future strategies:
[13:23:45.464] 1. sequential:
[13:23:45.464]    - args: function (..., envir = parent.frame())
[13:23:45.464]    - tweaked: FALSE
[13:23:45.464]    - call: NULL
[13:23:45.465] plan(): nbrOfWorkers() = 1
[13:23:45.465] plan(): Setting new future strategy stack:
[13:23:45.466] List of future strategies:
[13:23:45.466] 1. multicore:
[13:23:45.466]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.466]    - tweaked: FALSE
[13:23:45.466]    - call: plan(multicore)
[13:23:45.469] plan(): nbrOfWorkers() = 1
[13:23:45.469] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[13:23:45.474] getGlobalsAndPackages() ...
[13:23:45.474] Searching for globals...
[13:23:45.475] - globals found: [2] ‘{’, ‘ii’
[13:23:45.475] Searching for globals ... DONE
[13:23:45.475] Resolving globals: FALSE
[13:23:45.475] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.476] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.476] - globals: [1] ‘ii’
[13:23:45.476] 
[13:23:45.476] getGlobalsAndPackages() ... DONE
[13:23:45.476] Packages needed by the future expression (n = 0): <none>
[13:23:45.476] Packages needed by future strategies (n = 0): <none>
[13:23:45.477] {
[13:23:45.477]     {
[13:23:45.477]         {
[13:23:45.477]             ...future.startTime <- base::Sys.time()
[13:23:45.477]             {
[13:23:45.477]                 {
[13:23:45.477]                   {
[13:23:45.477]                     base::local({
[13:23:45.477]                       has_future <- base::requireNamespace("future", 
[13:23:45.477]                         quietly = TRUE)
[13:23:45.477]                       if (has_future) {
[13:23:45.477]                         ns <- base::getNamespace("future")
[13:23:45.477]                         version <- ns[[".package"]][["version"]]
[13:23:45.477]                         if (is.null(version)) 
[13:23:45.477]                           version <- utils::packageVersion("future")
[13:23:45.477]                       }
[13:23:45.477]                       else {
[13:23:45.477]                         version <- NULL
[13:23:45.477]                       }
[13:23:45.477]                       if (!has_future || version < "1.8.0") {
[13:23:45.477]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.477]                           "", base::R.version$version.string), 
[13:23:45.477]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.477]                             "release", "version")], collapse = " "), 
[13:23:45.477]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.477]                           info)
[13:23:45.477]                         info <- base::paste(info, collapse = "; ")
[13:23:45.477]                         if (!has_future) {
[13:23:45.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.477]                             info)
[13:23:45.477]                         }
[13:23:45.477]                         else {
[13:23:45.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.477]                             info, version)
[13:23:45.477]                         }
[13:23:45.477]                         base::stop(msg)
[13:23:45.477]                       }
[13:23:45.477]                     })
[13:23:45.477]                   }
[13:23:45.477]                   options(future.plan = NULL)
[13:23:45.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.477]                 }
[13:23:45.477]                 ...future.workdir <- getwd()
[13:23:45.477]             }
[13:23:45.477]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.477]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.477]         }
[13:23:45.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.477]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.477]             base::names(...future.oldOptions))
[13:23:45.477]     }
[13:23:45.477]     if (FALSE) {
[13:23:45.477]     }
[13:23:45.477]     else {
[13:23:45.477]         if (TRUE) {
[13:23:45.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.477]                 open = "w")
[13:23:45.477]         }
[13:23:45.477]         else {
[13:23:45.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.477]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.477]         }
[13:23:45.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.477]             base::sink(type = "output", split = FALSE)
[13:23:45.477]             base::close(...future.stdout)
[13:23:45.477]         }, add = TRUE)
[13:23:45.477]     }
[13:23:45.477]     ...future.frame <- base::sys.nframe()
[13:23:45.477]     ...future.conditions <- base::list()
[13:23:45.477]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.477]     if (FALSE) {
[13:23:45.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.477]     }
[13:23:45.477]     ...future.result <- base::tryCatch({
[13:23:45.477]         base::withCallingHandlers({
[13:23:45.477]             ...future.value <- base::withVisible(base::local({
[13:23:45.477]                 ii
[13:23:45.477]             }))
[13:23:45.477]             future::FutureResult(value = ...future.value$value, 
[13:23:45.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.477]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.477]                     ...future.globalenv.names))
[13:23:45.477]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.477]         }, condition = base::local({
[13:23:45.477]             c <- base::c
[13:23:45.477]             inherits <- base::inherits
[13:23:45.477]             invokeRestart <- base::invokeRestart
[13:23:45.477]             length <- base::length
[13:23:45.477]             list <- base::list
[13:23:45.477]             seq.int <- base::seq.int
[13:23:45.477]             signalCondition <- base::signalCondition
[13:23:45.477]             sys.calls <- base::sys.calls
[13:23:45.477]             `[[` <- base::`[[`
[13:23:45.477]             `+` <- base::`+`
[13:23:45.477]             `<<-` <- base::`<<-`
[13:23:45.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.477]                   3L)]
[13:23:45.477]             }
[13:23:45.477]             function(cond) {
[13:23:45.477]                 is_error <- inherits(cond, "error")
[13:23:45.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.477]                   NULL)
[13:23:45.477]                 if (is_error) {
[13:23:45.477]                   sessionInformation <- function() {
[13:23:45.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.477]                       search = base::search(), system = base::Sys.info())
[13:23:45.477]                   }
[13:23:45.477]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.477]                     cond$call), session = sessionInformation(), 
[13:23:45.477]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.477]                   signalCondition(cond)
[13:23:45.477]                 }
[13:23:45.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.477]                 "immediateCondition"))) {
[13:23:45.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.477]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.477]                   if (TRUE && !signal) {
[13:23:45.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.477]                     {
[13:23:45.477]                       inherits <- base::inherits
[13:23:45.477]                       invokeRestart <- base::invokeRestart
[13:23:45.477]                       is.null <- base::is.null
[13:23:45.477]                       muffled <- FALSE
[13:23:45.477]                       if (inherits(cond, "message")) {
[13:23:45.477]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.477]                         if (muffled) 
[13:23:45.477]                           invokeRestart("muffleMessage")
[13:23:45.477]                       }
[13:23:45.477]                       else if (inherits(cond, "warning")) {
[13:23:45.477]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.477]                         if (muffled) 
[13:23:45.477]                           invokeRestart("muffleWarning")
[13:23:45.477]                       }
[13:23:45.477]                       else if (inherits(cond, "condition")) {
[13:23:45.477]                         if (!is.null(pattern)) {
[13:23:45.477]                           computeRestarts <- base::computeRestarts
[13:23:45.477]                           grepl <- base::grepl
[13:23:45.477]                           restarts <- computeRestarts(cond)
[13:23:45.477]                           for (restart in restarts) {
[13:23:45.477]                             name <- restart$name
[13:23:45.477]                             if (is.null(name)) 
[13:23:45.477]                               next
[13:23:45.477]                             if (!grepl(pattern, name)) 
[13:23:45.477]                               next
[13:23:45.477]                             invokeRestart(restart)
[13:23:45.477]                             muffled <- TRUE
[13:23:45.477]                             break
[13:23:45.477]                           }
[13:23:45.477]                         }
[13:23:45.477]                       }
[13:23:45.477]                       invisible(muffled)
[13:23:45.477]                     }
[13:23:45.477]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.477]                   }
[13:23:45.477]                 }
[13:23:45.477]                 else {
[13:23:45.477]                   if (TRUE) {
[13:23:45.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.477]                     {
[13:23:45.477]                       inherits <- base::inherits
[13:23:45.477]                       invokeRestart <- base::invokeRestart
[13:23:45.477]                       is.null <- base::is.null
[13:23:45.477]                       muffled <- FALSE
[13:23:45.477]                       if (inherits(cond, "message")) {
[13:23:45.477]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.477]                         if (muffled) 
[13:23:45.477]                           invokeRestart("muffleMessage")
[13:23:45.477]                       }
[13:23:45.477]                       else if (inherits(cond, "warning")) {
[13:23:45.477]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.477]                         if (muffled) 
[13:23:45.477]                           invokeRestart("muffleWarning")
[13:23:45.477]                       }
[13:23:45.477]                       else if (inherits(cond, "condition")) {
[13:23:45.477]                         if (!is.null(pattern)) {
[13:23:45.477]                           computeRestarts <- base::computeRestarts
[13:23:45.477]                           grepl <- base::grepl
[13:23:45.477]                           restarts <- computeRestarts(cond)
[13:23:45.477]                           for (restart in restarts) {
[13:23:45.477]                             name <- restart$name
[13:23:45.477]                             if (is.null(name)) 
[13:23:45.477]                               next
[13:23:45.477]                             if (!grepl(pattern, name)) 
[13:23:45.477]                               next
[13:23:45.477]                             invokeRestart(restart)
[13:23:45.477]                             muffled <- TRUE
[13:23:45.477]                             break
[13:23:45.477]                           }
[13:23:45.477]                         }
[13:23:45.477]                       }
[13:23:45.477]                       invisible(muffled)
[13:23:45.477]                     }
[13:23:45.477]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.477]                   }
[13:23:45.477]                 }
[13:23:45.477]             }
[13:23:45.477]         }))
[13:23:45.477]     }, error = function(ex) {
[13:23:45.477]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.477]                 ...future.rng), started = ...future.startTime, 
[13:23:45.477]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.477]             version = "1.8"), class = "FutureResult")
[13:23:45.477]     }, finally = {
[13:23:45.477]         if (!identical(...future.workdir, getwd())) 
[13:23:45.477]             setwd(...future.workdir)
[13:23:45.477]         {
[13:23:45.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.477]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.477]             }
[13:23:45.477]             base::options(...future.oldOptions)
[13:23:45.477]             if (.Platform$OS.type == "windows") {
[13:23:45.477]                 old_names <- names(...future.oldEnvVars)
[13:23:45.477]                 envs <- base::Sys.getenv()
[13:23:45.477]                 names <- names(envs)
[13:23:45.477]                 common <- intersect(names, old_names)
[13:23:45.477]                 added <- setdiff(names, old_names)
[13:23:45.477]                 removed <- setdiff(old_names, names)
[13:23:45.477]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.477]                   envs[common]]
[13:23:45.477]                 NAMES <- toupper(changed)
[13:23:45.477]                 args <- list()
[13:23:45.477]                 for (kk in seq_along(NAMES)) {
[13:23:45.477]                   name <- changed[[kk]]
[13:23:45.477]                   NAME <- NAMES[[kk]]
[13:23:45.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.477]                     next
[13:23:45.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.477]                 }
[13:23:45.477]                 NAMES <- toupper(added)
[13:23:45.477]                 for (kk in seq_along(NAMES)) {
[13:23:45.477]                   name <- added[[kk]]
[13:23:45.477]                   NAME <- NAMES[[kk]]
[13:23:45.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.477]                     next
[13:23:45.477]                   args[[name]] <- ""
[13:23:45.477]                 }
[13:23:45.477]                 NAMES <- toupper(removed)
[13:23:45.477]                 for (kk in seq_along(NAMES)) {
[13:23:45.477]                   name <- removed[[kk]]
[13:23:45.477]                   NAME <- NAMES[[kk]]
[13:23:45.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.477]                     next
[13:23:45.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.477]                 }
[13:23:45.477]                 if (length(args) > 0) 
[13:23:45.477]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.477]             }
[13:23:45.477]             else {
[13:23:45.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.477]             }
[13:23:45.477]             {
[13:23:45.477]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.477]                   0L) {
[13:23:45.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.477]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.477]                   base::options(opts)
[13:23:45.477]                 }
[13:23:45.477]                 {
[13:23:45.477]                   {
[13:23:45.477]                     NULL
[13:23:45.477]                     RNGkind("Mersenne-Twister")
[13:23:45.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.477]                       inherits = FALSE)
[13:23:45.477]                   }
[13:23:45.477]                   options(future.plan = NULL)
[13:23:45.477]                   if (is.na(NA_character_)) 
[13:23:45.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.477]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.477]                     envir = parent.frame()) 
[13:23:45.477]                   {
[13:23:45.477]                     default_workers <- missing(workers)
[13:23:45.477]                     if (is.function(workers)) 
[13:23:45.477]                       workers <- workers()
[13:23:45.477]                     workers <- structure(as.integer(workers), 
[13:23:45.477]                       class = class(workers))
[13:23:45.477]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.477]                       1L)
[13:23:45.477]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.477]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.477]                       if (default_workers) 
[13:23:45.477]                         supportsMulticore(warn = TRUE)
[13:23:45.477]                       return(sequential(..., envir = envir))
[13:23:45.477]                     }
[13:23:45.477]                     oopts <- options(mc.cores = workers)
[13:23:45.477]                     on.exit(options(oopts))
[13:23:45.477]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.477]                       envir = envir)
[13:23:45.477]                     if (!future$lazy) 
[13:23:45.477]                       future <- run(future)
[13:23:45.477]                     invisible(future)
[13:23:45.477]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.477]                 }
[13:23:45.477]             }
[13:23:45.477]         }
[13:23:45.477]     })
[13:23:45.477]     if (TRUE) {
[13:23:45.477]         base::sink(type = "output", split = FALSE)
[13:23:45.477]         if (TRUE) {
[13:23:45.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.477]         }
[13:23:45.477]         else {
[13:23:45.477]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.477]         }
[13:23:45.477]         base::close(...future.stdout)
[13:23:45.477]         ...future.stdout <- NULL
[13:23:45.477]     }
[13:23:45.477]     ...future.result$conditions <- ...future.conditions
[13:23:45.477]     ...future.result$finished <- base::Sys.time()
[13:23:45.477]     ...future.result
[13:23:45.477] }
[13:23:45.479] assign_globals() ...
[13:23:45.479] List of 1
[13:23:45.479]  $ ii: int 1
[13:23:45.479]  - attr(*, "where")=List of 1
[13:23:45.479]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.479]  - attr(*, "resolved")= logi FALSE
[13:23:45.479]  - attr(*, "total_size")= num 56
[13:23:45.481] - copied ‘ii’ to environment
[13:23:45.481] assign_globals() ... done
[13:23:45.481] plan(): Setting new future strategy stack:
[13:23:45.481] List of future strategies:
[13:23:45.481] 1. sequential:
[13:23:45.481]    - args: function (..., envir = parent.frame())
[13:23:45.481]    - tweaked: FALSE
[13:23:45.481]    - call: NULL
[13:23:45.482] plan(): nbrOfWorkers() = 1
[13:23:45.483] plan(): Setting new future strategy stack:
[13:23:45.483] List of future strategies:
[13:23:45.483] 1. multicore:
[13:23:45.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.483]    - tweaked: FALSE
[13:23:45.483]    - call: plan(multicore)
[13:23:45.486] plan(): nbrOfWorkers() = 1
[13:23:45.486] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[13:23:45.490] getGlobalsAndPackages() ...
[13:23:45.490] Searching for globals...
[13:23:45.491] - globals found: [2] ‘{’, ‘ii’
[13:23:45.491] Searching for globals ... DONE
[13:23:45.491] Resolving globals: FALSE
[13:23:45.491] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.492] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.492] - globals: [1] ‘ii’
[13:23:45.492] 
[13:23:45.492] getGlobalsAndPackages() ... DONE
[13:23:45.492] Packages needed by the future expression (n = 0): <none>
[13:23:45.493] Packages needed by future strategies (n = 0): <none>
[13:23:45.493] {
[13:23:45.493]     {
[13:23:45.493]         {
[13:23:45.493]             ...future.startTime <- base::Sys.time()
[13:23:45.493]             {
[13:23:45.493]                 {
[13:23:45.493]                   {
[13:23:45.493]                     base::local({
[13:23:45.493]                       has_future <- base::requireNamespace("future", 
[13:23:45.493]                         quietly = TRUE)
[13:23:45.493]                       if (has_future) {
[13:23:45.493]                         ns <- base::getNamespace("future")
[13:23:45.493]                         version <- ns[[".package"]][["version"]]
[13:23:45.493]                         if (is.null(version)) 
[13:23:45.493]                           version <- utils::packageVersion("future")
[13:23:45.493]                       }
[13:23:45.493]                       else {
[13:23:45.493]                         version <- NULL
[13:23:45.493]                       }
[13:23:45.493]                       if (!has_future || version < "1.8.0") {
[13:23:45.493]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.493]                           "", base::R.version$version.string), 
[13:23:45.493]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.493]                             "release", "version")], collapse = " "), 
[13:23:45.493]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.493]                           info)
[13:23:45.493]                         info <- base::paste(info, collapse = "; ")
[13:23:45.493]                         if (!has_future) {
[13:23:45.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.493]                             info)
[13:23:45.493]                         }
[13:23:45.493]                         else {
[13:23:45.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.493]                             info, version)
[13:23:45.493]                         }
[13:23:45.493]                         base::stop(msg)
[13:23:45.493]                       }
[13:23:45.493]                     })
[13:23:45.493]                   }
[13:23:45.493]                   options(future.plan = NULL)
[13:23:45.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.493]                 }
[13:23:45.493]                 ...future.workdir <- getwd()
[13:23:45.493]             }
[13:23:45.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.493]         }
[13:23:45.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.493]             base::names(...future.oldOptions))
[13:23:45.493]     }
[13:23:45.493]     if (FALSE) {
[13:23:45.493]     }
[13:23:45.493]     else {
[13:23:45.493]         if (TRUE) {
[13:23:45.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.493]                 open = "w")
[13:23:45.493]         }
[13:23:45.493]         else {
[13:23:45.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.493]         }
[13:23:45.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.493]             base::sink(type = "output", split = FALSE)
[13:23:45.493]             base::close(...future.stdout)
[13:23:45.493]         }, add = TRUE)
[13:23:45.493]     }
[13:23:45.493]     ...future.frame <- base::sys.nframe()
[13:23:45.493]     ...future.conditions <- base::list()
[13:23:45.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.493]     if (FALSE) {
[13:23:45.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.493]     }
[13:23:45.493]     ...future.result <- base::tryCatch({
[13:23:45.493]         base::withCallingHandlers({
[13:23:45.493]             ...future.value <- base::withVisible(base::local({
[13:23:45.493]                 ii
[13:23:45.493]             }))
[13:23:45.493]             future::FutureResult(value = ...future.value$value, 
[13:23:45.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.493]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.493]                     ...future.globalenv.names))
[13:23:45.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.493]         }, condition = base::local({
[13:23:45.493]             c <- base::c
[13:23:45.493]             inherits <- base::inherits
[13:23:45.493]             invokeRestart <- base::invokeRestart
[13:23:45.493]             length <- base::length
[13:23:45.493]             list <- base::list
[13:23:45.493]             seq.int <- base::seq.int
[13:23:45.493]             signalCondition <- base::signalCondition
[13:23:45.493]             sys.calls <- base::sys.calls
[13:23:45.493]             `[[` <- base::`[[`
[13:23:45.493]             `+` <- base::`+`
[13:23:45.493]             `<<-` <- base::`<<-`
[13:23:45.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.493]                   3L)]
[13:23:45.493]             }
[13:23:45.493]             function(cond) {
[13:23:45.493]                 is_error <- inherits(cond, "error")
[13:23:45.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.493]                   NULL)
[13:23:45.493]                 if (is_error) {
[13:23:45.493]                   sessionInformation <- function() {
[13:23:45.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.493]                       search = base::search(), system = base::Sys.info())
[13:23:45.493]                   }
[13:23:45.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.493]                     cond$call), session = sessionInformation(), 
[13:23:45.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.493]                   signalCondition(cond)
[13:23:45.493]                 }
[13:23:45.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.493]                 "immediateCondition"))) {
[13:23:45.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.493]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.493]                   if (TRUE && !signal) {
[13:23:45.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.493]                     {
[13:23:45.493]                       inherits <- base::inherits
[13:23:45.493]                       invokeRestart <- base::invokeRestart
[13:23:45.493]                       is.null <- base::is.null
[13:23:45.493]                       muffled <- FALSE
[13:23:45.493]                       if (inherits(cond, "message")) {
[13:23:45.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.493]                         if (muffled) 
[13:23:45.493]                           invokeRestart("muffleMessage")
[13:23:45.493]                       }
[13:23:45.493]                       else if (inherits(cond, "warning")) {
[13:23:45.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.493]                         if (muffled) 
[13:23:45.493]                           invokeRestart("muffleWarning")
[13:23:45.493]                       }
[13:23:45.493]                       else if (inherits(cond, "condition")) {
[13:23:45.493]                         if (!is.null(pattern)) {
[13:23:45.493]                           computeRestarts <- base::computeRestarts
[13:23:45.493]                           grepl <- base::grepl
[13:23:45.493]                           restarts <- computeRestarts(cond)
[13:23:45.493]                           for (restart in restarts) {
[13:23:45.493]                             name <- restart$name
[13:23:45.493]                             if (is.null(name)) 
[13:23:45.493]                               next
[13:23:45.493]                             if (!grepl(pattern, name)) 
[13:23:45.493]                               next
[13:23:45.493]                             invokeRestart(restart)
[13:23:45.493]                             muffled <- TRUE
[13:23:45.493]                             break
[13:23:45.493]                           }
[13:23:45.493]                         }
[13:23:45.493]                       }
[13:23:45.493]                       invisible(muffled)
[13:23:45.493]                     }
[13:23:45.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.493]                   }
[13:23:45.493]                 }
[13:23:45.493]                 else {
[13:23:45.493]                   if (TRUE) {
[13:23:45.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.493]                     {
[13:23:45.493]                       inherits <- base::inherits
[13:23:45.493]                       invokeRestart <- base::invokeRestart
[13:23:45.493]                       is.null <- base::is.null
[13:23:45.493]                       muffled <- FALSE
[13:23:45.493]                       if (inherits(cond, "message")) {
[13:23:45.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.493]                         if (muffled) 
[13:23:45.493]                           invokeRestart("muffleMessage")
[13:23:45.493]                       }
[13:23:45.493]                       else if (inherits(cond, "warning")) {
[13:23:45.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.493]                         if (muffled) 
[13:23:45.493]                           invokeRestart("muffleWarning")
[13:23:45.493]                       }
[13:23:45.493]                       else if (inherits(cond, "condition")) {
[13:23:45.493]                         if (!is.null(pattern)) {
[13:23:45.493]                           computeRestarts <- base::computeRestarts
[13:23:45.493]                           grepl <- base::grepl
[13:23:45.493]                           restarts <- computeRestarts(cond)
[13:23:45.493]                           for (restart in restarts) {
[13:23:45.493]                             name <- restart$name
[13:23:45.493]                             if (is.null(name)) 
[13:23:45.493]                               next
[13:23:45.493]                             if (!grepl(pattern, name)) 
[13:23:45.493]                               next
[13:23:45.493]                             invokeRestart(restart)
[13:23:45.493]                             muffled <- TRUE
[13:23:45.493]                             break
[13:23:45.493]                           }
[13:23:45.493]                         }
[13:23:45.493]                       }
[13:23:45.493]                       invisible(muffled)
[13:23:45.493]                     }
[13:23:45.493]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.493]                   }
[13:23:45.493]                 }
[13:23:45.493]             }
[13:23:45.493]         }))
[13:23:45.493]     }, error = function(ex) {
[13:23:45.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.493]                 ...future.rng), started = ...future.startTime, 
[13:23:45.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.493]             version = "1.8"), class = "FutureResult")
[13:23:45.493]     }, finally = {
[13:23:45.493]         if (!identical(...future.workdir, getwd())) 
[13:23:45.493]             setwd(...future.workdir)
[13:23:45.493]         {
[13:23:45.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.493]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.493]             }
[13:23:45.493]             base::options(...future.oldOptions)
[13:23:45.493]             if (.Platform$OS.type == "windows") {
[13:23:45.493]                 old_names <- names(...future.oldEnvVars)
[13:23:45.493]                 envs <- base::Sys.getenv()
[13:23:45.493]                 names <- names(envs)
[13:23:45.493]                 common <- intersect(names, old_names)
[13:23:45.493]                 added <- setdiff(names, old_names)
[13:23:45.493]                 removed <- setdiff(old_names, names)
[13:23:45.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.493]                   envs[common]]
[13:23:45.493]                 NAMES <- toupper(changed)
[13:23:45.493]                 args <- list()
[13:23:45.493]                 for (kk in seq_along(NAMES)) {
[13:23:45.493]                   name <- changed[[kk]]
[13:23:45.493]                   NAME <- NAMES[[kk]]
[13:23:45.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.493]                     next
[13:23:45.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.493]                 }
[13:23:45.493]                 NAMES <- toupper(added)
[13:23:45.493]                 for (kk in seq_along(NAMES)) {
[13:23:45.493]                   name <- added[[kk]]
[13:23:45.493]                   NAME <- NAMES[[kk]]
[13:23:45.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.493]                     next
[13:23:45.493]                   args[[name]] <- ""
[13:23:45.493]                 }
[13:23:45.493]                 NAMES <- toupper(removed)
[13:23:45.493]                 for (kk in seq_along(NAMES)) {
[13:23:45.493]                   name <- removed[[kk]]
[13:23:45.493]                   NAME <- NAMES[[kk]]
[13:23:45.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.493]                     next
[13:23:45.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.493]                 }
[13:23:45.493]                 if (length(args) > 0) 
[13:23:45.493]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.493]             }
[13:23:45.493]             else {
[13:23:45.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.493]             }
[13:23:45.493]             {
[13:23:45.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.493]                   0L) {
[13:23:45.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.493]                   base::options(opts)
[13:23:45.493]                 }
[13:23:45.493]                 {
[13:23:45.493]                   {
[13:23:45.493]                     NULL
[13:23:45.493]                     RNGkind("Mersenne-Twister")
[13:23:45.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.493]                       inherits = FALSE)
[13:23:45.493]                   }
[13:23:45.493]                   options(future.plan = NULL)
[13:23:45.493]                   if (is.na(NA_character_)) 
[13:23:45.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.493]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.493]                     envir = parent.frame()) 
[13:23:45.493]                   {
[13:23:45.493]                     default_workers <- missing(workers)
[13:23:45.493]                     if (is.function(workers)) 
[13:23:45.493]                       workers <- workers()
[13:23:45.493]                     workers <- structure(as.integer(workers), 
[13:23:45.493]                       class = class(workers))
[13:23:45.493]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.493]                       1L)
[13:23:45.493]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.493]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.493]                       if (default_workers) 
[13:23:45.493]                         supportsMulticore(warn = TRUE)
[13:23:45.493]                       return(sequential(..., envir = envir))
[13:23:45.493]                     }
[13:23:45.493]                     oopts <- options(mc.cores = workers)
[13:23:45.493]                     on.exit(options(oopts))
[13:23:45.493]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.493]                       envir = envir)
[13:23:45.493]                     if (!future$lazy) 
[13:23:45.493]                       future <- run(future)
[13:23:45.493]                     invisible(future)
[13:23:45.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.493]                 }
[13:23:45.493]             }
[13:23:45.493]         }
[13:23:45.493]     })
[13:23:45.493]     if (TRUE) {
[13:23:45.493]         base::sink(type = "output", split = FALSE)
[13:23:45.493]         if (TRUE) {
[13:23:45.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.493]         }
[13:23:45.493]         else {
[13:23:45.493]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.493]         }
[13:23:45.493]         base::close(...future.stdout)
[13:23:45.493]         ...future.stdout <- NULL
[13:23:45.493]     }
[13:23:45.493]     ...future.result$conditions <- ...future.conditions
[13:23:45.493]     ...future.result$finished <- base::Sys.time()
[13:23:45.493]     ...future.result
[13:23:45.493] }
[13:23:45.495] assign_globals() ...
[13:23:45.495] List of 1
[13:23:45.495]  $ ii: int 2
[13:23:45.495]  - attr(*, "where")=List of 1
[13:23:45.495]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.495]  - attr(*, "resolved")= logi FALSE
[13:23:45.495]  - attr(*, "total_size")= num 56
[13:23:45.497] - copied ‘ii’ to environment
[13:23:45.497] assign_globals() ... done
[13:23:45.498] plan(): Setting new future strategy stack:
[13:23:45.498] List of future strategies:
[13:23:45.498] 1. sequential:
[13:23:45.498]    - args: function (..., envir = parent.frame())
[13:23:45.498]    - tweaked: FALSE
[13:23:45.498]    - call: NULL
[13:23:45.498] plan(): nbrOfWorkers() = 1
[13:23:45.499] plan(): Setting new future strategy stack:
[13:23:45.499] List of future strategies:
[13:23:45.499] 1. multicore:
[13:23:45.499]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.499]    - tweaked: FALSE
[13:23:45.499]    - call: plan(multicore)
[13:23:45.503] plan(): nbrOfWorkers() = 1
[13:23:45.503] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[13:23:45.507] getGlobalsAndPackages() ...
[13:23:45.507] Searching for globals...
[13:23:45.508] - globals found: [2] ‘{’, ‘ii’
[13:23:45.508] Searching for globals ... DONE
[13:23:45.508] Resolving globals: FALSE
[13:23:45.509] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.511] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.511] - globals: [1] ‘ii’
[13:23:45.511] 
[13:23:45.511] getGlobalsAndPackages() ... DONE
[13:23:45.511] Packages needed by the future expression (n = 0): <none>
[13:23:45.512] Packages needed by future strategies (n = 0): <none>
[13:23:45.512] {
[13:23:45.512]     {
[13:23:45.512]         {
[13:23:45.512]             ...future.startTime <- base::Sys.time()
[13:23:45.512]             {
[13:23:45.512]                 {
[13:23:45.512]                   {
[13:23:45.512]                     base::local({
[13:23:45.512]                       has_future <- base::requireNamespace("future", 
[13:23:45.512]                         quietly = TRUE)
[13:23:45.512]                       if (has_future) {
[13:23:45.512]                         ns <- base::getNamespace("future")
[13:23:45.512]                         version <- ns[[".package"]][["version"]]
[13:23:45.512]                         if (is.null(version)) 
[13:23:45.512]                           version <- utils::packageVersion("future")
[13:23:45.512]                       }
[13:23:45.512]                       else {
[13:23:45.512]                         version <- NULL
[13:23:45.512]                       }
[13:23:45.512]                       if (!has_future || version < "1.8.0") {
[13:23:45.512]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.512]                           "", base::R.version$version.string), 
[13:23:45.512]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.512]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.512]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.512]                             "release", "version")], collapse = " "), 
[13:23:45.512]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.512]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.512]                           info)
[13:23:45.512]                         info <- base::paste(info, collapse = "; ")
[13:23:45.512]                         if (!has_future) {
[13:23:45.512]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.512]                             info)
[13:23:45.512]                         }
[13:23:45.512]                         else {
[13:23:45.512]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.512]                             info, version)
[13:23:45.512]                         }
[13:23:45.512]                         base::stop(msg)
[13:23:45.512]                       }
[13:23:45.512]                     })
[13:23:45.512]                   }
[13:23:45.512]                   options(future.plan = NULL)
[13:23:45.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.512]                 }
[13:23:45.512]                 ...future.workdir <- getwd()
[13:23:45.512]             }
[13:23:45.512]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.512]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.512]         }
[13:23:45.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.512]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.512]             base::names(...future.oldOptions))
[13:23:45.512]     }
[13:23:45.512]     if (FALSE) {
[13:23:45.512]     }
[13:23:45.512]     else {
[13:23:45.512]         if (TRUE) {
[13:23:45.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.512]                 open = "w")
[13:23:45.512]         }
[13:23:45.512]         else {
[13:23:45.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.512]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.512]         }
[13:23:45.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.512]             base::sink(type = "output", split = FALSE)
[13:23:45.512]             base::close(...future.stdout)
[13:23:45.512]         }, add = TRUE)
[13:23:45.512]     }
[13:23:45.512]     ...future.frame <- base::sys.nframe()
[13:23:45.512]     ...future.conditions <- base::list()
[13:23:45.512]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.512]     if (FALSE) {
[13:23:45.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.512]     }
[13:23:45.512]     ...future.result <- base::tryCatch({
[13:23:45.512]         base::withCallingHandlers({
[13:23:45.512]             ...future.value <- base::withVisible(base::local({
[13:23:45.512]                 ii
[13:23:45.512]             }))
[13:23:45.512]             future::FutureResult(value = ...future.value$value, 
[13:23:45.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.512]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.512]                     ...future.globalenv.names))
[13:23:45.512]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.512]         }, condition = base::local({
[13:23:45.512]             c <- base::c
[13:23:45.512]             inherits <- base::inherits
[13:23:45.512]             invokeRestart <- base::invokeRestart
[13:23:45.512]             length <- base::length
[13:23:45.512]             list <- base::list
[13:23:45.512]             seq.int <- base::seq.int
[13:23:45.512]             signalCondition <- base::signalCondition
[13:23:45.512]             sys.calls <- base::sys.calls
[13:23:45.512]             `[[` <- base::`[[`
[13:23:45.512]             `+` <- base::`+`
[13:23:45.512]             `<<-` <- base::`<<-`
[13:23:45.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.512]                   3L)]
[13:23:45.512]             }
[13:23:45.512]             function(cond) {
[13:23:45.512]                 is_error <- inherits(cond, "error")
[13:23:45.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.512]                   NULL)
[13:23:45.512]                 if (is_error) {
[13:23:45.512]                   sessionInformation <- function() {
[13:23:45.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.512]                       search = base::search(), system = base::Sys.info())
[13:23:45.512]                   }
[13:23:45.512]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.512]                     cond$call), session = sessionInformation(), 
[13:23:45.512]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.512]                   signalCondition(cond)
[13:23:45.512]                 }
[13:23:45.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.512]                 "immediateCondition"))) {
[13:23:45.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.512]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.512]                   if (TRUE && !signal) {
[13:23:45.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.512]                     {
[13:23:45.512]                       inherits <- base::inherits
[13:23:45.512]                       invokeRestart <- base::invokeRestart
[13:23:45.512]                       is.null <- base::is.null
[13:23:45.512]                       muffled <- FALSE
[13:23:45.512]                       if (inherits(cond, "message")) {
[13:23:45.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.512]                         if (muffled) 
[13:23:45.512]                           invokeRestart("muffleMessage")
[13:23:45.512]                       }
[13:23:45.512]                       else if (inherits(cond, "warning")) {
[13:23:45.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.512]                         if (muffled) 
[13:23:45.512]                           invokeRestart("muffleWarning")
[13:23:45.512]                       }
[13:23:45.512]                       else if (inherits(cond, "condition")) {
[13:23:45.512]                         if (!is.null(pattern)) {
[13:23:45.512]                           computeRestarts <- base::computeRestarts
[13:23:45.512]                           grepl <- base::grepl
[13:23:45.512]                           restarts <- computeRestarts(cond)
[13:23:45.512]                           for (restart in restarts) {
[13:23:45.512]                             name <- restart$name
[13:23:45.512]                             if (is.null(name)) 
[13:23:45.512]                               next
[13:23:45.512]                             if (!grepl(pattern, name)) 
[13:23:45.512]                               next
[13:23:45.512]                             invokeRestart(restart)
[13:23:45.512]                             muffled <- TRUE
[13:23:45.512]                             break
[13:23:45.512]                           }
[13:23:45.512]                         }
[13:23:45.512]                       }
[13:23:45.512]                       invisible(muffled)
[13:23:45.512]                     }
[13:23:45.512]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.512]                   }
[13:23:45.512]                 }
[13:23:45.512]                 else {
[13:23:45.512]                   if (TRUE) {
[13:23:45.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.512]                     {
[13:23:45.512]                       inherits <- base::inherits
[13:23:45.512]                       invokeRestart <- base::invokeRestart
[13:23:45.512]                       is.null <- base::is.null
[13:23:45.512]                       muffled <- FALSE
[13:23:45.512]                       if (inherits(cond, "message")) {
[13:23:45.512]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.512]                         if (muffled) 
[13:23:45.512]                           invokeRestart("muffleMessage")
[13:23:45.512]                       }
[13:23:45.512]                       else if (inherits(cond, "warning")) {
[13:23:45.512]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.512]                         if (muffled) 
[13:23:45.512]                           invokeRestart("muffleWarning")
[13:23:45.512]                       }
[13:23:45.512]                       else if (inherits(cond, "condition")) {
[13:23:45.512]                         if (!is.null(pattern)) {
[13:23:45.512]                           computeRestarts <- base::computeRestarts
[13:23:45.512]                           grepl <- base::grepl
[13:23:45.512]                           restarts <- computeRestarts(cond)
[13:23:45.512]                           for (restart in restarts) {
[13:23:45.512]                             name <- restart$name
[13:23:45.512]                             if (is.null(name)) 
[13:23:45.512]                               next
[13:23:45.512]                             if (!grepl(pattern, name)) 
[13:23:45.512]                               next
[13:23:45.512]                             invokeRestart(restart)
[13:23:45.512]                             muffled <- TRUE
[13:23:45.512]                             break
[13:23:45.512]                           }
[13:23:45.512]                         }
[13:23:45.512]                       }
[13:23:45.512]                       invisible(muffled)
[13:23:45.512]                     }
[13:23:45.512]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.512]                   }
[13:23:45.512]                 }
[13:23:45.512]             }
[13:23:45.512]         }))
[13:23:45.512]     }, error = function(ex) {
[13:23:45.512]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.512]                 ...future.rng), started = ...future.startTime, 
[13:23:45.512]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.512]             version = "1.8"), class = "FutureResult")
[13:23:45.512]     }, finally = {
[13:23:45.512]         if (!identical(...future.workdir, getwd())) 
[13:23:45.512]             setwd(...future.workdir)
[13:23:45.512]         {
[13:23:45.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.512]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.512]             }
[13:23:45.512]             base::options(...future.oldOptions)
[13:23:45.512]             if (.Platform$OS.type == "windows") {
[13:23:45.512]                 old_names <- names(...future.oldEnvVars)
[13:23:45.512]                 envs <- base::Sys.getenv()
[13:23:45.512]                 names <- names(envs)
[13:23:45.512]                 common <- intersect(names, old_names)
[13:23:45.512]                 added <- setdiff(names, old_names)
[13:23:45.512]                 removed <- setdiff(old_names, names)
[13:23:45.512]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.512]                   envs[common]]
[13:23:45.512]                 NAMES <- toupper(changed)
[13:23:45.512]                 args <- list()
[13:23:45.512]                 for (kk in seq_along(NAMES)) {
[13:23:45.512]                   name <- changed[[kk]]
[13:23:45.512]                   NAME <- NAMES[[kk]]
[13:23:45.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.512]                     next
[13:23:45.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.512]                 }
[13:23:45.512]                 NAMES <- toupper(added)
[13:23:45.512]                 for (kk in seq_along(NAMES)) {
[13:23:45.512]                   name <- added[[kk]]
[13:23:45.512]                   NAME <- NAMES[[kk]]
[13:23:45.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.512]                     next
[13:23:45.512]                   args[[name]] <- ""
[13:23:45.512]                 }
[13:23:45.512]                 NAMES <- toupper(removed)
[13:23:45.512]                 for (kk in seq_along(NAMES)) {
[13:23:45.512]                   name <- removed[[kk]]
[13:23:45.512]                   NAME <- NAMES[[kk]]
[13:23:45.512]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.512]                     next
[13:23:45.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.512]                 }
[13:23:45.512]                 if (length(args) > 0) 
[13:23:45.512]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.512]             }
[13:23:45.512]             else {
[13:23:45.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.512]             }
[13:23:45.512]             {
[13:23:45.512]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.512]                   0L) {
[13:23:45.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.512]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.512]                   base::options(opts)
[13:23:45.512]                 }
[13:23:45.512]                 {
[13:23:45.512]                   {
[13:23:45.512]                     NULL
[13:23:45.512]                     RNGkind("Mersenne-Twister")
[13:23:45.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.512]                       inherits = FALSE)
[13:23:45.512]                   }
[13:23:45.512]                   options(future.plan = NULL)
[13:23:45.512]                   if (is.na(NA_character_)) 
[13:23:45.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.512]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.512]                     envir = parent.frame()) 
[13:23:45.512]                   {
[13:23:45.512]                     default_workers <- missing(workers)
[13:23:45.512]                     if (is.function(workers)) 
[13:23:45.512]                       workers <- workers()
[13:23:45.512]                     workers <- structure(as.integer(workers), 
[13:23:45.512]                       class = class(workers))
[13:23:45.512]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.512]                       1L)
[13:23:45.512]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.512]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.512]                       if (default_workers) 
[13:23:45.512]                         supportsMulticore(warn = TRUE)
[13:23:45.512]                       return(sequential(..., envir = envir))
[13:23:45.512]                     }
[13:23:45.512]                     oopts <- options(mc.cores = workers)
[13:23:45.512]                     on.exit(options(oopts))
[13:23:45.512]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.512]                       envir = envir)
[13:23:45.512]                     if (!future$lazy) 
[13:23:45.512]                       future <- run(future)
[13:23:45.512]                     invisible(future)
[13:23:45.512]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.512]                 }
[13:23:45.512]             }
[13:23:45.512]         }
[13:23:45.512]     })
[13:23:45.512]     if (TRUE) {
[13:23:45.512]         base::sink(type = "output", split = FALSE)
[13:23:45.512]         if (TRUE) {
[13:23:45.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.512]         }
[13:23:45.512]         else {
[13:23:45.512]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.512]         }
[13:23:45.512]         base::close(...future.stdout)
[13:23:45.512]         ...future.stdout <- NULL
[13:23:45.512]     }
[13:23:45.512]     ...future.result$conditions <- ...future.conditions
[13:23:45.512]     ...future.result$finished <- base::Sys.time()
[13:23:45.512]     ...future.result
[13:23:45.512] }
[13:23:45.514] assign_globals() ...
[13:23:45.514] List of 1
[13:23:45.514]  $ ii: int 3
[13:23:45.514]  - attr(*, "where")=List of 1
[13:23:45.514]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.514]  - attr(*, "resolved")= logi FALSE
[13:23:45.514]  - attr(*, "total_size")= num 56
[13:23:45.516] - copied ‘ii’ to environment
[13:23:45.516] assign_globals() ... done
[13:23:45.517] plan(): Setting new future strategy stack:
[13:23:45.517] List of future strategies:
[13:23:45.517] 1. sequential:
[13:23:45.517]    - args: function (..., envir = parent.frame())
[13:23:45.517]    - tweaked: FALSE
[13:23:45.517]    - call: NULL
[13:23:45.517] plan(): nbrOfWorkers() = 1
[13:23:45.518] plan(): Setting new future strategy stack:
[13:23:45.518] List of future strategies:
[13:23:45.518] 1. multicore:
[13:23:45.518]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.518]    - tweaked: FALSE
[13:23:45.518]    - call: plan(multicore)
[13:23:45.522] plan(): nbrOfWorkers() = 1
[13:23:45.522] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[13:23:45.525] getGlobalsAndPackages() ...
[13:23:45.525] Searching for globals...
[13:23:45.526] - globals found: [2] ‘{’, ‘ii’
[13:23:45.526] Searching for globals ... DONE
[13:23:45.526] Resolving globals: FALSE
[13:23:45.527] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.527] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.527] - globals: [1] ‘ii’
[13:23:45.527] 
[13:23:45.527] getGlobalsAndPackages() ... DONE
[13:23:45.528] Packages needed by the future expression (n = 0): <none>
[13:23:45.528] Packages needed by future strategies (n = 0): <none>
[13:23:45.528] {
[13:23:45.528]     {
[13:23:45.528]         {
[13:23:45.528]             ...future.startTime <- base::Sys.time()
[13:23:45.528]             {
[13:23:45.528]                 {
[13:23:45.528]                   {
[13:23:45.528]                     base::local({
[13:23:45.528]                       has_future <- base::requireNamespace("future", 
[13:23:45.528]                         quietly = TRUE)
[13:23:45.528]                       if (has_future) {
[13:23:45.528]                         ns <- base::getNamespace("future")
[13:23:45.528]                         version <- ns[[".package"]][["version"]]
[13:23:45.528]                         if (is.null(version)) 
[13:23:45.528]                           version <- utils::packageVersion("future")
[13:23:45.528]                       }
[13:23:45.528]                       else {
[13:23:45.528]                         version <- NULL
[13:23:45.528]                       }
[13:23:45.528]                       if (!has_future || version < "1.8.0") {
[13:23:45.528]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.528]                           "", base::R.version$version.string), 
[13:23:45.528]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.528]                             "release", "version")], collapse = " "), 
[13:23:45.528]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.528]                           info)
[13:23:45.528]                         info <- base::paste(info, collapse = "; ")
[13:23:45.528]                         if (!has_future) {
[13:23:45.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.528]                             info)
[13:23:45.528]                         }
[13:23:45.528]                         else {
[13:23:45.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.528]                             info, version)
[13:23:45.528]                         }
[13:23:45.528]                         base::stop(msg)
[13:23:45.528]                       }
[13:23:45.528]                     })
[13:23:45.528]                   }
[13:23:45.528]                   options(future.plan = NULL)
[13:23:45.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.528]                 }
[13:23:45.528]                 ...future.workdir <- getwd()
[13:23:45.528]             }
[13:23:45.528]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.528]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.528]         }
[13:23:45.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.528]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.528]             base::names(...future.oldOptions))
[13:23:45.528]     }
[13:23:45.528]     if (FALSE) {
[13:23:45.528]     }
[13:23:45.528]     else {
[13:23:45.528]         if (TRUE) {
[13:23:45.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.528]                 open = "w")
[13:23:45.528]         }
[13:23:45.528]         else {
[13:23:45.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.528]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.528]         }
[13:23:45.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.528]             base::sink(type = "output", split = FALSE)
[13:23:45.528]             base::close(...future.stdout)
[13:23:45.528]         }, add = TRUE)
[13:23:45.528]     }
[13:23:45.528]     ...future.frame <- base::sys.nframe()
[13:23:45.528]     ...future.conditions <- base::list()
[13:23:45.528]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.528]     if (FALSE) {
[13:23:45.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.528]     }
[13:23:45.528]     ...future.result <- base::tryCatch({
[13:23:45.528]         base::withCallingHandlers({
[13:23:45.528]             ...future.value <- base::withVisible(base::local({
[13:23:45.528]                 ii
[13:23:45.528]             }))
[13:23:45.528]             future::FutureResult(value = ...future.value$value, 
[13:23:45.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.528]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.528]                     ...future.globalenv.names))
[13:23:45.528]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.528]         }, condition = base::local({
[13:23:45.528]             c <- base::c
[13:23:45.528]             inherits <- base::inherits
[13:23:45.528]             invokeRestart <- base::invokeRestart
[13:23:45.528]             length <- base::length
[13:23:45.528]             list <- base::list
[13:23:45.528]             seq.int <- base::seq.int
[13:23:45.528]             signalCondition <- base::signalCondition
[13:23:45.528]             sys.calls <- base::sys.calls
[13:23:45.528]             `[[` <- base::`[[`
[13:23:45.528]             `+` <- base::`+`
[13:23:45.528]             `<<-` <- base::`<<-`
[13:23:45.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.528]                   3L)]
[13:23:45.528]             }
[13:23:45.528]             function(cond) {
[13:23:45.528]                 is_error <- inherits(cond, "error")
[13:23:45.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.528]                   NULL)
[13:23:45.528]                 if (is_error) {
[13:23:45.528]                   sessionInformation <- function() {
[13:23:45.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.528]                       search = base::search(), system = base::Sys.info())
[13:23:45.528]                   }
[13:23:45.528]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.528]                     cond$call), session = sessionInformation(), 
[13:23:45.528]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.528]                   signalCondition(cond)
[13:23:45.528]                 }
[13:23:45.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.528]                 "immediateCondition"))) {
[13:23:45.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.528]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.528]                   if (TRUE && !signal) {
[13:23:45.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.528]                     {
[13:23:45.528]                       inherits <- base::inherits
[13:23:45.528]                       invokeRestart <- base::invokeRestart
[13:23:45.528]                       is.null <- base::is.null
[13:23:45.528]                       muffled <- FALSE
[13:23:45.528]                       if (inherits(cond, "message")) {
[13:23:45.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.528]                         if (muffled) 
[13:23:45.528]                           invokeRestart("muffleMessage")
[13:23:45.528]                       }
[13:23:45.528]                       else if (inherits(cond, "warning")) {
[13:23:45.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.528]                         if (muffled) 
[13:23:45.528]                           invokeRestart("muffleWarning")
[13:23:45.528]                       }
[13:23:45.528]                       else if (inherits(cond, "condition")) {
[13:23:45.528]                         if (!is.null(pattern)) {
[13:23:45.528]                           computeRestarts <- base::computeRestarts
[13:23:45.528]                           grepl <- base::grepl
[13:23:45.528]                           restarts <- computeRestarts(cond)
[13:23:45.528]                           for (restart in restarts) {
[13:23:45.528]                             name <- restart$name
[13:23:45.528]                             if (is.null(name)) 
[13:23:45.528]                               next
[13:23:45.528]                             if (!grepl(pattern, name)) 
[13:23:45.528]                               next
[13:23:45.528]                             invokeRestart(restart)
[13:23:45.528]                             muffled <- TRUE
[13:23:45.528]                             break
[13:23:45.528]                           }
[13:23:45.528]                         }
[13:23:45.528]                       }
[13:23:45.528]                       invisible(muffled)
[13:23:45.528]                     }
[13:23:45.528]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.528]                   }
[13:23:45.528]                 }
[13:23:45.528]                 else {
[13:23:45.528]                   if (TRUE) {
[13:23:45.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.528]                     {
[13:23:45.528]                       inherits <- base::inherits
[13:23:45.528]                       invokeRestart <- base::invokeRestart
[13:23:45.528]                       is.null <- base::is.null
[13:23:45.528]                       muffled <- FALSE
[13:23:45.528]                       if (inherits(cond, "message")) {
[13:23:45.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.528]                         if (muffled) 
[13:23:45.528]                           invokeRestart("muffleMessage")
[13:23:45.528]                       }
[13:23:45.528]                       else if (inherits(cond, "warning")) {
[13:23:45.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.528]                         if (muffled) 
[13:23:45.528]                           invokeRestart("muffleWarning")
[13:23:45.528]                       }
[13:23:45.528]                       else if (inherits(cond, "condition")) {
[13:23:45.528]                         if (!is.null(pattern)) {
[13:23:45.528]                           computeRestarts <- base::computeRestarts
[13:23:45.528]                           grepl <- base::grepl
[13:23:45.528]                           restarts <- computeRestarts(cond)
[13:23:45.528]                           for (restart in restarts) {
[13:23:45.528]                             name <- restart$name
[13:23:45.528]                             if (is.null(name)) 
[13:23:45.528]                               next
[13:23:45.528]                             if (!grepl(pattern, name)) 
[13:23:45.528]                               next
[13:23:45.528]                             invokeRestart(restart)
[13:23:45.528]                             muffled <- TRUE
[13:23:45.528]                             break
[13:23:45.528]                           }
[13:23:45.528]                         }
[13:23:45.528]                       }
[13:23:45.528]                       invisible(muffled)
[13:23:45.528]                     }
[13:23:45.528]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.528]                   }
[13:23:45.528]                 }
[13:23:45.528]             }
[13:23:45.528]         }))
[13:23:45.528]     }, error = function(ex) {
[13:23:45.528]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.528]                 ...future.rng), started = ...future.startTime, 
[13:23:45.528]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.528]             version = "1.8"), class = "FutureResult")
[13:23:45.528]     }, finally = {
[13:23:45.528]         if (!identical(...future.workdir, getwd())) 
[13:23:45.528]             setwd(...future.workdir)
[13:23:45.528]         {
[13:23:45.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.528]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.528]             }
[13:23:45.528]             base::options(...future.oldOptions)
[13:23:45.528]             if (.Platform$OS.type == "windows") {
[13:23:45.528]                 old_names <- names(...future.oldEnvVars)
[13:23:45.528]                 envs <- base::Sys.getenv()
[13:23:45.528]                 names <- names(envs)
[13:23:45.528]                 common <- intersect(names, old_names)
[13:23:45.528]                 added <- setdiff(names, old_names)
[13:23:45.528]                 removed <- setdiff(old_names, names)
[13:23:45.528]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.528]                   envs[common]]
[13:23:45.528]                 NAMES <- toupper(changed)
[13:23:45.528]                 args <- list()
[13:23:45.528]                 for (kk in seq_along(NAMES)) {
[13:23:45.528]                   name <- changed[[kk]]
[13:23:45.528]                   NAME <- NAMES[[kk]]
[13:23:45.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.528]                     next
[13:23:45.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.528]                 }
[13:23:45.528]                 NAMES <- toupper(added)
[13:23:45.528]                 for (kk in seq_along(NAMES)) {
[13:23:45.528]                   name <- added[[kk]]
[13:23:45.528]                   NAME <- NAMES[[kk]]
[13:23:45.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.528]                     next
[13:23:45.528]                   args[[name]] <- ""
[13:23:45.528]                 }
[13:23:45.528]                 NAMES <- toupper(removed)
[13:23:45.528]                 for (kk in seq_along(NAMES)) {
[13:23:45.528]                   name <- removed[[kk]]
[13:23:45.528]                   NAME <- NAMES[[kk]]
[13:23:45.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.528]                     next
[13:23:45.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.528]                 }
[13:23:45.528]                 if (length(args) > 0) 
[13:23:45.528]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.528]             }
[13:23:45.528]             else {
[13:23:45.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.528]             }
[13:23:45.528]             {
[13:23:45.528]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.528]                   0L) {
[13:23:45.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.528]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.528]                   base::options(opts)
[13:23:45.528]                 }
[13:23:45.528]                 {
[13:23:45.528]                   {
[13:23:45.528]                     NULL
[13:23:45.528]                     RNGkind("Mersenne-Twister")
[13:23:45.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.528]                       inherits = FALSE)
[13:23:45.528]                   }
[13:23:45.528]                   options(future.plan = NULL)
[13:23:45.528]                   if (is.na(NA_character_)) 
[13:23:45.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.528]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.528]                     envir = parent.frame()) 
[13:23:45.528]                   {
[13:23:45.528]                     default_workers <- missing(workers)
[13:23:45.528]                     if (is.function(workers)) 
[13:23:45.528]                       workers <- workers()
[13:23:45.528]                     workers <- structure(as.integer(workers), 
[13:23:45.528]                       class = class(workers))
[13:23:45.528]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.528]                       1L)
[13:23:45.528]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.528]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.528]                       if (default_workers) 
[13:23:45.528]                         supportsMulticore(warn = TRUE)
[13:23:45.528]                       return(sequential(..., envir = envir))
[13:23:45.528]                     }
[13:23:45.528]                     oopts <- options(mc.cores = workers)
[13:23:45.528]                     on.exit(options(oopts))
[13:23:45.528]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.528]                       envir = envir)
[13:23:45.528]                     if (!future$lazy) 
[13:23:45.528]                       future <- run(future)
[13:23:45.528]                     invisible(future)
[13:23:45.528]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.528]                 }
[13:23:45.528]             }
[13:23:45.528]         }
[13:23:45.528]     })
[13:23:45.528]     if (TRUE) {
[13:23:45.528]         base::sink(type = "output", split = FALSE)
[13:23:45.528]         if (TRUE) {
[13:23:45.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.528]         }
[13:23:45.528]         else {
[13:23:45.528]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.528]         }
[13:23:45.528]         base::close(...future.stdout)
[13:23:45.528]         ...future.stdout <- NULL
[13:23:45.528]     }
[13:23:45.528]     ...future.result$conditions <- ...future.conditions
[13:23:45.528]     ...future.result$finished <- base::Sys.time()
[13:23:45.528]     ...future.result
[13:23:45.528] }
[13:23:45.530] assign_globals() ...
[13:23:45.530] List of 1
[13:23:45.530]  $ ii: int 4
[13:23:45.530]  - attr(*, "where")=List of 1
[13:23:45.530]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.530]  - attr(*, "resolved")= logi FALSE
[13:23:45.530]  - attr(*, "total_size")= num 56
[13:23:45.533] - copied ‘ii’ to environment
[13:23:45.533] assign_globals() ... done
[13:23:45.533] plan(): Setting new future strategy stack:
[13:23:45.533] List of future strategies:
[13:23:45.533] 1. sequential:
[13:23:45.533]    - args: function (..., envir = parent.frame())
[13:23:45.533]    - tweaked: FALSE
[13:23:45.533]    - call: NULL
[13:23:45.533] plan(): nbrOfWorkers() = 1
[13:23:45.534] plan(): Setting new future strategy stack:
[13:23:45.534] List of future strategies:
[13:23:45.534] 1. multicore:
[13:23:45.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.534]    - tweaked: FALSE
[13:23:45.534]    - call: plan(multicore)
[13:23:45.538] plan(): nbrOfWorkers() = 1
[13:23:45.538] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[13:23:45.542] getGlobalsAndPackages() ...
[13:23:45.542] Searching for globals...
[13:23:45.543] - globals found: [2] ‘{’, ‘stop’
[13:23:45.543] Searching for globals ... DONE
[13:23:45.544] Resolving globals: FALSE
[13:23:45.544] 
[13:23:45.544] 
[13:23:45.544] getGlobalsAndPackages() ... DONE
[13:23:45.545] Packages needed by the future expression (n = 0): <none>
[13:23:45.545] Packages needed by future strategies (n = 0): <none>
[13:23:45.545] {
[13:23:45.545]     {
[13:23:45.545]         {
[13:23:45.545]             ...future.startTime <- base::Sys.time()
[13:23:45.545]             {
[13:23:45.545]                 {
[13:23:45.545]                   {
[13:23:45.545]                     base::local({
[13:23:45.545]                       has_future <- base::requireNamespace("future", 
[13:23:45.545]                         quietly = TRUE)
[13:23:45.545]                       if (has_future) {
[13:23:45.545]                         ns <- base::getNamespace("future")
[13:23:45.545]                         version <- ns[[".package"]][["version"]]
[13:23:45.545]                         if (is.null(version)) 
[13:23:45.545]                           version <- utils::packageVersion("future")
[13:23:45.545]                       }
[13:23:45.545]                       else {
[13:23:45.545]                         version <- NULL
[13:23:45.545]                       }
[13:23:45.545]                       if (!has_future || version < "1.8.0") {
[13:23:45.545]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.545]                           "", base::R.version$version.string), 
[13:23:45.545]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.545]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.545]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.545]                             "release", "version")], collapse = " "), 
[13:23:45.545]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.545]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.545]                           info)
[13:23:45.545]                         info <- base::paste(info, collapse = "; ")
[13:23:45.545]                         if (!has_future) {
[13:23:45.545]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.545]                             info)
[13:23:45.545]                         }
[13:23:45.545]                         else {
[13:23:45.545]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.545]                             info, version)
[13:23:45.545]                         }
[13:23:45.545]                         base::stop(msg)
[13:23:45.545]                       }
[13:23:45.545]                     })
[13:23:45.545]                   }
[13:23:45.545]                   options(future.plan = NULL)
[13:23:45.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.545]                 }
[13:23:45.545]                 ...future.workdir <- getwd()
[13:23:45.545]             }
[13:23:45.545]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.545]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.545]         }
[13:23:45.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.545]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.545]             base::names(...future.oldOptions))
[13:23:45.545]     }
[13:23:45.545]     if (FALSE) {
[13:23:45.545]     }
[13:23:45.545]     else {
[13:23:45.545]         if (TRUE) {
[13:23:45.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.545]                 open = "w")
[13:23:45.545]         }
[13:23:45.545]         else {
[13:23:45.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.545]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.545]         }
[13:23:45.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.545]             base::sink(type = "output", split = FALSE)
[13:23:45.545]             base::close(...future.stdout)
[13:23:45.545]         }, add = TRUE)
[13:23:45.545]     }
[13:23:45.545]     ...future.frame <- base::sys.nframe()
[13:23:45.545]     ...future.conditions <- base::list()
[13:23:45.545]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.545]     if (FALSE) {
[13:23:45.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.545]     }
[13:23:45.545]     ...future.result <- base::tryCatch({
[13:23:45.545]         base::withCallingHandlers({
[13:23:45.545]             ...future.value <- base::withVisible(base::local({
[13:23:45.545]                 stop("Whoops!")
[13:23:45.545]                 1
[13:23:45.545]             }))
[13:23:45.545]             future::FutureResult(value = ...future.value$value, 
[13:23:45.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.545]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.545]                     ...future.globalenv.names))
[13:23:45.545]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.545]         }, condition = base::local({
[13:23:45.545]             c <- base::c
[13:23:45.545]             inherits <- base::inherits
[13:23:45.545]             invokeRestart <- base::invokeRestart
[13:23:45.545]             length <- base::length
[13:23:45.545]             list <- base::list
[13:23:45.545]             seq.int <- base::seq.int
[13:23:45.545]             signalCondition <- base::signalCondition
[13:23:45.545]             sys.calls <- base::sys.calls
[13:23:45.545]             `[[` <- base::`[[`
[13:23:45.545]             `+` <- base::`+`
[13:23:45.545]             `<<-` <- base::`<<-`
[13:23:45.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.545]                   3L)]
[13:23:45.545]             }
[13:23:45.545]             function(cond) {
[13:23:45.545]                 is_error <- inherits(cond, "error")
[13:23:45.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.545]                   NULL)
[13:23:45.545]                 if (is_error) {
[13:23:45.545]                   sessionInformation <- function() {
[13:23:45.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.545]                       search = base::search(), system = base::Sys.info())
[13:23:45.545]                   }
[13:23:45.545]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.545]                     cond$call), session = sessionInformation(), 
[13:23:45.545]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.545]                   signalCondition(cond)
[13:23:45.545]                 }
[13:23:45.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.545]                 "immediateCondition"))) {
[13:23:45.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.545]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.545]                   if (TRUE && !signal) {
[13:23:45.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.545]                     {
[13:23:45.545]                       inherits <- base::inherits
[13:23:45.545]                       invokeRestart <- base::invokeRestart
[13:23:45.545]                       is.null <- base::is.null
[13:23:45.545]                       muffled <- FALSE
[13:23:45.545]                       if (inherits(cond, "message")) {
[13:23:45.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.545]                         if (muffled) 
[13:23:45.545]                           invokeRestart("muffleMessage")
[13:23:45.545]                       }
[13:23:45.545]                       else if (inherits(cond, "warning")) {
[13:23:45.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.545]                         if (muffled) 
[13:23:45.545]                           invokeRestart("muffleWarning")
[13:23:45.545]                       }
[13:23:45.545]                       else if (inherits(cond, "condition")) {
[13:23:45.545]                         if (!is.null(pattern)) {
[13:23:45.545]                           computeRestarts <- base::computeRestarts
[13:23:45.545]                           grepl <- base::grepl
[13:23:45.545]                           restarts <- computeRestarts(cond)
[13:23:45.545]                           for (restart in restarts) {
[13:23:45.545]                             name <- restart$name
[13:23:45.545]                             if (is.null(name)) 
[13:23:45.545]                               next
[13:23:45.545]                             if (!grepl(pattern, name)) 
[13:23:45.545]                               next
[13:23:45.545]                             invokeRestart(restart)
[13:23:45.545]                             muffled <- TRUE
[13:23:45.545]                             break
[13:23:45.545]                           }
[13:23:45.545]                         }
[13:23:45.545]                       }
[13:23:45.545]                       invisible(muffled)
[13:23:45.545]                     }
[13:23:45.545]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.545]                   }
[13:23:45.545]                 }
[13:23:45.545]                 else {
[13:23:45.545]                   if (TRUE) {
[13:23:45.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.545]                     {
[13:23:45.545]                       inherits <- base::inherits
[13:23:45.545]                       invokeRestart <- base::invokeRestart
[13:23:45.545]                       is.null <- base::is.null
[13:23:45.545]                       muffled <- FALSE
[13:23:45.545]                       if (inherits(cond, "message")) {
[13:23:45.545]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.545]                         if (muffled) 
[13:23:45.545]                           invokeRestart("muffleMessage")
[13:23:45.545]                       }
[13:23:45.545]                       else if (inherits(cond, "warning")) {
[13:23:45.545]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.545]                         if (muffled) 
[13:23:45.545]                           invokeRestart("muffleWarning")
[13:23:45.545]                       }
[13:23:45.545]                       else if (inherits(cond, "condition")) {
[13:23:45.545]                         if (!is.null(pattern)) {
[13:23:45.545]                           computeRestarts <- base::computeRestarts
[13:23:45.545]                           grepl <- base::grepl
[13:23:45.545]                           restarts <- computeRestarts(cond)
[13:23:45.545]                           for (restart in restarts) {
[13:23:45.545]                             name <- restart$name
[13:23:45.545]                             if (is.null(name)) 
[13:23:45.545]                               next
[13:23:45.545]                             if (!grepl(pattern, name)) 
[13:23:45.545]                               next
[13:23:45.545]                             invokeRestart(restart)
[13:23:45.545]                             muffled <- TRUE
[13:23:45.545]                             break
[13:23:45.545]                           }
[13:23:45.545]                         }
[13:23:45.545]                       }
[13:23:45.545]                       invisible(muffled)
[13:23:45.545]                     }
[13:23:45.545]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.545]                   }
[13:23:45.545]                 }
[13:23:45.545]             }
[13:23:45.545]         }))
[13:23:45.545]     }, error = function(ex) {
[13:23:45.545]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.545]                 ...future.rng), started = ...future.startTime, 
[13:23:45.545]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.545]             version = "1.8"), class = "FutureResult")
[13:23:45.545]     }, finally = {
[13:23:45.545]         if (!identical(...future.workdir, getwd())) 
[13:23:45.545]             setwd(...future.workdir)
[13:23:45.545]         {
[13:23:45.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.545]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.545]             }
[13:23:45.545]             base::options(...future.oldOptions)
[13:23:45.545]             if (.Platform$OS.type == "windows") {
[13:23:45.545]                 old_names <- names(...future.oldEnvVars)
[13:23:45.545]                 envs <- base::Sys.getenv()
[13:23:45.545]                 names <- names(envs)
[13:23:45.545]                 common <- intersect(names, old_names)
[13:23:45.545]                 added <- setdiff(names, old_names)
[13:23:45.545]                 removed <- setdiff(old_names, names)
[13:23:45.545]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.545]                   envs[common]]
[13:23:45.545]                 NAMES <- toupper(changed)
[13:23:45.545]                 args <- list()
[13:23:45.545]                 for (kk in seq_along(NAMES)) {
[13:23:45.545]                   name <- changed[[kk]]
[13:23:45.545]                   NAME <- NAMES[[kk]]
[13:23:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.545]                     next
[13:23:45.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.545]                 }
[13:23:45.545]                 NAMES <- toupper(added)
[13:23:45.545]                 for (kk in seq_along(NAMES)) {
[13:23:45.545]                   name <- added[[kk]]
[13:23:45.545]                   NAME <- NAMES[[kk]]
[13:23:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.545]                     next
[13:23:45.545]                   args[[name]] <- ""
[13:23:45.545]                 }
[13:23:45.545]                 NAMES <- toupper(removed)
[13:23:45.545]                 for (kk in seq_along(NAMES)) {
[13:23:45.545]                   name <- removed[[kk]]
[13:23:45.545]                   NAME <- NAMES[[kk]]
[13:23:45.545]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.545]                     next
[13:23:45.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.545]                 }
[13:23:45.545]                 if (length(args) > 0) 
[13:23:45.545]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.545]             }
[13:23:45.545]             else {
[13:23:45.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.545]             }
[13:23:45.545]             {
[13:23:45.545]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.545]                   0L) {
[13:23:45.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.545]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.545]                   base::options(opts)
[13:23:45.545]                 }
[13:23:45.545]                 {
[13:23:45.545]                   {
[13:23:45.545]                     NULL
[13:23:45.545]                     RNGkind("Mersenne-Twister")
[13:23:45.545]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.545]                       inherits = FALSE)
[13:23:45.545]                   }
[13:23:45.545]                   options(future.plan = NULL)
[13:23:45.545]                   if (is.na(NA_character_)) 
[13:23:45.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.545]                     envir = parent.frame()) 
[13:23:45.545]                   {
[13:23:45.545]                     default_workers <- missing(workers)
[13:23:45.545]                     if (is.function(workers)) 
[13:23:45.545]                       workers <- workers()
[13:23:45.545]                     workers <- structure(as.integer(workers), 
[13:23:45.545]                       class = class(workers))
[13:23:45.545]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.545]                       1L)
[13:23:45.545]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.545]                       if (default_workers) 
[13:23:45.545]                         supportsMulticore(warn = TRUE)
[13:23:45.545]                       return(sequential(..., envir = envir))
[13:23:45.545]                     }
[13:23:45.545]                     oopts <- options(mc.cores = workers)
[13:23:45.545]                     on.exit(options(oopts))
[13:23:45.545]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.545]                       envir = envir)
[13:23:45.545]                     if (!future$lazy) 
[13:23:45.545]                       future <- run(future)
[13:23:45.545]                     invisible(future)
[13:23:45.545]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.545]                 }
[13:23:45.545]             }
[13:23:45.545]         }
[13:23:45.545]     })
[13:23:45.545]     if (TRUE) {
[13:23:45.545]         base::sink(type = "output", split = FALSE)
[13:23:45.545]         if (TRUE) {
[13:23:45.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.545]         }
[13:23:45.545]         else {
[13:23:45.545]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.545]         }
[13:23:45.545]         base::close(...future.stdout)
[13:23:45.545]         ...future.stdout <- NULL
[13:23:45.545]     }
[13:23:45.545]     ...future.result$conditions <- ...future.conditions
[13:23:45.545]     ...future.result$finished <- base::Sys.time()
[13:23:45.545]     ...future.result
[13:23:45.545] }
[13:23:45.547] plan(): Setting new future strategy stack:
[13:23:45.547] List of future strategies:
[13:23:45.547] 1. sequential:
[13:23:45.547]    - args: function (..., envir = parent.frame())
[13:23:45.547]    - tweaked: FALSE
[13:23:45.547]    - call: NULL
[13:23:45.547] plan(): nbrOfWorkers() = 1
[13:23:45.548] plan(): Setting new future strategy stack:
[13:23:45.549] List of future strategies:
[13:23:45.549] 1. multicore:
[13:23:45.549]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.549]    - tweaked: FALSE
[13:23:45.549]    - call: plan(multicore)
[13:23:45.552] plan(): nbrOfWorkers() = 1
[13:23:45.553] SequentialFuture started (and completed)
[13:23:45.553] signalConditions() ...
[13:23:45.553]  - include = ‘immediateCondition’
[13:23:45.553]  - exclude = 
[13:23:45.553]  - resignal = FALSE
[13:23:45.553]  - Number of conditions: 1
[13:23:45.553] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:45.554] signalConditions() ...
[13:23:45.554]  - include = ‘immediateCondition’
[13:23:45.554]  - exclude = 
[13:23:45.554]  - resignal = FALSE
[13:23:45.554]  - Number of conditions: 1
[13:23:45.554] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.554] signalConditions() ...
[13:23:45.556]  - include = ‘immediateCondition’
[13:23:45.557]  - exclude = 
[13:23:45.557]  - resignal = FALSE
[13:23:45.557]  - Number of conditions: 1
[13:23:45.557] signalConditions() ... done
[13:23:45.557] Future state: ‘finished’
[13:23:45.557] signalConditions() ...
[13:23:45.557]  - include = ‘condition’
[13:23:45.557]  - exclude = ‘immediateCondition’
[13:23:45.557]  - resignal = TRUE
[13:23:45.557]  - Number of conditions: 1
[13:23:45.558]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.558] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.558] signalConditions() ...
[13:23:45.558]  - include = ‘immediateCondition’
[13:23:45.558]  - exclude = 
[13:23:45.558]  - resignal = FALSE
[13:23:45.559]  - Number of conditions: 1
[13:23:45.559] signalConditions() ... done
[13:23:45.559] Future state: ‘finished’
[13:23:45.559] signalConditions() ...
[13:23:45.559]  - include = ‘condition’
[13:23:45.559]  - exclude = ‘immediateCondition’
[13:23:45.559]  - resignal = TRUE
[13:23:45.559]  - Number of conditions: 1
[13:23:45.559]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.559] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[13:23:45.563] getGlobalsAndPackages() ...
[13:23:45.563] Searching for globals...
[13:23:45.564] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[13:23:45.565] Searching for globals ... DONE
[13:23:45.565] Resolving globals: FALSE
[13:23:45.565] 
[13:23:45.565] 
[13:23:45.565] getGlobalsAndPackages() ... DONE
[13:23:45.566] Packages needed by the future expression (n = 0): <none>
[13:23:45.566] Packages needed by future strategies (n = 0): <none>
[13:23:45.566] {
[13:23:45.566]     {
[13:23:45.566]         {
[13:23:45.566]             ...future.startTime <- base::Sys.time()
[13:23:45.566]             {
[13:23:45.566]                 {
[13:23:45.566]                   {
[13:23:45.566]                     base::local({
[13:23:45.566]                       has_future <- base::requireNamespace("future", 
[13:23:45.566]                         quietly = TRUE)
[13:23:45.566]                       if (has_future) {
[13:23:45.566]                         ns <- base::getNamespace("future")
[13:23:45.566]                         version <- ns[[".package"]][["version"]]
[13:23:45.566]                         if (is.null(version)) 
[13:23:45.566]                           version <- utils::packageVersion("future")
[13:23:45.566]                       }
[13:23:45.566]                       else {
[13:23:45.566]                         version <- NULL
[13:23:45.566]                       }
[13:23:45.566]                       if (!has_future || version < "1.8.0") {
[13:23:45.566]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.566]                           "", base::R.version$version.string), 
[13:23:45.566]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.566]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.566]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.566]                             "release", "version")], collapse = " "), 
[13:23:45.566]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.566]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.566]                           info)
[13:23:45.566]                         info <- base::paste(info, collapse = "; ")
[13:23:45.566]                         if (!has_future) {
[13:23:45.566]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.566]                             info)
[13:23:45.566]                         }
[13:23:45.566]                         else {
[13:23:45.566]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.566]                             info, version)
[13:23:45.566]                         }
[13:23:45.566]                         base::stop(msg)
[13:23:45.566]                       }
[13:23:45.566]                     })
[13:23:45.566]                   }
[13:23:45.566]                   options(future.plan = NULL)
[13:23:45.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.566]                 }
[13:23:45.566]                 ...future.workdir <- getwd()
[13:23:45.566]             }
[13:23:45.566]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.566]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.566]         }
[13:23:45.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.566]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.566]             base::names(...future.oldOptions))
[13:23:45.566]     }
[13:23:45.566]     if (FALSE) {
[13:23:45.566]     }
[13:23:45.566]     else {
[13:23:45.566]         if (TRUE) {
[13:23:45.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.566]                 open = "w")
[13:23:45.566]         }
[13:23:45.566]         else {
[13:23:45.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.566]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.566]         }
[13:23:45.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.566]             base::sink(type = "output", split = FALSE)
[13:23:45.566]             base::close(...future.stdout)
[13:23:45.566]         }, add = TRUE)
[13:23:45.566]     }
[13:23:45.566]     ...future.frame <- base::sys.nframe()
[13:23:45.566]     ...future.conditions <- base::list()
[13:23:45.566]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.566]     if (FALSE) {
[13:23:45.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.566]     }
[13:23:45.566]     ...future.result <- base::tryCatch({
[13:23:45.566]         base::withCallingHandlers({
[13:23:45.566]             ...future.value <- base::withVisible(base::local({
[13:23:45.566]                 stop(structure(list(message = "boom"), class = c("MyError", 
[13:23:45.566]                   "error", "condition")))
[13:23:45.566]             }))
[13:23:45.566]             future::FutureResult(value = ...future.value$value, 
[13:23:45.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.566]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.566]                     ...future.globalenv.names))
[13:23:45.566]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.566]         }, condition = base::local({
[13:23:45.566]             c <- base::c
[13:23:45.566]             inherits <- base::inherits
[13:23:45.566]             invokeRestart <- base::invokeRestart
[13:23:45.566]             length <- base::length
[13:23:45.566]             list <- base::list
[13:23:45.566]             seq.int <- base::seq.int
[13:23:45.566]             signalCondition <- base::signalCondition
[13:23:45.566]             sys.calls <- base::sys.calls
[13:23:45.566]             `[[` <- base::`[[`
[13:23:45.566]             `+` <- base::`+`
[13:23:45.566]             `<<-` <- base::`<<-`
[13:23:45.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.566]                   3L)]
[13:23:45.566]             }
[13:23:45.566]             function(cond) {
[13:23:45.566]                 is_error <- inherits(cond, "error")
[13:23:45.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.566]                   NULL)
[13:23:45.566]                 if (is_error) {
[13:23:45.566]                   sessionInformation <- function() {
[13:23:45.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.566]                       search = base::search(), system = base::Sys.info())
[13:23:45.566]                   }
[13:23:45.566]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.566]                     cond$call), session = sessionInformation(), 
[13:23:45.566]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.566]                   signalCondition(cond)
[13:23:45.566]                 }
[13:23:45.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.566]                 "immediateCondition"))) {
[13:23:45.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.566]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.566]                   if (TRUE && !signal) {
[13:23:45.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.566]                     {
[13:23:45.566]                       inherits <- base::inherits
[13:23:45.566]                       invokeRestart <- base::invokeRestart
[13:23:45.566]                       is.null <- base::is.null
[13:23:45.566]                       muffled <- FALSE
[13:23:45.566]                       if (inherits(cond, "message")) {
[13:23:45.566]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.566]                         if (muffled) 
[13:23:45.566]                           invokeRestart("muffleMessage")
[13:23:45.566]                       }
[13:23:45.566]                       else if (inherits(cond, "warning")) {
[13:23:45.566]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.566]                         if (muffled) 
[13:23:45.566]                           invokeRestart("muffleWarning")
[13:23:45.566]                       }
[13:23:45.566]                       else if (inherits(cond, "condition")) {
[13:23:45.566]                         if (!is.null(pattern)) {
[13:23:45.566]                           computeRestarts <- base::computeRestarts
[13:23:45.566]                           grepl <- base::grepl
[13:23:45.566]                           restarts <- computeRestarts(cond)
[13:23:45.566]                           for (restart in restarts) {
[13:23:45.566]                             name <- restart$name
[13:23:45.566]                             if (is.null(name)) 
[13:23:45.566]                               next
[13:23:45.566]                             if (!grepl(pattern, name)) 
[13:23:45.566]                               next
[13:23:45.566]                             invokeRestart(restart)
[13:23:45.566]                             muffled <- TRUE
[13:23:45.566]                             break
[13:23:45.566]                           }
[13:23:45.566]                         }
[13:23:45.566]                       }
[13:23:45.566]                       invisible(muffled)
[13:23:45.566]                     }
[13:23:45.566]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.566]                   }
[13:23:45.566]                 }
[13:23:45.566]                 else {
[13:23:45.566]                   if (TRUE) {
[13:23:45.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.566]                     {
[13:23:45.566]                       inherits <- base::inherits
[13:23:45.566]                       invokeRestart <- base::invokeRestart
[13:23:45.566]                       is.null <- base::is.null
[13:23:45.566]                       muffled <- FALSE
[13:23:45.566]                       if (inherits(cond, "message")) {
[13:23:45.566]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.566]                         if (muffled) 
[13:23:45.566]                           invokeRestart("muffleMessage")
[13:23:45.566]                       }
[13:23:45.566]                       else if (inherits(cond, "warning")) {
[13:23:45.566]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.566]                         if (muffled) 
[13:23:45.566]                           invokeRestart("muffleWarning")
[13:23:45.566]                       }
[13:23:45.566]                       else if (inherits(cond, "condition")) {
[13:23:45.566]                         if (!is.null(pattern)) {
[13:23:45.566]                           computeRestarts <- base::computeRestarts
[13:23:45.566]                           grepl <- base::grepl
[13:23:45.566]                           restarts <- computeRestarts(cond)
[13:23:45.566]                           for (restart in restarts) {
[13:23:45.566]                             name <- restart$name
[13:23:45.566]                             if (is.null(name)) 
[13:23:45.566]                               next
[13:23:45.566]                             if (!grepl(pattern, name)) 
[13:23:45.566]                               next
[13:23:45.566]                             invokeRestart(restart)
[13:23:45.566]                             muffled <- TRUE
[13:23:45.566]                             break
[13:23:45.566]                           }
[13:23:45.566]                         }
[13:23:45.566]                       }
[13:23:45.566]                       invisible(muffled)
[13:23:45.566]                     }
[13:23:45.566]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.566]                   }
[13:23:45.566]                 }
[13:23:45.566]             }
[13:23:45.566]         }))
[13:23:45.566]     }, error = function(ex) {
[13:23:45.566]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.566]                 ...future.rng), started = ...future.startTime, 
[13:23:45.566]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.566]             version = "1.8"), class = "FutureResult")
[13:23:45.566]     }, finally = {
[13:23:45.566]         if (!identical(...future.workdir, getwd())) 
[13:23:45.566]             setwd(...future.workdir)
[13:23:45.566]         {
[13:23:45.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.566]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.566]             }
[13:23:45.566]             base::options(...future.oldOptions)
[13:23:45.566]             if (.Platform$OS.type == "windows") {
[13:23:45.566]                 old_names <- names(...future.oldEnvVars)
[13:23:45.566]                 envs <- base::Sys.getenv()
[13:23:45.566]                 names <- names(envs)
[13:23:45.566]                 common <- intersect(names, old_names)
[13:23:45.566]                 added <- setdiff(names, old_names)
[13:23:45.566]                 removed <- setdiff(old_names, names)
[13:23:45.566]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.566]                   envs[common]]
[13:23:45.566]                 NAMES <- toupper(changed)
[13:23:45.566]                 args <- list()
[13:23:45.566]                 for (kk in seq_along(NAMES)) {
[13:23:45.566]                   name <- changed[[kk]]
[13:23:45.566]                   NAME <- NAMES[[kk]]
[13:23:45.566]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.566]                     next
[13:23:45.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.566]                 }
[13:23:45.566]                 NAMES <- toupper(added)
[13:23:45.566]                 for (kk in seq_along(NAMES)) {
[13:23:45.566]                   name <- added[[kk]]
[13:23:45.566]                   NAME <- NAMES[[kk]]
[13:23:45.566]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.566]                     next
[13:23:45.566]                   args[[name]] <- ""
[13:23:45.566]                 }
[13:23:45.566]                 NAMES <- toupper(removed)
[13:23:45.566]                 for (kk in seq_along(NAMES)) {
[13:23:45.566]                   name <- removed[[kk]]
[13:23:45.566]                   NAME <- NAMES[[kk]]
[13:23:45.566]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.566]                     next
[13:23:45.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.566]                 }
[13:23:45.566]                 if (length(args) > 0) 
[13:23:45.566]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.566]             }
[13:23:45.566]             else {
[13:23:45.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.566]             }
[13:23:45.566]             {
[13:23:45.566]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.566]                   0L) {
[13:23:45.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.566]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.566]                   base::options(opts)
[13:23:45.566]                 }
[13:23:45.566]                 {
[13:23:45.566]                   {
[13:23:45.566]                     NULL
[13:23:45.566]                     RNGkind("Mersenne-Twister")
[13:23:45.566]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.566]                       inherits = FALSE)
[13:23:45.566]                   }
[13:23:45.566]                   options(future.plan = NULL)
[13:23:45.566]                   if (is.na(NA_character_)) 
[13:23:45.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.566]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.566]                     envir = parent.frame()) 
[13:23:45.566]                   {
[13:23:45.566]                     default_workers <- missing(workers)
[13:23:45.566]                     if (is.function(workers)) 
[13:23:45.566]                       workers <- workers()
[13:23:45.566]                     workers <- structure(as.integer(workers), 
[13:23:45.566]                       class = class(workers))
[13:23:45.566]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.566]                       1L)
[13:23:45.566]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.566]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.566]                       if (default_workers) 
[13:23:45.566]                         supportsMulticore(warn = TRUE)
[13:23:45.566]                       return(sequential(..., envir = envir))
[13:23:45.566]                     }
[13:23:45.566]                     oopts <- options(mc.cores = workers)
[13:23:45.566]                     on.exit(options(oopts))
[13:23:45.566]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.566]                       envir = envir)
[13:23:45.566]                     if (!future$lazy) 
[13:23:45.566]                       future <- run(future)
[13:23:45.566]                     invisible(future)
[13:23:45.566]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.566]                 }
[13:23:45.566]             }
[13:23:45.566]         }
[13:23:45.566]     })
[13:23:45.566]     if (TRUE) {
[13:23:45.566]         base::sink(type = "output", split = FALSE)
[13:23:45.566]         if (TRUE) {
[13:23:45.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.566]         }
[13:23:45.566]         else {
[13:23:45.566]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.566]         }
[13:23:45.566]         base::close(...future.stdout)
[13:23:45.566]         ...future.stdout <- NULL
[13:23:45.566]     }
[13:23:45.566]     ...future.result$conditions <- ...future.conditions
[13:23:45.566]     ...future.result$finished <- base::Sys.time()
[13:23:45.566]     ...future.result
[13:23:45.566] }
[13:23:45.568] plan(): Setting new future strategy stack:
[13:23:45.568] List of future strategies:
[13:23:45.568] 1. sequential:
[13:23:45.568]    - args: function (..., envir = parent.frame())
[13:23:45.568]    - tweaked: FALSE
[13:23:45.568]    - call: NULL
[13:23:45.569] plan(): nbrOfWorkers() = 1
[13:23:45.569] plan(): Setting new future strategy stack:
[13:23:45.570] List of future strategies:
[13:23:45.570] 1. multicore:
[13:23:45.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.570]    - tweaked: FALSE
[13:23:45.570]    - call: plan(multicore)
[13:23:45.573] plan(): nbrOfWorkers() = 1
[13:23:45.573] SequentialFuture started (and completed)
[13:23:45.573] signalConditions() ...
[13:23:45.574]  - include = ‘immediateCondition’
[13:23:45.574]  - exclude = 
[13:23:45.574]  - resignal = FALSE
[13:23:45.574]  - Number of conditions: 1
[13:23:45.574] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 0 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:23:45.575] signalConditions() ...
[13:23:45.575]  - include = ‘immediateCondition’
[13:23:45.575]  - exclude = 
[13:23:45.575]  - resignal = FALSE
[13:23:45.575]  - Number of conditions: 1
[13:23:45.575] signalConditions() ... done
<MyError: boom>
[13:23:45.575] signalConditions() ...
[13:23:45.575]  - include = ‘immediateCondition’
[13:23:45.575]  - exclude = 
[13:23:45.575]  - resignal = FALSE
[13:23:45.576]  - Number of conditions: 1
[13:23:45.576] signalConditions() ... done
[13:23:45.576] Future state: ‘finished’
[13:23:45.576] signalConditions() ...
[13:23:45.576]  - include = ‘condition’
[13:23:45.576]  - exclude = ‘immediateCondition’
[13:23:45.576]  - resignal = TRUE
[13:23:45.576]  - Number of conditions: 1
[13:23:45.576]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:23:45.577] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[13:23:45.577] getGlobalsAndPackages() ...
[13:23:45.577] Searching for globals...
[13:23:45.578] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[13:23:45.578] Searching for globals ... DONE
[13:23:45.578] Resolving globals: FALSE
[13:23:45.578] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:45.579] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[13:23:45.579] - globals: [2] ‘a’, ‘b’
[13:23:45.579] 
[13:23:45.579] getGlobalsAndPackages() ... DONE
[13:23:45.580] Packages needed by the future expression (n = 0): <none>
[13:23:45.580] Packages needed by future strategies (n = 0): <none>
[13:23:45.580] {
[13:23:45.580]     {
[13:23:45.580]         {
[13:23:45.580]             ...future.startTime <- base::Sys.time()
[13:23:45.580]             {
[13:23:45.580]                 {
[13:23:45.580]                   {
[13:23:45.580]                     base::local({
[13:23:45.580]                       has_future <- base::requireNamespace("future", 
[13:23:45.580]                         quietly = TRUE)
[13:23:45.580]                       if (has_future) {
[13:23:45.580]                         ns <- base::getNamespace("future")
[13:23:45.580]                         version <- ns[[".package"]][["version"]]
[13:23:45.580]                         if (is.null(version)) 
[13:23:45.580]                           version <- utils::packageVersion("future")
[13:23:45.580]                       }
[13:23:45.580]                       else {
[13:23:45.580]                         version <- NULL
[13:23:45.580]                       }
[13:23:45.580]                       if (!has_future || version < "1.8.0") {
[13:23:45.580]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.580]                           "", base::R.version$version.string), 
[13:23:45.580]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:45.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.580]                             "release", "version")], collapse = " "), 
[13:23:45.580]                           hostname = base::Sys.info()[["nodename"]])
[13:23:45.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.580]                           info)
[13:23:45.580]                         info <- base::paste(info, collapse = "; ")
[13:23:45.580]                         if (!has_future) {
[13:23:45.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.580]                             info)
[13:23:45.580]                         }
[13:23:45.580]                         else {
[13:23:45.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.580]                             info, version)
[13:23:45.580]                         }
[13:23:45.580]                         base::stop(msg)
[13:23:45.580]                       }
[13:23:45.580]                     })
[13:23:45.580]                   }
[13:23:45.580]                   options(future.plan = NULL)
[13:23:45.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.580]                 }
[13:23:45.580]                 ...future.workdir <- getwd()
[13:23:45.580]             }
[13:23:45.580]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.580]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.580]         }
[13:23:45.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.580]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.580]             base::names(...future.oldOptions))
[13:23:45.580]     }
[13:23:45.580]     if (FALSE) {
[13:23:45.580]     }
[13:23:45.580]     else {
[13:23:45.580]         if (TRUE) {
[13:23:45.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.580]                 open = "w")
[13:23:45.580]         }
[13:23:45.580]         else {
[13:23:45.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.580]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.580]         }
[13:23:45.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.580]             base::sink(type = "output", split = FALSE)
[13:23:45.580]             base::close(...future.stdout)
[13:23:45.580]         }, add = TRUE)
[13:23:45.580]     }
[13:23:45.580]     ...future.frame <- base::sys.nframe()
[13:23:45.580]     ...future.conditions <- base::list()
[13:23:45.580]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.580]     if (FALSE) {
[13:23:45.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.580]     }
[13:23:45.580]     ...future.result <- base::tryCatch({
[13:23:45.580]         base::withCallingHandlers({
[13:23:45.580]             ...future.value <- base::withVisible(base::local({
[13:23:45.580]                 a * b
[13:23:45.580]             }))
[13:23:45.580]             future::FutureResult(value = ...future.value$value, 
[13:23:45.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.580]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.580]                     ...future.globalenv.names))
[13:23:45.580]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.580]         }, condition = base::local({
[13:23:45.580]             c <- base::c
[13:23:45.580]             inherits <- base::inherits
[13:23:45.580]             invokeRestart <- base::invokeRestart
[13:23:45.580]             length <- base::length
[13:23:45.580]             list <- base::list
[13:23:45.580]             seq.int <- base::seq.int
[13:23:45.580]             signalCondition <- base::signalCondition
[13:23:45.580]             sys.calls <- base::sys.calls
[13:23:45.580]             `[[` <- base::`[[`
[13:23:45.580]             `+` <- base::`+`
[13:23:45.580]             `<<-` <- base::`<<-`
[13:23:45.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.580]                   3L)]
[13:23:45.580]             }
[13:23:45.580]             function(cond) {
[13:23:45.580]                 is_error <- inherits(cond, "error")
[13:23:45.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.580]                   NULL)
[13:23:45.580]                 if (is_error) {
[13:23:45.580]                   sessionInformation <- function() {
[13:23:45.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.580]                       search = base::search(), system = base::Sys.info())
[13:23:45.580]                   }
[13:23:45.580]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.580]                     cond$call), session = sessionInformation(), 
[13:23:45.580]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.580]                   signalCondition(cond)
[13:23:45.580]                 }
[13:23:45.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.580]                 "immediateCondition"))) {
[13:23:45.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.580]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.580]                   if (TRUE && !signal) {
[13:23:45.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.580]                     {
[13:23:45.580]                       inherits <- base::inherits
[13:23:45.580]                       invokeRestart <- base::invokeRestart
[13:23:45.580]                       is.null <- base::is.null
[13:23:45.580]                       muffled <- FALSE
[13:23:45.580]                       if (inherits(cond, "message")) {
[13:23:45.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.580]                         if (muffled) 
[13:23:45.580]                           invokeRestart("muffleMessage")
[13:23:45.580]                       }
[13:23:45.580]                       else if (inherits(cond, "warning")) {
[13:23:45.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.580]                         if (muffled) 
[13:23:45.580]                           invokeRestart("muffleWarning")
[13:23:45.580]                       }
[13:23:45.580]                       else if (inherits(cond, "condition")) {
[13:23:45.580]                         if (!is.null(pattern)) {
[13:23:45.580]                           computeRestarts <- base::computeRestarts
[13:23:45.580]                           grepl <- base::grepl
[13:23:45.580]                           restarts <- computeRestarts(cond)
[13:23:45.580]                           for (restart in restarts) {
[13:23:45.580]                             name <- restart$name
[13:23:45.580]                             if (is.null(name)) 
[13:23:45.580]                               next
[13:23:45.580]                             if (!grepl(pattern, name)) 
[13:23:45.580]                               next
[13:23:45.580]                             invokeRestart(restart)
[13:23:45.580]                             muffled <- TRUE
[13:23:45.580]                             break
[13:23:45.580]                           }
[13:23:45.580]                         }
[13:23:45.580]                       }
[13:23:45.580]                       invisible(muffled)
[13:23:45.580]                     }
[13:23:45.580]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.580]                   }
[13:23:45.580]                 }
[13:23:45.580]                 else {
[13:23:45.580]                   if (TRUE) {
[13:23:45.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.580]                     {
[13:23:45.580]                       inherits <- base::inherits
[13:23:45.580]                       invokeRestart <- base::invokeRestart
[13:23:45.580]                       is.null <- base::is.null
[13:23:45.580]                       muffled <- FALSE
[13:23:45.580]                       if (inherits(cond, "message")) {
[13:23:45.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.580]                         if (muffled) 
[13:23:45.580]                           invokeRestart("muffleMessage")
[13:23:45.580]                       }
[13:23:45.580]                       else if (inherits(cond, "warning")) {
[13:23:45.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.580]                         if (muffled) 
[13:23:45.580]                           invokeRestart("muffleWarning")
[13:23:45.580]                       }
[13:23:45.580]                       else if (inherits(cond, "condition")) {
[13:23:45.580]                         if (!is.null(pattern)) {
[13:23:45.580]                           computeRestarts <- base::computeRestarts
[13:23:45.580]                           grepl <- base::grepl
[13:23:45.580]                           restarts <- computeRestarts(cond)
[13:23:45.580]                           for (restart in restarts) {
[13:23:45.580]                             name <- restart$name
[13:23:45.580]                             if (is.null(name)) 
[13:23:45.580]                               next
[13:23:45.580]                             if (!grepl(pattern, name)) 
[13:23:45.580]                               next
[13:23:45.580]                             invokeRestart(restart)
[13:23:45.580]                             muffled <- TRUE
[13:23:45.580]                             break
[13:23:45.580]                           }
[13:23:45.580]                         }
[13:23:45.580]                       }
[13:23:45.580]                       invisible(muffled)
[13:23:45.580]                     }
[13:23:45.580]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.580]                   }
[13:23:45.580]                 }
[13:23:45.580]             }
[13:23:45.580]         }))
[13:23:45.580]     }, error = function(ex) {
[13:23:45.580]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.580]                 ...future.rng), started = ...future.startTime, 
[13:23:45.580]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.580]             version = "1.8"), class = "FutureResult")
[13:23:45.580]     }, finally = {
[13:23:45.580]         if (!identical(...future.workdir, getwd())) 
[13:23:45.580]             setwd(...future.workdir)
[13:23:45.580]         {
[13:23:45.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.580]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.580]             }
[13:23:45.580]             base::options(...future.oldOptions)
[13:23:45.580]             if (.Platform$OS.type == "windows") {
[13:23:45.580]                 old_names <- names(...future.oldEnvVars)
[13:23:45.580]                 envs <- base::Sys.getenv()
[13:23:45.580]                 names <- names(envs)
[13:23:45.580]                 common <- intersect(names, old_names)
[13:23:45.580]                 added <- setdiff(names, old_names)
[13:23:45.580]                 removed <- setdiff(old_names, names)
[13:23:45.580]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.580]                   envs[common]]
[13:23:45.580]                 NAMES <- toupper(changed)
[13:23:45.580]                 args <- list()
[13:23:45.580]                 for (kk in seq_along(NAMES)) {
[13:23:45.580]                   name <- changed[[kk]]
[13:23:45.580]                   NAME <- NAMES[[kk]]
[13:23:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.580]                     next
[13:23:45.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.580]                 }
[13:23:45.580]                 NAMES <- toupper(added)
[13:23:45.580]                 for (kk in seq_along(NAMES)) {
[13:23:45.580]                   name <- added[[kk]]
[13:23:45.580]                   NAME <- NAMES[[kk]]
[13:23:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.580]                     next
[13:23:45.580]                   args[[name]] <- ""
[13:23:45.580]                 }
[13:23:45.580]                 NAMES <- toupper(removed)
[13:23:45.580]                 for (kk in seq_along(NAMES)) {
[13:23:45.580]                   name <- removed[[kk]]
[13:23:45.580]                   NAME <- NAMES[[kk]]
[13:23:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.580]                     next
[13:23:45.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.580]                 }
[13:23:45.580]                 if (length(args) > 0) 
[13:23:45.580]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.580]             }
[13:23:45.580]             else {
[13:23:45.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.580]             }
[13:23:45.580]             {
[13:23:45.580]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.580]                   0L) {
[13:23:45.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.580]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.580]                   base::options(opts)
[13:23:45.580]                 }
[13:23:45.580]                 {
[13:23:45.580]                   {
[13:23:45.580]                     NULL
[13:23:45.580]                     RNGkind("Mersenne-Twister")
[13:23:45.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:45.580]                       inherits = FALSE)
[13:23:45.580]                   }
[13:23:45.580]                   options(future.plan = NULL)
[13:23:45.580]                   if (is.na(NA_character_)) 
[13:23:45.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.580]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.580]                     envir = parent.frame()) 
[13:23:45.580]                   {
[13:23:45.580]                     default_workers <- missing(workers)
[13:23:45.580]                     if (is.function(workers)) 
[13:23:45.580]                       workers <- workers()
[13:23:45.580]                     workers <- structure(as.integer(workers), 
[13:23:45.580]                       class = class(workers))
[13:23:45.580]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.580]                       1L)
[13:23:45.580]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.580]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.580]                       if (default_workers) 
[13:23:45.580]                         supportsMulticore(warn = TRUE)
[13:23:45.580]                       return(sequential(..., envir = envir))
[13:23:45.580]                     }
[13:23:45.580]                     oopts <- options(mc.cores = workers)
[13:23:45.580]                     on.exit(options(oopts))
[13:23:45.580]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.580]                       envir = envir)
[13:23:45.580]                     if (!future$lazy) 
[13:23:45.580]                       future <- run(future)
[13:23:45.580]                     invisible(future)
[13:23:45.580]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.580]                 }
[13:23:45.580]             }
[13:23:45.580]         }
[13:23:45.580]     })
[13:23:45.580]     if (TRUE) {
[13:23:45.580]         base::sink(type = "output", split = FALSE)
[13:23:45.580]         if (TRUE) {
[13:23:45.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.580]         }
[13:23:45.580]         else {
[13:23:45.580]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.580]         }
[13:23:45.580]         base::close(...future.stdout)
[13:23:45.580]         ...future.stdout <- NULL
[13:23:45.580]     }
[13:23:45.580]     ...future.result$conditions <- ...future.conditions
[13:23:45.580]     ...future.result$finished <- base::Sys.time()
[13:23:45.580]     ...future.result
[13:23:45.580] }
[13:23:45.582] assign_globals() ...
[13:23:45.582] List of 2
[13:23:45.582]  $ a: num 2
[13:23:45.582]  $ b: num 3
[13:23:45.582]  - attr(*, "where")=List of 2
[13:23:45.582]   ..$ a:<environment: R_EmptyEnv> 
[13:23:45.582]   ..$ b:<environment: R_EmptyEnv> 
[13:23:45.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.582]  - attr(*, "resolved")= logi FALSE
[13:23:45.582]  - attr(*, "total_size")= num 112
[13:23:45.585] - copied ‘a’ to environment
[13:23:45.585] - copied ‘b’ to environment
[13:23:45.585] assign_globals() ... done
[13:23:45.585] plan(): Setting new future strategy stack:
[13:23:45.585] List of future strategies:
[13:23:45.585] 1. sequential:
[13:23:45.585]    - args: function (..., envir = parent.frame())
[13:23:45.585]    - tweaked: FALSE
[13:23:45.585]    - call: NULL
[13:23:45.586] plan(): nbrOfWorkers() = 1
[13:23:45.587] plan(): Setting new future strategy stack:
[13:23:45.587] List of future strategies:
[13:23:45.587] 1. multicore:
[13:23:45.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.587]    - tweaked: FALSE
[13:23:45.587]    - call: plan(multicore)
[13:23:45.590] plan(): nbrOfWorkers() = 1
[13:23:45.591] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[13:23:45.599] getGlobalsAndPackages() ...
[13:23:45.600] Not searching for globals
[13:23:45.600] - globals: [0] <none>
[13:23:45.600] getGlobalsAndPackages() ... DONE
[13:23:45.601] Packages needed by the future expression (n = 0): <none>
[13:23:45.601] Packages needed by future strategies (n = 0): <none>
[13:23:45.602] {
[13:23:45.602]     {
[13:23:45.602]         {
[13:23:45.602]             ...future.startTime <- base::Sys.time()
[13:23:45.602]             {
[13:23:45.602]                 {
[13:23:45.602]                   {
[13:23:45.602]                     {
[13:23:45.602]                       base::local({
[13:23:45.602]                         has_future <- base::requireNamespace("future", 
[13:23:45.602]                           quietly = TRUE)
[13:23:45.602]                         if (has_future) {
[13:23:45.602]                           ns <- base::getNamespace("future")
[13:23:45.602]                           version <- ns[[".package"]][["version"]]
[13:23:45.602]                           if (is.null(version)) 
[13:23:45.602]                             version <- utils::packageVersion("future")
[13:23:45.602]                         }
[13:23:45.602]                         else {
[13:23:45.602]                           version <- NULL
[13:23:45.602]                         }
[13:23:45.602]                         if (!has_future || version < "1.8.0") {
[13:23:45.602]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.602]                             "", base::R.version$version.string), 
[13:23:45.602]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.602]                               "release", "version")], collapse = " "), 
[13:23:45.602]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.602]                             info)
[13:23:45.602]                           info <- base::paste(info, collapse = "; ")
[13:23:45.602]                           if (!has_future) {
[13:23:45.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.602]                               info)
[13:23:45.602]                           }
[13:23:45.602]                           else {
[13:23:45.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.602]                               info, version)
[13:23:45.602]                           }
[13:23:45.602]                           base::stop(msg)
[13:23:45.602]                         }
[13:23:45.602]                       })
[13:23:45.602]                     }
[13:23:45.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.602]                     base::options(mc.cores = 1L)
[13:23:45.602]                   }
[13:23:45.602]                   options(future.plan = NULL)
[13:23:45.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.602]                 }
[13:23:45.602]                 ...future.workdir <- getwd()
[13:23:45.602]             }
[13:23:45.602]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.602]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.602]         }
[13:23:45.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.602]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.602]             base::names(...future.oldOptions))
[13:23:45.602]     }
[13:23:45.602]     if (FALSE) {
[13:23:45.602]     }
[13:23:45.602]     else {
[13:23:45.602]         if (TRUE) {
[13:23:45.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.602]                 open = "w")
[13:23:45.602]         }
[13:23:45.602]         else {
[13:23:45.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.602]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.602]         }
[13:23:45.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.602]             base::sink(type = "output", split = FALSE)
[13:23:45.602]             base::close(...future.stdout)
[13:23:45.602]         }, add = TRUE)
[13:23:45.602]     }
[13:23:45.602]     ...future.frame <- base::sys.nframe()
[13:23:45.602]     ...future.conditions <- base::list()
[13:23:45.602]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.602]     if (FALSE) {
[13:23:45.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.602]     }
[13:23:45.602]     ...future.result <- base::tryCatch({
[13:23:45.602]         base::withCallingHandlers({
[13:23:45.602]             ...future.value <- base::withVisible(base::local({
[13:23:45.602]                 withCallingHandlers({
[13:23:45.602]                   {
[13:23:45.602]                     42L
[13:23:45.602]                   }
[13:23:45.602]                 }, immediateCondition = function(cond) {
[13:23:45.602]                   save_rds <- function (object, pathname, ...) 
[13:23:45.602]                   {
[13:23:45.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.602]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.602]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.602]                         fi_tmp[["mtime"]])
[13:23:45.602]                     }
[13:23:45.602]                     tryCatch({
[13:23:45.602]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.602]                     }, error = function(ex) {
[13:23:45.602]                       msg <- conditionMessage(ex)
[13:23:45.602]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.602]                         fi_tmp[["mtime"]], msg)
[13:23:45.602]                       ex$message <- msg
[13:23:45.602]                       stop(ex)
[13:23:45.602]                     })
[13:23:45.602]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.602]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.602]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.602]                       fi <- file.info(pathname)
[13:23:45.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.602]                         fi[["size"]], fi[["mtime"]])
[13:23:45.602]                       stop(msg)
[13:23:45.602]                     }
[13:23:45.602]                     invisible(pathname)
[13:23:45.602]                   }
[13:23:45.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.602]                     rootPath = tempdir()) 
[13:23:45.602]                   {
[13:23:45.602]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.602]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.602]                       tmpdir = path, fileext = ".rds")
[13:23:45.602]                     save_rds(obj, file)
[13:23:45.602]                   }
[13:23:45.602]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.602]                   {
[13:23:45.602]                     inherits <- base::inherits
[13:23:45.602]                     invokeRestart <- base::invokeRestart
[13:23:45.602]                     is.null <- base::is.null
[13:23:45.602]                     muffled <- FALSE
[13:23:45.602]                     if (inherits(cond, "message")) {
[13:23:45.602]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.602]                       if (muffled) 
[13:23:45.602]                         invokeRestart("muffleMessage")
[13:23:45.602]                     }
[13:23:45.602]                     else if (inherits(cond, "warning")) {
[13:23:45.602]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.602]                       if (muffled) 
[13:23:45.602]                         invokeRestart("muffleWarning")
[13:23:45.602]                     }
[13:23:45.602]                     else if (inherits(cond, "condition")) {
[13:23:45.602]                       if (!is.null(pattern)) {
[13:23:45.602]                         computeRestarts <- base::computeRestarts
[13:23:45.602]                         grepl <- base::grepl
[13:23:45.602]                         restarts <- computeRestarts(cond)
[13:23:45.602]                         for (restart in restarts) {
[13:23:45.602]                           name <- restart$name
[13:23:45.602]                           if (is.null(name)) 
[13:23:45.602]                             next
[13:23:45.602]                           if (!grepl(pattern, name)) 
[13:23:45.602]                             next
[13:23:45.602]                           invokeRestart(restart)
[13:23:45.602]                           muffled <- TRUE
[13:23:45.602]                           break
[13:23:45.602]                         }
[13:23:45.602]                       }
[13:23:45.602]                     }
[13:23:45.602]                     invisible(muffled)
[13:23:45.602]                   }
[13:23:45.602]                   muffleCondition(cond)
[13:23:45.602]                 })
[13:23:45.602]             }))
[13:23:45.602]             future::FutureResult(value = ...future.value$value, 
[13:23:45.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.602]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.602]                     ...future.globalenv.names))
[13:23:45.602]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.602]         }, condition = base::local({
[13:23:45.602]             c <- base::c
[13:23:45.602]             inherits <- base::inherits
[13:23:45.602]             invokeRestart <- base::invokeRestart
[13:23:45.602]             length <- base::length
[13:23:45.602]             list <- base::list
[13:23:45.602]             seq.int <- base::seq.int
[13:23:45.602]             signalCondition <- base::signalCondition
[13:23:45.602]             sys.calls <- base::sys.calls
[13:23:45.602]             `[[` <- base::`[[`
[13:23:45.602]             `+` <- base::`+`
[13:23:45.602]             `<<-` <- base::`<<-`
[13:23:45.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.602]                   3L)]
[13:23:45.602]             }
[13:23:45.602]             function(cond) {
[13:23:45.602]                 is_error <- inherits(cond, "error")
[13:23:45.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.602]                   NULL)
[13:23:45.602]                 if (is_error) {
[13:23:45.602]                   sessionInformation <- function() {
[13:23:45.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.602]                       search = base::search(), system = base::Sys.info())
[13:23:45.602]                   }
[13:23:45.602]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.602]                     cond$call), session = sessionInformation(), 
[13:23:45.602]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.602]                   signalCondition(cond)
[13:23:45.602]                 }
[13:23:45.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.602]                 "immediateCondition"))) {
[13:23:45.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.602]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.602]                   if (TRUE && !signal) {
[13:23:45.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.602]                     {
[13:23:45.602]                       inherits <- base::inherits
[13:23:45.602]                       invokeRestart <- base::invokeRestart
[13:23:45.602]                       is.null <- base::is.null
[13:23:45.602]                       muffled <- FALSE
[13:23:45.602]                       if (inherits(cond, "message")) {
[13:23:45.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.602]                         if (muffled) 
[13:23:45.602]                           invokeRestart("muffleMessage")
[13:23:45.602]                       }
[13:23:45.602]                       else if (inherits(cond, "warning")) {
[13:23:45.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.602]                         if (muffled) 
[13:23:45.602]                           invokeRestart("muffleWarning")
[13:23:45.602]                       }
[13:23:45.602]                       else if (inherits(cond, "condition")) {
[13:23:45.602]                         if (!is.null(pattern)) {
[13:23:45.602]                           computeRestarts <- base::computeRestarts
[13:23:45.602]                           grepl <- base::grepl
[13:23:45.602]                           restarts <- computeRestarts(cond)
[13:23:45.602]                           for (restart in restarts) {
[13:23:45.602]                             name <- restart$name
[13:23:45.602]                             if (is.null(name)) 
[13:23:45.602]                               next
[13:23:45.602]                             if (!grepl(pattern, name)) 
[13:23:45.602]                               next
[13:23:45.602]                             invokeRestart(restart)
[13:23:45.602]                             muffled <- TRUE
[13:23:45.602]                             break
[13:23:45.602]                           }
[13:23:45.602]                         }
[13:23:45.602]                       }
[13:23:45.602]                       invisible(muffled)
[13:23:45.602]                     }
[13:23:45.602]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.602]                   }
[13:23:45.602]                 }
[13:23:45.602]                 else {
[13:23:45.602]                   if (TRUE) {
[13:23:45.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.602]                     {
[13:23:45.602]                       inherits <- base::inherits
[13:23:45.602]                       invokeRestart <- base::invokeRestart
[13:23:45.602]                       is.null <- base::is.null
[13:23:45.602]                       muffled <- FALSE
[13:23:45.602]                       if (inherits(cond, "message")) {
[13:23:45.602]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.602]                         if (muffled) 
[13:23:45.602]                           invokeRestart("muffleMessage")
[13:23:45.602]                       }
[13:23:45.602]                       else if (inherits(cond, "warning")) {
[13:23:45.602]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.602]                         if (muffled) 
[13:23:45.602]                           invokeRestart("muffleWarning")
[13:23:45.602]                       }
[13:23:45.602]                       else if (inherits(cond, "condition")) {
[13:23:45.602]                         if (!is.null(pattern)) {
[13:23:45.602]                           computeRestarts <- base::computeRestarts
[13:23:45.602]                           grepl <- base::grepl
[13:23:45.602]                           restarts <- computeRestarts(cond)
[13:23:45.602]                           for (restart in restarts) {
[13:23:45.602]                             name <- restart$name
[13:23:45.602]                             if (is.null(name)) 
[13:23:45.602]                               next
[13:23:45.602]                             if (!grepl(pattern, name)) 
[13:23:45.602]                               next
[13:23:45.602]                             invokeRestart(restart)
[13:23:45.602]                             muffled <- TRUE
[13:23:45.602]                             break
[13:23:45.602]                           }
[13:23:45.602]                         }
[13:23:45.602]                       }
[13:23:45.602]                       invisible(muffled)
[13:23:45.602]                     }
[13:23:45.602]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.602]                   }
[13:23:45.602]                 }
[13:23:45.602]             }
[13:23:45.602]         }))
[13:23:45.602]     }, error = function(ex) {
[13:23:45.602]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.602]                 ...future.rng), started = ...future.startTime, 
[13:23:45.602]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.602]             version = "1.8"), class = "FutureResult")
[13:23:45.602]     }, finally = {
[13:23:45.602]         if (!identical(...future.workdir, getwd())) 
[13:23:45.602]             setwd(...future.workdir)
[13:23:45.602]         {
[13:23:45.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.602]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.602]             }
[13:23:45.602]             base::options(...future.oldOptions)
[13:23:45.602]             if (.Platform$OS.type == "windows") {
[13:23:45.602]                 old_names <- names(...future.oldEnvVars)
[13:23:45.602]                 envs <- base::Sys.getenv()
[13:23:45.602]                 names <- names(envs)
[13:23:45.602]                 common <- intersect(names, old_names)
[13:23:45.602]                 added <- setdiff(names, old_names)
[13:23:45.602]                 removed <- setdiff(old_names, names)
[13:23:45.602]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.602]                   envs[common]]
[13:23:45.602]                 NAMES <- toupper(changed)
[13:23:45.602]                 args <- list()
[13:23:45.602]                 for (kk in seq_along(NAMES)) {
[13:23:45.602]                   name <- changed[[kk]]
[13:23:45.602]                   NAME <- NAMES[[kk]]
[13:23:45.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.602]                     next
[13:23:45.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.602]                 }
[13:23:45.602]                 NAMES <- toupper(added)
[13:23:45.602]                 for (kk in seq_along(NAMES)) {
[13:23:45.602]                   name <- added[[kk]]
[13:23:45.602]                   NAME <- NAMES[[kk]]
[13:23:45.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.602]                     next
[13:23:45.602]                   args[[name]] <- ""
[13:23:45.602]                 }
[13:23:45.602]                 NAMES <- toupper(removed)
[13:23:45.602]                 for (kk in seq_along(NAMES)) {
[13:23:45.602]                   name <- removed[[kk]]
[13:23:45.602]                   NAME <- NAMES[[kk]]
[13:23:45.602]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.602]                     next
[13:23:45.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.602]                 }
[13:23:45.602]                 if (length(args) > 0) 
[13:23:45.602]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.602]             }
[13:23:45.602]             else {
[13:23:45.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.602]             }
[13:23:45.602]             {
[13:23:45.602]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.602]                   0L) {
[13:23:45.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.602]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.602]                   base::options(opts)
[13:23:45.602]                 }
[13:23:45.602]                 {
[13:23:45.602]                   {
[13:23:45.602]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.602]                     NULL
[13:23:45.602]                   }
[13:23:45.602]                   options(future.plan = NULL)
[13:23:45.602]                   if (is.na(NA_character_)) 
[13:23:45.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.602]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.602]                     envir = parent.frame()) 
[13:23:45.602]                   {
[13:23:45.602]                     default_workers <- missing(workers)
[13:23:45.602]                     if (is.function(workers)) 
[13:23:45.602]                       workers <- workers()
[13:23:45.602]                     workers <- structure(as.integer(workers), 
[13:23:45.602]                       class = class(workers))
[13:23:45.602]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.602]                       1L)
[13:23:45.602]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.602]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.602]                       if (default_workers) 
[13:23:45.602]                         supportsMulticore(warn = TRUE)
[13:23:45.602]                       return(sequential(..., envir = envir))
[13:23:45.602]                     }
[13:23:45.602]                     oopts <- options(mc.cores = workers)
[13:23:45.602]                     on.exit(options(oopts))
[13:23:45.602]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.602]                       envir = envir)
[13:23:45.602]                     if (!future$lazy) 
[13:23:45.602]                       future <- run(future)
[13:23:45.602]                     invisible(future)
[13:23:45.602]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.602]                 }
[13:23:45.602]             }
[13:23:45.602]         }
[13:23:45.602]     })
[13:23:45.602]     if (TRUE) {
[13:23:45.602]         base::sink(type = "output", split = FALSE)
[13:23:45.602]         if (TRUE) {
[13:23:45.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.602]         }
[13:23:45.602]         else {
[13:23:45.602]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.602]         }
[13:23:45.602]         base::close(...future.stdout)
[13:23:45.602]         ...future.stdout <- NULL
[13:23:45.602]     }
[13:23:45.602]     ...future.result$conditions <- ...future.conditions
[13:23:45.602]     ...future.result$finished <- base::Sys.time()
[13:23:45.602]     ...future.result
[13:23:45.602] }
[13:23:45.604] requestCore(): workers = 2
[13:23:45.607] MulticoreFuture started
[13:23:45.608] plan(): Setting new future strategy stack:
[13:23:45.609] List of future strategies:
[13:23:45.609] 1. sequential:
[13:23:45.609]    - args: function (..., envir = parent.frame())
[13:23:45.609]    - tweaked: FALSE
[13:23:45.609]    - call: NULL
[13:23:45.609] plan(): nbrOfWorkers() = 1
[13:23:45.612] plan(): Setting new future strategy stack:
[13:23:45.612] List of future strategies:
[13:23:45.612] 1. multicore:
[13:23:45.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.612]    - tweaked: FALSE
[13:23:45.612]    - call: plan(multicore)
[13:23:45.618] plan(): nbrOfWorkers() = 2
[1] TRUE
[13:23:45.619] result() for MulticoreFuture ...
[13:23:45.625] result() for MulticoreFuture ...
[13:23:45.626] result() for MulticoreFuture ... done
[13:23:45.626] result() for MulticoreFuture ... done
[13:23:45.626] result() for MulticoreFuture ...
[13:23:45.626] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = FALSE) with globals
[13:23:45.630] getGlobalsAndPackages() ...
[13:23:45.630] Not searching for globals
[13:23:45.630] - globals: [0] <none>
[13:23:45.630] getGlobalsAndPackages() ... DONE
[13:23:45.631] Packages needed by the future expression (n = 0): <none>
[13:23:45.631] Packages needed by future strategies (n = 0): <none>
[13:23:45.632] {
[13:23:45.632]     {
[13:23:45.632]         {
[13:23:45.632]             ...future.startTime <- base::Sys.time()
[13:23:45.632]             {
[13:23:45.632]                 {
[13:23:45.632]                   {
[13:23:45.632]                     {
[13:23:45.632]                       base::local({
[13:23:45.632]                         has_future <- base::requireNamespace("future", 
[13:23:45.632]                           quietly = TRUE)
[13:23:45.632]                         if (has_future) {
[13:23:45.632]                           ns <- base::getNamespace("future")
[13:23:45.632]                           version <- ns[[".package"]][["version"]]
[13:23:45.632]                           if (is.null(version)) 
[13:23:45.632]                             version <- utils::packageVersion("future")
[13:23:45.632]                         }
[13:23:45.632]                         else {
[13:23:45.632]                           version <- NULL
[13:23:45.632]                         }
[13:23:45.632]                         if (!has_future || version < "1.8.0") {
[13:23:45.632]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.632]                             "", base::R.version$version.string), 
[13:23:45.632]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.632]                               "release", "version")], collapse = " "), 
[13:23:45.632]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.632]                             info)
[13:23:45.632]                           info <- base::paste(info, collapse = "; ")
[13:23:45.632]                           if (!has_future) {
[13:23:45.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.632]                               info)
[13:23:45.632]                           }
[13:23:45.632]                           else {
[13:23:45.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.632]                               info, version)
[13:23:45.632]                           }
[13:23:45.632]                           base::stop(msg)
[13:23:45.632]                         }
[13:23:45.632]                       })
[13:23:45.632]                     }
[13:23:45.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.632]                     base::options(mc.cores = 1L)
[13:23:45.632]                   }
[13:23:45.632]                   options(future.plan = NULL)
[13:23:45.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.632]                 }
[13:23:45.632]                 ...future.workdir <- getwd()
[13:23:45.632]             }
[13:23:45.632]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.632]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.632]         }
[13:23:45.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.632]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.632]             base::names(...future.oldOptions))
[13:23:45.632]     }
[13:23:45.632]     if (FALSE) {
[13:23:45.632]     }
[13:23:45.632]     else {
[13:23:45.632]         if (TRUE) {
[13:23:45.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.632]                 open = "w")
[13:23:45.632]         }
[13:23:45.632]         else {
[13:23:45.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.632]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.632]         }
[13:23:45.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.632]             base::sink(type = "output", split = FALSE)
[13:23:45.632]             base::close(...future.stdout)
[13:23:45.632]         }, add = TRUE)
[13:23:45.632]     }
[13:23:45.632]     ...future.frame <- base::sys.nframe()
[13:23:45.632]     ...future.conditions <- base::list()
[13:23:45.632]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.632]     if (FALSE) {
[13:23:45.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.632]     }
[13:23:45.632]     ...future.result <- base::tryCatch({
[13:23:45.632]         base::withCallingHandlers({
[13:23:45.632]             ...future.value <- base::withVisible(base::local({
[13:23:45.632]                 withCallingHandlers({
[13:23:45.632]                   {
[13:23:45.632]                     b <- 3
[13:23:45.632]                     c <- 2
[13:23:45.632]                     a * b * c
[13:23:45.632]                   }
[13:23:45.632]                 }, immediateCondition = function(cond) {
[13:23:45.632]                   save_rds <- function (object, pathname, ...) 
[13:23:45.632]                   {
[13:23:45.632]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.632]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.632]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.632]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.632]                         fi_tmp[["mtime"]])
[13:23:45.632]                     }
[13:23:45.632]                     tryCatch({
[13:23:45.632]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.632]                     }, error = function(ex) {
[13:23:45.632]                       msg <- conditionMessage(ex)
[13:23:45.632]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.632]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.632]                         fi_tmp[["mtime"]], msg)
[13:23:45.632]                       ex$message <- msg
[13:23:45.632]                       stop(ex)
[13:23:45.632]                     })
[13:23:45.632]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.632]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.632]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.632]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.632]                       fi <- file.info(pathname)
[13:23:45.632]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.632]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.632]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.632]                         fi[["size"]], fi[["mtime"]])
[13:23:45.632]                       stop(msg)
[13:23:45.632]                     }
[13:23:45.632]                     invisible(pathname)
[13:23:45.632]                   }
[13:23:45.632]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.632]                     rootPath = tempdir()) 
[13:23:45.632]                   {
[13:23:45.632]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.632]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.632]                       tmpdir = path, fileext = ".rds")
[13:23:45.632]                     save_rds(obj, file)
[13:23:45.632]                   }
[13:23:45.632]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.632]                   {
[13:23:45.632]                     inherits <- base::inherits
[13:23:45.632]                     invokeRestart <- base::invokeRestart
[13:23:45.632]                     is.null <- base::is.null
[13:23:45.632]                     muffled <- FALSE
[13:23:45.632]                     if (inherits(cond, "message")) {
[13:23:45.632]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.632]                       if (muffled) 
[13:23:45.632]                         invokeRestart("muffleMessage")
[13:23:45.632]                     }
[13:23:45.632]                     else if (inherits(cond, "warning")) {
[13:23:45.632]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.632]                       if (muffled) 
[13:23:45.632]                         invokeRestart("muffleWarning")
[13:23:45.632]                     }
[13:23:45.632]                     else if (inherits(cond, "condition")) {
[13:23:45.632]                       if (!is.null(pattern)) {
[13:23:45.632]                         computeRestarts <- base::computeRestarts
[13:23:45.632]                         grepl <- base::grepl
[13:23:45.632]                         restarts <- computeRestarts(cond)
[13:23:45.632]                         for (restart in restarts) {
[13:23:45.632]                           name <- restart$name
[13:23:45.632]                           if (is.null(name)) 
[13:23:45.632]                             next
[13:23:45.632]                           if (!grepl(pattern, name)) 
[13:23:45.632]                             next
[13:23:45.632]                           invokeRestart(restart)
[13:23:45.632]                           muffled <- TRUE
[13:23:45.632]                           break
[13:23:45.632]                         }
[13:23:45.632]                       }
[13:23:45.632]                     }
[13:23:45.632]                     invisible(muffled)
[13:23:45.632]                   }
[13:23:45.632]                   muffleCondition(cond)
[13:23:45.632]                 })
[13:23:45.632]             }))
[13:23:45.632]             future::FutureResult(value = ...future.value$value, 
[13:23:45.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.632]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.632]                     ...future.globalenv.names))
[13:23:45.632]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.632]         }, condition = base::local({
[13:23:45.632]             c <- base::c
[13:23:45.632]             inherits <- base::inherits
[13:23:45.632]             invokeRestart <- base::invokeRestart
[13:23:45.632]             length <- base::length
[13:23:45.632]             list <- base::list
[13:23:45.632]             seq.int <- base::seq.int
[13:23:45.632]             signalCondition <- base::signalCondition
[13:23:45.632]             sys.calls <- base::sys.calls
[13:23:45.632]             `[[` <- base::`[[`
[13:23:45.632]             `+` <- base::`+`
[13:23:45.632]             `<<-` <- base::`<<-`
[13:23:45.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.632]                   3L)]
[13:23:45.632]             }
[13:23:45.632]             function(cond) {
[13:23:45.632]                 is_error <- inherits(cond, "error")
[13:23:45.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.632]                   NULL)
[13:23:45.632]                 if (is_error) {
[13:23:45.632]                   sessionInformation <- function() {
[13:23:45.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.632]                       search = base::search(), system = base::Sys.info())
[13:23:45.632]                   }
[13:23:45.632]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.632]                     cond$call), session = sessionInformation(), 
[13:23:45.632]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.632]                   signalCondition(cond)
[13:23:45.632]                 }
[13:23:45.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.632]                 "immediateCondition"))) {
[13:23:45.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.632]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.632]                   if (TRUE && !signal) {
[13:23:45.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.632]                     {
[13:23:45.632]                       inherits <- base::inherits
[13:23:45.632]                       invokeRestart <- base::invokeRestart
[13:23:45.632]                       is.null <- base::is.null
[13:23:45.632]                       muffled <- FALSE
[13:23:45.632]                       if (inherits(cond, "message")) {
[13:23:45.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.632]                         if (muffled) 
[13:23:45.632]                           invokeRestart("muffleMessage")
[13:23:45.632]                       }
[13:23:45.632]                       else if (inherits(cond, "warning")) {
[13:23:45.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.632]                         if (muffled) 
[13:23:45.632]                           invokeRestart("muffleWarning")
[13:23:45.632]                       }
[13:23:45.632]                       else if (inherits(cond, "condition")) {
[13:23:45.632]                         if (!is.null(pattern)) {
[13:23:45.632]                           computeRestarts <- base::computeRestarts
[13:23:45.632]                           grepl <- base::grepl
[13:23:45.632]                           restarts <- computeRestarts(cond)
[13:23:45.632]                           for (restart in restarts) {
[13:23:45.632]                             name <- restart$name
[13:23:45.632]                             if (is.null(name)) 
[13:23:45.632]                               next
[13:23:45.632]                             if (!grepl(pattern, name)) 
[13:23:45.632]                               next
[13:23:45.632]                             invokeRestart(restart)
[13:23:45.632]                             muffled <- TRUE
[13:23:45.632]                             break
[13:23:45.632]                           }
[13:23:45.632]                         }
[13:23:45.632]                       }
[13:23:45.632]                       invisible(muffled)
[13:23:45.632]                     }
[13:23:45.632]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.632]                   }
[13:23:45.632]                 }
[13:23:45.632]                 else {
[13:23:45.632]                   if (TRUE) {
[13:23:45.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.632]                     {
[13:23:45.632]                       inherits <- base::inherits
[13:23:45.632]                       invokeRestart <- base::invokeRestart
[13:23:45.632]                       is.null <- base::is.null
[13:23:45.632]                       muffled <- FALSE
[13:23:45.632]                       if (inherits(cond, "message")) {
[13:23:45.632]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.632]                         if (muffled) 
[13:23:45.632]                           invokeRestart("muffleMessage")
[13:23:45.632]                       }
[13:23:45.632]                       else if (inherits(cond, "warning")) {
[13:23:45.632]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.632]                         if (muffled) 
[13:23:45.632]                           invokeRestart("muffleWarning")
[13:23:45.632]                       }
[13:23:45.632]                       else if (inherits(cond, "condition")) {
[13:23:45.632]                         if (!is.null(pattern)) {
[13:23:45.632]                           computeRestarts <- base::computeRestarts
[13:23:45.632]                           grepl <- base::grepl
[13:23:45.632]                           restarts <- computeRestarts(cond)
[13:23:45.632]                           for (restart in restarts) {
[13:23:45.632]                             name <- restart$name
[13:23:45.632]                             if (is.null(name)) 
[13:23:45.632]                               next
[13:23:45.632]                             if (!grepl(pattern, name)) 
[13:23:45.632]                               next
[13:23:45.632]                             invokeRestart(restart)
[13:23:45.632]                             muffled <- TRUE
[13:23:45.632]                             break
[13:23:45.632]                           }
[13:23:45.632]                         }
[13:23:45.632]                       }
[13:23:45.632]                       invisible(muffled)
[13:23:45.632]                     }
[13:23:45.632]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.632]                   }
[13:23:45.632]                 }
[13:23:45.632]             }
[13:23:45.632]         }))
[13:23:45.632]     }, error = function(ex) {
[13:23:45.632]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.632]                 ...future.rng), started = ...future.startTime, 
[13:23:45.632]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.632]             version = "1.8"), class = "FutureResult")
[13:23:45.632]     }, finally = {
[13:23:45.632]         if (!identical(...future.workdir, getwd())) 
[13:23:45.632]             setwd(...future.workdir)
[13:23:45.632]         {
[13:23:45.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.632]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.632]             }
[13:23:45.632]             base::options(...future.oldOptions)
[13:23:45.632]             if (.Platform$OS.type == "windows") {
[13:23:45.632]                 old_names <- names(...future.oldEnvVars)
[13:23:45.632]                 envs <- base::Sys.getenv()
[13:23:45.632]                 names <- names(envs)
[13:23:45.632]                 common <- intersect(names, old_names)
[13:23:45.632]                 added <- setdiff(names, old_names)
[13:23:45.632]                 removed <- setdiff(old_names, names)
[13:23:45.632]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.632]                   envs[common]]
[13:23:45.632]                 NAMES <- toupper(changed)
[13:23:45.632]                 args <- list()
[13:23:45.632]                 for (kk in seq_along(NAMES)) {
[13:23:45.632]                   name <- changed[[kk]]
[13:23:45.632]                   NAME <- NAMES[[kk]]
[13:23:45.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.632]                     next
[13:23:45.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.632]                 }
[13:23:45.632]                 NAMES <- toupper(added)
[13:23:45.632]                 for (kk in seq_along(NAMES)) {
[13:23:45.632]                   name <- added[[kk]]
[13:23:45.632]                   NAME <- NAMES[[kk]]
[13:23:45.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.632]                     next
[13:23:45.632]                   args[[name]] <- ""
[13:23:45.632]                 }
[13:23:45.632]                 NAMES <- toupper(removed)
[13:23:45.632]                 for (kk in seq_along(NAMES)) {
[13:23:45.632]                   name <- removed[[kk]]
[13:23:45.632]                   NAME <- NAMES[[kk]]
[13:23:45.632]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.632]                     next
[13:23:45.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.632]                 }
[13:23:45.632]                 if (length(args) > 0) 
[13:23:45.632]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.632]             }
[13:23:45.632]             else {
[13:23:45.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.632]             }
[13:23:45.632]             {
[13:23:45.632]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.632]                   0L) {
[13:23:45.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.632]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.632]                   base::options(opts)
[13:23:45.632]                 }
[13:23:45.632]                 {
[13:23:45.632]                   {
[13:23:45.632]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.632]                     NULL
[13:23:45.632]                   }
[13:23:45.632]                   options(future.plan = NULL)
[13:23:45.632]                   if (is.na(NA_character_)) 
[13:23:45.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.632]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.632]                     envir = parent.frame()) 
[13:23:45.632]                   {
[13:23:45.632]                     default_workers <- missing(workers)
[13:23:45.632]                     if (is.function(workers)) 
[13:23:45.632]                       workers <- workers()
[13:23:45.632]                     workers <- structure(as.integer(workers), 
[13:23:45.632]                       class = class(workers))
[13:23:45.632]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.632]                       1L)
[13:23:45.632]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.632]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.632]                       if (default_workers) 
[13:23:45.632]                         supportsMulticore(warn = TRUE)
[13:23:45.632]                       return(sequential(..., envir = envir))
[13:23:45.632]                     }
[13:23:45.632]                     oopts <- options(mc.cores = workers)
[13:23:45.632]                     on.exit(options(oopts))
[13:23:45.632]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.632]                       envir = envir)
[13:23:45.632]                     if (!future$lazy) 
[13:23:45.632]                       future <- run(future)
[13:23:45.632]                     invisible(future)
[13:23:45.632]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.632]                 }
[13:23:45.632]             }
[13:23:45.632]         }
[13:23:45.632]     })
[13:23:45.632]     if (TRUE) {
[13:23:45.632]         base::sink(type = "output", split = FALSE)
[13:23:45.632]         if (TRUE) {
[13:23:45.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.632]         }
[13:23:45.632]         else {
[13:23:45.632]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.632]         }
[13:23:45.632]         base::close(...future.stdout)
[13:23:45.632]         ...future.stdout <- NULL
[13:23:45.632]     }
[13:23:45.632]     ...future.result$conditions <- ...future.conditions
[13:23:45.632]     ...future.result$finished <- base::Sys.time()
[13:23:45.632]     ...future.result
[13:23:45.632] }
[13:23:45.635] requestCore(): workers = 2
[13:23:45.637] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:45.638] plan(): Setting new future strategy stack:
[13:23:45.638] List of future strategies:
[13:23:45.638] 1. sequential:
[13:23:45.638]    - args: function (..., envir = parent.frame())
[13:23:45.638]    - tweaked: FALSE
[13:23:45.638]    - call: NULL
[13:23:45.639] plan(): nbrOfWorkers() = 1
[13:23:45.641] plan(): Setting new future strategy stack:
[13:23:45.641] List of future strategies:
[13:23:45.641] 1. multicore:
[13:23:45.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.641]    - tweaked: FALSE
[13:23:45.641]    - call: plan(multicore)
[13:23:45.646] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:45.647] result() for MulticoreFuture ...
[13:23:45.648] result() for MulticoreFuture ...
[13:23:45.648] result() for MulticoreFuture ... done
[13:23:45.648] result() for MulticoreFuture ... done
[13:23:45.648] result() for MulticoreFuture ...
[13:23:45.648] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[13:23:45.653] getGlobalsAndPackages() ...
[13:23:45.653] Not searching for globals
[13:23:45.653] - globals: [0] <none>
[13:23:45.653] getGlobalsAndPackages() ... DONE
[13:23:45.654] Packages needed by the future expression (n = 0): <none>
[13:23:45.654] Packages needed by future strategies (n = 0): <none>
[13:23:45.654] {
[13:23:45.654]     {
[13:23:45.654]         {
[13:23:45.654]             ...future.startTime <- base::Sys.time()
[13:23:45.654]             {
[13:23:45.654]                 {
[13:23:45.654]                   {
[13:23:45.654]                     {
[13:23:45.654]                       base::local({
[13:23:45.654]                         has_future <- base::requireNamespace("future", 
[13:23:45.654]                           quietly = TRUE)
[13:23:45.654]                         if (has_future) {
[13:23:45.654]                           ns <- base::getNamespace("future")
[13:23:45.654]                           version <- ns[[".package"]][["version"]]
[13:23:45.654]                           if (is.null(version)) 
[13:23:45.654]                             version <- utils::packageVersion("future")
[13:23:45.654]                         }
[13:23:45.654]                         else {
[13:23:45.654]                           version <- NULL
[13:23:45.654]                         }
[13:23:45.654]                         if (!has_future || version < "1.8.0") {
[13:23:45.654]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.654]                             "", base::R.version$version.string), 
[13:23:45.654]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.654]                               "release", "version")], collapse = " "), 
[13:23:45.654]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.654]                             info)
[13:23:45.654]                           info <- base::paste(info, collapse = "; ")
[13:23:45.654]                           if (!has_future) {
[13:23:45.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.654]                               info)
[13:23:45.654]                           }
[13:23:45.654]                           else {
[13:23:45.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.654]                               info, version)
[13:23:45.654]                           }
[13:23:45.654]                           base::stop(msg)
[13:23:45.654]                         }
[13:23:45.654]                       })
[13:23:45.654]                     }
[13:23:45.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.654]                     base::options(mc.cores = 1L)
[13:23:45.654]                   }
[13:23:45.654]                   options(future.plan = NULL)
[13:23:45.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.654]                 }
[13:23:45.654]                 ...future.workdir <- getwd()
[13:23:45.654]             }
[13:23:45.654]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.654]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.654]         }
[13:23:45.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.654]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.654]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.654]             base::names(...future.oldOptions))
[13:23:45.654]     }
[13:23:45.654]     if (FALSE) {
[13:23:45.654]     }
[13:23:45.654]     else {
[13:23:45.654]         if (TRUE) {
[13:23:45.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.654]                 open = "w")
[13:23:45.654]         }
[13:23:45.654]         else {
[13:23:45.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.654]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.654]         }
[13:23:45.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.654]             base::sink(type = "output", split = FALSE)
[13:23:45.654]             base::close(...future.stdout)
[13:23:45.654]         }, add = TRUE)
[13:23:45.654]     }
[13:23:45.654]     ...future.frame <- base::sys.nframe()
[13:23:45.654]     ...future.conditions <- base::list()
[13:23:45.654]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.654]     if (FALSE) {
[13:23:45.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.654]     }
[13:23:45.654]     ...future.result <- base::tryCatch({
[13:23:45.654]         base::withCallingHandlers({
[13:23:45.654]             ...future.value <- base::withVisible(base::local({
[13:23:45.654]                 withCallingHandlers({
[13:23:45.654]                   {
[13:23:45.654]                     ii
[13:23:45.654]                   }
[13:23:45.654]                 }, immediateCondition = function(cond) {
[13:23:45.654]                   save_rds <- function (object, pathname, ...) 
[13:23:45.654]                   {
[13:23:45.654]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.654]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.654]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.654]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.654]                         fi_tmp[["mtime"]])
[13:23:45.654]                     }
[13:23:45.654]                     tryCatch({
[13:23:45.654]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.654]                     }, error = function(ex) {
[13:23:45.654]                       msg <- conditionMessage(ex)
[13:23:45.654]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.654]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.654]                         fi_tmp[["mtime"]], msg)
[13:23:45.654]                       ex$message <- msg
[13:23:45.654]                       stop(ex)
[13:23:45.654]                     })
[13:23:45.654]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.654]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.654]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.654]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.654]                       fi <- file.info(pathname)
[13:23:45.654]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.654]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.654]                         fi[["size"]], fi[["mtime"]])
[13:23:45.654]                       stop(msg)
[13:23:45.654]                     }
[13:23:45.654]                     invisible(pathname)
[13:23:45.654]                   }
[13:23:45.654]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.654]                     rootPath = tempdir()) 
[13:23:45.654]                   {
[13:23:45.654]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.654]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.654]                       tmpdir = path, fileext = ".rds")
[13:23:45.654]                     save_rds(obj, file)
[13:23:45.654]                   }
[13:23:45.654]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.654]                   {
[13:23:45.654]                     inherits <- base::inherits
[13:23:45.654]                     invokeRestart <- base::invokeRestart
[13:23:45.654]                     is.null <- base::is.null
[13:23:45.654]                     muffled <- FALSE
[13:23:45.654]                     if (inherits(cond, "message")) {
[13:23:45.654]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.654]                       if (muffled) 
[13:23:45.654]                         invokeRestart("muffleMessage")
[13:23:45.654]                     }
[13:23:45.654]                     else if (inherits(cond, "warning")) {
[13:23:45.654]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.654]                       if (muffled) 
[13:23:45.654]                         invokeRestart("muffleWarning")
[13:23:45.654]                     }
[13:23:45.654]                     else if (inherits(cond, "condition")) {
[13:23:45.654]                       if (!is.null(pattern)) {
[13:23:45.654]                         computeRestarts <- base::computeRestarts
[13:23:45.654]                         grepl <- base::grepl
[13:23:45.654]                         restarts <- computeRestarts(cond)
[13:23:45.654]                         for (restart in restarts) {
[13:23:45.654]                           name <- restart$name
[13:23:45.654]                           if (is.null(name)) 
[13:23:45.654]                             next
[13:23:45.654]                           if (!grepl(pattern, name)) 
[13:23:45.654]                             next
[13:23:45.654]                           invokeRestart(restart)
[13:23:45.654]                           muffled <- TRUE
[13:23:45.654]                           break
[13:23:45.654]                         }
[13:23:45.654]                       }
[13:23:45.654]                     }
[13:23:45.654]                     invisible(muffled)
[13:23:45.654]                   }
[13:23:45.654]                   muffleCondition(cond)
[13:23:45.654]                 })
[13:23:45.654]             }))
[13:23:45.654]             future::FutureResult(value = ...future.value$value, 
[13:23:45.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.654]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.654]                     ...future.globalenv.names))
[13:23:45.654]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.654]         }, condition = base::local({
[13:23:45.654]             c <- base::c
[13:23:45.654]             inherits <- base::inherits
[13:23:45.654]             invokeRestart <- base::invokeRestart
[13:23:45.654]             length <- base::length
[13:23:45.654]             list <- base::list
[13:23:45.654]             seq.int <- base::seq.int
[13:23:45.654]             signalCondition <- base::signalCondition
[13:23:45.654]             sys.calls <- base::sys.calls
[13:23:45.654]             `[[` <- base::`[[`
[13:23:45.654]             `+` <- base::`+`
[13:23:45.654]             `<<-` <- base::`<<-`
[13:23:45.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.654]                   3L)]
[13:23:45.654]             }
[13:23:45.654]             function(cond) {
[13:23:45.654]                 is_error <- inherits(cond, "error")
[13:23:45.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.654]                   NULL)
[13:23:45.654]                 if (is_error) {
[13:23:45.654]                   sessionInformation <- function() {
[13:23:45.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.654]                       search = base::search(), system = base::Sys.info())
[13:23:45.654]                   }
[13:23:45.654]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.654]                     cond$call), session = sessionInformation(), 
[13:23:45.654]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.654]                   signalCondition(cond)
[13:23:45.654]                 }
[13:23:45.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.654]                 "immediateCondition"))) {
[13:23:45.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.654]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.654]                   if (TRUE && !signal) {
[13:23:45.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.654]                     {
[13:23:45.654]                       inherits <- base::inherits
[13:23:45.654]                       invokeRestart <- base::invokeRestart
[13:23:45.654]                       is.null <- base::is.null
[13:23:45.654]                       muffled <- FALSE
[13:23:45.654]                       if (inherits(cond, "message")) {
[13:23:45.654]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.654]                         if (muffled) 
[13:23:45.654]                           invokeRestart("muffleMessage")
[13:23:45.654]                       }
[13:23:45.654]                       else if (inherits(cond, "warning")) {
[13:23:45.654]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.654]                         if (muffled) 
[13:23:45.654]                           invokeRestart("muffleWarning")
[13:23:45.654]                       }
[13:23:45.654]                       else if (inherits(cond, "condition")) {
[13:23:45.654]                         if (!is.null(pattern)) {
[13:23:45.654]                           computeRestarts <- base::computeRestarts
[13:23:45.654]                           grepl <- base::grepl
[13:23:45.654]                           restarts <- computeRestarts(cond)
[13:23:45.654]                           for (restart in restarts) {
[13:23:45.654]                             name <- restart$name
[13:23:45.654]                             if (is.null(name)) 
[13:23:45.654]                               next
[13:23:45.654]                             if (!grepl(pattern, name)) 
[13:23:45.654]                               next
[13:23:45.654]                             invokeRestart(restart)
[13:23:45.654]                             muffled <- TRUE
[13:23:45.654]                             break
[13:23:45.654]                           }
[13:23:45.654]                         }
[13:23:45.654]                       }
[13:23:45.654]                       invisible(muffled)
[13:23:45.654]                     }
[13:23:45.654]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.654]                   }
[13:23:45.654]                 }
[13:23:45.654]                 else {
[13:23:45.654]                   if (TRUE) {
[13:23:45.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.654]                     {
[13:23:45.654]                       inherits <- base::inherits
[13:23:45.654]                       invokeRestart <- base::invokeRestart
[13:23:45.654]                       is.null <- base::is.null
[13:23:45.654]                       muffled <- FALSE
[13:23:45.654]                       if (inherits(cond, "message")) {
[13:23:45.654]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.654]                         if (muffled) 
[13:23:45.654]                           invokeRestart("muffleMessage")
[13:23:45.654]                       }
[13:23:45.654]                       else if (inherits(cond, "warning")) {
[13:23:45.654]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.654]                         if (muffled) 
[13:23:45.654]                           invokeRestart("muffleWarning")
[13:23:45.654]                       }
[13:23:45.654]                       else if (inherits(cond, "condition")) {
[13:23:45.654]                         if (!is.null(pattern)) {
[13:23:45.654]                           computeRestarts <- base::computeRestarts
[13:23:45.654]                           grepl <- base::grepl
[13:23:45.654]                           restarts <- computeRestarts(cond)
[13:23:45.654]                           for (restart in restarts) {
[13:23:45.654]                             name <- restart$name
[13:23:45.654]                             if (is.null(name)) 
[13:23:45.654]                               next
[13:23:45.654]                             if (!grepl(pattern, name)) 
[13:23:45.654]                               next
[13:23:45.654]                             invokeRestart(restart)
[13:23:45.654]                             muffled <- TRUE
[13:23:45.654]                             break
[13:23:45.654]                           }
[13:23:45.654]                         }
[13:23:45.654]                       }
[13:23:45.654]                       invisible(muffled)
[13:23:45.654]                     }
[13:23:45.654]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.654]                   }
[13:23:45.654]                 }
[13:23:45.654]             }
[13:23:45.654]         }))
[13:23:45.654]     }, error = function(ex) {
[13:23:45.654]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.654]                 ...future.rng), started = ...future.startTime, 
[13:23:45.654]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.654]             version = "1.8"), class = "FutureResult")
[13:23:45.654]     }, finally = {
[13:23:45.654]         if (!identical(...future.workdir, getwd())) 
[13:23:45.654]             setwd(...future.workdir)
[13:23:45.654]         {
[13:23:45.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.654]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.654]             }
[13:23:45.654]             base::options(...future.oldOptions)
[13:23:45.654]             if (.Platform$OS.type == "windows") {
[13:23:45.654]                 old_names <- names(...future.oldEnvVars)
[13:23:45.654]                 envs <- base::Sys.getenv()
[13:23:45.654]                 names <- names(envs)
[13:23:45.654]                 common <- intersect(names, old_names)
[13:23:45.654]                 added <- setdiff(names, old_names)
[13:23:45.654]                 removed <- setdiff(old_names, names)
[13:23:45.654]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.654]                   envs[common]]
[13:23:45.654]                 NAMES <- toupper(changed)
[13:23:45.654]                 args <- list()
[13:23:45.654]                 for (kk in seq_along(NAMES)) {
[13:23:45.654]                   name <- changed[[kk]]
[13:23:45.654]                   NAME <- NAMES[[kk]]
[13:23:45.654]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.654]                     next
[13:23:45.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.654]                 }
[13:23:45.654]                 NAMES <- toupper(added)
[13:23:45.654]                 for (kk in seq_along(NAMES)) {
[13:23:45.654]                   name <- added[[kk]]
[13:23:45.654]                   NAME <- NAMES[[kk]]
[13:23:45.654]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.654]                     next
[13:23:45.654]                   args[[name]] <- ""
[13:23:45.654]                 }
[13:23:45.654]                 NAMES <- toupper(removed)
[13:23:45.654]                 for (kk in seq_along(NAMES)) {
[13:23:45.654]                   name <- removed[[kk]]
[13:23:45.654]                   NAME <- NAMES[[kk]]
[13:23:45.654]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.654]                     next
[13:23:45.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.654]                 }
[13:23:45.654]                 if (length(args) > 0) 
[13:23:45.654]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.654]             }
[13:23:45.654]             else {
[13:23:45.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.654]             }
[13:23:45.654]             {
[13:23:45.654]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.654]                   0L) {
[13:23:45.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.654]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.654]                   base::options(opts)
[13:23:45.654]                 }
[13:23:45.654]                 {
[13:23:45.654]                   {
[13:23:45.654]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.654]                     NULL
[13:23:45.654]                   }
[13:23:45.654]                   options(future.plan = NULL)
[13:23:45.654]                   if (is.na(NA_character_)) 
[13:23:45.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.654]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.654]                     envir = parent.frame()) 
[13:23:45.654]                   {
[13:23:45.654]                     default_workers <- missing(workers)
[13:23:45.654]                     if (is.function(workers)) 
[13:23:45.654]                       workers <- workers()
[13:23:45.654]                     workers <- structure(as.integer(workers), 
[13:23:45.654]                       class = class(workers))
[13:23:45.654]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.654]                       1L)
[13:23:45.654]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.654]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.654]                       if (default_workers) 
[13:23:45.654]                         supportsMulticore(warn = TRUE)
[13:23:45.654]                       return(sequential(..., envir = envir))
[13:23:45.654]                     }
[13:23:45.654]                     oopts <- options(mc.cores = workers)
[13:23:45.654]                     on.exit(options(oopts))
[13:23:45.654]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.654]                       envir = envir)
[13:23:45.654]                     if (!future$lazy) 
[13:23:45.654]                       future <- run(future)
[13:23:45.654]                     invisible(future)
[13:23:45.654]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.654]                 }
[13:23:45.654]             }
[13:23:45.654]         }
[13:23:45.654]     })
[13:23:45.654]     if (TRUE) {
[13:23:45.654]         base::sink(type = "output", split = FALSE)
[13:23:45.654]         if (TRUE) {
[13:23:45.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.654]         }
[13:23:45.654]         else {
[13:23:45.654]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.654]         }
[13:23:45.654]         base::close(...future.stdout)
[13:23:45.654]         ...future.stdout <- NULL
[13:23:45.654]     }
[13:23:45.654]     ...future.result$conditions <- ...future.conditions
[13:23:45.654]     ...future.result$finished <- base::Sys.time()
[13:23:45.654]     ...future.result
[13:23:45.654] }
[13:23:45.657] requestCore(): workers = 2
[13:23:45.659] MulticoreFuture started
 - Creating multicore future #2 ...
[13:23:45.660] plan(): Setting new future strategy stack:
[13:23:45.661] List of future strategies:
[13:23:45.661] 1. sequential:
[13:23:45.661]    - args: function (..., envir = parent.frame())
[13:23:45.661]    - tweaked: FALSE
[13:23:45.661]    - call: NULL
[13:23:45.661] plan(): nbrOfWorkers() = 1
[13:23:45.663] plan(): Setting new future strategy stack:
[13:23:45.663] List of future strategies:
[13:23:45.663] 1. multicore:
[13:23:45.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.663]    - tweaked: FALSE
[13:23:45.663]    - call: plan(multicore)
[13:23:45.665] getGlobalsAndPackages() ...
[13:23:45.665] Not searching for globals
[13:23:45.665] - globals: [0] <none>
[13:23:45.665] getGlobalsAndPackages() ... DONE
[13:23:45.666] Packages needed by the future expression (n = 0): <none>
[13:23:45.666] Packages needed by future strategies (n = 0): <none>
[13:23:45.667] plan(): nbrOfWorkers() = 2
[13:23:45.667] {
[13:23:45.667]     {
[13:23:45.667]         {
[13:23:45.667]             ...future.startTime <- base::Sys.time()
[13:23:45.667]             {
[13:23:45.667]                 {
[13:23:45.667]                   {
[13:23:45.667]                     {
[13:23:45.667]                       base::local({
[13:23:45.667]                         has_future <- base::requireNamespace("future", 
[13:23:45.667]                           quietly = TRUE)
[13:23:45.667]                         if (has_future) {
[13:23:45.667]                           ns <- base::getNamespace("future")
[13:23:45.667]                           version <- ns[[".package"]][["version"]]
[13:23:45.667]                           if (is.null(version)) 
[13:23:45.667]                             version <- utils::packageVersion("future")
[13:23:45.667]                         }
[13:23:45.667]                         else {
[13:23:45.667]                           version <- NULL
[13:23:45.667]                         }
[13:23:45.667]                         if (!has_future || version < "1.8.0") {
[13:23:45.667]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.667]                             "", base::R.version$version.string), 
[13:23:45.667]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.667]                               "release", "version")], collapse = " "), 
[13:23:45.667]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.667]                             info)
[13:23:45.667]                           info <- base::paste(info, collapse = "; ")
[13:23:45.667]                           if (!has_future) {
[13:23:45.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.667]                               info)
[13:23:45.667]                           }
[13:23:45.667]                           else {
[13:23:45.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.667]                               info, version)
[13:23:45.667]                           }
[13:23:45.667]                           base::stop(msg)
[13:23:45.667]                         }
[13:23:45.667]                       })
[13:23:45.667]                     }
[13:23:45.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.667]                     base::options(mc.cores = 1L)
[13:23:45.667]                   }
[13:23:45.667]                   options(future.plan = NULL)
[13:23:45.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.667]                 }
[13:23:45.667]                 ...future.workdir <- getwd()
[13:23:45.667]             }
[13:23:45.667]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.667]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.667]         }
[13:23:45.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.667]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.667]             base::names(...future.oldOptions))
[13:23:45.667]     }
[13:23:45.667]     if (FALSE) {
[13:23:45.667]     }
[13:23:45.667]     else {
[13:23:45.667]         if (TRUE) {
[13:23:45.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.667]                 open = "w")
[13:23:45.667]         }
[13:23:45.667]         else {
[13:23:45.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.667]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.667]         }
[13:23:45.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.667]             base::sink(type = "output", split = FALSE)
[13:23:45.667]             base::close(...future.stdout)
[13:23:45.667]         }, add = TRUE)
[13:23:45.667]     }
[13:23:45.667]     ...future.frame <- base::sys.nframe()
[13:23:45.667]     ...future.conditions <- base::list()
[13:23:45.667]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.667]     if (FALSE) {
[13:23:45.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.667]     }
[13:23:45.667]     ...future.result <- base::tryCatch({
[13:23:45.667]         base::withCallingHandlers({
[13:23:45.667]             ...future.value <- base::withVisible(base::local({
[13:23:45.667]                 withCallingHandlers({
[13:23:45.667]                   {
[13:23:45.667]                     ii
[13:23:45.667]                   }
[13:23:45.667]                 }, immediateCondition = function(cond) {
[13:23:45.667]                   save_rds <- function (object, pathname, ...) 
[13:23:45.667]                   {
[13:23:45.667]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.667]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.667]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.667]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.667]                         fi_tmp[["mtime"]])
[13:23:45.667]                     }
[13:23:45.667]                     tryCatch({
[13:23:45.667]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.667]                     }, error = function(ex) {
[13:23:45.667]                       msg <- conditionMessage(ex)
[13:23:45.667]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.667]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.667]                         fi_tmp[["mtime"]], msg)
[13:23:45.667]                       ex$message <- msg
[13:23:45.667]                       stop(ex)
[13:23:45.667]                     })
[13:23:45.667]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.667]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.667]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.667]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.667]                       fi <- file.info(pathname)
[13:23:45.667]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.667]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.667]                         fi[["size"]], fi[["mtime"]])
[13:23:45.667]                       stop(msg)
[13:23:45.667]                     }
[13:23:45.667]                     invisible(pathname)
[13:23:45.667]                   }
[13:23:45.667]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.667]                     rootPath = tempdir()) 
[13:23:45.667]                   {
[13:23:45.667]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.667]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.667]                       tmpdir = path, fileext = ".rds")
[13:23:45.667]                     save_rds(obj, file)
[13:23:45.667]                   }
[13:23:45.667]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.667]                   {
[13:23:45.667]                     inherits <- base::inherits
[13:23:45.667]                     invokeRestart <- base::invokeRestart
[13:23:45.667]                     is.null <- base::is.null
[13:23:45.667]                     muffled <- FALSE
[13:23:45.667]                     if (inherits(cond, "message")) {
[13:23:45.667]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.667]                       if (muffled) 
[13:23:45.667]                         invokeRestart("muffleMessage")
[13:23:45.667]                     }
[13:23:45.667]                     else if (inherits(cond, "warning")) {
[13:23:45.667]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.667]                       if (muffled) 
[13:23:45.667]                         invokeRestart("muffleWarning")
[13:23:45.667]                     }
[13:23:45.667]                     else if (inherits(cond, "condition")) {
[13:23:45.667]                       if (!is.null(pattern)) {
[13:23:45.667]                         computeRestarts <- base::computeRestarts
[13:23:45.667]                         grepl <- base::grepl
[13:23:45.667]                         restarts <- computeRestarts(cond)
[13:23:45.667]                         for (restart in restarts) {
[13:23:45.667]                           name <- restart$name
[13:23:45.667]                           if (is.null(name)) 
[13:23:45.667]                             next
[13:23:45.667]                           if (!grepl(pattern, name)) 
[13:23:45.667]                             next
[13:23:45.667]                           invokeRestart(restart)
[13:23:45.667]                           muffled <- TRUE
[13:23:45.667]                           break
[13:23:45.667]                         }
[13:23:45.667]                       }
[13:23:45.667]                     }
[13:23:45.667]                     invisible(muffled)
[13:23:45.667]                   }
[13:23:45.667]                   muffleCondition(cond)
[13:23:45.667]                 })
[13:23:45.667]             }))
[13:23:45.667]             future::FutureResult(value = ...future.value$value, 
[13:23:45.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.667]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.667]                     ...future.globalenv.names))
[13:23:45.667]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.667]         }, condition = base::local({
[13:23:45.667]             c <- base::c
[13:23:45.667]             inherits <- base::inherits
[13:23:45.667]             invokeRestart <- base::invokeRestart
[13:23:45.667]             length <- base::length
[13:23:45.667]             list <- base::list
[13:23:45.667]             seq.int <- base::seq.int
[13:23:45.667]             signalCondition <- base::signalCondition
[13:23:45.667]             sys.calls <- base::sys.calls
[13:23:45.667]             `[[` <- base::`[[`
[13:23:45.667]             `+` <- base::`+`
[13:23:45.667]             `<<-` <- base::`<<-`
[13:23:45.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.667]                   3L)]
[13:23:45.667]             }
[13:23:45.667]             function(cond) {
[13:23:45.667]                 is_error <- inherits(cond, "error")
[13:23:45.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.667]                   NULL)
[13:23:45.667]                 if (is_error) {
[13:23:45.667]                   sessionInformation <- function() {
[13:23:45.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.667]                       search = base::search(), system = base::Sys.info())
[13:23:45.667]                   }
[13:23:45.667]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.667]                     cond$call), session = sessionInformation(), 
[13:23:45.667]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.667]                   signalCondition(cond)
[13:23:45.667]                 }
[13:23:45.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.667]                 "immediateCondition"))) {
[13:23:45.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.667]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.667]                   if (TRUE && !signal) {
[13:23:45.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.667]                     {
[13:23:45.667]                       inherits <- base::inherits
[13:23:45.667]                       invokeRestart <- base::invokeRestart
[13:23:45.667]                       is.null <- base::is.null
[13:23:45.667]                       muffled <- FALSE
[13:23:45.667]                       if (inherits(cond, "message")) {
[13:23:45.667]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.667]                         if (muffled) 
[13:23:45.667]                           invokeRestart("muffleMessage")
[13:23:45.667]                       }
[13:23:45.667]                       else if (inherits(cond, "warning")) {
[13:23:45.667]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.667]                         if (muffled) 
[13:23:45.667]                           invokeRestart("muffleWarning")
[13:23:45.667]                       }
[13:23:45.667]                       else if (inherits(cond, "condition")) {
[13:23:45.667]                         if (!is.null(pattern)) {
[13:23:45.667]                           computeRestarts <- base::computeRestarts
[13:23:45.667]                           grepl <- base::grepl
[13:23:45.667]                           restarts <- computeRestarts(cond)
[13:23:45.667]                           for (restart in restarts) {
[13:23:45.667]                             name <- restart$name
[13:23:45.667]                             if (is.null(name)) 
[13:23:45.667]                               next
[13:23:45.667]                             if (!grepl(pattern, name)) 
[13:23:45.667]                               next
[13:23:45.667]                             invokeRestart(restart)
[13:23:45.667]                             muffled <- TRUE
[13:23:45.667]                             break
[13:23:45.667]                           }
[13:23:45.667]                         }
[13:23:45.667]                       }
[13:23:45.667]                       invisible(muffled)
[13:23:45.667]                     }
[13:23:45.667]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.667]                   }
[13:23:45.667]                 }
[13:23:45.667]                 else {
[13:23:45.667]                   if (TRUE) {
[13:23:45.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.667]                     {
[13:23:45.667]                       inherits <- base::inherits
[13:23:45.667]                       invokeRestart <- base::invokeRestart
[13:23:45.667]                       is.null <- base::is.null
[13:23:45.667]                       muffled <- FALSE
[13:23:45.667]                       if (inherits(cond, "message")) {
[13:23:45.667]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.667]                         if (muffled) 
[13:23:45.667]                           invokeRestart("muffleMessage")
[13:23:45.667]                       }
[13:23:45.667]                       else if (inherits(cond, "warning")) {
[13:23:45.667]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.667]                         if (muffled) 
[13:23:45.667]                           invokeRestart("muffleWarning")
[13:23:45.667]                       }
[13:23:45.667]                       else if (inherits(cond, "condition")) {
[13:23:45.667]                         if (!is.null(pattern)) {
[13:23:45.667]                           computeRestarts <- base::computeRestarts
[13:23:45.667]                           grepl <- base::grepl
[13:23:45.667]                           restarts <- computeRestarts(cond)
[13:23:45.667]                           for (restart in restarts) {
[13:23:45.667]                             name <- restart$name
[13:23:45.667]                             if (is.null(name)) 
[13:23:45.667]                               next
[13:23:45.667]                             if (!grepl(pattern, name)) 
[13:23:45.667]                               next
[13:23:45.667]                             invokeRestart(restart)
[13:23:45.667]                             muffled <- TRUE
[13:23:45.667]                             break
[13:23:45.667]                           }
[13:23:45.667]                         }
[13:23:45.667]                       }
[13:23:45.667]                       invisible(muffled)
[13:23:45.667]                     }
[13:23:45.667]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.667]                   }
[13:23:45.667]                 }
[13:23:45.667]             }
[13:23:45.667]         }))
[13:23:45.667]     }, error = function(ex) {
[13:23:45.667]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.667]                 ...future.rng), started = ...future.startTime, 
[13:23:45.667]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.667]             version = "1.8"), class = "FutureResult")
[13:23:45.667]     }, finally = {
[13:23:45.667]         if (!identical(...future.workdir, getwd())) 
[13:23:45.667]             setwd(...future.workdir)
[13:23:45.667]         {
[13:23:45.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.667]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.667]             }
[13:23:45.667]             base::options(...future.oldOptions)
[13:23:45.667]             if (.Platform$OS.type == "windows") {
[13:23:45.667]                 old_names <- names(...future.oldEnvVars)
[13:23:45.667]                 envs <- base::Sys.getenv()
[13:23:45.667]                 names <- names(envs)
[13:23:45.667]                 common <- intersect(names, old_names)
[13:23:45.667]                 added <- setdiff(names, old_names)
[13:23:45.667]                 removed <- setdiff(old_names, names)
[13:23:45.667]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.667]                   envs[common]]
[13:23:45.667]                 NAMES <- toupper(changed)
[13:23:45.667]                 args <- list()
[13:23:45.667]                 for (kk in seq_along(NAMES)) {
[13:23:45.667]                   name <- changed[[kk]]
[13:23:45.667]                   NAME <- NAMES[[kk]]
[13:23:45.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.667]                     next
[13:23:45.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.667]                 }
[13:23:45.667]                 NAMES <- toupper(added)
[13:23:45.667]                 for (kk in seq_along(NAMES)) {
[13:23:45.667]                   name <- added[[kk]]
[13:23:45.667]                   NAME <- NAMES[[kk]]
[13:23:45.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.667]                     next
[13:23:45.667]                   args[[name]] <- ""
[13:23:45.667]                 }
[13:23:45.667]                 NAMES <- toupper(removed)
[13:23:45.667]                 for (kk in seq_along(NAMES)) {
[13:23:45.667]                   name <- removed[[kk]]
[13:23:45.667]                   NAME <- NAMES[[kk]]
[13:23:45.667]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.667]                     next
[13:23:45.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.667]                 }
[13:23:45.667]                 if (length(args) > 0) 
[13:23:45.667]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.667]             }
[13:23:45.667]             else {
[13:23:45.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.667]             }
[13:23:45.667]             {
[13:23:45.667]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.667]                   0L) {
[13:23:45.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.667]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.667]                   base::options(opts)
[13:23:45.667]                 }
[13:23:45.667]                 {
[13:23:45.667]                   {
[13:23:45.667]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.667]                     NULL
[13:23:45.667]                   }
[13:23:45.667]                   options(future.plan = NULL)
[13:23:45.667]                   if (is.na(NA_character_)) 
[13:23:45.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.667]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.667]                     envir = parent.frame()) 
[13:23:45.667]                   {
[13:23:45.667]                     default_workers <- missing(workers)
[13:23:45.667]                     if (is.function(workers)) 
[13:23:45.667]                       workers <- workers()
[13:23:45.667]                     workers <- structure(as.integer(workers), 
[13:23:45.667]                       class = class(workers))
[13:23:45.667]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.667]                       1L)
[13:23:45.667]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.667]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.667]                       if (default_workers) 
[13:23:45.667]                         supportsMulticore(warn = TRUE)
[13:23:45.667]                       return(sequential(..., envir = envir))
[13:23:45.667]                     }
[13:23:45.667]                     oopts <- options(mc.cores = workers)
[13:23:45.667]                     on.exit(options(oopts))
[13:23:45.667]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.667]                       envir = envir)
[13:23:45.667]                     if (!future$lazy) 
[13:23:45.667]                       future <- run(future)
[13:23:45.667]                     invisible(future)
[13:23:45.667]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.667]                 }
[13:23:45.667]             }
[13:23:45.667]         }
[13:23:45.667]     })
[13:23:45.667]     if (TRUE) {
[13:23:45.667]         base::sink(type = "output", split = FALSE)
[13:23:45.667]         if (TRUE) {
[13:23:45.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.667]         }
[13:23:45.667]         else {
[13:23:45.667]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.667]         }
[13:23:45.667]         base::close(...future.stdout)
[13:23:45.667]         ...future.stdout <- NULL
[13:23:45.667]     }
[13:23:45.667]     ...future.result$conditions <- ...future.conditions
[13:23:45.667]     ...future.result$finished <- base::Sys.time()
[13:23:45.667]     ...future.result
[13:23:45.667] }
[13:23:45.670] requestCore(): workers = 2
[13:23:45.673] MulticoreFuture started
 - Creating multicore future #3 ...
[13:23:45.674] plan(): Setting new future strategy stack:
[13:23:45.674] List of future strategies:
[13:23:45.674] 1. sequential:
[13:23:45.674]    - args: function (..., envir = parent.frame())
[13:23:45.674]    - tweaked: FALSE
[13:23:45.674]    - call: NULL
[13:23:45.675] plan(): nbrOfWorkers() = 1
[13:23:45.677] plan(): Setting new future strategy stack:
[13:23:45.677] List of future strategies:
[13:23:45.677] 1. multicore:
[13:23:45.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.677]    - tweaked: FALSE
[13:23:45.677]    - call: plan(multicore)
[13:23:45.678] getGlobalsAndPackages() ...
[13:23:45.678] Not searching for globals
[13:23:45.679] - globals: [0] <none>
[13:23:45.679] getGlobalsAndPackages() ... DONE
[13:23:45.680] Packages needed by the future expression (n = 0): <none>
[13:23:45.680] Packages needed by future strategies (n = 0): <none>
[13:23:45.681] plan(): nbrOfWorkers() = 2
[13:23:45.681] {
[13:23:45.681]     {
[13:23:45.681]         {
[13:23:45.681]             ...future.startTime <- base::Sys.time()
[13:23:45.681]             {
[13:23:45.681]                 {
[13:23:45.681]                   {
[13:23:45.681]                     {
[13:23:45.681]                       base::local({
[13:23:45.681]                         has_future <- base::requireNamespace("future", 
[13:23:45.681]                           quietly = TRUE)
[13:23:45.681]                         if (has_future) {
[13:23:45.681]                           ns <- base::getNamespace("future")
[13:23:45.681]                           version <- ns[[".package"]][["version"]]
[13:23:45.681]                           if (is.null(version)) 
[13:23:45.681]                             version <- utils::packageVersion("future")
[13:23:45.681]                         }
[13:23:45.681]                         else {
[13:23:45.681]                           version <- NULL
[13:23:45.681]                         }
[13:23:45.681]                         if (!has_future || version < "1.8.0") {
[13:23:45.681]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.681]                             "", base::R.version$version.string), 
[13:23:45.681]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.681]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.681]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.681]                               "release", "version")], collapse = " "), 
[13:23:45.681]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.681]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.681]                             info)
[13:23:45.681]                           info <- base::paste(info, collapse = "; ")
[13:23:45.681]                           if (!has_future) {
[13:23:45.681]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.681]                               info)
[13:23:45.681]                           }
[13:23:45.681]                           else {
[13:23:45.681]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.681]                               info, version)
[13:23:45.681]                           }
[13:23:45.681]                           base::stop(msg)
[13:23:45.681]                         }
[13:23:45.681]                       })
[13:23:45.681]                     }
[13:23:45.681]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.681]                     base::options(mc.cores = 1L)
[13:23:45.681]                   }
[13:23:45.681]                   options(future.plan = NULL)
[13:23:45.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.681]                 }
[13:23:45.681]                 ...future.workdir <- getwd()
[13:23:45.681]             }
[13:23:45.681]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.681]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.681]         }
[13:23:45.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.681]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.681]             base::names(...future.oldOptions))
[13:23:45.681]     }
[13:23:45.681]     if (FALSE) {
[13:23:45.681]     }
[13:23:45.681]     else {
[13:23:45.681]         if (TRUE) {
[13:23:45.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.681]                 open = "w")
[13:23:45.681]         }
[13:23:45.681]         else {
[13:23:45.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.681]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.681]         }
[13:23:45.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.681]             base::sink(type = "output", split = FALSE)
[13:23:45.681]             base::close(...future.stdout)
[13:23:45.681]         }, add = TRUE)
[13:23:45.681]     }
[13:23:45.681]     ...future.frame <- base::sys.nframe()
[13:23:45.681]     ...future.conditions <- base::list()
[13:23:45.681]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.681]     if (FALSE) {
[13:23:45.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.681]     }
[13:23:45.681]     ...future.result <- base::tryCatch({
[13:23:45.681]         base::withCallingHandlers({
[13:23:45.681]             ...future.value <- base::withVisible(base::local({
[13:23:45.681]                 withCallingHandlers({
[13:23:45.681]                   {
[13:23:45.681]                     ii
[13:23:45.681]                   }
[13:23:45.681]                 }, immediateCondition = function(cond) {
[13:23:45.681]                   save_rds <- function (object, pathname, ...) 
[13:23:45.681]                   {
[13:23:45.681]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.681]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.681]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.681]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.681]                         fi_tmp[["mtime"]])
[13:23:45.681]                     }
[13:23:45.681]                     tryCatch({
[13:23:45.681]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.681]                     }, error = function(ex) {
[13:23:45.681]                       msg <- conditionMessage(ex)
[13:23:45.681]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.681]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.681]                         fi_tmp[["mtime"]], msg)
[13:23:45.681]                       ex$message <- msg
[13:23:45.681]                       stop(ex)
[13:23:45.681]                     })
[13:23:45.681]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.681]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.681]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.681]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.681]                       fi <- file.info(pathname)
[13:23:45.681]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.681]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.681]                         fi[["size"]], fi[["mtime"]])
[13:23:45.681]                       stop(msg)
[13:23:45.681]                     }
[13:23:45.681]                     invisible(pathname)
[13:23:45.681]                   }
[13:23:45.681]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.681]                     rootPath = tempdir()) 
[13:23:45.681]                   {
[13:23:45.681]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.681]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.681]                       tmpdir = path, fileext = ".rds")
[13:23:45.681]                     save_rds(obj, file)
[13:23:45.681]                   }
[13:23:45.681]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.681]                   {
[13:23:45.681]                     inherits <- base::inherits
[13:23:45.681]                     invokeRestart <- base::invokeRestart
[13:23:45.681]                     is.null <- base::is.null
[13:23:45.681]                     muffled <- FALSE
[13:23:45.681]                     if (inherits(cond, "message")) {
[13:23:45.681]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.681]                       if (muffled) 
[13:23:45.681]                         invokeRestart("muffleMessage")
[13:23:45.681]                     }
[13:23:45.681]                     else if (inherits(cond, "warning")) {
[13:23:45.681]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.681]                       if (muffled) 
[13:23:45.681]                         invokeRestart("muffleWarning")
[13:23:45.681]                     }
[13:23:45.681]                     else if (inherits(cond, "condition")) {
[13:23:45.681]                       if (!is.null(pattern)) {
[13:23:45.681]                         computeRestarts <- base::computeRestarts
[13:23:45.681]                         grepl <- base::grepl
[13:23:45.681]                         restarts <- computeRestarts(cond)
[13:23:45.681]                         for (restart in restarts) {
[13:23:45.681]                           name <- restart$name
[13:23:45.681]                           if (is.null(name)) 
[13:23:45.681]                             next
[13:23:45.681]                           if (!grepl(pattern, name)) 
[13:23:45.681]                             next
[13:23:45.681]                           invokeRestart(restart)
[13:23:45.681]                           muffled <- TRUE
[13:23:45.681]                           break
[13:23:45.681]                         }
[13:23:45.681]                       }
[13:23:45.681]                     }
[13:23:45.681]                     invisible(muffled)
[13:23:45.681]                   }
[13:23:45.681]                   muffleCondition(cond)
[13:23:45.681]                 })
[13:23:45.681]             }))
[13:23:45.681]             future::FutureResult(value = ...future.value$value, 
[13:23:45.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.681]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.681]                     ...future.globalenv.names))
[13:23:45.681]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.681]         }, condition = base::local({
[13:23:45.681]             c <- base::c
[13:23:45.681]             inherits <- base::inherits
[13:23:45.681]             invokeRestart <- base::invokeRestart
[13:23:45.681]             length <- base::length
[13:23:45.681]             list <- base::list
[13:23:45.681]             seq.int <- base::seq.int
[13:23:45.681]             signalCondition <- base::signalCondition
[13:23:45.681]             sys.calls <- base::sys.calls
[13:23:45.681]             `[[` <- base::`[[`
[13:23:45.681]             `+` <- base::`+`
[13:23:45.681]             `<<-` <- base::`<<-`
[13:23:45.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.681]                   3L)]
[13:23:45.681]             }
[13:23:45.681]             function(cond) {
[13:23:45.681]                 is_error <- inherits(cond, "error")
[13:23:45.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.681]                   NULL)
[13:23:45.681]                 if (is_error) {
[13:23:45.681]                   sessionInformation <- function() {
[13:23:45.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.681]                       search = base::search(), system = base::Sys.info())
[13:23:45.681]                   }
[13:23:45.681]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.681]                     cond$call), session = sessionInformation(), 
[13:23:45.681]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.681]                   signalCondition(cond)
[13:23:45.681]                 }
[13:23:45.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.681]                 "immediateCondition"))) {
[13:23:45.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.681]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.681]                   if (TRUE && !signal) {
[13:23:45.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.681]                     {
[13:23:45.681]                       inherits <- base::inherits
[13:23:45.681]                       invokeRestart <- base::invokeRestart
[13:23:45.681]                       is.null <- base::is.null
[13:23:45.681]                       muffled <- FALSE
[13:23:45.681]                       if (inherits(cond, "message")) {
[13:23:45.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.681]                         if (muffled) 
[13:23:45.681]                           invokeRestart("muffleMessage")
[13:23:45.681]                       }
[13:23:45.681]                       else if (inherits(cond, "warning")) {
[13:23:45.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.681]                         if (muffled) 
[13:23:45.681]                           invokeRestart("muffleWarning")
[13:23:45.681]                       }
[13:23:45.681]                       else if (inherits(cond, "condition")) {
[13:23:45.681]                         if (!is.null(pattern)) {
[13:23:45.681]                           computeRestarts <- base::computeRestarts
[13:23:45.681]                           grepl <- base::grepl
[13:23:45.681]                           restarts <- computeRestarts(cond)
[13:23:45.681]                           for (restart in restarts) {
[13:23:45.681]                             name <- restart$name
[13:23:45.681]                             if (is.null(name)) 
[13:23:45.681]                               next
[13:23:45.681]                             if (!grepl(pattern, name)) 
[13:23:45.681]                               next
[13:23:45.681]                             invokeRestart(restart)
[13:23:45.681]                             muffled <- TRUE
[13:23:45.681]                             break
[13:23:45.681]                           }
[13:23:45.681]                         }
[13:23:45.681]                       }
[13:23:45.681]                       invisible(muffled)
[13:23:45.681]                     }
[13:23:45.681]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.681]                   }
[13:23:45.681]                 }
[13:23:45.681]                 else {
[13:23:45.681]                   if (TRUE) {
[13:23:45.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.681]                     {
[13:23:45.681]                       inherits <- base::inherits
[13:23:45.681]                       invokeRestart <- base::invokeRestart
[13:23:45.681]                       is.null <- base::is.null
[13:23:45.681]                       muffled <- FALSE
[13:23:45.681]                       if (inherits(cond, "message")) {
[13:23:45.681]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.681]                         if (muffled) 
[13:23:45.681]                           invokeRestart("muffleMessage")
[13:23:45.681]                       }
[13:23:45.681]                       else if (inherits(cond, "warning")) {
[13:23:45.681]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.681]                         if (muffled) 
[13:23:45.681]                           invokeRestart("muffleWarning")
[13:23:45.681]                       }
[13:23:45.681]                       else if (inherits(cond, "condition")) {
[13:23:45.681]                         if (!is.null(pattern)) {
[13:23:45.681]                           computeRestarts <- base::computeRestarts
[13:23:45.681]                           grepl <- base::grepl
[13:23:45.681]                           restarts <- computeRestarts(cond)
[13:23:45.681]                           for (restart in restarts) {
[13:23:45.681]                             name <- restart$name
[13:23:45.681]                             if (is.null(name)) 
[13:23:45.681]                               next
[13:23:45.681]                             if (!grepl(pattern, name)) 
[13:23:45.681]                               next
[13:23:45.681]                             invokeRestart(restart)
[13:23:45.681]                             muffled <- TRUE
[13:23:45.681]                             break
[13:23:45.681]                           }
[13:23:45.681]                         }
[13:23:45.681]                       }
[13:23:45.681]                       invisible(muffled)
[13:23:45.681]                     }
[13:23:45.681]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.681]                   }
[13:23:45.681]                 }
[13:23:45.681]             }
[13:23:45.681]         }))
[13:23:45.681]     }, error = function(ex) {
[13:23:45.681]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.681]                 ...future.rng), started = ...future.startTime, 
[13:23:45.681]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.681]             version = "1.8"), class = "FutureResult")
[13:23:45.681]     }, finally = {
[13:23:45.681]         if (!identical(...future.workdir, getwd())) 
[13:23:45.681]             setwd(...future.workdir)
[13:23:45.681]         {
[13:23:45.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.681]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.681]             }
[13:23:45.681]             base::options(...future.oldOptions)
[13:23:45.681]             if (.Platform$OS.type == "windows") {
[13:23:45.681]                 old_names <- names(...future.oldEnvVars)
[13:23:45.681]                 envs <- base::Sys.getenv()
[13:23:45.681]                 names <- names(envs)
[13:23:45.681]                 common <- intersect(names, old_names)
[13:23:45.681]                 added <- setdiff(names, old_names)
[13:23:45.681]                 removed <- setdiff(old_names, names)
[13:23:45.681]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.681]                   envs[common]]
[13:23:45.681]                 NAMES <- toupper(changed)
[13:23:45.681]                 args <- list()
[13:23:45.681]                 for (kk in seq_along(NAMES)) {
[13:23:45.681]                   name <- changed[[kk]]
[13:23:45.681]                   NAME <- NAMES[[kk]]
[13:23:45.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.681]                     next
[13:23:45.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.681]                 }
[13:23:45.681]                 NAMES <- toupper(added)
[13:23:45.681]                 for (kk in seq_along(NAMES)) {
[13:23:45.681]                   name <- added[[kk]]
[13:23:45.681]                   NAME <- NAMES[[kk]]
[13:23:45.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.681]                     next
[13:23:45.681]                   args[[name]] <- ""
[13:23:45.681]                 }
[13:23:45.681]                 NAMES <- toupper(removed)
[13:23:45.681]                 for (kk in seq_along(NAMES)) {
[13:23:45.681]                   name <- removed[[kk]]
[13:23:45.681]                   NAME <- NAMES[[kk]]
[13:23:45.681]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.681]                     next
[13:23:45.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.681]                 }
[13:23:45.681]                 if (length(args) > 0) 
[13:23:45.681]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.681]             }
[13:23:45.681]             else {
[13:23:45.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.681]             }
[13:23:45.681]             {
[13:23:45.681]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.681]                   0L) {
[13:23:45.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.681]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.681]                   base::options(opts)
[13:23:45.681]                 }
[13:23:45.681]                 {
[13:23:45.681]                   {
[13:23:45.681]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.681]                     NULL
[13:23:45.681]                   }
[13:23:45.681]                   options(future.plan = NULL)
[13:23:45.681]                   if (is.na(NA_character_)) 
[13:23:45.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.681]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.681]                     envir = parent.frame()) 
[13:23:45.681]                   {
[13:23:45.681]                     default_workers <- missing(workers)
[13:23:45.681]                     if (is.function(workers)) 
[13:23:45.681]                       workers <- workers()
[13:23:45.681]                     workers <- structure(as.integer(workers), 
[13:23:45.681]                       class = class(workers))
[13:23:45.681]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.681]                       1L)
[13:23:45.681]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.681]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.681]                       if (default_workers) 
[13:23:45.681]                         supportsMulticore(warn = TRUE)
[13:23:45.681]                       return(sequential(..., envir = envir))
[13:23:45.681]                     }
[13:23:45.681]                     oopts <- options(mc.cores = workers)
[13:23:45.681]                     on.exit(options(oopts))
[13:23:45.681]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.681]                       envir = envir)
[13:23:45.681]                     if (!future$lazy) 
[13:23:45.681]                       future <- run(future)
[13:23:45.681]                     invisible(future)
[13:23:45.681]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.681]                 }
[13:23:45.681]             }
[13:23:45.681]         }
[13:23:45.681]     })
[13:23:45.681]     if (TRUE) {
[13:23:45.681]         base::sink(type = "output", split = FALSE)
[13:23:45.681]         if (TRUE) {
[13:23:45.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.681]         }
[13:23:45.681]         else {
[13:23:45.681]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.681]         }
[13:23:45.681]         base::close(...future.stdout)
[13:23:45.681]         ...future.stdout <- NULL
[13:23:45.681]     }
[13:23:45.681]     ...future.result$conditions <- ...future.conditions
[13:23:45.681]     ...future.result$finished <- base::Sys.time()
[13:23:45.681]     ...future.result
[13:23:45.681] }
[13:23:45.684] requestCore(): workers = 2
[13:23:45.684] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:45.695] result() for MulticoreFuture ...
[13:23:45.696] result() for MulticoreFuture ...
[13:23:45.696] result() for MulticoreFuture ... done
[13:23:45.696] result() for MulticoreFuture ... done
[13:23:45.697] result() for MulticoreFuture ...
[13:23:45.697] result() for MulticoreFuture ... done
[13:23:45.699] MulticoreFuture started
 - Creating multicore future #4 ...
[13:23:45.700] plan(): Setting new future strategy stack:
[13:23:45.700] List of future strategies:
[13:23:45.700] 1. sequential:
[13:23:45.700]    - args: function (..., envir = parent.frame())
[13:23:45.700]    - tweaked: FALSE
[13:23:45.700]    - call: NULL
[13:23:45.701] plan(): nbrOfWorkers() = 1
[13:23:45.703] plan(): Setting new future strategy stack:
[13:23:45.703] List of future strategies:
[13:23:45.703] 1. multicore:
[13:23:45.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.703]    - tweaked: FALSE
[13:23:45.703]    - call: plan(multicore)
[13:23:45.705] getGlobalsAndPackages() ...
[13:23:45.705] Not searching for globals
[13:23:45.705] - globals: [0] <none>
[13:23:45.705] getGlobalsAndPackages() ... DONE
[13:23:45.706] Packages needed by the future expression (n = 0): <none>
[13:23:45.706] Packages needed by future strategies (n = 0): <none>
[13:23:45.708] plan(): nbrOfWorkers() = 2
[13:23:45.707] {
[13:23:45.707]     {
[13:23:45.707]         {
[13:23:45.707]             ...future.startTime <- base::Sys.time()
[13:23:45.707]             {
[13:23:45.707]                 {
[13:23:45.707]                   {
[13:23:45.707]                     {
[13:23:45.707]                       base::local({
[13:23:45.707]                         has_future <- base::requireNamespace("future", 
[13:23:45.707]                           quietly = TRUE)
[13:23:45.707]                         if (has_future) {
[13:23:45.707]                           ns <- base::getNamespace("future")
[13:23:45.707]                           version <- ns[[".package"]][["version"]]
[13:23:45.707]                           if (is.null(version)) 
[13:23:45.707]                             version <- utils::packageVersion("future")
[13:23:45.707]                         }
[13:23:45.707]                         else {
[13:23:45.707]                           version <- NULL
[13:23:45.707]                         }
[13:23:45.707]                         if (!has_future || version < "1.8.0") {
[13:23:45.707]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.707]                             "", base::R.version$version.string), 
[13:23:45.707]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.707]                               "release", "version")], collapse = " "), 
[13:23:45.707]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.707]                             info)
[13:23:45.707]                           info <- base::paste(info, collapse = "; ")
[13:23:45.707]                           if (!has_future) {
[13:23:45.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.707]                               info)
[13:23:45.707]                           }
[13:23:45.707]                           else {
[13:23:45.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.707]                               info, version)
[13:23:45.707]                           }
[13:23:45.707]                           base::stop(msg)
[13:23:45.707]                         }
[13:23:45.707]                       })
[13:23:45.707]                     }
[13:23:45.707]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.707]                     base::options(mc.cores = 1L)
[13:23:45.707]                   }
[13:23:45.707]                   options(future.plan = NULL)
[13:23:45.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.707]                 }
[13:23:45.707]                 ...future.workdir <- getwd()
[13:23:45.707]             }
[13:23:45.707]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.707]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.707]         }
[13:23:45.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.707]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.707]             base::names(...future.oldOptions))
[13:23:45.707]     }
[13:23:45.707]     if (FALSE) {
[13:23:45.707]     }
[13:23:45.707]     else {
[13:23:45.707]         if (TRUE) {
[13:23:45.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.707]                 open = "w")
[13:23:45.707]         }
[13:23:45.707]         else {
[13:23:45.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.707]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.707]         }
[13:23:45.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.707]             base::sink(type = "output", split = FALSE)
[13:23:45.707]             base::close(...future.stdout)
[13:23:45.707]         }, add = TRUE)
[13:23:45.707]     }
[13:23:45.707]     ...future.frame <- base::sys.nframe()
[13:23:45.707]     ...future.conditions <- base::list()
[13:23:45.707]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.707]     if (FALSE) {
[13:23:45.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.707]     }
[13:23:45.707]     ...future.result <- base::tryCatch({
[13:23:45.707]         base::withCallingHandlers({
[13:23:45.707]             ...future.value <- base::withVisible(base::local({
[13:23:45.707]                 withCallingHandlers({
[13:23:45.707]                   {
[13:23:45.707]                     ii
[13:23:45.707]                   }
[13:23:45.707]                 }, immediateCondition = function(cond) {
[13:23:45.707]                   save_rds <- function (object, pathname, ...) 
[13:23:45.707]                   {
[13:23:45.707]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.707]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.707]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.707]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.707]                         fi_tmp[["mtime"]])
[13:23:45.707]                     }
[13:23:45.707]                     tryCatch({
[13:23:45.707]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.707]                     }, error = function(ex) {
[13:23:45.707]                       msg <- conditionMessage(ex)
[13:23:45.707]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.707]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.707]                         fi_tmp[["mtime"]], msg)
[13:23:45.707]                       ex$message <- msg
[13:23:45.707]                       stop(ex)
[13:23:45.707]                     })
[13:23:45.707]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.707]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.707]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.707]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.707]                       fi <- file.info(pathname)
[13:23:45.707]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.707]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.707]                         fi[["size"]], fi[["mtime"]])
[13:23:45.707]                       stop(msg)
[13:23:45.707]                     }
[13:23:45.707]                     invisible(pathname)
[13:23:45.707]                   }
[13:23:45.707]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.707]                     rootPath = tempdir()) 
[13:23:45.707]                   {
[13:23:45.707]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.707]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.707]                       tmpdir = path, fileext = ".rds")
[13:23:45.707]                     save_rds(obj, file)
[13:23:45.707]                   }
[13:23:45.707]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.707]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.707]                   {
[13:23:45.707]                     inherits <- base::inherits
[13:23:45.707]                     invokeRestart <- base::invokeRestart
[13:23:45.707]                     is.null <- base::is.null
[13:23:45.707]                     muffled <- FALSE
[13:23:45.707]                     if (inherits(cond, "message")) {
[13:23:45.707]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.707]                       if (muffled) 
[13:23:45.707]                         invokeRestart("muffleMessage")
[13:23:45.707]                     }
[13:23:45.707]                     else if (inherits(cond, "warning")) {
[13:23:45.707]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.707]                       if (muffled) 
[13:23:45.707]                         invokeRestart("muffleWarning")
[13:23:45.707]                     }
[13:23:45.707]                     else if (inherits(cond, "condition")) {
[13:23:45.707]                       if (!is.null(pattern)) {
[13:23:45.707]                         computeRestarts <- base::computeRestarts
[13:23:45.707]                         grepl <- base::grepl
[13:23:45.707]                         restarts <- computeRestarts(cond)
[13:23:45.707]                         for (restart in restarts) {
[13:23:45.707]                           name <- restart$name
[13:23:45.707]                           if (is.null(name)) 
[13:23:45.707]                             next
[13:23:45.707]                           if (!grepl(pattern, name)) 
[13:23:45.707]                             next
[13:23:45.707]                           invokeRestart(restart)
[13:23:45.707]                           muffled <- TRUE
[13:23:45.707]                           break
[13:23:45.707]                         }
[13:23:45.707]                       }
[13:23:45.707]                     }
[13:23:45.707]                     invisible(muffled)
[13:23:45.707]                   }
[13:23:45.707]                   muffleCondition(cond)
[13:23:45.707]                 })
[13:23:45.707]             }))
[13:23:45.707]             future::FutureResult(value = ...future.value$value, 
[13:23:45.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.707]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.707]                     ...future.globalenv.names))
[13:23:45.707]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.707]         }, condition = base::local({
[13:23:45.707]             c <- base::c
[13:23:45.707]             inherits <- base::inherits
[13:23:45.707]             invokeRestart <- base::invokeRestart
[13:23:45.707]             length <- base::length
[13:23:45.707]             list <- base::list
[13:23:45.707]             seq.int <- base::seq.int
[13:23:45.707]             signalCondition <- base::signalCondition
[13:23:45.707]             sys.calls <- base::sys.calls
[13:23:45.707]             `[[` <- base::`[[`
[13:23:45.707]             `+` <- base::`+`
[13:23:45.707]             `<<-` <- base::`<<-`
[13:23:45.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.707]                   3L)]
[13:23:45.707]             }
[13:23:45.707]             function(cond) {
[13:23:45.707]                 is_error <- inherits(cond, "error")
[13:23:45.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.707]                   NULL)
[13:23:45.707]                 if (is_error) {
[13:23:45.707]                   sessionInformation <- function() {
[13:23:45.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.707]                       search = base::search(), system = base::Sys.info())
[13:23:45.707]                   }
[13:23:45.707]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.707]                     cond$call), session = sessionInformation(), 
[13:23:45.707]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.707]                   signalCondition(cond)
[13:23:45.707]                 }
[13:23:45.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.707]                 "immediateCondition"))) {
[13:23:45.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.707]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.707]                   if (TRUE && !signal) {
[13:23:45.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.707]                     {
[13:23:45.707]                       inherits <- base::inherits
[13:23:45.707]                       invokeRestart <- base::invokeRestart
[13:23:45.707]                       is.null <- base::is.null
[13:23:45.707]                       muffled <- FALSE
[13:23:45.707]                       if (inherits(cond, "message")) {
[13:23:45.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.707]                         if (muffled) 
[13:23:45.707]                           invokeRestart("muffleMessage")
[13:23:45.707]                       }
[13:23:45.707]                       else if (inherits(cond, "warning")) {
[13:23:45.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.707]                         if (muffled) 
[13:23:45.707]                           invokeRestart("muffleWarning")
[13:23:45.707]                       }
[13:23:45.707]                       else if (inherits(cond, "condition")) {
[13:23:45.707]                         if (!is.null(pattern)) {
[13:23:45.707]                           computeRestarts <- base::computeRestarts
[13:23:45.707]                           grepl <- base::grepl
[13:23:45.707]                           restarts <- computeRestarts(cond)
[13:23:45.707]                           for (restart in restarts) {
[13:23:45.707]                             name <- restart$name
[13:23:45.707]                             if (is.null(name)) 
[13:23:45.707]                               next
[13:23:45.707]                             if (!grepl(pattern, name)) 
[13:23:45.707]                               next
[13:23:45.707]                             invokeRestart(restart)
[13:23:45.707]                             muffled <- TRUE
[13:23:45.707]                             break
[13:23:45.707]                           }
[13:23:45.707]                         }
[13:23:45.707]                       }
[13:23:45.707]                       invisible(muffled)
[13:23:45.707]                     }
[13:23:45.707]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.707]                   }
[13:23:45.707]                 }
[13:23:45.707]                 else {
[13:23:45.707]                   if (TRUE) {
[13:23:45.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.707]                     {
[13:23:45.707]                       inherits <- base::inherits
[13:23:45.707]                       invokeRestart <- base::invokeRestart
[13:23:45.707]                       is.null <- base::is.null
[13:23:45.707]                       muffled <- FALSE
[13:23:45.707]                       if (inherits(cond, "message")) {
[13:23:45.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.707]                         if (muffled) 
[13:23:45.707]                           invokeRestart("muffleMessage")
[13:23:45.707]                       }
[13:23:45.707]                       else if (inherits(cond, "warning")) {
[13:23:45.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.707]                         if (muffled) 
[13:23:45.707]                           invokeRestart("muffleWarning")
[13:23:45.707]                       }
[13:23:45.707]                       else if (inherits(cond, "condition")) {
[13:23:45.707]                         if (!is.null(pattern)) {
[13:23:45.707]                           computeRestarts <- base::computeRestarts
[13:23:45.707]                           grepl <- base::grepl
[13:23:45.707]                           restarts <- computeRestarts(cond)
[13:23:45.707]                           for (restart in restarts) {
[13:23:45.707]                             name <- restart$name
[13:23:45.707]                             if (is.null(name)) 
[13:23:45.707]                               next
[13:23:45.707]                             if (!grepl(pattern, name)) 
[13:23:45.707]                               next
[13:23:45.707]                             invokeRestart(restart)
[13:23:45.707]                             muffled <- TRUE
[13:23:45.707]                             break
[13:23:45.707]                           }
[13:23:45.707]                         }
[13:23:45.707]                       }
[13:23:45.707]                       invisible(muffled)
[13:23:45.707]                     }
[13:23:45.707]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.707]                   }
[13:23:45.707]                 }
[13:23:45.707]             }
[13:23:45.707]         }))
[13:23:45.707]     }, error = function(ex) {
[13:23:45.707]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.707]                 ...future.rng), started = ...future.startTime, 
[13:23:45.707]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.707]             version = "1.8"), class = "FutureResult")
[13:23:45.707]     }, finally = {
[13:23:45.707]         if (!identical(...future.workdir, getwd())) 
[13:23:45.707]             setwd(...future.workdir)
[13:23:45.707]         {
[13:23:45.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.707]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.707]             }
[13:23:45.707]             base::options(...future.oldOptions)
[13:23:45.707]             if (.Platform$OS.type == "windows") {
[13:23:45.707]                 old_names <- names(...future.oldEnvVars)
[13:23:45.707]                 envs <- base::Sys.getenv()
[13:23:45.707]                 names <- names(envs)
[13:23:45.707]                 common <- intersect(names, old_names)
[13:23:45.707]                 added <- setdiff(names, old_names)
[13:23:45.707]                 removed <- setdiff(old_names, names)
[13:23:45.707]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.707]                   envs[common]]
[13:23:45.707]                 NAMES <- toupper(changed)
[13:23:45.707]                 args <- list()
[13:23:45.707]                 for (kk in seq_along(NAMES)) {
[13:23:45.707]                   name <- changed[[kk]]
[13:23:45.707]                   NAME <- NAMES[[kk]]
[13:23:45.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.707]                     next
[13:23:45.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.707]                 }
[13:23:45.707]                 NAMES <- toupper(added)
[13:23:45.707]                 for (kk in seq_along(NAMES)) {
[13:23:45.707]                   name <- added[[kk]]
[13:23:45.707]                   NAME <- NAMES[[kk]]
[13:23:45.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.707]                     next
[13:23:45.707]                   args[[name]] <- ""
[13:23:45.707]                 }
[13:23:45.707]                 NAMES <- toupper(removed)
[13:23:45.707]                 for (kk in seq_along(NAMES)) {
[13:23:45.707]                   name <- removed[[kk]]
[13:23:45.707]                   NAME <- NAMES[[kk]]
[13:23:45.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.707]                     next
[13:23:45.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.707]                 }
[13:23:45.707]                 if (length(args) > 0) 
[13:23:45.707]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.707]             }
[13:23:45.707]             else {
[13:23:45.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.707]             }
[13:23:45.707]             {
[13:23:45.707]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.707]                   0L) {
[13:23:45.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.707]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.707]                   base::options(opts)
[13:23:45.707]                 }
[13:23:45.707]                 {
[13:23:45.707]                   {
[13:23:45.707]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.707]                     NULL
[13:23:45.707]                   }
[13:23:45.707]                   options(future.plan = NULL)
[13:23:45.707]                   if (is.na(NA_character_)) 
[13:23:45.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.707]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.707]                     envir = parent.frame()) 
[13:23:45.707]                   {
[13:23:45.707]                     default_workers <- missing(workers)
[13:23:45.707]                     if (is.function(workers)) 
[13:23:45.707]                       workers <- workers()
[13:23:45.707]                     workers <- structure(as.integer(workers), 
[13:23:45.707]                       class = class(workers))
[13:23:45.707]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.707]                       1L)
[13:23:45.707]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.707]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.707]                       if (default_workers) 
[13:23:45.707]                         supportsMulticore(warn = TRUE)
[13:23:45.707]                       return(sequential(..., envir = envir))
[13:23:45.707]                     }
[13:23:45.707]                     oopts <- options(mc.cores = workers)
[13:23:45.707]                     on.exit(options(oopts))
[13:23:45.707]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.707]                       envir = envir)
[13:23:45.707]                     if (!future$lazy) 
[13:23:45.707]                       future <- run(future)
[13:23:45.707]                     invisible(future)
[13:23:45.707]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.707]                 }
[13:23:45.707]             }
[13:23:45.707]         }
[13:23:45.707]     })
[13:23:45.707]     if (TRUE) {
[13:23:45.707]         base::sink(type = "output", split = FALSE)
[13:23:45.707]         if (TRUE) {
[13:23:45.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.707]         }
[13:23:45.707]         else {
[13:23:45.707]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.707]         }
[13:23:45.707]         base::close(...future.stdout)
[13:23:45.707]         ...future.stdout <- NULL
[13:23:45.707]     }
[13:23:45.707]     ...future.result$conditions <- ...future.conditions
[13:23:45.707]     ...future.result$finished <- base::Sys.time()
[13:23:45.707]     ...future.result
[13:23:45.707] }
[13:23:45.717] requestCore(): workers = 2
[13:23:45.718] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:45.742] result() for MulticoreFuture ...
[13:23:45.743] result() for MulticoreFuture ...
[13:23:45.743] result() for MulticoreFuture ... done
[13:23:45.743] result() for MulticoreFuture ... done
[13:23:45.743] result() for MulticoreFuture ...
[13:23:45.743] result() for MulticoreFuture ... done
[13:23:45.746] MulticoreFuture started
 - Resolving 4 multicore futures
[13:23:45.747] result() for MulticoreFuture ...
[13:23:45.747] result() for MulticoreFuture ... done
[13:23:45.747] plan(): Setting new future strategy stack:
[13:23:45.747] result() for MulticoreFuture ...
[13:23:45.748] result() for MulticoreFuture ... done
[13:23:45.748] result() for MulticoreFuture ...
[13:23:45.748] result() for MulticoreFuture ... done
[13:23:45.747] List of future strategies:
[13:23:45.747] 1. sequential:
[13:23:45.747]    - args: function (..., envir = parent.frame())
[13:23:45.747]    - tweaked: FALSE
[13:23:45.747]    - call: NULL
[13:23:45.748] result() for MulticoreFuture ...
[13:23:45.749] result() for MulticoreFuture ... done
[13:23:45.749] plan(): nbrOfWorkers() = 1
[13:23:45.749] result() for MulticoreFuture ...
[13:23:45.751] result() for MulticoreFuture ...
[13:23:45.751] result() for MulticoreFuture ... done
[13:23:45.751] result() for MulticoreFuture ... done
[13:23:45.751] plan(): Setting new future strategy stack:
[13:23:45.751] result() for MulticoreFuture ...
[13:23:45.751] result() for MulticoreFuture ... done
[13:23:45.752] result() for MulticoreFuture ...
[13:23:45.751] List of future strategies:
[13:23:45.751] 1. multicore:
[13:23:45.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.751]    - tweaked: FALSE
[13:23:45.751]    - call: plan(multicore)
[13:23:45.756] plan(): nbrOfWorkers() = 2
[13:23:45.757] result() for MulticoreFuture ...
[13:23:45.757] result() for MulticoreFuture ... done
[13:23:45.757] result() for MulticoreFuture ... done
[13:23:45.757] result() for MulticoreFuture ...
[13:23:45.758] result() for MulticoreFuture ... done
*** multicore(..., globals = FALSE) and errors
[13:23:45.762] getGlobalsAndPackages() ...
[13:23:45.762] Not searching for globals
[13:23:45.762] - globals: [0] <none>
[13:23:45.762] getGlobalsAndPackages() ... DONE
[13:23:45.763] Packages needed by the future expression (n = 0): <none>
[13:23:45.763] Packages needed by future strategies (n = 0): <none>
[13:23:45.764] {
[13:23:45.764]     {
[13:23:45.764]         {
[13:23:45.764]             ...future.startTime <- base::Sys.time()
[13:23:45.764]             {
[13:23:45.764]                 {
[13:23:45.764]                   {
[13:23:45.764]                     {
[13:23:45.764]                       base::local({
[13:23:45.764]                         has_future <- base::requireNamespace("future", 
[13:23:45.764]                           quietly = TRUE)
[13:23:45.764]                         if (has_future) {
[13:23:45.764]                           ns <- base::getNamespace("future")
[13:23:45.764]                           version <- ns[[".package"]][["version"]]
[13:23:45.764]                           if (is.null(version)) 
[13:23:45.764]                             version <- utils::packageVersion("future")
[13:23:45.764]                         }
[13:23:45.764]                         else {
[13:23:45.764]                           version <- NULL
[13:23:45.764]                         }
[13:23:45.764]                         if (!has_future || version < "1.8.0") {
[13:23:45.764]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.764]                             "", base::R.version$version.string), 
[13:23:45.764]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.764]                               "release", "version")], collapse = " "), 
[13:23:45.764]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.764]                             info)
[13:23:45.764]                           info <- base::paste(info, collapse = "; ")
[13:23:45.764]                           if (!has_future) {
[13:23:45.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.764]                               info)
[13:23:45.764]                           }
[13:23:45.764]                           else {
[13:23:45.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.764]                               info, version)
[13:23:45.764]                           }
[13:23:45.764]                           base::stop(msg)
[13:23:45.764]                         }
[13:23:45.764]                       })
[13:23:45.764]                     }
[13:23:45.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.764]                     base::options(mc.cores = 1L)
[13:23:45.764]                   }
[13:23:45.764]                   options(future.plan = NULL)
[13:23:45.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.764]                 }
[13:23:45.764]                 ...future.workdir <- getwd()
[13:23:45.764]             }
[13:23:45.764]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.764]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.764]         }
[13:23:45.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.764]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.764]             base::names(...future.oldOptions))
[13:23:45.764]     }
[13:23:45.764]     if (FALSE) {
[13:23:45.764]     }
[13:23:45.764]     else {
[13:23:45.764]         if (TRUE) {
[13:23:45.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.764]                 open = "w")
[13:23:45.764]         }
[13:23:45.764]         else {
[13:23:45.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.764]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.764]         }
[13:23:45.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.764]             base::sink(type = "output", split = FALSE)
[13:23:45.764]             base::close(...future.stdout)
[13:23:45.764]         }, add = TRUE)
[13:23:45.764]     }
[13:23:45.764]     ...future.frame <- base::sys.nframe()
[13:23:45.764]     ...future.conditions <- base::list()
[13:23:45.764]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.764]     if (FALSE) {
[13:23:45.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.764]     }
[13:23:45.764]     ...future.result <- base::tryCatch({
[13:23:45.764]         base::withCallingHandlers({
[13:23:45.764]             ...future.value <- base::withVisible(base::local({
[13:23:45.764]                 withCallingHandlers({
[13:23:45.764]                   {
[13:23:45.764]                     stop("Whoops!")
[13:23:45.764]                     1
[13:23:45.764]                   }
[13:23:45.764]                 }, immediateCondition = function(cond) {
[13:23:45.764]                   save_rds <- function (object, pathname, ...) 
[13:23:45.764]                   {
[13:23:45.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.764]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.764]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.764]                         fi_tmp[["mtime"]])
[13:23:45.764]                     }
[13:23:45.764]                     tryCatch({
[13:23:45.764]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.764]                     }, error = function(ex) {
[13:23:45.764]                       msg <- conditionMessage(ex)
[13:23:45.764]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.764]                         fi_tmp[["mtime"]], msg)
[13:23:45.764]                       ex$message <- msg
[13:23:45.764]                       stop(ex)
[13:23:45.764]                     })
[13:23:45.764]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.764]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.764]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.764]                       fi <- file.info(pathname)
[13:23:45.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.764]                         fi[["size"]], fi[["mtime"]])
[13:23:45.764]                       stop(msg)
[13:23:45.764]                     }
[13:23:45.764]                     invisible(pathname)
[13:23:45.764]                   }
[13:23:45.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.764]                     rootPath = tempdir()) 
[13:23:45.764]                   {
[13:23:45.764]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.764]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.764]                       tmpdir = path, fileext = ".rds")
[13:23:45.764]                     save_rds(obj, file)
[13:23:45.764]                   }
[13:23:45.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.764]                   {
[13:23:45.764]                     inherits <- base::inherits
[13:23:45.764]                     invokeRestart <- base::invokeRestart
[13:23:45.764]                     is.null <- base::is.null
[13:23:45.764]                     muffled <- FALSE
[13:23:45.764]                     if (inherits(cond, "message")) {
[13:23:45.764]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.764]                       if (muffled) 
[13:23:45.764]                         invokeRestart("muffleMessage")
[13:23:45.764]                     }
[13:23:45.764]                     else if (inherits(cond, "warning")) {
[13:23:45.764]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.764]                       if (muffled) 
[13:23:45.764]                         invokeRestart("muffleWarning")
[13:23:45.764]                     }
[13:23:45.764]                     else if (inherits(cond, "condition")) {
[13:23:45.764]                       if (!is.null(pattern)) {
[13:23:45.764]                         computeRestarts <- base::computeRestarts
[13:23:45.764]                         grepl <- base::grepl
[13:23:45.764]                         restarts <- computeRestarts(cond)
[13:23:45.764]                         for (restart in restarts) {
[13:23:45.764]                           name <- restart$name
[13:23:45.764]                           if (is.null(name)) 
[13:23:45.764]                             next
[13:23:45.764]                           if (!grepl(pattern, name)) 
[13:23:45.764]                             next
[13:23:45.764]                           invokeRestart(restart)
[13:23:45.764]                           muffled <- TRUE
[13:23:45.764]                           break
[13:23:45.764]                         }
[13:23:45.764]                       }
[13:23:45.764]                     }
[13:23:45.764]                     invisible(muffled)
[13:23:45.764]                   }
[13:23:45.764]                   muffleCondition(cond)
[13:23:45.764]                 })
[13:23:45.764]             }))
[13:23:45.764]             future::FutureResult(value = ...future.value$value, 
[13:23:45.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.764]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.764]                     ...future.globalenv.names))
[13:23:45.764]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.764]         }, condition = base::local({
[13:23:45.764]             c <- base::c
[13:23:45.764]             inherits <- base::inherits
[13:23:45.764]             invokeRestart <- base::invokeRestart
[13:23:45.764]             length <- base::length
[13:23:45.764]             list <- base::list
[13:23:45.764]             seq.int <- base::seq.int
[13:23:45.764]             signalCondition <- base::signalCondition
[13:23:45.764]             sys.calls <- base::sys.calls
[13:23:45.764]             `[[` <- base::`[[`
[13:23:45.764]             `+` <- base::`+`
[13:23:45.764]             `<<-` <- base::`<<-`
[13:23:45.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.764]                   3L)]
[13:23:45.764]             }
[13:23:45.764]             function(cond) {
[13:23:45.764]                 is_error <- inherits(cond, "error")
[13:23:45.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.764]                   NULL)
[13:23:45.764]                 if (is_error) {
[13:23:45.764]                   sessionInformation <- function() {
[13:23:45.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.764]                       search = base::search(), system = base::Sys.info())
[13:23:45.764]                   }
[13:23:45.764]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.764]                     cond$call), session = sessionInformation(), 
[13:23:45.764]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.764]                   signalCondition(cond)
[13:23:45.764]                 }
[13:23:45.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.764]                 "immediateCondition"))) {
[13:23:45.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.764]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.764]                   if (TRUE && !signal) {
[13:23:45.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.764]                     {
[13:23:45.764]                       inherits <- base::inherits
[13:23:45.764]                       invokeRestart <- base::invokeRestart
[13:23:45.764]                       is.null <- base::is.null
[13:23:45.764]                       muffled <- FALSE
[13:23:45.764]                       if (inherits(cond, "message")) {
[13:23:45.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.764]                         if (muffled) 
[13:23:45.764]                           invokeRestart("muffleMessage")
[13:23:45.764]                       }
[13:23:45.764]                       else if (inherits(cond, "warning")) {
[13:23:45.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.764]                         if (muffled) 
[13:23:45.764]                           invokeRestart("muffleWarning")
[13:23:45.764]                       }
[13:23:45.764]                       else if (inherits(cond, "condition")) {
[13:23:45.764]                         if (!is.null(pattern)) {
[13:23:45.764]                           computeRestarts <- base::computeRestarts
[13:23:45.764]                           grepl <- base::grepl
[13:23:45.764]                           restarts <- computeRestarts(cond)
[13:23:45.764]                           for (restart in restarts) {
[13:23:45.764]                             name <- restart$name
[13:23:45.764]                             if (is.null(name)) 
[13:23:45.764]                               next
[13:23:45.764]                             if (!grepl(pattern, name)) 
[13:23:45.764]                               next
[13:23:45.764]                             invokeRestart(restart)
[13:23:45.764]                             muffled <- TRUE
[13:23:45.764]                             break
[13:23:45.764]                           }
[13:23:45.764]                         }
[13:23:45.764]                       }
[13:23:45.764]                       invisible(muffled)
[13:23:45.764]                     }
[13:23:45.764]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.764]                   }
[13:23:45.764]                 }
[13:23:45.764]                 else {
[13:23:45.764]                   if (TRUE) {
[13:23:45.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.764]                     {
[13:23:45.764]                       inherits <- base::inherits
[13:23:45.764]                       invokeRestart <- base::invokeRestart
[13:23:45.764]                       is.null <- base::is.null
[13:23:45.764]                       muffled <- FALSE
[13:23:45.764]                       if (inherits(cond, "message")) {
[13:23:45.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.764]                         if (muffled) 
[13:23:45.764]                           invokeRestart("muffleMessage")
[13:23:45.764]                       }
[13:23:45.764]                       else if (inherits(cond, "warning")) {
[13:23:45.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.764]                         if (muffled) 
[13:23:45.764]                           invokeRestart("muffleWarning")
[13:23:45.764]                       }
[13:23:45.764]                       else if (inherits(cond, "condition")) {
[13:23:45.764]                         if (!is.null(pattern)) {
[13:23:45.764]                           computeRestarts <- base::computeRestarts
[13:23:45.764]                           grepl <- base::grepl
[13:23:45.764]                           restarts <- computeRestarts(cond)
[13:23:45.764]                           for (restart in restarts) {
[13:23:45.764]                             name <- restart$name
[13:23:45.764]                             if (is.null(name)) 
[13:23:45.764]                               next
[13:23:45.764]                             if (!grepl(pattern, name)) 
[13:23:45.764]                               next
[13:23:45.764]                             invokeRestart(restart)
[13:23:45.764]                             muffled <- TRUE
[13:23:45.764]                             break
[13:23:45.764]                           }
[13:23:45.764]                         }
[13:23:45.764]                       }
[13:23:45.764]                       invisible(muffled)
[13:23:45.764]                     }
[13:23:45.764]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.764]                   }
[13:23:45.764]                 }
[13:23:45.764]             }
[13:23:45.764]         }))
[13:23:45.764]     }, error = function(ex) {
[13:23:45.764]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.764]                 ...future.rng), started = ...future.startTime, 
[13:23:45.764]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.764]             version = "1.8"), class = "FutureResult")
[13:23:45.764]     }, finally = {
[13:23:45.764]         if (!identical(...future.workdir, getwd())) 
[13:23:45.764]             setwd(...future.workdir)
[13:23:45.764]         {
[13:23:45.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.764]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.764]             }
[13:23:45.764]             base::options(...future.oldOptions)
[13:23:45.764]             if (.Platform$OS.type == "windows") {
[13:23:45.764]                 old_names <- names(...future.oldEnvVars)
[13:23:45.764]                 envs <- base::Sys.getenv()
[13:23:45.764]                 names <- names(envs)
[13:23:45.764]                 common <- intersect(names, old_names)
[13:23:45.764]                 added <- setdiff(names, old_names)
[13:23:45.764]                 removed <- setdiff(old_names, names)
[13:23:45.764]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.764]                   envs[common]]
[13:23:45.764]                 NAMES <- toupper(changed)
[13:23:45.764]                 args <- list()
[13:23:45.764]                 for (kk in seq_along(NAMES)) {
[13:23:45.764]                   name <- changed[[kk]]
[13:23:45.764]                   NAME <- NAMES[[kk]]
[13:23:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.764]                     next
[13:23:45.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.764]                 }
[13:23:45.764]                 NAMES <- toupper(added)
[13:23:45.764]                 for (kk in seq_along(NAMES)) {
[13:23:45.764]                   name <- added[[kk]]
[13:23:45.764]                   NAME <- NAMES[[kk]]
[13:23:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.764]                     next
[13:23:45.764]                   args[[name]] <- ""
[13:23:45.764]                 }
[13:23:45.764]                 NAMES <- toupper(removed)
[13:23:45.764]                 for (kk in seq_along(NAMES)) {
[13:23:45.764]                   name <- removed[[kk]]
[13:23:45.764]                   NAME <- NAMES[[kk]]
[13:23:45.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.764]                     next
[13:23:45.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.764]                 }
[13:23:45.764]                 if (length(args) > 0) 
[13:23:45.764]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.764]             }
[13:23:45.764]             else {
[13:23:45.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.764]             }
[13:23:45.764]             {
[13:23:45.764]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.764]                   0L) {
[13:23:45.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.764]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.764]                   base::options(opts)
[13:23:45.764]                 }
[13:23:45.764]                 {
[13:23:45.764]                   {
[13:23:45.764]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.764]                     NULL
[13:23:45.764]                   }
[13:23:45.764]                   options(future.plan = NULL)
[13:23:45.764]                   if (is.na(NA_character_)) 
[13:23:45.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.764]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.764]                     envir = parent.frame()) 
[13:23:45.764]                   {
[13:23:45.764]                     default_workers <- missing(workers)
[13:23:45.764]                     if (is.function(workers)) 
[13:23:45.764]                       workers <- workers()
[13:23:45.764]                     workers <- structure(as.integer(workers), 
[13:23:45.764]                       class = class(workers))
[13:23:45.764]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.764]                       1L)
[13:23:45.764]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.764]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.764]                       if (default_workers) 
[13:23:45.764]                         supportsMulticore(warn = TRUE)
[13:23:45.764]                       return(sequential(..., envir = envir))
[13:23:45.764]                     }
[13:23:45.764]                     oopts <- options(mc.cores = workers)
[13:23:45.764]                     on.exit(options(oopts))
[13:23:45.764]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.764]                       envir = envir)
[13:23:45.764]                     if (!future$lazy) 
[13:23:45.764]                       future <- run(future)
[13:23:45.764]                     invisible(future)
[13:23:45.764]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.764]                 }
[13:23:45.764]             }
[13:23:45.764]         }
[13:23:45.764]     })
[13:23:45.764]     if (TRUE) {
[13:23:45.764]         base::sink(type = "output", split = FALSE)
[13:23:45.764]         if (TRUE) {
[13:23:45.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.764]         }
[13:23:45.764]         else {
[13:23:45.764]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.764]         }
[13:23:45.764]         base::close(...future.stdout)
[13:23:45.764]         ...future.stdout <- NULL
[13:23:45.764]     }
[13:23:45.764]     ...future.result$conditions <- ...future.conditions
[13:23:45.764]     ...future.result$finished <- base::Sys.time()
[13:23:45.764]     ...future.result
[13:23:45.764] }
[13:23:45.767] requestCore(): workers = 2
[13:23:45.769] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:23:45.770] plan(): Setting new future strategy stack:
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:45.770] List of future strategies:
[13:23:45.770] 1. sequential:
[13:23:45.770]    - args: function (..., envir = parent.frame())
[13:23:45.770]    - tweaked: FALSE
[13:23:45.770]    - call: NULL
[13:23:45.771] plan(): nbrOfWorkers() = 1
[13:23:45.773] plan(): Setting new future strategy stack:
[13:23:45.773] List of future strategies:
[13:23:45.773] 1. multicore:
[13:23:45.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.773]    - tweaked: FALSE
[13:23:45.773]    - call: plan(multicore)
[13:23:45.779] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:45.781] result() for MulticoreFuture ...
[13:23:45.784] result() for MulticoreFuture ...
[13:23:45.784] result() for MulticoreFuture ... done
[13:23:45.784] signalConditions() ...
[13:23:45.784]  - include = ‘immediateCondition’
[13:23:45.785]  - exclude = 
[13:23:45.785]  - resignal = FALSE
[13:23:45.785]  - Number of conditions: 1
[13:23:45.785] signalConditions() ... done
[13:23:45.785] result() for MulticoreFuture ... done
[13:23:45.785] result() for MulticoreFuture ...
[13:23:45.785] result() for MulticoreFuture ... done
[13:23:45.785] signalConditions() ...
[13:23:45.786]  - include = ‘immediateCondition’
[13:23:45.786]  - exclude = 
[13:23:45.786]  - resignal = FALSE
[13:23:45.786]  - Number of conditions: 1
[13:23:45.786] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:45.787] result() for MulticoreFuture ...
[13:23:45.787] result() for MulticoreFuture ... done
[13:23:45.787] result() for MulticoreFuture ...
[13:23:45.787] result() for MulticoreFuture ... done
[13:23:45.787] signalConditions() ...
[13:23:45.787]  - include = ‘immediateCondition’
[13:23:45.788]  - exclude = 
[13:23:45.788]  - resignal = FALSE
[13:23:45.788]  - Number of conditions: 1
[13:23:45.788] signalConditions() ... done
[13:23:45.788] Future state: ‘finished’
[13:23:45.788] result() for MulticoreFuture ...
[13:23:45.788] result() for MulticoreFuture ... done
[13:23:45.788] signalConditions() ...
[13:23:45.789]  - include = ‘condition’
[13:23:45.789]  - exclude = ‘immediateCondition’
[13:23:45.789]  - resignal = TRUE
[13:23:45.792]  - Number of conditions: 1
[13:23:45.792]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.792] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:45.793] result() for MulticoreFuture ...
[13:23:45.793] result() for MulticoreFuture ... done
[13:23:45.793] result() for MulticoreFuture ...
[13:23:45.793] result() for MulticoreFuture ... done
[13:23:45.794] signalConditions() ...
[13:23:45.794]  - include = ‘immediateCondition’
[13:23:45.794]  - exclude = 
[13:23:45.794]  - resignal = FALSE
[13:23:45.794]  - Number of conditions: 1
[13:23:45.794] signalConditions() ... done
[13:23:45.795] Future state: ‘finished’
[13:23:45.795] result() for MulticoreFuture ...
[13:23:45.795] result() for MulticoreFuture ... done
[13:23:45.795] signalConditions() ...
[13:23:45.795]  - include = ‘condition’
[13:23:45.795]  - exclude = ‘immediateCondition’
[13:23:45.795]  - resignal = TRUE
[13:23:45.795]  - Number of conditions: 1
[13:23:45.796]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:45.796] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:45.800] getGlobalsAndPackages() ...
[13:23:45.801] 
[13:23:45.801] - globals: [0] <none>
[13:23:45.801] getGlobalsAndPackages() ... DONE
[13:23:45.801] Packages needed by the future expression (n = 0): <none>
[13:23:45.802] Packages needed by future strategies (n = 0): <none>
[13:23:45.802] {
[13:23:45.802]     {
[13:23:45.802]         {
[13:23:45.802]             ...future.startTime <- base::Sys.time()
[13:23:45.802]             {
[13:23:45.802]                 {
[13:23:45.802]                   {
[13:23:45.802]                     {
[13:23:45.802]                       base::local({
[13:23:45.802]                         has_future <- base::requireNamespace("future", 
[13:23:45.802]                           quietly = TRUE)
[13:23:45.802]                         if (has_future) {
[13:23:45.802]                           ns <- base::getNamespace("future")
[13:23:45.802]                           version <- ns[[".package"]][["version"]]
[13:23:45.802]                           if (is.null(version)) 
[13:23:45.802]                             version <- utils::packageVersion("future")
[13:23:45.802]                         }
[13:23:45.802]                         else {
[13:23:45.802]                           version <- NULL
[13:23:45.802]                         }
[13:23:45.802]                         if (!has_future || version < "1.8.0") {
[13:23:45.802]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.802]                             "", base::R.version$version.string), 
[13:23:45.802]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.802]                               "release", "version")], collapse = " "), 
[13:23:45.802]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.802]                             info)
[13:23:45.802]                           info <- base::paste(info, collapse = "; ")
[13:23:45.802]                           if (!has_future) {
[13:23:45.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.802]                               info)
[13:23:45.802]                           }
[13:23:45.802]                           else {
[13:23:45.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.802]                               info, version)
[13:23:45.802]                           }
[13:23:45.802]                           base::stop(msg)
[13:23:45.802]                         }
[13:23:45.802]                       })
[13:23:45.802]                     }
[13:23:45.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.802]                     base::options(mc.cores = 1L)
[13:23:45.802]                   }
[13:23:45.802]                   options(future.plan = NULL)
[13:23:45.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.802]                 }
[13:23:45.802]                 ...future.workdir <- getwd()
[13:23:45.802]             }
[13:23:45.802]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.802]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.802]         }
[13:23:45.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.802]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.802]             base::names(...future.oldOptions))
[13:23:45.802]     }
[13:23:45.802]     if (FALSE) {
[13:23:45.802]     }
[13:23:45.802]     else {
[13:23:45.802]         if (TRUE) {
[13:23:45.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.802]                 open = "w")
[13:23:45.802]         }
[13:23:45.802]         else {
[13:23:45.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.802]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.802]         }
[13:23:45.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.802]             base::sink(type = "output", split = FALSE)
[13:23:45.802]             base::close(...future.stdout)
[13:23:45.802]         }, add = TRUE)
[13:23:45.802]     }
[13:23:45.802]     ...future.frame <- base::sys.nframe()
[13:23:45.802]     ...future.conditions <- base::list()
[13:23:45.802]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.802]     if (FALSE) {
[13:23:45.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.802]     }
[13:23:45.802]     ...future.result <- base::tryCatch({
[13:23:45.802]         base::withCallingHandlers({
[13:23:45.802]             ...future.value <- base::withVisible(base::local({
[13:23:45.802]                 withCallingHandlers({
[13:23:45.802]                   {
[13:23:45.802]                     stop(structure(list(message = "boom"), class = c("MyError", 
[13:23:45.802]                       "error", "condition")))
[13:23:45.802]                   }
[13:23:45.802]                 }, immediateCondition = function(cond) {
[13:23:45.802]                   save_rds <- function (object, pathname, ...) 
[13:23:45.802]                   {
[13:23:45.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.802]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.802]                         fi_tmp[["mtime"]])
[13:23:45.802]                     }
[13:23:45.802]                     tryCatch({
[13:23:45.802]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.802]                     }, error = function(ex) {
[13:23:45.802]                       msg <- conditionMessage(ex)
[13:23:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.802]                         fi_tmp[["mtime"]], msg)
[13:23:45.802]                       ex$message <- msg
[13:23:45.802]                       stop(ex)
[13:23:45.802]                     })
[13:23:45.802]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.802]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.802]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.802]                       fi <- file.info(pathname)
[13:23:45.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.802]                         fi[["size"]], fi[["mtime"]])
[13:23:45.802]                       stop(msg)
[13:23:45.802]                     }
[13:23:45.802]                     invisible(pathname)
[13:23:45.802]                   }
[13:23:45.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.802]                     rootPath = tempdir()) 
[13:23:45.802]                   {
[13:23:45.802]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.802]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.802]                       tmpdir = path, fileext = ".rds")
[13:23:45.802]                     save_rds(obj, file)
[13:23:45.802]                   }
[13:23:45.802]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.802]                   {
[13:23:45.802]                     inherits <- base::inherits
[13:23:45.802]                     invokeRestart <- base::invokeRestart
[13:23:45.802]                     is.null <- base::is.null
[13:23:45.802]                     muffled <- FALSE
[13:23:45.802]                     if (inherits(cond, "message")) {
[13:23:45.802]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.802]                       if (muffled) 
[13:23:45.802]                         invokeRestart("muffleMessage")
[13:23:45.802]                     }
[13:23:45.802]                     else if (inherits(cond, "warning")) {
[13:23:45.802]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.802]                       if (muffled) 
[13:23:45.802]                         invokeRestart("muffleWarning")
[13:23:45.802]                     }
[13:23:45.802]                     else if (inherits(cond, "condition")) {
[13:23:45.802]                       if (!is.null(pattern)) {
[13:23:45.802]                         computeRestarts <- base::computeRestarts
[13:23:45.802]                         grepl <- base::grepl
[13:23:45.802]                         restarts <- computeRestarts(cond)
[13:23:45.802]                         for (restart in restarts) {
[13:23:45.802]                           name <- restart$name
[13:23:45.802]                           if (is.null(name)) 
[13:23:45.802]                             next
[13:23:45.802]                           if (!grepl(pattern, name)) 
[13:23:45.802]                             next
[13:23:45.802]                           invokeRestart(restart)
[13:23:45.802]                           muffled <- TRUE
[13:23:45.802]                           break
[13:23:45.802]                         }
[13:23:45.802]                       }
[13:23:45.802]                     }
[13:23:45.802]                     invisible(muffled)
[13:23:45.802]                   }
[13:23:45.802]                   muffleCondition(cond)
[13:23:45.802]                 })
[13:23:45.802]             }))
[13:23:45.802]             future::FutureResult(value = ...future.value$value, 
[13:23:45.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.802]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.802]                     ...future.globalenv.names))
[13:23:45.802]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.802]         }, condition = base::local({
[13:23:45.802]             c <- base::c
[13:23:45.802]             inherits <- base::inherits
[13:23:45.802]             invokeRestart <- base::invokeRestart
[13:23:45.802]             length <- base::length
[13:23:45.802]             list <- base::list
[13:23:45.802]             seq.int <- base::seq.int
[13:23:45.802]             signalCondition <- base::signalCondition
[13:23:45.802]             sys.calls <- base::sys.calls
[13:23:45.802]             `[[` <- base::`[[`
[13:23:45.802]             `+` <- base::`+`
[13:23:45.802]             `<<-` <- base::`<<-`
[13:23:45.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.802]                   3L)]
[13:23:45.802]             }
[13:23:45.802]             function(cond) {
[13:23:45.802]                 is_error <- inherits(cond, "error")
[13:23:45.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.802]                   NULL)
[13:23:45.802]                 if (is_error) {
[13:23:45.802]                   sessionInformation <- function() {
[13:23:45.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.802]                       search = base::search(), system = base::Sys.info())
[13:23:45.802]                   }
[13:23:45.802]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.802]                     cond$call), session = sessionInformation(), 
[13:23:45.802]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.802]                   signalCondition(cond)
[13:23:45.802]                 }
[13:23:45.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.802]                 "immediateCondition"))) {
[13:23:45.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.802]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.802]                   if (TRUE && !signal) {
[13:23:45.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.802]                     {
[13:23:45.802]                       inherits <- base::inherits
[13:23:45.802]                       invokeRestart <- base::invokeRestart
[13:23:45.802]                       is.null <- base::is.null
[13:23:45.802]                       muffled <- FALSE
[13:23:45.802]                       if (inherits(cond, "message")) {
[13:23:45.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.802]                         if (muffled) 
[13:23:45.802]                           invokeRestart("muffleMessage")
[13:23:45.802]                       }
[13:23:45.802]                       else if (inherits(cond, "warning")) {
[13:23:45.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.802]                         if (muffled) 
[13:23:45.802]                           invokeRestart("muffleWarning")
[13:23:45.802]                       }
[13:23:45.802]                       else if (inherits(cond, "condition")) {
[13:23:45.802]                         if (!is.null(pattern)) {
[13:23:45.802]                           computeRestarts <- base::computeRestarts
[13:23:45.802]                           grepl <- base::grepl
[13:23:45.802]                           restarts <- computeRestarts(cond)
[13:23:45.802]                           for (restart in restarts) {
[13:23:45.802]                             name <- restart$name
[13:23:45.802]                             if (is.null(name)) 
[13:23:45.802]                               next
[13:23:45.802]                             if (!grepl(pattern, name)) 
[13:23:45.802]                               next
[13:23:45.802]                             invokeRestart(restart)
[13:23:45.802]                             muffled <- TRUE
[13:23:45.802]                             break
[13:23:45.802]                           }
[13:23:45.802]                         }
[13:23:45.802]                       }
[13:23:45.802]                       invisible(muffled)
[13:23:45.802]                     }
[13:23:45.802]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.802]                   }
[13:23:45.802]                 }
[13:23:45.802]                 else {
[13:23:45.802]                   if (TRUE) {
[13:23:45.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.802]                     {
[13:23:45.802]                       inherits <- base::inherits
[13:23:45.802]                       invokeRestart <- base::invokeRestart
[13:23:45.802]                       is.null <- base::is.null
[13:23:45.802]                       muffled <- FALSE
[13:23:45.802]                       if (inherits(cond, "message")) {
[13:23:45.802]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.802]                         if (muffled) 
[13:23:45.802]                           invokeRestart("muffleMessage")
[13:23:45.802]                       }
[13:23:45.802]                       else if (inherits(cond, "warning")) {
[13:23:45.802]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.802]                         if (muffled) 
[13:23:45.802]                           invokeRestart("muffleWarning")
[13:23:45.802]                       }
[13:23:45.802]                       else if (inherits(cond, "condition")) {
[13:23:45.802]                         if (!is.null(pattern)) {
[13:23:45.802]                           computeRestarts <- base::computeRestarts
[13:23:45.802]                           grepl <- base::grepl
[13:23:45.802]                           restarts <- computeRestarts(cond)
[13:23:45.802]                           for (restart in restarts) {
[13:23:45.802]                             name <- restart$name
[13:23:45.802]                             if (is.null(name)) 
[13:23:45.802]                               next
[13:23:45.802]                             if (!grepl(pattern, name)) 
[13:23:45.802]                               next
[13:23:45.802]                             invokeRestart(restart)
[13:23:45.802]                             muffled <- TRUE
[13:23:45.802]                             break
[13:23:45.802]                           }
[13:23:45.802]                         }
[13:23:45.802]                       }
[13:23:45.802]                       invisible(muffled)
[13:23:45.802]                     }
[13:23:45.802]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.802]                   }
[13:23:45.802]                 }
[13:23:45.802]             }
[13:23:45.802]         }))
[13:23:45.802]     }, error = function(ex) {
[13:23:45.802]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.802]                 ...future.rng), started = ...future.startTime, 
[13:23:45.802]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.802]             version = "1.8"), class = "FutureResult")
[13:23:45.802]     }, finally = {
[13:23:45.802]         if (!identical(...future.workdir, getwd())) 
[13:23:45.802]             setwd(...future.workdir)
[13:23:45.802]         {
[13:23:45.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.802]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.802]             }
[13:23:45.802]             base::options(...future.oldOptions)
[13:23:45.802]             if (.Platform$OS.type == "windows") {
[13:23:45.802]                 old_names <- names(...future.oldEnvVars)
[13:23:45.802]                 envs <- base::Sys.getenv()
[13:23:45.802]                 names <- names(envs)
[13:23:45.802]                 common <- intersect(names, old_names)
[13:23:45.802]                 added <- setdiff(names, old_names)
[13:23:45.802]                 removed <- setdiff(old_names, names)
[13:23:45.802]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.802]                   envs[common]]
[13:23:45.802]                 NAMES <- toupper(changed)
[13:23:45.802]                 args <- list()
[13:23:45.802]                 for (kk in seq_along(NAMES)) {
[13:23:45.802]                   name <- changed[[kk]]
[13:23:45.802]                   NAME <- NAMES[[kk]]
[13:23:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.802]                     next
[13:23:45.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.802]                 }
[13:23:45.802]                 NAMES <- toupper(added)
[13:23:45.802]                 for (kk in seq_along(NAMES)) {
[13:23:45.802]                   name <- added[[kk]]
[13:23:45.802]                   NAME <- NAMES[[kk]]
[13:23:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.802]                     next
[13:23:45.802]                   args[[name]] <- ""
[13:23:45.802]                 }
[13:23:45.802]                 NAMES <- toupper(removed)
[13:23:45.802]                 for (kk in seq_along(NAMES)) {
[13:23:45.802]                   name <- removed[[kk]]
[13:23:45.802]                   NAME <- NAMES[[kk]]
[13:23:45.802]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.802]                     next
[13:23:45.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.802]                 }
[13:23:45.802]                 if (length(args) > 0) 
[13:23:45.802]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.802]             }
[13:23:45.802]             else {
[13:23:45.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.802]             }
[13:23:45.802]             {
[13:23:45.802]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.802]                   0L) {
[13:23:45.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.802]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.802]                   base::options(opts)
[13:23:45.802]                 }
[13:23:45.802]                 {
[13:23:45.802]                   {
[13:23:45.802]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.802]                     NULL
[13:23:45.802]                   }
[13:23:45.802]                   options(future.plan = NULL)
[13:23:45.802]                   if (is.na(NA_character_)) 
[13:23:45.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.802]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.802]                     envir = parent.frame()) 
[13:23:45.802]                   {
[13:23:45.802]                     default_workers <- missing(workers)
[13:23:45.802]                     if (is.function(workers)) 
[13:23:45.802]                       workers <- workers()
[13:23:45.802]                     workers <- structure(as.integer(workers), 
[13:23:45.802]                       class = class(workers))
[13:23:45.802]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.802]                       1L)
[13:23:45.802]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.802]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.802]                       if (default_workers) 
[13:23:45.802]                         supportsMulticore(warn = TRUE)
[13:23:45.802]                       return(sequential(..., envir = envir))
[13:23:45.802]                     }
[13:23:45.802]                     oopts <- options(mc.cores = workers)
[13:23:45.802]                     on.exit(options(oopts))
[13:23:45.802]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.802]                       envir = envir)
[13:23:45.802]                     if (!future$lazy) 
[13:23:45.802]                       future <- run(future)
[13:23:45.802]                     invisible(future)
[13:23:45.802]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.802]                 }
[13:23:45.802]             }
[13:23:45.802]         }
[13:23:45.802]     })
[13:23:45.802]     if (TRUE) {
[13:23:45.802]         base::sink(type = "output", split = FALSE)
[13:23:45.802]         if (TRUE) {
[13:23:45.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.802]         }
[13:23:45.802]         else {
[13:23:45.802]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.802]         }
[13:23:45.802]         base::close(...future.stdout)
[13:23:45.802]         ...future.stdout <- NULL
[13:23:45.802]     }
[13:23:45.802]     ...future.result$conditions <- ...future.conditions
[13:23:45.802]     ...future.result$finished <- base::Sys.time()
[13:23:45.802]     ...future.result
[13:23:45.802] }
[13:23:45.805] requestCore(): workers = 2
[13:23:45.807] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:45.808] plan(): Setting new future strategy stack:
[13:23:45.808] List of future strategies:
[13:23:45.808] 1. sequential:
[13:23:45.808]    - args: function (..., envir = parent.frame())
[13:23:45.808]    - tweaked: FALSE
[13:23:45.808]    - call: NULL
[13:23:45.809] plan(): nbrOfWorkers() = 1
[13:23:45.811] plan(): Setting new future strategy stack:
[13:23:45.812] List of future strategies:
[13:23:45.812] 1. multicore:
[13:23:45.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.812]    - tweaked: FALSE
[13:23:45.812]    - call: plan(multicore)
[13:23:45.817] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:45.819] result() for MulticoreFuture ...
[13:23:45.822] result() for MulticoreFuture ...
[13:23:45.822] result() for MulticoreFuture ... done
[13:23:45.822] signalConditions() ...
[13:23:45.822]  - include = ‘immediateCondition’
[13:23:45.822]  - exclude = 
[13:23:45.822]  - resignal = FALSE
[13:23:45.823]  - Number of conditions: 1
[13:23:45.823] signalConditions() ... done
[13:23:45.823] result() for MulticoreFuture ... done
[13:23:45.823] result() for MulticoreFuture ...
[13:23:45.823] result() for MulticoreFuture ... done
[13:23:45.823] signalConditions() ...
[13:23:45.823]  - include = ‘immediateCondition’
[13:23:45.823]  - exclude = 
[13:23:45.824]  - resignal = FALSE
[13:23:45.824]  - Number of conditions: 1
[13:23:45.824] signalConditions() ... done
<MyError: boom>
[13:23:45.824] result() for MulticoreFuture ...
[13:23:45.824] result() for MulticoreFuture ... done
[13:23:45.824] result() for MulticoreFuture ...
[13:23:45.825] result() for MulticoreFuture ... done
[13:23:45.825] signalConditions() ...
[13:23:45.825]  - include = ‘immediateCondition’
[13:23:45.825]  - exclude = 
[13:23:45.825]  - resignal = FALSE
[13:23:45.825]  - Number of conditions: 1
[13:23:45.825] signalConditions() ... done
[13:23:45.825] Future state: ‘finished’
[13:23:45.825] result() for MulticoreFuture ...
[13:23:45.826] result() for MulticoreFuture ... done
[13:23:45.826] signalConditions() ...
[13:23:45.826]  - include = ‘condition’
[13:23:45.826]  - exclude = ‘immediateCondition’
[13:23:45.826]  - resignal = TRUE
[13:23:45.826]  - Number of conditions: 1
[13:23:45.826]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:23:45.826] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[13:23:45.831] getGlobalsAndPackages() ...
[13:23:45.831] Searching for globals...
[13:23:45.832] - globals found: [1] ‘{’
[13:23:45.832] Searching for globals ... DONE
[13:23:45.832] Resolving globals: FALSE
[13:23:45.833] 
[13:23:45.833] 
[13:23:45.833] getGlobalsAndPackages() ... DONE
[13:23:45.833] Packages needed by the future expression (n = 0): <none>
[13:23:45.834] Packages needed by future strategies (n = 0): <none>
[13:23:45.834] {
[13:23:45.834]     {
[13:23:45.834]         {
[13:23:45.834]             ...future.startTime <- base::Sys.time()
[13:23:45.834]             {
[13:23:45.834]                 {
[13:23:45.834]                   {
[13:23:45.834]                     {
[13:23:45.834]                       base::local({
[13:23:45.834]                         has_future <- base::requireNamespace("future", 
[13:23:45.834]                           quietly = TRUE)
[13:23:45.834]                         if (has_future) {
[13:23:45.834]                           ns <- base::getNamespace("future")
[13:23:45.834]                           version <- ns[[".package"]][["version"]]
[13:23:45.834]                           if (is.null(version)) 
[13:23:45.834]                             version <- utils::packageVersion("future")
[13:23:45.834]                         }
[13:23:45.834]                         else {
[13:23:45.834]                           version <- NULL
[13:23:45.834]                         }
[13:23:45.834]                         if (!has_future || version < "1.8.0") {
[13:23:45.834]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.834]                             "", base::R.version$version.string), 
[13:23:45.834]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.834]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.834]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.834]                               "release", "version")], collapse = " "), 
[13:23:45.834]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.834]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.834]                             info)
[13:23:45.834]                           info <- base::paste(info, collapse = "; ")
[13:23:45.834]                           if (!has_future) {
[13:23:45.834]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.834]                               info)
[13:23:45.834]                           }
[13:23:45.834]                           else {
[13:23:45.834]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.834]                               info, version)
[13:23:45.834]                           }
[13:23:45.834]                           base::stop(msg)
[13:23:45.834]                         }
[13:23:45.834]                       })
[13:23:45.834]                     }
[13:23:45.834]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.834]                     base::options(mc.cores = 1L)
[13:23:45.834]                   }
[13:23:45.834]                   options(future.plan = NULL)
[13:23:45.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.834]                 }
[13:23:45.834]                 ...future.workdir <- getwd()
[13:23:45.834]             }
[13:23:45.834]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.834]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.834]         }
[13:23:45.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.834]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.834]             base::names(...future.oldOptions))
[13:23:45.834]     }
[13:23:45.834]     if (FALSE) {
[13:23:45.834]     }
[13:23:45.834]     else {
[13:23:45.834]         if (TRUE) {
[13:23:45.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.834]                 open = "w")
[13:23:45.834]         }
[13:23:45.834]         else {
[13:23:45.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.834]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.834]         }
[13:23:45.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.834]             base::sink(type = "output", split = FALSE)
[13:23:45.834]             base::close(...future.stdout)
[13:23:45.834]         }, add = TRUE)
[13:23:45.834]     }
[13:23:45.834]     ...future.frame <- base::sys.nframe()
[13:23:45.834]     ...future.conditions <- base::list()
[13:23:45.834]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.834]     if (FALSE) {
[13:23:45.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.834]     }
[13:23:45.834]     ...future.result <- base::tryCatch({
[13:23:45.834]         base::withCallingHandlers({
[13:23:45.834]             ...future.value <- base::withVisible(base::local({
[13:23:45.834]                 withCallingHandlers({
[13:23:45.834]                   {
[13:23:45.834]                     42L
[13:23:45.834]                   }
[13:23:45.834]                 }, immediateCondition = function(cond) {
[13:23:45.834]                   save_rds <- function (object, pathname, ...) 
[13:23:45.834]                   {
[13:23:45.834]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.834]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.834]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.834]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.834]                         fi_tmp[["mtime"]])
[13:23:45.834]                     }
[13:23:45.834]                     tryCatch({
[13:23:45.834]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.834]                     }, error = function(ex) {
[13:23:45.834]                       msg <- conditionMessage(ex)
[13:23:45.834]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.834]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.834]                         fi_tmp[["mtime"]], msg)
[13:23:45.834]                       ex$message <- msg
[13:23:45.834]                       stop(ex)
[13:23:45.834]                     })
[13:23:45.834]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.834]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.834]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.834]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.834]                       fi <- file.info(pathname)
[13:23:45.834]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.834]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.834]                         fi[["size"]], fi[["mtime"]])
[13:23:45.834]                       stop(msg)
[13:23:45.834]                     }
[13:23:45.834]                     invisible(pathname)
[13:23:45.834]                   }
[13:23:45.834]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.834]                     rootPath = tempdir()) 
[13:23:45.834]                   {
[13:23:45.834]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.834]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.834]                       tmpdir = path, fileext = ".rds")
[13:23:45.834]                     save_rds(obj, file)
[13:23:45.834]                   }
[13:23:45.834]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.834]                   {
[13:23:45.834]                     inherits <- base::inherits
[13:23:45.834]                     invokeRestart <- base::invokeRestart
[13:23:45.834]                     is.null <- base::is.null
[13:23:45.834]                     muffled <- FALSE
[13:23:45.834]                     if (inherits(cond, "message")) {
[13:23:45.834]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.834]                       if (muffled) 
[13:23:45.834]                         invokeRestart("muffleMessage")
[13:23:45.834]                     }
[13:23:45.834]                     else if (inherits(cond, "warning")) {
[13:23:45.834]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.834]                       if (muffled) 
[13:23:45.834]                         invokeRestart("muffleWarning")
[13:23:45.834]                     }
[13:23:45.834]                     else if (inherits(cond, "condition")) {
[13:23:45.834]                       if (!is.null(pattern)) {
[13:23:45.834]                         computeRestarts <- base::computeRestarts
[13:23:45.834]                         grepl <- base::grepl
[13:23:45.834]                         restarts <- computeRestarts(cond)
[13:23:45.834]                         for (restart in restarts) {
[13:23:45.834]                           name <- restart$name
[13:23:45.834]                           if (is.null(name)) 
[13:23:45.834]                             next
[13:23:45.834]                           if (!grepl(pattern, name)) 
[13:23:45.834]                             next
[13:23:45.834]                           invokeRestart(restart)
[13:23:45.834]                           muffled <- TRUE
[13:23:45.834]                           break
[13:23:45.834]                         }
[13:23:45.834]                       }
[13:23:45.834]                     }
[13:23:45.834]                     invisible(muffled)
[13:23:45.834]                   }
[13:23:45.834]                   muffleCondition(cond)
[13:23:45.834]                 })
[13:23:45.834]             }))
[13:23:45.834]             future::FutureResult(value = ...future.value$value, 
[13:23:45.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.834]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.834]                     ...future.globalenv.names))
[13:23:45.834]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.834]         }, condition = base::local({
[13:23:45.834]             c <- base::c
[13:23:45.834]             inherits <- base::inherits
[13:23:45.834]             invokeRestart <- base::invokeRestart
[13:23:45.834]             length <- base::length
[13:23:45.834]             list <- base::list
[13:23:45.834]             seq.int <- base::seq.int
[13:23:45.834]             signalCondition <- base::signalCondition
[13:23:45.834]             sys.calls <- base::sys.calls
[13:23:45.834]             `[[` <- base::`[[`
[13:23:45.834]             `+` <- base::`+`
[13:23:45.834]             `<<-` <- base::`<<-`
[13:23:45.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.834]                   3L)]
[13:23:45.834]             }
[13:23:45.834]             function(cond) {
[13:23:45.834]                 is_error <- inherits(cond, "error")
[13:23:45.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.834]                   NULL)
[13:23:45.834]                 if (is_error) {
[13:23:45.834]                   sessionInformation <- function() {
[13:23:45.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.834]                       search = base::search(), system = base::Sys.info())
[13:23:45.834]                   }
[13:23:45.834]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.834]                     cond$call), session = sessionInformation(), 
[13:23:45.834]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.834]                   signalCondition(cond)
[13:23:45.834]                 }
[13:23:45.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.834]                 "immediateCondition"))) {
[13:23:45.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.834]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.834]                   if (TRUE && !signal) {
[13:23:45.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.834]                     {
[13:23:45.834]                       inherits <- base::inherits
[13:23:45.834]                       invokeRestart <- base::invokeRestart
[13:23:45.834]                       is.null <- base::is.null
[13:23:45.834]                       muffled <- FALSE
[13:23:45.834]                       if (inherits(cond, "message")) {
[13:23:45.834]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.834]                         if (muffled) 
[13:23:45.834]                           invokeRestart("muffleMessage")
[13:23:45.834]                       }
[13:23:45.834]                       else if (inherits(cond, "warning")) {
[13:23:45.834]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.834]                         if (muffled) 
[13:23:45.834]                           invokeRestart("muffleWarning")
[13:23:45.834]                       }
[13:23:45.834]                       else if (inherits(cond, "condition")) {
[13:23:45.834]                         if (!is.null(pattern)) {
[13:23:45.834]                           computeRestarts <- base::computeRestarts
[13:23:45.834]                           grepl <- base::grepl
[13:23:45.834]                           restarts <- computeRestarts(cond)
[13:23:45.834]                           for (restart in restarts) {
[13:23:45.834]                             name <- restart$name
[13:23:45.834]                             if (is.null(name)) 
[13:23:45.834]                               next
[13:23:45.834]                             if (!grepl(pattern, name)) 
[13:23:45.834]                               next
[13:23:45.834]                             invokeRestart(restart)
[13:23:45.834]                             muffled <- TRUE
[13:23:45.834]                             break
[13:23:45.834]                           }
[13:23:45.834]                         }
[13:23:45.834]                       }
[13:23:45.834]                       invisible(muffled)
[13:23:45.834]                     }
[13:23:45.834]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.834]                   }
[13:23:45.834]                 }
[13:23:45.834]                 else {
[13:23:45.834]                   if (TRUE) {
[13:23:45.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.834]                     {
[13:23:45.834]                       inherits <- base::inherits
[13:23:45.834]                       invokeRestart <- base::invokeRestart
[13:23:45.834]                       is.null <- base::is.null
[13:23:45.834]                       muffled <- FALSE
[13:23:45.834]                       if (inherits(cond, "message")) {
[13:23:45.834]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.834]                         if (muffled) 
[13:23:45.834]                           invokeRestart("muffleMessage")
[13:23:45.834]                       }
[13:23:45.834]                       else if (inherits(cond, "warning")) {
[13:23:45.834]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.834]                         if (muffled) 
[13:23:45.834]                           invokeRestart("muffleWarning")
[13:23:45.834]                       }
[13:23:45.834]                       else if (inherits(cond, "condition")) {
[13:23:45.834]                         if (!is.null(pattern)) {
[13:23:45.834]                           computeRestarts <- base::computeRestarts
[13:23:45.834]                           grepl <- base::grepl
[13:23:45.834]                           restarts <- computeRestarts(cond)
[13:23:45.834]                           for (restart in restarts) {
[13:23:45.834]                             name <- restart$name
[13:23:45.834]                             if (is.null(name)) 
[13:23:45.834]                               next
[13:23:45.834]                             if (!grepl(pattern, name)) 
[13:23:45.834]                               next
[13:23:45.834]                             invokeRestart(restart)
[13:23:45.834]                             muffled <- TRUE
[13:23:45.834]                             break
[13:23:45.834]                           }
[13:23:45.834]                         }
[13:23:45.834]                       }
[13:23:45.834]                       invisible(muffled)
[13:23:45.834]                     }
[13:23:45.834]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.834]                   }
[13:23:45.834]                 }
[13:23:45.834]             }
[13:23:45.834]         }))
[13:23:45.834]     }, error = function(ex) {
[13:23:45.834]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.834]                 ...future.rng), started = ...future.startTime, 
[13:23:45.834]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.834]             version = "1.8"), class = "FutureResult")
[13:23:45.834]     }, finally = {
[13:23:45.834]         if (!identical(...future.workdir, getwd())) 
[13:23:45.834]             setwd(...future.workdir)
[13:23:45.834]         {
[13:23:45.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.834]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.834]             }
[13:23:45.834]             base::options(...future.oldOptions)
[13:23:45.834]             if (.Platform$OS.type == "windows") {
[13:23:45.834]                 old_names <- names(...future.oldEnvVars)
[13:23:45.834]                 envs <- base::Sys.getenv()
[13:23:45.834]                 names <- names(envs)
[13:23:45.834]                 common <- intersect(names, old_names)
[13:23:45.834]                 added <- setdiff(names, old_names)
[13:23:45.834]                 removed <- setdiff(old_names, names)
[13:23:45.834]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.834]                   envs[common]]
[13:23:45.834]                 NAMES <- toupper(changed)
[13:23:45.834]                 args <- list()
[13:23:45.834]                 for (kk in seq_along(NAMES)) {
[13:23:45.834]                   name <- changed[[kk]]
[13:23:45.834]                   NAME <- NAMES[[kk]]
[13:23:45.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.834]                     next
[13:23:45.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.834]                 }
[13:23:45.834]                 NAMES <- toupper(added)
[13:23:45.834]                 for (kk in seq_along(NAMES)) {
[13:23:45.834]                   name <- added[[kk]]
[13:23:45.834]                   NAME <- NAMES[[kk]]
[13:23:45.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.834]                     next
[13:23:45.834]                   args[[name]] <- ""
[13:23:45.834]                 }
[13:23:45.834]                 NAMES <- toupper(removed)
[13:23:45.834]                 for (kk in seq_along(NAMES)) {
[13:23:45.834]                   name <- removed[[kk]]
[13:23:45.834]                   NAME <- NAMES[[kk]]
[13:23:45.834]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.834]                     next
[13:23:45.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.834]                 }
[13:23:45.834]                 if (length(args) > 0) 
[13:23:45.834]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.834]             }
[13:23:45.834]             else {
[13:23:45.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.834]             }
[13:23:45.834]             {
[13:23:45.834]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.834]                   0L) {
[13:23:45.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.834]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.834]                   base::options(opts)
[13:23:45.834]                 }
[13:23:45.834]                 {
[13:23:45.834]                   {
[13:23:45.834]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.834]                     NULL
[13:23:45.834]                   }
[13:23:45.834]                   options(future.plan = NULL)
[13:23:45.834]                   if (is.na(NA_character_)) 
[13:23:45.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.834]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.834]                     envir = parent.frame()) 
[13:23:45.834]                   {
[13:23:45.834]                     default_workers <- missing(workers)
[13:23:45.834]                     if (is.function(workers)) 
[13:23:45.834]                       workers <- workers()
[13:23:45.834]                     workers <- structure(as.integer(workers), 
[13:23:45.834]                       class = class(workers))
[13:23:45.834]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.834]                       1L)
[13:23:45.834]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.834]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.834]                       if (default_workers) 
[13:23:45.834]                         supportsMulticore(warn = TRUE)
[13:23:45.834]                       return(sequential(..., envir = envir))
[13:23:45.834]                     }
[13:23:45.834]                     oopts <- options(mc.cores = workers)
[13:23:45.834]                     on.exit(options(oopts))
[13:23:45.834]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.834]                       envir = envir)
[13:23:45.834]                     if (!future$lazy) 
[13:23:45.834]                       future <- run(future)
[13:23:45.834]                     invisible(future)
[13:23:45.834]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.834]                 }
[13:23:45.834]             }
[13:23:45.834]         }
[13:23:45.834]     })
[13:23:45.834]     if (TRUE) {
[13:23:45.834]         base::sink(type = "output", split = FALSE)
[13:23:45.834]         if (TRUE) {
[13:23:45.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.834]         }
[13:23:45.834]         else {
[13:23:45.834]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.834]         }
[13:23:45.834]         base::close(...future.stdout)
[13:23:45.834]         ...future.stdout <- NULL
[13:23:45.834]     }
[13:23:45.834]     ...future.result$conditions <- ...future.conditions
[13:23:45.834]     ...future.result$finished <- base::Sys.time()
[13:23:45.834]     ...future.result
[13:23:45.834] }
[13:23:45.837] requestCore(): workers = 2
[13:23:45.839] MulticoreFuture started
[13:23:45.841] plan(): Setting new future strategy stack:
[13:23:45.841] List of future strategies:
[13:23:45.841] 1. sequential:
[13:23:45.841]    - args: function (..., envir = parent.frame())
[13:23:45.841]    - tweaked: FALSE
[13:23:45.841]    - call: NULL
[13:23:45.842] plan(): nbrOfWorkers() = 1
[13:23:45.844] plan(): Setting new future strategy stack:
[13:23:45.844] List of future strategies:
[13:23:45.844] 1. multicore:
[13:23:45.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.844]    - tweaked: FALSE
[13:23:45.844]    - call: plan(multicore)
[13:23:45.850] plan(): nbrOfWorkers() = 2
[1] TRUE
[13:23:45.850] result() for MulticoreFuture ...
[13:23:45.851] result() for MulticoreFuture ...
[13:23:45.852] result() for MulticoreFuture ... done
[13:23:45.852] result() for MulticoreFuture ... done
[13:23:45.852] result() for MulticoreFuture ...
[13:23:45.852] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = TRUE) with globals
[13:23:45.857] getGlobalsAndPackages() ...
[13:23:45.857] Searching for globals...
[13:23:45.859] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[13:23:45.859] Searching for globals ... DONE
[13:23:45.859] Resolving globals: FALSE
[13:23:45.860] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.860] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[13:23:45.861] - globals: [1] ‘a’
[13:23:45.861] 
[13:23:45.861] getGlobalsAndPackages() ... DONE
[13:23:45.861] Packages needed by the future expression (n = 0): <none>
[13:23:45.862] Packages needed by future strategies (n = 0): <none>
[13:23:45.862] {
[13:23:45.862]     {
[13:23:45.862]         {
[13:23:45.862]             ...future.startTime <- base::Sys.time()
[13:23:45.862]             {
[13:23:45.862]                 {
[13:23:45.862]                   {
[13:23:45.862]                     {
[13:23:45.862]                       base::local({
[13:23:45.862]                         has_future <- base::requireNamespace("future", 
[13:23:45.862]                           quietly = TRUE)
[13:23:45.862]                         if (has_future) {
[13:23:45.862]                           ns <- base::getNamespace("future")
[13:23:45.862]                           version <- ns[[".package"]][["version"]]
[13:23:45.862]                           if (is.null(version)) 
[13:23:45.862]                             version <- utils::packageVersion("future")
[13:23:45.862]                         }
[13:23:45.862]                         else {
[13:23:45.862]                           version <- NULL
[13:23:45.862]                         }
[13:23:45.862]                         if (!has_future || version < "1.8.0") {
[13:23:45.862]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.862]                             "", base::R.version$version.string), 
[13:23:45.862]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.862]                               "release", "version")], collapse = " "), 
[13:23:45.862]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.862]                             info)
[13:23:45.862]                           info <- base::paste(info, collapse = "; ")
[13:23:45.862]                           if (!has_future) {
[13:23:45.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.862]                               info)
[13:23:45.862]                           }
[13:23:45.862]                           else {
[13:23:45.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.862]                               info, version)
[13:23:45.862]                           }
[13:23:45.862]                           base::stop(msg)
[13:23:45.862]                         }
[13:23:45.862]                       })
[13:23:45.862]                     }
[13:23:45.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.862]                     base::options(mc.cores = 1L)
[13:23:45.862]                   }
[13:23:45.862]                   options(future.plan = NULL)
[13:23:45.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.862]                 }
[13:23:45.862]                 ...future.workdir <- getwd()
[13:23:45.862]             }
[13:23:45.862]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.862]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.862]         }
[13:23:45.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.862]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.862]             base::names(...future.oldOptions))
[13:23:45.862]     }
[13:23:45.862]     if (FALSE) {
[13:23:45.862]     }
[13:23:45.862]     else {
[13:23:45.862]         if (TRUE) {
[13:23:45.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.862]                 open = "w")
[13:23:45.862]         }
[13:23:45.862]         else {
[13:23:45.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.862]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.862]         }
[13:23:45.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.862]             base::sink(type = "output", split = FALSE)
[13:23:45.862]             base::close(...future.stdout)
[13:23:45.862]         }, add = TRUE)
[13:23:45.862]     }
[13:23:45.862]     ...future.frame <- base::sys.nframe()
[13:23:45.862]     ...future.conditions <- base::list()
[13:23:45.862]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.862]     if (FALSE) {
[13:23:45.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.862]     }
[13:23:45.862]     ...future.result <- base::tryCatch({
[13:23:45.862]         base::withCallingHandlers({
[13:23:45.862]             ...future.value <- base::withVisible(base::local({
[13:23:45.862]                 withCallingHandlers({
[13:23:45.862]                   {
[13:23:45.862]                     b <- 3
[13:23:45.862]                     c <- 2
[13:23:45.862]                     a * b * c
[13:23:45.862]                   }
[13:23:45.862]                 }, immediateCondition = function(cond) {
[13:23:45.862]                   save_rds <- function (object, pathname, ...) 
[13:23:45.862]                   {
[13:23:45.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.862]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.862]                         fi_tmp[["mtime"]])
[13:23:45.862]                     }
[13:23:45.862]                     tryCatch({
[13:23:45.862]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.862]                     }, error = function(ex) {
[13:23:45.862]                       msg <- conditionMessage(ex)
[13:23:45.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.862]                         fi_tmp[["mtime"]], msg)
[13:23:45.862]                       ex$message <- msg
[13:23:45.862]                       stop(ex)
[13:23:45.862]                     })
[13:23:45.862]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.862]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.862]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.862]                       fi <- file.info(pathname)
[13:23:45.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.862]                         fi[["size"]], fi[["mtime"]])
[13:23:45.862]                       stop(msg)
[13:23:45.862]                     }
[13:23:45.862]                     invisible(pathname)
[13:23:45.862]                   }
[13:23:45.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.862]                     rootPath = tempdir()) 
[13:23:45.862]                   {
[13:23:45.862]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.862]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.862]                       tmpdir = path, fileext = ".rds")
[13:23:45.862]                     save_rds(obj, file)
[13:23:45.862]                   }
[13:23:45.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.862]                   {
[13:23:45.862]                     inherits <- base::inherits
[13:23:45.862]                     invokeRestart <- base::invokeRestart
[13:23:45.862]                     is.null <- base::is.null
[13:23:45.862]                     muffled <- FALSE
[13:23:45.862]                     if (inherits(cond, "message")) {
[13:23:45.862]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.862]                       if (muffled) 
[13:23:45.862]                         invokeRestart("muffleMessage")
[13:23:45.862]                     }
[13:23:45.862]                     else if (inherits(cond, "warning")) {
[13:23:45.862]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.862]                       if (muffled) 
[13:23:45.862]                         invokeRestart("muffleWarning")
[13:23:45.862]                     }
[13:23:45.862]                     else if (inherits(cond, "condition")) {
[13:23:45.862]                       if (!is.null(pattern)) {
[13:23:45.862]                         computeRestarts <- base::computeRestarts
[13:23:45.862]                         grepl <- base::grepl
[13:23:45.862]                         restarts <- computeRestarts(cond)
[13:23:45.862]                         for (restart in restarts) {
[13:23:45.862]                           name <- restart$name
[13:23:45.862]                           if (is.null(name)) 
[13:23:45.862]                             next
[13:23:45.862]                           if (!grepl(pattern, name)) 
[13:23:45.862]                             next
[13:23:45.862]                           invokeRestart(restart)
[13:23:45.862]                           muffled <- TRUE
[13:23:45.862]                           break
[13:23:45.862]                         }
[13:23:45.862]                       }
[13:23:45.862]                     }
[13:23:45.862]                     invisible(muffled)
[13:23:45.862]                   }
[13:23:45.862]                   muffleCondition(cond)
[13:23:45.862]                 })
[13:23:45.862]             }))
[13:23:45.862]             future::FutureResult(value = ...future.value$value, 
[13:23:45.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.862]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.862]                     ...future.globalenv.names))
[13:23:45.862]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.862]         }, condition = base::local({
[13:23:45.862]             c <- base::c
[13:23:45.862]             inherits <- base::inherits
[13:23:45.862]             invokeRestart <- base::invokeRestart
[13:23:45.862]             length <- base::length
[13:23:45.862]             list <- base::list
[13:23:45.862]             seq.int <- base::seq.int
[13:23:45.862]             signalCondition <- base::signalCondition
[13:23:45.862]             sys.calls <- base::sys.calls
[13:23:45.862]             `[[` <- base::`[[`
[13:23:45.862]             `+` <- base::`+`
[13:23:45.862]             `<<-` <- base::`<<-`
[13:23:45.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.862]                   3L)]
[13:23:45.862]             }
[13:23:45.862]             function(cond) {
[13:23:45.862]                 is_error <- inherits(cond, "error")
[13:23:45.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.862]                   NULL)
[13:23:45.862]                 if (is_error) {
[13:23:45.862]                   sessionInformation <- function() {
[13:23:45.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.862]                       search = base::search(), system = base::Sys.info())
[13:23:45.862]                   }
[13:23:45.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.862]                     cond$call), session = sessionInformation(), 
[13:23:45.862]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.862]                   signalCondition(cond)
[13:23:45.862]                 }
[13:23:45.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.862]                 "immediateCondition"))) {
[13:23:45.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.862]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.862]                   if (TRUE && !signal) {
[13:23:45.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.862]                     {
[13:23:45.862]                       inherits <- base::inherits
[13:23:45.862]                       invokeRestart <- base::invokeRestart
[13:23:45.862]                       is.null <- base::is.null
[13:23:45.862]                       muffled <- FALSE
[13:23:45.862]                       if (inherits(cond, "message")) {
[13:23:45.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.862]                         if (muffled) 
[13:23:45.862]                           invokeRestart("muffleMessage")
[13:23:45.862]                       }
[13:23:45.862]                       else if (inherits(cond, "warning")) {
[13:23:45.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.862]                         if (muffled) 
[13:23:45.862]                           invokeRestart("muffleWarning")
[13:23:45.862]                       }
[13:23:45.862]                       else if (inherits(cond, "condition")) {
[13:23:45.862]                         if (!is.null(pattern)) {
[13:23:45.862]                           computeRestarts <- base::computeRestarts
[13:23:45.862]                           grepl <- base::grepl
[13:23:45.862]                           restarts <- computeRestarts(cond)
[13:23:45.862]                           for (restart in restarts) {
[13:23:45.862]                             name <- restart$name
[13:23:45.862]                             if (is.null(name)) 
[13:23:45.862]                               next
[13:23:45.862]                             if (!grepl(pattern, name)) 
[13:23:45.862]                               next
[13:23:45.862]                             invokeRestart(restart)
[13:23:45.862]                             muffled <- TRUE
[13:23:45.862]                             break
[13:23:45.862]                           }
[13:23:45.862]                         }
[13:23:45.862]                       }
[13:23:45.862]                       invisible(muffled)
[13:23:45.862]                     }
[13:23:45.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.862]                   }
[13:23:45.862]                 }
[13:23:45.862]                 else {
[13:23:45.862]                   if (TRUE) {
[13:23:45.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.862]                     {
[13:23:45.862]                       inherits <- base::inherits
[13:23:45.862]                       invokeRestart <- base::invokeRestart
[13:23:45.862]                       is.null <- base::is.null
[13:23:45.862]                       muffled <- FALSE
[13:23:45.862]                       if (inherits(cond, "message")) {
[13:23:45.862]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.862]                         if (muffled) 
[13:23:45.862]                           invokeRestart("muffleMessage")
[13:23:45.862]                       }
[13:23:45.862]                       else if (inherits(cond, "warning")) {
[13:23:45.862]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.862]                         if (muffled) 
[13:23:45.862]                           invokeRestart("muffleWarning")
[13:23:45.862]                       }
[13:23:45.862]                       else if (inherits(cond, "condition")) {
[13:23:45.862]                         if (!is.null(pattern)) {
[13:23:45.862]                           computeRestarts <- base::computeRestarts
[13:23:45.862]                           grepl <- base::grepl
[13:23:45.862]                           restarts <- computeRestarts(cond)
[13:23:45.862]                           for (restart in restarts) {
[13:23:45.862]                             name <- restart$name
[13:23:45.862]                             if (is.null(name)) 
[13:23:45.862]                               next
[13:23:45.862]                             if (!grepl(pattern, name)) 
[13:23:45.862]                               next
[13:23:45.862]                             invokeRestart(restart)
[13:23:45.862]                             muffled <- TRUE
[13:23:45.862]                             break
[13:23:45.862]                           }
[13:23:45.862]                         }
[13:23:45.862]                       }
[13:23:45.862]                       invisible(muffled)
[13:23:45.862]                     }
[13:23:45.862]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.862]                   }
[13:23:45.862]                 }
[13:23:45.862]             }
[13:23:45.862]         }))
[13:23:45.862]     }, error = function(ex) {
[13:23:45.862]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.862]                 ...future.rng), started = ...future.startTime, 
[13:23:45.862]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.862]             version = "1.8"), class = "FutureResult")
[13:23:45.862]     }, finally = {
[13:23:45.862]         if (!identical(...future.workdir, getwd())) 
[13:23:45.862]             setwd(...future.workdir)
[13:23:45.862]         {
[13:23:45.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.862]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.862]             }
[13:23:45.862]             base::options(...future.oldOptions)
[13:23:45.862]             if (.Platform$OS.type == "windows") {
[13:23:45.862]                 old_names <- names(...future.oldEnvVars)
[13:23:45.862]                 envs <- base::Sys.getenv()
[13:23:45.862]                 names <- names(envs)
[13:23:45.862]                 common <- intersect(names, old_names)
[13:23:45.862]                 added <- setdiff(names, old_names)
[13:23:45.862]                 removed <- setdiff(old_names, names)
[13:23:45.862]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.862]                   envs[common]]
[13:23:45.862]                 NAMES <- toupper(changed)
[13:23:45.862]                 args <- list()
[13:23:45.862]                 for (kk in seq_along(NAMES)) {
[13:23:45.862]                   name <- changed[[kk]]
[13:23:45.862]                   NAME <- NAMES[[kk]]
[13:23:45.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.862]                     next
[13:23:45.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.862]                 }
[13:23:45.862]                 NAMES <- toupper(added)
[13:23:45.862]                 for (kk in seq_along(NAMES)) {
[13:23:45.862]                   name <- added[[kk]]
[13:23:45.862]                   NAME <- NAMES[[kk]]
[13:23:45.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.862]                     next
[13:23:45.862]                   args[[name]] <- ""
[13:23:45.862]                 }
[13:23:45.862]                 NAMES <- toupper(removed)
[13:23:45.862]                 for (kk in seq_along(NAMES)) {
[13:23:45.862]                   name <- removed[[kk]]
[13:23:45.862]                   NAME <- NAMES[[kk]]
[13:23:45.862]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.862]                     next
[13:23:45.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.862]                 }
[13:23:45.862]                 if (length(args) > 0) 
[13:23:45.862]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.862]             }
[13:23:45.862]             else {
[13:23:45.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.862]             }
[13:23:45.862]             {
[13:23:45.862]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.862]                   0L) {
[13:23:45.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.862]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.862]                   base::options(opts)
[13:23:45.862]                 }
[13:23:45.862]                 {
[13:23:45.862]                   {
[13:23:45.862]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.862]                     NULL
[13:23:45.862]                   }
[13:23:45.862]                   options(future.plan = NULL)
[13:23:45.862]                   if (is.na(NA_character_)) 
[13:23:45.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.862]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.862]                     envir = parent.frame()) 
[13:23:45.862]                   {
[13:23:45.862]                     default_workers <- missing(workers)
[13:23:45.862]                     if (is.function(workers)) 
[13:23:45.862]                       workers <- workers()
[13:23:45.862]                     workers <- structure(as.integer(workers), 
[13:23:45.862]                       class = class(workers))
[13:23:45.862]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.862]                       1L)
[13:23:45.862]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.862]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.862]                       if (default_workers) 
[13:23:45.862]                         supportsMulticore(warn = TRUE)
[13:23:45.862]                       return(sequential(..., envir = envir))
[13:23:45.862]                     }
[13:23:45.862]                     oopts <- options(mc.cores = workers)
[13:23:45.862]                     on.exit(options(oopts))
[13:23:45.862]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.862]                       envir = envir)
[13:23:45.862]                     if (!future$lazy) 
[13:23:45.862]                       future <- run(future)
[13:23:45.862]                     invisible(future)
[13:23:45.862]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.862]                 }
[13:23:45.862]             }
[13:23:45.862]         }
[13:23:45.862]     })
[13:23:45.862]     if (TRUE) {
[13:23:45.862]         base::sink(type = "output", split = FALSE)
[13:23:45.862]         if (TRUE) {
[13:23:45.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.862]         }
[13:23:45.862]         else {
[13:23:45.862]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.862]         }
[13:23:45.862]         base::close(...future.stdout)
[13:23:45.862]         ...future.stdout <- NULL
[13:23:45.862]     }
[13:23:45.862]     ...future.result$conditions <- ...future.conditions
[13:23:45.862]     ...future.result$finished <- base::Sys.time()
[13:23:45.862]     ...future.result
[13:23:45.862] }
[13:23:45.868] assign_globals() ...
[13:23:45.868] List of 1
[13:23:45.868]  $ a: num 0
[13:23:45.868]  - attr(*, "where")=List of 1
[13:23:45.868]   ..$ a:<environment: R_EmptyEnv> 
[13:23:45.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.868]  - attr(*, "resolved")= logi FALSE
[13:23:45.868]  - attr(*, "total_size")= num 56
[13:23:45.871] - copied ‘a’ to environment
[13:23:45.872] assign_globals() ... done
[13:23:45.872] requestCore(): workers = 2
[13:23:45.874] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:23:45.875] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 56 bytes (numeric ‘a’ of 56 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:45.875] List of future strategies:
[13:23:45.875] 1. sequential:
[13:23:45.875]    - args: function (..., envir = parent.frame())
[13:23:45.875]    - tweaked: FALSE
[13:23:45.875]    - call: NULL
[13:23:45.876] plan(): nbrOfWorkers() = 1
[13:23:45.878] plan(): Setting new future strategy stack:
[13:23:45.879] List of future strategies:
[13:23:45.879] 1. multicore:
[13:23:45.879]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.879]    - tweaked: FALSE
[13:23:45.879]    - call: plan(multicore)
[13:23:45.884] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:45.885] result() for MulticoreFuture ...
[13:23:45.886] result() for MulticoreFuture ...
[13:23:45.886] result() for MulticoreFuture ... done
[13:23:45.887] result() for MulticoreFuture ... done
[13:23:45.887] result() for MulticoreFuture ...
[13:23:45.887] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[13:23:45.891] getGlobalsAndPackages() ...
[13:23:45.892] Searching for globals...
[13:23:45.893] - globals found: [2] ‘{’, ‘ii’
[13:23:45.893] Searching for globals ... DONE
[13:23:45.893] Resolving globals: FALSE
[13:23:45.893] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.894] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.894] - globals: [1] ‘ii’
[13:23:45.894] 
[13:23:45.894] getGlobalsAndPackages() ... DONE
[13:23:45.895] Packages needed by the future expression (n = 0): <none>
[13:23:45.895] Packages needed by future strategies (n = 0): <none>
[13:23:45.896] {
[13:23:45.896]     {
[13:23:45.896]         {
[13:23:45.896]             ...future.startTime <- base::Sys.time()
[13:23:45.896]             {
[13:23:45.896]                 {
[13:23:45.896]                   {
[13:23:45.896]                     {
[13:23:45.896]                       base::local({
[13:23:45.896]                         has_future <- base::requireNamespace("future", 
[13:23:45.896]                           quietly = TRUE)
[13:23:45.896]                         if (has_future) {
[13:23:45.896]                           ns <- base::getNamespace("future")
[13:23:45.896]                           version <- ns[[".package"]][["version"]]
[13:23:45.896]                           if (is.null(version)) 
[13:23:45.896]                             version <- utils::packageVersion("future")
[13:23:45.896]                         }
[13:23:45.896]                         else {
[13:23:45.896]                           version <- NULL
[13:23:45.896]                         }
[13:23:45.896]                         if (!has_future || version < "1.8.0") {
[13:23:45.896]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.896]                             "", base::R.version$version.string), 
[13:23:45.896]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.896]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.896]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.896]                               "release", "version")], collapse = " "), 
[13:23:45.896]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.896]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.896]                             info)
[13:23:45.896]                           info <- base::paste(info, collapse = "; ")
[13:23:45.896]                           if (!has_future) {
[13:23:45.896]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.896]                               info)
[13:23:45.896]                           }
[13:23:45.896]                           else {
[13:23:45.896]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.896]                               info, version)
[13:23:45.896]                           }
[13:23:45.896]                           base::stop(msg)
[13:23:45.896]                         }
[13:23:45.896]                       })
[13:23:45.896]                     }
[13:23:45.896]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.896]                     base::options(mc.cores = 1L)
[13:23:45.896]                   }
[13:23:45.896]                   options(future.plan = NULL)
[13:23:45.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.896]                 }
[13:23:45.896]                 ...future.workdir <- getwd()
[13:23:45.896]             }
[13:23:45.896]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.896]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.896]         }
[13:23:45.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.896]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.896]             base::names(...future.oldOptions))
[13:23:45.896]     }
[13:23:45.896]     if (FALSE) {
[13:23:45.896]     }
[13:23:45.896]     else {
[13:23:45.896]         if (TRUE) {
[13:23:45.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.896]                 open = "w")
[13:23:45.896]         }
[13:23:45.896]         else {
[13:23:45.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.896]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.896]         }
[13:23:45.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.896]             base::sink(type = "output", split = FALSE)
[13:23:45.896]             base::close(...future.stdout)
[13:23:45.896]         }, add = TRUE)
[13:23:45.896]     }
[13:23:45.896]     ...future.frame <- base::sys.nframe()
[13:23:45.896]     ...future.conditions <- base::list()
[13:23:45.896]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.896]     if (FALSE) {
[13:23:45.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.896]     }
[13:23:45.896]     ...future.result <- base::tryCatch({
[13:23:45.896]         base::withCallingHandlers({
[13:23:45.896]             ...future.value <- base::withVisible(base::local({
[13:23:45.896]                 withCallingHandlers({
[13:23:45.896]                   {
[13:23:45.896]                     ii
[13:23:45.896]                   }
[13:23:45.896]                 }, immediateCondition = function(cond) {
[13:23:45.896]                   save_rds <- function (object, pathname, ...) 
[13:23:45.896]                   {
[13:23:45.896]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.896]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.896]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.896]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.896]                         fi_tmp[["mtime"]])
[13:23:45.896]                     }
[13:23:45.896]                     tryCatch({
[13:23:45.896]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.896]                     }, error = function(ex) {
[13:23:45.896]                       msg <- conditionMessage(ex)
[13:23:45.896]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.896]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.896]                         fi_tmp[["mtime"]], msg)
[13:23:45.896]                       ex$message <- msg
[13:23:45.896]                       stop(ex)
[13:23:45.896]                     })
[13:23:45.896]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.896]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.896]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.896]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.896]                       fi <- file.info(pathname)
[13:23:45.896]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.896]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.896]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.896]                         fi[["size"]], fi[["mtime"]])
[13:23:45.896]                       stop(msg)
[13:23:45.896]                     }
[13:23:45.896]                     invisible(pathname)
[13:23:45.896]                   }
[13:23:45.896]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.896]                     rootPath = tempdir()) 
[13:23:45.896]                   {
[13:23:45.896]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.896]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.896]                       tmpdir = path, fileext = ".rds")
[13:23:45.896]                     save_rds(obj, file)
[13:23:45.896]                   }
[13:23:45.896]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.896]                   {
[13:23:45.896]                     inherits <- base::inherits
[13:23:45.896]                     invokeRestart <- base::invokeRestart
[13:23:45.896]                     is.null <- base::is.null
[13:23:45.896]                     muffled <- FALSE
[13:23:45.896]                     if (inherits(cond, "message")) {
[13:23:45.896]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.896]                       if (muffled) 
[13:23:45.896]                         invokeRestart("muffleMessage")
[13:23:45.896]                     }
[13:23:45.896]                     else if (inherits(cond, "warning")) {
[13:23:45.896]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.896]                       if (muffled) 
[13:23:45.896]                         invokeRestart("muffleWarning")
[13:23:45.896]                     }
[13:23:45.896]                     else if (inherits(cond, "condition")) {
[13:23:45.896]                       if (!is.null(pattern)) {
[13:23:45.896]                         computeRestarts <- base::computeRestarts
[13:23:45.896]                         grepl <- base::grepl
[13:23:45.896]                         restarts <- computeRestarts(cond)
[13:23:45.896]                         for (restart in restarts) {
[13:23:45.896]                           name <- restart$name
[13:23:45.896]                           if (is.null(name)) 
[13:23:45.896]                             next
[13:23:45.896]                           if (!grepl(pattern, name)) 
[13:23:45.896]                             next
[13:23:45.896]                           invokeRestart(restart)
[13:23:45.896]                           muffled <- TRUE
[13:23:45.896]                           break
[13:23:45.896]                         }
[13:23:45.896]                       }
[13:23:45.896]                     }
[13:23:45.896]                     invisible(muffled)
[13:23:45.896]                   }
[13:23:45.896]                   muffleCondition(cond)
[13:23:45.896]                 })
[13:23:45.896]             }))
[13:23:45.896]             future::FutureResult(value = ...future.value$value, 
[13:23:45.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.896]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.896]                     ...future.globalenv.names))
[13:23:45.896]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.896]         }, condition = base::local({
[13:23:45.896]             c <- base::c
[13:23:45.896]             inherits <- base::inherits
[13:23:45.896]             invokeRestart <- base::invokeRestart
[13:23:45.896]             length <- base::length
[13:23:45.896]             list <- base::list
[13:23:45.896]             seq.int <- base::seq.int
[13:23:45.896]             signalCondition <- base::signalCondition
[13:23:45.896]             sys.calls <- base::sys.calls
[13:23:45.896]             `[[` <- base::`[[`
[13:23:45.896]             `+` <- base::`+`
[13:23:45.896]             `<<-` <- base::`<<-`
[13:23:45.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.896]                   3L)]
[13:23:45.896]             }
[13:23:45.896]             function(cond) {
[13:23:45.896]                 is_error <- inherits(cond, "error")
[13:23:45.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.896]                   NULL)
[13:23:45.896]                 if (is_error) {
[13:23:45.896]                   sessionInformation <- function() {
[13:23:45.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.896]                       search = base::search(), system = base::Sys.info())
[13:23:45.896]                   }
[13:23:45.896]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.896]                     cond$call), session = sessionInformation(), 
[13:23:45.896]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.896]                   signalCondition(cond)
[13:23:45.896]                 }
[13:23:45.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.896]                 "immediateCondition"))) {
[13:23:45.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.896]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.896]                   if (TRUE && !signal) {
[13:23:45.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.896]                     {
[13:23:45.896]                       inherits <- base::inherits
[13:23:45.896]                       invokeRestart <- base::invokeRestart
[13:23:45.896]                       is.null <- base::is.null
[13:23:45.896]                       muffled <- FALSE
[13:23:45.896]                       if (inherits(cond, "message")) {
[13:23:45.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.896]                         if (muffled) 
[13:23:45.896]                           invokeRestart("muffleMessage")
[13:23:45.896]                       }
[13:23:45.896]                       else if (inherits(cond, "warning")) {
[13:23:45.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.896]                         if (muffled) 
[13:23:45.896]                           invokeRestart("muffleWarning")
[13:23:45.896]                       }
[13:23:45.896]                       else if (inherits(cond, "condition")) {
[13:23:45.896]                         if (!is.null(pattern)) {
[13:23:45.896]                           computeRestarts <- base::computeRestarts
[13:23:45.896]                           grepl <- base::grepl
[13:23:45.896]                           restarts <- computeRestarts(cond)
[13:23:45.896]                           for (restart in restarts) {
[13:23:45.896]                             name <- restart$name
[13:23:45.896]                             if (is.null(name)) 
[13:23:45.896]                               next
[13:23:45.896]                             if (!grepl(pattern, name)) 
[13:23:45.896]                               next
[13:23:45.896]                             invokeRestart(restart)
[13:23:45.896]                             muffled <- TRUE
[13:23:45.896]                             break
[13:23:45.896]                           }
[13:23:45.896]                         }
[13:23:45.896]                       }
[13:23:45.896]                       invisible(muffled)
[13:23:45.896]                     }
[13:23:45.896]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.896]                   }
[13:23:45.896]                 }
[13:23:45.896]                 else {
[13:23:45.896]                   if (TRUE) {
[13:23:45.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.896]                     {
[13:23:45.896]                       inherits <- base::inherits
[13:23:45.896]                       invokeRestart <- base::invokeRestart
[13:23:45.896]                       is.null <- base::is.null
[13:23:45.896]                       muffled <- FALSE
[13:23:45.896]                       if (inherits(cond, "message")) {
[13:23:45.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.896]                         if (muffled) 
[13:23:45.896]                           invokeRestart("muffleMessage")
[13:23:45.896]                       }
[13:23:45.896]                       else if (inherits(cond, "warning")) {
[13:23:45.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.896]                         if (muffled) 
[13:23:45.896]                           invokeRestart("muffleWarning")
[13:23:45.896]                       }
[13:23:45.896]                       else if (inherits(cond, "condition")) {
[13:23:45.896]                         if (!is.null(pattern)) {
[13:23:45.896]                           computeRestarts <- base::computeRestarts
[13:23:45.896]                           grepl <- base::grepl
[13:23:45.896]                           restarts <- computeRestarts(cond)
[13:23:45.896]                           for (restart in restarts) {
[13:23:45.896]                             name <- restart$name
[13:23:45.896]                             if (is.null(name)) 
[13:23:45.896]                               next
[13:23:45.896]                             if (!grepl(pattern, name)) 
[13:23:45.896]                               next
[13:23:45.896]                             invokeRestart(restart)
[13:23:45.896]                             muffled <- TRUE
[13:23:45.896]                             break
[13:23:45.896]                           }
[13:23:45.896]                         }
[13:23:45.896]                       }
[13:23:45.896]                       invisible(muffled)
[13:23:45.896]                     }
[13:23:45.896]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.896]                   }
[13:23:45.896]                 }
[13:23:45.896]             }
[13:23:45.896]         }))
[13:23:45.896]     }, error = function(ex) {
[13:23:45.896]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.896]                 ...future.rng), started = ...future.startTime, 
[13:23:45.896]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.896]             version = "1.8"), class = "FutureResult")
[13:23:45.896]     }, finally = {
[13:23:45.896]         if (!identical(...future.workdir, getwd())) 
[13:23:45.896]             setwd(...future.workdir)
[13:23:45.896]         {
[13:23:45.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.896]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.896]             }
[13:23:45.896]             base::options(...future.oldOptions)
[13:23:45.896]             if (.Platform$OS.type == "windows") {
[13:23:45.896]                 old_names <- names(...future.oldEnvVars)
[13:23:45.896]                 envs <- base::Sys.getenv()
[13:23:45.896]                 names <- names(envs)
[13:23:45.896]                 common <- intersect(names, old_names)
[13:23:45.896]                 added <- setdiff(names, old_names)
[13:23:45.896]                 removed <- setdiff(old_names, names)
[13:23:45.896]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.896]                   envs[common]]
[13:23:45.896]                 NAMES <- toupper(changed)
[13:23:45.896]                 args <- list()
[13:23:45.896]                 for (kk in seq_along(NAMES)) {
[13:23:45.896]                   name <- changed[[kk]]
[13:23:45.896]                   NAME <- NAMES[[kk]]
[13:23:45.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.896]                     next
[13:23:45.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.896]                 }
[13:23:45.896]                 NAMES <- toupper(added)
[13:23:45.896]                 for (kk in seq_along(NAMES)) {
[13:23:45.896]                   name <- added[[kk]]
[13:23:45.896]                   NAME <- NAMES[[kk]]
[13:23:45.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.896]                     next
[13:23:45.896]                   args[[name]] <- ""
[13:23:45.896]                 }
[13:23:45.896]                 NAMES <- toupper(removed)
[13:23:45.896]                 for (kk in seq_along(NAMES)) {
[13:23:45.896]                   name <- removed[[kk]]
[13:23:45.896]                   NAME <- NAMES[[kk]]
[13:23:45.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.896]                     next
[13:23:45.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.896]                 }
[13:23:45.896]                 if (length(args) > 0) 
[13:23:45.896]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.896]             }
[13:23:45.896]             else {
[13:23:45.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.896]             }
[13:23:45.896]             {
[13:23:45.896]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.896]                   0L) {
[13:23:45.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.896]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.896]                   base::options(opts)
[13:23:45.896]                 }
[13:23:45.896]                 {
[13:23:45.896]                   {
[13:23:45.896]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.896]                     NULL
[13:23:45.896]                   }
[13:23:45.896]                   options(future.plan = NULL)
[13:23:45.896]                   if (is.na(NA_character_)) 
[13:23:45.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.896]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.896]                     envir = parent.frame()) 
[13:23:45.896]                   {
[13:23:45.896]                     default_workers <- missing(workers)
[13:23:45.896]                     if (is.function(workers)) 
[13:23:45.896]                       workers <- workers()
[13:23:45.896]                     workers <- structure(as.integer(workers), 
[13:23:45.896]                       class = class(workers))
[13:23:45.896]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.896]                       1L)
[13:23:45.896]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.896]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.896]                       if (default_workers) 
[13:23:45.896]                         supportsMulticore(warn = TRUE)
[13:23:45.896]                       return(sequential(..., envir = envir))
[13:23:45.896]                     }
[13:23:45.896]                     oopts <- options(mc.cores = workers)
[13:23:45.896]                     on.exit(options(oopts))
[13:23:45.896]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.896]                       envir = envir)
[13:23:45.896]                     if (!future$lazy) 
[13:23:45.896]                       future <- run(future)
[13:23:45.896]                     invisible(future)
[13:23:45.896]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.896]                 }
[13:23:45.896]             }
[13:23:45.896]         }
[13:23:45.896]     })
[13:23:45.896]     if (TRUE) {
[13:23:45.896]         base::sink(type = "output", split = FALSE)
[13:23:45.896]         if (TRUE) {
[13:23:45.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.896]         }
[13:23:45.896]         else {
[13:23:45.896]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.896]         }
[13:23:45.896]         base::close(...future.stdout)
[13:23:45.896]         ...future.stdout <- NULL
[13:23:45.896]     }
[13:23:45.896]     ...future.result$conditions <- ...future.conditions
[13:23:45.896]     ...future.result$finished <- base::Sys.time()
[13:23:45.896]     ...future.result
[13:23:45.896] }
[13:23:45.899] assign_globals() ...
[13:23:45.899] List of 1
[13:23:45.899]  $ ii: int 1
[13:23:45.899]  - attr(*, "where")=List of 1
[13:23:45.899]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.899]  - attr(*, "resolved")= logi FALSE
[13:23:45.899]  - attr(*, "total_size")= num 56
[13:23:45.902] - copied ‘ii’ to environment
[13:23:45.902] assign_globals() ... done
[13:23:45.902] requestCore(): workers = 2
[13:23:45.904] MulticoreFuture started
 - Creating multicore future #2 ...
[13:23:45.905] plan(): Setting new future strategy stack:
[13:23:45.906] List of future strategies:
[13:23:45.906] 1. sequential:
[13:23:45.906]    - args: function (..., envir = parent.frame())
[13:23:45.906]    - tweaked: FALSE
[13:23:45.906]    - call: NULL
[13:23:45.906] plan(): nbrOfWorkers() = 1
[13:23:45.908] plan(): Setting new future strategy stack:
[13:23:45.909] List of future strategies:
[13:23:45.909] 1. multicore:
[13:23:45.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.909]    - tweaked: FALSE
[13:23:45.909]    - call: plan(multicore)
[13:23:45.911] getGlobalsAndPackages() ...
[13:23:45.911] Searching for globals...
[13:23:45.912] - globals found: [2] ‘{’, ‘ii’
[13:23:45.913] Searching for globals ... DONE
[13:23:45.913] Resolving globals: FALSE
[13:23:45.914] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.914] plan(): nbrOfWorkers() = 2
[13:23:45.915] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.915] - globals: [1] ‘ii’
[13:23:45.915] 
[13:23:45.915] getGlobalsAndPackages() ... DONE
[13:23:45.916] Packages needed by the future expression (n = 0): <none>
[13:23:45.916] Packages needed by future strategies (n = 0): <none>
[13:23:45.917] {
[13:23:45.917]     {
[13:23:45.917]         {
[13:23:45.917]             ...future.startTime <- base::Sys.time()
[13:23:45.917]             {
[13:23:45.917]                 {
[13:23:45.917]                   {
[13:23:45.917]                     {
[13:23:45.917]                       base::local({
[13:23:45.917]                         has_future <- base::requireNamespace("future", 
[13:23:45.917]                           quietly = TRUE)
[13:23:45.917]                         if (has_future) {
[13:23:45.917]                           ns <- base::getNamespace("future")
[13:23:45.917]                           version <- ns[[".package"]][["version"]]
[13:23:45.917]                           if (is.null(version)) 
[13:23:45.917]                             version <- utils::packageVersion("future")
[13:23:45.917]                         }
[13:23:45.917]                         else {
[13:23:45.917]                           version <- NULL
[13:23:45.917]                         }
[13:23:45.917]                         if (!has_future || version < "1.8.0") {
[13:23:45.917]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.917]                             "", base::R.version$version.string), 
[13:23:45.917]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.917]                               "release", "version")], collapse = " "), 
[13:23:45.917]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.917]                             info)
[13:23:45.917]                           info <- base::paste(info, collapse = "; ")
[13:23:45.917]                           if (!has_future) {
[13:23:45.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.917]                               info)
[13:23:45.917]                           }
[13:23:45.917]                           else {
[13:23:45.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.917]                               info, version)
[13:23:45.917]                           }
[13:23:45.917]                           base::stop(msg)
[13:23:45.917]                         }
[13:23:45.917]                       })
[13:23:45.917]                     }
[13:23:45.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.917]                     base::options(mc.cores = 1L)
[13:23:45.917]                   }
[13:23:45.917]                   options(future.plan = NULL)
[13:23:45.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.917]                 }
[13:23:45.917]                 ...future.workdir <- getwd()
[13:23:45.917]             }
[13:23:45.917]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.917]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.917]         }
[13:23:45.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.917]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.917]             base::names(...future.oldOptions))
[13:23:45.917]     }
[13:23:45.917]     if (FALSE) {
[13:23:45.917]     }
[13:23:45.917]     else {
[13:23:45.917]         if (TRUE) {
[13:23:45.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.917]                 open = "w")
[13:23:45.917]         }
[13:23:45.917]         else {
[13:23:45.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.917]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.917]         }
[13:23:45.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.917]             base::sink(type = "output", split = FALSE)
[13:23:45.917]             base::close(...future.stdout)
[13:23:45.917]         }, add = TRUE)
[13:23:45.917]     }
[13:23:45.917]     ...future.frame <- base::sys.nframe()
[13:23:45.917]     ...future.conditions <- base::list()
[13:23:45.917]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.917]     if (FALSE) {
[13:23:45.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.917]     }
[13:23:45.917]     ...future.result <- base::tryCatch({
[13:23:45.917]         base::withCallingHandlers({
[13:23:45.917]             ...future.value <- base::withVisible(base::local({
[13:23:45.917]                 withCallingHandlers({
[13:23:45.917]                   {
[13:23:45.917]                     ii
[13:23:45.917]                   }
[13:23:45.917]                 }, immediateCondition = function(cond) {
[13:23:45.917]                   save_rds <- function (object, pathname, ...) 
[13:23:45.917]                   {
[13:23:45.917]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.917]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.917]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.917]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.917]                         fi_tmp[["mtime"]])
[13:23:45.917]                     }
[13:23:45.917]                     tryCatch({
[13:23:45.917]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.917]                     }, error = function(ex) {
[13:23:45.917]                       msg <- conditionMessage(ex)
[13:23:45.917]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.917]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.917]                         fi_tmp[["mtime"]], msg)
[13:23:45.917]                       ex$message <- msg
[13:23:45.917]                       stop(ex)
[13:23:45.917]                     })
[13:23:45.917]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.917]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.917]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.917]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.917]                       fi <- file.info(pathname)
[13:23:45.917]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.917]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.917]                         fi[["size"]], fi[["mtime"]])
[13:23:45.917]                       stop(msg)
[13:23:45.917]                     }
[13:23:45.917]                     invisible(pathname)
[13:23:45.917]                   }
[13:23:45.917]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.917]                     rootPath = tempdir()) 
[13:23:45.917]                   {
[13:23:45.917]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.917]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.917]                       tmpdir = path, fileext = ".rds")
[13:23:45.917]                     save_rds(obj, file)
[13:23:45.917]                   }
[13:23:45.917]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.917]                   {
[13:23:45.917]                     inherits <- base::inherits
[13:23:45.917]                     invokeRestart <- base::invokeRestart
[13:23:45.917]                     is.null <- base::is.null
[13:23:45.917]                     muffled <- FALSE
[13:23:45.917]                     if (inherits(cond, "message")) {
[13:23:45.917]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.917]                       if (muffled) 
[13:23:45.917]                         invokeRestart("muffleMessage")
[13:23:45.917]                     }
[13:23:45.917]                     else if (inherits(cond, "warning")) {
[13:23:45.917]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.917]                       if (muffled) 
[13:23:45.917]                         invokeRestart("muffleWarning")
[13:23:45.917]                     }
[13:23:45.917]                     else if (inherits(cond, "condition")) {
[13:23:45.917]                       if (!is.null(pattern)) {
[13:23:45.917]                         computeRestarts <- base::computeRestarts
[13:23:45.917]                         grepl <- base::grepl
[13:23:45.917]                         restarts <- computeRestarts(cond)
[13:23:45.917]                         for (restart in restarts) {
[13:23:45.917]                           name <- restart$name
[13:23:45.917]                           if (is.null(name)) 
[13:23:45.917]                             next
[13:23:45.917]                           if (!grepl(pattern, name)) 
[13:23:45.917]                             next
[13:23:45.917]                           invokeRestart(restart)
[13:23:45.917]                           muffled <- TRUE
[13:23:45.917]                           break
[13:23:45.917]                         }
[13:23:45.917]                       }
[13:23:45.917]                     }
[13:23:45.917]                     invisible(muffled)
[13:23:45.917]                   }
[13:23:45.917]                   muffleCondition(cond)
[13:23:45.917]                 })
[13:23:45.917]             }))
[13:23:45.917]             future::FutureResult(value = ...future.value$value, 
[13:23:45.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.917]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.917]                     ...future.globalenv.names))
[13:23:45.917]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.917]         }, condition = base::local({
[13:23:45.917]             c <- base::c
[13:23:45.917]             inherits <- base::inherits
[13:23:45.917]             invokeRestart <- base::invokeRestart
[13:23:45.917]             length <- base::length
[13:23:45.917]             list <- base::list
[13:23:45.917]             seq.int <- base::seq.int
[13:23:45.917]             signalCondition <- base::signalCondition
[13:23:45.917]             sys.calls <- base::sys.calls
[13:23:45.917]             `[[` <- base::`[[`
[13:23:45.917]             `+` <- base::`+`
[13:23:45.917]             `<<-` <- base::`<<-`
[13:23:45.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.917]                   3L)]
[13:23:45.917]             }
[13:23:45.917]             function(cond) {
[13:23:45.917]                 is_error <- inherits(cond, "error")
[13:23:45.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.917]                   NULL)
[13:23:45.917]                 if (is_error) {
[13:23:45.917]                   sessionInformation <- function() {
[13:23:45.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.917]                       search = base::search(), system = base::Sys.info())
[13:23:45.917]                   }
[13:23:45.917]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.917]                     cond$call), session = sessionInformation(), 
[13:23:45.917]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.917]                   signalCondition(cond)
[13:23:45.917]                 }
[13:23:45.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.917]                 "immediateCondition"))) {
[13:23:45.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.917]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.917]                   if (TRUE && !signal) {
[13:23:45.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.917]                     {
[13:23:45.917]                       inherits <- base::inherits
[13:23:45.917]                       invokeRestart <- base::invokeRestart
[13:23:45.917]                       is.null <- base::is.null
[13:23:45.917]                       muffled <- FALSE
[13:23:45.917]                       if (inherits(cond, "message")) {
[13:23:45.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.917]                         if (muffled) 
[13:23:45.917]                           invokeRestart("muffleMessage")
[13:23:45.917]                       }
[13:23:45.917]                       else if (inherits(cond, "warning")) {
[13:23:45.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.917]                         if (muffled) 
[13:23:45.917]                           invokeRestart("muffleWarning")
[13:23:45.917]                       }
[13:23:45.917]                       else if (inherits(cond, "condition")) {
[13:23:45.917]                         if (!is.null(pattern)) {
[13:23:45.917]                           computeRestarts <- base::computeRestarts
[13:23:45.917]                           grepl <- base::grepl
[13:23:45.917]                           restarts <- computeRestarts(cond)
[13:23:45.917]                           for (restart in restarts) {
[13:23:45.917]                             name <- restart$name
[13:23:45.917]                             if (is.null(name)) 
[13:23:45.917]                               next
[13:23:45.917]                             if (!grepl(pattern, name)) 
[13:23:45.917]                               next
[13:23:45.917]                             invokeRestart(restart)
[13:23:45.917]                             muffled <- TRUE
[13:23:45.917]                             break
[13:23:45.917]                           }
[13:23:45.917]                         }
[13:23:45.917]                       }
[13:23:45.917]                       invisible(muffled)
[13:23:45.917]                     }
[13:23:45.917]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.917]                   }
[13:23:45.917]                 }
[13:23:45.917]                 else {
[13:23:45.917]                   if (TRUE) {
[13:23:45.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.917]                     {
[13:23:45.917]                       inherits <- base::inherits
[13:23:45.917]                       invokeRestart <- base::invokeRestart
[13:23:45.917]                       is.null <- base::is.null
[13:23:45.917]                       muffled <- FALSE
[13:23:45.917]                       if (inherits(cond, "message")) {
[13:23:45.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.917]                         if (muffled) 
[13:23:45.917]                           invokeRestart("muffleMessage")
[13:23:45.917]                       }
[13:23:45.917]                       else if (inherits(cond, "warning")) {
[13:23:45.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.917]                         if (muffled) 
[13:23:45.917]                           invokeRestart("muffleWarning")
[13:23:45.917]                       }
[13:23:45.917]                       else if (inherits(cond, "condition")) {
[13:23:45.917]                         if (!is.null(pattern)) {
[13:23:45.917]                           computeRestarts <- base::computeRestarts
[13:23:45.917]                           grepl <- base::grepl
[13:23:45.917]                           restarts <- computeRestarts(cond)
[13:23:45.917]                           for (restart in restarts) {
[13:23:45.917]                             name <- restart$name
[13:23:45.917]                             if (is.null(name)) 
[13:23:45.917]                               next
[13:23:45.917]                             if (!grepl(pattern, name)) 
[13:23:45.917]                               next
[13:23:45.917]                             invokeRestart(restart)
[13:23:45.917]                             muffled <- TRUE
[13:23:45.917]                             break
[13:23:45.917]                           }
[13:23:45.917]                         }
[13:23:45.917]                       }
[13:23:45.917]                       invisible(muffled)
[13:23:45.917]                     }
[13:23:45.917]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.917]                   }
[13:23:45.917]                 }
[13:23:45.917]             }
[13:23:45.917]         }))
[13:23:45.917]     }, error = function(ex) {
[13:23:45.917]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.917]                 ...future.rng), started = ...future.startTime, 
[13:23:45.917]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.917]             version = "1.8"), class = "FutureResult")
[13:23:45.917]     }, finally = {
[13:23:45.917]         if (!identical(...future.workdir, getwd())) 
[13:23:45.917]             setwd(...future.workdir)
[13:23:45.917]         {
[13:23:45.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.917]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.917]             }
[13:23:45.917]             base::options(...future.oldOptions)
[13:23:45.917]             if (.Platform$OS.type == "windows") {
[13:23:45.917]                 old_names <- names(...future.oldEnvVars)
[13:23:45.917]                 envs <- base::Sys.getenv()
[13:23:45.917]                 names <- names(envs)
[13:23:45.917]                 common <- intersect(names, old_names)
[13:23:45.917]                 added <- setdiff(names, old_names)
[13:23:45.917]                 removed <- setdiff(old_names, names)
[13:23:45.917]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.917]                   envs[common]]
[13:23:45.917]                 NAMES <- toupper(changed)
[13:23:45.917]                 args <- list()
[13:23:45.917]                 for (kk in seq_along(NAMES)) {
[13:23:45.917]                   name <- changed[[kk]]
[13:23:45.917]                   NAME <- NAMES[[kk]]
[13:23:45.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.917]                     next
[13:23:45.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.917]                 }
[13:23:45.917]                 NAMES <- toupper(added)
[13:23:45.917]                 for (kk in seq_along(NAMES)) {
[13:23:45.917]                   name <- added[[kk]]
[13:23:45.917]                   NAME <- NAMES[[kk]]
[13:23:45.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.917]                     next
[13:23:45.917]                   args[[name]] <- ""
[13:23:45.917]                 }
[13:23:45.917]                 NAMES <- toupper(removed)
[13:23:45.917]                 for (kk in seq_along(NAMES)) {
[13:23:45.917]                   name <- removed[[kk]]
[13:23:45.917]                   NAME <- NAMES[[kk]]
[13:23:45.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.917]                     next
[13:23:45.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.917]                 }
[13:23:45.917]                 if (length(args) > 0) 
[13:23:45.917]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.917]             }
[13:23:45.917]             else {
[13:23:45.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.917]             }
[13:23:45.917]             {
[13:23:45.917]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.917]                   0L) {
[13:23:45.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.917]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.917]                   base::options(opts)
[13:23:45.917]                 }
[13:23:45.917]                 {
[13:23:45.917]                   {
[13:23:45.917]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.917]                     NULL
[13:23:45.917]                   }
[13:23:45.917]                   options(future.plan = NULL)
[13:23:45.917]                   if (is.na(NA_character_)) 
[13:23:45.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.917]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.917]                     envir = parent.frame()) 
[13:23:45.917]                   {
[13:23:45.917]                     default_workers <- missing(workers)
[13:23:45.917]                     if (is.function(workers)) 
[13:23:45.917]                       workers <- workers()
[13:23:45.917]                     workers <- structure(as.integer(workers), 
[13:23:45.917]                       class = class(workers))
[13:23:45.917]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.917]                       1L)
[13:23:45.917]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.917]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.917]                       if (default_workers) 
[13:23:45.917]                         supportsMulticore(warn = TRUE)
[13:23:45.917]                       return(sequential(..., envir = envir))
[13:23:45.917]                     }
[13:23:45.917]                     oopts <- options(mc.cores = workers)
[13:23:45.917]                     on.exit(options(oopts))
[13:23:45.917]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.917]                       envir = envir)
[13:23:45.917]                     if (!future$lazy) 
[13:23:45.917]                       future <- run(future)
[13:23:45.917]                     invisible(future)
[13:23:45.917]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.917]                 }
[13:23:45.917]             }
[13:23:45.917]         }
[13:23:45.917]     })
[13:23:45.917]     if (TRUE) {
[13:23:45.917]         base::sink(type = "output", split = FALSE)
[13:23:45.917]         if (TRUE) {
[13:23:45.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.917]         }
[13:23:45.917]         else {
[13:23:45.917]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.917]         }
[13:23:45.917]         base::close(...future.stdout)
[13:23:45.917]         ...future.stdout <- NULL
[13:23:45.917]     }
[13:23:45.917]     ...future.result$conditions <- ...future.conditions
[13:23:45.917]     ...future.result$finished <- base::Sys.time()
[13:23:45.917]     ...future.result
[13:23:45.917] }
[13:23:45.921] assign_globals() ...
[13:23:45.921] List of 1
[13:23:45.921]  $ ii: int 2
[13:23:45.921]  - attr(*, "where")=List of 1
[13:23:45.921]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.921]  - attr(*, "resolved")= logi FALSE
[13:23:45.921]  - attr(*, "total_size")= num 56
[13:23:45.925] - copied ‘ii’ to environment
[13:23:45.925] assign_globals() ... done
[13:23:45.925] requestCore(): workers = 2
[13:23:45.927] MulticoreFuture started
 - Creating multicore future #3 ...
[13:23:45.929] plan(): Setting new future strategy stack:
[13:23:45.929] List of future strategies:
[13:23:45.929] 1. sequential:
[13:23:45.929]    - args: function (..., envir = parent.frame())
[13:23:45.929]    - tweaked: FALSE
[13:23:45.929]    - call: NULL
[13:23:45.930] plan(): nbrOfWorkers() = 1
[13:23:45.932] plan(): Setting new future strategy stack:
[13:23:45.932] List of future strategies:
[13:23:45.932] 1. multicore:
[13:23:45.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.932]    - tweaked: FALSE
[13:23:45.932]    - call: plan(multicore)
[13:23:45.934] getGlobalsAndPackages() ...
[13:23:45.934] Searching for globals...
[13:23:45.941] - globals found: [2] ‘{’, ‘ii’
[13:23:45.942] Searching for globals ... DONE
[13:23:45.942] Resolving globals: FALSE
[13:23:45.943] plan(): nbrOfWorkers() = 2
[13:23:45.943] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.944] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.944] - globals: [1] ‘ii’
[13:23:45.945] 
[13:23:45.945] getGlobalsAndPackages() ... DONE
[13:23:45.946] Packages needed by the future expression (n = 0): <none>
[13:23:45.946] Packages needed by future strategies (n = 0): <none>
[13:23:45.947] {
[13:23:45.947]     {
[13:23:45.947]         {
[13:23:45.947]             ...future.startTime <- base::Sys.time()
[13:23:45.947]             {
[13:23:45.947]                 {
[13:23:45.947]                   {
[13:23:45.947]                     {
[13:23:45.947]                       base::local({
[13:23:45.947]                         has_future <- base::requireNamespace("future", 
[13:23:45.947]                           quietly = TRUE)
[13:23:45.947]                         if (has_future) {
[13:23:45.947]                           ns <- base::getNamespace("future")
[13:23:45.947]                           version <- ns[[".package"]][["version"]]
[13:23:45.947]                           if (is.null(version)) 
[13:23:45.947]                             version <- utils::packageVersion("future")
[13:23:45.947]                         }
[13:23:45.947]                         else {
[13:23:45.947]                           version <- NULL
[13:23:45.947]                         }
[13:23:45.947]                         if (!has_future || version < "1.8.0") {
[13:23:45.947]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.947]                             "", base::R.version$version.string), 
[13:23:45.947]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.947]                               "release", "version")], collapse = " "), 
[13:23:45.947]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.947]                             info)
[13:23:45.947]                           info <- base::paste(info, collapse = "; ")
[13:23:45.947]                           if (!has_future) {
[13:23:45.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.947]                               info)
[13:23:45.947]                           }
[13:23:45.947]                           else {
[13:23:45.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.947]                               info, version)
[13:23:45.947]                           }
[13:23:45.947]                           base::stop(msg)
[13:23:45.947]                         }
[13:23:45.947]                       })
[13:23:45.947]                     }
[13:23:45.947]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.947]                     base::options(mc.cores = 1L)
[13:23:45.947]                   }
[13:23:45.947]                   options(future.plan = NULL)
[13:23:45.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.947]                 }
[13:23:45.947]                 ...future.workdir <- getwd()
[13:23:45.947]             }
[13:23:45.947]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.947]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.947]         }
[13:23:45.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.947]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.947]             base::names(...future.oldOptions))
[13:23:45.947]     }
[13:23:45.947]     if (FALSE) {
[13:23:45.947]     }
[13:23:45.947]     else {
[13:23:45.947]         if (TRUE) {
[13:23:45.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.947]                 open = "w")
[13:23:45.947]         }
[13:23:45.947]         else {
[13:23:45.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.947]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.947]         }
[13:23:45.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.947]             base::sink(type = "output", split = FALSE)
[13:23:45.947]             base::close(...future.stdout)
[13:23:45.947]         }, add = TRUE)
[13:23:45.947]     }
[13:23:45.947]     ...future.frame <- base::sys.nframe()
[13:23:45.947]     ...future.conditions <- base::list()
[13:23:45.947]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.947]     if (FALSE) {
[13:23:45.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.947]     }
[13:23:45.947]     ...future.result <- base::tryCatch({
[13:23:45.947]         base::withCallingHandlers({
[13:23:45.947]             ...future.value <- base::withVisible(base::local({
[13:23:45.947]                 withCallingHandlers({
[13:23:45.947]                   {
[13:23:45.947]                     ii
[13:23:45.947]                   }
[13:23:45.947]                 }, immediateCondition = function(cond) {
[13:23:45.947]                   save_rds <- function (object, pathname, ...) 
[13:23:45.947]                   {
[13:23:45.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.947]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.947]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.947]                         fi_tmp[["mtime"]])
[13:23:45.947]                     }
[13:23:45.947]                     tryCatch({
[13:23:45.947]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.947]                     }, error = function(ex) {
[13:23:45.947]                       msg <- conditionMessage(ex)
[13:23:45.947]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.947]                         fi_tmp[["mtime"]], msg)
[13:23:45.947]                       ex$message <- msg
[13:23:45.947]                       stop(ex)
[13:23:45.947]                     })
[13:23:45.947]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.947]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.947]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.947]                       fi <- file.info(pathname)
[13:23:45.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.947]                         fi[["size"]], fi[["mtime"]])
[13:23:45.947]                       stop(msg)
[13:23:45.947]                     }
[13:23:45.947]                     invisible(pathname)
[13:23:45.947]                   }
[13:23:45.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.947]                     rootPath = tempdir()) 
[13:23:45.947]                   {
[13:23:45.947]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.947]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.947]                       tmpdir = path, fileext = ".rds")
[13:23:45.947]                     save_rds(obj, file)
[13:23:45.947]                   }
[13:23:45.947]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.947]                   {
[13:23:45.947]                     inherits <- base::inherits
[13:23:45.947]                     invokeRestart <- base::invokeRestart
[13:23:45.947]                     is.null <- base::is.null
[13:23:45.947]                     muffled <- FALSE
[13:23:45.947]                     if (inherits(cond, "message")) {
[13:23:45.947]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.947]                       if (muffled) 
[13:23:45.947]                         invokeRestart("muffleMessage")
[13:23:45.947]                     }
[13:23:45.947]                     else if (inherits(cond, "warning")) {
[13:23:45.947]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.947]                       if (muffled) 
[13:23:45.947]                         invokeRestart("muffleWarning")
[13:23:45.947]                     }
[13:23:45.947]                     else if (inherits(cond, "condition")) {
[13:23:45.947]                       if (!is.null(pattern)) {
[13:23:45.947]                         computeRestarts <- base::computeRestarts
[13:23:45.947]                         grepl <- base::grepl
[13:23:45.947]                         restarts <- computeRestarts(cond)
[13:23:45.947]                         for (restart in restarts) {
[13:23:45.947]                           name <- restart$name
[13:23:45.947]                           if (is.null(name)) 
[13:23:45.947]                             next
[13:23:45.947]                           if (!grepl(pattern, name)) 
[13:23:45.947]                             next
[13:23:45.947]                           invokeRestart(restart)
[13:23:45.947]                           muffled <- TRUE
[13:23:45.947]                           break
[13:23:45.947]                         }
[13:23:45.947]                       }
[13:23:45.947]                     }
[13:23:45.947]                     invisible(muffled)
[13:23:45.947]                   }
[13:23:45.947]                   muffleCondition(cond)
[13:23:45.947]                 })
[13:23:45.947]             }))
[13:23:45.947]             future::FutureResult(value = ...future.value$value, 
[13:23:45.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.947]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.947]                     ...future.globalenv.names))
[13:23:45.947]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.947]         }, condition = base::local({
[13:23:45.947]             c <- base::c
[13:23:45.947]             inherits <- base::inherits
[13:23:45.947]             invokeRestart <- base::invokeRestart
[13:23:45.947]             length <- base::length
[13:23:45.947]             list <- base::list
[13:23:45.947]             seq.int <- base::seq.int
[13:23:45.947]             signalCondition <- base::signalCondition
[13:23:45.947]             sys.calls <- base::sys.calls
[13:23:45.947]             `[[` <- base::`[[`
[13:23:45.947]             `+` <- base::`+`
[13:23:45.947]             `<<-` <- base::`<<-`
[13:23:45.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.947]                   3L)]
[13:23:45.947]             }
[13:23:45.947]             function(cond) {
[13:23:45.947]                 is_error <- inherits(cond, "error")
[13:23:45.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.947]                   NULL)
[13:23:45.947]                 if (is_error) {
[13:23:45.947]                   sessionInformation <- function() {
[13:23:45.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.947]                       search = base::search(), system = base::Sys.info())
[13:23:45.947]                   }
[13:23:45.947]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.947]                     cond$call), session = sessionInformation(), 
[13:23:45.947]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.947]                   signalCondition(cond)
[13:23:45.947]                 }
[13:23:45.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.947]                 "immediateCondition"))) {
[13:23:45.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.947]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.947]                   if (TRUE && !signal) {
[13:23:45.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.947]                     {
[13:23:45.947]                       inherits <- base::inherits
[13:23:45.947]                       invokeRestart <- base::invokeRestart
[13:23:45.947]                       is.null <- base::is.null
[13:23:45.947]                       muffled <- FALSE
[13:23:45.947]                       if (inherits(cond, "message")) {
[13:23:45.947]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.947]                         if (muffled) 
[13:23:45.947]                           invokeRestart("muffleMessage")
[13:23:45.947]                       }
[13:23:45.947]                       else if (inherits(cond, "warning")) {
[13:23:45.947]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.947]                         if (muffled) 
[13:23:45.947]                           invokeRestart("muffleWarning")
[13:23:45.947]                       }
[13:23:45.947]                       else if (inherits(cond, "condition")) {
[13:23:45.947]                         if (!is.null(pattern)) {
[13:23:45.947]                           computeRestarts <- base::computeRestarts
[13:23:45.947]                           grepl <- base::grepl
[13:23:45.947]                           restarts <- computeRestarts(cond)
[13:23:45.947]                           for (restart in restarts) {
[13:23:45.947]                             name <- restart$name
[13:23:45.947]                             if (is.null(name)) 
[13:23:45.947]                               next
[13:23:45.947]                             if (!grepl(pattern, name)) 
[13:23:45.947]                               next
[13:23:45.947]                             invokeRestart(restart)
[13:23:45.947]                             muffled <- TRUE
[13:23:45.947]                             break
[13:23:45.947]                           }
[13:23:45.947]                         }
[13:23:45.947]                       }
[13:23:45.947]                       invisible(muffled)
[13:23:45.947]                     }
[13:23:45.947]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.947]                   }
[13:23:45.947]                 }
[13:23:45.947]                 else {
[13:23:45.947]                   if (TRUE) {
[13:23:45.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.947]                     {
[13:23:45.947]                       inherits <- base::inherits
[13:23:45.947]                       invokeRestart <- base::invokeRestart
[13:23:45.947]                       is.null <- base::is.null
[13:23:45.947]                       muffled <- FALSE
[13:23:45.947]                       if (inherits(cond, "message")) {
[13:23:45.947]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.947]                         if (muffled) 
[13:23:45.947]                           invokeRestart("muffleMessage")
[13:23:45.947]                       }
[13:23:45.947]                       else if (inherits(cond, "warning")) {
[13:23:45.947]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.947]                         if (muffled) 
[13:23:45.947]                           invokeRestart("muffleWarning")
[13:23:45.947]                       }
[13:23:45.947]                       else if (inherits(cond, "condition")) {
[13:23:45.947]                         if (!is.null(pattern)) {
[13:23:45.947]                           computeRestarts <- base::computeRestarts
[13:23:45.947]                           grepl <- base::grepl
[13:23:45.947]                           restarts <- computeRestarts(cond)
[13:23:45.947]                           for (restart in restarts) {
[13:23:45.947]                             name <- restart$name
[13:23:45.947]                             if (is.null(name)) 
[13:23:45.947]                               next
[13:23:45.947]                             if (!grepl(pattern, name)) 
[13:23:45.947]                               next
[13:23:45.947]                             invokeRestart(restart)
[13:23:45.947]                             muffled <- TRUE
[13:23:45.947]                             break
[13:23:45.947]                           }
[13:23:45.947]                         }
[13:23:45.947]                       }
[13:23:45.947]                       invisible(muffled)
[13:23:45.947]                     }
[13:23:45.947]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.947]                   }
[13:23:45.947]                 }
[13:23:45.947]             }
[13:23:45.947]         }))
[13:23:45.947]     }, error = function(ex) {
[13:23:45.947]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.947]                 ...future.rng), started = ...future.startTime, 
[13:23:45.947]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.947]             version = "1.8"), class = "FutureResult")
[13:23:45.947]     }, finally = {
[13:23:45.947]         if (!identical(...future.workdir, getwd())) 
[13:23:45.947]             setwd(...future.workdir)
[13:23:45.947]         {
[13:23:45.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.947]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.947]             }
[13:23:45.947]             base::options(...future.oldOptions)
[13:23:45.947]             if (.Platform$OS.type == "windows") {
[13:23:45.947]                 old_names <- names(...future.oldEnvVars)
[13:23:45.947]                 envs <- base::Sys.getenv()
[13:23:45.947]                 names <- names(envs)
[13:23:45.947]                 common <- intersect(names, old_names)
[13:23:45.947]                 added <- setdiff(names, old_names)
[13:23:45.947]                 removed <- setdiff(old_names, names)
[13:23:45.947]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.947]                   envs[common]]
[13:23:45.947]                 NAMES <- toupper(changed)
[13:23:45.947]                 args <- list()
[13:23:45.947]                 for (kk in seq_along(NAMES)) {
[13:23:45.947]                   name <- changed[[kk]]
[13:23:45.947]                   NAME <- NAMES[[kk]]
[13:23:45.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.947]                     next
[13:23:45.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.947]                 }
[13:23:45.947]                 NAMES <- toupper(added)
[13:23:45.947]                 for (kk in seq_along(NAMES)) {
[13:23:45.947]                   name <- added[[kk]]
[13:23:45.947]                   NAME <- NAMES[[kk]]
[13:23:45.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.947]                     next
[13:23:45.947]                   args[[name]] <- ""
[13:23:45.947]                 }
[13:23:45.947]                 NAMES <- toupper(removed)
[13:23:45.947]                 for (kk in seq_along(NAMES)) {
[13:23:45.947]                   name <- removed[[kk]]
[13:23:45.947]                   NAME <- NAMES[[kk]]
[13:23:45.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.947]                     next
[13:23:45.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.947]                 }
[13:23:45.947]                 if (length(args) > 0) 
[13:23:45.947]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.947]             }
[13:23:45.947]             else {
[13:23:45.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.947]             }
[13:23:45.947]             {
[13:23:45.947]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.947]                   0L) {
[13:23:45.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.947]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.947]                   base::options(opts)
[13:23:45.947]                 }
[13:23:45.947]                 {
[13:23:45.947]                   {
[13:23:45.947]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.947]                     NULL
[13:23:45.947]                   }
[13:23:45.947]                   options(future.plan = NULL)
[13:23:45.947]                   if (is.na(NA_character_)) 
[13:23:45.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.947]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.947]                     envir = parent.frame()) 
[13:23:45.947]                   {
[13:23:45.947]                     default_workers <- missing(workers)
[13:23:45.947]                     if (is.function(workers)) 
[13:23:45.947]                       workers <- workers()
[13:23:45.947]                     workers <- structure(as.integer(workers), 
[13:23:45.947]                       class = class(workers))
[13:23:45.947]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.947]                       1L)
[13:23:45.947]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.947]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.947]                       if (default_workers) 
[13:23:45.947]                         supportsMulticore(warn = TRUE)
[13:23:45.947]                       return(sequential(..., envir = envir))
[13:23:45.947]                     }
[13:23:45.947]                     oopts <- options(mc.cores = workers)
[13:23:45.947]                     on.exit(options(oopts))
[13:23:45.947]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.947]                       envir = envir)
[13:23:45.947]                     if (!future$lazy) 
[13:23:45.947]                       future <- run(future)
[13:23:45.947]                     invisible(future)
[13:23:45.947]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.947]                 }
[13:23:45.947]             }
[13:23:45.947]         }
[13:23:45.947]     })
[13:23:45.947]     if (TRUE) {
[13:23:45.947]         base::sink(type = "output", split = FALSE)
[13:23:45.947]         if (TRUE) {
[13:23:45.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.947]         }
[13:23:45.947]         else {
[13:23:45.947]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.947]         }
[13:23:45.947]         base::close(...future.stdout)
[13:23:45.947]         ...future.stdout <- NULL
[13:23:45.947]     }
[13:23:45.947]     ...future.result$conditions <- ...future.conditions
[13:23:45.947]     ...future.result$finished <- base::Sys.time()
[13:23:45.947]     ...future.result
[13:23:45.947] }
[13:23:45.950] assign_globals() ...
[13:23:45.950] List of 1
[13:23:45.950]  $ ii: int 3
[13:23:45.950]  - attr(*, "where")=List of 1
[13:23:45.950]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.950]  - attr(*, "resolved")= logi FALSE
[13:23:45.950]  - attr(*, "total_size")= num 56
[13:23:45.953] - copied ‘ii’ to environment
[13:23:45.954] assign_globals() ... done
[13:23:45.954] requestCore(): workers = 2
[13:23:45.954] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:45.965] result() for MulticoreFuture ...
[13:23:45.966] result() for MulticoreFuture ...
[13:23:45.966] result() for MulticoreFuture ... done
[13:23:45.966] result() for MulticoreFuture ... done
[13:23:45.966] result() for MulticoreFuture ...
[13:23:45.966] result() for MulticoreFuture ... done
[13:23:45.969] MulticoreFuture started
 - Creating multicore future #4 ...
[13:23:45.970] plan(): Setting new future strategy stack:
[13:23:45.970] List of future strategies:
[13:23:45.970] 1. sequential:
[13:23:45.970]    - args: function (..., envir = parent.frame())
[13:23:45.970]    - tweaked: FALSE
[13:23:45.970]    - call: NULL
[13:23:45.971] plan(): nbrOfWorkers() = 1
[13:23:45.974] plan(): Setting new future strategy stack:
[13:23:45.974] List of future strategies:
[13:23:45.974] 1. multicore:
[13:23:45.974]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:45.974]    - tweaked: FALSE
[13:23:45.974]    - call: plan(multicore)
[13:23:45.976] getGlobalsAndPackages() ...
[13:23:45.976] Searching for globals...
[13:23:45.978] - globals found: [2] ‘{’, ‘ii’
[13:23:45.978] Searching for globals ... DONE
[13:23:45.979] Resolving globals: FALSE
[13:23:45.980] The total size of the 1 globals is 56 bytes (56 bytes)
[13:23:45.980] plan(): nbrOfWorkers() = 2
[13:23:45.980] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[13:23:45.981] - globals: [1] ‘ii’
[13:23:45.981] 
[13:23:45.981] getGlobalsAndPackages() ... DONE
[13:23:45.982] Packages needed by the future expression (n = 0): <none>
[13:23:45.982] Packages needed by future strategies (n = 0): <none>
[13:23:45.983] {
[13:23:45.983]     {
[13:23:45.983]         {
[13:23:45.983]             ...future.startTime <- base::Sys.time()
[13:23:45.983]             {
[13:23:45.983]                 {
[13:23:45.983]                   {
[13:23:45.983]                     {
[13:23:45.983]                       base::local({
[13:23:45.983]                         has_future <- base::requireNamespace("future", 
[13:23:45.983]                           quietly = TRUE)
[13:23:45.983]                         if (has_future) {
[13:23:45.983]                           ns <- base::getNamespace("future")
[13:23:45.983]                           version <- ns[[".package"]][["version"]]
[13:23:45.983]                           if (is.null(version)) 
[13:23:45.983]                             version <- utils::packageVersion("future")
[13:23:45.983]                         }
[13:23:45.983]                         else {
[13:23:45.983]                           version <- NULL
[13:23:45.983]                         }
[13:23:45.983]                         if (!has_future || version < "1.8.0") {
[13:23:45.983]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:45.983]                             "", base::R.version$version.string), 
[13:23:45.983]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:45.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:45.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:45.983]                               "release", "version")], collapse = " "), 
[13:23:45.983]                             hostname = base::Sys.info()[["nodename"]])
[13:23:45.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:45.983]                             info)
[13:23:45.983]                           info <- base::paste(info, collapse = "; ")
[13:23:45.983]                           if (!has_future) {
[13:23:45.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:45.983]                               info)
[13:23:45.983]                           }
[13:23:45.983]                           else {
[13:23:45.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:45.983]                               info, version)
[13:23:45.983]                           }
[13:23:45.983]                           base::stop(msg)
[13:23:45.983]                         }
[13:23:45.983]                       })
[13:23:45.983]                     }
[13:23:45.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:45.983]                     base::options(mc.cores = 1L)
[13:23:45.983]                   }
[13:23:45.983]                   options(future.plan = NULL)
[13:23:45.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:45.983]                 }
[13:23:45.983]                 ...future.workdir <- getwd()
[13:23:45.983]             }
[13:23:45.983]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:45.983]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:45.983]         }
[13:23:45.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:45.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:45.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:45.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:45.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:45.983]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:45.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:45.983]             base::names(...future.oldOptions))
[13:23:45.983]     }
[13:23:45.983]     if (FALSE) {
[13:23:45.983]     }
[13:23:45.983]     else {
[13:23:45.983]         if (TRUE) {
[13:23:45.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:45.983]                 open = "w")
[13:23:45.983]         }
[13:23:45.983]         else {
[13:23:45.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:45.983]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:45.983]         }
[13:23:45.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:45.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:45.983]             base::sink(type = "output", split = FALSE)
[13:23:45.983]             base::close(...future.stdout)
[13:23:45.983]         }, add = TRUE)
[13:23:45.983]     }
[13:23:45.983]     ...future.frame <- base::sys.nframe()
[13:23:45.983]     ...future.conditions <- base::list()
[13:23:45.983]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:45.983]     if (FALSE) {
[13:23:45.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:45.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:45.983]     }
[13:23:45.983]     ...future.result <- base::tryCatch({
[13:23:45.983]         base::withCallingHandlers({
[13:23:45.983]             ...future.value <- base::withVisible(base::local({
[13:23:45.983]                 withCallingHandlers({
[13:23:45.983]                   {
[13:23:45.983]                     ii
[13:23:45.983]                   }
[13:23:45.983]                 }, immediateCondition = function(cond) {
[13:23:45.983]                   save_rds <- function (object, pathname, ...) 
[13:23:45.983]                   {
[13:23:45.983]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:45.983]                     if (file_test("-f", pathname_tmp)) {
[13:23:45.983]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.983]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:45.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.983]                         fi_tmp[["mtime"]])
[13:23:45.983]                     }
[13:23:45.983]                     tryCatch({
[13:23:45.983]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:45.983]                     }, error = function(ex) {
[13:23:45.983]                       msg <- conditionMessage(ex)
[13:23:45.983]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.983]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:45.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.983]                         fi_tmp[["mtime"]], msg)
[13:23:45.983]                       ex$message <- msg
[13:23:45.983]                       stop(ex)
[13:23:45.983]                     })
[13:23:45.983]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:45.983]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:45.983]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:45.983]                       fi_tmp <- file.info(pathname_tmp)
[13:23:45.983]                       fi <- file.info(pathname)
[13:23:45.983]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:45.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:45.983]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:45.983]                         fi[["size"]], fi[["mtime"]])
[13:23:45.983]                       stop(msg)
[13:23:45.983]                     }
[13:23:45.983]                     invisible(pathname)
[13:23:45.983]                   }
[13:23:45.983]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:45.983]                     rootPath = tempdir()) 
[13:23:45.983]                   {
[13:23:45.983]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:45.983]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:45.983]                       tmpdir = path, fileext = ".rds")
[13:23:45.983]                     save_rds(obj, file)
[13:23:45.983]                   }
[13:23:45.983]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:45.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.983]                   {
[13:23:45.983]                     inherits <- base::inherits
[13:23:45.983]                     invokeRestart <- base::invokeRestart
[13:23:45.983]                     is.null <- base::is.null
[13:23:45.983]                     muffled <- FALSE
[13:23:45.983]                     if (inherits(cond, "message")) {
[13:23:45.983]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:45.983]                       if (muffled) 
[13:23:45.983]                         invokeRestart("muffleMessage")
[13:23:45.983]                     }
[13:23:45.983]                     else if (inherits(cond, "warning")) {
[13:23:45.983]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:45.983]                       if (muffled) 
[13:23:45.983]                         invokeRestart("muffleWarning")
[13:23:45.983]                     }
[13:23:45.983]                     else if (inherits(cond, "condition")) {
[13:23:45.983]                       if (!is.null(pattern)) {
[13:23:45.983]                         computeRestarts <- base::computeRestarts
[13:23:45.983]                         grepl <- base::grepl
[13:23:45.983]                         restarts <- computeRestarts(cond)
[13:23:45.983]                         for (restart in restarts) {
[13:23:45.983]                           name <- restart$name
[13:23:45.983]                           if (is.null(name)) 
[13:23:45.983]                             next
[13:23:45.983]                           if (!grepl(pattern, name)) 
[13:23:45.983]                             next
[13:23:45.983]                           invokeRestart(restart)
[13:23:45.983]                           muffled <- TRUE
[13:23:45.983]                           break
[13:23:45.983]                         }
[13:23:45.983]                       }
[13:23:45.983]                     }
[13:23:45.983]                     invisible(muffled)
[13:23:45.983]                   }
[13:23:45.983]                   muffleCondition(cond)
[13:23:45.983]                 })
[13:23:45.983]             }))
[13:23:45.983]             future::FutureResult(value = ...future.value$value, 
[13:23:45.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.983]                   ...future.rng), globalenv = if (FALSE) 
[13:23:45.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:45.983]                     ...future.globalenv.names))
[13:23:45.983]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:45.983]         }, condition = base::local({
[13:23:45.983]             c <- base::c
[13:23:45.983]             inherits <- base::inherits
[13:23:45.983]             invokeRestart <- base::invokeRestart
[13:23:45.983]             length <- base::length
[13:23:45.983]             list <- base::list
[13:23:45.983]             seq.int <- base::seq.int
[13:23:45.983]             signalCondition <- base::signalCondition
[13:23:45.983]             sys.calls <- base::sys.calls
[13:23:45.983]             `[[` <- base::`[[`
[13:23:45.983]             `+` <- base::`+`
[13:23:45.983]             `<<-` <- base::`<<-`
[13:23:45.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:45.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:45.983]                   3L)]
[13:23:45.983]             }
[13:23:45.983]             function(cond) {
[13:23:45.983]                 is_error <- inherits(cond, "error")
[13:23:45.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:45.983]                   NULL)
[13:23:45.983]                 if (is_error) {
[13:23:45.983]                   sessionInformation <- function() {
[13:23:45.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:45.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:45.983]                       search = base::search(), system = base::Sys.info())
[13:23:45.983]                   }
[13:23:45.983]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:45.983]                     cond$call), session = sessionInformation(), 
[13:23:45.983]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:45.983]                   signalCondition(cond)
[13:23:45.983]                 }
[13:23:45.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:45.983]                 "immediateCondition"))) {
[13:23:45.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:45.983]                   ...future.conditions[[length(...future.conditions) + 
[13:23:45.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:45.983]                   if (TRUE && !signal) {
[13:23:45.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.983]                     {
[13:23:45.983]                       inherits <- base::inherits
[13:23:45.983]                       invokeRestart <- base::invokeRestart
[13:23:45.983]                       is.null <- base::is.null
[13:23:45.983]                       muffled <- FALSE
[13:23:45.983]                       if (inherits(cond, "message")) {
[13:23:45.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.983]                         if (muffled) 
[13:23:45.983]                           invokeRestart("muffleMessage")
[13:23:45.983]                       }
[13:23:45.983]                       else if (inherits(cond, "warning")) {
[13:23:45.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.983]                         if (muffled) 
[13:23:45.983]                           invokeRestart("muffleWarning")
[13:23:45.983]                       }
[13:23:45.983]                       else if (inherits(cond, "condition")) {
[13:23:45.983]                         if (!is.null(pattern)) {
[13:23:45.983]                           computeRestarts <- base::computeRestarts
[13:23:45.983]                           grepl <- base::grepl
[13:23:45.983]                           restarts <- computeRestarts(cond)
[13:23:45.983]                           for (restart in restarts) {
[13:23:45.983]                             name <- restart$name
[13:23:45.983]                             if (is.null(name)) 
[13:23:45.983]                               next
[13:23:45.983]                             if (!grepl(pattern, name)) 
[13:23:45.983]                               next
[13:23:45.983]                             invokeRestart(restart)
[13:23:45.983]                             muffled <- TRUE
[13:23:45.983]                             break
[13:23:45.983]                           }
[13:23:45.983]                         }
[13:23:45.983]                       }
[13:23:45.983]                       invisible(muffled)
[13:23:45.983]                     }
[13:23:45.983]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.983]                   }
[13:23:45.983]                 }
[13:23:45.983]                 else {
[13:23:45.983]                   if (TRUE) {
[13:23:45.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:45.983]                     {
[13:23:45.983]                       inherits <- base::inherits
[13:23:45.983]                       invokeRestart <- base::invokeRestart
[13:23:45.983]                       is.null <- base::is.null
[13:23:45.983]                       muffled <- FALSE
[13:23:45.983]                       if (inherits(cond, "message")) {
[13:23:45.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:45.983]                         if (muffled) 
[13:23:45.983]                           invokeRestart("muffleMessage")
[13:23:45.983]                       }
[13:23:45.983]                       else if (inherits(cond, "warning")) {
[13:23:45.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:45.983]                         if (muffled) 
[13:23:45.983]                           invokeRestart("muffleWarning")
[13:23:45.983]                       }
[13:23:45.983]                       else if (inherits(cond, "condition")) {
[13:23:45.983]                         if (!is.null(pattern)) {
[13:23:45.983]                           computeRestarts <- base::computeRestarts
[13:23:45.983]                           grepl <- base::grepl
[13:23:45.983]                           restarts <- computeRestarts(cond)
[13:23:45.983]                           for (restart in restarts) {
[13:23:45.983]                             name <- restart$name
[13:23:45.983]                             if (is.null(name)) 
[13:23:45.983]                               next
[13:23:45.983]                             if (!grepl(pattern, name)) 
[13:23:45.983]                               next
[13:23:45.983]                             invokeRestart(restart)
[13:23:45.983]                             muffled <- TRUE
[13:23:45.983]                             break
[13:23:45.983]                           }
[13:23:45.983]                         }
[13:23:45.983]                       }
[13:23:45.983]                       invisible(muffled)
[13:23:45.983]                     }
[13:23:45.983]                     muffleCondition(cond, pattern = "^muffle")
[13:23:45.983]                   }
[13:23:45.983]                 }
[13:23:45.983]             }
[13:23:45.983]         }))
[13:23:45.983]     }, error = function(ex) {
[13:23:45.983]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:45.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:45.983]                 ...future.rng), started = ...future.startTime, 
[13:23:45.983]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:45.983]             version = "1.8"), class = "FutureResult")
[13:23:45.983]     }, finally = {
[13:23:45.983]         if (!identical(...future.workdir, getwd())) 
[13:23:45.983]             setwd(...future.workdir)
[13:23:45.983]         {
[13:23:45.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:45.983]                 ...future.oldOptions$nwarnings <- NULL
[13:23:45.983]             }
[13:23:45.983]             base::options(...future.oldOptions)
[13:23:45.983]             if (.Platform$OS.type == "windows") {
[13:23:45.983]                 old_names <- names(...future.oldEnvVars)
[13:23:45.983]                 envs <- base::Sys.getenv()
[13:23:45.983]                 names <- names(envs)
[13:23:45.983]                 common <- intersect(names, old_names)
[13:23:45.983]                 added <- setdiff(names, old_names)
[13:23:45.983]                 removed <- setdiff(old_names, names)
[13:23:45.983]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:45.983]                   envs[common]]
[13:23:45.983]                 NAMES <- toupper(changed)
[13:23:45.983]                 args <- list()
[13:23:45.983]                 for (kk in seq_along(NAMES)) {
[13:23:45.983]                   name <- changed[[kk]]
[13:23:45.983]                   NAME <- NAMES[[kk]]
[13:23:45.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.983]                     next
[13:23:45.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.983]                 }
[13:23:45.983]                 NAMES <- toupper(added)
[13:23:45.983]                 for (kk in seq_along(NAMES)) {
[13:23:45.983]                   name <- added[[kk]]
[13:23:45.983]                   NAME <- NAMES[[kk]]
[13:23:45.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.983]                     next
[13:23:45.983]                   args[[name]] <- ""
[13:23:45.983]                 }
[13:23:45.983]                 NAMES <- toupper(removed)
[13:23:45.983]                 for (kk in seq_along(NAMES)) {
[13:23:45.983]                   name <- removed[[kk]]
[13:23:45.983]                   NAME <- NAMES[[kk]]
[13:23:45.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:45.983]                     next
[13:23:45.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:45.983]                 }
[13:23:45.983]                 if (length(args) > 0) 
[13:23:45.983]                   base::do.call(base::Sys.setenv, args = args)
[13:23:45.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:45.983]             }
[13:23:45.983]             else {
[13:23:45.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:45.983]             }
[13:23:45.983]             {
[13:23:45.983]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:45.983]                   0L) {
[13:23:45.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:45.983]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:45.983]                   base::options(opts)
[13:23:45.983]                 }
[13:23:45.983]                 {
[13:23:45.983]                   {
[13:23:45.983]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:45.983]                     NULL
[13:23:45.983]                   }
[13:23:45.983]                   options(future.plan = NULL)
[13:23:45.983]                   if (is.na(NA_character_)) 
[13:23:45.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:45.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:45.983]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:45.983]                     envir = parent.frame()) 
[13:23:45.983]                   {
[13:23:45.983]                     default_workers <- missing(workers)
[13:23:45.983]                     if (is.function(workers)) 
[13:23:45.983]                       workers <- workers()
[13:23:45.983]                     workers <- structure(as.integer(workers), 
[13:23:45.983]                       class = class(workers))
[13:23:45.983]                     stop_if_not(is.finite(workers), workers >= 
[13:23:45.983]                       1L)
[13:23:45.983]                     if ((workers == 1L && !inherits(workers, 
[13:23:45.983]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:45.983]                       if (default_workers) 
[13:23:45.983]                         supportsMulticore(warn = TRUE)
[13:23:45.983]                       return(sequential(..., envir = envir))
[13:23:45.983]                     }
[13:23:45.983]                     oopts <- options(mc.cores = workers)
[13:23:45.983]                     on.exit(options(oopts))
[13:23:45.983]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:45.983]                       envir = envir)
[13:23:45.983]                     if (!future$lazy) 
[13:23:45.983]                       future <- run(future)
[13:23:45.983]                     invisible(future)
[13:23:45.983]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:45.983]                 }
[13:23:45.983]             }
[13:23:45.983]         }
[13:23:45.983]     })
[13:23:45.983]     if (TRUE) {
[13:23:45.983]         base::sink(type = "output", split = FALSE)
[13:23:45.983]         if (TRUE) {
[13:23:45.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:45.983]         }
[13:23:45.983]         else {
[13:23:45.983]             ...future.result["stdout"] <- base::list(NULL)
[13:23:45.983]         }
[13:23:45.983]         base::close(...future.stdout)
[13:23:45.983]         ...future.stdout <- NULL
[13:23:45.983]     }
[13:23:45.983]     ...future.result$conditions <- ...future.conditions
[13:23:45.983]     ...future.result$finished <- base::Sys.time()
[13:23:45.983]     ...future.result
[13:23:45.983] }
[13:23:45.986] assign_globals() ...
[13:23:45.987] List of 1
[13:23:45.987]  $ ii: int 4
[13:23:45.987]  - attr(*, "where")=List of 1
[13:23:45.987]   ..$ ii:<environment: R_EmptyEnv> 
[13:23:45.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:45.987]  - attr(*, "resolved")= logi FALSE
[13:23:45.987]  - attr(*, "total_size")= num 56
[13:23:45.990] - copied ‘ii’ to environment
[13:23:45.990] assign_globals() ... done
[13:23:45.991] requestCore(): workers = 2
[13:23:45.991] Poll #1 (0): usedCores() = 2, workers = 2
[13:23:46.002] result() for MulticoreFuture ...
[13:23:46.003] result() for MulticoreFuture ...
[13:23:46.003] result() for MulticoreFuture ... done
[13:23:46.003] result() for MulticoreFuture ... done
[13:23:46.003] result() for MulticoreFuture ...
[13:23:46.003] result() for MulticoreFuture ... done
[13:23:46.006] MulticoreFuture started
 - Resolving 4 multicore futures
[13:23:46.007] result() for MulticoreFuture ...
[13:23:46.008] result() for MulticoreFuture ... done
[13:23:46.008] plan(): Setting new future strategy stack:
[13:23:46.008] result() for MulticoreFuture ...
[13:23:46.008] result() for MulticoreFuture ... done
[13:23:46.008] result() for MulticoreFuture ...
[13:23:46.008] result() for MulticoreFuture ... done
[13:23:46.008] List of future strategies:
[13:23:46.008] 1. sequential:
[13:23:46.008]    - args: function (..., envir = parent.frame())
[13:23:46.008]    - tweaked: FALSE
[13:23:46.008]    - call: NULL
[13:23:46.008] result() for MulticoreFuture ...
[13:23:46.009] result() for MulticoreFuture ... done
[13:23:46.009] plan(): nbrOfWorkers() = 1
[13:23:46.009] result() for MulticoreFuture ...
[13:23:46.010] result() for MulticoreFuture ...
[13:23:46.010] result() for MulticoreFuture ... done
[13:23:46.010] result() for MulticoreFuture ... done
[13:23:46.011] result() for MulticoreFuture ...
[13:23:46.011] result() for MulticoreFuture ... done
[13:23:46.011] plan(): Setting new future strategy stack:
[13:23:46.011] result() for MulticoreFuture ...
[13:23:46.011] List of future strategies:
[13:23:46.011] 1. multicore:
[13:23:46.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:46.011]    - tweaked: FALSE
[13:23:46.011]    - call: plan(multicore)
[13:23:46.016] plan(): nbrOfWorkers() = 2
[13:23:46.017] result() for MulticoreFuture ...
[13:23:46.017] result() for MulticoreFuture ... done
[13:23:46.017] result() for MulticoreFuture ... done
[13:23:46.017] result() for MulticoreFuture ...
[13:23:46.017] result() for MulticoreFuture ... done
*** multicore(..., globals = TRUE) and errors
[13:23:46.021] getGlobalsAndPackages() ...
[13:23:46.022] Searching for globals...
[13:23:46.023] - globals found: [2] ‘{’, ‘stop’
[13:23:46.023] Searching for globals ... DONE
[13:23:46.023] Resolving globals: FALSE
[13:23:46.027] 
[13:23:46.027] 
[13:23:46.027] getGlobalsAndPackages() ... DONE
[13:23:46.027] Packages needed by the future expression (n = 0): <none>
[13:23:46.028] Packages needed by future strategies (n = 0): <none>
[13:23:46.028] {
[13:23:46.028]     {
[13:23:46.028]         {
[13:23:46.028]             ...future.startTime <- base::Sys.time()
[13:23:46.028]             {
[13:23:46.028]                 {
[13:23:46.028]                   {
[13:23:46.028]                     {
[13:23:46.028]                       base::local({
[13:23:46.028]                         has_future <- base::requireNamespace("future", 
[13:23:46.028]                           quietly = TRUE)
[13:23:46.028]                         if (has_future) {
[13:23:46.028]                           ns <- base::getNamespace("future")
[13:23:46.028]                           version <- ns[[".package"]][["version"]]
[13:23:46.028]                           if (is.null(version)) 
[13:23:46.028]                             version <- utils::packageVersion("future")
[13:23:46.028]                         }
[13:23:46.028]                         else {
[13:23:46.028]                           version <- NULL
[13:23:46.028]                         }
[13:23:46.028]                         if (!has_future || version < "1.8.0") {
[13:23:46.028]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:46.028]                             "", base::R.version$version.string), 
[13:23:46.028]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:46.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:46.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:46.028]                               "release", "version")], collapse = " "), 
[13:23:46.028]                             hostname = base::Sys.info()[["nodename"]])
[13:23:46.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:46.028]                             info)
[13:23:46.028]                           info <- base::paste(info, collapse = "; ")
[13:23:46.028]                           if (!has_future) {
[13:23:46.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:46.028]                               info)
[13:23:46.028]                           }
[13:23:46.028]                           else {
[13:23:46.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:46.028]                               info, version)
[13:23:46.028]                           }
[13:23:46.028]                           base::stop(msg)
[13:23:46.028]                         }
[13:23:46.028]                       })
[13:23:46.028]                     }
[13:23:46.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:46.028]                     base::options(mc.cores = 1L)
[13:23:46.028]                   }
[13:23:46.028]                   options(future.plan = NULL)
[13:23:46.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:46.028]                 }
[13:23:46.028]                 ...future.workdir <- getwd()
[13:23:46.028]             }
[13:23:46.028]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:46.028]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:46.028]         }
[13:23:46.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:46.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:46.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:46.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:46.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:46.028]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:46.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:46.028]             base::names(...future.oldOptions))
[13:23:46.028]     }
[13:23:46.028]     if (FALSE) {
[13:23:46.028]     }
[13:23:46.028]     else {
[13:23:46.028]         if (TRUE) {
[13:23:46.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:46.028]                 open = "w")
[13:23:46.028]         }
[13:23:46.028]         else {
[13:23:46.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:46.028]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:46.028]         }
[13:23:46.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:46.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:46.028]             base::sink(type = "output", split = FALSE)
[13:23:46.028]             base::close(...future.stdout)
[13:23:46.028]         }, add = TRUE)
[13:23:46.028]     }
[13:23:46.028]     ...future.frame <- base::sys.nframe()
[13:23:46.028]     ...future.conditions <- base::list()
[13:23:46.028]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:46.028]     if (FALSE) {
[13:23:46.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:46.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:46.028]     }
[13:23:46.028]     ...future.result <- base::tryCatch({
[13:23:46.028]         base::withCallingHandlers({
[13:23:46.028]             ...future.value <- base::withVisible(base::local({
[13:23:46.028]                 withCallingHandlers({
[13:23:46.028]                   {
[13:23:46.028]                     stop("Whoops!")
[13:23:46.028]                     1
[13:23:46.028]                   }
[13:23:46.028]                 }, immediateCondition = function(cond) {
[13:23:46.028]                   save_rds <- function (object, pathname, ...) 
[13:23:46.028]                   {
[13:23:46.028]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:46.028]                     if (file_test("-f", pathname_tmp)) {
[13:23:46.028]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.028]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:46.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.028]                         fi_tmp[["mtime"]])
[13:23:46.028]                     }
[13:23:46.028]                     tryCatch({
[13:23:46.028]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:46.028]                     }, error = function(ex) {
[13:23:46.028]                       msg <- conditionMessage(ex)
[13:23:46.028]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.028]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:46.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.028]                         fi_tmp[["mtime"]], msg)
[13:23:46.028]                       ex$message <- msg
[13:23:46.028]                       stop(ex)
[13:23:46.028]                     })
[13:23:46.028]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:46.028]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:46.028]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:46.028]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.028]                       fi <- file.info(pathname)
[13:23:46.028]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:46.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.028]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:46.028]                         fi[["size"]], fi[["mtime"]])
[13:23:46.028]                       stop(msg)
[13:23:46.028]                     }
[13:23:46.028]                     invisible(pathname)
[13:23:46.028]                   }
[13:23:46.028]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:46.028]                     rootPath = tempdir()) 
[13:23:46.028]                   {
[13:23:46.028]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:46.028]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:46.028]                       tmpdir = path, fileext = ".rds")
[13:23:46.028]                     save_rds(obj, file)
[13:23:46.028]                   }
[13:23:46.028]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:46.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.028]                   {
[13:23:46.028]                     inherits <- base::inherits
[13:23:46.028]                     invokeRestart <- base::invokeRestart
[13:23:46.028]                     is.null <- base::is.null
[13:23:46.028]                     muffled <- FALSE
[13:23:46.028]                     if (inherits(cond, "message")) {
[13:23:46.028]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:46.028]                       if (muffled) 
[13:23:46.028]                         invokeRestart("muffleMessage")
[13:23:46.028]                     }
[13:23:46.028]                     else if (inherits(cond, "warning")) {
[13:23:46.028]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:46.028]                       if (muffled) 
[13:23:46.028]                         invokeRestart("muffleWarning")
[13:23:46.028]                     }
[13:23:46.028]                     else if (inherits(cond, "condition")) {
[13:23:46.028]                       if (!is.null(pattern)) {
[13:23:46.028]                         computeRestarts <- base::computeRestarts
[13:23:46.028]                         grepl <- base::grepl
[13:23:46.028]                         restarts <- computeRestarts(cond)
[13:23:46.028]                         for (restart in restarts) {
[13:23:46.028]                           name <- restart$name
[13:23:46.028]                           if (is.null(name)) 
[13:23:46.028]                             next
[13:23:46.028]                           if (!grepl(pattern, name)) 
[13:23:46.028]                             next
[13:23:46.028]                           invokeRestart(restart)
[13:23:46.028]                           muffled <- TRUE
[13:23:46.028]                           break
[13:23:46.028]                         }
[13:23:46.028]                       }
[13:23:46.028]                     }
[13:23:46.028]                     invisible(muffled)
[13:23:46.028]                   }
[13:23:46.028]                   muffleCondition(cond)
[13:23:46.028]                 })
[13:23:46.028]             }))
[13:23:46.028]             future::FutureResult(value = ...future.value$value, 
[13:23:46.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.028]                   ...future.rng), globalenv = if (FALSE) 
[13:23:46.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:46.028]                     ...future.globalenv.names))
[13:23:46.028]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:46.028]         }, condition = base::local({
[13:23:46.028]             c <- base::c
[13:23:46.028]             inherits <- base::inherits
[13:23:46.028]             invokeRestart <- base::invokeRestart
[13:23:46.028]             length <- base::length
[13:23:46.028]             list <- base::list
[13:23:46.028]             seq.int <- base::seq.int
[13:23:46.028]             signalCondition <- base::signalCondition
[13:23:46.028]             sys.calls <- base::sys.calls
[13:23:46.028]             `[[` <- base::`[[`
[13:23:46.028]             `+` <- base::`+`
[13:23:46.028]             `<<-` <- base::`<<-`
[13:23:46.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:46.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:46.028]                   3L)]
[13:23:46.028]             }
[13:23:46.028]             function(cond) {
[13:23:46.028]                 is_error <- inherits(cond, "error")
[13:23:46.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:46.028]                   NULL)
[13:23:46.028]                 if (is_error) {
[13:23:46.028]                   sessionInformation <- function() {
[13:23:46.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:46.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:46.028]                       search = base::search(), system = base::Sys.info())
[13:23:46.028]                   }
[13:23:46.028]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:46.028]                     cond$call), session = sessionInformation(), 
[13:23:46.028]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:46.028]                   signalCondition(cond)
[13:23:46.028]                 }
[13:23:46.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:46.028]                 "immediateCondition"))) {
[13:23:46.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:46.028]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:46.028]                   if (TRUE && !signal) {
[13:23:46.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.028]                     {
[13:23:46.028]                       inherits <- base::inherits
[13:23:46.028]                       invokeRestart <- base::invokeRestart
[13:23:46.028]                       is.null <- base::is.null
[13:23:46.028]                       muffled <- FALSE
[13:23:46.028]                       if (inherits(cond, "message")) {
[13:23:46.028]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.028]                         if (muffled) 
[13:23:46.028]                           invokeRestart("muffleMessage")
[13:23:46.028]                       }
[13:23:46.028]                       else if (inherits(cond, "warning")) {
[13:23:46.028]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.028]                         if (muffled) 
[13:23:46.028]                           invokeRestart("muffleWarning")
[13:23:46.028]                       }
[13:23:46.028]                       else if (inherits(cond, "condition")) {
[13:23:46.028]                         if (!is.null(pattern)) {
[13:23:46.028]                           computeRestarts <- base::computeRestarts
[13:23:46.028]                           grepl <- base::grepl
[13:23:46.028]                           restarts <- computeRestarts(cond)
[13:23:46.028]                           for (restart in restarts) {
[13:23:46.028]                             name <- restart$name
[13:23:46.028]                             if (is.null(name)) 
[13:23:46.028]                               next
[13:23:46.028]                             if (!grepl(pattern, name)) 
[13:23:46.028]                               next
[13:23:46.028]                             invokeRestart(restart)
[13:23:46.028]                             muffled <- TRUE
[13:23:46.028]                             break
[13:23:46.028]                           }
[13:23:46.028]                         }
[13:23:46.028]                       }
[13:23:46.028]                       invisible(muffled)
[13:23:46.028]                     }
[13:23:46.028]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.028]                   }
[13:23:46.028]                 }
[13:23:46.028]                 else {
[13:23:46.028]                   if (TRUE) {
[13:23:46.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.028]                     {
[13:23:46.028]                       inherits <- base::inherits
[13:23:46.028]                       invokeRestart <- base::invokeRestart
[13:23:46.028]                       is.null <- base::is.null
[13:23:46.028]                       muffled <- FALSE
[13:23:46.028]                       if (inherits(cond, "message")) {
[13:23:46.028]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.028]                         if (muffled) 
[13:23:46.028]                           invokeRestart("muffleMessage")
[13:23:46.028]                       }
[13:23:46.028]                       else if (inherits(cond, "warning")) {
[13:23:46.028]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.028]                         if (muffled) 
[13:23:46.028]                           invokeRestart("muffleWarning")
[13:23:46.028]                       }
[13:23:46.028]                       else if (inherits(cond, "condition")) {
[13:23:46.028]                         if (!is.null(pattern)) {
[13:23:46.028]                           computeRestarts <- base::computeRestarts
[13:23:46.028]                           grepl <- base::grepl
[13:23:46.028]                           restarts <- computeRestarts(cond)
[13:23:46.028]                           for (restart in restarts) {
[13:23:46.028]                             name <- restart$name
[13:23:46.028]                             if (is.null(name)) 
[13:23:46.028]                               next
[13:23:46.028]                             if (!grepl(pattern, name)) 
[13:23:46.028]                               next
[13:23:46.028]                             invokeRestart(restart)
[13:23:46.028]                             muffled <- TRUE
[13:23:46.028]                             break
[13:23:46.028]                           }
[13:23:46.028]                         }
[13:23:46.028]                       }
[13:23:46.028]                       invisible(muffled)
[13:23:46.028]                     }
[13:23:46.028]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.028]                   }
[13:23:46.028]                 }
[13:23:46.028]             }
[13:23:46.028]         }))
[13:23:46.028]     }, error = function(ex) {
[13:23:46.028]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:46.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.028]                 ...future.rng), started = ...future.startTime, 
[13:23:46.028]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:46.028]             version = "1.8"), class = "FutureResult")
[13:23:46.028]     }, finally = {
[13:23:46.028]         if (!identical(...future.workdir, getwd())) 
[13:23:46.028]             setwd(...future.workdir)
[13:23:46.028]         {
[13:23:46.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:46.028]                 ...future.oldOptions$nwarnings <- NULL
[13:23:46.028]             }
[13:23:46.028]             base::options(...future.oldOptions)
[13:23:46.028]             if (.Platform$OS.type == "windows") {
[13:23:46.028]                 old_names <- names(...future.oldEnvVars)
[13:23:46.028]                 envs <- base::Sys.getenv()
[13:23:46.028]                 names <- names(envs)
[13:23:46.028]                 common <- intersect(names, old_names)
[13:23:46.028]                 added <- setdiff(names, old_names)
[13:23:46.028]                 removed <- setdiff(old_names, names)
[13:23:46.028]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:46.028]                   envs[common]]
[13:23:46.028]                 NAMES <- toupper(changed)
[13:23:46.028]                 args <- list()
[13:23:46.028]                 for (kk in seq_along(NAMES)) {
[13:23:46.028]                   name <- changed[[kk]]
[13:23:46.028]                   NAME <- NAMES[[kk]]
[13:23:46.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.028]                     next
[13:23:46.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.028]                 }
[13:23:46.028]                 NAMES <- toupper(added)
[13:23:46.028]                 for (kk in seq_along(NAMES)) {
[13:23:46.028]                   name <- added[[kk]]
[13:23:46.028]                   NAME <- NAMES[[kk]]
[13:23:46.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.028]                     next
[13:23:46.028]                   args[[name]] <- ""
[13:23:46.028]                 }
[13:23:46.028]                 NAMES <- toupper(removed)
[13:23:46.028]                 for (kk in seq_along(NAMES)) {
[13:23:46.028]                   name <- removed[[kk]]
[13:23:46.028]                   NAME <- NAMES[[kk]]
[13:23:46.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.028]                     next
[13:23:46.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.028]                 }
[13:23:46.028]                 if (length(args) > 0) 
[13:23:46.028]                   base::do.call(base::Sys.setenv, args = args)
[13:23:46.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:46.028]             }
[13:23:46.028]             else {
[13:23:46.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:46.028]             }
[13:23:46.028]             {
[13:23:46.028]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:46.028]                   0L) {
[13:23:46.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:46.028]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:46.028]                   base::options(opts)
[13:23:46.028]                 }
[13:23:46.028]                 {
[13:23:46.028]                   {
[13:23:46.028]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:46.028]                     NULL
[13:23:46.028]                   }
[13:23:46.028]                   options(future.plan = NULL)
[13:23:46.028]                   if (is.na(NA_character_)) 
[13:23:46.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:46.028]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:46.028]                     envir = parent.frame()) 
[13:23:46.028]                   {
[13:23:46.028]                     default_workers <- missing(workers)
[13:23:46.028]                     if (is.function(workers)) 
[13:23:46.028]                       workers <- workers()
[13:23:46.028]                     workers <- structure(as.integer(workers), 
[13:23:46.028]                       class = class(workers))
[13:23:46.028]                     stop_if_not(is.finite(workers), workers >= 
[13:23:46.028]                       1L)
[13:23:46.028]                     if ((workers == 1L && !inherits(workers, 
[13:23:46.028]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:46.028]                       if (default_workers) 
[13:23:46.028]                         supportsMulticore(warn = TRUE)
[13:23:46.028]                       return(sequential(..., envir = envir))
[13:23:46.028]                     }
[13:23:46.028]                     oopts <- options(mc.cores = workers)
[13:23:46.028]                     on.exit(options(oopts))
[13:23:46.028]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:46.028]                       envir = envir)
[13:23:46.028]                     if (!future$lazy) 
[13:23:46.028]                       future <- run(future)
[13:23:46.028]                     invisible(future)
[13:23:46.028]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:46.028]                 }
[13:23:46.028]             }
[13:23:46.028]         }
[13:23:46.028]     })
[13:23:46.028]     if (TRUE) {
[13:23:46.028]         base::sink(type = "output", split = FALSE)
[13:23:46.028]         if (TRUE) {
[13:23:46.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:46.028]         }
[13:23:46.028]         else {
[13:23:46.028]             ...future.result["stdout"] <- base::list(NULL)
[13:23:46.028]         }
[13:23:46.028]         base::close(...future.stdout)
[13:23:46.028]         ...future.stdout <- NULL
[13:23:46.028]     }
[13:23:46.028]     ...future.result$conditions <- ...future.conditions
[13:23:46.028]     ...future.result$finished <- base::Sys.time()
[13:23:46.028]     ...future.result
[13:23:46.028] }
[13:23:46.031] requestCore(): workers = 2
[13:23:46.033] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:46.034] plan(): Setting new future strategy stack:
[13:23:46.034] List of future strategies:
[13:23:46.034] 1. sequential:
[13:23:46.034]    - args: function (..., envir = parent.frame())
[13:23:46.034]    - tweaked: FALSE
[13:23:46.034]    - call: NULL
[13:23:46.035] plan(): nbrOfWorkers() = 1
[13:23:46.037] plan(): Setting new future strategy stack:
[13:23:46.038] List of future strategies:
[13:23:46.038] 1. multicore:
[13:23:46.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:46.038]    - tweaked: FALSE
[13:23:46.038]    - call: plan(multicore)
[13:23:46.043] plan(): nbrOfWorkers() = 2
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:46.045] result() for MulticoreFuture ...
[13:23:46.048] result() for MulticoreFuture ...
[13:23:46.048] result() for MulticoreFuture ... done
[13:23:46.048] signalConditions() ...
[13:23:46.049]  - include = ‘immediateCondition’
[13:23:46.049]  - exclude = 
[13:23:46.049]  - resignal = FALSE
[13:23:46.049]  - Number of conditions: 1
[13:23:46.049] signalConditions() ... done
[13:23:46.049] result() for MulticoreFuture ... done
[13:23:46.049] result() for MulticoreFuture ...
[13:23:46.050] result() for MulticoreFuture ... done
[13:23:46.050] signalConditions() ...
[13:23:46.050]  - include = ‘immediateCondition’
[13:23:46.050]  - exclude = 
[13:23:46.050]  - resignal = FALSE
[13:23:46.050]  - Number of conditions: 1
[13:23:46.050] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:46.051] result() for MulticoreFuture ...
[13:23:46.051] result() for MulticoreFuture ... done
[13:23:46.051] result() for MulticoreFuture ...
[13:23:46.052] result() for MulticoreFuture ... done
[13:23:46.052] signalConditions() ...
[13:23:46.052]  - include = ‘immediateCondition’
[13:23:46.052]  - exclude = 
[13:23:46.052]  - resignal = FALSE
[13:23:46.052]  - Number of conditions: 1
[13:23:46.052] signalConditions() ... done
[13:23:46.052] Future state: ‘finished’
[13:23:46.053] result() for MulticoreFuture ...
[13:23:46.053] result() for MulticoreFuture ... done
[13:23:46.053] signalConditions() ...
[13:23:46.053]  - include = ‘condition’
[13:23:46.053]  - exclude = ‘immediateCondition’
[13:23:46.053]  - resignal = TRUE
[13:23:46.053]  - Number of conditions: 1
[13:23:46.053]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:46.054] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:46.054] result() for MulticoreFuture ...
[13:23:46.055] result() for MulticoreFuture ... done
[13:23:46.055] result() for MulticoreFuture ...
[13:23:46.055] result() for MulticoreFuture ... done
[13:23:46.055] signalConditions() ...
[13:23:46.055]  - include = ‘immediateCondition’
[13:23:46.055]  - exclude = 
[13:23:46.055]  - resignal = FALSE
[13:23:46.055]  - Number of conditions: 1
[13:23:46.056] signalConditions() ... done
[13:23:46.056] Future state: ‘finished’
[13:23:46.056] result() for MulticoreFuture ...
[13:23:46.056] result() for MulticoreFuture ... done
[13:23:46.056] signalConditions() ...
[13:23:46.056]  - include = ‘condition’
[13:23:46.056]  - exclude = ‘immediateCondition’
[13:23:46.056]  - resignal = TRUE
[13:23:46.056]  - Number of conditions: 1
[13:23:46.057]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:23:46.057] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[13:23:46.062] getGlobalsAndPackages() ...
[13:23:46.062] 
[13:23:46.062] - globals: [0] <none>
[13:23:46.062] getGlobalsAndPackages() ... DONE
[13:23:46.063] Packages needed by the future expression (n = 0): <none>
[13:23:46.063] Packages needed by future strategies (n = 0): <none>
[13:23:46.064] {
[13:23:46.064]     {
[13:23:46.064]         {
[13:23:46.064]             ...future.startTime <- base::Sys.time()
[13:23:46.064]             {
[13:23:46.064]                 {
[13:23:46.064]                   {
[13:23:46.064]                     {
[13:23:46.064]                       base::local({
[13:23:46.064]                         has_future <- base::requireNamespace("future", 
[13:23:46.064]                           quietly = TRUE)
[13:23:46.064]                         if (has_future) {
[13:23:46.064]                           ns <- base::getNamespace("future")
[13:23:46.064]                           version <- ns[[".package"]][["version"]]
[13:23:46.064]                           if (is.null(version)) 
[13:23:46.064]                             version <- utils::packageVersion("future")
[13:23:46.064]                         }
[13:23:46.064]                         else {
[13:23:46.064]                           version <- NULL
[13:23:46.064]                         }
[13:23:46.064]                         if (!has_future || version < "1.8.0") {
[13:23:46.064]                           info <- base::c(r_version = base::gsub("R version ", 
[13:23:46.064]                             "", base::R.version$version.string), 
[13:23:46.064]                             platform = base::sprintf("%s (%s-bit)", 
[13:23:46.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:46.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:46.064]                               "release", "version")], collapse = " "), 
[13:23:46.064]                             hostname = base::Sys.info()[["nodename"]])
[13:23:46.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:23:46.064]                             info)
[13:23:46.064]                           info <- base::paste(info, collapse = "; ")
[13:23:46.064]                           if (!has_future) {
[13:23:46.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:46.064]                               info)
[13:23:46.064]                           }
[13:23:46.064]                           else {
[13:23:46.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:46.064]                               info, version)
[13:23:46.064]                           }
[13:23:46.064]                           base::stop(msg)
[13:23:46.064]                         }
[13:23:46.064]                       })
[13:23:46.064]                     }
[13:23:46.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:23:46.064]                     base::options(mc.cores = 1L)
[13:23:46.064]                   }
[13:23:46.064]                   options(future.plan = NULL)
[13:23:46.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:46.064]                 }
[13:23:46.064]                 ...future.workdir <- getwd()
[13:23:46.064]             }
[13:23:46.064]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:46.064]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:46.064]         }
[13:23:46.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:46.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:46.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:46.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:46.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:46.064]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:46.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:46.064]             base::names(...future.oldOptions))
[13:23:46.064]     }
[13:23:46.064]     if (FALSE) {
[13:23:46.064]     }
[13:23:46.064]     else {
[13:23:46.064]         if (TRUE) {
[13:23:46.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:46.064]                 open = "w")
[13:23:46.064]         }
[13:23:46.064]         else {
[13:23:46.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:46.064]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:46.064]         }
[13:23:46.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:46.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:46.064]             base::sink(type = "output", split = FALSE)
[13:23:46.064]             base::close(...future.stdout)
[13:23:46.064]         }, add = TRUE)
[13:23:46.064]     }
[13:23:46.064]     ...future.frame <- base::sys.nframe()
[13:23:46.064]     ...future.conditions <- base::list()
[13:23:46.064]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:46.064]     if (FALSE) {
[13:23:46.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:46.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:46.064]     }
[13:23:46.064]     ...future.result <- base::tryCatch({
[13:23:46.064]         base::withCallingHandlers({
[13:23:46.064]             ...future.value <- base::withVisible(base::local({
[13:23:46.064]                 withCallingHandlers({
[13:23:46.064]                   {
[13:23:46.064]                     stop(structure(list(message = "boom"), class = c("MyError", 
[13:23:46.064]                       "error", "condition")))
[13:23:46.064]                   }
[13:23:46.064]                 }, immediateCondition = function(cond) {
[13:23:46.064]                   save_rds <- function (object, pathname, ...) 
[13:23:46.064]                   {
[13:23:46.064]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:23:46.064]                     if (file_test("-f", pathname_tmp)) {
[13:23:46.064]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.064]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:23:46.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.064]                         fi_tmp[["mtime"]])
[13:23:46.064]                     }
[13:23:46.064]                     tryCatch({
[13:23:46.064]                       saveRDS(object, file = pathname_tmp, ...)
[13:23:46.064]                     }, error = function(ex) {
[13:23:46.064]                       msg <- conditionMessage(ex)
[13:23:46.064]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.064]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:23:46.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.064]                         fi_tmp[["mtime"]], msg)
[13:23:46.064]                       ex$message <- msg
[13:23:46.064]                       stop(ex)
[13:23:46.064]                     })
[13:23:46.064]                     stopifnot(file_test("-f", pathname_tmp))
[13:23:46.064]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:23:46.064]                     if (!res || file_test("-f", pathname_tmp)) {
[13:23:46.064]                       fi_tmp <- file.info(pathname_tmp)
[13:23:46.064]                       fi <- file.info(pathname)
[13:23:46.064]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:23:46.064]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:23:46.064]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:23:46.064]                         fi[["size"]], fi[["mtime"]])
[13:23:46.064]                       stop(msg)
[13:23:46.064]                     }
[13:23:46.064]                     invisible(pathname)
[13:23:46.064]                   }
[13:23:46.064]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:23:46.064]                     rootPath = tempdir()) 
[13:23:46.064]                   {
[13:23:46.064]                     obj <- list(time = Sys.time(), condition = cond)
[13:23:46.064]                     file <- tempfile(pattern = class(cond)[1], 
[13:23:46.064]                       tmpdir = path, fileext = ".rds")
[13:23:46.064]                     save_rds(obj, file)
[13:23:46.064]                   }
[13:23:46.064]                   saveImmediateCondition(cond, path = "/tmp/RtmpN8MuAY/.future/immediateConditions")
[13:23:46.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.064]                   {
[13:23:46.064]                     inherits <- base::inherits
[13:23:46.064]                     invokeRestart <- base::invokeRestart
[13:23:46.064]                     is.null <- base::is.null
[13:23:46.064]                     muffled <- FALSE
[13:23:46.064]                     if (inherits(cond, "message")) {
[13:23:46.064]                       muffled <- grepl(pattern, "muffleMessage")
[13:23:46.064]                       if (muffled) 
[13:23:46.064]                         invokeRestart("muffleMessage")
[13:23:46.064]                     }
[13:23:46.064]                     else if (inherits(cond, "warning")) {
[13:23:46.064]                       muffled <- grepl(pattern, "muffleWarning")
[13:23:46.064]                       if (muffled) 
[13:23:46.064]                         invokeRestart("muffleWarning")
[13:23:46.064]                     }
[13:23:46.064]                     else if (inherits(cond, "condition")) {
[13:23:46.064]                       if (!is.null(pattern)) {
[13:23:46.064]                         computeRestarts <- base::computeRestarts
[13:23:46.064]                         grepl <- base::grepl
[13:23:46.064]                         restarts <- computeRestarts(cond)
[13:23:46.064]                         for (restart in restarts) {
[13:23:46.064]                           name <- restart$name
[13:23:46.064]                           if (is.null(name)) 
[13:23:46.064]                             next
[13:23:46.064]                           if (!grepl(pattern, name)) 
[13:23:46.064]                             next
[13:23:46.064]                           invokeRestart(restart)
[13:23:46.064]                           muffled <- TRUE
[13:23:46.064]                           break
[13:23:46.064]                         }
[13:23:46.064]                       }
[13:23:46.064]                     }
[13:23:46.064]                     invisible(muffled)
[13:23:46.064]                   }
[13:23:46.064]                   muffleCondition(cond)
[13:23:46.064]                 })
[13:23:46.064]             }))
[13:23:46.064]             future::FutureResult(value = ...future.value$value, 
[13:23:46.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.064]                   ...future.rng), globalenv = if (FALSE) 
[13:23:46.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:46.064]                     ...future.globalenv.names))
[13:23:46.064]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:46.064]         }, condition = base::local({
[13:23:46.064]             c <- base::c
[13:23:46.064]             inherits <- base::inherits
[13:23:46.064]             invokeRestart <- base::invokeRestart
[13:23:46.064]             length <- base::length
[13:23:46.064]             list <- base::list
[13:23:46.064]             seq.int <- base::seq.int
[13:23:46.064]             signalCondition <- base::signalCondition
[13:23:46.064]             sys.calls <- base::sys.calls
[13:23:46.064]             `[[` <- base::`[[`
[13:23:46.064]             `+` <- base::`+`
[13:23:46.064]             `<<-` <- base::`<<-`
[13:23:46.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:46.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:46.064]                   3L)]
[13:23:46.064]             }
[13:23:46.064]             function(cond) {
[13:23:46.064]                 is_error <- inherits(cond, "error")
[13:23:46.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:46.064]                   NULL)
[13:23:46.064]                 if (is_error) {
[13:23:46.064]                   sessionInformation <- function() {
[13:23:46.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:46.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:46.064]                       search = base::search(), system = base::Sys.info())
[13:23:46.064]                   }
[13:23:46.064]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:46.064]                     cond$call), session = sessionInformation(), 
[13:23:46.064]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:46.064]                   signalCondition(cond)
[13:23:46.064]                 }
[13:23:46.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:46.064]                 "immediateCondition"))) {
[13:23:46.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:46.064]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:46.064]                   if (TRUE && !signal) {
[13:23:46.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.064]                     {
[13:23:46.064]                       inherits <- base::inherits
[13:23:46.064]                       invokeRestart <- base::invokeRestart
[13:23:46.064]                       is.null <- base::is.null
[13:23:46.064]                       muffled <- FALSE
[13:23:46.064]                       if (inherits(cond, "message")) {
[13:23:46.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.064]                         if (muffled) 
[13:23:46.064]                           invokeRestart("muffleMessage")
[13:23:46.064]                       }
[13:23:46.064]                       else if (inherits(cond, "warning")) {
[13:23:46.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.064]                         if (muffled) 
[13:23:46.064]                           invokeRestart("muffleWarning")
[13:23:46.064]                       }
[13:23:46.064]                       else if (inherits(cond, "condition")) {
[13:23:46.064]                         if (!is.null(pattern)) {
[13:23:46.064]                           computeRestarts <- base::computeRestarts
[13:23:46.064]                           grepl <- base::grepl
[13:23:46.064]                           restarts <- computeRestarts(cond)
[13:23:46.064]                           for (restart in restarts) {
[13:23:46.064]                             name <- restart$name
[13:23:46.064]                             if (is.null(name)) 
[13:23:46.064]                               next
[13:23:46.064]                             if (!grepl(pattern, name)) 
[13:23:46.064]                               next
[13:23:46.064]                             invokeRestart(restart)
[13:23:46.064]                             muffled <- TRUE
[13:23:46.064]                             break
[13:23:46.064]                           }
[13:23:46.064]                         }
[13:23:46.064]                       }
[13:23:46.064]                       invisible(muffled)
[13:23:46.064]                     }
[13:23:46.064]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.064]                   }
[13:23:46.064]                 }
[13:23:46.064]                 else {
[13:23:46.064]                   if (TRUE) {
[13:23:46.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.064]                     {
[13:23:46.064]                       inherits <- base::inherits
[13:23:46.064]                       invokeRestart <- base::invokeRestart
[13:23:46.064]                       is.null <- base::is.null
[13:23:46.064]                       muffled <- FALSE
[13:23:46.064]                       if (inherits(cond, "message")) {
[13:23:46.064]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.064]                         if (muffled) 
[13:23:46.064]                           invokeRestart("muffleMessage")
[13:23:46.064]                       }
[13:23:46.064]                       else if (inherits(cond, "warning")) {
[13:23:46.064]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.064]                         if (muffled) 
[13:23:46.064]                           invokeRestart("muffleWarning")
[13:23:46.064]                       }
[13:23:46.064]                       else if (inherits(cond, "condition")) {
[13:23:46.064]                         if (!is.null(pattern)) {
[13:23:46.064]                           computeRestarts <- base::computeRestarts
[13:23:46.064]                           grepl <- base::grepl
[13:23:46.064]                           restarts <- computeRestarts(cond)
[13:23:46.064]                           for (restart in restarts) {
[13:23:46.064]                             name <- restart$name
[13:23:46.064]                             if (is.null(name)) 
[13:23:46.064]                               next
[13:23:46.064]                             if (!grepl(pattern, name)) 
[13:23:46.064]                               next
[13:23:46.064]                             invokeRestart(restart)
[13:23:46.064]                             muffled <- TRUE
[13:23:46.064]                             break
[13:23:46.064]                           }
[13:23:46.064]                         }
[13:23:46.064]                       }
[13:23:46.064]                       invisible(muffled)
[13:23:46.064]                     }
[13:23:46.064]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.064]                   }
[13:23:46.064]                 }
[13:23:46.064]             }
[13:23:46.064]         }))
[13:23:46.064]     }, error = function(ex) {
[13:23:46.064]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:46.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.064]                 ...future.rng), started = ...future.startTime, 
[13:23:46.064]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:46.064]             version = "1.8"), class = "FutureResult")
[13:23:46.064]     }, finally = {
[13:23:46.064]         if (!identical(...future.workdir, getwd())) 
[13:23:46.064]             setwd(...future.workdir)
[13:23:46.064]         {
[13:23:46.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:46.064]                 ...future.oldOptions$nwarnings <- NULL
[13:23:46.064]             }
[13:23:46.064]             base::options(...future.oldOptions)
[13:23:46.064]             if (.Platform$OS.type == "windows") {
[13:23:46.064]                 old_names <- names(...future.oldEnvVars)
[13:23:46.064]                 envs <- base::Sys.getenv()
[13:23:46.064]                 names <- names(envs)
[13:23:46.064]                 common <- intersect(names, old_names)
[13:23:46.064]                 added <- setdiff(names, old_names)
[13:23:46.064]                 removed <- setdiff(old_names, names)
[13:23:46.064]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:46.064]                   envs[common]]
[13:23:46.064]                 NAMES <- toupper(changed)
[13:23:46.064]                 args <- list()
[13:23:46.064]                 for (kk in seq_along(NAMES)) {
[13:23:46.064]                   name <- changed[[kk]]
[13:23:46.064]                   NAME <- NAMES[[kk]]
[13:23:46.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.064]                     next
[13:23:46.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.064]                 }
[13:23:46.064]                 NAMES <- toupper(added)
[13:23:46.064]                 for (kk in seq_along(NAMES)) {
[13:23:46.064]                   name <- added[[kk]]
[13:23:46.064]                   NAME <- NAMES[[kk]]
[13:23:46.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.064]                     next
[13:23:46.064]                   args[[name]] <- ""
[13:23:46.064]                 }
[13:23:46.064]                 NAMES <- toupper(removed)
[13:23:46.064]                 for (kk in seq_along(NAMES)) {
[13:23:46.064]                   name <- removed[[kk]]
[13:23:46.064]                   NAME <- NAMES[[kk]]
[13:23:46.064]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.064]                     next
[13:23:46.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.064]                 }
[13:23:46.064]                 if (length(args) > 0) 
[13:23:46.064]                   base::do.call(base::Sys.setenv, args = args)
[13:23:46.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:46.064]             }
[13:23:46.064]             else {
[13:23:46.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:46.064]             }
[13:23:46.064]             {
[13:23:46.064]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:46.064]                   0L) {
[13:23:46.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:46.064]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:46.064]                   base::options(opts)
[13:23:46.064]                 }
[13:23:46.064]                 {
[13:23:46.064]                   {
[13:23:46.064]                     base::options(mc.cores = ...future.mc.cores.old)
[13:23:46.064]                     NULL
[13:23:46.064]                   }
[13:23:46.064]                   options(future.plan = NULL)
[13:23:46.064]                   if (is.na(NA_character_)) 
[13:23:46.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:46.064]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:46.064]                     envir = parent.frame()) 
[13:23:46.064]                   {
[13:23:46.064]                     default_workers <- missing(workers)
[13:23:46.064]                     if (is.function(workers)) 
[13:23:46.064]                       workers <- workers()
[13:23:46.064]                     workers <- structure(as.integer(workers), 
[13:23:46.064]                       class = class(workers))
[13:23:46.064]                     stop_if_not(is.finite(workers), workers >= 
[13:23:46.064]                       1L)
[13:23:46.064]                     if ((workers == 1L && !inherits(workers, 
[13:23:46.064]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:46.064]                       if (default_workers) 
[13:23:46.064]                         supportsMulticore(warn = TRUE)
[13:23:46.064]                       return(sequential(..., envir = envir))
[13:23:46.064]                     }
[13:23:46.064]                     oopts <- options(mc.cores = workers)
[13:23:46.064]                     on.exit(options(oopts))
[13:23:46.064]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:46.064]                       envir = envir)
[13:23:46.064]                     if (!future$lazy) 
[13:23:46.064]                       future <- run(future)
[13:23:46.064]                     invisible(future)
[13:23:46.064]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:46.064]                 }
[13:23:46.064]             }
[13:23:46.064]         }
[13:23:46.064]     })
[13:23:46.064]     if (TRUE) {
[13:23:46.064]         base::sink(type = "output", split = FALSE)
[13:23:46.064]         if (TRUE) {
[13:23:46.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:46.064]         }
[13:23:46.064]         else {
[13:23:46.064]             ...future.result["stdout"] <- base::list(NULL)
[13:23:46.064]         }
[13:23:46.064]         base::close(...future.stdout)
[13:23:46.064]         ...future.stdout <- NULL
[13:23:46.064]     }
[13:23:46.064]     ...future.result$conditions <- ...future.conditions
[13:23:46.064]     ...future.result$finished <- base::Sys.time()
[13:23:46.064]     ...future.result
[13:23:46.064] }
[13:23:46.067] requestCore(): workers = 2
[13:23:46.069] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:23:46.070] plan(): Setting new future strategy stack:
[13:23:46.070] List of future strategies:
[13:23:46.070] 1. sequential:
[13:23:46.070]    - args: function (..., envir = parent.frame())
[13:23:46.070]    - tweaked: FALSE
[13:23:46.070]    - call: NULL
[13:23:46.071] plan(): nbrOfWorkers() = 1
[13:23:46.073] plan(): Setting new future strategy stack:
[13:23:46.073] List of future strategies:
[13:23:46.073] 1. multicore:
[13:23:46.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:46.073]    - tweaked: FALSE
[13:23:46.073]    - call: plan(multicore)
[13:23:46.078] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d6ec03eb-09d0-151b-2ff0-2b1ad0deafa9
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:23:46.081] result() for MulticoreFuture ...
[13:23:46.083] result() for MulticoreFuture ...
[13:23:46.083] result() for MulticoreFuture ... done
[13:23:46.083] signalConditions() ...
[13:23:46.083]  - include = ‘immediateCondition’
[13:23:46.084]  - exclude = 
[13:23:46.084]  - resignal = FALSE
[13:23:46.084]  - Number of conditions: 1
[13:23:46.084] signalConditions() ... done
[13:23:46.084] result() for MulticoreFuture ... done
[13:23:46.084] result() for MulticoreFuture ...
[13:23:46.085] result() for MulticoreFuture ... done
[13:23:46.085] signalConditions() ...
[13:23:46.085]  - include = ‘immediateCondition’
[13:23:46.085]  - exclude = 
[13:23:46.085]  - resignal = FALSE
[13:23:46.085]  - Number of conditions: 1
[13:23:46.086] signalConditions() ... done
<MyError: boom>
[13:23:46.086] result() for MulticoreFuture ...
[13:23:46.086] result() for MulticoreFuture ... done
[13:23:46.086] result() for MulticoreFuture ...
[13:23:46.086] result() for MulticoreFuture ... done
[13:23:46.086] signalConditions() ...
[13:23:46.087]  - include = ‘immediateCondition’
[13:23:46.087]  - exclude = 
[13:23:46.087]  - resignal = FALSE
[13:23:46.087]  - Number of conditions: 1
[13:23:46.087] signalConditions() ... done
[13:23:46.087] Future state: ‘finished’
[13:23:46.087] result() for MulticoreFuture ...
[13:23:46.087] result() for MulticoreFuture ... done
[13:23:46.087] signalConditions() ...
[13:23:46.088]  - include = ‘condition’
[13:23:46.088]  - exclude = ‘immediateCondition’
[13:23:46.088]  - resignal = TRUE
[13:23:46.088]  - Number of conditions: 1
[13:23:46.088]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[13:23:46.088] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[13:23:46.089] getGlobalsAndPackages() ...
[13:23:46.089] Searching for globals...
[13:23:46.090] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[13:23:46.090] Searching for globals ... DONE
[13:23:46.090] Resolving globals: FALSE
[13:23:46.091] The total size of the 2 globals is 112 bytes (112 bytes)
[13:23:46.095] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘b’ (56 bytes of class ‘numeric’)
[13:23:46.095] - globals: [2] ‘a’, ‘b’
[13:23:46.095] 
[13:23:46.095] getGlobalsAndPackages() ... DONE
[13:23:46.096] Packages needed by the future expression (n = 0): <none>
[13:23:46.096] Packages needed by future strategies (n = 0): <none>
[13:23:46.097] {
[13:23:46.097]     {
[13:23:46.097]         {
[13:23:46.097]             ...future.startTime <- base::Sys.time()
[13:23:46.097]             {
[13:23:46.097]                 {
[13:23:46.097]                   {
[13:23:46.097]                     base::local({
[13:23:46.097]                       has_future <- base::requireNamespace("future", 
[13:23:46.097]                         quietly = TRUE)
[13:23:46.097]                       if (has_future) {
[13:23:46.097]                         ns <- base::getNamespace("future")
[13:23:46.097]                         version <- ns[[".package"]][["version"]]
[13:23:46.097]                         if (is.null(version)) 
[13:23:46.097]                           version <- utils::packageVersion("future")
[13:23:46.097]                       }
[13:23:46.097]                       else {
[13:23:46.097]                         version <- NULL
[13:23:46.097]                       }
[13:23:46.097]                       if (!has_future || version < "1.8.0") {
[13:23:46.097]                         info <- base::c(r_version = base::gsub("R version ", 
[13:23:46.097]                           "", base::R.version$version.string), 
[13:23:46.097]                           platform = base::sprintf("%s (%s-bit)", 
[13:23:46.097]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:23:46.097]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:23:46.097]                             "release", "version")], collapse = " "), 
[13:23:46.097]                           hostname = base::Sys.info()[["nodename"]])
[13:23:46.097]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:23:46.097]                           info)
[13:23:46.097]                         info <- base::paste(info, collapse = "; ")
[13:23:46.097]                         if (!has_future) {
[13:23:46.097]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:23:46.097]                             info)
[13:23:46.097]                         }
[13:23:46.097]                         else {
[13:23:46.097]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:23:46.097]                             info, version)
[13:23:46.097]                         }
[13:23:46.097]                         base::stop(msg)
[13:23:46.097]                       }
[13:23:46.097]                     })
[13:23:46.097]                   }
[13:23:46.097]                   options(future.plan = NULL)
[13:23:46.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:23:46.097]                 }
[13:23:46.097]                 ...future.workdir <- getwd()
[13:23:46.097]             }
[13:23:46.097]             ...future.oldOptions <- base::as.list(base::.Options)
[13:23:46.097]             ...future.oldEnvVars <- base::Sys.getenv()
[13:23:46.097]         }
[13:23:46.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:23:46.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:23:46.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:23:46.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:23:46.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:23:46.097]             future.stdout.windows.reencode = NULL, width = 80L)
[13:23:46.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:23:46.097]             base::names(...future.oldOptions))
[13:23:46.097]     }
[13:23:46.097]     if (FALSE) {
[13:23:46.097]     }
[13:23:46.097]     else {
[13:23:46.097]         if (TRUE) {
[13:23:46.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:23:46.097]                 open = "w")
[13:23:46.097]         }
[13:23:46.097]         else {
[13:23:46.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:23:46.097]                 windows = "NUL", "/dev/null"), open = "w")
[13:23:46.097]         }
[13:23:46.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:23:46.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:23:46.097]             base::sink(type = "output", split = FALSE)
[13:23:46.097]             base::close(...future.stdout)
[13:23:46.097]         }, add = TRUE)
[13:23:46.097]     }
[13:23:46.097]     ...future.frame <- base::sys.nframe()
[13:23:46.097]     ...future.conditions <- base::list()
[13:23:46.097]     ...future.rng <- base::globalenv()$.Random.seed
[13:23:46.097]     if (FALSE) {
[13:23:46.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:23:46.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:23:46.097]     }
[13:23:46.097]     ...future.result <- base::tryCatch({
[13:23:46.097]         base::withCallingHandlers({
[13:23:46.097]             ...future.value <- base::withVisible(base::local({
[13:23:46.097]                 a * b
[13:23:46.097]             }))
[13:23:46.097]             future::FutureResult(value = ...future.value$value, 
[13:23:46.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.097]                   ...future.rng), globalenv = if (FALSE) 
[13:23:46.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:23:46.097]                     ...future.globalenv.names))
[13:23:46.097]                 else NULL, started = ...future.startTime, version = "1.8")
[13:23:46.097]         }, condition = base::local({
[13:23:46.097]             c <- base::c
[13:23:46.097]             inherits <- base::inherits
[13:23:46.097]             invokeRestart <- base::invokeRestart
[13:23:46.097]             length <- base::length
[13:23:46.097]             list <- base::list
[13:23:46.097]             seq.int <- base::seq.int
[13:23:46.097]             signalCondition <- base::signalCondition
[13:23:46.097]             sys.calls <- base::sys.calls
[13:23:46.097]             `[[` <- base::`[[`
[13:23:46.097]             `+` <- base::`+`
[13:23:46.097]             `<<-` <- base::`<<-`
[13:23:46.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:23:46.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:23:46.097]                   3L)]
[13:23:46.097]             }
[13:23:46.097]             function(cond) {
[13:23:46.097]                 is_error <- inherits(cond, "error")
[13:23:46.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:23:46.097]                   NULL)
[13:23:46.097]                 if (is_error) {
[13:23:46.097]                   sessionInformation <- function() {
[13:23:46.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:23:46.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:23:46.097]                       search = base::search(), system = base::Sys.info())
[13:23:46.097]                   }
[13:23:46.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:23:46.097]                     cond$call), session = sessionInformation(), 
[13:23:46.097]                     timestamp = base::Sys.time(), signaled = 0L)
[13:23:46.097]                   signalCondition(cond)
[13:23:46.097]                 }
[13:23:46.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:23:46.097]                 "immediateCondition"))) {
[13:23:46.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:23:46.097]                   ...future.conditions[[length(...future.conditions) + 
[13:23:46.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:23:46.097]                   if (TRUE && !signal) {
[13:23:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.097]                     {
[13:23:46.097]                       inherits <- base::inherits
[13:23:46.097]                       invokeRestart <- base::invokeRestart
[13:23:46.097]                       is.null <- base::is.null
[13:23:46.097]                       muffled <- FALSE
[13:23:46.097]                       if (inherits(cond, "message")) {
[13:23:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.097]                         if (muffled) 
[13:23:46.097]                           invokeRestart("muffleMessage")
[13:23:46.097]                       }
[13:23:46.097]                       else if (inherits(cond, "warning")) {
[13:23:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.097]                         if (muffled) 
[13:23:46.097]                           invokeRestart("muffleWarning")
[13:23:46.097]                       }
[13:23:46.097]                       else if (inherits(cond, "condition")) {
[13:23:46.097]                         if (!is.null(pattern)) {
[13:23:46.097]                           computeRestarts <- base::computeRestarts
[13:23:46.097]                           grepl <- base::grepl
[13:23:46.097]                           restarts <- computeRestarts(cond)
[13:23:46.097]                           for (restart in restarts) {
[13:23:46.097]                             name <- restart$name
[13:23:46.097]                             if (is.null(name)) 
[13:23:46.097]                               next
[13:23:46.097]                             if (!grepl(pattern, name)) 
[13:23:46.097]                               next
[13:23:46.097]                             invokeRestart(restart)
[13:23:46.097]                             muffled <- TRUE
[13:23:46.097]                             break
[13:23:46.097]                           }
[13:23:46.097]                         }
[13:23:46.097]                       }
[13:23:46.097]                       invisible(muffled)
[13:23:46.097]                     }
[13:23:46.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.097]                   }
[13:23:46.097]                 }
[13:23:46.097]                 else {
[13:23:46.097]                   if (TRUE) {
[13:23:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:23:46.097]                     {
[13:23:46.097]                       inherits <- base::inherits
[13:23:46.097]                       invokeRestart <- base::invokeRestart
[13:23:46.097]                       is.null <- base::is.null
[13:23:46.097]                       muffled <- FALSE
[13:23:46.097]                       if (inherits(cond, "message")) {
[13:23:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:23:46.097]                         if (muffled) 
[13:23:46.097]                           invokeRestart("muffleMessage")
[13:23:46.097]                       }
[13:23:46.097]                       else if (inherits(cond, "warning")) {
[13:23:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:23:46.097]                         if (muffled) 
[13:23:46.097]                           invokeRestart("muffleWarning")
[13:23:46.097]                       }
[13:23:46.097]                       else if (inherits(cond, "condition")) {
[13:23:46.097]                         if (!is.null(pattern)) {
[13:23:46.097]                           computeRestarts <- base::computeRestarts
[13:23:46.097]                           grepl <- base::grepl
[13:23:46.097]                           restarts <- computeRestarts(cond)
[13:23:46.097]                           for (restart in restarts) {
[13:23:46.097]                             name <- restart$name
[13:23:46.097]                             if (is.null(name)) 
[13:23:46.097]                               next
[13:23:46.097]                             if (!grepl(pattern, name)) 
[13:23:46.097]                               next
[13:23:46.097]                             invokeRestart(restart)
[13:23:46.097]                             muffled <- TRUE
[13:23:46.097]                             break
[13:23:46.097]                           }
[13:23:46.097]                         }
[13:23:46.097]                       }
[13:23:46.097]                       invisible(muffled)
[13:23:46.097]                     }
[13:23:46.097]                     muffleCondition(cond, pattern = "^muffle")
[13:23:46.097]                   }
[13:23:46.097]                 }
[13:23:46.097]             }
[13:23:46.097]         }))
[13:23:46.097]     }, error = function(ex) {
[13:23:46.097]         base::structure(base::list(value = NULL, visible = NULL, 
[13:23:46.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:23:46.097]                 ...future.rng), started = ...future.startTime, 
[13:23:46.097]             finished = Sys.time(), session_uuid = NA_character_, 
[13:23:46.097]             version = "1.8"), class = "FutureResult")
[13:23:46.097]     }, finally = {
[13:23:46.097]         if (!identical(...future.workdir, getwd())) 
[13:23:46.097]             setwd(...future.workdir)
[13:23:46.097]         {
[13:23:46.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:23:46.097]                 ...future.oldOptions$nwarnings <- NULL
[13:23:46.097]             }
[13:23:46.097]             base::options(...future.oldOptions)
[13:23:46.097]             if (.Platform$OS.type == "windows") {
[13:23:46.097]                 old_names <- names(...future.oldEnvVars)
[13:23:46.097]                 envs <- base::Sys.getenv()
[13:23:46.097]                 names <- names(envs)
[13:23:46.097]                 common <- intersect(names, old_names)
[13:23:46.097]                 added <- setdiff(names, old_names)
[13:23:46.097]                 removed <- setdiff(old_names, names)
[13:23:46.097]                 changed <- common[...future.oldEnvVars[common] != 
[13:23:46.097]                   envs[common]]
[13:23:46.097]                 NAMES <- toupper(changed)
[13:23:46.097]                 args <- list()
[13:23:46.097]                 for (kk in seq_along(NAMES)) {
[13:23:46.097]                   name <- changed[[kk]]
[13:23:46.097]                   NAME <- NAMES[[kk]]
[13:23:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.097]                     next
[13:23:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.097]                 }
[13:23:46.097]                 NAMES <- toupper(added)
[13:23:46.097]                 for (kk in seq_along(NAMES)) {
[13:23:46.097]                   name <- added[[kk]]
[13:23:46.097]                   NAME <- NAMES[[kk]]
[13:23:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.097]                     next
[13:23:46.097]                   args[[name]] <- ""
[13:23:46.097]                 }
[13:23:46.097]                 NAMES <- toupper(removed)
[13:23:46.097]                 for (kk in seq_along(NAMES)) {
[13:23:46.097]                   name <- removed[[kk]]
[13:23:46.097]                   NAME <- NAMES[[kk]]
[13:23:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:23:46.097]                     next
[13:23:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:23:46.097]                 }
[13:23:46.097]                 if (length(args) > 0) 
[13:23:46.097]                   base::do.call(base::Sys.setenv, args = args)
[13:23:46.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:23:46.097]             }
[13:23:46.097]             else {
[13:23:46.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:23:46.097]             }
[13:23:46.097]             {
[13:23:46.097]                 if (base::length(...future.futureOptionsAdded) > 
[13:23:46.097]                   0L) {
[13:23:46.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:23:46.097]                   base::names(opts) <- ...future.futureOptionsAdded
[13:23:46.097]                   base::options(opts)
[13:23:46.097]                 }
[13:23:46.097]                 {
[13:23:46.097]                   {
[13:23:46.097]                     NULL
[13:23:46.097]                     RNGkind("Mersenne-Twister")
[13:23:46.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:23:46.097]                       inherits = FALSE)
[13:23:46.097]                   }
[13:23:46.097]                   options(future.plan = NULL)
[13:23:46.097]                   if (is.na(NA_character_)) 
[13:23:46.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:23:46.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:23:46.097]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:23:46.097]                     envir = parent.frame()) 
[13:23:46.097]                   {
[13:23:46.097]                     default_workers <- missing(workers)
[13:23:46.097]                     if (is.function(workers)) 
[13:23:46.097]                       workers <- workers()
[13:23:46.097]                     workers <- structure(as.integer(workers), 
[13:23:46.097]                       class = class(workers))
[13:23:46.097]                     stop_if_not(is.finite(workers), workers >= 
[13:23:46.097]                       1L)
[13:23:46.097]                     if ((workers == 1L && !inherits(workers, 
[13:23:46.097]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:23:46.097]                       if (default_workers) 
[13:23:46.097]                         supportsMulticore(warn = TRUE)
[13:23:46.097]                       return(sequential(..., envir = envir))
[13:23:46.097]                     }
[13:23:46.097]                     oopts <- options(mc.cores = workers)
[13:23:46.097]                     on.exit(options(oopts))
[13:23:46.097]                     future <- MulticoreFuture(..., workers = workers, 
[13:23:46.097]                       envir = envir)
[13:23:46.097]                     if (!future$lazy) 
[13:23:46.097]                       future <- run(future)
[13:23:46.097]                     invisible(future)
[13:23:46.097]                   }), .cleanup = FALSE, .init = FALSE)
[13:23:46.097]                 }
[13:23:46.097]             }
[13:23:46.097]         }
[13:23:46.097]     })
[13:23:46.097]     if (TRUE) {
[13:23:46.097]         base::sink(type = "output", split = FALSE)
[13:23:46.097]         if (TRUE) {
[13:23:46.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:23:46.097]         }
[13:23:46.097]         else {
[13:23:46.097]             ...future.result["stdout"] <- base::list(NULL)
[13:23:46.097]         }
[13:23:46.097]         base::close(...future.stdout)
[13:23:46.097]         ...future.stdout <- NULL
[13:23:46.097]     }
[13:23:46.097]     ...future.result$conditions <- ...future.conditions
[13:23:46.097]     ...future.result$finished <- base::Sys.time()
[13:23:46.097]     ...future.result
[13:23:46.097] }
[13:23:46.099] assign_globals() ...
[13:23:46.099] List of 2
[13:23:46.099]  $ a: num 2
[13:23:46.099]  $ b: num 3
[13:23:46.099]  - attr(*, "where")=List of 2
[13:23:46.099]   ..$ a:<environment: R_EmptyEnv> 
[13:23:46.099]   ..$ b:<environment: R_EmptyEnv> 
[13:23:46.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:23:46.099]  - attr(*, "resolved")= logi FALSE
[13:23:46.099]  - attr(*, "total_size")= num 112
[13:23:46.103] - copied ‘a’ to environment
[13:23:46.103] - copied ‘b’ to environment
[13:23:46.103] assign_globals() ... done
[13:23:46.103] plan(): Setting new future strategy stack:
[13:23:46.103] List of future strategies:
[13:23:46.103] 1. sequential:
[13:23:46.103]    - args: function (..., envir = parent.frame())
[13:23:46.103]    - tweaked: FALSE
[13:23:46.103]    - call: NULL
[13:23:46.104] plan(): nbrOfWorkers() = 1
[13:23:46.104] plan(): Setting new future strategy stack:
[13:23:46.105] List of future strategies:
[13:23:46.105] 1. multicore:
[13:23:46.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:23:46.105]    - tweaked: FALSE
[13:23:46.105]    - call: plan(multicore)
[13:23:46.109] plan(): nbrOfWorkers() = 2
[13:23:46.109] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[13:23:46.110] plan(): Setting new future strategy stack:
[13:23:46.111] List of future strategies:
[13:23:46.111] 1. FutureStrategy:
[13:23:46.111]    - args: function (..., envir = parent.frame())
[13:23:46.111]    - tweaked: FALSE
[13:23:46.111]    - call: future::plan(oplan)
[13:23:46.111] plan(): nbrOfWorkers() = 1
> 
