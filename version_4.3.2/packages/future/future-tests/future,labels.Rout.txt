
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:27.739] plan(): Setting new future strategy stack:
[16:04:27.739] List of future strategies:
[16:04:27.739] 1. sequential:
[16:04:27.739]    - args: function (..., envir = parent.frame())
[16:04:27.739]    - tweaked: FALSE
[16:04:27.739]    - call: future::plan("sequential")
[16:04:27.752] plan(): nbrOfWorkers() = 1
> 
> message("*** Futures - labels ...")
*** Futures - labels ...
> 
> strategies <- supportedStrategies()
> 
> ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
> if (!fullTest && isWin32) strategies <- NULL
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   for (label in list(NULL, sprintf("strategy = %s", strategy))) {
+     fcn <- get(strategy, mode = "function")
+     stopifnot(inherits(fcn, strategy))
+     f <- fcn(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+     
+     f <- future(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+ 
+     v %<-% { 42 } %label% label
+     f <- futureOf(v)
+     print(f)
+     stopifnot(identical(f$label, label))
+     stopifnot(v == 42)
+ 
+   } ## for (label ...)
+ 
+   message(sprintf("- plan('%s') ... DONE", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[16:04:27.775] plan(): Setting new future strategy stack:
[16:04:27.775] List of future strategies:
[16:04:27.775] 1. sequential:
[16:04:27.775]    - args: function (..., envir = parent.frame())
[16:04:27.775]    - tweaked: FALSE
[16:04:27.775]    - call: plan(strategy)
[16:04:27.788] plan(): nbrOfWorkers() = 1
[16:04:27.789] getGlobalsAndPackages() ...
[16:04:27.789] Searching for globals...
[16:04:27.793] 
[16:04:27.793] Searching for globals ... DONE
[16:04:27.793] - globals: [0] <none>
[16:04:27.793] getGlobalsAndPackages() ... DONE
[16:04:27.794] Packages needed by the future expression (n = 0): <none>
[16:04:27.794] Packages needed by future strategies (n = 0): <none>
[16:04:27.795] {
[16:04:27.795]     {
[16:04:27.795]         {
[16:04:27.795]             ...future.startTime <- base::Sys.time()
[16:04:27.795]             {
[16:04:27.795]                 {
[16:04:27.795]                   {
[16:04:27.795]                     base::local({
[16:04:27.795]                       has_future <- base::requireNamespace("future", 
[16:04:27.795]                         quietly = TRUE)
[16:04:27.795]                       if (has_future) {
[16:04:27.795]                         ns <- base::getNamespace("future")
[16:04:27.795]                         version <- ns[[".package"]][["version"]]
[16:04:27.795]                         if (is.null(version)) 
[16:04:27.795]                           version <- utils::packageVersion("future")
[16:04:27.795]                       }
[16:04:27.795]                       else {
[16:04:27.795]                         version <- NULL
[16:04:27.795]                       }
[16:04:27.795]                       if (!has_future || version < "1.8.0") {
[16:04:27.795]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.795]                           "", base::R.version$version.string), 
[16:04:27.795]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.795]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.795]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.795]                             "release", "version")], collapse = " "), 
[16:04:27.795]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.795]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.795]                           info)
[16:04:27.795]                         info <- base::paste(info, collapse = "; ")
[16:04:27.795]                         if (!has_future) {
[16:04:27.795]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.795]                             info)
[16:04:27.795]                         }
[16:04:27.795]                         else {
[16:04:27.795]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.795]                             info, version)
[16:04:27.795]                         }
[16:04:27.795]                         base::stop(msg)
[16:04:27.795]                       }
[16:04:27.795]                     })
[16:04:27.795]                   }
[16:04:27.795]                   options(future.plan = NULL)
[16:04:27.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.795]                 }
[16:04:27.795]                 ...future.workdir <- getwd()
[16:04:27.795]             }
[16:04:27.795]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.795]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.795]         }
[16:04:27.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.795]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.795]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.795]             base::names(...future.oldOptions))
[16:04:27.795]     }
[16:04:27.795]     if (FALSE) {
[16:04:27.795]     }
[16:04:27.795]     else {
[16:04:27.795]         if (TRUE) {
[16:04:27.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.795]                 open = "w")
[16:04:27.795]         }
[16:04:27.795]         else {
[16:04:27.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.795]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.795]         }
[16:04:27.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.795]             base::sink(type = "output", split = FALSE)
[16:04:27.795]             base::close(...future.stdout)
[16:04:27.795]         }, add = TRUE)
[16:04:27.795]     }
[16:04:27.795]     ...future.frame <- base::sys.nframe()
[16:04:27.795]     ...future.conditions <- base::list()
[16:04:27.795]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.795]     if (FALSE) {
[16:04:27.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.795]     }
[16:04:27.795]     ...future.result <- base::tryCatch({
[16:04:27.795]         base::withCallingHandlers({
[16:04:27.795]             ...future.value <- base::withVisible(base::local(42))
[16:04:27.795]             future::FutureResult(value = ...future.value$value, 
[16:04:27.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.795]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.795]                     ...future.globalenv.names))
[16:04:27.795]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.795]         }, condition = base::local({
[16:04:27.795]             c <- base::c
[16:04:27.795]             inherits <- base::inherits
[16:04:27.795]             invokeRestart <- base::invokeRestart
[16:04:27.795]             length <- base::length
[16:04:27.795]             list <- base::list
[16:04:27.795]             seq.int <- base::seq.int
[16:04:27.795]             signalCondition <- base::signalCondition
[16:04:27.795]             sys.calls <- base::sys.calls
[16:04:27.795]             `[[` <- base::`[[`
[16:04:27.795]             `+` <- base::`+`
[16:04:27.795]             `<<-` <- base::`<<-`
[16:04:27.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.795]                   3L)]
[16:04:27.795]             }
[16:04:27.795]             function(cond) {
[16:04:27.795]                 is_error <- inherits(cond, "error")
[16:04:27.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.795]                   NULL)
[16:04:27.795]                 if (is_error) {
[16:04:27.795]                   sessionInformation <- function() {
[16:04:27.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.795]                       search = base::search(), system = base::Sys.info())
[16:04:27.795]                   }
[16:04:27.795]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.795]                     cond$call), session = sessionInformation(), 
[16:04:27.795]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.795]                   signalCondition(cond)
[16:04:27.795]                 }
[16:04:27.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.795]                 "immediateCondition"))) {
[16:04:27.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.795]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.795]                   if (TRUE && !signal) {
[16:04:27.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.795]                     {
[16:04:27.795]                       inherits <- base::inherits
[16:04:27.795]                       invokeRestart <- base::invokeRestart
[16:04:27.795]                       is.null <- base::is.null
[16:04:27.795]                       muffled <- FALSE
[16:04:27.795]                       if (inherits(cond, "message")) {
[16:04:27.795]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.795]                         if (muffled) 
[16:04:27.795]                           invokeRestart("muffleMessage")
[16:04:27.795]                       }
[16:04:27.795]                       else if (inherits(cond, "warning")) {
[16:04:27.795]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.795]                         if (muffled) 
[16:04:27.795]                           invokeRestart("muffleWarning")
[16:04:27.795]                       }
[16:04:27.795]                       else if (inherits(cond, "condition")) {
[16:04:27.795]                         if (!is.null(pattern)) {
[16:04:27.795]                           computeRestarts <- base::computeRestarts
[16:04:27.795]                           grepl <- base::grepl
[16:04:27.795]                           restarts <- computeRestarts(cond)
[16:04:27.795]                           for (restart in restarts) {
[16:04:27.795]                             name <- restart$name
[16:04:27.795]                             if (is.null(name)) 
[16:04:27.795]                               next
[16:04:27.795]                             if (!grepl(pattern, name)) 
[16:04:27.795]                               next
[16:04:27.795]                             invokeRestart(restart)
[16:04:27.795]                             muffled <- TRUE
[16:04:27.795]                             break
[16:04:27.795]                           }
[16:04:27.795]                         }
[16:04:27.795]                       }
[16:04:27.795]                       invisible(muffled)
[16:04:27.795]                     }
[16:04:27.795]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.795]                   }
[16:04:27.795]                 }
[16:04:27.795]                 else {
[16:04:27.795]                   if (TRUE) {
[16:04:27.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.795]                     {
[16:04:27.795]                       inherits <- base::inherits
[16:04:27.795]                       invokeRestart <- base::invokeRestart
[16:04:27.795]                       is.null <- base::is.null
[16:04:27.795]                       muffled <- FALSE
[16:04:27.795]                       if (inherits(cond, "message")) {
[16:04:27.795]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.795]                         if (muffled) 
[16:04:27.795]                           invokeRestart("muffleMessage")
[16:04:27.795]                       }
[16:04:27.795]                       else if (inherits(cond, "warning")) {
[16:04:27.795]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.795]                         if (muffled) 
[16:04:27.795]                           invokeRestart("muffleWarning")
[16:04:27.795]                       }
[16:04:27.795]                       else if (inherits(cond, "condition")) {
[16:04:27.795]                         if (!is.null(pattern)) {
[16:04:27.795]                           computeRestarts <- base::computeRestarts
[16:04:27.795]                           grepl <- base::grepl
[16:04:27.795]                           restarts <- computeRestarts(cond)
[16:04:27.795]                           for (restart in restarts) {
[16:04:27.795]                             name <- restart$name
[16:04:27.795]                             if (is.null(name)) 
[16:04:27.795]                               next
[16:04:27.795]                             if (!grepl(pattern, name)) 
[16:04:27.795]                               next
[16:04:27.795]                             invokeRestart(restart)
[16:04:27.795]                             muffled <- TRUE
[16:04:27.795]                             break
[16:04:27.795]                           }
[16:04:27.795]                         }
[16:04:27.795]                       }
[16:04:27.795]                       invisible(muffled)
[16:04:27.795]                     }
[16:04:27.795]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.795]                   }
[16:04:27.795]                 }
[16:04:27.795]             }
[16:04:27.795]         }))
[16:04:27.795]     }, error = function(ex) {
[16:04:27.795]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.795]                 ...future.rng), started = ...future.startTime, 
[16:04:27.795]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.795]             version = "1.8"), class = "FutureResult")
[16:04:27.795]     }, finally = {
[16:04:27.795]         if (!identical(...future.workdir, getwd())) 
[16:04:27.795]             setwd(...future.workdir)
[16:04:27.795]         {
[16:04:27.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.795]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.795]             }
[16:04:27.795]             base::options(...future.oldOptions)
[16:04:27.795]             if (.Platform$OS.type == "windows") {
[16:04:27.795]                 old_names <- names(...future.oldEnvVars)
[16:04:27.795]                 envs <- base::Sys.getenv()
[16:04:27.795]                 names <- names(envs)
[16:04:27.795]                 common <- intersect(names, old_names)
[16:04:27.795]                 added <- setdiff(names, old_names)
[16:04:27.795]                 removed <- setdiff(old_names, names)
[16:04:27.795]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.795]                   envs[common]]
[16:04:27.795]                 NAMES <- toupper(changed)
[16:04:27.795]                 args <- list()
[16:04:27.795]                 for (kk in seq_along(NAMES)) {
[16:04:27.795]                   name <- changed[[kk]]
[16:04:27.795]                   NAME <- NAMES[[kk]]
[16:04:27.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.795]                     next
[16:04:27.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.795]                 }
[16:04:27.795]                 NAMES <- toupper(added)
[16:04:27.795]                 for (kk in seq_along(NAMES)) {
[16:04:27.795]                   name <- added[[kk]]
[16:04:27.795]                   NAME <- NAMES[[kk]]
[16:04:27.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.795]                     next
[16:04:27.795]                   args[[name]] <- ""
[16:04:27.795]                 }
[16:04:27.795]                 NAMES <- toupper(removed)
[16:04:27.795]                 for (kk in seq_along(NAMES)) {
[16:04:27.795]                   name <- removed[[kk]]
[16:04:27.795]                   NAME <- NAMES[[kk]]
[16:04:27.795]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.795]                     next
[16:04:27.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.795]                 }
[16:04:27.795]                 if (length(args) > 0) 
[16:04:27.795]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.795]             }
[16:04:27.795]             else {
[16:04:27.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.795]             }
[16:04:27.795]             {
[16:04:27.795]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.795]                   0L) {
[16:04:27.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.795]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.795]                   base::options(opts)
[16:04:27.795]                 }
[16:04:27.795]                 {
[16:04:27.795]                   {
[16:04:27.795]                     NULL
[16:04:27.795]                     RNGkind("Mersenne-Twister")
[16:04:27.795]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.795]                       inherits = FALSE)
[16:04:27.795]                   }
[16:04:27.795]                   options(future.plan = NULL)
[16:04:27.795]                   if (is.na(NA_character_)) 
[16:04:27.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.795]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.795]                   {
[16:04:27.795]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.795]                     if (!future$lazy) 
[16:04:27.795]                       future <- run(future)
[16:04:27.795]                     invisible(future)
[16:04:27.795]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.795]                 }
[16:04:27.795]             }
[16:04:27.795]         }
[16:04:27.795]     })
[16:04:27.795]     if (TRUE) {
[16:04:27.795]         base::sink(type = "output", split = FALSE)
[16:04:27.795]         if (TRUE) {
[16:04:27.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.795]         }
[16:04:27.795]         else {
[16:04:27.795]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.795]         }
[16:04:27.795]         base::close(...future.stdout)
[16:04:27.795]         ...future.stdout <- NULL
[16:04:27.795]     }
[16:04:27.795]     ...future.result$conditions <- ...future.conditions
[16:04:27.795]     ...future.result$finished <- base::Sys.time()
[16:04:27.795]     ...future.result
[16:04:27.795] }
[16:04:27.797] plan(): Setting new future strategy stack:
[16:04:27.797] List of future strategies:
[16:04:27.797] 1. sequential:
[16:04:27.797]    - args: function (..., envir = parent.frame())
[16:04:27.797]    - tweaked: FALSE
[16:04:27.797]    - call: NULL
[16:04:27.797] plan(): nbrOfWorkers() = 1
[16:04:27.798] plan(): Setting new future strategy stack:
[16:04:27.798] List of future strategies:
[16:04:27.798] 1. sequential:
[16:04:27.798]    - args: function (..., envir = parent.frame())
[16:04:27.798]    - tweaked: FALSE
[16:04:27.798]    - call: plan(strategy)
[16:04:27.799] plan(): nbrOfWorkers() = 1
[16:04:27.799] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.801] getGlobalsAndPackages() ...
[16:04:27.801] Searching for globals...
[16:04:27.801] 
[16:04:27.801] Searching for globals ... DONE
[16:04:27.801] - globals: [0] <none>
[16:04:27.801] getGlobalsAndPackages() ... DONE
[16:04:27.802] run() for ‘Future’ ...
[16:04:27.802] - state: ‘created’
[16:04:27.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:27.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:27.802]   - Field: ‘label’
[16:04:27.802]   - Field: ‘local’
[16:04:27.803]   - Field: ‘owner’
[16:04:27.803]   - Field: ‘envir’
[16:04:27.803]   - Field: ‘packages’
[16:04:27.803]   - Field: ‘gc’
[16:04:27.803]   - Field: ‘conditions’
[16:04:27.803]   - Field: ‘expr’
[16:04:27.803]   - Field: ‘uuid’
[16:04:27.803]   - Field: ‘seed’
[16:04:27.803]   - Field: ‘version’
[16:04:27.803]   - Field: ‘result’
[16:04:27.804]   - Field: ‘asynchronous’
[16:04:27.804]   - Field: ‘calls’
[16:04:27.804]   - Field: ‘globals’
[16:04:27.804]   - Field: ‘stdout’
[16:04:27.804]   - Field: ‘earlySignal’
[16:04:27.804]   - Field: ‘lazy’
[16:04:27.804]   - Field: ‘state’
[16:04:27.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:27.804] - Launch lazy future ...
[16:04:27.804] Packages needed by the future expression (n = 0): <none>
[16:04:27.805] Packages needed by future strategies (n = 0): <none>
[16:04:27.805] {
[16:04:27.805]     {
[16:04:27.805]         {
[16:04:27.805]             ...future.startTime <- base::Sys.time()
[16:04:27.805]             {
[16:04:27.805]                 {
[16:04:27.805]                   {
[16:04:27.805]                     base::local({
[16:04:27.805]                       has_future <- base::requireNamespace("future", 
[16:04:27.805]                         quietly = TRUE)
[16:04:27.805]                       if (has_future) {
[16:04:27.805]                         ns <- base::getNamespace("future")
[16:04:27.805]                         version <- ns[[".package"]][["version"]]
[16:04:27.805]                         if (is.null(version)) 
[16:04:27.805]                           version <- utils::packageVersion("future")
[16:04:27.805]                       }
[16:04:27.805]                       else {
[16:04:27.805]                         version <- NULL
[16:04:27.805]                       }
[16:04:27.805]                       if (!has_future || version < "1.8.0") {
[16:04:27.805]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.805]                           "", base::R.version$version.string), 
[16:04:27.805]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.805]                             "release", "version")], collapse = " "), 
[16:04:27.805]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.805]                           info)
[16:04:27.805]                         info <- base::paste(info, collapse = "; ")
[16:04:27.805]                         if (!has_future) {
[16:04:27.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.805]                             info)
[16:04:27.805]                         }
[16:04:27.805]                         else {
[16:04:27.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.805]                             info, version)
[16:04:27.805]                         }
[16:04:27.805]                         base::stop(msg)
[16:04:27.805]                       }
[16:04:27.805]                     })
[16:04:27.805]                   }
[16:04:27.805]                   options(future.plan = NULL)
[16:04:27.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.805]                 }
[16:04:27.805]                 ...future.workdir <- getwd()
[16:04:27.805]             }
[16:04:27.805]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.805]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.805]         }
[16:04:27.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.805]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.805]             base::names(...future.oldOptions))
[16:04:27.805]     }
[16:04:27.805]     if (FALSE) {
[16:04:27.805]     }
[16:04:27.805]     else {
[16:04:27.805]         if (TRUE) {
[16:04:27.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.805]                 open = "w")
[16:04:27.805]         }
[16:04:27.805]         else {
[16:04:27.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.805]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.805]         }
[16:04:27.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.805]             base::sink(type = "output", split = FALSE)
[16:04:27.805]             base::close(...future.stdout)
[16:04:27.805]         }, add = TRUE)
[16:04:27.805]     }
[16:04:27.805]     ...future.frame <- base::sys.nframe()
[16:04:27.805]     ...future.conditions <- base::list()
[16:04:27.805]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.805]     if (FALSE) {
[16:04:27.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.805]     }
[16:04:27.805]     ...future.result <- base::tryCatch({
[16:04:27.805]         base::withCallingHandlers({
[16:04:27.805]             ...future.value <- base::withVisible(base::local(42))
[16:04:27.805]             future::FutureResult(value = ...future.value$value, 
[16:04:27.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.805]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.805]                     ...future.globalenv.names))
[16:04:27.805]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.805]         }, condition = base::local({
[16:04:27.805]             c <- base::c
[16:04:27.805]             inherits <- base::inherits
[16:04:27.805]             invokeRestart <- base::invokeRestart
[16:04:27.805]             length <- base::length
[16:04:27.805]             list <- base::list
[16:04:27.805]             seq.int <- base::seq.int
[16:04:27.805]             signalCondition <- base::signalCondition
[16:04:27.805]             sys.calls <- base::sys.calls
[16:04:27.805]             `[[` <- base::`[[`
[16:04:27.805]             `+` <- base::`+`
[16:04:27.805]             `<<-` <- base::`<<-`
[16:04:27.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.805]                   3L)]
[16:04:27.805]             }
[16:04:27.805]             function(cond) {
[16:04:27.805]                 is_error <- inherits(cond, "error")
[16:04:27.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.805]                   NULL)
[16:04:27.805]                 if (is_error) {
[16:04:27.805]                   sessionInformation <- function() {
[16:04:27.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.805]                       search = base::search(), system = base::Sys.info())
[16:04:27.805]                   }
[16:04:27.805]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.805]                     cond$call), session = sessionInformation(), 
[16:04:27.805]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.805]                   signalCondition(cond)
[16:04:27.805]                 }
[16:04:27.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.805]                 "immediateCondition"))) {
[16:04:27.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.805]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.805]                   if (TRUE && !signal) {
[16:04:27.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.805]                     {
[16:04:27.805]                       inherits <- base::inherits
[16:04:27.805]                       invokeRestart <- base::invokeRestart
[16:04:27.805]                       is.null <- base::is.null
[16:04:27.805]                       muffled <- FALSE
[16:04:27.805]                       if (inherits(cond, "message")) {
[16:04:27.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.805]                         if (muffled) 
[16:04:27.805]                           invokeRestart("muffleMessage")
[16:04:27.805]                       }
[16:04:27.805]                       else if (inherits(cond, "warning")) {
[16:04:27.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.805]                         if (muffled) 
[16:04:27.805]                           invokeRestart("muffleWarning")
[16:04:27.805]                       }
[16:04:27.805]                       else if (inherits(cond, "condition")) {
[16:04:27.805]                         if (!is.null(pattern)) {
[16:04:27.805]                           computeRestarts <- base::computeRestarts
[16:04:27.805]                           grepl <- base::grepl
[16:04:27.805]                           restarts <- computeRestarts(cond)
[16:04:27.805]                           for (restart in restarts) {
[16:04:27.805]                             name <- restart$name
[16:04:27.805]                             if (is.null(name)) 
[16:04:27.805]                               next
[16:04:27.805]                             if (!grepl(pattern, name)) 
[16:04:27.805]                               next
[16:04:27.805]                             invokeRestart(restart)
[16:04:27.805]                             muffled <- TRUE
[16:04:27.805]                             break
[16:04:27.805]                           }
[16:04:27.805]                         }
[16:04:27.805]                       }
[16:04:27.805]                       invisible(muffled)
[16:04:27.805]                     }
[16:04:27.805]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.805]                   }
[16:04:27.805]                 }
[16:04:27.805]                 else {
[16:04:27.805]                   if (TRUE) {
[16:04:27.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.805]                     {
[16:04:27.805]                       inherits <- base::inherits
[16:04:27.805]                       invokeRestart <- base::invokeRestart
[16:04:27.805]                       is.null <- base::is.null
[16:04:27.805]                       muffled <- FALSE
[16:04:27.805]                       if (inherits(cond, "message")) {
[16:04:27.805]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.805]                         if (muffled) 
[16:04:27.805]                           invokeRestart("muffleMessage")
[16:04:27.805]                       }
[16:04:27.805]                       else if (inherits(cond, "warning")) {
[16:04:27.805]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.805]                         if (muffled) 
[16:04:27.805]                           invokeRestart("muffleWarning")
[16:04:27.805]                       }
[16:04:27.805]                       else if (inherits(cond, "condition")) {
[16:04:27.805]                         if (!is.null(pattern)) {
[16:04:27.805]                           computeRestarts <- base::computeRestarts
[16:04:27.805]                           grepl <- base::grepl
[16:04:27.805]                           restarts <- computeRestarts(cond)
[16:04:27.805]                           for (restart in restarts) {
[16:04:27.805]                             name <- restart$name
[16:04:27.805]                             if (is.null(name)) 
[16:04:27.805]                               next
[16:04:27.805]                             if (!grepl(pattern, name)) 
[16:04:27.805]                               next
[16:04:27.805]                             invokeRestart(restart)
[16:04:27.805]                             muffled <- TRUE
[16:04:27.805]                             break
[16:04:27.805]                           }
[16:04:27.805]                         }
[16:04:27.805]                       }
[16:04:27.805]                       invisible(muffled)
[16:04:27.805]                     }
[16:04:27.805]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.805]                   }
[16:04:27.805]                 }
[16:04:27.805]             }
[16:04:27.805]         }))
[16:04:27.805]     }, error = function(ex) {
[16:04:27.805]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.805]                 ...future.rng), started = ...future.startTime, 
[16:04:27.805]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.805]             version = "1.8"), class = "FutureResult")
[16:04:27.805]     }, finally = {
[16:04:27.805]         if (!identical(...future.workdir, getwd())) 
[16:04:27.805]             setwd(...future.workdir)
[16:04:27.805]         {
[16:04:27.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.805]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.805]             }
[16:04:27.805]             base::options(...future.oldOptions)
[16:04:27.805]             if (.Platform$OS.type == "windows") {
[16:04:27.805]                 old_names <- names(...future.oldEnvVars)
[16:04:27.805]                 envs <- base::Sys.getenv()
[16:04:27.805]                 names <- names(envs)
[16:04:27.805]                 common <- intersect(names, old_names)
[16:04:27.805]                 added <- setdiff(names, old_names)
[16:04:27.805]                 removed <- setdiff(old_names, names)
[16:04:27.805]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.805]                   envs[common]]
[16:04:27.805]                 NAMES <- toupper(changed)
[16:04:27.805]                 args <- list()
[16:04:27.805]                 for (kk in seq_along(NAMES)) {
[16:04:27.805]                   name <- changed[[kk]]
[16:04:27.805]                   NAME <- NAMES[[kk]]
[16:04:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.805]                     next
[16:04:27.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.805]                 }
[16:04:27.805]                 NAMES <- toupper(added)
[16:04:27.805]                 for (kk in seq_along(NAMES)) {
[16:04:27.805]                   name <- added[[kk]]
[16:04:27.805]                   NAME <- NAMES[[kk]]
[16:04:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.805]                     next
[16:04:27.805]                   args[[name]] <- ""
[16:04:27.805]                 }
[16:04:27.805]                 NAMES <- toupper(removed)
[16:04:27.805]                 for (kk in seq_along(NAMES)) {
[16:04:27.805]                   name <- removed[[kk]]
[16:04:27.805]                   NAME <- NAMES[[kk]]
[16:04:27.805]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.805]                     next
[16:04:27.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.805]                 }
[16:04:27.805]                 if (length(args) > 0) 
[16:04:27.805]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.805]             }
[16:04:27.805]             else {
[16:04:27.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.805]             }
[16:04:27.805]             {
[16:04:27.805]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.805]                   0L) {
[16:04:27.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.805]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.805]                   base::options(opts)
[16:04:27.805]                 }
[16:04:27.805]                 {
[16:04:27.805]                   {
[16:04:27.805]                     NULL
[16:04:27.805]                     RNGkind("Mersenne-Twister")
[16:04:27.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.805]                       inherits = FALSE)
[16:04:27.805]                   }
[16:04:27.805]                   options(future.plan = NULL)
[16:04:27.805]                   if (is.na(NA_character_)) 
[16:04:27.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.805]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.805]                   {
[16:04:27.805]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.805]                     if (!future$lazy) 
[16:04:27.805]                       future <- run(future)
[16:04:27.805]                     invisible(future)
[16:04:27.805]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.805]                 }
[16:04:27.805]             }
[16:04:27.805]         }
[16:04:27.805]     })
[16:04:27.805]     if (TRUE) {
[16:04:27.805]         base::sink(type = "output", split = FALSE)
[16:04:27.805]         if (TRUE) {
[16:04:27.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.805]         }
[16:04:27.805]         else {
[16:04:27.805]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.805]         }
[16:04:27.805]         base::close(...future.stdout)
[16:04:27.805]         ...future.stdout <- NULL
[16:04:27.805]     }
[16:04:27.805]     ...future.result$conditions <- ...future.conditions
[16:04:27.805]     ...future.result$finished <- base::Sys.time()
[16:04:27.805]     ...future.result
[16:04:27.805] }
[16:04:27.807] plan(): Setting new future strategy stack:
[16:04:27.807] List of future strategies:
[16:04:27.807] 1. sequential:
[16:04:27.807]    - args: function (..., envir = parent.frame())
[16:04:27.807]    - tweaked: FALSE
[16:04:27.807]    - call: NULL
[16:04:27.807] plan(): nbrOfWorkers() = 1
[16:04:27.808] plan(): Setting new future strategy stack:
[16:04:27.808] List of future strategies:
[16:04:27.808] 1. sequential:
[16:04:27.808]    - args: function (..., envir = parent.frame())
[16:04:27.808]    - tweaked: FALSE
[16:04:27.808]    - call: plan(strategy)
[16:04:27.808] plan(): nbrOfWorkers() = 1
[16:04:27.808] SequentialFuture started (and completed)
[16:04:27.808] - Launch lazy future ... done
[16:04:27.808] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.810] getGlobalsAndPackages() ...
[16:04:27.810] Searching for globals...
[16:04:27.811] - globals found: [1] ‘{’
[16:04:27.811] Searching for globals ... DONE
[16:04:27.812] Resolving globals: FALSE
[16:04:27.812] 
[16:04:27.812] 
[16:04:27.812] getGlobalsAndPackages() ... DONE
[16:04:27.812] run() for ‘Future’ ...
[16:04:27.812] - state: ‘created’
[16:04:27.813] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:27.813] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:27.813]   - Field: ‘label’
[16:04:27.813]   - Field: ‘local’
[16:04:27.813]   - Field: ‘owner’
[16:04:27.813]   - Field: ‘envir’
[16:04:27.813]   - Field: ‘packages’
[16:04:27.814]   - Field: ‘gc’
[16:04:27.814]   - Field: ‘conditions’
[16:04:27.814]   - Field: ‘expr’
[16:04:27.814]   - Field: ‘uuid’
[16:04:27.814]   - Field: ‘seed’
[16:04:27.814]   - Field: ‘version’
[16:04:27.814]   - Field: ‘result’
[16:04:27.814]   - Field: ‘asynchronous’
[16:04:27.814]   - Field: ‘calls’
[16:04:27.814]   - Field: ‘globals’
[16:04:27.814]   - Field: ‘stdout’
[16:04:27.815]   - Field: ‘earlySignal’
[16:04:27.815]   - Field: ‘lazy’
[16:04:27.815]   - Field: ‘state’
[16:04:27.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:27.815] - Launch lazy future ...
[16:04:27.815] Packages needed by the future expression (n = 0): <none>
[16:04:27.815] Packages needed by future strategies (n = 0): <none>
[16:04:27.816] {
[16:04:27.816]     {
[16:04:27.816]         {
[16:04:27.816]             ...future.startTime <- base::Sys.time()
[16:04:27.816]             {
[16:04:27.816]                 {
[16:04:27.816]                   {
[16:04:27.816]                     base::local({
[16:04:27.816]                       has_future <- base::requireNamespace("future", 
[16:04:27.816]                         quietly = TRUE)
[16:04:27.816]                       if (has_future) {
[16:04:27.816]                         ns <- base::getNamespace("future")
[16:04:27.816]                         version <- ns[[".package"]][["version"]]
[16:04:27.816]                         if (is.null(version)) 
[16:04:27.816]                           version <- utils::packageVersion("future")
[16:04:27.816]                       }
[16:04:27.816]                       else {
[16:04:27.816]                         version <- NULL
[16:04:27.816]                       }
[16:04:27.816]                       if (!has_future || version < "1.8.0") {
[16:04:27.816]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.816]                           "", base::R.version$version.string), 
[16:04:27.816]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.816]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.816]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.816]                             "release", "version")], collapse = " "), 
[16:04:27.816]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.816]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.816]                           info)
[16:04:27.816]                         info <- base::paste(info, collapse = "; ")
[16:04:27.816]                         if (!has_future) {
[16:04:27.816]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.816]                             info)
[16:04:27.816]                         }
[16:04:27.816]                         else {
[16:04:27.816]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.816]                             info, version)
[16:04:27.816]                         }
[16:04:27.816]                         base::stop(msg)
[16:04:27.816]                       }
[16:04:27.816]                     })
[16:04:27.816]                   }
[16:04:27.816]                   options(future.plan = NULL)
[16:04:27.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.816]                 }
[16:04:27.816]                 ...future.workdir <- getwd()
[16:04:27.816]             }
[16:04:27.816]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.816]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.816]         }
[16:04:27.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.816]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.816]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.816]             base::names(...future.oldOptions))
[16:04:27.816]     }
[16:04:27.816]     if (FALSE) {
[16:04:27.816]     }
[16:04:27.816]     else {
[16:04:27.816]         if (TRUE) {
[16:04:27.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.816]                 open = "w")
[16:04:27.816]         }
[16:04:27.816]         else {
[16:04:27.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.816]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.816]         }
[16:04:27.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.816]             base::sink(type = "output", split = FALSE)
[16:04:27.816]             base::close(...future.stdout)
[16:04:27.816]         }, add = TRUE)
[16:04:27.816]     }
[16:04:27.816]     ...future.frame <- base::sys.nframe()
[16:04:27.816]     ...future.conditions <- base::list()
[16:04:27.816]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.816]     if (FALSE) {
[16:04:27.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.816]     }
[16:04:27.816]     ...future.result <- base::tryCatch({
[16:04:27.816]         base::withCallingHandlers({
[16:04:27.816]             ...future.value <- base::withVisible(base::local({
[16:04:27.816]                 42
[16:04:27.816]             }))
[16:04:27.816]             future::FutureResult(value = ...future.value$value, 
[16:04:27.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.816]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.816]                     ...future.globalenv.names))
[16:04:27.816]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.816]         }, condition = base::local({
[16:04:27.816]             c <- base::c
[16:04:27.816]             inherits <- base::inherits
[16:04:27.816]             invokeRestart <- base::invokeRestart
[16:04:27.816]             length <- base::length
[16:04:27.816]             list <- base::list
[16:04:27.816]             seq.int <- base::seq.int
[16:04:27.816]             signalCondition <- base::signalCondition
[16:04:27.816]             sys.calls <- base::sys.calls
[16:04:27.816]             `[[` <- base::`[[`
[16:04:27.816]             `+` <- base::`+`
[16:04:27.816]             `<<-` <- base::`<<-`
[16:04:27.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.816]                   3L)]
[16:04:27.816]             }
[16:04:27.816]             function(cond) {
[16:04:27.816]                 is_error <- inherits(cond, "error")
[16:04:27.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.816]                   NULL)
[16:04:27.816]                 if (is_error) {
[16:04:27.816]                   sessionInformation <- function() {
[16:04:27.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.816]                       search = base::search(), system = base::Sys.info())
[16:04:27.816]                   }
[16:04:27.816]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.816]                     cond$call), session = sessionInformation(), 
[16:04:27.816]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.816]                   signalCondition(cond)
[16:04:27.816]                 }
[16:04:27.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.816]                 "immediateCondition"))) {
[16:04:27.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.816]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.816]                   if (TRUE && !signal) {
[16:04:27.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.816]                     {
[16:04:27.816]                       inherits <- base::inherits
[16:04:27.816]                       invokeRestart <- base::invokeRestart
[16:04:27.816]                       is.null <- base::is.null
[16:04:27.816]                       muffled <- FALSE
[16:04:27.816]                       if (inherits(cond, "message")) {
[16:04:27.816]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.816]                         if (muffled) 
[16:04:27.816]                           invokeRestart("muffleMessage")
[16:04:27.816]                       }
[16:04:27.816]                       else if (inherits(cond, "warning")) {
[16:04:27.816]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.816]                         if (muffled) 
[16:04:27.816]                           invokeRestart("muffleWarning")
[16:04:27.816]                       }
[16:04:27.816]                       else if (inherits(cond, "condition")) {
[16:04:27.816]                         if (!is.null(pattern)) {
[16:04:27.816]                           computeRestarts <- base::computeRestarts
[16:04:27.816]                           grepl <- base::grepl
[16:04:27.816]                           restarts <- computeRestarts(cond)
[16:04:27.816]                           for (restart in restarts) {
[16:04:27.816]                             name <- restart$name
[16:04:27.816]                             if (is.null(name)) 
[16:04:27.816]                               next
[16:04:27.816]                             if (!grepl(pattern, name)) 
[16:04:27.816]                               next
[16:04:27.816]                             invokeRestart(restart)
[16:04:27.816]                             muffled <- TRUE
[16:04:27.816]                             break
[16:04:27.816]                           }
[16:04:27.816]                         }
[16:04:27.816]                       }
[16:04:27.816]                       invisible(muffled)
[16:04:27.816]                     }
[16:04:27.816]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.816]                   }
[16:04:27.816]                 }
[16:04:27.816]                 else {
[16:04:27.816]                   if (TRUE) {
[16:04:27.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.816]                     {
[16:04:27.816]                       inherits <- base::inherits
[16:04:27.816]                       invokeRestart <- base::invokeRestart
[16:04:27.816]                       is.null <- base::is.null
[16:04:27.816]                       muffled <- FALSE
[16:04:27.816]                       if (inherits(cond, "message")) {
[16:04:27.816]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.816]                         if (muffled) 
[16:04:27.816]                           invokeRestart("muffleMessage")
[16:04:27.816]                       }
[16:04:27.816]                       else if (inherits(cond, "warning")) {
[16:04:27.816]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.816]                         if (muffled) 
[16:04:27.816]                           invokeRestart("muffleWarning")
[16:04:27.816]                       }
[16:04:27.816]                       else if (inherits(cond, "condition")) {
[16:04:27.816]                         if (!is.null(pattern)) {
[16:04:27.816]                           computeRestarts <- base::computeRestarts
[16:04:27.816]                           grepl <- base::grepl
[16:04:27.816]                           restarts <- computeRestarts(cond)
[16:04:27.816]                           for (restart in restarts) {
[16:04:27.816]                             name <- restart$name
[16:04:27.816]                             if (is.null(name)) 
[16:04:27.816]                               next
[16:04:27.816]                             if (!grepl(pattern, name)) 
[16:04:27.816]                               next
[16:04:27.816]                             invokeRestart(restart)
[16:04:27.816]                             muffled <- TRUE
[16:04:27.816]                             break
[16:04:27.816]                           }
[16:04:27.816]                         }
[16:04:27.816]                       }
[16:04:27.816]                       invisible(muffled)
[16:04:27.816]                     }
[16:04:27.816]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.816]                   }
[16:04:27.816]                 }
[16:04:27.816]             }
[16:04:27.816]         }))
[16:04:27.816]     }, error = function(ex) {
[16:04:27.816]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.816]                 ...future.rng), started = ...future.startTime, 
[16:04:27.816]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.816]             version = "1.8"), class = "FutureResult")
[16:04:27.816]     }, finally = {
[16:04:27.816]         if (!identical(...future.workdir, getwd())) 
[16:04:27.816]             setwd(...future.workdir)
[16:04:27.816]         {
[16:04:27.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.816]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.816]             }
[16:04:27.816]             base::options(...future.oldOptions)
[16:04:27.816]             if (.Platform$OS.type == "windows") {
[16:04:27.816]                 old_names <- names(...future.oldEnvVars)
[16:04:27.816]                 envs <- base::Sys.getenv()
[16:04:27.816]                 names <- names(envs)
[16:04:27.816]                 common <- intersect(names, old_names)
[16:04:27.816]                 added <- setdiff(names, old_names)
[16:04:27.816]                 removed <- setdiff(old_names, names)
[16:04:27.816]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.816]                   envs[common]]
[16:04:27.816]                 NAMES <- toupper(changed)
[16:04:27.816]                 args <- list()
[16:04:27.816]                 for (kk in seq_along(NAMES)) {
[16:04:27.816]                   name <- changed[[kk]]
[16:04:27.816]                   NAME <- NAMES[[kk]]
[16:04:27.816]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.816]                     next
[16:04:27.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.816]                 }
[16:04:27.816]                 NAMES <- toupper(added)
[16:04:27.816]                 for (kk in seq_along(NAMES)) {
[16:04:27.816]                   name <- added[[kk]]
[16:04:27.816]                   NAME <- NAMES[[kk]]
[16:04:27.816]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.816]                     next
[16:04:27.816]                   args[[name]] <- ""
[16:04:27.816]                 }
[16:04:27.816]                 NAMES <- toupper(removed)
[16:04:27.816]                 for (kk in seq_along(NAMES)) {
[16:04:27.816]                   name <- removed[[kk]]
[16:04:27.816]                   NAME <- NAMES[[kk]]
[16:04:27.816]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.816]                     next
[16:04:27.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.816]                 }
[16:04:27.816]                 if (length(args) > 0) 
[16:04:27.816]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.816]             }
[16:04:27.816]             else {
[16:04:27.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.816]             }
[16:04:27.816]             {
[16:04:27.816]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.816]                   0L) {
[16:04:27.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.816]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.816]                   base::options(opts)
[16:04:27.816]                 }
[16:04:27.816]                 {
[16:04:27.816]                   {
[16:04:27.816]                     NULL
[16:04:27.816]                     RNGkind("Mersenne-Twister")
[16:04:27.816]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.816]                       inherits = FALSE)
[16:04:27.816]                   }
[16:04:27.816]                   options(future.plan = NULL)
[16:04:27.816]                   if (is.na(NA_character_)) 
[16:04:27.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.816]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.816]                   {
[16:04:27.816]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.816]                     if (!future$lazy) 
[16:04:27.816]                       future <- run(future)
[16:04:27.816]                     invisible(future)
[16:04:27.816]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.816]                 }
[16:04:27.816]             }
[16:04:27.816]         }
[16:04:27.816]     })
[16:04:27.816]     if (TRUE) {
[16:04:27.816]         base::sink(type = "output", split = FALSE)
[16:04:27.816]         if (TRUE) {
[16:04:27.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.816]         }
[16:04:27.816]         else {
[16:04:27.816]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.816]         }
[16:04:27.816]         base::close(...future.stdout)
[16:04:27.816]         ...future.stdout <- NULL
[16:04:27.816]     }
[16:04:27.816]     ...future.result$conditions <- ...future.conditions
[16:04:27.816]     ...future.result$finished <- base::Sys.time()
[16:04:27.816]     ...future.result
[16:04:27.816] }
[16:04:27.817] plan(): Setting new future strategy stack:
[16:04:27.817] List of future strategies:
[16:04:27.817] 1. sequential:
[16:04:27.817]    - args: function (..., envir = parent.frame())
[16:04:27.817]    - tweaked: FALSE
[16:04:27.817]    - call: NULL
[16:04:27.818] plan(): nbrOfWorkers() = 1
[16:04:27.818] plan(): Setting new future strategy stack:
[16:04:27.818] List of future strategies:
[16:04:27.818] 1. sequential:
[16:04:27.818]    - args: function (..., envir = parent.frame())
[16:04:27.818]    - tweaked: FALSE
[16:04:27.818]    - call: plan(strategy)
[16:04:27.819] plan(): nbrOfWorkers() = 1
[16:04:27.819] SequentialFuture started (and completed)
[16:04:27.819] - Launch lazy future ... done
[16:04:27.819] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.820] getGlobalsAndPackages() ...
[16:04:27.820] Searching for globals...
[16:04:27.820] 
[16:04:27.820] Searching for globals ... DONE
[16:04:27.820] - globals: [0] <none>
[16:04:27.821] getGlobalsAndPackages() ... DONE
[16:04:27.821] Packages needed by the future expression (n = 0): <none>
[16:04:27.821] Packages needed by future strategies (n = 0): <none>
[16:04:27.821] {
[16:04:27.821]     {
[16:04:27.821]         {
[16:04:27.821]             ...future.startTime <- base::Sys.time()
[16:04:27.821]             {
[16:04:27.821]                 {
[16:04:27.821]                   {
[16:04:27.821]                     base::local({
[16:04:27.821]                       has_future <- base::requireNamespace("future", 
[16:04:27.821]                         quietly = TRUE)
[16:04:27.821]                       if (has_future) {
[16:04:27.821]                         ns <- base::getNamespace("future")
[16:04:27.821]                         version <- ns[[".package"]][["version"]]
[16:04:27.821]                         if (is.null(version)) 
[16:04:27.821]                           version <- utils::packageVersion("future")
[16:04:27.821]                       }
[16:04:27.821]                       else {
[16:04:27.821]                         version <- NULL
[16:04:27.821]                       }
[16:04:27.821]                       if (!has_future || version < "1.8.0") {
[16:04:27.821]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.821]                           "", base::R.version$version.string), 
[16:04:27.821]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.821]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.821]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.821]                             "release", "version")], collapse = " "), 
[16:04:27.821]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.821]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.821]                           info)
[16:04:27.821]                         info <- base::paste(info, collapse = "; ")
[16:04:27.821]                         if (!has_future) {
[16:04:27.821]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.821]                             info)
[16:04:27.821]                         }
[16:04:27.821]                         else {
[16:04:27.821]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.821]                             info, version)
[16:04:27.821]                         }
[16:04:27.821]                         base::stop(msg)
[16:04:27.821]                       }
[16:04:27.821]                     })
[16:04:27.821]                   }
[16:04:27.821]                   options(future.plan = NULL)
[16:04:27.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.821]                 }
[16:04:27.821]                 ...future.workdir <- getwd()
[16:04:27.821]             }
[16:04:27.821]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.821]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.821]         }
[16:04:27.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.821]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.821]             base::names(...future.oldOptions))
[16:04:27.821]     }
[16:04:27.821]     if (FALSE) {
[16:04:27.821]     }
[16:04:27.821]     else {
[16:04:27.821]         if (TRUE) {
[16:04:27.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.821]                 open = "w")
[16:04:27.821]         }
[16:04:27.821]         else {
[16:04:27.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.821]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.821]         }
[16:04:27.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.821]             base::sink(type = "output", split = FALSE)
[16:04:27.821]             base::close(...future.stdout)
[16:04:27.821]         }, add = TRUE)
[16:04:27.821]     }
[16:04:27.821]     ...future.frame <- base::sys.nframe()
[16:04:27.821]     ...future.conditions <- base::list()
[16:04:27.821]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.821]     if (FALSE) {
[16:04:27.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.821]     }
[16:04:27.821]     ...future.result <- base::tryCatch({
[16:04:27.821]         base::withCallingHandlers({
[16:04:27.821]             ...future.value <- base::withVisible(base::local(42))
[16:04:27.821]             future::FutureResult(value = ...future.value$value, 
[16:04:27.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.821]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.821]                     ...future.globalenv.names))
[16:04:27.821]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.821]         }, condition = base::local({
[16:04:27.821]             c <- base::c
[16:04:27.821]             inherits <- base::inherits
[16:04:27.821]             invokeRestart <- base::invokeRestart
[16:04:27.821]             length <- base::length
[16:04:27.821]             list <- base::list
[16:04:27.821]             seq.int <- base::seq.int
[16:04:27.821]             signalCondition <- base::signalCondition
[16:04:27.821]             sys.calls <- base::sys.calls
[16:04:27.821]             `[[` <- base::`[[`
[16:04:27.821]             `+` <- base::`+`
[16:04:27.821]             `<<-` <- base::`<<-`
[16:04:27.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.821]                   3L)]
[16:04:27.821]             }
[16:04:27.821]             function(cond) {
[16:04:27.821]                 is_error <- inherits(cond, "error")
[16:04:27.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.821]                   NULL)
[16:04:27.821]                 if (is_error) {
[16:04:27.821]                   sessionInformation <- function() {
[16:04:27.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.821]                       search = base::search(), system = base::Sys.info())
[16:04:27.821]                   }
[16:04:27.821]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.821]                     cond$call), session = sessionInformation(), 
[16:04:27.821]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.821]                   signalCondition(cond)
[16:04:27.821]                 }
[16:04:27.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.821]                 "immediateCondition"))) {
[16:04:27.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.821]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.821]                   if (TRUE && !signal) {
[16:04:27.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.821]                     {
[16:04:27.821]                       inherits <- base::inherits
[16:04:27.821]                       invokeRestart <- base::invokeRestart
[16:04:27.821]                       is.null <- base::is.null
[16:04:27.821]                       muffled <- FALSE
[16:04:27.821]                       if (inherits(cond, "message")) {
[16:04:27.821]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.821]                         if (muffled) 
[16:04:27.821]                           invokeRestart("muffleMessage")
[16:04:27.821]                       }
[16:04:27.821]                       else if (inherits(cond, "warning")) {
[16:04:27.821]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.821]                         if (muffled) 
[16:04:27.821]                           invokeRestart("muffleWarning")
[16:04:27.821]                       }
[16:04:27.821]                       else if (inherits(cond, "condition")) {
[16:04:27.821]                         if (!is.null(pattern)) {
[16:04:27.821]                           computeRestarts <- base::computeRestarts
[16:04:27.821]                           grepl <- base::grepl
[16:04:27.821]                           restarts <- computeRestarts(cond)
[16:04:27.821]                           for (restart in restarts) {
[16:04:27.821]                             name <- restart$name
[16:04:27.821]                             if (is.null(name)) 
[16:04:27.821]                               next
[16:04:27.821]                             if (!grepl(pattern, name)) 
[16:04:27.821]                               next
[16:04:27.821]                             invokeRestart(restart)
[16:04:27.821]                             muffled <- TRUE
[16:04:27.821]                             break
[16:04:27.821]                           }
[16:04:27.821]                         }
[16:04:27.821]                       }
[16:04:27.821]                       invisible(muffled)
[16:04:27.821]                     }
[16:04:27.821]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.821]                   }
[16:04:27.821]                 }
[16:04:27.821]                 else {
[16:04:27.821]                   if (TRUE) {
[16:04:27.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.821]                     {
[16:04:27.821]                       inherits <- base::inherits
[16:04:27.821]                       invokeRestart <- base::invokeRestart
[16:04:27.821]                       is.null <- base::is.null
[16:04:27.821]                       muffled <- FALSE
[16:04:27.821]                       if (inherits(cond, "message")) {
[16:04:27.821]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.821]                         if (muffled) 
[16:04:27.821]                           invokeRestart("muffleMessage")
[16:04:27.821]                       }
[16:04:27.821]                       else if (inherits(cond, "warning")) {
[16:04:27.821]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.821]                         if (muffled) 
[16:04:27.821]                           invokeRestart("muffleWarning")
[16:04:27.821]                       }
[16:04:27.821]                       else if (inherits(cond, "condition")) {
[16:04:27.821]                         if (!is.null(pattern)) {
[16:04:27.821]                           computeRestarts <- base::computeRestarts
[16:04:27.821]                           grepl <- base::grepl
[16:04:27.821]                           restarts <- computeRestarts(cond)
[16:04:27.821]                           for (restart in restarts) {
[16:04:27.821]                             name <- restart$name
[16:04:27.821]                             if (is.null(name)) 
[16:04:27.821]                               next
[16:04:27.821]                             if (!grepl(pattern, name)) 
[16:04:27.821]                               next
[16:04:27.821]                             invokeRestart(restart)
[16:04:27.821]                             muffled <- TRUE
[16:04:27.821]                             break
[16:04:27.821]                           }
[16:04:27.821]                         }
[16:04:27.821]                       }
[16:04:27.821]                       invisible(muffled)
[16:04:27.821]                     }
[16:04:27.821]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.821]                   }
[16:04:27.821]                 }
[16:04:27.821]             }
[16:04:27.821]         }))
[16:04:27.821]     }, error = function(ex) {
[16:04:27.821]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.821]                 ...future.rng), started = ...future.startTime, 
[16:04:27.821]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.821]             version = "1.8"), class = "FutureResult")
[16:04:27.821]     }, finally = {
[16:04:27.821]         if (!identical(...future.workdir, getwd())) 
[16:04:27.821]             setwd(...future.workdir)
[16:04:27.821]         {
[16:04:27.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.821]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.821]             }
[16:04:27.821]             base::options(...future.oldOptions)
[16:04:27.821]             if (.Platform$OS.type == "windows") {
[16:04:27.821]                 old_names <- names(...future.oldEnvVars)
[16:04:27.821]                 envs <- base::Sys.getenv()
[16:04:27.821]                 names <- names(envs)
[16:04:27.821]                 common <- intersect(names, old_names)
[16:04:27.821]                 added <- setdiff(names, old_names)
[16:04:27.821]                 removed <- setdiff(old_names, names)
[16:04:27.821]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.821]                   envs[common]]
[16:04:27.821]                 NAMES <- toupper(changed)
[16:04:27.821]                 args <- list()
[16:04:27.821]                 for (kk in seq_along(NAMES)) {
[16:04:27.821]                   name <- changed[[kk]]
[16:04:27.821]                   NAME <- NAMES[[kk]]
[16:04:27.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.821]                     next
[16:04:27.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.821]                 }
[16:04:27.821]                 NAMES <- toupper(added)
[16:04:27.821]                 for (kk in seq_along(NAMES)) {
[16:04:27.821]                   name <- added[[kk]]
[16:04:27.821]                   NAME <- NAMES[[kk]]
[16:04:27.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.821]                     next
[16:04:27.821]                   args[[name]] <- ""
[16:04:27.821]                 }
[16:04:27.821]                 NAMES <- toupper(removed)
[16:04:27.821]                 for (kk in seq_along(NAMES)) {
[16:04:27.821]                   name <- removed[[kk]]
[16:04:27.821]                   NAME <- NAMES[[kk]]
[16:04:27.821]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.821]                     next
[16:04:27.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.821]                 }
[16:04:27.821]                 if (length(args) > 0) 
[16:04:27.821]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.821]             }
[16:04:27.821]             else {
[16:04:27.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.821]             }
[16:04:27.821]             {
[16:04:27.821]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.821]                   0L) {
[16:04:27.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.821]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.821]                   base::options(opts)
[16:04:27.821]                 }
[16:04:27.821]                 {
[16:04:27.821]                   {
[16:04:27.821]                     NULL
[16:04:27.821]                     RNGkind("Mersenne-Twister")
[16:04:27.821]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.821]                       inherits = FALSE)
[16:04:27.821]                   }
[16:04:27.821]                   options(future.plan = NULL)
[16:04:27.821]                   if (is.na(NA_character_)) 
[16:04:27.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.821]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.821]                   {
[16:04:27.821]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.821]                     if (!future$lazy) 
[16:04:27.821]                       future <- run(future)
[16:04:27.821]                     invisible(future)
[16:04:27.821]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.821]                 }
[16:04:27.821]             }
[16:04:27.821]         }
[16:04:27.821]     })
[16:04:27.821]     if (TRUE) {
[16:04:27.821]         base::sink(type = "output", split = FALSE)
[16:04:27.821]         if (TRUE) {
[16:04:27.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.821]         }
[16:04:27.821]         else {
[16:04:27.821]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.821]         }
[16:04:27.821]         base::close(...future.stdout)
[16:04:27.821]         ...future.stdout <- NULL
[16:04:27.821]     }
[16:04:27.821]     ...future.result$conditions <- ...future.conditions
[16:04:27.821]     ...future.result$finished <- base::Sys.time()
[16:04:27.821]     ...future.result
[16:04:27.821] }
[16:04:27.823] plan(): Setting new future strategy stack:
[16:04:27.823] List of future strategies:
[16:04:27.823] 1. sequential:
[16:04:27.823]    - args: function (..., envir = parent.frame())
[16:04:27.823]    - tweaked: FALSE
[16:04:27.823]    - call: NULL
[16:04:27.823] plan(): nbrOfWorkers() = 1
[16:04:27.824] plan(): Setting new future strategy stack:
[16:04:27.824] List of future strategies:
[16:04:27.824] 1. sequential:
[16:04:27.824]    - args: function (..., envir = parent.frame())
[16:04:27.824]    - tweaked: FALSE
[16:04:27.824]    - call: plan(strategy)
[16:04:27.824] plan(): nbrOfWorkers() = 1
[16:04:27.825] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.825] getGlobalsAndPackages() ...
[16:04:27.825] Searching for globals...
[16:04:27.826] 
[16:04:27.826] Searching for globals ... DONE
[16:04:27.826] - globals: [0] <none>
[16:04:27.826] getGlobalsAndPackages() ... DONE
[16:04:27.826] run() for ‘Future’ ...
[16:04:27.826] - state: ‘created’
[16:04:27.826] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:27.827] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.827] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:27.827]   - Field: ‘label’
[16:04:27.827]   - Field: ‘local’
[16:04:27.827]   - Field: ‘owner’
[16:04:27.827]   - Field: ‘envir’
[16:04:27.829]   - Field: ‘packages’
[16:04:27.829]   - Field: ‘gc’
[16:04:27.829]   - Field: ‘conditions’
[16:04:27.829]   - Field: ‘expr’
[16:04:27.829]   - Field: ‘uuid’
[16:04:27.829]   - Field: ‘seed’
[16:04:27.829]   - Field: ‘version’
[16:04:27.830]   - Field: ‘result’
[16:04:27.830]   - Field: ‘asynchronous’
[16:04:27.830]   - Field: ‘calls’
[16:04:27.830]   - Field: ‘globals’
[16:04:27.830]   - Field: ‘stdout’
[16:04:27.830]   - Field: ‘earlySignal’
[16:04:27.830]   - Field: ‘lazy’
[16:04:27.830]   - Field: ‘state’
[16:04:27.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:27.830] - Launch lazy future ...
[16:04:27.831] Packages needed by the future expression (n = 0): <none>
[16:04:27.831] Packages needed by future strategies (n = 0): <none>
[16:04:27.831] {
[16:04:27.831]     {
[16:04:27.831]         {
[16:04:27.831]             ...future.startTime <- base::Sys.time()
[16:04:27.831]             {
[16:04:27.831]                 {
[16:04:27.831]                   {
[16:04:27.831]                     base::local({
[16:04:27.831]                       has_future <- base::requireNamespace("future", 
[16:04:27.831]                         quietly = TRUE)
[16:04:27.831]                       if (has_future) {
[16:04:27.831]                         ns <- base::getNamespace("future")
[16:04:27.831]                         version <- ns[[".package"]][["version"]]
[16:04:27.831]                         if (is.null(version)) 
[16:04:27.831]                           version <- utils::packageVersion("future")
[16:04:27.831]                       }
[16:04:27.831]                       else {
[16:04:27.831]                         version <- NULL
[16:04:27.831]                       }
[16:04:27.831]                       if (!has_future || version < "1.8.0") {
[16:04:27.831]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.831]                           "", base::R.version$version.string), 
[16:04:27.831]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.831]                             "release", "version")], collapse = " "), 
[16:04:27.831]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.831]                           info)
[16:04:27.831]                         info <- base::paste(info, collapse = "; ")
[16:04:27.831]                         if (!has_future) {
[16:04:27.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.831]                             info)
[16:04:27.831]                         }
[16:04:27.831]                         else {
[16:04:27.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.831]                             info, version)
[16:04:27.831]                         }
[16:04:27.831]                         base::stop(msg)
[16:04:27.831]                       }
[16:04:27.831]                     })
[16:04:27.831]                   }
[16:04:27.831]                   options(future.plan = NULL)
[16:04:27.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.831]                 }
[16:04:27.831]                 ...future.workdir <- getwd()
[16:04:27.831]             }
[16:04:27.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.831]         }
[16:04:27.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.831]             base::names(...future.oldOptions))
[16:04:27.831]     }
[16:04:27.831]     if (FALSE) {
[16:04:27.831]     }
[16:04:27.831]     else {
[16:04:27.831]         if (TRUE) {
[16:04:27.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.831]                 open = "w")
[16:04:27.831]         }
[16:04:27.831]         else {
[16:04:27.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.831]         }
[16:04:27.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.831]             base::sink(type = "output", split = FALSE)
[16:04:27.831]             base::close(...future.stdout)
[16:04:27.831]         }, add = TRUE)
[16:04:27.831]     }
[16:04:27.831]     ...future.frame <- base::sys.nframe()
[16:04:27.831]     ...future.conditions <- base::list()
[16:04:27.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.831]     if (FALSE) {
[16:04:27.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.831]     }
[16:04:27.831]     ...future.result <- base::tryCatch({
[16:04:27.831]         base::withCallingHandlers({
[16:04:27.831]             ...future.value <- base::withVisible(base::local(42))
[16:04:27.831]             future::FutureResult(value = ...future.value$value, 
[16:04:27.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.831]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.831]                     ...future.globalenv.names))
[16:04:27.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.831]         }, condition = base::local({
[16:04:27.831]             c <- base::c
[16:04:27.831]             inherits <- base::inherits
[16:04:27.831]             invokeRestart <- base::invokeRestart
[16:04:27.831]             length <- base::length
[16:04:27.831]             list <- base::list
[16:04:27.831]             seq.int <- base::seq.int
[16:04:27.831]             signalCondition <- base::signalCondition
[16:04:27.831]             sys.calls <- base::sys.calls
[16:04:27.831]             `[[` <- base::`[[`
[16:04:27.831]             `+` <- base::`+`
[16:04:27.831]             `<<-` <- base::`<<-`
[16:04:27.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.831]                   3L)]
[16:04:27.831]             }
[16:04:27.831]             function(cond) {
[16:04:27.831]                 is_error <- inherits(cond, "error")
[16:04:27.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.831]                   NULL)
[16:04:27.831]                 if (is_error) {
[16:04:27.831]                   sessionInformation <- function() {
[16:04:27.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.831]                       search = base::search(), system = base::Sys.info())
[16:04:27.831]                   }
[16:04:27.831]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.831]                     cond$call), session = sessionInformation(), 
[16:04:27.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.831]                   signalCondition(cond)
[16:04:27.831]                 }
[16:04:27.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.831]                 "immediateCondition"))) {
[16:04:27.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.831]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.831]                   if (TRUE && !signal) {
[16:04:27.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.831]                     {
[16:04:27.831]                       inherits <- base::inherits
[16:04:27.831]                       invokeRestart <- base::invokeRestart
[16:04:27.831]                       is.null <- base::is.null
[16:04:27.831]                       muffled <- FALSE
[16:04:27.831]                       if (inherits(cond, "message")) {
[16:04:27.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.831]                         if (muffled) 
[16:04:27.831]                           invokeRestart("muffleMessage")
[16:04:27.831]                       }
[16:04:27.831]                       else if (inherits(cond, "warning")) {
[16:04:27.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.831]                         if (muffled) 
[16:04:27.831]                           invokeRestart("muffleWarning")
[16:04:27.831]                       }
[16:04:27.831]                       else if (inherits(cond, "condition")) {
[16:04:27.831]                         if (!is.null(pattern)) {
[16:04:27.831]                           computeRestarts <- base::computeRestarts
[16:04:27.831]                           grepl <- base::grepl
[16:04:27.831]                           restarts <- computeRestarts(cond)
[16:04:27.831]                           for (restart in restarts) {
[16:04:27.831]                             name <- restart$name
[16:04:27.831]                             if (is.null(name)) 
[16:04:27.831]                               next
[16:04:27.831]                             if (!grepl(pattern, name)) 
[16:04:27.831]                               next
[16:04:27.831]                             invokeRestart(restart)
[16:04:27.831]                             muffled <- TRUE
[16:04:27.831]                             break
[16:04:27.831]                           }
[16:04:27.831]                         }
[16:04:27.831]                       }
[16:04:27.831]                       invisible(muffled)
[16:04:27.831]                     }
[16:04:27.831]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.831]                   }
[16:04:27.831]                 }
[16:04:27.831]                 else {
[16:04:27.831]                   if (TRUE) {
[16:04:27.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.831]                     {
[16:04:27.831]                       inherits <- base::inherits
[16:04:27.831]                       invokeRestart <- base::invokeRestart
[16:04:27.831]                       is.null <- base::is.null
[16:04:27.831]                       muffled <- FALSE
[16:04:27.831]                       if (inherits(cond, "message")) {
[16:04:27.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.831]                         if (muffled) 
[16:04:27.831]                           invokeRestart("muffleMessage")
[16:04:27.831]                       }
[16:04:27.831]                       else if (inherits(cond, "warning")) {
[16:04:27.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.831]                         if (muffled) 
[16:04:27.831]                           invokeRestart("muffleWarning")
[16:04:27.831]                       }
[16:04:27.831]                       else if (inherits(cond, "condition")) {
[16:04:27.831]                         if (!is.null(pattern)) {
[16:04:27.831]                           computeRestarts <- base::computeRestarts
[16:04:27.831]                           grepl <- base::grepl
[16:04:27.831]                           restarts <- computeRestarts(cond)
[16:04:27.831]                           for (restart in restarts) {
[16:04:27.831]                             name <- restart$name
[16:04:27.831]                             if (is.null(name)) 
[16:04:27.831]                               next
[16:04:27.831]                             if (!grepl(pattern, name)) 
[16:04:27.831]                               next
[16:04:27.831]                             invokeRestart(restart)
[16:04:27.831]                             muffled <- TRUE
[16:04:27.831]                             break
[16:04:27.831]                           }
[16:04:27.831]                         }
[16:04:27.831]                       }
[16:04:27.831]                       invisible(muffled)
[16:04:27.831]                     }
[16:04:27.831]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.831]                   }
[16:04:27.831]                 }
[16:04:27.831]             }
[16:04:27.831]         }))
[16:04:27.831]     }, error = function(ex) {
[16:04:27.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.831]                 ...future.rng), started = ...future.startTime, 
[16:04:27.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.831]             version = "1.8"), class = "FutureResult")
[16:04:27.831]     }, finally = {
[16:04:27.831]         if (!identical(...future.workdir, getwd())) 
[16:04:27.831]             setwd(...future.workdir)
[16:04:27.831]         {
[16:04:27.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.831]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.831]             }
[16:04:27.831]             base::options(...future.oldOptions)
[16:04:27.831]             if (.Platform$OS.type == "windows") {
[16:04:27.831]                 old_names <- names(...future.oldEnvVars)
[16:04:27.831]                 envs <- base::Sys.getenv()
[16:04:27.831]                 names <- names(envs)
[16:04:27.831]                 common <- intersect(names, old_names)
[16:04:27.831]                 added <- setdiff(names, old_names)
[16:04:27.831]                 removed <- setdiff(old_names, names)
[16:04:27.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.831]                   envs[common]]
[16:04:27.831]                 NAMES <- toupper(changed)
[16:04:27.831]                 args <- list()
[16:04:27.831]                 for (kk in seq_along(NAMES)) {
[16:04:27.831]                   name <- changed[[kk]]
[16:04:27.831]                   NAME <- NAMES[[kk]]
[16:04:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.831]                     next
[16:04:27.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.831]                 }
[16:04:27.831]                 NAMES <- toupper(added)
[16:04:27.831]                 for (kk in seq_along(NAMES)) {
[16:04:27.831]                   name <- added[[kk]]
[16:04:27.831]                   NAME <- NAMES[[kk]]
[16:04:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.831]                     next
[16:04:27.831]                   args[[name]] <- ""
[16:04:27.831]                 }
[16:04:27.831]                 NAMES <- toupper(removed)
[16:04:27.831]                 for (kk in seq_along(NAMES)) {
[16:04:27.831]                   name <- removed[[kk]]
[16:04:27.831]                   NAME <- NAMES[[kk]]
[16:04:27.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.831]                     next
[16:04:27.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.831]                 }
[16:04:27.831]                 if (length(args) > 0) 
[16:04:27.831]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.831]             }
[16:04:27.831]             else {
[16:04:27.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.831]             }
[16:04:27.831]             {
[16:04:27.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.831]                   0L) {
[16:04:27.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.831]                   base::options(opts)
[16:04:27.831]                 }
[16:04:27.831]                 {
[16:04:27.831]                   {
[16:04:27.831]                     NULL
[16:04:27.831]                     RNGkind("Mersenne-Twister")
[16:04:27.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.831]                       inherits = FALSE)
[16:04:27.831]                   }
[16:04:27.831]                   options(future.plan = NULL)
[16:04:27.831]                   if (is.na(NA_character_)) 
[16:04:27.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.831]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.831]                   {
[16:04:27.831]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.831]                     if (!future$lazy) 
[16:04:27.831]                       future <- run(future)
[16:04:27.831]                     invisible(future)
[16:04:27.831]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.831]                 }
[16:04:27.831]             }
[16:04:27.831]         }
[16:04:27.831]     })
[16:04:27.831]     if (TRUE) {
[16:04:27.831]         base::sink(type = "output", split = FALSE)
[16:04:27.831]         if (TRUE) {
[16:04:27.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.831]         }
[16:04:27.831]         else {
[16:04:27.831]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.831]         }
[16:04:27.831]         base::close(...future.stdout)
[16:04:27.831]         ...future.stdout <- NULL
[16:04:27.831]     }
[16:04:27.831]     ...future.result$conditions <- ...future.conditions
[16:04:27.831]     ...future.result$finished <- base::Sys.time()
[16:04:27.831]     ...future.result
[16:04:27.831] }
[16:04:27.833] plan(): Setting new future strategy stack:
[16:04:27.833] List of future strategies:
[16:04:27.833] 1. sequential:
[16:04:27.833]    - args: function (..., envir = parent.frame())
[16:04:27.833]    - tweaked: FALSE
[16:04:27.833]    - call: NULL
[16:04:27.833] plan(): nbrOfWorkers() = 1
[16:04:27.834] plan(): Setting new future strategy stack:
[16:04:27.834] List of future strategies:
[16:04:27.834] 1. sequential:
[16:04:27.834]    - args: function (..., envir = parent.frame())
[16:04:27.834]    - tweaked: FALSE
[16:04:27.834]    - call: plan(strategy)
[16:04:27.834] plan(): nbrOfWorkers() = 1
[16:04:27.834] SequentialFuture started (and completed)
[16:04:27.835] - Launch lazy future ... done
[16:04:27.835] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.835] getGlobalsAndPackages() ...
[16:04:27.835] Searching for globals...
[16:04:27.836] - globals found: [1] ‘{’
[16:04:27.836] Searching for globals ... DONE
[16:04:27.836] Resolving globals: FALSE
[16:04:27.836] 
[16:04:27.836] 
[16:04:27.837] getGlobalsAndPackages() ... DONE
[16:04:27.837] run() for ‘Future’ ...
[16:04:27.837] - state: ‘created’
[16:04:27.837] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:27.837] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:27.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:27.837]   - Field: ‘label’
[16:04:27.837]   - Field: ‘local’
[16:04:27.838]   - Field: ‘owner’
[16:04:27.838]   - Field: ‘envir’
[16:04:27.838]   - Field: ‘packages’
[16:04:27.838]   - Field: ‘gc’
[16:04:27.838]   - Field: ‘conditions’
[16:04:27.838]   - Field: ‘expr’
[16:04:27.838]   - Field: ‘uuid’
[16:04:27.838]   - Field: ‘seed’
[16:04:27.838]   - Field: ‘version’
[16:04:27.838]   - Field: ‘result’
[16:04:27.838]   - Field: ‘asynchronous’
[16:04:27.839]   - Field: ‘calls’
[16:04:27.839]   - Field: ‘globals’
[16:04:27.839]   - Field: ‘stdout’
[16:04:27.839]   - Field: ‘earlySignal’
[16:04:27.839]   - Field: ‘lazy’
[16:04:27.839]   - Field: ‘state’
[16:04:27.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:27.839] - Launch lazy future ...
[16:04:27.839] Packages needed by the future expression (n = 0): <none>
[16:04:27.839] Packages needed by future strategies (n = 0): <none>
[16:04:27.840] {
[16:04:27.840]     {
[16:04:27.840]         {
[16:04:27.840]             ...future.startTime <- base::Sys.time()
[16:04:27.840]             {
[16:04:27.840]                 {
[16:04:27.840]                   {
[16:04:27.840]                     base::local({
[16:04:27.840]                       has_future <- base::requireNamespace("future", 
[16:04:27.840]                         quietly = TRUE)
[16:04:27.840]                       if (has_future) {
[16:04:27.840]                         ns <- base::getNamespace("future")
[16:04:27.840]                         version <- ns[[".package"]][["version"]]
[16:04:27.840]                         if (is.null(version)) 
[16:04:27.840]                           version <- utils::packageVersion("future")
[16:04:27.840]                       }
[16:04:27.840]                       else {
[16:04:27.840]                         version <- NULL
[16:04:27.840]                       }
[16:04:27.840]                       if (!has_future || version < "1.8.0") {
[16:04:27.840]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.840]                           "", base::R.version$version.string), 
[16:04:27.840]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:27.840]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.840]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.840]                             "release", "version")], collapse = " "), 
[16:04:27.840]                           hostname = base::Sys.info()[["nodename"]])
[16:04:27.840]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.840]                           info)
[16:04:27.840]                         info <- base::paste(info, collapse = "; ")
[16:04:27.840]                         if (!has_future) {
[16:04:27.840]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.840]                             info)
[16:04:27.840]                         }
[16:04:27.840]                         else {
[16:04:27.840]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.840]                             info, version)
[16:04:27.840]                         }
[16:04:27.840]                         base::stop(msg)
[16:04:27.840]                       }
[16:04:27.840]                     })
[16:04:27.840]                   }
[16:04:27.840]                   options(future.plan = NULL)
[16:04:27.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.840]                 }
[16:04:27.840]                 ...future.workdir <- getwd()
[16:04:27.840]             }
[16:04:27.840]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.840]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.840]         }
[16:04:27.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.840]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.840]             base::names(...future.oldOptions))
[16:04:27.840]     }
[16:04:27.840]     if (FALSE) {
[16:04:27.840]     }
[16:04:27.840]     else {
[16:04:27.840]         if (TRUE) {
[16:04:27.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.840]                 open = "w")
[16:04:27.840]         }
[16:04:27.840]         else {
[16:04:27.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.840]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.840]         }
[16:04:27.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.840]             base::sink(type = "output", split = FALSE)
[16:04:27.840]             base::close(...future.stdout)
[16:04:27.840]         }, add = TRUE)
[16:04:27.840]     }
[16:04:27.840]     ...future.frame <- base::sys.nframe()
[16:04:27.840]     ...future.conditions <- base::list()
[16:04:27.840]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.840]     if (FALSE) {
[16:04:27.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.840]     }
[16:04:27.840]     ...future.result <- base::tryCatch({
[16:04:27.840]         base::withCallingHandlers({
[16:04:27.840]             ...future.value <- base::withVisible(base::local({
[16:04:27.840]                 42
[16:04:27.840]             }))
[16:04:27.840]             future::FutureResult(value = ...future.value$value, 
[16:04:27.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.840]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.840]                     ...future.globalenv.names))
[16:04:27.840]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.840]         }, condition = base::local({
[16:04:27.840]             c <- base::c
[16:04:27.840]             inherits <- base::inherits
[16:04:27.840]             invokeRestart <- base::invokeRestart
[16:04:27.840]             length <- base::length
[16:04:27.840]             list <- base::list
[16:04:27.840]             seq.int <- base::seq.int
[16:04:27.840]             signalCondition <- base::signalCondition
[16:04:27.840]             sys.calls <- base::sys.calls
[16:04:27.840]             `[[` <- base::`[[`
[16:04:27.840]             `+` <- base::`+`
[16:04:27.840]             `<<-` <- base::`<<-`
[16:04:27.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.840]                   3L)]
[16:04:27.840]             }
[16:04:27.840]             function(cond) {
[16:04:27.840]                 is_error <- inherits(cond, "error")
[16:04:27.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.840]                   NULL)
[16:04:27.840]                 if (is_error) {
[16:04:27.840]                   sessionInformation <- function() {
[16:04:27.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.840]                       search = base::search(), system = base::Sys.info())
[16:04:27.840]                   }
[16:04:27.840]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.840]                     cond$call), session = sessionInformation(), 
[16:04:27.840]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.840]                   signalCondition(cond)
[16:04:27.840]                 }
[16:04:27.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.840]                 "immediateCondition"))) {
[16:04:27.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.840]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.840]                   if (TRUE && !signal) {
[16:04:27.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.840]                     {
[16:04:27.840]                       inherits <- base::inherits
[16:04:27.840]                       invokeRestart <- base::invokeRestart
[16:04:27.840]                       is.null <- base::is.null
[16:04:27.840]                       muffled <- FALSE
[16:04:27.840]                       if (inherits(cond, "message")) {
[16:04:27.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.840]                         if (muffled) 
[16:04:27.840]                           invokeRestart("muffleMessage")
[16:04:27.840]                       }
[16:04:27.840]                       else if (inherits(cond, "warning")) {
[16:04:27.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.840]                         if (muffled) 
[16:04:27.840]                           invokeRestart("muffleWarning")
[16:04:27.840]                       }
[16:04:27.840]                       else if (inherits(cond, "condition")) {
[16:04:27.840]                         if (!is.null(pattern)) {
[16:04:27.840]                           computeRestarts <- base::computeRestarts
[16:04:27.840]                           grepl <- base::grepl
[16:04:27.840]                           restarts <- computeRestarts(cond)
[16:04:27.840]                           for (restart in restarts) {
[16:04:27.840]                             name <- restart$name
[16:04:27.840]                             if (is.null(name)) 
[16:04:27.840]                               next
[16:04:27.840]                             if (!grepl(pattern, name)) 
[16:04:27.840]                               next
[16:04:27.840]                             invokeRestart(restart)
[16:04:27.840]                             muffled <- TRUE
[16:04:27.840]                             break
[16:04:27.840]                           }
[16:04:27.840]                         }
[16:04:27.840]                       }
[16:04:27.840]                       invisible(muffled)
[16:04:27.840]                     }
[16:04:27.840]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.840]                   }
[16:04:27.840]                 }
[16:04:27.840]                 else {
[16:04:27.840]                   if (TRUE) {
[16:04:27.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.840]                     {
[16:04:27.840]                       inherits <- base::inherits
[16:04:27.840]                       invokeRestart <- base::invokeRestart
[16:04:27.840]                       is.null <- base::is.null
[16:04:27.840]                       muffled <- FALSE
[16:04:27.840]                       if (inherits(cond, "message")) {
[16:04:27.840]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.840]                         if (muffled) 
[16:04:27.840]                           invokeRestart("muffleMessage")
[16:04:27.840]                       }
[16:04:27.840]                       else if (inherits(cond, "warning")) {
[16:04:27.840]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.840]                         if (muffled) 
[16:04:27.840]                           invokeRestart("muffleWarning")
[16:04:27.840]                       }
[16:04:27.840]                       else if (inherits(cond, "condition")) {
[16:04:27.840]                         if (!is.null(pattern)) {
[16:04:27.840]                           computeRestarts <- base::computeRestarts
[16:04:27.840]                           grepl <- base::grepl
[16:04:27.840]                           restarts <- computeRestarts(cond)
[16:04:27.840]                           for (restart in restarts) {
[16:04:27.840]                             name <- restart$name
[16:04:27.840]                             if (is.null(name)) 
[16:04:27.840]                               next
[16:04:27.840]                             if (!grepl(pattern, name)) 
[16:04:27.840]                               next
[16:04:27.840]                             invokeRestart(restart)
[16:04:27.840]                             muffled <- TRUE
[16:04:27.840]                             break
[16:04:27.840]                           }
[16:04:27.840]                         }
[16:04:27.840]                       }
[16:04:27.840]                       invisible(muffled)
[16:04:27.840]                     }
[16:04:27.840]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.840]                   }
[16:04:27.840]                 }
[16:04:27.840]             }
[16:04:27.840]         }))
[16:04:27.840]     }, error = function(ex) {
[16:04:27.840]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.840]                 ...future.rng), started = ...future.startTime, 
[16:04:27.840]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.840]             version = "1.8"), class = "FutureResult")
[16:04:27.840]     }, finally = {
[16:04:27.840]         if (!identical(...future.workdir, getwd())) 
[16:04:27.840]             setwd(...future.workdir)
[16:04:27.840]         {
[16:04:27.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.840]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.840]             }
[16:04:27.840]             base::options(...future.oldOptions)
[16:04:27.840]             if (.Platform$OS.type == "windows") {
[16:04:27.840]                 old_names <- names(...future.oldEnvVars)
[16:04:27.840]                 envs <- base::Sys.getenv()
[16:04:27.840]                 names <- names(envs)
[16:04:27.840]                 common <- intersect(names, old_names)
[16:04:27.840]                 added <- setdiff(names, old_names)
[16:04:27.840]                 removed <- setdiff(old_names, names)
[16:04:27.840]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.840]                   envs[common]]
[16:04:27.840]                 NAMES <- toupper(changed)
[16:04:27.840]                 args <- list()
[16:04:27.840]                 for (kk in seq_along(NAMES)) {
[16:04:27.840]                   name <- changed[[kk]]
[16:04:27.840]                   NAME <- NAMES[[kk]]
[16:04:27.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.840]                     next
[16:04:27.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.840]                 }
[16:04:27.840]                 NAMES <- toupper(added)
[16:04:27.840]                 for (kk in seq_along(NAMES)) {
[16:04:27.840]                   name <- added[[kk]]
[16:04:27.840]                   NAME <- NAMES[[kk]]
[16:04:27.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.840]                     next
[16:04:27.840]                   args[[name]] <- ""
[16:04:27.840]                 }
[16:04:27.840]                 NAMES <- toupper(removed)
[16:04:27.840]                 for (kk in seq_along(NAMES)) {
[16:04:27.840]                   name <- removed[[kk]]
[16:04:27.840]                   NAME <- NAMES[[kk]]
[16:04:27.840]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.840]                     next
[16:04:27.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.840]                 }
[16:04:27.840]                 if (length(args) > 0) 
[16:04:27.840]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.840]             }
[16:04:27.840]             else {
[16:04:27.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.840]             }
[16:04:27.840]             {
[16:04:27.840]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.840]                   0L) {
[16:04:27.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.840]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.840]                   base::options(opts)
[16:04:27.840]                 }
[16:04:27.840]                 {
[16:04:27.840]                   {
[16:04:27.840]                     NULL
[16:04:27.840]                     RNGkind("Mersenne-Twister")
[16:04:27.840]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:27.840]                       inherits = FALSE)
[16:04:27.840]                   }
[16:04:27.840]                   options(future.plan = NULL)
[16:04:27.840]                   if (is.na(NA_character_)) 
[16:04:27.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.840]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:27.840]                   {
[16:04:27.840]                     future <- SequentialFuture(..., envir = envir)
[16:04:27.840]                     if (!future$lazy) 
[16:04:27.840]                       future <- run(future)
[16:04:27.840]                     invisible(future)
[16:04:27.840]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.840]                 }
[16:04:27.840]             }
[16:04:27.840]         }
[16:04:27.840]     })
[16:04:27.840]     if (TRUE) {
[16:04:27.840]         base::sink(type = "output", split = FALSE)
[16:04:27.840]         if (TRUE) {
[16:04:27.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.840]         }
[16:04:27.840]         else {
[16:04:27.840]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.840]         }
[16:04:27.840]         base::close(...future.stdout)
[16:04:27.840]         ...future.stdout <- NULL
[16:04:27.840]     }
[16:04:27.840]     ...future.result$conditions <- ...future.conditions
[16:04:27.840]     ...future.result$finished <- base::Sys.time()
[16:04:27.840]     ...future.result
[16:04:27.840] }
[16:04:27.841] plan(): Setting new future strategy stack:
[16:04:27.842] List of future strategies:
[16:04:27.842] 1. sequential:
[16:04:27.842]    - args: function (..., envir = parent.frame())
[16:04:27.842]    - tweaked: FALSE
[16:04:27.842]    - call: NULL
[16:04:27.842] plan(): nbrOfWorkers() = 1
[16:04:27.843] plan(): Setting new future strategy stack:
[16:04:27.843] List of future strategies:
[16:04:27.843] 1. sequential:
[16:04:27.843]    - args: function (..., envir = parent.frame())
[16:04:27.843]    - tweaked: FALSE
[16:04:27.843]    - call: plan(strategy)
[16:04:27.843] plan(): nbrOfWorkers() = 1
[16:04:27.843] SequentialFuture started (and completed)
[16:04:27.843] - Launch lazy future ... done
[16:04:27.843] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- plan('sequential') ... DONE
- plan('multicore') ...
[16:04:27.844] plan(): Setting new future strategy stack:
[16:04:27.844] List of future strategies:
[16:04:27.844] 1. multicore:
[16:04:27.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.844]    - tweaked: FALSE
[16:04:27.844]    - call: plan(strategy)
[16:04:27.848] plan(): nbrOfWorkers() = 2
[16:04:27.851] getGlobalsAndPackages() ...
[16:04:27.851] 
[16:04:27.852] - globals: [0] <none>
[16:04:27.852] getGlobalsAndPackages() ... DONE
[16:04:27.853] Packages needed by the future expression (n = 0): <none>
[16:04:27.853] Packages needed by future strategies (n = 0): <none>
[16:04:27.853] {
[16:04:27.853]     {
[16:04:27.853]         {
[16:04:27.853]             ...future.startTime <- base::Sys.time()
[16:04:27.853]             {
[16:04:27.853]                 {
[16:04:27.853]                   {
[16:04:27.853]                     {
[16:04:27.853]                       base::local({
[16:04:27.853]                         has_future <- base::requireNamespace("future", 
[16:04:27.853]                           quietly = TRUE)
[16:04:27.853]                         if (has_future) {
[16:04:27.853]                           ns <- base::getNamespace("future")
[16:04:27.853]                           version <- ns[[".package"]][["version"]]
[16:04:27.853]                           if (is.null(version)) 
[16:04:27.853]                             version <- utils::packageVersion("future")
[16:04:27.853]                         }
[16:04:27.853]                         else {
[16:04:27.853]                           version <- NULL
[16:04:27.853]                         }
[16:04:27.853]                         if (!has_future || version < "1.8.0") {
[16:04:27.853]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.853]                             "", base::R.version$version.string), 
[16:04:27.853]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.853]                               "release", "version")], collapse = " "), 
[16:04:27.853]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.853]                             info)
[16:04:27.853]                           info <- base::paste(info, collapse = "; ")
[16:04:27.853]                           if (!has_future) {
[16:04:27.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.853]                               info)
[16:04:27.853]                           }
[16:04:27.853]                           else {
[16:04:27.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.853]                               info, version)
[16:04:27.853]                           }
[16:04:27.853]                           base::stop(msg)
[16:04:27.853]                         }
[16:04:27.853]                       })
[16:04:27.853]                     }
[16:04:27.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.853]                     base::options(mc.cores = 1L)
[16:04:27.853]                   }
[16:04:27.853]                   options(future.plan = NULL)
[16:04:27.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.853]                 }
[16:04:27.853]                 ...future.workdir <- getwd()
[16:04:27.853]             }
[16:04:27.853]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.853]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.853]         }
[16:04:27.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.853]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.853]             base::names(...future.oldOptions))
[16:04:27.853]     }
[16:04:27.853]     if (FALSE) {
[16:04:27.853]     }
[16:04:27.853]     else {
[16:04:27.853]         if (TRUE) {
[16:04:27.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.853]                 open = "w")
[16:04:27.853]         }
[16:04:27.853]         else {
[16:04:27.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.853]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.853]         }
[16:04:27.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.853]             base::sink(type = "output", split = FALSE)
[16:04:27.853]             base::close(...future.stdout)
[16:04:27.853]         }, add = TRUE)
[16:04:27.853]     }
[16:04:27.853]     ...future.frame <- base::sys.nframe()
[16:04:27.853]     ...future.conditions <- base::list()
[16:04:27.853]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.853]     if (FALSE) {
[16:04:27.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.853]     }
[16:04:27.853]     ...future.result <- base::tryCatch({
[16:04:27.853]         base::withCallingHandlers({
[16:04:27.853]             ...future.value <- base::withVisible(base::local({
[16:04:27.853]                 withCallingHandlers({
[16:04:27.853]                   42
[16:04:27.853]                 }, immediateCondition = function(cond) {
[16:04:27.853]                   save_rds <- function (object, pathname, ...) 
[16:04:27.853]                   {
[16:04:27.853]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.853]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.853]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.853]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.853]                         fi_tmp[["mtime"]])
[16:04:27.853]                     }
[16:04:27.853]                     tryCatch({
[16:04:27.853]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.853]                     }, error = function(ex) {
[16:04:27.853]                       msg <- conditionMessage(ex)
[16:04:27.853]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.853]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.853]                         fi_tmp[["mtime"]], msg)
[16:04:27.853]                       ex$message <- msg
[16:04:27.853]                       stop(ex)
[16:04:27.853]                     })
[16:04:27.853]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.853]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.853]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.853]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.853]                       fi <- file.info(pathname)
[16:04:27.853]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.853]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.853]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.853]                         fi[["size"]], fi[["mtime"]])
[16:04:27.853]                       stop(msg)
[16:04:27.853]                     }
[16:04:27.853]                     invisible(pathname)
[16:04:27.853]                   }
[16:04:27.853]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.853]                     rootPath = tempdir()) 
[16:04:27.853]                   {
[16:04:27.853]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.853]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.853]                       tmpdir = path, fileext = ".rds")
[16:04:27.853]                     save_rds(obj, file)
[16:04:27.853]                   }
[16:04:27.853]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.853]                   {
[16:04:27.853]                     inherits <- base::inherits
[16:04:27.853]                     invokeRestart <- base::invokeRestart
[16:04:27.853]                     is.null <- base::is.null
[16:04:27.853]                     muffled <- FALSE
[16:04:27.853]                     if (inherits(cond, "message")) {
[16:04:27.853]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.853]                       if (muffled) 
[16:04:27.853]                         invokeRestart("muffleMessage")
[16:04:27.853]                     }
[16:04:27.853]                     else if (inherits(cond, "warning")) {
[16:04:27.853]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.853]                       if (muffled) 
[16:04:27.853]                         invokeRestart("muffleWarning")
[16:04:27.853]                     }
[16:04:27.853]                     else if (inherits(cond, "condition")) {
[16:04:27.853]                       if (!is.null(pattern)) {
[16:04:27.853]                         computeRestarts <- base::computeRestarts
[16:04:27.853]                         grepl <- base::grepl
[16:04:27.853]                         restarts <- computeRestarts(cond)
[16:04:27.853]                         for (restart in restarts) {
[16:04:27.853]                           name <- restart$name
[16:04:27.853]                           if (is.null(name)) 
[16:04:27.853]                             next
[16:04:27.853]                           if (!grepl(pattern, name)) 
[16:04:27.853]                             next
[16:04:27.853]                           invokeRestart(restart)
[16:04:27.853]                           muffled <- TRUE
[16:04:27.853]                           break
[16:04:27.853]                         }
[16:04:27.853]                       }
[16:04:27.853]                     }
[16:04:27.853]                     invisible(muffled)
[16:04:27.853]                   }
[16:04:27.853]                   muffleCondition(cond)
[16:04:27.853]                 })
[16:04:27.853]             }))
[16:04:27.853]             future::FutureResult(value = ...future.value$value, 
[16:04:27.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.853]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.853]                     ...future.globalenv.names))
[16:04:27.853]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.853]         }, condition = base::local({
[16:04:27.853]             c <- base::c
[16:04:27.853]             inherits <- base::inherits
[16:04:27.853]             invokeRestart <- base::invokeRestart
[16:04:27.853]             length <- base::length
[16:04:27.853]             list <- base::list
[16:04:27.853]             seq.int <- base::seq.int
[16:04:27.853]             signalCondition <- base::signalCondition
[16:04:27.853]             sys.calls <- base::sys.calls
[16:04:27.853]             `[[` <- base::`[[`
[16:04:27.853]             `+` <- base::`+`
[16:04:27.853]             `<<-` <- base::`<<-`
[16:04:27.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.853]                   3L)]
[16:04:27.853]             }
[16:04:27.853]             function(cond) {
[16:04:27.853]                 is_error <- inherits(cond, "error")
[16:04:27.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.853]                   NULL)
[16:04:27.853]                 if (is_error) {
[16:04:27.853]                   sessionInformation <- function() {
[16:04:27.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.853]                       search = base::search(), system = base::Sys.info())
[16:04:27.853]                   }
[16:04:27.853]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.853]                     cond$call), session = sessionInformation(), 
[16:04:27.853]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.853]                   signalCondition(cond)
[16:04:27.853]                 }
[16:04:27.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.853]                 "immediateCondition"))) {
[16:04:27.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.853]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.853]                   if (TRUE && !signal) {
[16:04:27.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.853]                     {
[16:04:27.853]                       inherits <- base::inherits
[16:04:27.853]                       invokeRestart <- base::invokeRestart
[16:04:27.853]                       is.null <- base::is.null
[16:04:27.853]                       muffled <- FALSE
[16:04:27.853]                       if (inherits(cond, "message")) {
[16:04:27.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.853]                         if (muffled) 
[16:04:27.853]                           invokeRestart("muffleMessage")
[16:04:27.853]                       }
[16:04:27.853]                       else if (inherits(cond, "warning")) {
[16:04:27.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.853]                         if (muffled) 
[16:04:27.853]                           invokeRestart("muffleWarning")
[16:04:27.853]                       }
[16:04:27.853]                       else if (inherits(cond, "condition")) {
[16:04:27.853]                         if (!is.null(pattern)) {
[16:04:27.853]                           computeRestarts <- base::computeRestarts
[16:04:27.853]                           grepl <- base::grepl
[16:04:27.853]                           restarts <- computeRestarts(cond)
[16:04:27.853]                           for (restart in restarts) {
[16:04:27.853]                             name <- restart$name
[16:04:27.853]                             if (is.null(name)) 
[16:04:27.853]                               next
[16:04:27.853]                             if (!grepl(pattern, name)) 
[16:04:27.853]                               next
[16:04:27.853]                             invokeRestart(restart)
[16:04:27.853]                             muffled <- TRUE
[16:04:27.853]                             break
[16:04:27.853]                           }
[16:04:27.853]                         }
[16:04:27.853]                       }
[16:04:27.853]                       invisible(muffled)
[16:04:27.853]                     }
[16:04:27.853]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.853]                   }
[16:04:27.853]                 }
[16:04:27.853]                 else {
[16:04:27.853]                   if (TRUE) {
[16:04:27.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.853]                     {
[16:04:27.853]                       inherits <- base::inherits
[16:04:27.853]                       invokeRestart <- base::invokeRestart
[16:04:27.853]                       is.null <- base::is.null
[16:04:27.853]                       muffled <- FALSE
[16:04:27.853]                       if (inherits(cond, "message")) {
[16:04:27.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.853]                         if (muffled) 
[16:04:27.853]                           invokeRestart("muffleMessage")
[16:04:27.853]                       }
[16:04:27.853]                       else if (inherits(cond, "warning")) {
[16:04:27.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.853]                         if (muffled) 
[16:04:27.853]                           invokeRestart("muffleWarning")
[16:04:27.853]                       }
[16:04:27.853]                       else if (inherits(cond, "condition")) {
[16:04:27.853]                         if (!is.null(pattern)) {
[16:04:27.853]                           computeRestarts <- base::computeRestarts
[16:04:27.853]                           grepl <- base::grepl
[16:04:27.853]                           restarts <- computeRestarts(cond)
[16:04:27.853]                           for (restart in restarts) {
[16:04:27.853]                             name <- restart$name
[16:04:27.853]                             if (is.null(name)) 
[16:04:27.853]                               next
[16:04:27.853]                             if (!grepl(pattern, name)) 
[16:04:27.853]                               next
[16:04:27.853]                             invokeRestart(restart)
[16:04:27.853]                             muffled <- TRUE
[16:04:27.853]                             break
[16:04:27.853]                           }
[16:04:27.853]                         }
[16:04:27.853]                       }
[16:04:27.853]                       invisible(muffled)
[16:04:27.853]                     }
[16:04:27.853]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.853]                   }
[16:04:27.853]                 }
[16:04:27.853]             }
[16:04:27.853]         }))
[16:04:27.853]     }, error = function(ex) {
[16:04:27.853]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.853]                 ...future.rng), started = ...future.startTime, 
[16:04:27.853]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.853]             version = "1.8"), class = "FutureResult")
[16:04:27.853]     }, finally = {
[16:04:27.853]         if (!identical(...future.workdir, getwd())) 
[16:04:27.853]             setwd(...future.workdir)
[16:04:27.853]         {
[16:04:27.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.853]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.853]             }
[16:04:27.853]             base::options(...future.oldOptions)
[16:04:27.853]             if (.Platform$OS.type == "windows") {
[16:04:27.853]                 old_names <- names(...future.oldEnvVars)
[16:04:27.853]                 envs <- base::Sys.getenv()
[16:04:27.853]                 names <- names(envs)
[16:04:27.853]                 common <- intersect(names, old_names)
[16:04:27.853]                 added <- setdiff(names, old_names)
[16:04:27.853]                 removed <- setdiff(old_names, names)
[16:04:27.853]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.853]                   envs[common]]
[16:04:27.853]                 NAMES <- toupper(changed)
[16:04:27.853]                 args <- list()
[16:04:27.853]                 for (kk in seq_along(NAMES)) {
[16:04:27.853]                   name <- changed[[kk]]
[16:04:27.853]                   NAME <- NAMES[[kk]]
[16:04:27.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.853]                     next
[16:04:27.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.853]                 }
[16:04:27.853]                 NAMES <- toupper(added)
[16:04:27.853]                 for (kk in seq_along(NAMES)) {
[16:04:27.853]                   name <- added[[kk]]
[16:04:27.853]                   NAME <- NAMES[[kk]]
[16:04:27.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.853]                     next
[16:04:27.853]                   args[[name]] <- ""
[16:04:27.853]                 }
[16:04:27.853]                 NAMES <- toupper(removed)
[16:04:27.853]                 for (kk in seq_along(NAMES)) {
[16:04:27.853]                   name <- removed[[kk]]
[16:04:27.853]                   NAME <- NAMES[[kk]]
[16:04:27.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.853]                     next
[16:04:27.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.853]                 }
[16:04:27.853]                 if (length(args) > 0) 
[16:04:27.853]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.853]             }
[16:04:27.853]             else {
[16:04:27.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.853]             }
[16:04:27.853]             {
[16:04:27.853]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.853]                   0L) {
[16:04:27.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.853]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.853]                   base::options(opts)
[16:04:27.853]                 }
[16:04:27.853]                 {
[16:04:27.853]                   {
[16:04:27.853]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.853]                     NULL
[16:04:27.853]                   }
[16:04:27.853]                   options(future.plan = NULL)
[16:04:27.853]                   if (is.na(NA_character_)) 
[16:04:27.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.853]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.853]                     envir = parent.frame()) 
[16:04:27.853]                   {
[16:04:27.853]                     default_workers <- missing(workers)
[16:04:27.853]                     if (is.function(workers)) 
[16:04:27.853]                       workers <- workers()
[16:04:27.853]                     workers <- structure(as.integer(workers), 
[16:04:27.853]                       class = class(workers))
[16:04:27.853]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.853]                       1L)
[16:04:27.853]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.853]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.853]                       if (default_workers) 
[16:04:27.853]                         supportsMulticore(warn = TRUE)
[16:04:27.853]                       return(sequential(..., envir = envir))
[16:04:27.853]                     }
[16:04:27.853]                     oopts <- options(mc.cores = workers)
[16:04:27.853]                     on.exit(options(oopts))
[16:04:27.853]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.853]                       envir = envir)
[16:04:27.853]                     if (!future$lazy) 
[16:04:27.853]                       future <- run(future)
[16:04:27.853]                     invisible(future)
[16:04:27.853]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.853]                 }
[16:04:27.853]             }
[16:04:27.853]         }
[16:04:27.853]     })
[16:04:27.853]     if (TRUE) {
[16:04:27.853]         base::sink(type = "output", split = FALSE)
[16:04:27.853]         if (TRUE) {
[16:04:27.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.853]         }
[16:04:27.853]         else {
[16:04:27.853]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.853]         }
[16:04:27.853]         base::close(...future.stdout)
[16:04:27.853]         ...future.stdout <- NULL
[16:04:27.853]     }
[16:04:27.853]     ...future.result$conditions <- ...future.conditions
[16:04:27.853]     ...future.result$finished <- base::Sys.time()
[16:04:27.853]     ...future.result
[16:04:27.853] }
[16:04:27.855] requestCore(): workers = 2
[16:04:27.858] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
[16:04:27.859] plan(): Setting new future strategy stack:
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.859] List of future strategies:
[16:04:27.859] 1. sequential:
[16:04:27.859]    - args: function (..., envir = parent.frame())
[16:04:27.859]    - tweaked: FALSE
[16:04:27.859]    - call: NULL
[16:04:27.860] plan(): nbrOfWorkers() = 1
[16:04:27.862] plan(): Setting new future strategy stack:
[16:04:27.862] List of future strategies:
[16:04:27.862] 1. multicore:
[16:04:27.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.862]    - tweaked: FALSE
[16:04:27.862]    - call: plan(strategy)
[16:04:27.866] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.868] result() for MulticoreFuture ...
[16:04:27.872] result() for MulticoreFuture ...
[16:04:27.872] result() for MulticoreFuture ... done
[16:04:27.872] result() for MulticoreFuture ... done
[16:04:27.873] result() for MulticoreFuture ...
[16:04:27.873] result() for MulticoreFuture ... done
[16:04:27.873] getGlobalsAndPackages() ...
[16:04:27.873] Searching for globals...
[16:04:27.873] 
[16:04:27.873] Searching for globals ... DONE
[16:04:27.874] - globals: [0] <none>
[16:04:27.874] getGlobalsAndPackages() ... DONE
[16:04:27.874] run() for ‘Future’ ...
[16:04:27.874] - state: ‘created’
[16:04:27.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:27.878] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:27.878]   - Field: ‘label’
[16:04:27.878]   - Field: ‘local’
[16:04:27.879]   - Field: ‘owner’
[16:04:27.879]   - Field: ‘envir’
[16:04:27.879]   - Field: ‘workers’
[16:04:27.879]   - Field: ‘packages’
[16:04:27.879]   - Field: ‘gc’
[16:04:27.879]   - Field: ‘job’
[16:04:27.879]   - Field: ‘conditions’
[16:04:27.879]   - Field: ‘expr’
[16:04:27.879]   - Field: ‘uuid’
[16:04:27.880]   - Field: ‘seed’
[16:04:27.880]   - Field: ‘version’
[16:04:27.880]   - Field: ‘result’
[16:04:27.880]   - Field: ‘asynchronous’
[16:04:27.880]   - Field: ‘calls’
[16:04:27.880]   - Field: ‘globals’
[16:04:27.880]   - Field: ‘stdout’
[16:04:27.880]   - Field: ‘earlySignal’
[16:04:27.880]   - Field: ‘lazy’
[16:04:27.881]   - Field: ‘state’
[16:04:27.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:27.883] - Launch lazy future ...
[16:04:27.884] Packages needed by the future expression (n = 0): <none>
[16:04:27.884] Packages needed by future strategies (n = 0): <none>
[16:04:27.884] {
[16:04:27.884]     {
[16:04:27.884]         {
[16:04:27.884]             ...future.startTime <- base::Sys.time()
[16:04:27.884]             {
[16:04:27.884]                 {
[16:04:27.884]                   {
[16:04:27.884]                     {
[16:04:27.884]                       base::local({
[16:04:27.884]                         has_future <- base::requireNamespace("future", 
[16:04:27.884]                           quietly = TRUE)
[16:04:27.884]                         if (has_future) {
[16:04:27.884]                           ns <- base::getNamespace("future")
[16:04:27.884]                           version <- ns[[".package"]][["version"]]
[16:04:27.884]                           if (is.null(version)) 
[16:04:27.884]                             version <- utils::packageVersion("future")
[16:04:27.884]                         }
[16:04:27.884]                         else {
[16:04:27.884]                           version <- NULL
[16:04:27.884]                         }
[16:04:27.884]                         if (!has_future || version < "1.8.0") {
[16:04:27.884]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.884]                             "", base::R.version$version.string), 
[16:04:27.884]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.884]                               "release", "version")], collapse = " "), 
[16:04:27.884]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.884]                             info)
[16:04:27.884]                           info <- base::paste(info, collapse = "; ")
[16:04:27.884]                           if (!has_future) {
[16:04:27.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.884]                               info)
[16:04:27.884]                           }
[16:04:27.884]                           else {
[16:04:27.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.884]                               info, version)
[16:04:27.884]                           }
[16:04:27.884]                           base::stop(msg)
[16:04:27.884]                         }
[16:04:27.884]                       })
[16:04:27.884]                     }
[16:04:27.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.884]                     base::options(mc.cores = 1L)
[16:04:27.884]                   }
[16:04:27.884]                   options(future.plan = NULL)
[16:04:27.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.884]                 }
[16:04:27.884]                 ...future.workdir <- getwd()
[16:04:27.884]             }
[16:04:27.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.884]         }
[16:04:27.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.884]             base::names(...future.oldOptions))
[16:04:27.884]     }
[16:04:27.884]     if (FALSE) {
[16:04:27.884]     }
[16:04:27.884]     else {
[16:04:27.884]         if (TRUE) {
[16:04:27.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.884]                 open = "w")
[16:04:27.884]         }
[16:04:27.884]         else {
[16:04:27.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.884]         }
[16:04:27.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.884]             base::sink(type = "output", split = FALSE)
[16:04:27.884]             base::close(...future.stdout)
[16:04:27.884]         }, add = TRUE)
[16:04:27.884]     }
[16:04:27.884]     ...future.frame <- base::sys.nframe()
[16:04:27.884]     ...future.conditions <- base::list()
[16:04:27.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.884]     if (FALSE) {
[16:04:27.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.884]     }
[16:04:27.884]     ...future.result <- base::tryCatch({
[16:04:27.884]         base::withCallingHandlers({
[16:04:27.884]             ...future.value <- base::withVisible(base::local({
[16:04:27.884]                 withCallingHandlers({
[16:04:27.884]                   42
[16:04:27.884]                 }, immediateCondition = function(cond) {
[16:04:27.884]                   save_rds <- function (object, pathname, ...) 
[16:04:27.884]                   {
[16:04:27.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.884]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.884]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.884]                         fi_tmp[["mtime"]])
[16:04:27.884]                     }
[16:04:27.884]                     tryCatch({
[16:04:27.884]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.884]                     }, error = function(ex) {
[16:04:27.884]                       msg <- conditionMessage(ex)
[16:04:27.884]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.884]                         fi_tmp[["mtime"]], msg)
[16:04:27.884]                       ex$message <- msg
[16:04:27.884]                       stop(ex)
[16:04:27.884]                     })
[16:04:27.884]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.884]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.884]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.884]                       fi <- file.info(pathname)
[16:04:27.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.884]                         fi[["size"]], fi[["mtime"]])
[16:04:27.884]                       stop(msg)
[16:04:27.884]                     }
[16:04:27.884]                     invisible(pathname)
[16:04:27.884]                   }
[16:04:27.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.884]                     rootPath = tempdir()) 
[16:04:27.884]                   {
[16:04:27.884]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.884]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.884]                       tmpdir = path, fileext = ".rds")
[16:04:27.884]                     save_rds(obj, file)
[16:04:27.884]                   }
[16:04:27.884]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.884]                   {
[16:04:27.884]                     inherits <- base::inherits
[16:04:27.884]                     invokeRestart <- base::invokeRestart
[16:04:27.884]                     is.null <- base::is.null
[16:04:27.884]                     muffled <- FALSE
[16:04:27.884]                     if (inherits(cond, "message")) {
[16:04:27.884]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.884]                       if (muffled) 
[16:04:27.884]                         invokeRestart("muffleMessage")
[16:04:27.884]                     }
[16:04:27.884]                     else if (inherits(cond, "warning")) {
[16:04:27.884]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.884]                       if (muffled) 
[16:04:27.884]                         invokeRestart("muffleWarning")
[16:04:27.884]                     }
[16:04:27.884]                     else if (inherits(cond, "condition")) {
[16:04:27.884]                       if (!is.null(pattern)) {
[16:04:27.884]                         computeRestarts <- base::computeRestarts
[16:04:27.884]                         grepl <- base::grepl
[16:04:27.884]                         restarts <- computeRestarts(cond)
[16:04:27.884]                         for (restart in restarts) {
[16:04:27.884]                           name <- restart$name
[16:04:27.884]                           if (is.null(name)) 
[16:04:27.884]                             next
[16:04:27.884]                           if (!grepl(pattern, name)) 
[16:04:27.884]                             next
[16:04:27.884]                           invokeRestart(restart)
[16:04:27.884]                           muffled <- TRUE
[16:04:27.884]                           break
[16:04:27.884]                         }
[16:04:27.884]                       }
[16:04:27.884]                     }
[16:04:27.884]                     invisible(muffled)
[16:04:27.884]                   }
[16:04:27.884]                   muffleCondition(cond)
[16:04:27.884]                 })
[16:04:27.884]             }))
[16:04:27.884]             future::FutureResult(value = ...future.value$value, 
[16:04:27.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.884]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.884]                     ...future.globalenv.names))
[16:04:27.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.884]         }, condition = base::local({
[16:04:27.884]             c <- base::c
[16:04:27.884]             inherits <- base::inherits
[16:04:27.884]             invokeRestart <- base::invokeRestart
[16:04:27.884]             length <- base::length
[16:04:27.884]             list <- base::list
[16:04:27.884]             seq.int <- base::seq.int
[16:04:27.884]             signalCondition <- base::signalCondition
[16:04:27.884]             sys.calls <- base::sys.calls
[16:04:27.884]             `[[` <- base::`[[`
[16:04:27.884]             `+` <- base::`+`
[16:04:27.884]             `<<-` <- base::`<<-`
[16:04:27.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.884]                   3L)]
[16:04:27.884]             }
[16:04:27.884]             function(cond) {
[16:04:27.884]                 is_error <- inherits(cond, "error")
[16:04:27.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.884]                   NULL)
[16:04:27.884]                 if (is_error) {
[16:04:27.884]                   sessionInformation <- function() {
[16:04:27.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.884]                       search = base::search(), system = base::Sys.info())
[16:04:27.884]                   }
[16:04:27.884]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.884]                     cond$call), session = sessionInformation(), 
[16:04:27.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.884]                   signalCondition(cond)
[16:04:27.884]                 }
[16:04:27.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.884]                 "immediateCondition"))) {
[16:04:27.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.884]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.884]                   if (TRUE && !signal) {
[16:04:27.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.884]                     {
[16:04:27.884]                       inherits <- base::inherits
[16:04:27.884]                       invokeRestart <- base::invokeRestart
[16:04:27.884]                       is.null <- base::is.null
[16:04:27.884]                       muffled <- FALSE
[16:04:27.884]                       if (inherits(cond, "message")) {
[16:04:27.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.884]                         if (muffled) 
[16:04:27.884]                           invokeRestart("muffleMessage")
[16:04:27.884]                       }
[16:04:27.884]                       else if (inherits(cond, "warning")) {
[16:04:27.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.884]                         if (muffled) 
[16:04:27.884]                           invokeRestart("muffleWarning")
[16:04:27.884]                       }
[16:04:27.884]                       else if (inherits(cond, "condition")) {
[16:04:27.884]                         if (!is.null(pattern)) {
[16:04:27.884]                           computeRestarts <- base::computeRestarts
[16:04:27.884]                           grepl <- base::grepl
[16:04:27.884]                           restarts <- computeRestarts(cond)
[16:04:27.884]                           for (restart in restarts) {
[16:04:27.884]                             name <- restart$name
[16:04:27.884]                             if (is.null(name)) 
[16:04:27.884]                               next
[16:04:27.884]                             if (!grepl(pattern, name)) 
[16:04:27.884]                               next
[16:04:27.884]                             invokeRestart(restart)
[16:04:27.884]                             muffled <- TRUE
[16:04:27.884]                             break
[16:04:27.884]                           }
[16:04:27.884]                         }
[16:04:27.884]                       }
[16:04:27.884]                       invisible(muffled)
[16:04:27.884]                     }
[16:04:27.884]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.884]                   }
[16:04:27.884]                 }
[16:04:27.884]                 else {
[16:04:27.884]                   if (TRUE) {
[16:04:27.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.884]                     {
[16:04:27.884]                       inherits <- base::inherits
[16:04:27.884]                       invokeRestart <- base::invokeRestart
[16:04:27.884]                       is.null <- base::is.null
[16:04:27.884]                       muffled <- FALSE
[16:04:27.884]                       if (inherits(cond, "message")) {
[16:04:27.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.884]                         if (muffled) 
[16:04:27.884]                           invokeRestart("muffleMessage")
[16:04:27.884]                       }
[16:04:27.884]                       else if (inherits(cond, "warning")) {
[16:04:27.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.884]                         if (muffled) 
[16:04:27.884]                           invokeRestart("muffleWarning")
[16:04:27.884]                       }
[16:04:27.884]                       else if (inherits(cond, "condition")) {
[16:04:27.884]                         if (!is.null(pattern)) {
[16:04:27.884]                           computeRestarts <- base::computeRestarts
[16:04:27.884]                           grepl <- base::grepl
[16:04:27.884]                           restarts <- computeRestarts(cond)
[16:04:27.884]                           for (restart in restarts) {
[16:04:27.884]                             name <- restart$name
[16:04:27.884]                             if (is.null(name)) 
[16:04:27.884]                               next
[16:04:27.884]                             if (!grepl(pattern, name)) 
[16:04:27.884]                               next
[16:04:27.884]                             invokeRestart(restart)
[16:04:27.884]                             muffled <- TRUE
[16:04:27.884]                             break
[16:04:27.884]                           }
[16:04:27.884]                         }
[16:04:27.884]                       }
[16:04:27.884]                       invisible(muffled)
[16:04:27.884]                     }
[16:04:27.884]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.884]                   }
[16:04:27.884]                 }
[16:04:27.884]             }
[16:04:27.884]         }))
[16:04:27.884]     }, error = function(ex) {
[16:04:27.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.884]                 ...future.rng), started = ...future.startTime, 
[16:04:27.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.884]             version = "1.8"), class = "FutureResult")
[16:04:27.884]     }, finally = {
[16:04:27.884]         if (!identical(...future.workdir, getwd())) 
[16:04:27.884]             setwd(...future.workdir)
[16:04:27.884]         {
[16:04:27.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.884]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.884]             }
[16:04:27.884]             base::options(...future.oldOptions)
[16:04:27.884]             if (.Platform$OS.type == "windows") {
[16:04:27.884]                 old_names <- names(...future.oldEnvVars)
[16:04:27.884]                 envs <- base::Sys.getenv()
[16:04:27.884]                 names <- names(envs)
[16:04:27.884]                 common <- intersect(names, old_names)
[16:04:27.884]                 added <- setdiff(names, old_names)
[16:04:27.884]                 removed <- setdiff(old_names, names)
[16:04:27.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.884]                   envs[common]]
[16:04:27.884]                 NAMES <- toupper(changed)
[16:04:27.884]                 args <- list()
[16:04:27.884]                 for (kk in seq_along(NAMES)) {
[16:04:27.884]                   name <- changed[[kk]]
[16:04:27.884]                   NAME <- NAMES[[kk]]
[16:04:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.884]                     next
[16:04:27.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.884]                 }
[16:04:27.884]                 NAMES <- toupper(added)
[16:04:27.884]                 for (kk in seq_along(NAMES)) {
[16:04:27.884]                   name <- added[[kk]]
[16:04:27.884]                   NAME <- NAMES[[kk]]
[16:04:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.884]                     next
[16:04:27.884]                   args[[name]] <- ""
[16:04:27.884]                 }
[16:04:27.884]                 NAMES <- toupper(removed)
[16:04:27.884]                 for (kk in seq_along(NAMES)) {
[16:04:27.884]                   name <- removed[[kk]]
[16:04:27.884]                   NAME <- NAMES[[kk]]
[16:04:27.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.884]                     next
[16:04:27.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.884]                 }
[16:04:27.884]                 if (length(args) > 0) 
[16:04:27.884]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.884]             }
[16:04:27.884]             else {
[16:04:27.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.884]             }
[16:04:27.884]             {
[16:04:27.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.884]                   0L) {
[16:04:27.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.884]                   base::options(opts)
[16:04:27.884]                 }
[16:04:27.884]                 {
[16:04:27.884]                   {
[16:04:27.884]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.884]                     NULL
[16:04:27.884]                   }
[16:04:27.884]                   options(future.plan = NULL)
[16:04:27.884]                   if (is.na(NA_character_)) 
[16:04:27.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.884]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.884]                     envir = parent.frame()) 
[16:04:27.884]                   {
[16:04:27.884]                     default_workers <- missing(workers)
[16:04:27.884]                     if (is.function(workers)) 
[16:04:27.884]                       workers <- workers()
[16:04:27.884]                     workers <- structure(as.integer(workers), 
[16:04:27.884]                       class = class(workers))
[16:04:27.884]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.884]                       1L)
[16:04:27.884]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.884]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.884]                       if (default_workers) 
[16:04:27.884]                         supportsMulticore(warn = TRUE)
[16:04:27.884]                       return(sequential(..., envir = envir))
[16:04:27.884]                     }
[16:04:27.884]                     oopts <- options(mc.cores = workers)
[16:04:27.884]                     on.exit(options(oopts))
[16:04:27.884]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.884]                       envir = envir)
[16:04:27.884]                     if (!future$lazy) 
[16:04:27.884]                       future <- run(future)
[16:04:27.884]                     invisible(future)
[16:04:27.884]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.884]                 }
[16:04:27.884]             }
[16:04:27.884]         }
[16:04:27.884]     })
[16:04:27.884]     if (TRUE) {
[16:04:27.884]         base::sink(type = "output", split = FALSE)
[16:04:27.884]         if (TRUE) {
[16:04:27.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.884]         }
[16:04:27.884]         else {
[16:04:27.884]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.884]         }
[16:04:27.884]         base::close(...future.stdout)
[16:04:27.884]         ...future.stdout <- NULL
[16:04:27.884]     }
[16:04:27.884]     ...future.result$conditions <- ...future.conditions
[16:04:27.884]     ...future.result$finished <- base::Sys.time()
[16:04:27.884]     ...future.result
[16:04:27.884] }
[16:04:27.887] requestCore(): workers = 2
[16:04:27.888] MulticoreFuture started
[16:04:27.889] - Launch lazy future ... done
[16:04:27.889] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
[16:04:27.890] plan(): Setting new future strategy stack:
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.890] List of future strategies:
[16:04:27.890] 1. sequential:
[16:04:27.890]    - args: function (..., envir = parent.frame())
[16:04:27.890]    - tweaked: FALSE
[16:04:27.890]    - call: NULL
[16:04:27.891] plan(): nbrOfWorkers() = 1
[16:04:27.893] plan(): Setting new future strategy stack:
[16:04:27.893] List of future strategies:
[16:04:27.893] 1. multicore:
[16:04:27.893]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.893]    - tweaked: FALSE
[16:04:27.893]    - call: plan(strategy)
[16:04:27.898] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.899] result() for MulticoreFuture ...
[16:04:27.900] result() for MulticoreFuture ...
[16:04:27.900] result() for MulticoreFuture ... done
[16:04:27.900] result() for MulticoreFuture ... done
[16:04:27.900] result() for MulticoreFuture ...
[16:04:27.900] result() for MulticoreFuture ... done
[16:04:27.901] getGlobalsAndPackages() ...
[16:04:27.901] Searching for globals...
[16:04:27.902] - globals found: [1] ‘{’
[16:04:27.902] Searching for globals ... DONE
[16:04:27.902] Resolving globals: FALSE
[16:04:27.902] 
[16:04:27.903] 
[16:04:27.903] getGlobalsAndPackages() ... DONE
[16:04:27.903] run() for ‘Future’ ...
[16:04:27.903] - state: ‘created’
[16:04:27.903] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:27.907] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:27.907]   - Field: ‘label’
[16:04:27.908]   - Field: ‘local’
[16:04:27.908]   - Field: ‘owner’
[16:04:27.908]   - Field: ‘envir’
[16:04:27.908]   - Field: ‘workers’
[16:04:27.908]   - Field: ‘packages’
[16:04:27.908]   - Field: ‘gc’
[16:04:27.908]   - Field: ‘job’
[16:04:27.908]   - Field: ‘conditions’
[16:04:27.909]   - Field: ‘expr’
[16:04:27.909]   - Field: ‘uuid’
[16:04:27.909]   - Field: ‘seed’
[16:04:27.909]   - Field: ‘version’
[16:04:27.909]   - Field: ‘result’
[16:04:27.909]   - Field: ‘asynchronous’
[16:04:27.909]   - Field: ‘calls’
[16:04:27.909]   - Field: ‘globals’
[16:04:27.909]   - Field: ‘stdout’
[16:04:27.910]   - Field: ‘earlySignal’
[16:04:27.910]   - Field: ‘lazy’
[16:04:27.910]   - Field: ‘state’
[16:04:27.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:27.910] - Launch lazy future ...
[16:04:27.910] Packages needed by the future expression (n = 0): <none>
[16:04:27.910] Packages needed by future strategies (n = 0): <none>
[16:04:27.911] {
[16:04:27.911]     {
[16:04:27.911]         {
[16:04:27.911]             ...future.startTime <- base::Sys.time()
[16:04:27.911]             {
[16:04:27.911]                 {
[16:04:27.911]                   {
[16:04:27.911]                     {
[16:04:27.911]                       base::local({
[16:04:27.911]                         has_future <- base::requireNamespace("future", 
[16:04:27.911]                           quietly = TRUE)
[16:04:27.911]                         if (has_future) {
[16:04:27.911]                           ns <- base::getNamespace("future")
[16:04:27.911]                           version <- ns[[".package"]][["version"]]
[16:04:27.911]                           if (is.null(version)) 
[16:04:27.911]                             version <- utils::packageVersion("future")
[16:04:27.911]                         }
[16:04:27.911]                         else {
[16:04:27.911]                           version <- NULL
[16:04:27.911]                         }
[16:04:27.911]                         if (!has_future || version < "1.8.0") {
[16:04:27.911]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.911]                             "", base::R.version$version.string), 
[16:04:27.911]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.911]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.911]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.911]                               "release", "version")], collapse = " "), 
[16:04:27.911]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.911]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.911]                             info)
[16:04:27.911]                           info <- base::paste(info, collapse = "; ")
[16:04:27.911]                           if (!has_future) {
[16:04:27.911]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.911]                               info)
[16:04:27.911]                           }
[16:04:27.911]                           else {
[16:04:27.911]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.911]                               info, version)
[16:04:27.911]                           }
[16:04:27.911]                           base::stop(msg)
[16:04:27.911]                         }
[16:04:27.911]                       })
[16:04:27.911]                     }
[16:04:27.911]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.911]                     base::options(mc.cores = 1L)
[16:04:27.911]                   }
[16:04:27.911]                   options(future.plan = NULL)
[16:04:27.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.911]                 }
[16:04:27.911]                 ...future.workdir <- getwd()
[16:04:27.911]             }
[16:04:27.911]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.911]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.911]         }
[16:04:27.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.911]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.911]             base::names(...future.oldOptions))
[16:04:27.911]     }
[16:04:27.911]     if (FALSE) {
[16:04:27.911]     }
[16:04:27.911]     else {
[16:04:27.911]         if (TRUE) {
[16:04:27.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.911]                 open = "w")
[16:04:27.911]         }
[16:04:27.911]         else {
[16:04:27.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.911]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.911]         }
[16:04:27.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.911]             base::sink(type = "output", split = FALSE)
[16:04:27.911]             base::close(...future.stdout)
[16:04:27.911]         }, add = TRUE)
[16:04:27.911]     }
[16:04:27.911]     ...future.frame <- base::sys.nframe()
[16:04:27.911]     ...future.conditions <- base::list()
[16:04:27.911]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.911]     if (FALSE) {
[16:04:27.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.911]     }
[16:04:27.911]     ...future.result <- base::tryCatch({
[16:04:27.911]         base::withCallingHandlers({
[16:04:27.911]             ...future.value <- base::withVisible(base::local({
[16:04:27.911]                 withCallingHandlers({
[16:04:27.911]                   {
[16:04:27.911]                     42
[16:04:27.911]                   }
[16:04:27.911]                 }, immediateCondition = function(cond) {
[16:04:27.911]                   save_rds <- function (object, pathname, ...) 
[16:04:27.911]                   {
[16:04:27.911]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.911]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.911]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.911]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.911]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.911]                         fi_tmp[["mtime"]])
[16:04:27.911]                     }
[16:04:27.911]                     tryCatch({
[16:04:27.911]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.911]                     }, error = function(ex) {
[16:04:27.911]                       msg <- conditionMessage(ex)
[16:04:27.911]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.911]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.911]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.911]                         fi_tmp[["mtime"]], msg)
[16:04:27.911]                       ex$message <- msg
[16:04:27.911]                       stop(ex)
[16:04:27.911]                     })
[16:04:27.911]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.911]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.911]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.911]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.911]                       fi <- file.info(pathname)
[16:04:27.911]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.911]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.911]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.911]                         fi[["size"]], fi[["mtime"]])
[16:04:27.911]                       stop(msg)
[16:04:27.911]                     }
[16:04:27.911]                     invisible(pathname)
[16:04:27.911]                   }
[16:04:27.911]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.911]                     rootPath = tempdir()) 
[16:04:27.911]                   {
[16:04:27.911]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.911]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.911]                       tmpdir = path, fileext = ".rds")
[16:04:27.911]                     save_rds(obj, file)
[16:04:27.911]                   }
[16:04:27.911]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.911]                   {
[16:04:27.911]                     inherits <- base::inherits
[16:04:27.911]                     invokeRestart <- base::invokeRestart
[16:04:27.911]                     is.null <- base::is.null
[16:04:27.911]                     muffled <- FALSE
[16:04:27.911]                     if (inherits(cond, "message")) {
[16:04:27.911]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.911]                       if (muffled) 
[16:04:27.911]                         invokeRestart("muffleMessage")
[16:04:27.911]                     }
[16:04:27.911]                     else if (inherits(cond, "warning")) {
[16:04:27.911]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.911]                       if (muffled) 
[16:04:27.911]                         invokeRestart("muffleWarning")
[16:04:27.911]                     }
[16:04:27.911]                     else if (inherits(cond, "condition")) {
[16:04:27.911]                       if (!is.null(pattern)) {
[16:04:27.911]                         computeRestarts <- base::computeRestarts
[16:04:27.911]                         grepl <- base::grepl
[16:04:27.911]                         restarts <- computeRestarts(cond)
[16:04:27.911]                         for (restart in restarts) {
[16:04:27.911]                           name <- restart$name
[16:04:27.911]                           if (is.null(name)) 
[16:04:27.911]                             next
[16:04:27.911]                           if (!grepl(pattern, name)) 
[16:04:27.911]                             next
[16:04:27.911]                           invokeRestart(restart)
[16:04:27.911]                           muffled <- TRUE
[16:04:27.911]                           break
[16:04:27.911]                         }
[16:04:27.911]                       }
[16:04:27.911]                     }
[16:04:27.911]                     invisible(muffled)
[16:04:27.911]                   }
[16:04:27.911]                   muffleCondition(cond)
[16:04:27.911]                 })
[16:04:27.911]             }))
[16:04:27.911]             future::FutureResult(value = ...future.value$value, 
[16:04:27.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.911]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.911]                     ...future.globalenv.names))
[16:04:27.911]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.911]         }, condition = base::local({
[16:04:27.911]             c <- base::c
[16:04:27.911]             inherits <- base::inherits
[16:04:27.911]             invokeRestart <- base::invokeRestart
[16:04:27.911]             length <- base::length
[16:04:27.911]             list <- base::list
[16:04:27.911]             seq.int <- base::seq.int
[16:04:27.911]             signalCondition <- base::signalCondition
[16:04:27.911]             sys.calls <- base::sys.calls
[16:04:27.911]             `[[` <- base::`[[`
[16:04:27.911]             `+` <- base::`+`
[16:04:27.911]             `<<-` <- base::`<<-`
[16:04:27.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.911]                   3L)]
[16:04:27.911]             }
[16:04:27.911]             function(cond) {
[16:04:27.911]                 is_error <- inherits(cond, "error")
[16:04:27.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.911]                   NULL)
[16:04:27.911]                 if (is_error) {
[16:04:27.911]                   sessionInformation <- function() {
[16:04:27.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.911]                       search = base::search(), system = base::Sys.info())
[16:04:27.911]                   }
[16:04:27.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.911]                     cond$call), session = sessionInformation(), 
[16:04:27.911]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.911]                   signalCondition(cond)
[16:04:27.911]                 }
[16:04:27.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.911]                 "immediateCondition"))) {
[16:04:27.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.911]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.911]                   if (TRUE && !signal) {
[16:04:27.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.911]                     {
[16:04:27.911]                       inherits <- base::inherits
[16:04:27.911]                       invokeRestart <- base::invokeRestart
[16:04:27.911]                       is.null <- base::is.null
[16:04:27.911]                       muffled <- FALSE
[16:04:27.911]                       if (inherits(cond, "message")) {
[16:04:27.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.911]                         if (muffled) 
[16:04:27.911]                           invokeRestart("muffleMessage")
[16:04:27.911]                       }
[16:04:27.911]                       else if (inherits(cond, "warning")) {
[16:04:27.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.911]                         if (muffled) 
[16:04:27.911]                           invokeRestart("muffleWarning")
[16:04:27.911]                       }
[16:04:27.911]                       else if (inherits(cond, "condition")) {
[16:04:27.911]                         if (!is.null(pattern)) {
[16:04:27.911]                           computeRestarts <- base::computeRestarts
[16:04:27.911]                           grepl <- base::grepl
[16:04:27.911]                           restarts <- computeRestarts(cond)
[16:04:27.911]                           for (restart in restarts) {
[16:04:27.911]                             name <- restart$name
[16:04:27.911]                             if (is.null(name)) 
[16:04:27.911]                               next
[16:04:27.911]                             if (!grepl(pattern, name)) 
[16:04:27.911]                               next
[16:04:27.911]                             invokeRestart(restart)
[16:04:27.911]                             muffled <- TRUE
[16:04:27.911]                             break
[16:04:27.911]                           }
[16:04:27.911]                         }
[16:04:27.911]                       }
[16:04:27.911]                       invisible(muffled)
[16:04:27.911]                     }
[16:04:27.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.911]                   }
[16:04:27.911]                 }
[16:04:27.911]                 else {
[16:04:27.911]                   if (TRUE) {
[16:04:27.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.911]                     {
[16:04:27.911]                       inherits <- base::inherits
[16:04:27.911]                       invokeRestart <- base::invokeRestart
[16:04:27.911]                       is.null <- base::is.null
[16:04:27.911]                       muffled <- FALSE
[16:04:27.911]                       if (inherits(cond, "message")) {
[16:04:27.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.911]                         if (muffled) 
[16:04:27.911]                           invokeRestart("muffleMessage")
[16:04:27.911]                       }
[16:04:27.911]                       else if (inherits(cond, "warning")) {
[16:04:27.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.911]                         if (muffled) 
[16:04:27.911]                           invokeRestart("muffleWarning")
[16:04:27.911]                       }
[16:04:27.911]                       else if (inherits(cond, "condition")) {
[16:04:27.911]                         if (!is.null(pattern)) {
[16:04:27.911]                           computeRestarts <- base::computeRestarts
[16:04:27.911]                           grepl <- base::grepl
[16:04:27.911]                           restarts <- computeRestarts(cond)
[16:04:27.911]                           for (restart in restarts) {
[16:04:27.911]                             name <- restart$name
[16:04:27.911]                             if (is.null(name)) 
[16:04:27.911]                               next
[16:04:27.911]                             if (!grepl(pattern, name)) 
[16:04:27.911]                               next
[16:04:27.911]                             invokeRestart(restart)
[16:04:27.911]                             muffled <- TRUE
[16:04:27.911]                             break
[16:04:27.911]                           }
[16:04:27.911]                         }
[16:04:27.911]                       }
[16:04:27.911]                       invisible(muffled)
[16:04:27.911]                     }
[16:04:27.911]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.911]                   }
[16:04:27.911]                 }
[16:04:27.911]             }
[16:04:27.911]         }))
[16:04:27.911]     }, error = function(ex) {
[16:04:27.911]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.911]                 ...future.rng), started = ...future.startTime, 
[16:04:27.911]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.911]             version = "1.8"), class = "FutureResult")
[16:04:27.911]     }, finally = {
[16:04:27.911]         if (!identical(...future.workdir, getwd())) 
[16:04:27.911]             setwd(...future.workdir)
[16:04:27.911]         {
[16:04:27.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.911]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.911]             }
[16:04:27.911]             base::options(...future.oldOptions)
[16:04:27.911]             if (.Platform$OS.type == "windows") {
[16:04:27.911]                 old_names <- names(...future.oldEnvVars)
[16:04:27.911]                 envs <- base::Sys.getenv()
[16:04:27.911]                 names <- names(envs)
[16:04:27.911]                 common <- intersect(names, old_names)
[16:04:27.911]                 added <- setdiff(names, old_names)
[16:04:27.911]                 removed <- setdiff(old_names, names)
[16:04:27.911]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.911]                   envs[common]]
[16:04:27.911]                 NAMES <- toupper(changed)
[16:04:27.911]                 args <- list()
[16:04:27.911]                 for (kk in seq_along(NAMES)) {
[16:04:27.911]                   name <- changed[[kk]]
[16:04:27.911]                   NAME <- NAMES[[kk]]
[16:04:27.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.911]                     next
[16:04:27.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.911]                 }
[16:04:27.911]                 NAMES <- toupper(added)
[16:04:27.911]                 for (kk in seq_along(NAMES)) {
[16:04:27.911]                   name <- added[[kk]]
[16:04:27.911]                   NAME <- NAMES[[kk]]
[16:04:27.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.911]                     next
[16:04:27.911]                   args[[name]] <- ""
[16:04:27.911]                 }
[16:04:27.911]                 NAMES <- toupper(removed)
[16:04:27.911]                 for (kk in seq_along(NAMES)) {
[16:04:27.911]                   name <- removed[[kk]]
[16:04:27.911]                   NAME <- NAMES[[kk]]
[16:04:27.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.911]                     next
[16:04:27.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.911]                 }
[16:04:27.911]                 if (length(args) > 0) 
[16:04:27.911]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.911]             }
[16:04:27.911]             else {
[16:04:27.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.911]             }
[16:04:27.911]             {
[16:04:27.911]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.911]                   0L) {
[16:04:27.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.911]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.911]                   base::options(opts)
[16:04:27.911]                 }
[16:04:27.911]                 {
[16:04:27.911]                   {
[16:04:27.911]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.911]                     NULL
[16:04:27.911]                   }
[16:04:27.911]                   options(future.plan = NULL)
[16:04:27.911]                   if (is.na(NA_character_)) 
[16:04:27.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.911]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.911]                     envir = parent.frame()) 
[16:04:27.911]                   {
[16:04:27.911]                     default_workers <- missing(workers)
[16:04:27.911]                     if (is.function(workers)) 
[16:04:27.911]                       workers <- workers()
[16:04:27.911]                     workers <- structure(as.integer(workers), 
[16:04:27.911]                       class = class(workers))
[16:04:27.911]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.911]                       1L)
[16:04:27.911]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.911]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.911]                       if (default_workers) 
[16:04:27.911]                         supportsMulticore(warn = TRUE)
[16:04:27.911]                       return(sequential(..., envir = envir))
[16:04:27.911]                     }
[16:04:27.911]                     oopts <- options(mc.cores = workers)
[16:04:27.911]                     on.exit(options(oopts))
[16:04:27.911]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.911]                       envir = envir)
[16:04:27.911]                     if (!future$lazy) 
[16:04:27.911]                       future <- run(future)
[16:04:27.911]                     invisible(future)
[16:04:27.911]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.911]                 }
[16:04:27.911]             }
[16:04:27.911]         }
[16:04:27.911]     })
[16:04:27.911]     if (TRUE) {
[16:04:27.911]         base::sink(type = "output", split = FALSE)
[16:04:27.911]         if (TRUE) {
[16:04:27.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.911]         }
[16:04:27.911]         else {
[16:04:27.911]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.911]         }
[16:04:27.911]         base::close(...future.stdout)
[16:04:27.911]         ...future.stdout <- NULL
[16:04:27.911]     }
[16:04:27.911]     ...future.result$conditions <- ...future.conditions
[16:04:27.911]     ...future.result$finished <- base::Sys.time()
[16:04:27.911]     ...future.result
[16:04:27.911] }
[16:04:27.914] requestCore(): workers = 2
[16:04:27.915] MulticoreFuture started
[16:04:27.916] - Launch lazy future ... done
[16:04:27.916] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
[16:04:27.916] plan(): Setting new future strategy stack:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.917] List of future strategies:
[16:04:27.917] 1. sequential:
[16:04:27.917]    - args: function (..., envir = parent.frame())
[16:04:27.917]    - tweaked: FALSE
[16:04:27.917]    - call: NULL
[16:04:27.917] plan(): nbrOfWorkers() = 1
[16:04:27.919] plan(): Setting new future strategy stack:
[16:04:27.919] List of future strategies:
[16:04:27.919] 1. multicore:
[16:04:27.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.919]    - tweaked: FALSE
[16:04:27.919]    - call: plan(strategy)
[16:04:27.924] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.925] result() for MulticoreFuture ...
[16:04:27.926] result() for MulticoreFuture ...
[16:04:27.926] result() for MulticoreFuture ... done
[16:04:27.926] result() for MulticoreFuture ... done
[16:04:27.926] result() for MulticoreFuture ...
[16:04:27.926] result() for MulticoreFuture ... done
[16:04:27.930] getGlobalsAndPackages() ...
[16:04:27.930] 
[16:04:27.930] - globals: [0] <none>
[16:04:27.930] getGlobalsAndPackages() ... DONE
[16:04:27.931] Packages needed by the future expression (n = 0): <none>
[16:04:27.931] Packages needed by future strategies (n = 0): <none>
[16:04:27.931] {
[16:04:27.931]     {
[16:04:27.931]         {
[16:04:27.931]             ...future.startTime <- base::Sys.time()
[16:04:27.931]             {
[16:04:27.931]                 {
[16:04:27.931]                   {
[16:04:27.931]                     {
[16:04:27.931]                       base::local({
[16:04:27.931]                         has_future <- base::requireNamespace("future", 
[16:04:27.931]                           quietly = TRUE)
[16:04:27.931]                         if (has_future) {
[16:04:27.931]                           ns <- base::getNamespace("future")
[16:04:27.931]                           version <- ns[[".package"]][["version"]]
[16:04:27.931]                           if (is.null(version)) 
[16:04:27.931]                             version <- utils::packageVersion("future")
[16:04:27.931]                         }
[16:04:27.931]                         else {
[16:04:27.931]                           version <- NULL
[16:04:27.931]                         }
[16:04:27.931]                         if (!has_future || version < "1.8.0") {
[16:04:27.931]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.931]                             "", base::R.version$version.string), 
[16:04:27.931]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.931]                               "release", "version")], collapse = " "), 
[16:04:27.931]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.931]                             info)
[16:04:27.931]                           info <- base::paste(info, collapse = "; ")
[16:04:27.931]                           if (!has_future) {
[16:04:27.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.931]                               info)
[16:04:27.931]                           }
[16:04:27.931]                           else {
[16:04:27.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.931]                               info, version)
[16:04:27.931]                           }
[16:04:27.931]                           base::stop(msg)
[16:04:27.931]                         }
[16:04:27.931]                       })
[16:04:27.931]                     }
[16:04:27.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.931]                     base::options(mc.cores = 1L)
[16:04:27.931]                   }
[16:04:27.931]                   options(future.plan = NULL)
[16:04:27.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.931]                 }
[16:04:27.931]                 ...future.workdir <- getwd()
[16:04:27.931]             }
[16:04:27.931]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.931]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.931]         }
[16:04:27.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.931]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.931]             base::names(...future.oldOptions))
[16:04:27.931]     }
[16:04:27.931]     if (FALSE) {
[16:04:27.931]     }
[16:04:27.931]     else {
[16:04:27.931]         if (TRUE) {
[16:04:27.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.931]                 open = "w")
[16:04:27.931]         }
[16:04:27.931]         else {
[16:04:27.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.931]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.931]         }
[16:04:27.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.931]             base::sink(type = "output", split = FALSE)
[16:04:27.931]             base::close(...future.stdout)
[16:04:27.931]         }, add = TRUE)
[16:04:27.931]     }
[16:04:27.931]     ...future.frame <- base::sys.nframe()
[16:04:27.931]     ...future.conditions <- base::list()
[16:04:27.931]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.931]     if (FALSE) {
[16:04:27.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.931]     }
[16:04:27.931]     ...future.result <- base::tryCatch({
[16:04:27.931]         base::withCallingHandlers({
[16:04:27.931]             ...future.value <- base::withVisible(base::local({
[16:04:27.931]                 withCallingHandlers({
[16:04:27.931]                   42
[16:04:27.931]                 }, immediateCondition = function(cond) {
[16:04:27.931]                   save_rds <- function (object, pathname, ...) 
[16:04:27.931]                   {
[16:04:27.931]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.931]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.931]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.931]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.931]                         fi_tmp[["mtime"]])
[16:04:27.931]                     }
[16:04:27.931]                     tryCatch({
[16:04:27.931]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.931]                     }, error = function(ex) {
[16:04:27.931]                       msg <- conditionMessage(ex)
[16:04:27.931]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.931]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.931]                         fi_tmp[["mtime"]], msg)
[16:04:27.931]                       ex$message <- msg
[16:04:27.931]                       stop(ex)
[16:04:27.931]                     })
[16:04:27.931]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.931]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.931]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.931]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.931]                       fi <- file.info(pathname)
[16:04:27.931]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.931]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.931]                         fi[["size"]], fi[["mtime"]])
[16:04:27.931]                       stop(msg)
[16:04:27.931]                     }
[16:04:27.931]                     invisible(pathname)
[16:04:27.931]                   }
[16:04:27.931]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.931]                     rootPath = tempdir()) 
[16:04:27.931]                   {
[16:04:27.931]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.931]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.931]                       tmpdir = path, fileext = ".rds")
[16:04:27.931]                     save_rds(obj, file)
[16:04:27.931]                   }
[16:04:27.931]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.931]                   {
[16:04:27.931]                     inherits <- base::inherits
[16:04:27.931]                     invokeRestart <- base::invokeRestart
[16:04:27.931]                     is.null <- base::is.null
[16:04:27.931]                     muffled <- FALSE
[16:04:27.931]                     if (inherits(cond, "message")) {
[16:04:27.931]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.931]                       if (muffled) 
[16:04:27.931]                         invokeRestart("muffleMessage")
[16:04:27.931]                     }
[16:04:27.931]                     else if (inherits(cond, "warning")) {
[16:04:27.931]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.931]                       if (muffled) 
[16:04:27.931]                         invokeRestart("muffleWarning")
[16:04:27.931]                     }
[16:04:27.931]                     else if (inherits(cond, "condition")) {
[16:04:27.931]                       if (!is.null(pattern)) {
[16:04:27.931]                         computeRestarts <- base::computeRestarts
[16:04:27.931]                         grepl <- base::grepl
[16:04:27.931]                         restarts <- computeRestarts(cond)
[16:04:27.931]                         for (restart in restarts) {
[16:04:27.931]                           name <- restart$name
[16:04:27.931]                           if (is.null(name)) 
[16:04:27.931]                             next
[16:04:27.931]                           if (!grepl(pattern, name)) 
[16:04:27.931]                             next
[16:04:27.931]                           invokeRestart(restart)
[16:04:27.931]                           muffled <- TRUE
[16:04:27.931]                           break
[16:04:27.931]                         }
[16:04:27.931]                       }
[16:04:27.931]                     }
[16:04:27.931]                     invisible(muffled)
[16:04:27.931]                   }
[16:04:27.931]                   muffleCondition(cond)
[16:04:27.931]                 })
[16:04:27.931]             }))
[16:04:27.931]             future::FutureResult(value = ...future.value$value, 
[16:04:27.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.931]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.931]                     ...future.globalenv.names))
[16:04:27.931]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.931]         }, condition = base::local({
[16:04:27.931]             c <- base::c
[16:04:27.931]             inherits <- base::inherits
[16:04:27.931]             invokeRestart <- base::invokeRestart
[16:04:27.931]             length <- base::length
[16:04:27.931]             list <- base::list
[16:04:27.931]             seq.int <- base::seq.int
[16:04:27.931]             signalCondition <- base::signalCondition
[16:04:27.931]             sys.calls <- base::sys.calls
[16:04:27.931]             `[[` <- base::`[[`
[16:04:27.931]             `+` <- base::`+`
[16:04:27.931]             `<<-` <- base::`<<-`
[16:04:27.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.931]                   3L)]
[16:04:27.931]             }
[16:04:27.931]             function(cond) {
[16:04:27.931]                 is_error <- inherits(cond, "error")
[16:04:27.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.931]                   NULL)
[16:04:27.931]                 if (is_error) {
[16:04:27.931]                   sessionInformation <- function() {
[16:04:27.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.931]                       search = base::search(), system = base::Sys.info())
[16:04:27.931]                   }
[16:04:27.931]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.931]                     cond$call), session = sessionInformation(), 
[16:04:27.931]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.931]                   signalCondition(cond)
[16:04:27.931]                 }
[16:04:27.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.931]                 "immediateCondition"))) {
[16:04:27.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.931]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.931]                   if (TRUE && !signal) {
[16:04:27.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.931]                     {
[16:04:27.931]                       inherits <- base::inherits
[16:04:27.931]                       invokeRestart <- base::invokeRestart
[16:04:27.931]                       is.null <- base::is.null
[16:04:27.931]                       muffled <- FALSE
[16:04:27.931]                       if (inherits(cond, "message")) {
[16:04:27.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.931]                         if (muffled) 
[16:04:27.931]                           invokeRestart("muffleMessage")
[16:04:27.931]                       }
[16:04:27.931]                       else if (inherits(cond, "warning")) {
[16:04:27.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.931]                         if (muffled) 
[16:04:27.931]                           invokeRestart("muffleWarning")
[16:04:27.931]                       }
[16:04:27.931]                       else if (inherits(cond, "condition")) {
[16:04:27.931]                         if (!is.null(pattern)) {
[16:04:27.931]                           computeRestarts <- base::computeRestarts
[16:04:27.931]                           grepl <- base::grepl
[16:04:27.931]                           restarts <- computeRestarts(cond)
[16:04:27.931]                           for (restart in restarts) {
[16:04:27.931]                             name <- restart$name
[16:04:27.931]                             if (is.null(name)) 
[16:04:27.931]                               next
[16:04:27.931]                             if (!grepl(pattern, name)) 
[16:04:27.931]                               next
[16:04:27.931]                             invokeRestart(restart)
[16:04:27.931]                             muffled <- TRUE
[16:04:27.931]                             break
[16:04:27.931]                           }
[16:04:27.931]                         }
[16:04:27.931]                       }
[16:04:27.931]                       invisible(muffled)
[16:04:27.931]                     }
[16:04:27.931]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.931]                   }
[16:04:27.931]                 }
[16:04:27.931]                 else {
[16:04:27.931]                   if (TRUE) {
[16:04:27.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.931]                     {
[16:04:27.931]                       inherits <- base::inherits
[16:04:27.931]                       invokeRestart <- base::invokeRestart
[16:04:27.931]                       is.null <- base::is.null
[16:04:27.931]                       muffled <- FALSE
[16:04:27.931]                       if (inherits(cond, "message")) {
[16:04:27.931]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.931]                         if (muffled) 
[16:04:27.931]                           invokeRestart("muffleMessage")
[16:04:27.931]                       }
[16:04:27.931]                       else if (inherits(cond, "warning")) {
[16:04:27.931]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.931]                         if (muffled) 
[16:04:27.931]                           invokeRestart("muffleWarning")
[16:04:27.931]                       }
[16:04:27.931]                       else if (inherits(cond, "condition")) {
[16:04:27.931]                         if (!is.null(pattern)) {
[16:04:27.931]                           computeRestarts <- base::computeRestarts
[16:04:27.931]                           grepl <- base::grepl
[16:04:27.931]                           restarts <- computeRestarts(cond)
[16:04:27.931]                           for (restart in restarts) {
[16:04:27.931]                             name <- restart$name
[16:04:27.931]                             if (is.null(name)) 
[16:04:27.931]                               next
[16:04:27.931]                             if (!grepl(pattern, name)) 
[16:04:27.931]                               next
[16:04:27.931]                             invokeRestart(restart)
[16:04:27.931]                             muffled <- TRUE
[16:04:27.931]                             break
[16:04:27.931]                           }
[16:04:27.931]                         }
[16:04:27.931]                       }
[16:04:27.931]                       invisible(muffled)
[16:04:27.931]                     }
[16:04:27.931]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.931]                   }
[16:04:27.931]                 }
[16:04:27.931]             }
[16:04:27.931]         }))
[16:04:27.931]     }, error = function(ex) {
[16:04:27.931]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.931]                 ...future.rng), started = ...future.startTime, 
[16:04:27.931]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.931]             version = "1.8"), class = "FutureResult")
[16:04:27.931]     }, finally = {
[16:04:27.931]         if (!identical(...future.workdir, getwd())) 
[16:04:27.931]             setwd(...future.workdir)
[16:04:27.931]         {
[16:04:27.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.931]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.931]             }
[16:04:27.931]             base::options(...future.oldOptions)
[16:04:27.931]             if (.Platform$OS.type == "windows") {
[16:04:27.931]                 old_names <- names(...future.oldEnvVars)
[16:04:27.931]                 envs <- base::Sys.getenv()
[16:04:27.931]                 names <- names(envs)
[16:04:27.931]                 common <- intersect(names, old_names)
[16:04:27.931]                 added <- setdiff(names, old_names)
[16:04:27.931]                 removed <- setdiff(old_names, names)
[16:04:27.931]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.931]                   envs[common]]
[16:04:27.931]                 NAMES <- toupper(changed)
[16:04:27.931]                 args <- list()
[16:04:27.931]                 for (kk in seq_along(NAMES)) {
[16:04:27.931]                   name <- changed[[kk]]
[16:04:27.931]                   NAME <- NAMES[[kk]]
[16:04:27.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.931]                     next
[16:04:27.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.931]                 }
[16:04:27.931]                 NAMES <- toupper(added)
[16:04:27.931]                 for (kk in seq_along(NAMES)) {
[16:04:27.931]                   name <- added[[kk]]
[16:04:27.931]                   NAME <- NAMES[[kk]]
[16:04:27.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.931]                     next
[16:04:27.931]                   args[[name]] <- ""
[16:04:27.931]                 }
[16:04:27.931]                 NAMES <- toupper(removed)
[16:04:27.931]                 for (kk in seq_along(NAMES)) {
[16:04:27.931]                   name <- removed[[kk]]
[16:04:27.931]                   NAME <- NAMES[[kk]]
[16:04:27.931]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.931]                     next
[16:04:27.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.931]                 }
[16:04:27.931]                 if (length(args) > 0) 
[16:04:27.931]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.931]             }
[16:04:27.931]             else {
[16:04:27.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.931]             }
[16:04:27.931]             {
[16:04:27.931]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.931]                   0L) {
[16:04:27.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.931]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.931]                   base::options(opts)
[16:04:27.931]                 }
[16:04:27.931]                 {
[16:04:27.931]                   {
[16:04:27.931]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.931]                     NULL
[16:04:27.931]                   }
[16:04:27.931]                   options(future.plan = NULL)
[16:04:27.931]                   if (is.na(NA_character_)) 
[16:04:27.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.931]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.931]                     envir = parent.frame()) 
[16:04:27.931]                   {
[16:04:27.931]                     default_workers <- missing(workers)
[16:04:27.931]                     if (is.function(workers)) 
[16:04:27.931]                       workers <- workers()
[16:04:27.931]                     workers <- structure(as.integer(workers), 
[16:04:27.931]                       class = class(workers))
[16:04:27.931]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.931]                       1L)
[16:04:27.931]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.931]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.931]                       if (default_workers) 
[16:04:27.931]                         supportsMulticore(warn = TRUE)
[16:04:27.931]                       return(sequential(..., envir = envir))
[16:04:27.931]                     }
[16:04:27.931]                     oopts <- options(mc.cores = workers)
[16:04:27.931]                     on.exit(options(oopts))
[16:04:27.931]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.931]                       envir = envir)
[16:04:27.931]                     if (!future$lazy) 
[16:04:27.931]                       future <- run(future)
[16:04:27.931]                     invisible(future)
[16:04:27.931]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.931]                 }
[16:04:27.931]             }
[16:04:27.931]         }
[16:04:27.931]     })
[16:04:27.931]     if (TRUE) {
[16:04:27.931]         base::sink(type = "output", split = FALSE)
[16:04:27.931]         if (TRUE) {
[16:04:27.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.931]         }
[16:04:27.931]         else {
[16:04:27.931]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.931]         }
[16:04:27.931]         base::close(...future.stdout)
[16:04:27.931]         ...future.stdout <- NULL
[16:04:27.931]     }
[16:04:27.931]     ...future.result$conditions <- ...future.conditions
[16:04:27.931]     ...future.result$finished <- base::Sys.time()
[16:04:27.931]     ...future.result
[16:04:27.931] }
[16:04:27.934] requestCore(): workers = 2
[16:04:27.936] MulticoreFuture started
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.937] plan(): Setting new future strategy stack:
[16:04:27.937] List of future strategies:
[16:04:27.937] 1. sequential:
[16:04:27.937]    - args: function (..., envir = parent.frame())
[16:04:27.937]    - tweaked: FALSE
[16:04:27.937]    - call: NULL
[16:04:27.938] plan(): nbrOfWorkers() = 1
[16:04:27.939] plan(): Setting new future strategy stack:
[16:04:27.940] List of future strategies:
[16:04:27.940] 1. multicore:
[16:04:27.940]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.940]    - tweaked: FALSE
[16:04:27.940]    - call: plan(strategy)
[16:04:27.944] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.945] result() for MulticoreFuture ...
[16:04:27.946] result() for MulticoreFuture ...
[16:04:27.946] result() for MulticoreFuture ... done
[16:04:27.946] result() for MulticoreFuture ... done
[16:04:27.946] result() for MulticoreFuture ...
[16:04:27.947] result() for MulticoreFuture ... done
[16:04:27.947] getGlobalsAndPackages() ...
[16:04:27.947] Searching for globals...
[16:04:27.947] 
[16:04:27.948] Searching for globals ... DONE
[16:04:27.948] - globals: [0] <none>
[16:04:27.948] getGlobalsAndPackages() ... DONE
[16:04:27.948] run() for ‘Future’ ...
[16:04:27.948] - state: ‘created’
[16:04:27.948] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:27.952] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:27.953]   - Field: ‘label’
[16:04:27.953]   - Field: ‘local’
[16:04:27.953]   - Field: ‘owner’
[16:04:27.953]   - Field: ‘envir’
[16:04:27.953]   - Field: ‘workers’
[16:04:27.953]   - Field: ‘packages’
[16:04:27.953]   - Field: ‘gc’
[16:04:27.953]   - Field: ‘job’
[16:04:27.953]   - Field: ‘conditions’
[16:04:27.954]   - Field: ‘expr’
[16:04:27.954]   - Field: ‘uuid’
[16:04:27.954]   - Field: ‘seed’
[16:04:27.954]   - Field: ‘version’
[16:04:27.954]   - Field: ‘result’
[16:04:27.954]   - Field: ‘asynchronous’
[16:04:27.954]   - Field: ‘calls’
[16:04:27.954]   - Field: ‘globals’
[16:04:27.954]   - Field: ‘stdout’
[16:04:27.955]   - Field: ‘earlySignal’
[16:04:27.955]   - Field: ‘lazy’
[16:04:27.955]   - Field: ‘state’
[16:04:27.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:27.955] - Launch lazy future ...
[16:04:27.955] Packages needed by the future expression (n = 0): <none>
[16:04:27.956] Packages needed by future strategies (n = 0): <none>
[16:04:27.956] {
[16:04:27.956]     {
[16:04:27.956]         {
[16:04:27.956]             ...future.startTime <- base::Sys.time()
[16:04:27.956]             {
[16:04:27.956]                 {
[16:04:27.956]                   {
[16:04:27.956]                     {
[16:04:27.956]                       base::local({
[16:04:27.956]                         has_future <- base::requireNamespace("future", 
[16:04:27.956]                           quietly = TRUE)
[16:04:27.956]                         if (has_future) {
[16:04:27.956]                           ns <- base::getNamespace("future")
[16:04:27.956]                           version <- ns[[".package"]][["version"]]
[16:04:27.956]                           if (is.null(version)) 
[16:04:27.956]                             version <- utils::packageVersion("future")
[16:04:27.956]                         }
[16:04:27.956]                         else {
[16:04:27.956]                           version <- NULL
[16:04:27.956]                         }
[16:04:27.956]                         if (!has_future || version < "1.8.0") {
[16:04:27.956]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.956]                             "", base::R.version$version.string), 
[16:04:27.956]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.956]                               "release", "version")], collapse = " "), 
[16:04:27.956]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.956]                             info)
[16:04:27.956]                           info <- base::paste(info, collapse = "; ")
[16:04:27.956]                           if (!has_future) {
[16:04:27.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.956]                               info)
[16:04:27.956]                           }
[16:04:27.956]                           else {
[16:04:27.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.956]                               info, version)
[16:04:27.956]                           }
[16:04:27.956]                           base::stop(msg)
[16:04:27.956]                         }
[16:04:27.956]                       })
[16:04:27.956]                     }
[16:04:27.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.956]                     base::options(mc.cores = 1L)
[16:04:27.956]                   }
[16:04:27.956]                   options(future.plan = NULL)
[16:04:27.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.956]                 }
[16:04:27.956]                 ...future.workdir <- getwd()
[16:04:27.956]             }
[16:04:27.956]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.956]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.956]         }
[16:04:27.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.956]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.956]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.956]             base::names(...future.oldOptions))
[16:04:27.956]     }
[16:04:27.956]     if (FALSE) {
[16:04:27.956]     }
[16:04:27.956]     else {
[16:04:27.956]         if (TRUE) {
[16:04:27.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.956]                 open = "w")
[16:04:27.956]         }
[16:04:27.956]         else {
[16:04:27.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.956]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.956]         }
[16:04:27.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.956]             base::sink(type = "output", split = FALSE)
[16:04:27.956]             base::close(...future.stdout)
[16:04:27.956]         }, add = TRUE)
[16:04:27.956]     }
[16:04:27.956]     ...future.frame <- base::sys.nframe()
[16:04:27.956]     ...future.conditions <- base::list()
[16:04:27.956]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.956]     if (FALSE) {
[16:04:27.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.956]     }
[16:04:27.956]     ...future.result <- base::tryCatch({
[16:04:27.956]         base::withCallingHandlers({
[16:04:27.956]             ...future.value <- base::withVisible(base::local({
[16:04:27.956]                 withCallingHandlers({
[16:04:27.956]                   42
[16:04:27.956]                 }, immediateCondition = function(cond) {
[16:04:27.956]                   save_rds <- function (object, pathname, ...) 
[16:04:27.956]                   {
[16:04:27.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.956]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.956]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.956]                         fi_tmp[["mtime"]])
[16:04:27.956]                     }
[16:04:27.956]                     tryCatch({
[16:04:27.956]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.956]                     }, error = function(ex) {
[16:04:27.956]                       msg <- conditionMessage(ex)
[16:04:27.956]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.956]                         fi_tmp[["mtime"]], msg)
[16:04:27.956]                       ex$message <- msg
[16:04:27.956]                       stop(ex)
[16:04:27.956]                     })
[16:04:27.956]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.956]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.956]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.956]                       fi <- file.info(pathname)
[16:04:27.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.956]                         fi[["size"]], fi[["mtime"]])
[16:04:27.956]                       stop(msg)
[16:04:27.956]                     }
[16:04:27.956]                     invisible(pathname)
[16:04:27.956]                   }
[16:04:27.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.956]                     rootPath = tempdir()) 
[16:04:27.956]                   {
[16:04:27.956]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.956]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.956]                       tmpdir = path, fileext = ".rds")
[16:04:27.956]                     save_rds(obj, file)
[16:04:27.956]                   }
[16:04:27.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.956]                   {
[16:04:27.956]                     inherits <- base::inherits
[16:04:27.956]                     invokeRestart <- base::invokeRestart
[16:04:27.956]                     is.null <- base::is.null
[16:04:27.956]                     muffled <- FALSE
[16:04:27.956]                     if (inherits(cond, "message")) {
[16:04:27.956]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.956]                       if (muffled) 
[16:04:27.956]                         invokeRestart("muffleMessage")
[16:04:27.956]                     }
[16:04:27.956]                     else if (inherits(cond, "warning")) {
[16:04:27.956]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.956]                       if (muffled) 
[16:04:27.956]                         invokeRestart("muffleWarning")
[16:04:27.956]                     }
[16:04:27.956]                     else if (inherits(cond, "condition")) {
[16:04:27.956]                       if (!is.null(pattern)) {
[16:04:27.956]                         computeRestarts <- base::computeRestarts
[16:04:27.956]                         grepl <- base::grepl
[16:04:27.956]                         restarts <- computeRestarts(cond)
[16:04:27.956]                         for (restart in restarts) {
[16:04:27.956]                           name <- restart$name
[16:04:27.956]                           if (is.null(name)) 
[16:04:27.956]                             next
[16:04:27.956]                           if (!grepl(pattern, name)) 
[16:04:27.956]                             next
[16:04:27.956]                           invokeRestart(restart)
[16:04:27.956]                           muffled <- TRUE
[16:04:27.956]                           break
[16:04:27.956]                         }
[16:04:27.956]                       }
[16:04:27.956]                     }
[16:04:27.956]                     invisible(muffled)
[16:04:27.956]                   }
[16:04:27.956]                   muffleCondition(cond)
[16:04:27.956]                 })
[16:04:27.956]             }))
[16:04:27.956]             future::FutureResult(value = ...future.value$value, 
[16:04:27.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.956]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.956]                     ...future.globalenv.names))
[16:04:27.956]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.956]         }, condition = base::local({
[16:04:27.956]             c <- base::c
[16:04:27.956]             inherits <- base::inherits
[16:04:27.956]             invokeRestart <- base::invokeRestart
[16:04:27.956]             length <- base::length
[16:04:27.956]             list <- base::list
[16:04:27.956]             seq.int <- base::seq.int
[16:04:27.956]             signalCondition <- base::signalCondition
[16:04:27.956]             sys.calls <- base::sys.calls
[16:04:27.956]             `[[` <- base::`[[`
[16:04:27.956]             `+` <- base::`+`
[16:04:27.956]             `<<-` <- base::`<<-`
[16:04:27.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.956]                   3L)]
[16:04:27.956]             }
[16:04:27.956]             function(cond) {
[16:04:27.956]                 is_error <- inherits(cond, "error")
[16:04:27.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.956]                   NULL)
[16:04:27.956]                 if (is_error) {
[16:04:27.956]                   sessionInformation <- function() {
[16:04:27.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.956]                       search = base::search(), system = base::Sys.info())
[16:04:27.956]                   }
[16:04:27.956]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.956]                     cond$call), session = sessionInformation(), 
[16:04:27.956]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.956]                   signalCondition(cond)
[16:04:27.956]                 }
[16:04:27.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.956]                 "immediateCondition"))) {
[16:04:27.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.956]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.956]                   if (TRUE && !signal) {
[16:04:27.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.956]                     {
[16:04:27.956]                       inherits <- base::inherits
[16:04:27.956]                       invokeRestart <- base::invokeRestart
[16:04:27.956]                       is.null <- base::is.null
[16:04:27.956]                       muffled <- FALSE
[16:04:27.956]                       if (inherits(cond, "message")) {
[16:04:27.956]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.956]                         if (muffled) 
[16:04:27.956]                           invokeRestart("muffleMessage")
[16:04:27.956]                       }
[16:04:27.956]                       else if (inherits(cond, "warning")) {
[16:04:27.956]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.956]                         if (muffled) 
[16:04:27.956]                           invokeRestart("muffleWarning")
[16:04:27.956]                       }
[16:04:27.956]                       else if (inherits(cond, "condition")) {
[16:04:27.956]                         if (!is.null(pattern)) {
[16:04:27.956]                           computeRestarts <- base::computeRestarts
[16:04:27.956]                           grepl <- base::grepl
[16:04:27.956]                           restarts <- computeRestarts(cond)
[16:04:27.956]                           for (restart in restarts) {
[16:04:27.956]                             name <- restart$name
[16:04:27.956]                             if (is.null(name)) 
[16:04:27.956]                               next
[16:04:27.956]                             if (!grepl(pattern, name)) 
[16:04:27.956]                               next
[16:04:27.956]                             invokeRestart(restart)
[16:04:27.956]                             muffled <- TRUE
[16:04:27.956]                             break
[16:04:27.956]                           }
[16:04:27.956]                         }
[16:04:27.956]                       }
[16:04:27.956]                       invisible(muffled)
[16:04:27.956]                     }
[16:04:27.956]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.956]                   }
[16:04:27.956]                 }
[16:04:27.956]                 else {
[16:04:27.956]                   if (TRUE) {
[16:04:27.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.956]                     {
[16:04:27.956]                       inherits <- base::inherits
[16:04:27.956]                       invokeRestart <- base::invokeRestart
[16:04:27.956]                       is.null <- base::is.null
[16:04:27.956]                       muffled <- FALSE
[16:04:27.956]                       if (inherits(cond, "message")) {
[16:04:27.956]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.956]                         if (muffled) 
[16:04:27.956]                           invokeRestart("muffleMessage")
[16:04:27.956]                       }
[16:04:27.956]                       else if (inherits(cond, "warning")) {
[16:04:27.956]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.956]                         if (muffled) 
[16:04:27.956]                           invokeRestart("muffleWarning")
[16:04:27.956]                       }
[16:04:27.956]                       else if (inherits(cond, "condition")) {
[16:04:27.956]                         if (!is.null(pattern)) {
[16:04:27.956]                           computeRestarts <- base::computeRestarts
[16:04:27.956]                           grepl <- base::grepl
[16:04:27.956]                           restarts <- computeRestarts(cond)
[16:04:27.956]                           for (restart in restarts) {
[16:04:27.956]                             name <- restart$name
[16:04:27.956]                             if (is.null(name)) 
[16:04:27.956]                               next
[16:04:27.956]                             if (!grepl(pattern, name)) 
[16:04:27.956]                               next
[16:04:27.956]                             invokeRestart(restart)
[16:04:27.956]                             muffled <- TRUE
[16:04:27.956]                             break
[16:04:27.956]                           }
[16:04:27.956]                         }
[16:04:27.956]                       }
[16:04:27.956]                       invisible(muffled)
[16:04:27.956]                     }
[16:04:27.956]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.956]                   }
[16:04:27.956]                 }
[16:04:27.956]             }
[16:04:27.956]         }))
[16:04:27.956]     }, error = function(ex) {
[16:04:27.956]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.956]                 ...future.rng), started = ...future.startTime, 
[16:04:27.956]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.956]             version = "1.8"), class = "FutureResult")
[16:04:27.956]     }, finally = {
[16:04:27.956]         if (!identical(...future.workdir, getwd())) 
[16:04:27.956]             setwd(...future.workdir)
[16:04:27.956]         {
[16:04:27.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.956]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.956]             }
[16:04:27.956]             base::options(...future.oldOptions)
[16:04:27.956]             if (.Platform$OS.type == "windows") {
[16:04:27.956]                 old_names <- names(...future.oldEnvVars)
[16:04:27.956]                 envs <- base::Sys.getenv()
[16:04:27.956]                 names <- names(envs)
[16:04:27.956]                 common <- intersect(names, old_names)
[16:04:27.956]                 added <- setdiff(names, old_names)
[16:04:27.956]                 removed <- setdiff(old_names, names)
[16:04:27.956]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.956]                   envs[common]]
[16:04:27.956]                 NAMES <- toupper(changed)
[16:04:27.956]                 args <- list()
[16:04:27.956]                 for (kk in seq_along(NAMES)) {
[16:04:27.956]                   name <- changed[[kk]]
[16:04:27.956]                   NAME <- NAMES[[kk]]
[16:04:27.956]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.956]                     next
[16:04:27.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.956]                 }
[16:04:27.956]                 NAMES <- toupper(added)
[16:04:27.956]                 for (kk in seq_along(NAMES)) {
[16:04:27.956]                   name <- added[[kk]]
[16:04:27.956]                   NAME <- NAMES[[kk]]
[16:04:27.956]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.956]                     next
[16:04:27.956]                   args[[name]] <- ""
[16:04:27.956]                 }
[16:04:27.956]                 NAMES <- toupper(removed)
[16:04:27.956]                 for (kk in seq_along(NAMES)) {
[16:04:27.956]                   name <- removed[[kk]]
[16:04:27.956]                   NAME <- NAMES[[kk]]
[16:04:27.956]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.956]                     next
[16:04:27.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.956]                 }
[16:04:27.956]                 if (length(args) > 0) 
[16:04:27.956]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.956]             }
[16:04:27.956]             else {
[16:04:27.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.956]             }
[16:04:27.956]             {
[16:04:27.956]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.956]                   0L) {
[16:04:27.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.956]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.956]                   base::options(opts)
[16:04:27.956]                 }
[16:04:27.956]                 {
[16:04:27.956]                   {
[16:04:27.956]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.956]                     NULL
[16:04:27.956]                   }
[16:04:27.956]                   options(future.plan = NULL)
[16:04:27.956]                   if (is.na(NA_character_)) 
[16:04:27.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.956]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.956]                     envir = parent.frame()) 
[16:04:27.956]                   {
[16:04:27.956]                     default_workers <- missing(workers)
[16:04:27.956]                     if (is.function(workers)) 
[16:04:27.956]                       workers <- workers()
[16:04:27.956]                     workers <- structure(as.integer(workers), 
[16:04:27.956]                       class = class(workers))
[16:04:27.956]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.956]                       1L)
[16:04:27.956]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.956]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.956]                       if (default_workers) 
[16:04:27.956]                         supportsMulticore(warn = TRUE)
[16:04:27.956]                       return(sequential(..., envir = envir))
[16:04:27.956]                     }
[16:04:27.956]                     oopts <- options(mc.cores = workers)
[16:04:27.956]                     on.exit(options(oopts))
[16:04:27.956]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.956]                       envir = envir)
[16:04:27.956]                     if (!future$lazy) 
[16:04:27.956]                       future <- run(future)
[16:04:27.956]                     invisible(future)
[16:04:27.956]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.956]                 }
[16:04:27.956]             }
[16:04:27.956]         }
[16:04:27.956]     })
[16:04:27.956]     if (TRUE) {
[16:04:27.956]         base::sink(type = "output", split = FALSE)
[16:04:27.956]         if (TRUE) {
[16:04:27.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.956]         }
[16:04:27.956]         else {
[16:04:27.956]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.956]         }
[16:04:27.956]         base::close(...future.stdout)
[16:04:27.956]         ...future.stdout <- NULL
[16:04:27.956]     }
[16:04:27.956]     ...future.result$conditions <- ...future.conditions
[16:04:27.956]     ...future.result$finished <- base::Sys.time()
[16:04:27.956]     ...future.result
[16:04:27.956] }
[16:04:27.959] requestCore(): workers = 2
[16:04:27.960] MulticoreFuture started
[16:04:27.961] - Launch lazy future ... done
[16:04:27.961] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:04:27.961] plan(): Setting new future strategy stack:
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.962] List of future strategies:
[16:04:27.962] 1. sequential:
[16:04:27.962]    - args: function (..., envir = parent.frame())
[16:04:27.962]    - tweaked: FALSE
[16:04:27.962]    - call: NULL
[16:04:27.962] plan(): nbrOfWorkers() = 1
[16:04:27.964] plan(): Setting new future strategy stack:
[16:04:27.964] List of future strategies:
[16:04:27.964] 1. multicore:
[16:04:27.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.964]    - tweaked: FALSE
[16:04:27.964]    - call: plan(strategy)
[16:04:27.969] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.970] result() for MulticoreFuture ...
[16:04:27.971] result() for MulticoreFuture ...
[16:04:27.971] result() for MulticoreFuture ... done
[16:04:27.971] result() for MulticoreFuture ... done
[16:04:27.971] result() for MulticoreFuture ...
[16:04:27.971] result() for MulticoreFuture ... done
[16:04:27.972] getGlobalsAndPackages() ...
[16:04:27.972] Searching for globals...
[16:04:27.973] - globals found: [1] ‘{’
[16:04:27.973] Searching for globals ... DONE
[16:04:27.973] Resolving globals: FALSE
[16:04:27.973] 
[16:04:27.973] 
[16:04:27.973] getGlobalsAndPackages() ... DONE
[16:04:27.974] run() for ‘Future’ ...
[16:04:27.974] - state: ‘created’
[16:04:27.974] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:27.980] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.981] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:27.981]   - Field: ‘label’
[16:04:27.981]   - Field: ‘local’
[16:04:27.981]   - Field: ‘owner’
[16:04:27.981]   - Field: ‘envir’
[16:04:27.981]   - Field: ‘workers’
[16:04:27.981]   - Field: ‘packages’
[16:04:27.982]   - Field: ‘gc’
[16:04:27.982]   - Field: ‘job’
[16:04:27.982]   - Field: ‘conditions’
[16:04:27.982]   - Field: ‘expr’
[16:04:27.982]   - Field: ‘uuid’
[16:04:27.982]   - Field: ‘seed’
[16:04:27.982]   - Field: ‘version’
[16:04:27.983]   - Field: ‘result’
[16:04:27.983]   - Field: ‘asynchronous’
[16:04:27.983]   - Field: ‘calls’
[16:04:27.983]   - Field: ‘globals’
[16:04:27.983]   - Field: ‘stdout’
[16:04:27.983]   - Field: ‘earlySignal’
[16:04:27.983]   - Field: ‘lazy’
[16:04:27.983]   - Field: ‘state’
[16:04:27.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:27.984] - Launch lazy future ...
[16:04:27.984] Packages needed by the future expression (n = 0): <none>
[16:04:27.984] Packages needed by future strategies (n = 0): <none>
[16:04:27.985] {
[16:04:27.985]     {
[16:04:27.985]         {
[16:04:27.985]             ...future.startTime <- base::Sys.time()
[16:04:27.985]             {
[16:04:27.985]                 {
[16:04:27.985]                   {
[16:04:27.985]                     {
[16:04:27.985]                       base::local({
[16:04:27.985]                         has_future <- base::requireNamespace("future", 
[16:04:27.985]                           quietly = TRUE)
[16:04:27.985]                         if (has_future) {
[16:04:27.985]                           ns <- base::getNamespace("future")
[16:04:27.985]                           version <- ns[[".package"]][["version"]]
[16:04:27.985]                           if (is.null(version)) 
[16:04:27.985]                             version <- utils::packageVersion("future")
[16:04:27.985]                         }
[16:04:27.985]                         else {
[16:04:27.985]                           version <- NULL
[16:04:27.985]                         }
[16:04:27.985]                         if (!has_future || version < "1.8.0") {
[16:04:27.985]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:27.985]                             "", base::R.version$version.string), 
[16:04:27.985]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:27.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:27.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:27.985]                               "release", "version")], collapse = " "), 
[16:04:27.985]                             hostname = base::Sys.info()[["nodename"]])
[16:04:27.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:27.985]                             info)
[16:04:27.985]                           info <- base::paste(info, collapse = "; ")
[16:04:27.985]                           if (!has_future) {
[16:04:27.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:27.985]                               info)
[16:04:27.985]                           }
[16:04:27.985]                           else {
[16:04:27.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:27.985]                               info, version)
[16:04:27.985]                           }
[16:04:27.985]                           base::stop(msg)
[16:04:27.985]                         }
[16:04:27.985]                       })
[16:04:27.985]                     }
[16:04:27.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:27.985]                     base::options(mc.cores = 1L)
[16:04:27.985]                   }
[16:04:27.985]                   options(future.plan = NULL)
[16:04:27.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:27.985]                 }
[16:04:27.985]                 ...future.workdir <- getwd()
[16:04:27.985]             }
[16:04:27.985]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:27.985]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:27.985]         }
[16:04:27.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:27.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:27.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:27.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:27.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:27.985]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:27.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:27.985]             base::names(...future.oldOptions))
[16:04:27.985]     }
[16:04:27.985]     if (FALSE) {
[16:04:27.985]     }
[16:04:27.985]     else {
[16:04:27.985]         if (TRUE) {
[16:04:27.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:27.985]                 open = "w")
[16:04:27.985]         }
[16:04:27.985]         else {
[16:04:27.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:27.985]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:27.985]         }
[16:04:27.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:27.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:27.985]             base::sink(type = "output", split = FALSE)
[16:04:27.985]             base::close(...future.stdout)
[16:04:27.985]         }, add = TRUE)
[16:04:27.985]     }
[16:04:27.985]     ...future.frame <- base::sys.nframe()
[16:04:27.985]     ...future.conditions <- base::list()
[16:04:27.985]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:27.985]     if (FALSE) {
[16:04:27.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:27.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:27.985]     }
[16:04:27.985]     ...future.result <- base::tryCatch({
[16:04:27.985]         base::withCallingHandlers({
[16:04:27.985]             ...future.value <- base::withVisible(base::local({
[16:04:27.985]                 withCallingHandlers({
[16:04:27.985]                   {
[16:04:27.985]                     42
[16:04:27.985]                   }
[16:04:27.985]                 }, immediateCondition = function(cond) {
[16:04:27.985]                   save_rds <- function (object, pathname, ...) 
[16:04:27.985]                   {
[16:04:27.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:27.985]                     if (file_test("-f", pathname_tmp)) {
[16:04:27.985]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:27.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.985]                         fi_tmp[["mtime"]])
[16:04:27.985]                     }
[16:04:27.985]                     tryCatch({
[16:04:27.985]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:27.985]                     }, error = function(ex) {
[16:04:27.985]                       msg <- conditionMessage(ex)
[16:04:27.985]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:27.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.985]                         fi_tmp[["mtime"]], msg)
[16:04:27.985]                       ex$message <- msg
[16:04:27.985]                       stop(ex)
[16:04:27.985]                     })
[16:04:27.985]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:27.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:27.985]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:27.985]                       fi_tmp <- file.info(pathname_tmp)
[16:04:27.985]                       fi <- file.info(pathname)
[16:04:27.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:27.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:27.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:27.985]                         fi[["size"]], fi[["mtime"]])
[16:04:27.985]                       stop(msg)
[16:04:27.985]                     }
[16:04:27.985]                     invisible(pathname)
[16:04:27.985]                   }
[16:04:27.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:27.985]                     rootPath = tempdir()) 
[16:04:27.985]                   {
[16:04:27.985]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:27.985]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:27.985]                       tmpdir = path, fileext = ".rds")
[16:04:27.985]                     save_rds(obj, file)
[16:04:27.985]                   }
[16:04:27.985]                   saveImmediateCondition(cond, path = "/tmp/RtmpcyOEZt/.future/immediateConditions")
[16:04:27.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.985]                   {
[16:04:27.985]                     inherits <- base::inherits
[16:04:27.985]                     invokeRestart <- base::invokeRestart
[16:04:27.985]                     is.null <- base::is.null
[16:04:27.985]                     muffled <- FALSE
[16:04:27.985]                     if (inherits(cond, "message")) {
[16:04:27.985]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:27.985]                       if (muffled) 
[16:04:27.985]                         invokeRestart("muffleMessage")
[16:04:27.985]                     }
[16:04:27.985]                     else if (inherits(cond, "warning")) {
[16:04:27.985]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:27.985]                       if (muffled) 
[16:04:27.985]                         invokeRestart("muffleWarning")
[16:04:27.985]                     }
[16:04:27.985]                     else if (inherits(cond, "condition")) {
[16:04:27.985]                       if (!is.null(pattern)) {
[16:04:27.985]                         computeRestarts <- base::computeRestarts
[16:04:27.985]                         grepl <- base::grepl
[16:04:27.985]                         restarts <- computeRestarts(cond)
[16:04:27.985]                         for (restart in restarts) {
[16:04:27.985]                           name <- restart$name
[16:04:27.985]                           if (is.null(name)) 
[16:04:27.985]                             next
[16:04:27.985]                           if (!grepl(pattern, name)) 
[16:04:27.985]                             next
[16:04:27.985]                           invokeRestart(restart)
[16:04:27.985]                           muffled <- TRUE
[16:04:27.985]                           break
[16:04:27.985]                         }
[16:04:27.985]                       }
[16:04:27.985]                     }
[16:04:27.985]                     invisible(muffled)
[16:04:27.985]                   }
[16:04:27.985]                   muffleCondition(cond)
[16:04:27.985]                 })
[16:04:27.985]             }))
[16:04:27.985]             future::FutureResult(value = ...future.value$value, 
[16:04:27.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.985]                   ...future.rng), globalenv = if (FALSE) 
[16:04:27.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:27.985]                     ...future.globalenv.names))
[16:04:27.985]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:27.985]         }, condition = base::local({
[16:04:27.985]             c <- base::c
[16:04:27.985]             inherits <- base::inherits
[16:04:27.985]             invokeRestart <- base::invokeRestart
[16:04:27.985]             length <- base::length
[16:04:27.985]             list <- base::list
[16:04:27.985]             seq.int <- base::seq.int
[16:04:27.985]             signalCondition <- base::signalCondition
[16:04:27.985]             sys.calls <- base::sys.calls
[16:04:27.985]             `[[` <- base::`[[`
[16:04:27.985]             `+` <- base::`+`
[16:04:27.985]             `<<-` <- base::`<<-`
[16:04:27.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:27.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:27.985]                   3L)]
[16:04:27.985]             }
[16:04:27.985]             function(cond) {
[16:04:27.985]                 is_error <- inherits(cond, "error")
[16:04:27.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:27.985]                   NULL)
[16:04:27.985]                 if (is_error) {
[16:04:27.985]                   sessionInformation <- function() {
[16:04:27.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:27.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:27.985]                       search = base::search(), system = base::Sys.info())
[16:04:27.985]                   }
[16:04:27.985]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:27.985]                     cond$call), session = sessionInformation(), 
[16:04:27.985]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:27.985]                   signalCondition(cond)
[16:04:27.985]                 }
[16:04:27.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:27.985]                 "immediateCondition"))) {
[16:04:27.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:27.985]                   ...future.conditions[[length(...future.conditions) + 
[16:04:27.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:27.985]                   if (TRUE && !signal) {
[16:04:27.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.985]                     {
[16:04:27.985]                       inherits <- base::inherits
[16:04:27.985]                       invokeRestart <- base::invokeRestart
[16:04:27.985]                       is.null <- base::is.null
[16:04:27.985]                       muffled <- FALSE
[16:04:27.985]                       if (inherits(cond, "message")) {
[16:04:27.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.985]                         if (muffled) 
[16:04:27.985]                           invokeRestart("muffleMessage")
[16:04:27.985]                       }
[16:04:27.985]                       else if (inherits(cond, "warning")) {
[16:04:27.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.985]                         if (muffled) 
[16:04:27.985]                           invokeRestart("muffleWarning")
[16:04:27.985]                       }
[16:04:27.985]                       else if (inherits(cond, "condition")) {
[16:04:27.985]                         if (!is.null(pattern)) {
[16:04:27.985]                           computeRestarts <- base::computeRestarts
[16:04:27.985]                           grepl <- base::grepl
[16:04:27.985]                           restarts <- computeRestarts(cond)
[16:04:27.985]                           for (restart in restarts) {
[16:04:27.985]                             name <- restart$name
[16:04:27.985]                             if (is.null(name)) 
[16:04:27.985]                               next
[16:04:27.985]                             if (!grepl(pattern, name)) 
[16:04:27.985]                               next
[16:04:27.985]                             invokeRestart(restart)
[16:04:27.985]                             muffled <- TRUE
[16:04:27.985]                             break
[16:04:27.985]                           }
[16:04:27.985]                         }
[16:04:27.985]                       }
[16:04:27.985]                       invisible(muffled)
[16:04:27.985]                     }
[16:04:27.985]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.985]                   }
[16:04:27.985]                 }
[16:04:27.985]                 else {
[16:04:27.985]                   if (TRUE) {
[16:04:27.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:27.985]                     {
[16:04:27.985]                       inherits <- base::inherits
[16:04:27.985]                       invokeRestart <- base::invokeRestart
[16:04:27.985]                       is.null <- base::is.null
[16:04:27.985]                       muffled <- FALSE
[16:04:27.985]                       if (inherits(cond, "message")) {
[16:04:27.985]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:27.985]                         if (muffled) 
[16:04:27.985]                           invokeRestart("muffleMessage")
[16:04:27.985]                       }
[16:04:27.985]                       else if (inherits(cond, "warning")) {
[16:04:27.985]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:27.985]                         if (muffled) 
[16:04:27.985]                           invokeRestart("muffleWarning")
[16:04:27.985]                       }
[16:04:27.985]                       else if (inherits(cond, "condition")) {
[16:04:27.985]                         if (!is.null(pattern)) {
[16:04:27.985]                           computeRestarts <- base::computeRestarts
[16:04:27.985]                           grepl <- base::grepl
[16:04:27.985]                           restarts <- computeRestarts(cond)
[16:04:27.985]                           for (restart in restarts) {
[16:04:27.985]                             name <- restart$name
[16:04:27.985]                             if (is.null(name)) 
[16:04:27.985]                               next
[16:04:27.985]                             if (!grepl(pattern, name)) 
[16:04:27.985]                               next
[16:04:27.985]                             invokeRestart(restart)
[16:04:27.985]                             muffled <- TRUE
[16:04:27.985]                             break
[16:04:27.985]                           }
[16:04:27.985]                         }
[16:04:27.985]                       }
[16:04:27.985]                       invisible(muffled)
[16:04:27.985]                     }
[16:04:27.985]                     muffleCondition(cond, pattern = "^muffle")
[16:04:27.985]                   }
[16:04:27.985]                 }
[16:04:27.985]             }
[16:04:27.985]         }))
[16:04:27.985]     }, error = function(ex) {
[16:04:27.985]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:27.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:27.985]                 ...future.rng), started = ...future.startTime, 
[16:04:27.985]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:27.985]             version = "1.8"), class = "FutureResult")
[16:04:27.985]     }, finally = {
[16:04:27.985]         if (!identical(...future.workdir, getwd())) 
[16:04:27.985]             setwd(...future.workdir)
[16:04:27.985]         {
[16:04:27.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:27.985]                 ...future.oldOptions$nwarnings <- NULL
[16:04:27.985]             }
[16:04:27.985]             base::options(...future.oldOptions)
[16:04:27.985]             if (.Platform$OS.type == "windows") {
[16:04:27.985]                 old_names <- names(...future.oldEnvVars)
[16:04:27.985]                 envs <- base::Sys.getenv()
[16:04:27.985]                 names <- names(envs)
[16:04:27.985]                 common <- intersect(names, old_names)
[16:04:27.985]                 added <- setdiff(names, old_names)
[16:04:27.985]                 removed <- setdiff(old_names, names)
[16:04:27.985]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:27.985]                   envs[common]]
[16:04:27.985]                 NAMES <- toupper(changed)
[16:04:27.985]                 args <- list()
[16:04:27.985]                 for (kk in seq_along(NAMES)) {
[16:04:27.985]                   name <- changed[[kk]]
[16:04:27.985]                   NAME <- NAMES[[kk]]
[16:04:27.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.985]                     next
[16:04:27.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.985]                 }
[16:04:27.985]                 NAMES <- toupper(added)
[16:04:27.985]                 for (kk in seq_along(NAMES)) {
[16:04:27.985]                   name <- added[[kk]]
[16:04:27.985]                   NAME <- NAMES[[kk]]
[16:04:27.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.985]                     next
[16:04:27.985]                   args[[name]] <- ""
[16:04:27.985]                 }
[16:04:27.985]                 NAMES <- toupper(removed)
[16:04:27.985]                 for (kk in seq_along(NAMES)) {
[16:04:27.985]                   name <- removed[[kk]]
[16:04:27.985]                   NAME <- NAMES[[kk]]
[16:04:27.985]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:27.985]                     next
[16:04:27.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:27.985]                 }
[16:04:27.985]                 if (length(args) > 0) 
[16:04:27.985]                   base::do.call(base::Sys.setenv, args = args)
[16:04:27.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:27.985]             }
[16:04:27.985]             else {
[16:04:27.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:27.985]             }
[16:04:27.985]             {
[16:04:27.985]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:27.985]                   0L) {
[16:04:27.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:27.985]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:27.985]                   base::options(opts)
[16:04:27.985]                 }
[16:04:27.985]                 {
[16:04:27.985]                   {
[16:04:27.985]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:27.985]                     NULL
[16:04:27.985]                   }
[16:04:27.985]                   options(future.plan = NULL)
[16:04:27.985]                   if (is.na(NA_character_)) 
[16:04:27.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:27.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:27.985]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:27.985]                     envir = parent.frame()) 
[16:04:27.985]                   {
[16:04:27.985]                     default_workers <- missing(workers)
[16:04:27.985]                     if (is.function(workers)) 
[16:04:27.985]                       workers <- workers()
[16:04:27.985]                     workers <- structure(as.integer(workers), 
[16:04:27.985]                       class = class(workers))
[16:04:27.985]                     stop_if_not(is.finite(workers), workers >= 
[16:04:27.985]                       1L)
[16:04:27.985]                     if ((workers == 1L && !inherits(workers, 
[16:04:27.985]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:27.985]                       if (default_workers) 
[16:04:27.985]                         supportsMulticore(warn = TRUE)
[16:04:27.985]                       return(sequential(..., envir = envir))
[16:04:27.985]                     }
[16:04:27.985]                     oopts <- options(mc.cores = workers)
[16:04:27.985]                     on.exit(options(oopts))
[16:04:27.985]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:27.985]                       envir = envir)
[16:04:27.985]                     if (!future$lazy) 
[16:04:27.985]                       future <- run(future)
[16:04:27.985]                     invisible(future)
[16:04:27.985]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:27.985]                 }
[16:04:27.985]             }
[16:04:27.985]         }
[16:04:27.985]     })
[16:04:27.985]     if (TRUE) {
[16:04:27.985]         base::sink(type = "output", split = FALSE)
[16:04:27.985]         if (TRUE) {
[16:04:27.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:27.985]         }
[16:04:27.985]         else {
[16:04:27.985]             ...future.result["stdout"] <- base::list(NULL)
[16:04:27.985]         }
[16:04:27.985]         base::close(...future.stdout)
[16:04:27.985]         ...future.stdout <- NULL
[16:04:27.985]     }
[16:04:27.985]     ...future.result$conditions <- ...future.conditions
[16:04:27.985]     ...future.result$finished <- base::Sys.time()
[16:04:27.985]     ...future.result
[16:04:27.985] }
[16:04:27.987] requestCore(): workers = 2
[16:04:27.989] MulticoreFuture started
[16:04:27.989] - Launch lazy future ... done
[16:04:27.989] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
[16:04:27.990] plan(): Setting new future strategy stack:
Label: ‘strategy = multicore’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:04:27.990] List of future strategies:
[16:04:27.990] 1. sequential:
[16:04:27.990]    - args: function (..., envir = parent.frame())
[16:04:27.990]    - tweaked: FALSE
[16:04:27.990]    - call: NULL
[16:04:27.991] plan(): nbrOfWorkers() = 1
[16:04:27.993] plan(): Setting new future strategy stack:
[16:04:27.993] List of future strategies:
[16:04:27.993] 1. multicore:
[16:04:27.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:27.993]    - tweaked: FALSE
[16:04:27.993]    - call: plan(strategy)
[16:04:27.998] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:27.999] result() for MulticoreFuture ...
[16:04:28.000] result() for MulticoreFuture ...
[16:04:28.000] result() for MulticoreFuture ... done
[16:04:28.000] result() for MulticoreFuture ... done
[16:04:28.000] result() for MulticoreFuture ...
[16:04:28.000] result() for MulticoreFuture ... done
- plan('multicore') ... DONE
- plan('multisession') ...
[16:04:28.001] plan(): Setting new future strategy stack:
[16:04:28.001] List of future strategies:
[16:04:28.001] 1. multisession:
[16:04:28.001]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:28.001]    - tweaked: FALSE
[16:04:28.001]    - call: plan(strategy)
[16:04:28.001] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:28.002] multisession:
[16:04:28.002] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:28.002] - tweaked: FALSE
[16:04:28.002] - call: plan(strategy)
[16:04:28.008] getGlobalsAndPackages() ...
[16:04:28.008] Not searching for globals
[16:04:28.008] - globals: [0] <none>
[16:04:28.009] getGlobalsAndPackages() ... DONE
[16:04:28.009] [local output] makeClusterPSOCK() ...
[16:04:28.047] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:28.048] [local output] Base port: 11095
[16:04:28.048] [local output] Getting setup options for 2 cluster nodes ...
[16:04:28.049] [local output]  - Node 1 of 2 ...
[16:04:28.049] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:28.050] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcyOEZt/worker.rank=1.parallelly.parent=81822.13f9e3d4f3a07.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpcyOEZt/worker.rank=1.parallelly.parent=81822.13f9e3d4f3a07.pid")'’
[16:04:28.236] - Possible to infer worker's PID: TRUE
[16:04:28.236] [local output] Rscript port: 11095

[16:04:28.237] [local output]  - Node 2 of 2 ...
[16:04:28.237] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:28.238] [local output] Rscript port: 11095

[16:04:28.238] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:28.238] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:28.238] [local output] Setting up PSOCK nodes in parallel
[16:04:28.239] List of 36
[16:04:28.239]  $ worker          : chr "localhost"
[16:04:28.239]   ..- attr(*, "localhost")= logi TRUE
[16:04:28.239]  $ master          : chr "localhost"
[16:04:28.239]  $ port            : int 11095
[16:04:28.239]  $ connectTimeout  : num 120
[16:04:28.239]  $ timeout         : num 2592000
[16:04:28.239]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:28.239]  $ homogeneous     : logi TRUE
[16:04:28.239]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:28.239]  $ rscript_envs    : NULL
[16:04:28.239]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:28.239]  $ rscript_startup : NULL
[16:04:28.239]  $ rscript_sh      : chr "sh"
[16:04:28.239]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:28.239]  $ methods         : logi TRUE
[16:04:28.239]  $ socketOptions   : chr "no-delay"
[16:04:28.239]  $ useXDR          : logi FALSE
[16:04:28.239]  $ outfile         : chr "/dev/null"
[16:04:28.239]  $ renice          : int NA
[16:04:28.239]  $ rshcmd          : NULL
[16:04:28.239]  $ user            : chr(0) 
[16:04:28.239]  $ revtunnel       : logi FALSE
[16:04:28.239]  $ rshlogfile      : NULL
[16:04:28.239]  $ rshopts         : chr(0) 
[16:04:28.239]  $ rank            : int 1
[16:04:28.239]  $ manual          : logi FALSE
[16:04:28.239]  $ dryrun          : logi FALSE
[16:04:28.239]  $ quiet           : logi FALSE
[16:04:28.239]  $ setup_strategy  : chr "parallel"
[16:04:28.239]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:28.239]  $ pidfile         : chr "/tmp/RtmpcyOEZt/worker.rank=1.parallelly.parent=81822.13f9e3d4f3a07.pid"
[16:04:28.239]  $ rshcmd_label    : NULL
[16:04:28.239]  $ rsh_call        : NULL
[16:04:28.239]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:28.239]  $ localMachine    : logi TRUE
[16:04:28.239]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:28.239]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:28.239]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:28.239]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:28.239]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:28.239]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:28.239]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:28.239]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:28.239]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:28.239]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:28.239]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:28.239]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:28.239]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:28.239]  $ arguments       :List of 28
[16:04:28.239]   ..$ worker          : chr "localhost"
[16:04:28.239]   ..$ master          : NULL
[16:04:28.239]   ..$ port            : int 11095
[16:04:28.239]   ..$ connectTimeout  : num 120
[16:04:28.239]   ..$ timeout         : num 2592000
[16:04:28.239]   ..$ rscript         : NULL
[16:04:28.239]   ..$ homogeneous     : NULL
[16:04:28.239]   ..$ rscript_args    : NULL
[16:04:28.239]   ..$ rscript_envs    : NULL
[16:04:28.239]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:28.239]   ..$ rscript_startup : NULL
[16:04:28.239]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:28.239]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:28.239]   ..$ methods         : logi TRUE
[16:04:28.239]   ..$ socketOptions   : chr "no-delay"
[16:04:28.239]   ..$ useXDR          : logi FALSE
[16:04:28.239]   ..$ outfile         : chr "/dev/null"
[16:04:28.239]   ..$ renice          : int NA
[16:04:28.239]   ..$ rshcmd          : NULL
[16:04:28.239]   ..$ user            : NULL
[16:04:28.239]   ..$ revtunnel       : logi NA
[16:04:28.239]   ..$ rshlogfile      : NULL
[16:04:28.239]   ..$ rshopts         : NULL
[16:04:28.239]   ..$ rank            : int 1
[16:04:28.239]   ..$ manual          : logi FALSE
[16:04:28.239]   ..$ dryrun          : logi FALSE
[16:04:28.239]   ..$ quiet           : logi FALSE
[16:04:28.239]   ..$ setup_strategy  : chr "parallel"
[16:04:28.239]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:28.258] [local output] System call to launch all workers:
[16:04:28.258] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcyOEZt/worker.rank=1.parallelly.parent=81822.13f9e3d4f3a07.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11095 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:28.258] [local output] Starting PSOCK main server
[16:04:28.263] [local output] Workers launched
[16:04:28.264] [local output] Waiting for workers to connect back
[16:04:28.264]  - [local output] 0 workers out of 2 ready
[16:04:28.506]  - [local output] 0 workers out of 2 ready
[16:04:28.506]  - [local output] 1 workers out of 2 ready
[16:04:28.507]  - [local output] 1 workers out of 2 ready
[16:04:28.507]  - [local output] 2 workers out of 2 ready
[16:04:28.507] [local output] Launching of workers completed
[16:04:28.507] [local output] Collecting session information from workers
[16:04:28.508] [local output]  - Worker #1 of 2
[16:04:28.509] [local output]  - Worker #2 of 2
[16:04:28.509] [local output] makeClusterPSOCK() ... done
[16:04:28.520] Packages needed by the future expression (n = 0): <none>
[16:04:28.520] Packages needed by future strategies (n = 0): <none>
[16:04:28.521] {
[16:04:28.521]     {
[16:04:28.521]         {
[16:04:28.521]             ...future.startTime <- base::Sys.time()
[16:04:28.521]             {
[16:04:28.521]                 {
[16:04:28.521]                   {
[16:04:28.521]                     {
[16:04:28.521]                       base::local({
[16:04:28.521]                         has_future <- base::requireNamespace("future", 
[16:04:28.521]                           quietly = TRUE)
[16:04:28.521]                         if (has_future) {
[16:04:28.521]                           ns <- base::getNamespace("future")
[16:04:28.521]                           version <- ns[[".package"]][["version"]]
[16:04:28.521]                           if (is.null(version)) 
[16:04:28.521]                             version <- utils::packageVersion("future")
[16:04:28.521]                         }
[16:04:28.521]                         else {
[16:04:28.521]                           version <- NULL
[16:04:28.521]                         }
[16:04:28.521]                         if (!has_future || version < "1.8.0") {
[16:04:28.521]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.521]                             "", base::R.version$version.string), 
[16:04:28.521]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.521]                               "release", "version")], collapse = " "), 
[16:04:28.521]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.521]                             info)
[16:04:28.521]                           info <- base::paste(info, collapse = "; ")
[16:04:28.521]                           if (!has_future) {
[16:04:28.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.521]                               info)
[16:04:28.521]                           }
[16:04:28.521]                           else {
[16:04:28.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.521]                               info, version)
[16:04:28.521]                           }
[16:04:28.521]                           base::stop(msg)
[16:04:28.521]                         }
[16:04:28.521]                       })
[16:04:28.521]                     }
[16:04:28.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.521]                     base::options(mc.cores = 1L)
[16:04:28.521]                   }
[16:04:28.521]                   options(future.plan = NULL)
[16:04:28.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.521]                 }
[16:04:28.521]                 ...future.workdir <- getwd()
[16:04:28.521]             }
[16:04:28.521]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.521]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.521]         }
[16:04:28.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.521]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.521]             base::names(...future.oldOptions))
[16:04:28.521]     }
[16:04:28.521]     if (FALSE) {
[16:04:28.521]     }
[16:04:28.521]     else {
[16:04:28.521]         if (TRUE) {
[16:04:28.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.521]                 open = "w")
[16:04:28.521]         }
[16:04:28.521]         else {
[16:04:28.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.521]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.521]         }
[16:04:28.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.521]             base::sink(type = "output", split = FALSE)
[16:04:28.521]             base::close(...future.stdout)
[16:04:28.521]         }, add = TRUE)
[16:04:28.521]     }
[16:04:28.521]     ...future.frame <- base::sys.nframe()
[16:04:28.521]     ...future.conditions <- base::list()
[16:04:28.521]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.521]     if (FALSE) {
[16:04:28.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.521]     }
[16:04:28.521]     ...future.result <- base::tryCatch({
[16:04:28.521]         base::withCallingHandlers({
[16:04:28.521]             ...future.value <- base::withVisible(base::local({
[16:04:28.521]                 ...future.makeSendCondition <- base::local({
[16:04:28.521]                   sendCondition <- NULL
[16:04:28.521]                   function(frame = 1L) {
[16:04:28.521]                     if (is.function(sendCondition)) 
[16:04:28.521]                       return(sendCondition)
[16:04:28.521]                     ns <- getNamespace("parallel")
[16:04:28.521]                     if (exists("sendData", mode = "function", 
[16:04:28.521]                       envir = ns)) {
[16:04:28.521]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.521]                         envir = ns)
[16:04:28.521]                       envir <- sys.frame(frame)
[16:04:28.521]                       master <- NULL
[16:04:28.521]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.521]                         !identical(envir, emptyenv())) {
[16:04:28.521]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.521]                           inherits = FALSE)) {
[16:04:28.521]                           master <- get("master", mode = "list", 
[16:04:28.521]                             envir = envir, inherits = FALSE)
[16:04:28.521]                           if (inherits(master, c("SOCKnode", 
[16:04:28.521]                             "SOCK0node"))) {
[16:04:28.521]                             sendCondition <<- function(cond) {
[16:04:28.521]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.521]                                 success = TRUE)
[16:04:28.521]                               parallel_sendData(master, data)
[16:04:28.521]                             }
[16:04:28.521]                             return(sendCondition)
[16:04:28.521]                           }
[16:04:28.521]                         }
[16:04:28.521]                         frame <- frame + 1L
[16:04:28.521]                         envir <- sys.frame(frame)
[16:04:28.521]                       }
[16:04:28.521]                     }
[16:04:28.521]                     sendCondition <<- function(cond) NULL
[16:04:28.521]                   }
[16:04:28.521]                 })
[16:04:28.521]                 withCallingHandlers({
[16:04:28.521]                   NA
[16:04:28.521]                 }, immediateCondition = function(cond) {
[16:04:28.521]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.521]                   sendCondition(cond)
[16:04:28.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.521]                   {
[16:04:28.521]                     inherits <- base::inherits
[16:04:28.521]                     invokeRestart <- base::invokeRestart
[16:04:28.521]                     is.null <- base::is.null
[16:04:28.521]                     muffled <- FALSE
[16:04:28.521]                     if (inherits(cond, "message")) {
[16:04:28.521]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.521]                       if (muffled) 
[16:04:28.521]                         invokeRestart("muffleMessage")
[16:04:28.521]                     }
[16:04:28.521]                     else if (inherits(cond, "warning")) {
[16:04:28.521]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.521]                       if (muffled) 
[16:04:28.521]                         invokeRestart("muffleWarning")
[16:04:28.521]                     }
[16:04:28.521]                     else if (inherits(cond, "condition")) {
[16:04:28.521]                       if (!is.null(pattern)) {
[16:04:28.521]                         computeRestarts <- base::computeRestarts
[16:04:28.521]                         grepl <- base::grepl
[16:04:28.521]                         restarts <- computeRestarts(cond)
[16:04:28.521]                         for (restart in restarts) {
[16:04:28.521]                           name <- restart$name
[16:04:28.521]                           if (is.null(name)) 
[16:04:28.521]                             next
[16:04:28.521]                           if (!grepl(pattern, name)) 
[16:04:28.521]                             next
[16:04:28.521]                           invokeRestart(restart)
[16:04:28.521]                           muffled <- TRUE
[16:04:28.521]                           break
[16:04:28.521]                         }
[16:04:28.521]                       }
[16:04:28.521]                     }
[16:04:28.521]                     invisible(muffled)
[16:04:28.521]                   }
[16:04:28.521]                   muffleCondition(cond)
[16:04:28.521]                 })
[16:04:28.521]             }))
[16:04:28.521]             future::FutureResult(value = ...future.value$value, 
[16:04:28.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.521]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.521]                     ...future.globalenv.names))
[16:04:28.521]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.521]         }, condition = base::local({
[16:04:28.521]             c <- base::c
[16:04:28.521]             inherits <- base::inherits
[16:04:28.521]             invokeRestart <- base::invokeRestart
[16:04:28.521]             length <- base::length
[16:04:28.521]             list <- base::list
[16:04:28.521]             seq.int <- base::seq.int
[16:04:28.521]             signalCondition <- base::signalCondition
[16:04:28.521]             sys.calls <- base::sys.calls
[16:04:28.521]             `[[` <- base::`[[`
[16:04:28.521]             `+` <- base::`+`
[16:04:28.521]             `<<-` <- base::`<<-`
[16:04:28.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.521]                   3L)]
[16:04:28.521]             }
[16:04:28.521]             function(cond) {
[16:04:28.521]                 is_error <- inherits(cond, "error")
[16:04:28.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.521]                   NULL)
[16:04:28.521]                 if (is_error) {
[16:04:28.521]                   sessionInformation <- function() {
[16:04:28.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.521]                       search = base::search(), system = base::Sys.info())
[16:04:28.521]                   }
[16:04:28.521]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.521]                     cond$call), session = sessionInformation(), 
[16:04:28.521]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.521]                   signalCondition(cond)
[16:04:28.521]                 }
[16:04:28.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.521]                 "immediateCondition"))) {
[16:04:28.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.521]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.521]                   if (TRUE && !signal) {
[16:04:28.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.521]                     {
[16:04:28.521]                       inherits <- base::inherits
[16:04:28.521]                       invokeRestart <- base::invokeRestart
[16:04:28.521]                       is.null <- base::is.null
[16:04:28.521]                       muffled <- FALSE
[16:04:28.521]                       if (inherits(cond, "message")) {
[16:04:28.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.521]                         if (muffled) 
[16:04:28.521]                           invokeRestart("muffleMessage")
[16:04:28.521]                       }
[16:04:28.521]                       else if (inherits(cond, "warning")) {
[16:04:28.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.521]                         if (muffled) 
[16:04:28.521]                           invokeRestart("muffleWarning")
[16:04:28.521]                       }
[16:04:28.521]                       else if (inherits(cond, "condition")) {
[16:04:28.521]                         if (!is.null(pattern)) {
[16:04:28.521]                           computeRestarts <- base::computeRestarts
[16:04:28.521]                           grepl <- base::grepl
[16:04:28.521]                           restarts <- computeRestarts(cond)
[16:04:28.521]                           for (restart in restarts) {
[16:04:28.521]                             name <- restart$name
[16:04:28.521]                             if (is.null(name)) 
[16:04:28.521]                               next
[16:04:28.521]                             if (!grepl(pattern, name)) 
[16:04:28.521]                               next
[16:04:28.521]                             invokeRestart(restart)
[16:04:28.521]                             muffled <- TRUE
[16:04:28.521]                             break
[16:04:28.521]                           }
[16:04:28.521]                         }
[16:04:28.521]                       }
[16:04:28.521]                       invisible(muffled)
[16:04:28.521]                     }
[16:04:28.521]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.521]                   }
[16:04:28.521]                 }
[16:04:28.521]                 else {
[16:04:28.521]                   if (TRUE) {
[16:04:28.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.521]                     {
[16:04:28.521]                       inherits <- base::inherits
[16:04:28.521]                       invokeRestart <- base::invokeRestart
[16:04:28.521]                       is.null <- base::is.null
[16:04:28.521]                       muffled <- FALSE
[16:04:28.521]                       if (inherits(cond, "message")) {
[16:04:28.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.521]                         if (muffled) 
[16:04:28.521]                           invokeRestart("muffleMessage")
[16:04:28.521]                       }
[16:04:28.521]                       else if (inherits(cond, "warning")) {
[16:04:28.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.521]                         if (muffled) 
[16:04:28.521]                           invokeRestart("muffleWarning")
[16:04:28.521]                       }
[16:04:28.521]                       else if (inherits(cond, "condition")) {
[16:04:28.521]                         if (!is.null(pattern)) {
[16:04:28.521]                           computeRestarts <- base::computeRestarts
[16:04:28.521]                           grepl <- base::grepl
[16:04:28.521]                           restarts <- computeRestarts(cond)
[16:04:28.521]                           for (restart in restarts) {
[16:04:28.521]                             name <- restart$name
[16:04:28.521]                             if (is.null(name)) 
[16:04:28.521]                               next
[16:04:28.521]                             if (!grepl(pattern, name)) 
[16:04:28.521]                               next
[16:04:28.521]                             invokeRestart(restart)
[16:04:28.521]                             muffled <- TRUE
[16:04:28.521]                             break
[16:04:28.521]                           }
[16:04:28.521]                         }
[16:04:28.521]                       }
[16:04:28.521]                       invisible(muffled)
[16:04:28.521]                     }
[16:04:28.521]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.521]                   }
[16:04:28.521]                 }
[16:04:28.521]             }
[16:04:28.521]         }))
[16:04:28.521]     }, error = function(ex) {
[16:04:28.521]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.521]                 ...future.rng), started = ...future.startTime, 
[16:04:28.521]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.521]             version = "1.8"), class = "FutureResult")
[16:04:28.521]     }, finally = {
[16:04:28.521]         if (!identical(...future.workdir, getwd())) 
[16:04:28.521]             setwd(...future.workdir)
[16:04:28.521]         {
[16:04:28.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.521]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.521]             }
[16:04:28.521]             base::options(...future.oldOptions)
[16:04:28.521]             if (.Platform$OS.type == "windows") {
[16:04:28.521]                 old_names <- names(...future.oldEnvVars)
[16:04:28.521]                 envs <- base::Sys.getenv()
[16:04:28.521]                 names <- names(envs)
[16:04:28.521]                 common <- intersect(names, old_names)
[16:04:28.521]                 added <- setdiff(names, old_names)
[16:04:28.521]                 removed <- setdiff(old_names, names)
[16:04:28.521]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.521]                   envs[common]]
[16:04:28.521]                 NAMES <- toupper(changed)
[16:04:28.521]                 args <- list()
[16:04:28.521]                 for (kk in seq_along(NAMES)) {
[16:04:28.521]                   name <- changed[[kk]]
[16:04:28.521]                   NAME <- NAMES[[kk]]
[16:04:28.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.521]                     next
[16:04:28.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.521]                 }
[16:04:28.521]                 NAMES <- toupper(added)
[16:04:28.521]                 for (kk in seq_along(NAMES)) {
[16:04:28.521]                   name <- added[[kk]]
[16:04:28.521]                   NAME <- NAMES[[kk]]
[16:04:28.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.521]                     next
[16:04:28.521]                   args[[name]] <- ""
[16:04:28.521]                 }
[16:04:28.521]                 NAMES <- toupper(removed)
[16:04:28.521]                 for (kk in seq_along(NAMES)) {
[16:04:28.521]                   name <- removed[[kk]]
[16:04:28.521]                   NAME <- NAMES[[kk]]
[16:04:28.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.521]                     next
[16:04:28.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.521]                 }
[16:04:28.521]                 if (length(args) > 0) 
[16:04:28.521]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.521]             }
[16:04:28.521]             else {
[16:04:28.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.521]             }
[16:04:28.521]             {
[16:04:28.521]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.521]                   0L) {
[16:04:28.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.521]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.521]                   base::options(opts)
[16:04:28.521]                 }
[16:04:28.521]                 {
[16:04:28.521]                   {
[16:04:28.521]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.521]                     NULL
[16:04:28.521]                   }
[16:04:28.521]                   options(future.plan = NULL)
[16:04:28.521]                   if (is.na(NA_character_)) 
[16:04:28.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.521]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.521]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.521]                     envir = parent.frame()) 
[16:04:28.521]                   {
[16:04:28.521]                     if (is.function(workers)) 
[16:04:28.521]                       workers <- workers()
[16:04:28.521]                     workers <- structure(as.integer(workers), 
[16:04:28.521]                       class = class(workers))
[16:04:28.521]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.521]                       workers >= 1)
[16:04:28.521]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.521]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.521]                     }
[16:04:28.521]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.521]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.521]                       envir = envir)
[16:04:28.521]                     if (!future$lazy) 
[16:04:28.521]                       future <- run(future)
[16:04:28.521]                     invisible(future)
[16:04:28.521]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.521]                 }
[16:04:28.521]             }
[16:04:28.521]         }
[16:04:28.521]     })
[16:04:28.521]     if (TRUE) {
[16:04:28.521]         base::sink(type = "output", split = FALSE)
[16:04:28.521]         if (TRUE) {
[16:04:28.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.521]         }
[16:04:28.521]         else {
[16:04:28.521]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.521]         }
[16:04:28.521]         base::close(...future.stdout)
[16:04:28.521]         ...future.stdout <- NULL
[16:04:28.521]     }
[16:04:28.521]     ...future.result$conditions <- ...future.conditions
[16:04:28.521]     ...future.result$finished <- base::Sys.time()
[16:04:28.521]     ...future.result
[16:04:28.521] }
[16:04:28.573] MultisessionFuture started
[16:04:28.573] result() for ClusterFuture ...
[16:04:28.574] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.574] - Validating connection of MultisessionFuture
[16:04:28.616] - received message: FutureResult
[16:04:28.616] - Received FutureResult
[16:04:28.616] - Erased future from FutureRegistry
[16:04:28.617] result() for ClusterFuture ...
[16:04:28.617] - result already collected: FutureResult
[16:04:28.617] result() for ClusterFuture ... done
[16:04:28.617] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.617] result() for ClusterFuture ... done
[16:04:28.617] result() for ClusterFuture ...
[16:04:28.617] - result already collected: FutureResult
[16:04:28.617] result() for ClusterFuture ... done
[16:04:28.618] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:28.621] plan(): nbrOfWorkers() = 2
[16:04:28.625] getGlobalsAndPackages() ...
[16:04:28.625] 
[16:04:28.625] - globals: [0] <none>
[16:04:28.625] getGlobalsAndPackages() ... DONE
[16:04:28.636] Packages needed by the future expression (n = 0): <none>
[16:04:28.637] Packages needed by future strategies (n = 0): <none>
[16:04:28.637] {
[16:04:28.637]     {
[16:04:28.637]         {
[16:04:28.637]             ...future.startTime <- base::Sys.time()
[16:04:28.637]             {
[16:04:28.637]                 {
[16:04:28.637]                   {
[16:04:28.637]                     {
[16:04:28.637]                       base::local({
[16:04:28.637]                         has_future <- base::requireNamespace("future", 
[16:04:28.637]                           quietly = TRUE)
[16:04:28.637]                         if (has_future) {
[16:04:28.637]                           ns <- base::getNamespace("future")
[16:04:28.637]                           version <- ns[[".package"]][["version"]]
[16:04:28.637]                           if (is.null(version)) 
[16:04:28.637]                             version <- utils::packageVersion("future")
[16:04:28.637]                         }
[16:04:28.637]                         else {
[16:04:28.637]                           version <- NULL
[16:04:28.637]                         }
[16:04:28.637]                         if (!has_future || version < "1.8.0") {
[16:04:28.637]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.637]                             "", base::R.version$version.string), 
[16:04:28.637]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.637]                               "release", "version")], collapse = " "), 
[16:04:28.637]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.637]                             info)
[16:04:28.637]                           info <- base::paste(info, collapse = "; ")
[16:04:28.637]                           if (!has_future) {
[16:04:28.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.637]                               info)
[16:04:28.637]                           }
[16:04:28.637]                           else {
[16:04:28.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.637]                               info, version)
[16:04:28.637]                           }
[16:04:28.637]                           base::stop(msg)
[16:04:28.637]                         }
[16:04:28.637]                       })
[16:04:28.637]                     }
[16:04:28.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.637]                     base::options(mc.cores = 1L)
[16:04:28.637]                   }
[16:04:28.637]                   options(future.plan = NULL)
[16:04:28.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.637]                 }
[16:04:28.637]                 ...future.workdir <- getwd()
[16:04:28.637]             }
[16:04:28.637]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.637]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.637]         }
[16:04:28.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.637]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.637]             base::names(...future.oldOptions))
[16:04:28.637]     }
[16:04:28.637]     if (FALSE) {
[16:04:28.637]     }
[16:04:28.637]     else {
[16:04:28.637]         if (TRUE) {
[16:04:28.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.637]                 open = "w")
[16:04:28.637]         }
[16:04:28.637]         else {
[16:04:28.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.637]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.637]         }
[16:04:28.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.637]             base::sink(type = "output", split = FALSE)
[16:04:28.637]             base::close(...future.stdout)
[16:04:28.637]         }, add = TRUE)
[16:04:28.637]     }
[16:04:28.637]     ...future.frame <- base::sys.nframe()
[16:04:28.637]     ...future.conditions <- base::list()
[16:04:28.637]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.637]     if (FALSE) {
[16:04:28.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.637]     }
[16:04:28.637]     ...future.result <- base::tryCatch({
[16:04:28.637]         base::withCallingHandlers({
[16:04:28.637]             ...future.value <- base::withVisible(base::local({
[16:04:28.637]                 ...future.makeSendCondition <- base::local({
[16:04:28.637]                   sendCondition <- NULL
[16:04:28.637]                   function(frame = 1L) {
[16:04:28.637]                     if (is.function(sendCondition)) 
[16:04:28.637]                       return(sendCondition)
[16:04:28.637]                     ns <- getNamespace("parallel")
[16:04:28.637]                     if (exists("sendData", mode = "function", 
[16:04:28.637]                       envir = ns)) {
[16:04:28.637]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.637]                         envir = ns)
[16:04:28.637]                       envir <- sys.frame(frame)
[16:04:28.637]                       master <- NULL
[16:04:28.637]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.637]                         !identical(envir, emptyenv())) {
[16:04:28.637]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.637]                           inherits = FALSE)) {
[16:04:28.637]                           master <- get("master", mode = "list", 
[16:04:28.637]                             envir = envir, inherits = FALSE)
[16:04:28.637]                           if (inherits(master, c("SOCKnode", 
[16:04:28.637]                             "SOCK0node"))) {
[16:04:28.637]                             sendCondition <<- function(cond) {
[16:04:28.637]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.637]                                 success = TRUE)
[16:04:28.637]                               parallel_sendData(master, data)
[16:04:28.637]                             }
[16:04:28.637]                             return(sendCondition)
[16:04:28.637]                           }
[16:04:28.637]                         }
[16:04:28.637]                         frame <- frame + 1L
[16:04:28.637]                         envir <- sys.frame(frame)
[16:04:28.637]                       }
[16:04:28.637]                     }
[16:04:28.637]                     sendCondition <<- function(cond) NULL
[16:04:28.637]                   }
[16:04:28.637]                 })
[16:04:28.637]                 withCallingHandlers({
[16:04:28.637]                   42
[16:04:28.637]                 }, immediateCondition = function(cond) {
[16:04:28.637]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.637]                   sendCondition(cond)
[16:04:28.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.637]                   {
[16:04:28.637]                     inherits <- base::inherits
[16:04:28.637]                     invokeRestart <- base::invokeRestart
[16:04:28.637]                     is.null <- base::is.null
[16:04:28.637]                     muffled <- FALSE
[16:04:28.637]                     if (inherits(cond, "message")) {
[16:04:28.637]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.637]                       if (muffled) 
[16:04:28.637]                         invokeRestart("muffleMessage")
[16:04:28.637]                     }
[16:04:28.637]                     else if (inherits(cond, "warning")) {
[16:04:28.637]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.637]                       if (muffled) 
[16:04:28.637]                         invokeRestart("muffleWarning")
[16:04:28.637]                     }
[16:04:28.637]                     else if (inherits(cond, "condition")) {
[16:04:28.637]                       if (!is.null(pattern)) {
[16:04:28.637]                         computeRestarts <- base::computeRestarts
[16:04:28.637]                         grepl <- base::grepl
[16:04:28.637]                         restarts <- computeRestarts(cond)
[16:04:28.637]                         for (restart in restarts) {
[16:04:28.637]                           name <- restart$name
[16:04:28.637]                           if (is.null(name)) 
[16:04:28.637]                             next
[16:04:28.637]                           if (!grepl(pattern, name)) 
[16:04:28.637]                             next
[16:04:28.637]                           invokeRestart(restart)
[16:04:28.637]                           muffled <- TRUE
[16:04:28.637]                           break
[16:04:28.637]                         }
[16:04:28.637]                       }
[16:04:28.637]                     }
[16:04:28.637]                     invisible(muffled)
[16:04:28.637]                   }
[16:04:28.637]                   muffleCondition(cond)
[16:04:28.637]                 })
[16:04:28.637]             }))
[16:04:28.637]             future::FutureResult(value = ...future.value$value, 
[16:04:28.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.637]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.637]                     ...future.globalenv.names))
[16:04:28.637]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.637]         }, condition = base::local({
[16:04:28.637]             c <- base::c
[16:04:28.637]             inherits <- base::inherits
[16:04:28.637]             invokeRestart <- base::invokeRestart
[16:04:28.637]             length <- base::length
[16:04:28.637]             list <- base::list
[16:04:28.637]             seq.int <- base::seq.int
[16:04:28.637]             signalCondition <- base::signalCondition
[16:04:28.637]             sys.calls <- base::sys.calls
[16:04:28.637]             `[[` <- base::`[[`
[16:04:28.637]             `+` <- base::`+`
[16:04:28.637]             `<<-` <- base::`<<-`
[16:04:28.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.637]                   3L)]
[16:04:28.637]             }
[16:04:28.637]             function(cond) {
[16:04:28.637]                 is_error <- inherits(cond, "error")
[16:04:28.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.637]                   NULL)
[16:04:28.637]                 if (is_error) {
[16:04:28.637]                   sessionInformation <- function() {
[16:04:28.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.637]                       search = base::search(), system = base::Sys.info())
[16:04:28.637]                   }
[16:04:28.637]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.637]                     cond$call), session = sessionInformation(), 
[16:04:28.637]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.637]                   signalCondition(cond)
[16:04:28.637]                 }
[16:04:28.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.637]                 "immediateCondition"))) {
[16:04:28.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.637]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.637]                   if (TRUE && !signal) {
[16:04:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.637]                     {
[16:04:28.637]                       inherits <- base::inherits
[16:04:28.637]                       invokeRestart <- base::invokeRestart
[16:04:28.637]                       is.null <- base::is.null
[16:04:28.637]                       muffled <- FALSE
[16:04:28.637]                       if (inherits(cond, "message")) {
[16:04:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.637]                         if (muffled) 
[16:04:28.637]                           invokeRestart("muffleMessage")
[16:04:28.637]                       }
[16:04:28.637]                       else if (inherits(cond, "warning")) {
[16:04:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.637]                         if (muffled) 
[16:04:28.637]                           invokeRestart("muffleWarning")
[16:04:28.637]                       }
[16:04:28.637]                       else if (inherits(cond, "condition")) {
[16:04:28.637]                         if (!is.null(pattern)) {
[16:04:28.637]                           computeRestarts <- base::computeRestarts
[16:04:28.637]                           grepl <- base::grepl
[16:04:28.637]                           restarts <- computeRestarts(cond)
[16:04:28.637]                           for (restart in restarts) {
[16:04:28.637]                             name <- restart$name
[16:04:28.637]                             if (is.null(name)) 
[16:04:28.637]                               next
[16:04:28.637]                             if (!grepl(pattern, name)) 
[16:04:28.637]                               next
[16:04:28.637]                             invokeRestart(restart)
[16:04:28.637]                             muffled <- TRUE
[16:04:28.637]                             break
[16:04:28.637]                           }
[16:04:28.637]                         }
[16:04:28.637]                       }
[16:04:28.637]                       invisible(muffled)
[16:04:28.637]                     }
[16:04:28.637]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.637]                   }
[16:04:28.637]                 }
[16:04:28.637]                 else {
[16:04:28.637]                   if (TRUE) {
[16:04:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.637]                     {
[16:04:28.637]                       inherits <- base::inherits
[16:04:28.637]                       invokeRestart <- base::invokeRestart
[16:04:28.637]                       is.null <- base::is.null
[16:04:28.637]                       muffled <- FALSE
[16:04:28.637]                       if (inherits(cond, "message")) {
[16:04:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.637]                         if (muffled) 
[16:04:28.637]                           invokeRestart("muffleMessage")
[16:04:28.637]                       }
[16:04:28.637]                       else if (inherits(cond, "warning")) {
[16:04:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.637]                         if (muffled) 
[16:04:28.637]                           invokeRestart("muffleWarning")
[16:04:28.637]                       }
[16:04:28.637]                       else if (inherits(cond, "condition")) {
[16:04:28.637]                         if (!is.null(pattern)) {
[16:04:28.637]                           computeRestarts <- base::computeRestarts
[16:04:28.637]                           grepl <- base::grepl
[16:04:28.637]                           restarts <- computeRestarts(cond)
[16:04:28.637]                           for (restart in restarts) {
[16:04:28.637]                             name <- restart$name
[16:04:28.637]                             if (is.null(name)) 
[16:04:28.637]                               next
[16:04:28.637]                             if (!grepl(pattern, name)) 
[16:04:28.637]                               next
[16:04:28.637]                             invokeRestart(restart)
[16:04:28.637]                             muffled <- TRUE
[16:04:28.637]                             break
[16:04:28.637]                           }
[16:04:28.637]                         }
[16:04:28.637]                       }
[16:04:28.637]                       invisible(muffled)
[16:04:28.637]                     }
[16:04:28.637]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.637]                   }
[16:04:28.637]                 }
[16:04:28.637]             }
[16:04:28.637]         }))
[16:04:28.637]     }, error = function(ex) {
[16:04:28.637]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.637]                 ...future.rng), started = ...future.startTime, 
[16:04:28.637]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.637]             version = "1.8"), class = "FutureResult")
[16:04:28.637]     }, finally = {
[16:04:28.637]         if (!identical(...future.workdir, getwd())) 
[16:04:28.637]             setwd(...future.workdir)
[16:04:28.637]         {
[16:04:28.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.637]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.637]             }
[16:04:28.637]             base::options(...future.oldOptions)
[16:04:28.637]             if (.Platform$OS.type == "windows") {
[16:04:28.637]                 old_names <- names(...future.oldEnvVars)
[16:04:28.637]                 envs <- base::Sys.getenv()
[16:04:28.637]                 names <- names(envs)
[16:04:28.637]                 common <- intersect(names, old_names)
[16:04:28.637]                 added <- setdiff(names, old_names)
[16:04:28.637]                 removed <- setdiff(old_names, names)
[16:04:28.637]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.637]                   envs[common]]
[16:04:28.637]                 NAMES <- toupper(changed)
[16:04:28.637]                 args <- list()
[16:04:28.637]                 for (kk in seq_along(NAMES)) {
[16:04:28.637]                   name <- changed[[kk]]
[16:04:28.637]                   NAME <- NAMES[[kk]]
[16:04:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.637]                     next
[16:04:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.637]                 }
[16:04:28.637]                 NAMES <- toupper(added)
[16:04:28.637]                 for (kk in seq_along(NAMES)) {
[16:04:28.637]                   name <- added[[kk]]
[16:04:28.637]                   NAME <- NAMES[[kk]]
[16:04:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.637]                     next
[16:04:28.637]                   args[[name]] <- ""
[16:04:28.637]                 }
[16:04:28.637]                 NAMES <- toupper(removed)
[16:04:28.637]                 for (kk in seq_along(NAMES)) {
[16:04:28.637]                   name <- removed[[kk]]
[16:04:28.637]                   NAME <- NAMES[[kk]]
[16:04:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.637]                     next
[16:04:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.637]                 }
[16:04:28.637]                 if (length(args) > 0) 
[16:04:28.637]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.637]             }
[16:04:28.637]             else {
[16:04:28.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.637]             }
[16:04:28.637]             {
[16:04:28.637]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.637]                   0L) {
[16:04:28.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.637]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.637]                   base::options(opts)
[16:04:28.637]                 }
[16:04:28.637]                 {
[16:04:28.637]                   {
[16:04:28.637]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.637]                     NULL
[16:04:28.637]                   }
[16:04:28.637]                   options(future.plan = NULL)
[16:04:28.637]                   if (is.na(NA_character_)) 
[16:04:28.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.637]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.637]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.637]                     envir = parent.frame()) 
[16:04:28.637]                   {
[16:04:28.637]                     if (is.function(workers)) 
[16:04:28.637]                       workers <- workers()
[16:04:28.637]                     workers <- structure(as.integer(workers), 
[16:04:28.637]                       class = class(workers))
[16:04:28.637]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.637]                       workers >= 1)
[16:04:28.637]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.637]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.637]                     }
[16:04:28.637]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.637]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.637]                       envir = envir)
[16:04:28.637]                     if (!future$lazy) 
[16:04:28.637]                       future <- run(future)
[16:04:28.637]                     invisible(future)
[16:04:28.637]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.637]                 }
[16:04:28.637]             }
[16:04:28.637]         }
[16:04:28.637]     })
[16:04:28.637]     if (TRUE) {
[16:04:28.637]         base::sink(type = "output", split = FALSE)
[16:04:28.637]         if (TRUE) {
[16:04:28.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.637]         }
[16:04:28.637]         else {
[16:04:28.637]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.637]         }
[16:04:28.637]         base::close(...future.stdout)
[16:04:28.637]         ...future.stdout <- NULL
[16:04:28.637]     }
[16:04:28.637]     ...future.result$conditions <- ...future.conditions
[16:04:28.637]     ...future.result$finished <- base::Sys.time()
[16:04:28.637]     ...future.result
[16:04:28.637] }
[16:04:28.640] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.652] result() for ClusterFuture ...
[16:04:28.652] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.652] - Validating connection of MultisessionFuture
[16:04:28.687] - received message: FutureResult
[16:04:28.687] - Received FutureResult
[16:04:28.688] - Erased future from FutureRegistry
[16:04:28.688] result() for ClusterFuture ...
[16:04:28.688] - result already collected: FutureResult
[16:04:28.688] result() for ClusterFuture ... done
[16:04:28.688] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.688] result() for ClusterFuture ... done
[16:04:28.688] result() for ClusterFuture ...
[16:04:28.688] - result already collected: FutureResult
[16:04:28.689] result() for ClusterFuture ... done
[16:04:28.689] getGlobalsAndPackages() ...
[16:04:28.689] Searching for globals...
[16:04:28.689] 
[16:04:28.689] Searching for globals ... DONE
[16:04:28.689] - globals: [0] <none>
[16:04:28.690] getGlobalsAndPackages() ... DONE
[16:04:28.690] run() for ‘Future’ ...
[16:04:28.690] - state: ‘created’
[16:04:28.690] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:28.704] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:28.705]   - Field: ‘node’
[16:04:28.705]   - Field: ‘label’
[16:04:28.705]   - Field: ‘local’
[16:04:28.705]   - Field: ‘owner’
[16:04:28.705]   - Field: ‘envir’
[16:04:28.705]   - Field: ‘workers’
[16:04:28.705]   - Field: ‘packages’
[16:04:28.705]   - Field: ‘gc’
[16:04:28.705]   - Field: ‘conditions’
[16:04:28.706]   - Field: ‘persistent’
[16:04:28.706]   - Field: ‘expr’
[16:04:28.706]   - Field: ‘uuid’
[16:04:28.706]   - Field: ‘seed’
[16:04:28.706]   - Field: ‘version’
[16:04:28.706]   - Field: ‘result’
[16:04:28.706]   - Field: ‘asynchronous’
[16:04:28.706]   - Field: ‘calls’
[16:04:28.706]   - Field: ‘globals’
[16:04:28.707]   - Field: ‘stdout’
[16:04:28.707]   - Field: ‘earlySignal’
[16:04:28.707]   - Field: ‘lazy’
[16:04:28.707]   - Field: ‘state’
[16:04:28.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:28.707] - Launch lazy future ...
[16:04:28.708] Packages needed by the future expression (n = 0): <none>
[16:04:28.708] Packages needed by future strategies (n = 0): <none>
[16:04:28.708] {
[16:04:28.708]     {
[16:04:28.708]         {
[16:04:28.708]             ...future.startTime <- base::Sys.time()
[16:04:28.708]             {
[16:04:28.708]                 {
[16:04:28.708]                   {
[16:04:28.708]                     {
[16:04:28.708]                       base::local({
[16:04:28.708]                         has_future <- base::requireNamespace("future", 
[16:04:28.708]                           quietly = TRUE)
[16:04:28.708]                         if (has_future) {
[16:04:28.708]                           ns <- base::getNamespace("future")
[16:04:28.708]                           version <- ns[[".package"]][["version"]]
[16:04:28.708]                           if (is.null(version)) 
[16:04:28.708]                             version <- utils::packageVersion("future")
[16:04:28.708]                         }
[16:04:28.708]                         else {
[16:04:28.708]                           version <- NULL
[16:04:28.708]                         }
[16:04:28.708]                         if (!has_future || version < "1.8.0") {
[16:04:28.708]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.708]                             "", base::R.version$version.string), 
[16:04:28.708]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.708]                               "release", "version")], collapse = " "), 
[16:04:28.708]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.708]                             info)
[16:04:28.708]                           info <- base::paste(info, collapse = "; ")
[16:04:28.708]                           if (!has_future) {
[16:04:28.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.708]                               info)
[16:04:28.708]                           }
[16:04:28.708]                           else {
[16:04:28.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.708]                               info, version)
[16:04:28.708]                           }
[16:04:28.708]                           base::stop(msg)
[16:04:28.708]                         }
[16:04:28.708]                       })
[16:04:28.708]                     }
[16:04:28.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.708]                     base::options(mc.cores = 1L)
[16:04:28.708]                   }
[16:04:28.708]                   options(future.plan = NULL)
[16:04:28.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.708]                 }
[16:04:28.708]                 ...future.workdir <- getwd()
[16:04:28.708]             }
[16:04:28.708]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.708]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.708]         }
[16:04:28.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.708]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.708]             base::names(...future.oldOptions))
[16:04:28.708]     }
[16:04:28.708]     if (FALSE) {
[16:04:28.708]     }
[16:04:28.708]     else {
[16:04:28.708]         if (TRUE) {
[16:04:28.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.708]                 open = "w")
[16:04:28.708]         }
[16:04:28.708]         else {
[16:04:28.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.708]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.708]         }
[16:04:28.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.708]             base::sink(type = "output", split = FALSE)
[16:04:28.708]             base::close(...future.stdout)
[16:04:28.708]         }, add = TRUE)
[16:04:28.708]     }
[16:04:28.708]     ...future.frame <- base::sys.nframe()
[16:04:28.708]     ...future.conditions <- base::list()
[16:04:28.708]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.708]     if (FALSE) {
[16:04:28.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.708]     }
[16:04:28.708]     ...future.result <- base::tryCatch({
[16:04:28.708]         base::withCallingHandlers({
[16:04:28.708]             ...future.value <- base::withVisible(base::local({
[16:04:28.708]                 ...future.makeSendCondition <- base::local({
[16:04:28.708]                   sendCondition <- NULL
[16:04:28.708]                   function(frame = 1L) {
[16:04:28.708]                     if (is.function(sendCondition)) 
[16:04:28.708]                       return(sendCondition)
[16:04:28.708]                     ns <- getNamespace("parallel")
[16:04:28.708]                     if (exists("sendData", mode = "function", 
[16:04:28.708]                       envir = ns)) {
[16:04:28.708]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.708]                         envir = ns)
[16:04:28.708]                       envir <- sys.frame(frame)
[16:04:28.708]                       master <- NULL
[16:04:28.708]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.708]                         !identical(envir, emptyenv())) {
[16:04:28.708]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.708]                           inherits = FALSE)) {
[16:04:28.708]                           master <- get("master", mode = "list", 
[16:04:28.708]                             envir = envir, inherits = FALSE)
[16:04:28.708]                           if (inherits(master, c("SOCKnode", 
[16:04:28.708]                             "SOCK0node"))) {
[16:04:28.708]                             sendCondition <<- function(cond) {
[16:04:28.708]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.708]                                 success = TRUE)
[16:04:28.708]                               parallel_sendData(master, data)
[16:04:28.708]                             }
[16:04:28.708]                             return(sendCondition)
[16:04:28.708]                           }
[16:04:28.708]                         }
[16:04:28.708]                         frame <- frame + 1L
[16:04:28.708]                         envir <- sys.frame(frame)
[16:04:28.708]                       }
[16:04:28.708]                     }
[16:04:28.708]                     sendCondition <<- function(cond) NULL
[16:04:28.708]                   }
[16:04:28.708]                 })
[16:04:28.708]                 withCallingHandlers({
[16:04:28.708]                   42
[16:04:28.708]                 }, immediateCondition = function(cond) {
[16:04:28.708]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.708]                   sendCondition(cond)
[16:04:28.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.708]                   {
[16:04:28.708]                     inherits <- base::inherits
[16:04:28.708]                     invokeRestart <- base::invokeRestart
[16:04:28.708]                     is.null <- base::is.null
[16:04:28.708]                     muffled <- FALSE
[16:04:28.708]                     if (inherits(cond, "message")) {
[16:04:28.708]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.708]                       if (muffled) 
[16:04:28.708]                         invokeRestart("muffleMessage")
[16:04:28.708]                     }
[16:04:28.708]                     else if (inherits(cond, "warning")) {
[16:04:28.708]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.708]                       if (muffled) 
[16:04:28.708]                         invokeRestart("muffleWarning")
[16:04:28.708]                     }
[16:04:28.708]                     else if (inherits(cond, "condition")) {
[16:04:28.708]                       if (!is.null(pattern)) {
[16:04:28.708]                         computeRestarts <- base::computeRestarts
[16:04:28.708]                         grepl <- base::grepl
[16:04:28.708]                         restarts <- computeRestarts(cond)
[16:04:28.708]                         for (restart in restarts) {
[16:04:28.708]                           name <- restart$name
[16:04:28.708]                           if (is.null(name)) 
[16:04:28.708]                             next
[16:04:28.708]                           if (!grepl(pattern, name)) 
[16:04:28.708]                             next
[16:04:28.708]                           invokeRestart(restart)
[16:04:28.708]                           muffled <- TRUE
[16:04:28.708]                           break
[16:04:28.708]                         }
[16:04:28.708]                       }
[16:04:28.708]                     }
[16:04:28.708]                     invisible(muffled)
[16:04:28.708]                   }
[16:04:28.708]                   muffleCondition(cond)
[16:04:28.708]                 })
[16:04:28.708]             }))
[16:04:28.708]             future::FutureResult(value = ...future.value$value, 
[16:04:28.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.708]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.708]                     ...future.globalenv.names))
[16:04:28.708]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.708]         }, condition = base::local({
[16:04:28.708]             c <- base::c
[16:04:28.708]             inherits <- base::inherits
[16:04:28.708]             invokeRestart <- base::invokeRestart
[16:04:28.708]             length <- base::length
[16:04:28.708]             list <- base::list
[16:04:28.708]             seq.int <- base::seq.int
[16:04:28.708]             signalCondition <- base::signalCondition
[16:04:28.708]             sys.calls <- base::sys.calls
[16:04:28.708]             `[[` <- base::`[[`
[16:04:28.708]             `+` <- base::`+`
[16:04:28.708]             `<<-` <- base::`<<-`
[16:04:28.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.708]                   3L)]
[16:04:28.708]             }
[16:04:28.708]             function(cond) {
[16:04:28.708]                 is_error <- inherits(cond, "error")
[16:04:28.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.708]                   NULL)
[16:04:28.708]                 if (is_error) {
[16:04:28.708]                   sessionInformation <- function() {
[16:04:28.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.708]                       search = base::search(), system = base::Sys.info())
[16:04:28.708]                   }
[16:04:28.708]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.708]                     cond$call), session = sessionInformation(), 
[16:04:28.708]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.708]                   signalCondition(cond)
[16:04:28.708]                 }
[16:04:28.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.708]                 "immediateCondition"))) {
[16:04:28.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.708]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.708]                   if (TRUE && !signal) {
[16:04:28.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.708]                     {
[16:04:28.708]                       inherits <- base::inherits
[16:04:28.708]                       invokeRestart <- base::invokeRestart
[16:04:28.708]                       is.null <- base::is.null
[16:04:28.708]                       muffled <- FALSE
[16:04:28.708]                       if (inherits(cond, "message")) {
[16:04:28.708]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.708]                         if (muffled) 
[16:04:28.708]                           invokeRestart("muffleMessage")
[16:04:28.708]                       }
[16:04:28.708]                       else if (inherits(cond, "warning")) {
[16:04:28.708]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.708]                         if (muffled) 
[16:04:28.708]                           invokeRestart("muffleWarning")
[16:04:28.708]                       }
[16:04:28.708]                       else if (inherits(cond, "condition")) {
[16:04:28.708]                         if (!is.null(pattern)) {
[16:04:28.708]                           computeRestarts <- base::computeRestarts
[16:04:28.708]                           grepl <- base::grepl
[16:04:28.708]                           restarts <- computeRestarts(cond)
[16:04:28.708]                           for (restart in restarts) {
[16:04:28.708]                             name <- restart$name
[16:04:28.708]                             if (is.null(name)) 
[16:04:28.708]                               next
[16:04:28.708]                             if (!grepl(pattern, name)) 
[16:04:28.708]                               next
[16:04:28.708]                             invokeRestart(restart)
[16:04:28.708]                             muffled <- TRUE
[16:04:28.708]                             break
[16:04:28.708]                           }
[16:04:28.708]                         }
[16:04:28.708]                       }
[16:04:28.708]                       invisible(muffled)
[16:04:28.708]                     }
[16:04:28.708]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.708]                   }
[16:04:28.708]                 }
[16:04:28.708]                 else {
[16:04:28.708]                   if (TRUE) {
[16:04:28.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.708]                     {
[16:04:28.708]                       inherits <- base::inherits
[16:04:28.708]                       invokeRestart <- base::invokeRestart
[16:04:28.708]                       is.null <- base::is.null
[16:04:28.708]                       muffled <- FALSE
[16:04:28.708]                       if (inherits(cond, "message")) {
[16:04:28.708]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.708]                         if (muffled) 
[16:04:28.708]                           invokeRestart("muffleMessage")
[16:04:28.708]                       }
[16:04:28.708]                       else if (inherits(cond, "warning")) {
[16:04:28.708]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.708]                         if (muffled) 
[16:04:28.708]                           invokeRestart("muffleWarning")
[16:04:28.708]                       }
[16:04:28.708]                       else if (inherits(cond, "condition")) {
[16:04:28.708]                         if (!is.null(pattern)) {
[16:04:28.708]                           computeRestarts <- base::computeRestarts
[16:04:28.708]                           grepl <- base::grepl
[16:04:28.708]                           restarts <- computeRestarts(cond)
[16:04:28.708]                           for (restart in restarts) {
[16:04:28.708]                             name <- restart$name
[16:04:28.708]                             if (is.null(name)) 
[16:04:28.708]                               next
[16:04:28.708]                             if (!grepl(pattern, name)) 
[16:04:28.708]                               next
[16:04:28.708]                             invokeRestart(restart)
[16:04:28.708]                             muffled <- TRUE
[16:04:28.708]                             break
[16:04:28.708]                           }
[16:04:28.708]                         }
[16:04:28.708]                       }
[16:04:28.708]                       invisible(muffled)
[16:04:28.708]                     }
[16:04:28.708]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.708]                   }
[16:04:28.708]                 }
[16:04:28.708]             }
[16:04:28.708]         }))
[16:04:28.708]     }, error = function(ex) {
[16:04:28.708]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.708]                 ...future.rng), started = ...future.startTime, 
[16:04:28.708]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.708]             version = "1.8"), class = "FutureResult")
[16:04:28.708]     }, finally = {
[16:04:28.708]         if (!identical(...future.workdir, getwd())) 
[16:04:28.708]             setwd(...future.workdir)
[16:04:28.708]         {
[16:04:28.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.708]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.708]             }
[16:04:28.708]             base::options(...future.oldOptions)
[16:04:28.708]             if (.Platform$OS.type == "windows") {
[16:04:28.708]                 old_names <- names(...future.oldEnvVars)
[16:04:28.708]                 envs <- base::Sys.getenv()
[16:04:28.708]                 names <- names(envs)
[16:04:28.708]                 common <- intersect(names, old_names)
[16:04:28.708]                 added <- setdiff(names, old_names)
[16:04:28.708]                 removed <- setdiff(old_names, names)
[16:04:28.708]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.708]                   envs[common]]
[16:04:28.708]                 NAMES <- toupper(changed)
[16:04:28.708]                 args <- list()
[16:04:28.708]                 for (kk in seq_along(NAMES)) {
[16:04:28.708]                   name <- changed[[kk]]
[16:04:28.708]                   NAME <- NAMES[[kk]]
[16:04:28.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.708]                     next
[16:04:28.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.708]                 }
[16:04:28.708]                 NAMES <- toupper(added)
[16:04:28.708]                 for (kk in seq_along(NAMES)) {
[16:04:28.708]                   name <- added[[kk]]
[16:04:28.708]                   NAME <- NAMES[[kk]]
[16:04:28.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.708]                     next
[16:04:28.708]                   args[[name]] <- ""
[16:04:28.708]                 }
[16:04:28.708]                 NAMES <- toupper(removed)
[16:04:28.708]                 for (kk in seq_along(NAMES)) {
[16:04:28.708]                   name <- removed[[kk]]
[16:04:28.708]                   NAME <- NAMES[[kk]]
[16:04:28.708]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.708]                     next
[16:04:28.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.708]                 }
[16:04:28.708]                 if (length(args) > 0) 
[16:04:28.708]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.708]             }
[16:04:28.708]             else {
[16:04:28.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.708]             }
[16:04:28.708]             {
[16:04:28.708]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.708]                   0L) {
[16:04:28.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.708]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.708]                   base::options(opts)
[16:04:28.708]                 }
[16:04:28.708]                 {
[16:04:28.708]                   {
[16:04:28.708]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.708]                     NULL
[16:04:28.708]                   }
[16:04:28.708]                   options(future.plan = NULL)
[16:04:28.708]                   if (is.na(NA_character_)) 
[16:04:28.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.708]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.708]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.708]                     envir = parent.frame()) 
[16:04:28.708]                   {
[16:04:28.708]                     if (is.function(workers)) 
[16:04:28.708]                       workers <- workers()
[16:04:28.708]                     workers <- structure(as.integer(workers), 
[16:04:28.708]                       class = class(workers))
[16:04:28.708]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.708]                       workers >= 1)
[16:04:28.708]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.708]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.708]                     }
[16:04:28.708]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.708]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.708]                       envir = envir)
[16:04:28.708]                     if (!future$lazy) 
[16:04:28.708]                       future <- run(future)
[16:04:28.708]                     invisible(future)
[16:04:28.708]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.708]                 }
[16:04:28.708]             }
[16:04:28.708]         }
[16:04:28.708]     })
[16:04:28.708]     if (TRUE) {
[16:04:28.708]         base::sink(type = "output", split = FALSE)
[16:04:28.708]         if (TRUE) {
[16:04:28.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.708]         }
[16:04:28.708]         else {
[16:04:28.708]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.708]         }
[16:04:28.708]         base::close(...future.stdout)
[16:04:28.708]         ...future.stdout <- NULL
[16:04:28.708]     }
[16:04:28.708]     ...future.result$conditions <- ...future.conditions
[16:04:28.708]     ...future.result$finished <- base::Sys.time()
[16:04:28.708]     ...future.result
[16:04:28.708] }
[16:04:28.712] MultisessionFuture started
[16:04:28.712] - Launch lazy future ... done
[16:04:28.712] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.723] result() for ClusterFuture ...
[16:04:28.723] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.723] - Validating connection of MultisessionFuture
[16:04:28.759] - received message: FutureResult
[16:04:28.759] - Received FutureResult
[16:04:28.759] - Erased future from FutureRegistry
[16:04:28.760] result() for ClusterFuture ...
[16:04:28.760] - result already collected: FutureResult
[16:04:28.760] result() for ClusterFuture ... done
[16:04:28.760] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.760] result() for ClusterFuture ... done
[16:04:28.760] result() for ClusterFuture ...
[16:04:28.760] - result already collected: FutureResult
[16:04:28.760] result() for ClusterFuture ... done
[16:04:28.761] getGlobalsAndPackages() ...
[16:04:28.761] Searching for globals...
[16:04:28.762] - globals found: [1] ‘{’
[16:04:28.762] Searching for globals ... DONE
[16:04:28.762] Resolving globals: FALSE
[16:04:28.762] 
[16:04:28.762] 
[16:04:28.762] getGlobalsAndPackages() ... DONE
[16:04:28.763] run() for ‘Future’ ...
[16:04:28.763] - state: ‘created’
[16:04:28.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:28.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:28.777]   - Field: ‘node’
[16:04:28.777]   - Field: ‘label’
[16:04:28.778]   - Field: ‘local’
[16:04:28.778]   - Field: ‘owner’
[16:04:28.778]   - Field: ‘envir’
[16:04:28.778]   - Field: ‘workers’
[16:04:28.778]   - Field: ‘packages’
[16:04:28.778]   - Field: ‘gc’
[16:04:28.778]   - Field: ‘conditions’
[16:04:28.778]   - Field: ‘persistent’
[16:04:28.778]   - Field: ‘expr’
[16:04:28.779]   - Field: ‘uuid’
[16:04:28.779]   - Field: ‘seed’
[16:04:28.779]   - Field: ‘version’
[16:04:28.779]   - Field: ‘result’
[16:04:28.779]   - Field: ‘asynchronous’
[16:04:28.779]   - Field: ‘calls’
[16:04:28.779]   - Field: ‘globals’
[16:04:28.779]   - Field: ‘stdout’
[16:04:28.779]   - Field: ‘earlySignal’
[16:04:28.780]   - Field: ‘lazy’
[16:04:28.780]   - Field: ‘state’
[16:04:28.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:28.780] - Launch lazy future ...
[16:04:28.780] Packages needed by the future expression (n = 0): <none>
[16:04:28.780] Packages needed by future strategies (n = 0): <none>
[16:04:28.781] {
[16:04:28.781]     {
[16:04:28.781]         {
[16:04:28.781]             ...future.startTime <- base::Sys.time()
[16:04:28.781]             {
[16:04:28.781]                 {
[16:04:28.781]                   {
[16:04:28.781]                     {
[16:04:28.781]                       base::local({
[16:04:28.781]                         has_future <- base::requireNamespace("future", 
[16:04:28.781]                           quietly = TRUE)
[16:04:28.781]                         if (has_future) {
[16:04:28.781]                           ns <- base::getNamespace("future")
[16:04:28.781]                           version <- ns[[".package"]][["version"]]
[16:04:28.781]                           if (is.null(version)) 
[16:04:28.781]                             version <- utils::packageVersion("future")
[16:04:28.781]                         }
[16:04:28.781]                         else {
[16:04:28.781]                           version <- NULL
[16:04:28.781]                         }
[16:04:28.781]                         if (!has_future || version < "1.8.0") {
[16:04:28.781]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.781]                             "", base::R.version$version.string), 
[16:04:28.781]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.781]                               "release", "version")], collapse = " "), 
[16:04:28.781]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.781]                             info)
[16:04:28.781]                           info <- base::paste(info, collapse = "; ")
[16:04:28.781]                           if (!has_future) {
[16:04:28.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.781]                               info)
[16:04:28.781]                           }
[16:04:28.781]                           else {
[16:04:28.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.781]                               info, version)
[16:04:28.781]                           }
[16:04:28.781]                           base::stop(msg)
[16:04:28.781]                         }
[16:04:28.781]                       })
[16:04:28.781]                     }
[16:04:28.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.781]                     base::options(mc.cores = 1L)
[16:04:28.781]                   }
[16:04:28.781]                   options(future.plan = NULL)
[16:04:28.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.781]                 }
[16:04:28.781]                 ...future.workdir <- getwd()
[16:04:28.781]             }
[16:04:28.781]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.781]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.781]         }
[16:04:28.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.781]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.781]             base::names(...future.oldOptions))
[16:04:28.781]     }
[16:04:28.781]     if (FALSE) {
[16:04:28.781]     }
[16:04:28.781]     else {
[16:04:28.781]         if (TRUE) {
[16:04:28.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.781]                 open = "w")
[16:04:28.781]         }
[16:04:28.781]         else {
[16:04:28.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.781]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.781]         }
[16:04:28.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.781]             base::sink(type = "output", split = FALSE)
[16:04:28.781]             base::close(...future.stdout)
[16:04:28.781]         }, add = TRUE)
[16:04:28.781]     }
[16:04:28.781]     ...future.frame <- base::sys.nframe()
[16:04:28.781]     ...future.conditions <- base::list()
[16:04:28.781]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.781]     if (FALSE) {
[16:04:28.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.781]     }
[16:04:28.781]     ...future.result <- base::tryCatch({
[16:04:28.781]         base::withCallingHandlers({
[16:04:28.781]             ...future.value <- base::withVisible(base::local({
[16:04:28.781]                 ...future.makeSendCondition <- base::local({
[16:04:28.781]                   sendCondition <- NULL
[16:04:28.781]                   function(frame = 1L) {
[16:04:28.781]                     if (is.function(sendCondition)) 
[16:04:28.781]                       return(sendCondition)
[16:04:28.781]                     ns <- getNamespace("parallel")
[16:04:28.781]                     if (exists("sendData", mode = "function", 
[16:04:28.781]                       envir = ns)) {
[16:04:28.781]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.781]                         envir = ns)
[16:04:28.781]                       envir <- sys.frame(frame)
[16:04:28.781]                       master <- NULL
[16:04:28.781]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.781]                         !identical(envir, emptyenv())) {
[16:04:28.781]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.781]                           inherits = FALSE)) {
[16:04:28.781]                           master <- get("master", mode = "list", 
[16:04:28.781]                             envir = envir, inherits = FALSE)
[16:04:28.781]                           if (inherits(master, c("SOCKnode", 
[16:04:28.781]                             "SOCK0node"))) {
[16:04:28.781]                             sendCondition <<- function(cond) {
[16:04:28.781]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.781]                                 success = TRUE)
[16:04:28.781]                               parallel_sendData(master, data)
[16:04:28.781]                             }
[16:04:28.781]                             return(sendCondition)
[16:04:28.781]                           }
[16:04:28.781]                         }
[16:04:28.781]                         frame <- frame + 1L
[16:04:28.781]                         envir <- sys.frame(frame)
[16:04:28.781]                       }
[16:04:28.781]                     }
[16:04:28.781]                     sendCondition <<- function(cond) NULL
[16:04:28.781]                   }
[16:04:28.781]                 })
[16:04:28.781]                 withCallingHandlers({
[16:04:28.781]                   {
[16:04:28.781]                     42
[16:04:28.781]                   }
[16:04:28.781]                 }, immediateCondition = function(cond) {
[16:04:28.781]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.781]                   sendCondition(cond)
[16:04:28.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.781]                   {
[16:04:28.781]                     inherits <- base::inherits
[16:04:28.781]                     invokeRestart <- base::invokeRestart
[16:04:28.781]                     is.null <- base::is.null
[16:04:28.781]                     muffled <- FALSE
[16:04:28.781]                     if (inherits(cond, "message")) {
[16:04:28.781]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.781]                       if (muffled) 
[16:04:28.781]                         invokeRestart("muffleMessage")
[16:04:28.781]                     }
[16:04:28.781]                     else if (inherits(cond, "warning")) {
[16:04:28.781]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.781]                       if (muffled) 
[16:04:28.781]                         invokeRestart("muffleWarning")
[16:04:28.781]                     }
[16:04:28.781]                     else if (inherits(cond, "condition")) {
[16:04:28.781]                       if (!is.null(pattern)) {
[16:04:28.781]                         computeRestarts <- base::computeRestarts
[16:04:28.781]                         grepl <- base::grepl
[16:04:28.781]                         restarts <- computeRestarts(cond)
[16:04:28.781]                         for (restart in restarts) {
[16:04:28.781]                           name <- restart$name
[16:04:28.781]                           if (is.null(name)) 
[16:04:28.781]                             next
[16:04:28.781]                           if (!grepl(pattern, name)) 
[16:04:28.781]                             next
[16:04:28.781]                           invokeRestart(restart)
[16:04:28.781]                           muffled <- TRUE
[16:04:28.781]                           break
[16:04:28.781]                         }
[16:04:28.781]                       }
[16:04:28.781]                     }
[16:04:28.781]                     invisible(muffled)
[16:04:28.781]                   }
[16:04:28.781]                   muffleCondition(cond)
[16:04:28.781]                 })
[16:04:28.781]             }))
[16:04:28.781]             future::FutureResult(value = ...future.value$value, 
[16:04:28.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.781]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.781]                     ...future.globalenv.names))
[16:04:28.781]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.781]         }, condition = base::local({
[16:04:28.781]             c <- base::c
[16:04:28.781]             inherits <- base::inherits
[16:04:28.781]             invokeRestart <- base::invokeRestart
[16:04:28.781]             length <- base::length
[16:04:28.781]             list <- base::list
[16:04:28.781]             seq.int <- base::seq.int
[16:04:28.781]             signalCondition <- base::signalCondition
[16:04:28.781]             sys.calls <- base::sys.calls
[16:04:28.781]             `[[` <- base::`[[`
[16:04:28.781]             `+` <- base::`+`
[16:04:28.781]             `<<-` <- base::`<<-`
[16:04:28.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.781]                   3L)]
[16:04:28.781]             }
[16:04:28.781]             function(cond) {
[16:04:28.781]                 is_error <- inherits(cond, "error")
[16:04:28.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.781]                   NULL)
[16:04:28.781]                 if (is_error) {
[16:04:28.781]                   sessionInformation <- function() {
[16:04:28.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.781]                       search = base::search(), system = base::Sys.info())
[16:04:28.781]                   }
[16:04:28.781]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.781]                     cond$call), session = sessionInformation(), 
[16:04:28.781]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.781]                   signalCondition(cond)
[16:04:28.781]                 }
[16:04:28.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.781]                 "immediateCondition"))) {
[16:04:28.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.781]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.781]                   if (TRUE && !signal) {
[16:04:28.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.781]                     {
[16:04:28.781]                       inherits <- base::inherits
[16:04:28.781]                       invokeRestart <- base::invokeRestart
[16:04:28.781]                       is.null <- base::is.null
[16:04:28.781]                       muffled <- FALSE
[16:04:28.781]                       if (inherits(cond, "message")) {
[16:04:28.781]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.781]                         if (muffled) 
[16:04:28.781]                           invokeRestart("muffleMessage")
[16:04:28.781]                       }
[16:04:28.781]                       else if (inherits(cond, "warning")) {
[16:04:28.781]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.781]                         if (muffled) 
[16:04:28.781]                           invokeRestart("muffleWarning")
[16:04:28.781]                       }
[16:04:28.781]                       else if (inherits(cond, "condition")) {
[16:04:28.781]                         if (!is.null(pattern)) {
[16:04:28.781]                           computeRestarts <- base::computeRestarts
[16:04:28.781]                           grepl <- base::grepl
[16:04:28.781]                           restarts <- computeRestarts(cond)
[16:04:28.781]                           for (restart in restarts) {
[16:04:28.781]                             name <- restart$name
[16:04:28.781]                             if (is.null(name)) 
[16:04:28.781]                               next
[16:04:28.781]                             if (!grepl(pattern, name)) 
[16:04:28.781]                               next
[16:04:28.781]                             invokeRestart(restart)
[16:04:28.781]                             muffled <- TRUE
[16:04:28.781]                             break
[16:04:28.781]                           }
[16:04:28.781]                         }
[16:04:28.781]                       }
[16:04:28.781]                       invisible(muffled)
[16:04:28.781]                     }
[16:04:28.781]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.781]                   }
[16:04:28.781]                 }
[16:04:28.781]                 else {
[16:04:28.781]                   if (TRUE) {
[16:04:28.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.781]                     {
[16:04:28.781]                       inherits <- base::inherits
[16:04:28.781]                       invokeRestart <- base::invokeRestart
[16:04:28.781]                       is.null <- base::is.null
[16:04:28.781]                       muffled <- FALSE
[16:04:28.781]                       if (inherits(cond, "message")) {
[16:04:28.781]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.781]                         if (muffled) 
[16:04:28.781]                           invokeRestart("muffleMessage")
[16:04:28.781]                       }
[16:04:28.781]                       else if (inherits(cond, "warning")) {
[16:04:28.781]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.781]                         if (muffled) 
[16:04:28.781]                           invokeRestart("muffleWarning")
[16:04:28.781]                       }
[16:04:28.781]                       else if (inherits(cond, "condition")) {
[16:04:28.781]                         if (!is.null(pattern)) {
[16:04:28.781]                           computeRestarts <- base::computeRestarts
[16:04:28.781]                           grepl <- base::grepl
[16:04:28.781]                           restarts <- computeRestarts(cond)
[16:04:28.781]                           for (restart in restarts) {
[16:04:28.781]                             name <- restart$name
[16:04:28.781]                             if (is.null(name)) 
[16:04:28.781]                               next
[16:04:28.781]                             if (!grepl(pattern, name)) 
[16:04:28.781]                               next
[16:04:28.781]                             invokeRestart(restart)
[16:04:28.781]                             muffled <- TRUE
[16:04:28.781]                             break
[16:04:28.781]                           }
[16:04:28.781]                         }
[16:04:28.781]                       }
[16:04:28.781]                       invisible(muffled)
[16:04:28.781]                     }
[16:04:28.781]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.781]                   }
[16:04:28.781]                 }
[16:04:28.781]             }
[16:04:28.781]         }))
[16:04:28.781]     }, error = function(ex) {
[16:04:28.781]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.781]                 ...future.rng), started = ...future.startTime, 
[16:04:28.781]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.781]             version = "1.8"), class = "FutureResult")
[16:04:28.781]     }, finally = {
[16:04:28.781]         if (!identical(...future.workdir, getwd())) 
[16:04:28.781]             setwd(...future.workdir)
[16:04:28.781]         {
[16:04:28.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.781]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.781]             }
[16:04:28.781]             base::options(...future.oldOptions)
[16:04:28.781]             if (.Platform$OS.type == "windows") {
[16:04:28.781]                 old_names <- names(...future.oldEnvVars)
[16:04:28.781]                 envs <- base::Sys.getenv()
[16:04:28.781]                 names <- names(envs)
[16:04:28.781]                 common <- intersect(names, old_names)
[16:04:28.781]                 added <- setdiff(names, old_names)
[16:04:28.781]                 removed <- setdiff(old_names, names)
[16:04:28.781]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.781]                   envs[common]]
[16:04:28.781]                 NAMES <- toupper(changed)
[16:04:28.781]                 args <- list()
[16:04:28.781]                 for (kk in seq_along(NAMES)) {
[16:04:28.781]                   name <- changed[[kk]]
[16:04:28.781]                   NAME <- NAMES[[kk]]
[16:04:28.781]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.781]                     next
[16:04:28.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.781]                 }
[16:04:28.781]                 NAMES <- toupper(added)
[16:04:28.781]                 for (kk in seq_along(NAMES)) {
[16:04:28.781]                   name <- added[[kk]]
[16:04:28.781]                   NAME <- NAMES[[kk]]
[16:04:28.781]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.781]                     next
[16:04:28.781]                   args[[name]] <- ""
[16:04:28.781]                 }
[16:04:28.781]                 NAMES <- toupper(removed)
[16:04:28.781]                 for (kk in seq_along(NAMES)) {
[16:04:28.781]                   name <- removed[[kk]]
[16:04:28.781]                   NAME <- NAMES[[kk]]
[16:04:28.781]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.781]                     next
[16:04:28.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.781]                 }
[16:04:28.781]                 if (length(args) > 0) 
[16:04:28.781]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.781]             }
[16:04:28.781]             else {
[16:04:28.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.781]             }
[16:04:28.781]             {
[16:04:28.781]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.781]                   0L) {
[16:04:28.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.781]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.781]                   base::options(opts)
[16:04:28.781]                 }
[16:04:28.781]                 {
[16:04:28.781]                   {
[16:04:28.781]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.781]                     NULL
[16:04:28.781]                   }
[16:04:28.781]                   options(future.plan = NULL)
[16:04:28.781]                   if (is.na(NA_character_)) 
[16:04:28.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.781]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.781]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.781]                     envir = parent.frame()) 
[16:04:28.781]                   {
[16:04:28.781]                     if (is.function(workers)) 
[16:04:28.781]                       workers <- workers()
[16:04:28.781]                     workers <- structure(as.integer(workers), 
[16:04:28.781]                       class = class(workers))
[16:04:28.781]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.781]                       workers >= 1)
[16:04:28.781]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.781]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.781]                     }
[16:04:28.781]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.781]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.781]                       envir = envir)
[16:04:28.781]                     if (!future$lazy) 
[16:04:28.781]                       future <- run(future)
[16:04:28.781]                     invisible(future)
[16:04:28.781]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.781]                 }
[16:04:28.781]             }
[16:04:28.781]         }
[16:04:28.781]     })
[16:04:28.781]     if (TRUE) {
[16:04:28.781]         base::sink(type = "output", split = FALSE)
[16:04:28.781]         if (TRUE) {
[16:04:28.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.781]         }
[16:04:28.781]         else {
[16:04:28.781]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.781]         }
[16:04:28.781]         base::close(...future.stdout)
[16:04:28.781]         ...future.stdout <- NULL
[16:04:28.781]     }
[16:04:28.781]     ...future.result$conditions <- ...future.conditions
[16:04:28.781]     ...future.result$finished <- base::Sys.time()
[16:04:28.781]     ...future.result
[16:04:28.781] }
[16:04:28.784] MultisessionFuture started
[16:04:28.784] - Launch lazy future ... done
[16:04:28.785] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.796] result() for ClusterFuture ...
[16:04:28.796] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.796] - Validating connection of MultisessionFuture
[16:04:28.831] - received message: FutureResult
[16:04:28.831] - Received FutureResult
[16:04:28.832] - Erased future from FutureRegistry
[16:04:28.832] result() for ClusterFuture ...
[16:04:28.832] - result already collected: FutureResult
[16:04:28.832] result() for ClusterFuture ... done
[16:04:28.832] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.832] result() for ClusterFuture ... done
[16:04:28.832] result() for ClusterFuture ...
[16:04:28.832] - result already collected: FutureResult
[16:04:28.832] result() for ClusterFuture ... done
[16:04:28.836] getGlobalsAndPackages() ...
[16:04:28.836] 
[16:04:28.836] - globals: [0] <none>
[16:04:28.836] getGlobalsAndPackages() ... DONE
[16:04:28.847] Packages needed by the future expression (n = 0): <none>
[16:04:28.847] Packages needed by future strategies (n = 0): <none>
[16:04:28.850] {
[16:04:28.850]     {
[16:04:28.850]         {
[16:04:28.850]             ...future.startTime <- base::Sys.time()
[16:04:28.850]             {
[16:04:28.850]                 {
[16:04:28.850]                   {
[16:04:28.850]                     {
[16:04:28.850]                       base::local({
[16:04:28.850]                         has_future <- base::requireNamespace("future", 
[16:04:28.850]                           quietly = TRUE)
[16:04:28.850]                         if (has_future) {
[16:04:28.850]                           ns <- base::getNamespace("future")
[16:04:28.850]                           version <- ns[[".package"]][["version"]]
[16:04:28.850]                           if (is.null(version)) 
[16:04:28.850]                             version <- utils::packageVersion("future")
[16:04:28.850]                         }
[16:04:28.850]                         else {
[16:04:28.850]                           version <- NULL
[16:04:28.850]                         }
[16:04:28.850]                         if (!has_future || version < "1.8.0") {
[16:04:28.850]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.850]                             "", base::R.version$version.string), 
[16:04:28.850]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.850]                               "release", "version")], collapse = " "), 
[16:04:28.850]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.850]                             info)
[16:04:28.850]                           info <- base::paste(info, collapse = "; ")
[16:04:28.850]                           if (!has_future) {
[16:04:28.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.850]                               info)
[16:04:28.850]                           }
[16:04:28.850]                           else {
[16:04:28.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.850]                               info, version)
[16:04:28.850]                           }
[16:04:28.850]                           base::stop(msg)
[16:04:28.850]                         }
[16:04:28.850]                       })
[16:04:28.850]                     }
[16:04:28.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.850]                     base::options(mc.cores = 1L)
[16:04:28.850]                   }
[16:04:28.850]                   options(future.plan = NULL)
[16:04:28.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.850]                 }
[16:04:28.850]                 ...future.workdir <- getwd()
[16:04:28.850]             }
[16:04:28.850]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.850]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.850]         }
[16:04:28.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.850]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.850]             base::names(...future.oldOptions))
[16:04:28.850]     }
[16:04:28.850]     if (FALSE) {
[16:04:28.850]     }
[16:04:28.850]     else {
[16:04:28.850]         if (TRUE) {
[16:04:28.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.850]                 open = "w")
[16:04:28.850]         }
[16:04:28.850]         else {
[16:04:28.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.850]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.850]         }
[16:04:28.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.850]             base::sink(type = "output", split = FALSE)
[16:04:28.850]             base::close(...future.stdout)
[16:04:28.850]         }, add = TRUE)
[16:04:28.850]     }
[16:04:28.850]     ...future.frame <- base::sys.nframe()
[16:04:28.850]     ...future.conditions <- base::list()
[16:04:28.850]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.850]     if (FALSE) {
[16:04:28.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.850]     }
[16:04:28.850]     ...future.result <- base::tryCatch({
[16:04:28.850]         base::withCallingHandlers({
[16:04:28.850]             ...future.value <- base::withVisible(base::local({
[16:04:28.850]                 ...future.makeSendCondition <- base::local({
[16:04:28.850]                   sendCondition <- NULL
[16:04:28.850]                   function(frame = 1L) {
[16:04:28.850]                     if (is.function(sendCondition)) 
[16:04:28.850]                       return(sendCondition)
[16:04:28.850]                     ns <- getNamespace("parallel")
[16:04:28.850]                     if (exists("sendData", mode = "function", 
[16:04:28.850]                       envir = ns)) {
[16:04:28.850]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.850]                         envir = ns)
[16:04:28.850]                       envir <- sys.frame(frame)
[16:04:28.850]                       master <- NULL
[16:04:28.850]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.850]                         !identical(envir, emptyenv())) {
[16:04:28.850]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.850]                           inherits = FALSE)) {
[16:04:28.850]                           master <- get("master", mode = "list", 
[16:04:28.850]                             envir = envir, inherits = FALSE)
[16:04:28.850]                           if (inherits(master, c("SOCKnode", 
[16:04:28.850]                             "SOCK0node"))) {
[16:04:28.850]                             sendCondition <<- function(cond) {
[16:04:28.850]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.850]                                 success = TRUE)
[16:04:28.850]                               parallel_sendData(master, data)
[16:04:28.850]                             }
[16:04:28.850]                             return(sendCondition)
[16:04:28.850]                           }
[16:04:28.850]                         }
[16:04:28.850]                         frame <- frame + 1L
[16:04:28.850]                         envir <- sys.frame(frame)
[16:04:28.850]                       }
[16:04:28.850]                     }
[16:04:28.850]                     sendCondition <<- function(cond) NULL
[16:04:28.850]                   }
[16:04:28.850]                 })
[16:04:28.850]                 withCallingHandlers({
[16:04:28.850]                   42
[16:04:28.850]                 }, immediateCondition = function(cond) {
[16:04:28.850]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.850]                   sendCondition(cond)
[16:04:28.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.850]                   {
[16:04:28.850]                     inherits <- base::inherits
[16:04:28.850]                     invokeRestart <- base::invokeRestart
[16:04:28.850]                     is.null <- base::is.null
[16:04:28.850]                     muffled <- FALSE
[16:04:28.850]                     if (inherits(cond, "message")) {
[16:04:28.850]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.850]                       if (muffled) 
[16:04:28.850]                         invokeRestart("muffleMessage")
[16:04:28.850]                     }
[16:04:28.850]                     else if (inherits(cond, "warning")) {
[16:04:28.850]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.850]                       if (muffled) 
[16:04:28.850]                         invokeRestart("muffleWarning")
[16:04:28.850]                     }
[16:04:28.850]                     else if (inherits(cond, "condition")) {
[16:04:28.850]                       if (!is.null(pattern)) {
[16:04:28.850]                         computeRestarts <- base::computeRestarts
[16:04:28.850]                         grepl <- base::grepl
[16:04:28.850]                         restarts <- computeRestarts(cond)
[16:04:28.850]                         for (restart in restarts) {
[16:04:28.850]                           name <- restart$name
[16:04:28.850]                           if (is.null(name)) 
[16:04:28.850]                             next
[16:04:28.850]                           if (!grepl(pattern, name)) 
[16:04:28.850]                             next
[16:04:28.850]                           invokeRestart(restart)
[16:04:28.850]                           muffled <- TRUE
[16:04:28.850]                           break
[16:04:28.850]                         }
[16:04:28.850]                       }
[16:04:28.850]                     }
[16:04:28.850]                     invisible(muffled)
[16:04:28.850]                   }
[16:04:28.850]                   muffleCondition(cond)
[16:04:28.850]                 })
[16:04:28.850]             }))
[16:04:28.850]             future::FutureResult(value = ...future.value$value, 
[16:04:28.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.850]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.850]                     ...future.globalenv.names))
[16:04:28.850]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.850]         }, condition = base::local({
[16:04:28.850]             c <- base::c
[16:04:28.850]             inherits <- base::inherits
[16:04:28.850]             invokeRestart <- base::invokeRestart
[16:04:28.850]             length <- base::length
[16:04:28.850]             list <- base::list
[16:04:28.850]             seq.int <- base::seq.int
[16:04:28.850]             signalCondition <- base::signalCondition
[16:04:28.850]             sys.calls <- base::sys.calls
[16:04:28.850]             `[[` <- base::`[[`
[16:04:28.850]             `+` <- base::`+`
[16:04:28.850]             `<<-` <- base::`<<-`
[16:04:28.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.850]                   3L)]
[16:04:28.850]             }
[16:04:28.850]             function(cond) {
[16:04:28.850]                 is_error <- inherits(cond, "error")
[16:04:28.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.850]                   NULL)
[16:04:28.850]                 if (is_error) {
[16:04:28.850]                   sessionInformation <- function() {
[16:04:28.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.850]                       search = base::search(), system = base::Sys.info())
[16:04:28.850]                   }
[16:04:28.850]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.850]                     cond$call), session = sessionInformation(), 
[16:04:28.850]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.850]                   signalCondition(cond)
[16:04:28.850]                 }
[16:04:28.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.850]                 "immediateCondition"))) {
[16:04:28.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.850]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.850]                   if (TRUE && !signal) {
[16:04:28.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.850]                     {
[16:04:28.850]                       inherits <- base::inherits
[16:04:28.850]                       invokeRestart <- base::invokeRestart
[16:04:28.850]                       is.null <- base::is.null
[16:04:28.850]                       muffled <- FALSE
[16:04:28.850]                       if (inherits(cond, "message")) {
[16:04:28.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.850]                         if (muffled) 
[16:04:28.850]                           invokeRestart("muffleMessage")
[16:04:28.850]                       }
[16:04:28.850]                       else if (inherits(cond, "warning")) {
[16:04:28.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.850]                         if (muffled) 
[16:04:28.850]                           invokeRestart("muffleWarning")
[16:04:28.850]                       }
[16:04:28.850]                       else if (inherits(cond, "condition")) {
[16:04:28.850]                         if (!is.null(pattern)) {
[16:04:28.850]                           computeRestarts <- base::computeRestarts
[16:04:28.850]                           grepl <- base::grepl
[16:04:28.850]                           restarts <- computeRestarts(cond)
[16:04:28.850]                           for (restart in restarts) {
[16:04:28.850]                             name <- restart$name
[16:04:28.850]                             if (is.null(name)) 
[16:04:28.850]                               next
[16:04:28.850]                             if (!grepl(pattern, name)) 
[16:04:28.850]                               next
[16:04:28.850]                             invokeRestart(restart)
[16:04:28.850]                             muffled <- TRUE
[16:04:28.850]                             break
[16:04:28.850]                           }
[16:04:28.850]                         }
[16:04:28.850]                       }
[16:04:28.850]                       invisible(muffled)
[16:04:28.850]                     }
[16:04:28.850]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.850]                   }
[16:04:28.850]                 }
[16:04:28.850]                 else {
[16:04:28.850]                   if (TRUE) {
[16:04:28.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.850]                     {
[16:04:28.850]                       inherits <- base::inherits
[16:04:28.850]                       invokeRestart <- base::invokeRestart
[16:04:28.850]                       is.null <- base::is.null
[16:04:28.850]                       muffled <- FALSE
[16:04:28.850]                       if (inherits(cond, "message")) {
[16:04:28.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.850]                         if (muffled) 
[16:04:28.850]                           invokeRestart("muffleMessage")
[16:04:28.850]                       }
[16:04:28.850]                       else if (inherits(cond, "warning")) {
[16:04:28.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.850]                         if (muffled) 
[16:04:28.850]                           invokeRestart("muffleWarning")
[16:04:28.850]                       }
[16:04:28.850]                       else if (inherits(cond, "condition")) {
[16:04:28.850]                         if (!is.null(pattern)) {
[16:04:28.850]                           computeRestarts <- base::computeRestarts
[16:04:28.850]                           grepl <- base::grepl
[16:04:28.850]                           restarts <- computeRestarts(cond)
[16:04:28.850]                           for (restart in restarts) {
[16:04:28.850]                             name <- restart$name
[16:04:28.850]                             if (is.null(name)) 
[16:04:28.850]                               next
[16:04:28.850]                             if (!grepl(pattern, name)) 
[16:04:28.850]                               next
[16:04:28.850]                             invokeRestart(restart)
[16:04:28.850]                             muffled <- TRUE
[16:04:28.850]                             break
[16:04:28.850]                           }
[16:04:28.850]                         }
[16:04:28.850]                       }
[16:04:28.850]                       invisible(muffled)
[16:04:28.850]                     }
[16:04:28.850]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.850]                   }
[16:04:28.850]                 }
[16:04:28.850]             }
[16:04:28.850]         }))
[16:04:28.850]     }, error = function(ex) {
[16:04:28.850]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.850]                 ...future.rng), started = ...future.startTime, 
[16:04:28.850]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.850]             version = "1.8"), class = "FutureResult")
[16:04:28.850]     }, finally = {
[16:04:28.850]         if (!identical(...future.workdir, getwd())) 
[16:04:28.850]             setwd(...future.workdir)
[16:04:28.850]         {
[16:04:28.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.850]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.850]             }
[16:04:28.850]             base::options(...future.oldOptions)
[16:04:28.850]             if (.Platform$OS.type == "windows") {
[16:04:28.850]                 old_names <- names(...future.oldEnvVars)
[16:04:28.850]                 envs <- base::Sys.getenv()
[16:04:28.850]                 names <- names(envs)
[16:04:28.850]                 common <- intersect(names, old_names)
[16:04:28.850]                 added <- setdiff(names, old_names)
[16:04:28.850]                 removed <- setdiff(old_names, names)
[16:04:28.850]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.850]                   envs[common]]
[16:04:28.850]                 NAMES <- toupper(changed)
[16:04:28.850]                 args <- list()
[16:04:28.850]                 for (kk in seq_along(NAMES)) {
[16:04:28.850]                   name <- changed[[kk]]
[16:04:28.850]                   NAME <- NAMES[[kk]]
[16:04:28.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.850]                     next
[16:04:28.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.850]                 }
[16:04:28.850]                 NAMES <- toupper(added)
[16:04:28.850]                 for (kk in seq_along(NAMES)) {
[16:04:28.850]                   name <- added[[kk]]
[16:04:28.850]                   NAME <- NAMES[[kk]]
[16:04:28.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.850]                     next
[16:04:28.850]                   args[[name]] <- ""
[16:04:28.850]                 }
[16:04:28.850]                 NAMES <- toupper(removed)
[16:04:28.850]                 for (kk in seq_along(NAMES)) {
[16:04:28.850]                   name <- removed[[kk]]
[16:04:28.850]                   NAME <- NAMES[[kk]]
[16:04:28.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.850]                     next
[16:04:28.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.850]                 }
[16:04:28.850]                 if (length(args) > 0) 
[16:04:28.850]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.850]             }
[16:04:28.850]             else {
[16:04:28.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.850]             }
[16:04:28.850]             {
[16:04:28.850]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.850]                   0L) {
[16:04:28.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.850]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.850]                   base::options(opts)
[16:04:28.850]                 }
[16:04:28.850]                 {
[16:04:28.850]                   {
[16:04:28.850]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.850]                     NULL
[16:04:28.850]                   }
[16:04:28.850]                   options(future.plan = NULL)
[16:04:28.850]                   if (is.na(NA_character_)) 
[16:04:28.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.850]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.850]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.850]                     envir = parent.frame()) 
[16:04:28.850]                   {
[16:04:28.850]                     if (is.function(workers)) 
[16:04:28.850]                       workers <- workers()
[16:04:28.850]                     workers <- structure(as.integer(workers), 
[16:04:28.850]                       class = class(workers))
[16:04:28.850]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.850]                       workers >= 1)
[16:04:28.850]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.850]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.850]                     }
[16:04:28.850]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.850]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.850]                       envir = envir)
[16:04:28.850]                     if (!future$lazy) 
[16:04:28.850]                       future <- run(future)
[16:04:28.850]                     invisible(future)
[16:04:28.850]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.850]                 }
[16:04:28.850]             }
[16:04:28.850]         }
[16:04:28.850]     })
[16:04:28.850]     if (TRUE) {
[16:04:28.850]         base::sink(type = "output", split = FALSE)
[16:04:28.850]         if (TRUE) {
[16:04:28.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.850]         }
[16:04:28.850]         else {
[16:04:28.850]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.850]         }
[16:04:28.850]         base::close(...future.stdout)
[16:04:28.850]         ...future.stdout <- NULL
[16:04:28.850]     }
[16:04:28.850]     ...future.result$conditions <- ...future.conditions
[16:04:28.850]     ...future.result$finished <- base::Sys.time()
[16:04:28.850]     ...future.result
[16:04:28.850] }
[16:04:28.853] MultisessionFuture started
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.864] result() for ClusterFuture ...
[16:04:28.864] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.864] - Validating connection of MultisessionFuture
[16:04:28.899] - received message: FutureResult
[16:04:28.899] - Received FutureResult
[16:04:28.899] - Erased future from FutureRegistry
[16:04:28.900] result() for ClusterFuture ...
[16:04:28.900] - result already collected: FutureResult
[16:04:28.900] result() for ClusterFuture ... done
[16:04:28.900] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.900] result() for ClusterFuture ... done
[16:04:28.900] result() for ClusterFuture ...
[16:04:28.900] - result already collected: FutureResult
[16:04:28.900] result() for ClusterFuture ... done
[16:04:28.900] getGlobalsAndPackages() ...
[16:04:28.900] Searching for globals...
[16:04:28.901] 
[16:04:28.901] Searching for globals ... DONE
[16:04:28.901] - globals: [0] <none>
[16:04:28.901] getGlobalsAndPackages() ... DONE
[16:04:28.901] run() for ‘Future’ ...
[16:04:28.901] - state: ‘created’
[16:04:28.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:28.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:28.915]   - Field: ‘node’
[16:04:28.915]   - Field: ‘label’
[16:04:28.915]   - Field: ‘local’
[16:04:28.915]   - Field: ‘owner’
[16:04:28.915]   - Field: ‘envir’
[16:04:28.916]   - Field: ‘workers’
[16:04:28.916]   - Field: ‘packages’
[16:04:28.916]   - Field: ‘gc’
[16:04:28.916]   - Field: ‘conditions’
[16:04:28.916]   - Field: ‘persistent’
[16:04:28.916]   - Field: ‘expr’
[16:04:28.916]   - Field: ‘uuid’
[16:04:28.916]   - Field: ‘seed’
[16:04:28.916]   - Field: ‘version’
[16:04:28.916]   - Field: ‘result’
[16:04:28.916]   - Field: ‘asynchronous’
[16:04:28.917]   - Field: ‘calls’
[16:04:28.917]   - Field: ‘globals’
[16:04:28.917]   - Field: ‘stdout’
[16:04:28.917]   - Field: ‘earlySignal’
[16:04:28.917]   - Field: ‘lazy’
[16:04:28.917]   - Field: ‘state’
[16:04:28.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:28.917] - Launch lazy future ...
[16:04:28.917] Packages needed by the future expression (n = 0): <none>
[16:04:28.918] Packages needed by future strategies (n = 0): <none>
[16:04:28.918] {
[16:04:28.918]     {
[16:04:28.918]         {
[16:04:28.918]             ...future.startTime <- base::Sys.time()
[16:04:28.918]             {
[16:04:28.918]                 {
[16:04:28.918]                   {
[16:04:28.918]                     {
[16:04:28.918]                       base::local({
[16:04:28.918]                         has_future <- base::requireNamespace("future", 
[16:04:28.918]                           quietly = TRUE)
[16:04:28.918]                         if (has_future) {
[16:04:28.918]                           ns <- base::getNamespace("future")
[16:04:28.918]                           version <- ns[[".package"]][["version"]]
[16:04:28.918]                           if (is.null(version)) 
[16:04:28.918]                             version <- utils::packageVersion("future")
[16:04:28.918]                         }
[16:04:28.918]                         else {
[16:04:28.918]                           version <- NULL
[16:04:28.918]                         }
[16:04:28.918]                         if (!has_future || version < "1.8.0") {
[16:04:28.918]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.918]                             "", base::R.version$version.string), 
[16:04:28.918]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.918]                               "release", "version")], collapse = " "), 
[16:04:28.918]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.918]                             info)
[16:04:28.918]                           info <- base::paste(info, collapse = "; ")
[16:04:28.918]                           if (!has_future) {
[16:04:28.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.918]                               info)
[16:04:28.918]                           }
[16:04:28.918]                           else {
[16:04:28.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.918]                               info, version)
[16:04:28.918]                           }
[16:04:28.918]                           base::stop(msg)
[16:04:28.918]                         }
[16:04:28.918]                       })
[16:04:28.918]                     }
[16:04:28.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.918]                     base::options(mc.cores = 1L)
[16:04:28.918]                   }
[16:04:28.918]                   options(future.plan = NULL)
[16:04:28.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.918]                 }
[16:04:28.918]                 ...future.workdir <- getwd()
[16:04:28.918]             }
[16:04:28.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.918]         }
[16:04:28.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.918]             base::names(...future.oldOptions))
[16:04:28.918]     }
[16:04:28.918]     if (FALSE) {
[16:04:28.918]     }
[16:04:28.918]     else {
[16:04:28.918]         if (TRUE) {
[16:04:28.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.918]                 open = "w")
[16:04:28.918]         }
[16:04:28.918]         else {
[16:04:28.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.918]         }
[16:04:28.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.918]             base::sink(type = "output", split = FALSE)
[16:04:28.918]             base::close(...future.stdout)
[16:04:28.918]         }, add = TRUE)
[16:04:28.918]     }
[16:04:28.918]     ...future.frame <- base::sys.nframe()
[16:04:28.918]     ...future.conditions <- base::list()
[16:04:28.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.918]     if (FALSE) {
[16:04:28.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.918]     }
[16:04:28.918]     ...future.result <- base::tryCatch({
[16:04:28.918]         base::withCallingHandlers({
[16:04:28.918]             ...future.value <- base::withVisible(base::local({
[16:04:28.918]                 ...future.makeSendCondition <- base::local({
[16:04:28.918]                   sendCondition <- NULL
[16:04:28.918]                   function(frame = 1L) {
[16:04:28.918]                     if (is.function(sendCondition)) 
[16:04:28.918]                       return(sendCondition)
[16:04:28.918]                     ns <- getNamespace("parallel")
[16:04:28.918]                     if (exists("sendData", mode = "function", 
[16:04:28.918]                       envir = ns)) {
[16:04:28.918]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.918]                         envir = ns)
[16:04:28.918]                       envir <- sys.frame(frame)
[16:04:28.918]                       master <- NULL
[16:04:28.918]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.918]                         !identical(envir, emptyenv())) {
[16:04:28.918]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.918]                           inherits = FALSE)) {
[16:04:28.918]                           master <- get("master", mode = "list", 
[16:04:28.918]                             envir = envir, inherits = FALSE)
[16:04:28.918]                           if (inherits(master, c("SOCKnode", 
[16:04:28.918]                             "SOCK0node"))) {
[16:04:28.918]                             sendCondition <<- function(cond) {
[16:04:28.918]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.918]                                 success = TRUE)
[16:04:28.918]                               parallel_sendData(master, data)
[16:04:28.918]                             }
[16:04:28.918]                             return(sendCondition)
[16:04:28.918]                           }
[16:04:28.918]                         }
[16:04:28.918]                         frame <- frame + 1L
[16:04:28.918]                         envir <- sys.frame(frame)
[16:04:28.918]                       }
[16:04:28.918]                     }
[16:04:28.918]                     sendCondition <<- function(cond) NULL
[16:04:28.918]                   }
[16:04:28.918]                 })
[16:04:28.918]                 withCallingHandlers({
[16:04:28.918]                   42
[16:04:28.918]                 }, immediateCondition = function(cond) {
[16:04:28.918]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.918]                   sendCondition(cond)
[16:04:28.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.918]                   {
[16:04:28.918]                     inherits <- base::inherits
[16:04:28.918]                     invokeRestart <- base::invokeRestart
[16:04:28.918]                     is.null <- base::is.null
[16:04:28.918]                     muffled <- FALSE
[16:04:28.918]                     if (inherits(cond, "message")) {
[16:04:28.918]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.918]                       if (muffled) 
[16:04:28.918]                         invokeRestart("muffleMessage")
[16:04:28.918]                     }
[16:04:28.918]                     else if (inherits(cond, "warning")) {
[16:04:28.918]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.918]                       if (muffled) 
[16:04:28.918]                         invokeRestart("muffleWarning")
[16:04:28.918]                     }
[16:04:28.918]                     else if (inherits(cond, "condition")) {
[16:04:28.918]                       if (!is.null(pattern)) {
[16:04:28.918]                         computeRestarts <- base::computeRestarts
[16:04:28.918]                         grepl <- base::grepl
[16:04:28.918]                         restarts <- computeRestarts(cond)
[16:04:28.918]                         for (restart in restarts) {
[16:04:28.918]                           name <- restart$name
[16:04:28.918]                           if (is.null(name)) 
[16:04:28.918]                             next
[16:04:28.918]                           if (!grepl(pattern, name)) 
[16:04:28.918]                             next
[16:04:28.918]                           invokeRestart(restart)
[16:04:28.918]                           muffled <- TRUE
[16:04:28.918]                           break
[16:04:28.918]                         }
[16:04:28.918]                       }
[16:04:28.918]                     }
[16:04:28.918]                     invisible(muffled)
[16:04:28.918]                   }
[16:04:28.918]                   muffleCondition(cond)
[16:04:28.918]                 })
[16:04:28.918]             }))
[16:04:28.918]             future::FutureResult(value = ...future.value$value, 
[16:04:28.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.918]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.918]                     ...future.globalenv.names))
[16:04:28.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.918]         }, condition = base::local({
[16:04:28.918]             c <- base::c
[16:04:28.918]             inherits <- base::inherits
[16:04:28.918]             invokeRestart <- base::invokeRestart
[16:04:28.918]             length <- base::length
[16:04:28.918]             list <- base::list
[16:04:28.918]             seq.int <- base::seq.int
[16:04:28.918]             signalCondition <- base::signalCondition
[16:04:28.918]             sys.calls <- base::sys.calls
[16:04:28.918]             `[[` <- base::`[[`
[16:04:28.918]             `+` <- base::`+`
[16:04:28.918]             `<<-` <- base::`<<-`
[16:04:28.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.918]                   3L)]
[16:04:28.918]             }
[16:04:28.918]             function(cond) {
[16:04:28.918]                 is_error <- inherits(cond, "error")
[16:04:28.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.918]                   NULL)
[16:04:28.918]                 if (is_error) {
[16:04:28.918]                   sessionInformation <- function() {
[16:04:28.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.918]                       search = base::search(), system = base::Sys.info())
[16:04:28.918]                   }
[16:04:28.918]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.918]                     cond$call), session = sessionInformation(), 
[16:04:28.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.918]                   signalCondition(cond)
[16:04:28.918]                 }
[16:04:28.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.918]                 "immediateCondition"))) {
[16:04:28.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.918]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.918]                   if (TRUE && !signal) {
[16:04:28.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.918]                     {
[16:04:28.918]                       inherits <- base::inherits
[16:04:28.918]                       invokeRestart <- base::invokeRestart
[16:04:28.918]                       is.null <- base::is.null
[16:04:28.918]                       muffled <- FALSE
[16:04:28.918]                       if (inherits(cond, "message")) {
[16:04:28.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.918]                         if (muffled) 
[16:04:28.918]                           invokeRestart("muffleMessage")
[16:04:28.918]                       }
[16:04:28.918]                       else if (inherits(cond, "warning")) {
[16:04:28.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.918]                         if (muffled) 
[16:04:28.918]                           invokeRestart("muffleWarning")
[16:04:28.918]                       }
[16:04:28.918]                       else if (inherits(cond, "condition")) {
[16:04:28.918]                         if (!is.null(pattern)) {
[16:04:28.918]                           computeRestarts <- base::computeRestarts
[16:04:28.918]                           grepl <- base::grepl
[16:04:28.918]                           restarts <- computeRestarts(cond)
[16:04:28.918]                           for (restart in restarts) {
[16:04:28.918]                             name <- restart$name
[16:04:28.918]                             if (is.null(name)) 
[16:04:28.918]                               next
[16:04:28.918]                             if (!grepl(pattern, name)) 
[16:04:28.918]                               next
[16:04:28.918]                             invokeRestart(restart)
[16:04:28.918]                             muffled <- TRUE
[16:04:28.918]                             break
[16:04:28.918]                           }
[16:04:28.918]                         }
[16:04:28.918]                       }
[16:04:28.918]                       invisible(muffled)
[16:04:28.918]                     }
[16:04:28.918]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.918]                   }
[16:04:28.918]                 }
[16:04:28.918]                 else {
[16:04:28.918]                   if (TRUE) {
[16:04:28.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.918]                     {
[16:04:28.918]                       inherits <- base::inherits
[16:04:28.918]                       invokeRestart <- base::invokeRestart
[16:04:28.918]                       is.null <- base::is.null
[16:04:28.918]                       muffled <- FALSE
[16:04:28.918]                       if (inherits(cond, "message")) {
[16:04:28.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.918]                         if (muffled) 
[16:04:28.918]                           invokeRestart("muffleMessage")
[16:04:28.918]                       }
[16:04:28.918]                       else if (inherits(cond, "warning")) {
[16:04:28.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.918]                         if (muffled) 
[16:04:28.918]                           invokeRestart("muffleWarning")
[16:04:28.918]                       }
[16:04:28.918]                       else if (inherits(cond, "condition")) {
[16:04:28.918]                         if (!is.null(pattern)) {
[16:04:28.918]                           computeRestarts <- base::computeRestarts
[16:04:28.918]                           grepl <- base::grepl
[16:04:28.918]                           restarts <- computeRestarts(cond)
[16:04:28.918]                           for (restart in restarts) {
[16:04:28.918]                             name <- restart$name
[16:04:28.918]                             if (is.null(name)) 
[16:04:28.918]                               next
[16:04:28.918]                             if (!grepl(pattern, name)) 
[16:04:28.918]                               next
[16:04:28.918]                             invokeRestart(restart)
[16:04:28.918]                             muffled <- TRUE
[16:04:28.918]                             break
[16:04:28.918]                           }
[16:04:28.918]                         }
[16:04:28.918]                       }
[16:04:28.918]                       invisible(muffled)
[16:04:28.918]                     }
[16:04:28.918]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.918]                   }
[16:04:28.918]                 }
[16:04:28.918]             }
[16:04:28.918]         }))
[16:04:28.918]     }, error = function(ex) {
[16:04:28.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.918]                 ...future.rng), started = ...future.startTime, 
[16:04:28.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.918]             version = "1.8"), class = "FutureResult")
[16:04:28.918]     }, finally = {
[16:04:28.918]         if (!identical(...future.workdir, getwd())) 
[16:04:28.918]             setwd(...future.workdir)
[16:04:28.918]         {
[16:04:28.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.918]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.918]             }
[16:04:28.918]             base::options(...future.oldOptions)
[16:04:28.918]             if (.Platform$OS.type == "windows") {
[16:04:28.918]                 old_names <- names(...future.oldEnvVars)
[16:04:28.918]                 envs <- base::Sys.getenv()
[16:04:28.918]                 names <- names(envs)
[16:04:28.918]                 common <- intersect(names, old_names)
[16:04:28.918]                 added <- setdiff(names, old_names)
[16:04:28.918]                 removed <- setdiff(old_names, names)
[16:04:28.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.918]                   envs[common]]
[16:04:28.918]                 NAMES <- toupper(changed)
[16:04:28.918]                 args <- list()
[16:04:28.918]                 for (kk in seq_along(NAMES)) {
[16:04:28.918]                   name <- changed[[kk]]
[16:04:28.918]                   NAME <- NAMES[[kk]]
[16:04:28.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.918]                     next
[16:04:28.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.918]                 }
[16:04:28.918]                 NAMES <- toupper(added)
[16:04:28.918]                 for (kk in seq_along(NAMES)) {
[16:04:28.918]                   name <- added[[kk]]
[16:04:28.918]                   NAME <- NAMES[[kk]]
[16:04:28.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.918]                     next
[16:04:28.918]                   args[[name]] <- ""
[16:04:28.918]                 }
[16:04:28.918]                 NAMES <- toupper(removed)
[16:04:28.918]                 for (kk in seq_along(NAMES)) {
[16:04:28.918]                   name <- removed[[kk]]
[16:04:28.918]                   NAME <- NAMES[[kk]]
[16:04:28.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.918]                     next
[16:04:28.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.918]                 }
[16:04:28.918]                 if (length(args) > 0) 
[16:04:28.918]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.918]             }
[16:04:28.918]             else {
[16:04:28.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.918]             }
[16:04:28.918]             {
[16:04:28.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.918]                   0L) {
[16:04:28.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.918]                   base::options(opts)
[16:04:28.918]                 }
[16:04:28.918]                 {
[16:04:28.918]                   {
[16:04:28.918]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.918]                     NULL
[16:04:28.918]                   }
[16:04:28.918]                   options(future.plan = NULL)
[16:04:28.918]                   if (is.na(NA_character_)) 
[16:04:28.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.918]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.918]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.918]                     envir = parent.frame()) 
[16:04:28.918]                   {
[16:04:28.918]                     if (is.function(workers)) 
[16:04:28.918]                       workers <- workers()
[16:04:28.918]                     workers <- structure(as.integer(workers), 
[16:04:28.918]                       class = class(workers))
[16:04:28.918]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.918]                       workers >= 1)
[16:04:28.918]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.918]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.918]                     }
[16:04:28.918]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.918]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.918]                       envir = envir)
[16:04:28.918]                     if (!future$lazy) 
[16:04:28.918]                       future <- run(future)
[16:04:28.918]                     invisible(future)
[16:04:28.918]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.918]                 }
[16:04:28.918]             }
[16:04:28.918]         }
[16:04:28.918]     })
[16:04:28.918]     if (TRUE) {
[16:04:28.918]         base::sink(type = "output", split = FALSE)
[16:04:28.918]         if (TRUE) {
[16:04:28.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.918]         }
[16:04:28.918]         else {
[16:04:28.918]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.918]         }
[16:04:28.918]         base::close(...future.stdout)
[16:04:28.918]         ...future.stdout <- NULL
[16:04:28.918]     }
[16:04:28.918]     ...future.result$conditions <- ...future.conditions
[16:04:28.918]     ...future.result$finished <- base::Sys.time()
[16:04:28.918]     ...future.result
[16:04:28.918] }
[16:04:28.921] MultisessionFuture started
[16:04:28.921] - Launch lazy future ... done
[16:04:28.921] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.932] result() for ClusterFuture ...
[16:04:28.932] receiveMessageFromWorker() for ClusterFuture ...
[16:04:28.932] - Validating connection of MultisessionFuture
[16:04:28.967] - received message: FutureResult
[16:04:28.967] - Received FutureResult
[16:04:28.967] - Erased future from FutureRegistry
[16:04:28.968] result() for ClusterFuture ...
[16:04:28.968] - result already collected: FutureResult
[16:04:28.968] result() for ClusterFuture ... done
[16:04:28.968] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:28.968] result() for ClusterFuture ... done
[16:04:28.968] result() for ClusterFuture ...
[16:04:28.968] - result already collected: FutureResult
[16:04:28.968] result() for ClusterFuture ... done
[16:04:28.968] getGlobalsAndPackages() ...
[16:04:28.969] Searching for globals...
[16:04:28.969] - globals found: [1] ‘{’
[16:04:28.969] Searching for globals ... DONE
[16:04:28.969] Resolving globals: FALSE
[16:04:28.970] 
[16:04:28.970] 
[16:04:28.970] getGlobalsAndPackages() ... DONE
[16:04:28.970] run() for ‘Future’ ...
[16:04:28.970] - state: ‘created’
[16:04:28.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:28.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:28.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:28.984]   - Field: ‘node’
[16:04:28.984]   - Field: ‘label’
[16:04:28.984]   - Field: ‘local’
[16:04:28.984]   - Field: ‘owner’
[16:04:28.984]   - Field: ‘envir’
[16:04:28.984]   - Field: ‘workers’
[16:04:28.984]   - Field: ‘packages’
[16:04:28.984]   - Field: ‘gc’
[16:04:28.985]   - Field: ‘conditions’
[16:04:28.985]   - Field: ‘persistent’
[16:04:28.985]   - Field: ‘expr’
[16:04:28.985]   - Field: ‘uuid’
[16:04:28.985]   - Field: ‘seed’
[16:04:28.985]   - Field: ‘version’
[16:04:28.985]   - Field: ‘result’
[16:04:28.985]   - Field: ‘asynchronous’
[16:04:28.985]   - Field: ‘calls’
[16:04:28.985]   - Field: ‘globals’
[16:04:28.985]   - Field: ‘stdout’
[16:04:28.986]   - Field: ‘earlySignal’
[16:04:28.986]   - Field: ‘lazy’
[16:04:28.986]   - Field: ‘state’
[16:04:28.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:28.986] - Launch lazy future ...
[16:04:28.986] Packages needed by the future expression (n = 0): <none>
[16:04:28.986] Packages needed by future strategies (n = 0): <none>
[16:04:28.987] {
[16:04:28.987]     {
[16:04:28.987]         {
[16:04:28.987]             ...future.startTime <- base::Sys.time()
[16:04:28.987]             {
[16:04:28.987]                 {
[16:04:28.987]                   {
[16:04:28.987]                     {
[16:04:28.987]                       base::local({
[16:04:28.987]                         has_future <- base::requireNamespace("future", 
[16:04:28.987]                           quietly = TRUE)
[16:04:28.987]                         if (has_future) {
[16:04:28.987]                           ns <- base::getNamespace("future")
[16:04:28.987]                           version <- ns[[".package"]][["version"]]
[16:04:28.987]                           if (is.null(version)) 
[16:04:28.987]                             version <- utils::packageVersion("future")
[16:04:28.987]                         }
[16:04:28.987]                         else {
[16:04:28.987]                           version <- NULL
[16:04:28.987]                         }
[16:04:28.987]                         if (!has_future || version < "1.8.0") {
[16:04:28.987]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:28.987]                             "", base::R.version$version.string), 
[16:04:28.987]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:28.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:28.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:28.987]                               "release", "version")], collapse = " "), 
[16:04:28.987]                             hostname = base::Sys.info()[["nodename"]])
[16:04:28.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:28.987]                             info)
[16:04:28.987]                           info <- base::paste(info, collapse = "; ")
[16:04:28.987]                           if (!has_future) {
[16:04:28.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:28.987]                               info)
[16:04:28.987]                           }
[16:04:28.987]                           else {
[16:04:28.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:28.987]                               info, version)
[16:04:28.987]                           }
[16:04:28.987]                           base::stop(msg)
[16:04:28.987]                         }
[16:04:28.987]                       })
[16:04:28.987]                     }
[16:04:28.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:28.987]                     base::options(mc.cores = 1L)
[16:04:28.987]                   }
[16:04:28.987]                   options(future.plan = NULL)
[16:04:28.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:28.987]                 }
[16:04:28.987]                 ...future.workdir <- getwd()
[16:04:28.987]             }
[16:04:28.987]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:28.987]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:28.987]         }
[16:04:28.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:28.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:28.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:28.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:28.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:28.987]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:28.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:28.987]             base::names(...future.oldOptions))
[16:04:28.987]     }
[16:04:28.987]     if (FALSE) {
[16:04:28.987]     }
[16:04:28.987]     else {
[16:04:28.987]         if (TRUE) {
[16:04:28.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:28.987]                 open = "w")
[16:04:28.987]         }
[16:04:28.987]         else {
[16:04:28.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:28.987]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:28.987]         }
[16:04:28.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:28.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:28.987]             base::sink(type = "output", split = FALSE)
[16:04:28.987]             base::close(...future.stdout)
[16:04:28.987]         }, add = TRUE)
[16:04:28.987]     }
[16:04:28.987]     ...future.frame <- base::sys.nframe()
[16:04:28.987]     ...future.conditions <- base::list()
[16:04:28.987]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:28.987]     if (FALSE) {
[16:04:28.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:28.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:28.987]     }
[16:04:28.987]     ...future.result <- base::tryCatch({
[16:04:28.987]         base::withCallingHandlers({
[16:04:28.987]             ...future.value <- base::withVisible(base::local({
[16:04:28.987]                 ...future.makeSendCondition <- base::local({
[16:04:28.987]                   sendCondition <- NULL
[16:04:28.987]                   function(frame = 1L) {
[16:04:28.987]                     if (is.function(sendCondition)) 
[16:04:28.987]                       return(sendCondition)
[16:04:28.987]                     ns <- getNamespace("parallel")
[16:04:28.987]                     if (exists("sendData", mode = "function", 
[16:04:28.987]                       envir = ns)) {
[16:04:28.987]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:28.987]                         envir = ns)
[16:04:28.987]                       envir <- sys.frame(frame)
[16:04:28.987]                       master <- NULL
[16:04:28.987]                       while (!identical(envir, .GlobalEnv) && 
[16:04:28.987]                         !identical(envir, emptyenv())) {
[16:04:28.987]                         if (exists("master", mode = "list", envir = envir, 
[16:04:28.987]                           inherits = FALSE)) {
[16:04:28.987]                           master <- get("master", mode = "list", 
[16:04:28.987]                             envir = envir, inherits = FALSE)
[16:04:28.987]                           if (inherits(master, c("SOCKnode", 
[16:04:28.987]                             "SOCK0node"))) {
[16:04:28.987]                             sendCondition <<- function(cond) {
[16:04:28.987]                               data <- list(type = "VALUE", value = cond, 
[16:04:28.987]                                 success = TRUE)
[16:04:28.987]                               parallel_sendData(master, data)
[16:04:28.987]                             }
[16:04:28.987]                             return(sendCondition)
[16:04:28.987]                           }
[16:04:28.987]                         }
[16:04:28.987]                         frame <- frame + 1L
[16:04:28.987]                         envir <- sys.frame(frame)
[16:04:28.987]                       }
[16:04:28.987]                     }
[16:04:28.987]                     sendCondition <<- function(cond) NULL
[16:04:28.987]                   }
[16:04:28.987]                 })
[16:04:28.987]                 withCallingHandlers({
[16:04:28.987]                   {
[16:04:28.987]                     42
[16:04:28.987]                   }
[16:04:28.987]                 }, immediateCondition = function(cond) {
[16:04:28.987]                   sendCondition <- ...future.makeSendCondition()
[16:04:28.987]                   sendCondition(cond)
[16:04:28.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.987]                   {
[16:04:28.987]                     inherits <- base::inherits
[16:04:28.987]                     invokeRestart <- base::invokeRestart
[16:04:28.987]                     is.null <- base::is.null
[16:04:28.987]                     muffled <- FALSE
[16:04:28.987]                     if (inherits(cond, "message")) {
[16:04:28.987]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:28.987]                       if (muffled) 
[16:04:28.987]                         invokeRestart("muffleMessage")
[16:04:28.987]                     }
[16:04:28.987]                     else if (inherits(cond, "warning")) {
[16:04:28.987]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:28.987]                       if (muffled) 
[16:04:28.987]                         invokeRestart("muffleWarning")
[16:04:28.987]                     }
[16:04:28.987]                     else if (inherits(cond, "condition")) {
[16:04:28.987]                       if (!is.null(pattern)) {
[16:04:28.987]                         computeRestarts <- base::computeRestarts
[16:04:28.987]                         grepl <- base::grepl
[16:04:28.987]                         restarts <- computeRestarts(cond)
[16:04:28.987]                         for (restart in restarts) {
[16:04:28.987]                           name <- restart$name
[16:04:28.987]                           if (is.null(name)) 
[16:04:28.987]                             next
[16:04:28.987]                           if (!grepl(pattern, name)) 
[16:04:28.987]                             next
[16:04:28.987]                           invokeRestart(restart)
[16:04:28.987]                           muffled <- TRUE
[16:04:28.987]                           break
[16:04:28.987]                         }
[16:04:28.987]                       }
[16:04:28.987]                     }
[16:04:28.987]                     invisible(muffled)
[16:04:28.987]                   }
[16:04:28.987]                   muffleCondition(cond)
[16:04:28.987]                 })
[16:04:28.987]             }))
[16:04:28.987]             future::FutureResult(value = ...future.value$value, 
[16:04:28.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.987]                   ...future.rng), globalenv = if (FALSE) 
[16:04:28.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:28.987]                     ...future.globalenv.names))
[16:04:28.987]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:28.987]         }, condition = base::local({
[16:04:28.987]             c <- base::c
[16:04:28.987]             inherits <- base::inherits
[16:04:28.987]             invokeRestart <- base::invokeRestart
[16:04:28.987]             length <- base::length
[16:04:28.987]             list <- base::list
[16:04:28.987]             seq.int <- base::seq.int
[16:04:28.987]             signalCondition <- base::signalCondition
[16:04:28.987]             sys.calls <- base::sys.calls
[16:04:28.987]             `[[` <- base::`[[`
[16:04:28.987]             `+` <- base::`+`
[16:04:28.987]             `<<-` <- base::`<<-`
[16:04:28.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:28.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:28.987]                   3L)]
[16:04:28.987]             }
[16:04:28.987]             function(cond) {
[16:04:28.987]                 is_error <- inherits(cond, "error")
[16:04:28.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:28.987]                   NULL)
[16:04:28.987]                 if (is_error) {
[16:04:28.987]                   sessionInformation <- function() {
[16:04:28.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:28.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:28.987]                       search = base::search(), system = base::Sys.info())
[16:04:28.987]                   }
[16:04:28.987]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:28.987]                     cond$call), session = sessionInformation(), 
[16:04:28.987]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:28.987]                   signalCondition(cond)
[16:04:28.987]                 }
[16:04:28.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:28.987]                 "immediateCondition"))) {
[16:04:28.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:28.987]                   ...future.conditions[[length(...future.conditions) + 
[16:04:28.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:28.987]                   if (TRUE && !signal) {
[16:04:28.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.987]                     {
[16:04:28.987]                       inherits <- base::inherits
[16:04:28.987]                       invokeRestart <- base::invokeRestart
[16:04:28.987]                       is.null <- base::is.null
[16:04:28.987]                       muffled <- FALSE
[16:04:28.987]                       if (inherits(cond, "message")) {
[16:04:28.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.987]                         if (muffled) 
[16:04:28.987]                           invokeRestart("muffleMessage")
[16:04:28.987]                       }
[16:04:28.987]                       else if (inherits(cond, "warning")) {
[16:04:28.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.987]                         if (muffled) 
[16:04:28.987]                           invokeRestart("muffleWarning")
[16:04:28.987]                       }
[16:04:28.987]                       else if (inherits(cond, "condition")) {
[16:04:28.987]                         if (!is.null(pattern)) {
[16:04:28.987]                           computeRestarts <- base::computeRestarts
[16:04:28.987]                           grepl <- base::grepl
[16:04:28.987]                           restarts <- computeRestarts(cond)
[16:04:28.987]                           for (restart in restarts) {
[16:04:28.987]                             name <- restart$name
[16:04:28.987]                             if (is.null(name)) 
[16:04:28.987]                               next
[16:04:28.987]                             if (!grepl(pattern, name)) 
[16:04:28.987]                               next
[16:04:28.987]                             invokeRestart(restart)
[16:04:28.987]                             muffled <- TRUE
[16:04:28.987]                             break
[16:04:28.987]                           }
[16:04:28.987]                         }
[16:04:28.987]                       }
[16:04:28.987]                       invisible(muffled)
[16:04:28.987]                     }
[16:04:28.987]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.987]                   }
[16:04:28.987]                 }
[16:04:28.987]                 else {
[16:04:28.987]                   if (TRUE) {
[16:04:28.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:28.987]                     {
[16:04:28.987]                       inherits <- base::inherits
[16:04:28.987]                       invokeRestart <- base::invokeRestart
[16:04:28.987]                       is.null <- base::is.null
[16:04:28.987]                       muffled <- FALSE
[16:04:28.987]                       if (inherits(cond, "message")) {
[16:04:28.987]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:28.987]                         if (muffled) 
[16:04:28.987]                           invokeRestart("muffleMessage")
[16:04:28.987]                       }
[16:04:28.987]                       else if (inherits(cond, "warning")) {
[16:04:28.987]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:28.987]                         if (muffled) 
[16:04:28.987]                           invokeRestart("muffleWarning")
[16:04:28.987]                       }
[16:04:28.987]                       else if (inherits(cond, "condition")) {
[16:04:28.987]                         if (!is.null(pattern)) {
[16:04:28.987]                           computeRestarts <- base::computeRestarts
[16:04:28.987]                           grepl <- base::grepl
[16:04:28.987]                           restarts <- computeRestarts(cond)
[16:04:28.987]                           for (restart in restarts) {
[16:04:28.987]                             name <- restart$name
[16:04:28.987]                             if (is.null(name)) 
[16:04:28.987]                               next
[16:04:28.987]                             if (!grepl(pattern, name)) 
[16:04:28.987]                               next
[16:04:28.987]                             invokeRestart(restart)
[16:04:28.987]                             muffled <- TRUE
[16:04:28.987]                             break
[16:04:28.987]                           }
[16:04:28.987]                         }
[16:04:28.987]                       }
[16:04:28.987]                       invisible(muffled)
[16:04:28.987]                     }
[16:04:28.987]                     muffleCondition(cond, pattern = "^muffle")
[16:04:28.987]                   }
[16:04:28.987]                 }
[16:04:28.987]             }
[16:04:28.987]         }))
[16:04:28.987]     }, error = function(ex) {
[16:04:28.987]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:28.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:28.987]                 ...future.rng), started = ...future.startTime, 
[16:04:28.987]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:28.987]             version = "1.8"), class = "FutureResult")
[16:04:28.987]     }, finally = {
[16:04:28.987]         if (!identical(...future.workdir, getwd())) 
[16:04:28.987]             setwd(...future.workdir)
[16:04:28.987]         {
[16:04:28.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:28.987]                 ...future.oldOptions$nwarnings <- NULL
[16:04:28.987]             }
[16:04:28.987]             base::options(...future.oldOptions)
[16:04:28.987]             if (.Platform$OS.type == "windows") {
[16:04:28.987]                 old_names <- names(...future.oldEnvVars)
[16:04:28.987]                 envs <- base::Sys.getenv()
[16:04:28.987]                 names <- names(envs)
[16:04:28.987]                 common <- intersect(names, old_names)
[16:04:28.987]                 added <- setdiff(names, old_names)
[16:04:28.987]                 removed <- setdiff(old_names, names)
[16:04:28.987]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:28.987]                   envs[common]]
[16:04:28.987]                 NAMES <- toupper(changed)
[16:04:28.987]                 args <- list()
[16:04:28.987]                 for (kk in seq_along(NAMES)) {
[16:04:28.987]                   name <- changed[[kk]]
[16:04:28.987]                   NAME <- NAMES[[kk]]
[16:04:28.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.987]                     next
[16:04:28.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.987]                 }
[16:04:28.987]                 NAMES <- toupper(added)
[16:04:28.987]                 for (kk in seq_along(NAMES)) {
[16:04:28.987]                   name <- added[[kk]]
[16:04:28.987]                   NAME <- NAMES[[kk]]
[16:04:28.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.987]                     next
[16:04:28.987]                   args[[name]] <- ""
[16:04:28.987]                 }
[16:04:28.987]                 NAMES <- toupper(removed)
[16:04:28.987]                 for (kk in seq_along(NAMES)) {
[16:04:28.987]                   name <- removed[[kk]]
[16:04:28.987]                   NAME <- NAMES[[kk]]
[16:04:28.987]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:28.987]                     next
[16:04:28.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:28.987]                 }
[16:04:28.987]                 if (length(args) > 0) 
[16:04:28.987]                   base::do.call(base::Sys.setenv, args = args)
[16:04:28.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:28.987]             }
[16:04:28.987]             else {
[16:04:28.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:28.987]             }
[16:04:28.987]             {
[16:04:28.987]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:28.987]                   0L) {
[16:04:28.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:28.987]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:28.987]                   base::options(opts)
[16:04:28.987]                 }
[16:04:28.987]                 {
[16:04:28.987]                   {
[16:04:28.987]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:28.987]                     NULL
[16:04:28.987]                   }
[16:04:28.987]                   options(future.plan = NULL)
[16:04:28.987]                   if (is.na(NA_character_)) 
[16:04:28.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:28.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:28.987]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:28.987]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:28.987]                     envir = parent.frame()) 
[16:04:28.987]                   {
[16:04:28.987]                     if (is.function(workers)) 
[16:04:28.987]                       workers <- workers()
[16:04:28.987]                     workers <- structure(as.integer(workers), 
[16:04:28.987]                       class = class(workers))
[16:04:28.987]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:28.987]                       workers >= 1)
[16:04:28.987]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:28.987]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:28.987]                     }
[16:04:28.987]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:28.987]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:28.987]                       envir = envir)
[16:04:28.987]                     if (!future$lazy) 
[16:04:28.987]                       future <- run(future)
[16:04:28.987]                     invisible(future)
[16:04:28.987]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:28.987]                 }
[16:04:28.987]             }
[16:04:28.987]         }
[16:04:28.987]     })
[16:04:28.987]     if (TRUE) {
[16:04:28.987]         base::sink(type = "output", split = FALSE)
[16:04:28.987]         if (TRUE) {
[16:04:28.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:28.987]         }
[16:04:28.987]         else {
[16:04:28.987]             ...future.result["stdout"] <- base::list(NULL)
[16:04:28.987]         }
[16:04:28.987]         base::close(...future.stdout)
[16:04:28.987]         ...future.stdout <- NULL
[16:04:28.987]     }
[16:04:28.987]     ...future.result$conditions <- ...future.conditions
[16:04:28.987]     ...future.result$finished <- base::Sys.time()
[16:04:28.987]     ...future.result
[16:04:28.987] }
[16:04:28.990] MultisessionFuture started
[16:04:28.990] - Launch lazy future ... done
[16:04:28.990] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: a9445719-c603-6873-6436-c58d72842a33
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:29.001] result() for ClusterFuture ...
[16:04:29.001] receiveMessageFromWorker() for ClusterFuture ...
[16:04:29.001] - Validating connection of MultisessionFuture
[16:04:29.035] - received message: FutureResult
[16:04:29.035] - Received FutureResult
[16:04:29.036] - Erased future from FutureRegistry
[16:04:29.036] result() for ClusterFuture ...
[16:04:29.036] - result already collected: FutureResult
[16:04:29.036] result() for ClusterFuture ... done
[16:04:29.036] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:29.036] result() for ClusterFuture ... done
[16:04:29.036] result() for ClusterFuture ...
[16:04:29.036] - result already collected: FutureResult
[16:04:29.036] result() for ClusterFuture ... done
- plan('multisession') ... DONE
> 
> message("*** Futures - labels ... DONE")
*** Futures - labels ... DONE
> 
> source("incl/end.R")
[16:04:29.037] plan(): Setting new future strategy stack:
[16:04:29.037] List of future strategies:
[16:04:29.037] 1. FutureStrategy:
[16:04:29.037]    - args: function (..., envir = parent.frame())
[16:04:29.037]    - tweaked: FALSE
[16:04:29.037]    - call: future::plan(oplan)
[16:04:29.038] plan(): nbrOfWorkers() = 1
> 
