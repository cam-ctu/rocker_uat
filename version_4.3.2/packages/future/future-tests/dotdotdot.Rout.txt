
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:04:15.504] plan(): Setting new future strategy stack:
[16:04:15.505] List of future strategies:
[16:04:15.505] 1. sequential:
[16:04:15.505]    - args: function (..., envir = parent.frame())
[16:04:15.505]    - tweaked: FALSE
[16:04:15.505]    - call: future::plan("sequential")
[16:04:15.519] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[16:04:15.566] plan(): Setting new future strategy stack:
[16:04:15.566] List of future strategies:
[16:04:15.566] 1. sequential:
[16:04:15.566]    - args: function (..., envir = parent.frame())
[16:04:15.566]    - tweaked: FALSE
[16:04:15.566]    - call: plan(strategy, substitute = FALSE)
[16:04:15.577] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55e6eee73af0>
Arguments '...' exists: TRUE
[16:04:15.579] getGlobalsAndPackages() ...
[16:04:15.579] Searching for globals...
[16:04:15.587] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:15.587] Searching for globals ... DONE
[16:04:15.588] Resolving globals: FALSE
[16:04:15.588] Tweak future expression to call with '...' arguments ...
[16:04:15.588] {
[16:04:15.588]     do.call(function(...) {
[16:04:15.588]         sum(x, ...)
[16:04:15.588]     }, args = future.call.arguments)
[16:04:15.588] }
[16:04:15.588] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.589] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.590] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:15.590] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:15.590] 
[16:04:15.590] getGlobalsAndPackages() ... DONE
[16:04:15.591] run() for ‘Future’ ...
[16:04:15.591] - state: ‘created’
[16:04:15.591] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.592]   - Field: ‘label’
[16:04:15.592]   - Field: ‘local’
[16:04:15.592]   - Field: ‘owner’
[16:04:15.592]   - Field: ‘envir’
[16:04:15.592]   - Field: ‘packages’
[16:04:15.592]   - Field: ‘gc’
[16:04:15.592]   - Field: ‘conditions’
[16:04:15.592]   - Field: ‘expr’
[16:04:15.592]   - Field: ‘uuid’
[16:04:15.593]   - Field: ‘seed’
[16:04:15.593]   - Field: ‘version’
[16:04:15.593]   - Field: ‘result’
[16:04:15.593]   - Field: ‘asynchronous’
[16:04:15.593]   - Field: ‘calls’
[16:04:15.593]   - Field: ‘globals’
[16:04:15.593]   - Field: ‘stdout’
[16:04:15.593]   - Field: ‘earlySignal’
[16:04:15.593]   - Field: ‘lazy’
[16:04:15.593]   - Field: ‘state’
[16:04:15.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.594] - Launch lazy future ...
[16:04:15.594] Packages needed by the future expression (n = 0): <none>
[16:04:15.594] Packages needed by future strategies (n = 0): <none>
[16:04:15.595] {
[16:04:15.595]     {
[16:04:15.595]         {
[16:04:15.595]             ...future.startTime <- base::Sys.time()
[16:04:15.595]             {
[16:04:15.595]                 {
[16:04:15.595]                   {
[16:04:15.595]                     base::local({
[16:04:15.595]                       has_future <- base::requireNamespace("future", 
[16:04:15.595]                         quietly = TRUE)
[16:04:15.595]                       if (has_future) {
[16:04:15.595]                         ns <- base::getNamespace("future")
[16:04:15.595]                         version <- ns[[".package"]][["version"]]
[16:04:15.595]                         if (is.null(version)) 
[16:04:15.595]                           version <- utils::packageVersion("future")
[16:04:15.595]                       }
[16:04:15.595]                       else {
[16:04:15.595]                         version <- NULL
[16:04:15.595]                       }
[16:04:15.595]                       if (!has_future || version < "1.8.0") {
[16:04:15.595]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.595]                           "", base::R.version$version.string), 
[16:04:15.595]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.595]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.595]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.595]                             "release", "version")], collapse = " "), 
[16:04:15.595]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.595]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.595]                           info)
[16:04:15.595]                         info <- base::paste(info, collapse = "; ")
[16:04:15.595]                         if (!has_future) {
[16:04:15.595]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.595]                             info)
[16:04:15.595]                         }
[16:04:15.595]                         else {
[16:04:15.595]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.595]                             info, version)
[16:04:15.595]                         }
[16:04:15.595]                         base::stop(msg)
[16:04:15.595]                       }
[16:04:15.595]                     })
[16:04:15.595]                   }
[16:04:15.595]                   options(future.plan = NULL)
[16:04:15.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.595]                 }
[16:04:15.595]                 ...future.workdir <- getwd()
[16:04:15.595]             }
[16:04:15.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.595]         }
[16:04:15.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.595]             base::names(...future.oldOptions))
[16:04:15.595]     }
[16:04:15.595]     if (FALSE) {
[16:04:15.595]     }
[16:04:15.595]     else {
[16:04:15.595]         if (TRUE) {
[16:04:15.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.595]                 open = "w")
[16:04:15.595]         }
[16:04:15.595]         else {
[16:04:15.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.595]         }
[16:04:15.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.595]             base::sink(type = "output", split = FALSE)
[16:04:15.595]             base::close(...future.stdout)
[16:04:15.595]         }, add = TRUE)
[16:04:15.595]     }
[16:04:15.595]     ...future.frame <- base::sys.nframe()
[16:04:15.595]     ...future.conditions <- base::list()
[16:04:15.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.595]     if (FALSE) {
[16:04:15.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.595]     }
[16:04:15.595]     ...future.result <- base::tryCatch({
[16:04:15.595]         base::withCallingHandlers({
[16:04:15.595]             ...future.value <- base::withVisible(base::local({
[16:04:15.595]                 do.call(function(...) {
[16:04:15.595]                   sum(x, ...)
[16:04:15.595]                 }, args = future.call.arguments)
[16:04:15.595]             }))
[16:04:15.595]             future::FutureResult(value = ...future.value$value, 
[16:04:15.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.595]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.595]                     ...future.globalenv.names))
[16:04:15.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.595]         }, condition = base::local({
[16:04:15.595]             c <- base::c
[16:04:15.595]             inherits <- base::inherits
[16:04:15.595]             invokeRestart <- base::invokeRestart
[16:04:15.595]             length <- base::length
[16:04:15.595]             list <- base::list
[16:04:15.595]             seq.int <- base::seq.int
[16:04:15.595]             signalCondition <- base::signalCondition
[16:04:15.595]             sys.calls <- base::sys.calls
[16:04:15.595]             `[[` <- base::`[[`
[16:04:15.595]             `+` <- base::`+`
[16:04:15.595]             `<<-` <- base::`<<-`
[16:04:15.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.595]                   3L)]
[16:04:15.595]             }
[16:04:15.595]             function(cond) {
[16:04:15.595]                 is_error <- inherits(cond, "error")
[16:04:15.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.595]                   NULL)
[16:04:15.595]                 if (is_error) {
[16:04:15.595]                   sessionInformation <- function() {
[16:04:15.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.595]                       search = base::search(), system = base::Sys.info())
[16:04:15.595]                   }
[16:04:15.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.595]                     cond$call), session = sessionInformation(), 
[16:04:15.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.595]                   signalCondition(cond)
[16:04:15.595]                 }
[16:04:15.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.595]                 "immediateCondition"))) {
[16:04:15.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.595]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.595]                   if (TRUE && !signal) {
[16:04:15.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.595]                     {
[16:04:15.595]                       inherits <- base::inherits
[16:04:15.595]                       invokeRestart <- base::invokeRestart
[16:04:15.595]                       is.null <- base::is.null
[16:04:15.595]                       muffled <- FALSE
[16:04:15.595]                       if (inherits(cond, "message")) {
[16:04:15.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.595]                         if (muffled) 
[16:04:15.595]                           invokeRestart("muffleMessage")
[16:04:15.595]                       }
[16:04:15.595]                       else if (inherits(cond, "warning")) {
[16:04:15.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.595]                         if (muffled) 
[16:04:15.595]                           invokeRestart("muffleWarning")
[16:04:15.595]                       }
[16:04:15.595]                       else if (inherits(cond, "condition")) {
[16:04:15.595]                         if (!is.null(pattern)) {
[16:04:15.595]                           computeRestarts <- base::computeRestarts
[16:04:15.595]                           grepl <- base::grepl
[16:04:15.595]                           restarts <- computeRestarts(cond)
[16:04:15.595]                           for (restart in restarts) {
[16:04:15.595]                             name <- restart$name
[16:04:15.595]                             if (is.null(name)) 
[16:04:15.595]                               next
[16:04:15.595]                             if (!grepl(pattern, name)) 
[16:04:15.595]                               next
[16:04:15.595]                             invokeRestart(restart)
[16:04:15.595]                             muffled <- TRUE
[16:04:15.595]                             break
[16:04:15.595]                           }
[16:04:15.595]                         }
[16:04:15.595]                       }
[16:04:15.595]                       invisible(muffled)
[16:04:15.595]                     }
[16:04:15.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.595]                   }
[16:04:15.595]                 }
[16:04:15.595]                 else {
[16:04:15.595]                   if (TRUE) {
[16:04:15.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.595]                     {
[16:04:15.595]                       inherits <- base::inherits
[16:04:15.595]                       invokeRestart <- base::invokeRestart
[16:04:15.595]                       is.null <- base::is.null
[16:04:15.595]                       muffled <- FALSE
[16:04:15.595]                       if (inherits(cond, "message")) {
[16:04:15.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.595]                         if (muffled) 
[16:04:15.595]                           invokeRestart("muffleMessage")
[16:04:15.595]                       }
[16:04:15.595]                       else if (inherits(cond, "warning")) {
[16:04:15.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.595]                         if (muffled) 
[16:04:15.595]                           invokeRestart("muffleWarning")
[16:04:15.595]                       }
[16:04:15.595]                       else if (inherits(cond, "condition")) {
[16:04:15.595]                         if (!is.null(pattern)) {
[16:04:15.595]                           computeRestarts <- base::computeRestarts
[16:04:15.595]                           grepl <- base::grepl
[16:04:15.595]                           restarts <- computeRestarts(cond)
[16:04:15.595]                           for (restart in restarts) {
[16:04:15.595]                             name <- restart$name
[16:04:15.595]                             if (is.null(name)) 
[16:04:15.595]                               next
[16:04:15.595]                             if (!grepl(pattern, name)) 
[16:04:15.595]                               next
[16:04:15.595]                             invokeRestart(restart)
[16:04:15.595]                             muffled <- TRUE
[16:04:15.595]                             break
[16:04:15.595]                           }
[16:04:15.595]                         }
[16:04:15.595]                       }
[16:04:15.595]                       invisible(muffled)
[16:04:15.595]                     }
[16:04:15.595]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.595]                   }
[16:04:15.595]                 }
[16:04:15.595]             }
[16:04:15.595]         }))
[16:04:15.595]     }, error = function(ex) {
[16:04:15.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.595]                 ...future.rng), started = ...future.startTime, 
[16:04:15.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.595]             version = "1.8"), class = "FutureResult")
[16:04:15.595]     }, finally = {
[16:04:15.595]         if (!identical(...future.workdir, getwd())) 
[16:04:15.595]             setwd(...future.workdir)
[16:04:15.595]         {
[16:04:15.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.595]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.595]             }
[16:04:15.595]             base::options(...future.oldOptions)
[16:04:15.595]             if (.Platform$OS.type == "windows") {
[16:04:15.595]                 old_names <- names(...future.oldEnvVars)
[16:04:15.595]                 envs <- base::Sys.getenv()
[16:04:15.595]                 names <- names(envs)
[16:04:15.595]                 common <- intersect(names, old_names)
[16:04:15.595]                 added <- setdiff(names, old_names)
[16:04:15.595]                 removed <- setdiff(old_names, names)
[16:04:15.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.595]                   envs[common]]
[16:04:15.595]                 NAMES <- toupper(changed)
[16:04:15.595]                 args <- list()
[16:04:15.595]                 for (kk in seq_along(NAMES)) {
[16:04:15.595]                   name <- changed[[kk]]
[16:04:15.595]                   NAME <- NAMES[[kk]]
[16:04:15.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.595]                     next
[16:04:15.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.595]                 }
[16:04:15.595]                 NAMES <- toupper(added)
[16:04:15.595]                 for (kk in seq_along(NAMES)) {
[16:04:15.595]                   name <- added[[kk]]
[16:04:15.595]                   NAME <- NAMES[[kk]]
[16:04:15.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.595]                     next
[16:04:15.595]                   args[[name]] <- ""
[16:04:15.595]                 }
[16:04:15.595]                 NAMES <- toupper(removed)
[16:04:15.595]                 for (kk in seq_along(NAMES)) {
[16:04:15.595]                   name <- removed[[kk]]
[16:04:15.595]                   NAME <- NAMES[[kk]]
[16:04:15.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.595]                     next
[16:04:15.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.595]                 }
[16:04:15.595]                 if (length(args) > 0) 
[16:04:15.595]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.595]             }
[16:04:15.595]             else {
[16:04:15.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.595]             }
[16:04:15.595]             {
[16:04:15.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.595]                   0L) {
[16:04:15.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.595]                   base::options(opts)
[16:04:15.595]                 }
[16:04:15.595]                 {
[16:04:15.595]                   {
[16:04:15.595]                     NULL
[16:04:15.595]                     RNGkind("Mersenne-Twister")
[16:04:15.595]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.595]                       inherits = FALSE)
[16:04:15.595]                   }
[16:04:15.595]                   options(future.plan = NULL)
[16:04:15.595]                   if (is.na(NA_character_)) 
[16:04:15.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.595]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.595]                   {
[16:04:15.595]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.595]                     if (!future$lazy) 
[16:04:15.595]                       future <- run(future)
[16:04:15.595]                     invisible(future)
[16:04:15.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.595]                 }
[16:04:15.595]             }
[16:04:15.595]         }
[16:04:15.595]     })
[16:04:15.595]     if (TRUE) {
[16:04:15.595]         base::sink(type = "output", split = FALSE)
[16:04:15.595]         if (TRUE) {
[16:04:15.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.595]         }
[16:04:15.595]         else {
[16:04:15.595]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.595]         }
[16:04:15.595]         base::close(...future.stdout)
[16:04:15.595]         ...future.stdout <- NULL
[16:04:15.595]     }
[16:04:15.595]     ...future.result$conditions <- ...future.conditions
[16:04:15.595]     ...future.result$finished <- base::Sys.time()
[16:04:15.595]     ...future.result
[16:04:15.595] }
[16:04:15.597] assign_globals() ...
[16:04:15.597] List of 2
[16:04:15.597]  $ x                    : int [1:2] 1 2
[16:04:15.597]  $ future.call.arguments:List of 1
[16:04:15.597]   ..$ : num 3
[16:04:15.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.597]  - attr(*, "where")=List of 2
[16:04:15.597]   ..$ x                    :<environment: R_EmptyEnv> 
[16:04:15.597]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.597]  - attr(*, "resolved")= logi FALSE
[16:04:15.597]  - attr(*, "total_size")= num 112
[16:04:15.597]  - attr(*, "already-done")= logi TRUE
[16:04:15.603] - copied ‘x’ to environment
[16:04:15.603] - copied ‘future.call.arguments’ to environment
[16:04:15.603] assign_globals() ... done
[16:04:15.603] plan(): Setting new future strategy stack:
[16:04:15.604] List of future strategies:
[16:04:15.604] 1. sequential:
[16:04:15.604]    - args: function (..., envir = parent.frame())
[16:04:15.604]    - tweaked: FALSE
[16:04:15.604]    - call: NULL
[16:04:15.604] plan(): nbrOfWorkers() = 1
[16:04:15.605] plan(): Setting new future strategy stack:
[16:04:15.605] List of future strategies:
[16:04:15.605] 1. sequential:
[16:04:15.605]    - args: function (..., envir = parent.frame())
[16:04:15.605]    - tweaked: FALSE
[16:04:15.605]    - call: plan(strategy, substitute = FALSE)
[16:04:15.605] plan(): nbrOfWorkers() = 1
[16:04:15.606] SequentialFuture started (and completed)
[16:04:15.606] - Launch lazy future ... done
[16:04:15.606] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55e6ef12df38>
Arguments '...' exists: TRUE
[16:04:15.607] getGlobalsAndPackages() ...
[16:04:15.607] Searching for globals...
[16:04:15.609] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:15.609] Searching for globals ... DONE
[16:04:15.609] Resolving globals: FALSE
[16:04:15.609] Tweak future expression to call with '...' arguments ...
[16:04:15.609] {
[16:04:15.609]     do.call(function(...) {
[16:04:15.609]         sum(x, ...)
[16:04:15.609]     }, args = future.call.arguments)
[16:04:15.609] }
[16:04:15.609] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.610] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.610] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:15.610] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:15.610] 
[16:04:15.610] getGlobalsAndPackages() ... DONE
[16:04:15.611] run() for ‘Future’ ...
[16:04:15.611] - state: ‘created’
[16:04:15.611] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.611] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.611]   - Field: ‘label’
[16:04:15.611]   - Field: ‘local’
[16:04:15.611]   - Field: ‘owner’
[16:04:15.612]   - Field: ‘envir’
[16:04:15.612]   - Field: ‘packages’
[16:04:15.612]   - Field: ‘gc’
[16:04:15.612]   - Field: ‘conditions’
[16:04:15.612]   - Field: ‘expr’
[16:04:15.612]   - Field: ‘uuid’
[16:04:15.612]   - Field: ‘seed’
[16:04:15.612]   - Field: ‘version’
[16:04:15.612]   - Field: ‘result’
[16:04:15.612]   - Field: ‘asynchronous’
[16:04:15.612]   - Field: ‘calls’
[16:04:15.613]   - Field: ‘globals’
[16:04:15.613]   - Field: ‘stdout’
[16:04:15.613]   - Field: ‘earlySignal’
[16:04:15.613]   - Field: ‘lazy’
[16:04:15.613]   - Field: ‘state’
[16:04:15.613] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.613] - Launch lazy future ...
[16:04:15.613] Packages needed by the future expression (n = 0): <none>
[16:04:15.613] Packages needed by future strategies (n = 0): <none>
[16:04:15.614] {
[16:04:15.614]     {
[16:04:15.614]         {
[16:04:15.614]             ...future.startTime <- base::Sys.time()
[16:04:15.614]             {
[16:04:15.614]                 {
[16:04:15.614]                   {
[16:04:15.614]                     base::local({
[16:04:15.614]                       has_future <- base::requireNamespace("future", 
[16:04:15.614]                         quietly = TRUE)
[16:04:15.614]                       if (has_future) {
[16:04:15.614]                         ns <- base::getNamespace("future")
[16:04:15.614]                         version <- ns[[".package"]][["version"]]
[16:04:15.614]                         if (is.null(version)) 
[16:04:15.614]                           version <- utils::packageVersion("future")
[16:04:15.614]                       }
[16:04:15.614]                       else {
[16:04:15.614]                         version <- NULL
[16:04:15.614]                       }
[16:04:15.614]                       if (!has_future || version < "1.8.0") {
[16:04:15.614]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.614]                           "", base::R.version$version.string), 
[16:04:15.614]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.614]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.614]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.614]                             "release", "version")], collapse = " "), 
[16:04:15.614]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.614]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.614]                           info)
[16:04:15.614]                         info <- base::paste(info, collapse = "; ")
[16:04:15.614]                         if (!has_future) {
[16:04:15.614]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.614]                             info)
[16:04:15.614]                         }
[16:04:15.614]                         else {
[16:04:15.614]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.614]                             info, version)
[16:04:15.614]                         }
[16:04:15.614]                         base::stop(msg)
[16:04:15.614]                       }
[16:04:15.614]                     })
[16:04:15.614]                   }
[16:04:15.614]                   options(future.plan = NULL)
[16:04:15.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.614]                 }
[16:04:15.614]                 ...future.workdir <- getwd()
[16:04:15.614]             }
[16:04:15.614]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.614]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.614]         }
[16:04:15.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.614]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.614]             base::names(...future.oldOptions))
[16:04:15.614]     }
[16:04:15.614]     if (FALSE) {
[16:04:15.614]     }
[16:04:15.614]     else {
[16:04:15.614]         if (TRUE) {
[16:04:15.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.614]                 open = "w")
[16:04:15.614]         }
[16:04:15.614]         else {
[16:04:15.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.614]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.614]         }
[16:04:15.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.614]             base::sink(type = "output", split = FALSE)
[16:04:15.614]             base::close(...future.stdout)
[16:04:15.614]         }, add = TRUE)
[16:04:15.614]     }
[16:04:15.614]     ...future.frame <- base::sys.nframe()
[16:04:15.614]     ...future.conditions <- base::list()
[16:04:15.614]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.614]     if (FALSE) {
[16:04:15.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.614]     }
[16:04:15.614]     ...future.result <- base::tryCatch({
[16:04:15.614]         base::withCallingHandlers({
[16:04:15.614]             ...future.value <- base::withVisible(base::local({
[16:04:15.614]                 do.call(function(...) {
[16:04:15.614]                   sum(x, ...)
[16:04:15.614]                 }, args = future.call.arguments)
[16:04:15.614]             }))
[16:04:15.614]             future::FutureResult(value = ...future.value$value, 
[16:04:15.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.614]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.614]                     ...future.globalenv.names))
[16:04:15.614]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.614]         }, condition = base::local({
[16:04:15.614]             c <- base::c
[16:04:15.614]             inherits <- base::inherits
[16:04:15.614]             invokeRestart <- base::invokeRestart
[16:04:15.614]             length <- base::length
[16:04:15.614]             list <- base::list
[16:04:15.614]             seq.int <- base::seq.int
[16:04:15.614]             signalCondition <- base::signalCondition
[16:04:15.614]             sys.calls <- base::sys.calls
[16:04:15.614]             `[[` <- base::`[[`
[16:04:15.614]             `+` <- base::`+`
[16:04:15.614]             `<<-` <- base::`<<-`
[16:04:15.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.614]                   3L)]
[16:04:15.614]             }
[16:04:15.614]             function(cond) {
[16:04:15.614]                 is_error <- inherits(cond, "error")
[16:04:15.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.614]                   NULL)
[16:04:15.614]                 if (is_error) {
[16:04:15.614]                   sessionInformation <- function() {
[16:04:15.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.614]                       search = base::search(), system = base::Sys.info())
[16:04:15.614]                   }
[16:04:15.614]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.614]                     cond$call), session = sessionInformation(), 
[16:04:15.614]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.614]                   signalCondition(cond)
[16:04:15.614]                 }
[16:04:15.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.614]                 "immediateCondition"))) {
[16:04:15.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.614]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.614]                   if (TRUE && !signal) {
[16:04:15.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.614]                     {
[16:04:15.614]                       inherits <- base::inherits
[16:04:15.614]                       invokeRestart <- base::invokeRestart
[16:04:15.614]                       is.null <- base::is.null
[16:04:15.614]                       muffled <- FALSE
[16:04:15.614]                       if (inherits(cond, "message")) {
[16:04:15.614]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.614]                         if (muffled) 
[16:04:15.614]                           invokeRestart("muffleMessage")
[16:04:15.614]                       }
[16:04:15.614]                       else if (inherits(cond, "warning")) {
[16:04:15.614]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.614]                         if (muffled) 
[16:04:15.614]                           invokeRestart("muffleWarning")
[16:04:15.614]                       }
[16:04:15.614]                       else if (inherits(cond, "condition")) {
[16:04:15.614]                         if (!is.null(pattern)) {
[16:04:15.614]                           computeRestarts <- base::computeRestarts
[16:04:15.614]                           grepl <- base::grepl
[16:04:15.614]                           restarts <- computeRestarts(cond)
[16:04:15.614]                           for (restart in restarts) {
[16:04:15.614]                             name <- restart$name
[16:04:15.614]                             if (is.null(name)) 
[16:04:15.614]                               next
[16:04:15.614]                             if (!grepl(pattern, name)) 
[16:04:15.614]                               next
[16:04:15.614]                             invokeRestart(restart)
[16:04:15.614]                             muffled <- TRUE
[16:04:15.614]                             break
[16:04:15.614]                           }
[16:04:15.614]                         }
[16:04:15.614]                       }
[16:04:15.614]                       invisible(muffled)
[16:04:15.614]                     }
[16:04:15.614]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.614]                   }
[16:04:15.614]                 }
[16:04:15.614]                 else {
[16:04:15.614]                   if (TRUE) {
[16:04:15.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.614]                     {
[16:04:15.614]                       inherits <- base::inherits
[16:04:15.614]                       invokeRestart <- base::invokeRestart
[16:04:15.614]                       is.null <- base::is.null
[16:04:15.614]                       muffled <- FALSE
[16:04:15.614]                       if (inherits(cond, "message")) {
[16:04:15.614]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.614]                         if (muffled) 
[16:04:15.614]                           invokeRestart("muffleMessage")
[16:04:15.614]                       }
[16:04:15.614]                       else if (inherits(cond, "warning")) {
[16:04:15.614]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.614]                         if (muffled) 
[16:04:15.614]                           invokeRestart("muffleWarning")
[16:04:15.614]                       }
[16:04:15.614]                       else if (inherits(cond, "condition")) {
[16:04:15.614]                         if (!is.null(pattern)) {
[16:04:15.614]                           computeRestarts <- base::computeRestarts
[16:04:15.614]                           grepl <- base::grepl
[16:04:15.614]                           restarts <- computeRestarts(cond)
[16:04:15.614]                           for (restart in restarts) {
[16:04:15.614]                             name <- restart$name
[16:04:15.614]                             if (is.null(name)) 
[16:04:15.614]                               next
[16:04:15.614]                             if (!grepl(pattern, name)) 
[16:04:15.614]                               next
[16:04:15.614]                             invokeRestart(restart)
[16:04:15.614]                             muffled <- TRUE
[16:04:15.614]                             break
[16:04:15.614]                           }
[16:04:15.614]                         }
[16:04:15.614]                       }
[16:04:15.614]                       invisible(muffled)
[16:04:15.614]                     }
[16:04:15.614]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.614]                   }
[16:04:15.614]                 }
[16:04:15.614]             }
[16:04:15.614]         }))
[16:04:15.614]     }, error = function(ex) {
[16:04:15.614]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.614]                 ...future.rng), started = ...future.startTime, 
[16:04:15.614]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.614]             version = "1.8"), class = "FutureResult")
[16:04:15.614]     }, finally = {
[16:04:15.614]         if (!identical(...future.workdir, getwd())) 
[16:04:15.614]             setwd(...future.workdir)
[16:04:15.614]         {
[16:04:15.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.614]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.614]             }
[16:04:15.614]             base::options(...future.oldOptions)
[16:04:15.614]             if (.Platform$OS.type == "windows") {
[16:04:15.614]                 old_names <- names(...future.oldEnvVars)
[16:04:15.614]                 envs <- base::Sys.getenv()
[16:04:15.614]                 names <- names(envs)
[16:04:15.614]                 common <- intersect(names, old_names)
[16:04:15.614]                 added <- setdiff(names, old_names)
[16:04:15.614]                 removed <- setdiff(old_names, names)
[16:04:15.614]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.614]                   envs[common]]
[16:04:15.614]                 NAMES <- toupper(changed)
[16:04:15.614]                 args <- list()
[16:04:15.614]                 for (kk in seq_along(NAMES)) {
[16:04:15.614]                   name <- changed[[kk]]
[16:04:15.614]                   NAME <- NAMES[[kk]]
[16:04:15.614]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.614]                     next
[16:04:15.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.614]                 }
[16:04:15.614]                 NAMES <- toupper(added)
[16:04:15.614]                 for (kk in seq_along(NAMES)) {
[16:04:15.614]                   name <- added[[kk]]
[16:04:15.614]                   NAME <- NAMES[[kk]]
[16:04:15.614]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.614]                     next
[16:04:15.614]                   args[[name]] <- ""
[16:04:15.614]                 }
[16:04:15.614]                 NAMES <- toupper(removed)
[16:04:15.614]                 for (kk in seq_along(NAMES)) {
[16:04:15.614]                   name <- removed[[kk]]
[16:04:15.614]                   NAME <- NAMES[[kk]]
[16:04:15.614]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.614]                     next
[16:04:15.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.614]                 }
[16:04:15.614]                 if (length(args) > 0) 
[16:04:15.614]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.614]             }
[16:04:15.614]             else {
[16:04:15.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.614]             }
[16:04:15.614]             {
[16:04:15.614]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.614]                   0L) {
[16:04:15.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.614]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.614]                   base::options(opts)
[16:04:15.614]                 }
[16:04:15.614]                 {
[16:04:15.614]                   {
[16:04:15.614]                     NULL
[16:04:15.614]                     RNGkind("Mersenne-Twister")
[16:04:15.614]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.614]                       inherits = FALSE)
[16:04:15.614]                   }
[16:04:15.614]                   options(future.plan = NULL)
[16:04:15.614]                   if (is.na(NA_character_)) 
[16:04:15.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.614]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.614]                   {
[16:04:15.614]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.614]                     if (!future$lazy) 
[16:04:15.614]                       future <- run(future)
[16:04:15.614]                     invisible(future)
[16:04:15.614]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.614]                 }
[16:04:15.614]             }
[16:04:15.614]         }
[16:04:15.614]     })
[16:04:15.614]     if (TRUE) {
[16:04:15.614]         base::sink(type = "output", split = FALSE)
[16:04:15.614]         if (TRUE) {
[16:04:15.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.614]         }
[16:04:15.614]         else {
[16:04:15.614]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.614]         }
[16:04:15.614]         base::close(...future.stdout)
[16:04:15.614]         ...future.stdout <- NULL
[16:04:15.614]     }
[16:04:15.614]     ...future.result$conditions <- ...future.conditions
[16:04:15.614]     ...future.result$finished <- base::Sys.time()
[16:04:15.614]     ...future.result
[16:04:15.614] }
[16:04:15.615] assign_globals() ...
[16:04:15.615] List of 2
[16:04:15.615]  $ x                    : int [1:2] 1 2
[16:04:15.615]  $ future.call.arguments:List of 1
[16:04:15.615]   ..$ : num 3
[16:04:15.615]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.615]  - attr(*, "where")=List of 2
[16:04:15.615]   ..$ x                    :<environment: R_EmptyEnv> 
[16:04:15.615]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.615]  - attr(*, "resolved")= logi FALSE
[16:04:15.615]  - attr(*, "total_size")= num 112
[16:04:15.615]  - attr(*, "already-done")= logi TRUE
[16:04:15.621] - copied ‘x’ to environment
[16:04:15.621] - copied ‘future.call.arguments’ to environment
[16:04:15.621] assign_globals() ... done
[16:04:15.622] plan(): Setting new future strategy stack:
[16:04:15.622] List of future strategies:
[16:04:15.622] 1. sequential:
[16:04:15.622]    - args: function (..., envir = parent.frame())
[16:04:15.622]    - tweaked: FALSE
[16:04:15.622]    - call: NULL
[16:04:15.622] plan(): nbrOfWorkers() = 1
[16:04:15.623] plan(): Setting new future strategy stack:
[16:04:15.623] List of future strategies:
[16:04:15.623] 1. sequential:
[16:04:15.623]    - args: function (..., envir = parent.frame())
[16:04:15.623]    - tweaked: FALSE
[16:04:15.623]    - call: plan(strategy, substitute = FALSE)
[16:04:15.623] plan(): nbrOfWorkers() = 1
[16:04:15.623] SequentialFuture started (and completed)
[16:04:15.623] - Launch lazy future ... done
[16:04:15.624] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55e6ef28ef38>
Arguments '...' exists: FALSE
[16:04:15.624] getGlobalsAndPackages() ...
[16:04:15.624] Searching for globals...
[16:04:15.625] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[16:04:15.625] Searching for globals ... DONE
[16:04:15.625] Resolving globals: FALSE
[16:04:15.626] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.626] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.626] - globals: [2] ‘x’, ‘y’
[16:04:15.626] 
[16:04:15.626] getGlobalsAndPackages() ... DONE
[16:04:15.627] run() for ‘Future’ ...
[16:04:15.627] - state: ‘created’
[16:04:15.627] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.627] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.627]   - Field: ‘label’
[16:04:15.628]   - Field: ‘local’
[16:04:15.628]   - Field: ‘owner’
[16:04:15.628]   - Field: ‘envir’
[16:04:15.628]   - Field: ‘packages’
[16:04:15.628]   - Field: ‘gc’
[16:04:15.628]   - Field: ‘conditions’
[16:04:15.628]   - Field: ‘expr’
[16:04:15.628]   - Field: ‘uuid’
[16:04:15.628]   - Field: ‘seed’
[16:04:15.628]   - Field: ‘version’
[16:04:15.628]   - Field: ‘result’
[16:04:15.629]   - Field: ‘asynchronous’
[16:04:15.629]   - Field: ‘calls’
[16:04:15.629]   - Field: ‘globals’
[16:04:15.629]   - Field: ‘stdout’
[16:04:15.629]   - Field: ‘earlySignal’
[16:04:15.629]   - Field: ‘lazy’
[16:04:15.629]   - Field: ‘state’
[16:04:15.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.629] - Launch lazy future ...
[16:04:15.629] Packages needed by the future expression (n = 0): <none>
[16:04:15.630] Packages needed by future strategies (n = 0): <none>
[16:04:15.630] {
[16:04:15.630]     {
[16:04:15.630]         {
[16:04:15.630]             ...future.startTime <- base::Sys.time()
[16:04:15.630]             {
[16:04:15.630]                 {
[16:04:15.630]                   {
[16:04:15.630]                     base::local({
[16:04:15.630]                       has_future <- base::requireNamespace("future", 
[16:04:15.630]                         quietly = TRUE)
[16:04:15.630]                       if (has_future) {
[16:04:15.630]                         ns <- base::getNamespace("future")
[16:04:15.630]                         version <- ns[[".package"]][["version"]]
[16:04:15.630]                         if (is.null(version)) 
[16:04:15.630]                           version <- utils::packageVersion("future")
[16:04:15.630]                       }
[16:04:15.630]                       else {
[16:04:15.630]                         version <- NULL
[16:04:15.630]                       }
[16:04:15.630]                       if (!has_future || version < "1.8.0") {
[16:04:15.630]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.630]                           "", base::R.version$version.string), 
[16:04:15.630]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.630]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.630]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.630]                             "release", "version")], collapse = " "), 
[16:04:15.630]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.630]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.630]                           info)
[16:04:15.630]                         info <- base::paste(info, collapse = "; ")
[16:04:15.630]                         if (!has_future) {
[16:04:15.630]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.630]                             info)
[16:04:15.630]                         }
[16:04:15.630]                         else {
[16:04:15.630]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.630]                             info, version)
[16:04:15.630]                         }
[16:04:15.630]                         base::stop(msg)
[16:04:15.630]                       }
[16:04:15.630]                     })
[16:04:15.630]                   }
[16:04:15.630]                   options(future.plan = NULL)
[16:04:15.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.630]                 }
[16:04:15.630]                 ...future.workdir <- getwd()
[16:04:15.630]             }
[16:04:15.630]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.630]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.630]         }
[16:04:15.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.630]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.630]             base::names(...future.oldOptions))
[16:04:15.630]     }
[16:04:15.630]     if (FALSE) {
[16:04:15.630]     }
[16:04:15.630]     else {
[16:04:15.630]         if (TRUE) {
[16:04:15.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.630]                 open = "w")
[16:04:15.630]         }
[16:04:15.630]         else {
[16:04:15.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.630]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.630]         }
[16:04:15.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.630]             base::sink(type = "output", split = FALSE)
[16:04:15.630]             base::close(...future.stdout)
[16:04:15.630]         }, add = TRUE)
[16:04:15.630]     }
[16:04:15.630]     ...future.frame <- base::sys.nframe()
[16:04:15.630]     ...future.conditions <- base::list()
[16:04:15.630]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.630]     if (FALSE) {
[16:04:15.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.630]     }
[16:04:15.630]     ...future.result <- base::tryCatch({
[16:04:15.630]         base::withCallingHandlers({
[16:04:15.630]             ...future.value <- base::withVisible(base::local({
[16:04:15.630]                 sum(x, y)
[16:04:15.630]             }))
[16:04:15.630]             future::FutureResult(value = ...future.value$value, 
[16:04:15.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.630]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.630]                     ...future.globalenv.names))
[16:04:15.630]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.630]         }, condition = base::local({
[16:04:15.630]             c <- base::c
[16:04:15.630]             inherits <- base::inherits
[16:04:15.630]             invokeRestart <- base::invokeRestart
[16:04:15.630]             length <- base::length
[16:04:15.630]             list <- base::list
[16:04:15.630]             seq.int <- base::seq.int
[16:04:15.630]             signalCondition <- base::signalCondition
[16:04:15.630]             sys.calls <- base::sys.calls
[16:04:15.630]             `[[` <- base::`[[`
[16:04:15.630]             `+` <- base::`+`
[16:04:15.630]             `<<-` <- base::`<<-`
[16:04:15.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.630]                   3L)]
[16:04:15.630]             }
[16:04:15.630]             function(cond) {
[16:04:15.630]                 is_error <- inherits(cond, "error")
[16:04:15.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.630]                   NULL)
[16:04:15.630]                 if (is_error) {
[16:04:15.630]                   sessionInformation <- function() {
[16:04:15.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.630]                       search = base::search(), system = base::Sys.info())
[16:04:15.630]                   }
[16:04:15.630]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.630]                     cond$call), session = sessionInformation(), 
[16:04:15.630]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.630]                   signalCondition(cond)
[16:04:15.630]                 }
[16:04:15.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.630]                 "immediateCondition"))) {
[16:04:15.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.630]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.630]                   if (TRUE && !signal) {
[16:04:15.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.630]                     {
[16:04:15.630]                       inherits <- base::inherits
[16:04:15.630]                       invokeRestart <- base::invokeRestart
[16:04:15.630]                       is.null <- base::is.null
[16:04:15.630]                       muffled <- FALSE
[16:04:15.630]                       if (inherits(cond, "message")) {
[16:04:15.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.630]                         if (muffled) 
[16:04:15.630]                           invokeRestart("muffleMessage")
[16:04:15.630]                       }
[16:04:15.630]                       else if (inherits(cond, "warning")) {
[16:04:15.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.630]                         if (muffled) 
[16:04:15.630]                           invokeRestart("muffleWarning")
[16:04:15.630]                       }
[16:04:15.630]                       else if (inherits(cond, "condition")) {
[16:04:15.630]                         if (!is.null(pattern)) {
[16:04:15.630]                           computeRestarts <- base::computeRestarts
[16:04:15.630]                           grepl <- base::grepl
[16:04:15.630]                           restarts <- computeRestarts(cond)
[16:04:15.630]                           for (restart in restarts) {
[16:04:15.630]                             name <- restart$name
[16:04:15.630]                             if (is.null(name)) 
[16:04:15.630]                               next
[16:04:15.630]                             if (!grepl(pattern, name)) 
[16:04:15.630]                               next
[16:04:15.630]                             invokeRestart(restart)
[16:04:15.630]                             muffled <- TRUE
[16:04:15.630]                             break
[16:04:15.630]                           }
[16:04:15.630]                         }
[16:04:15.630]                       }
[16:04:15.630]                       invisible(muffled)
[16:04:15.630]                     }
[16:04:15.630]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.630]                   }
[16:04:15.630]                 }
[16:04:15.630]                 else {
[16:04:15.630]                   if (TRUE) {
[16:04:15.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.630]                     {
[16:04:15.630]                       inherits <- base::inherits
[16:04:15.630]                       invokeRestart <- base::invokeRestart
[16:04:15.630]                       is.null <- base::is.null
[16:04:15.630]                       muffled <- FALSE
[16:04:15.630]                       if (inherits(cond, "message")) {
[16:04:15.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.630]                         if (muffled) 
[16:04:15.630]                           invokeRestart("muffleMessage")
[16:04:15.630]                       }
[16:04:15.630]                       else if (inherits(cond, "warning")) {
[16:04:15.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.630]                         if (muffled) 
[16:04:15.630]                           invokeRestart("muffleWarning")
[16:04:15.630]                       }
[16:04:15.630]                       else if (inherits(cond, "condition")) {
[16:04:15.630]                         if (!is.null(pattern)) {
[16:04:15.630]                           computeRestarts <- base::computeRestarts
[16:04:15.630]                           grepl <- base::grepl
[16:04:15.630]                           restarts <- computeRestarts(cond)
[16:04:15.630]                           for (restart in restarts) {
[16:04:15.630]                             name <- restart$name
[16:04:15.630]                             if (is.null(name)) 
[16:04:15.630]                               next
[16:04:15.630]                             if (!grepl(pattern, name)) 
[16:04:15.630]                               next
[16:04:15.630]                             invokeRestart(restart)
[16:04:15.630]                             muffled <- TRUE
[16:04:15.630]                             break
[16:04:15.630]                           }
[16:04:15.630]                         }
[16:04:15.630]                       }
[16:04:15.630]                       invisible(muffled)
[16:04:15.630]                     }
[16:04:15.630]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.630]                   }
[16:04:15.630]                 }
[16:04:15.630]             }
[16:04:15.630]         }))
[16:04:15.630]     }, error = function(ex) {
[16:04:15.630]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.630]                 ...future.rng), started = ...future.startTime, 
[16:04:15.630]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.630]             version = "1.8"), class = "FutureResult")
[16:04:15.630]     }, finally = {
[16:04:15.630]         if (!identical(...future.workdir, getwd())) 
[16:04:15.630]             setwd(...future.workdir)
[16:04:15.630]         {
[16:04:15.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.630]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.630]             }
[16:04:15.630]             base::options(...future.oldOptions)
[16:04:15.630]             if (.Platform$OS.type == "windows") {
[16:04:15.630]                 old_names <- names(...future.oldEnvVars)
[16:04:15.630]                 envs <- base::Sys.getenv()
[16:04:15.630]                 names <- names(envs)
[16:04:15.630]                 common <- intersect(names, old_names)
[16:04:15.630]                 added <- setdiff(names, old_names)
[16:04:15.630]                 removed <- setdiff(old_names, names)
[16:04:15.630]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.630]                   envs[common]]
[16:04:15.630]                 NAMES <- toupper(changed)
[16:04:15.630]                 args <- list()
[16:04:15.630]                 for (kk in seq_along(NAMES)) {
[16:04:15.630]                   name <- changed[[kk]]
[16:04:15.630]                   NAME <- NAMES[[kk]]
[16:04:15.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.630]                     next
[16:04:15.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.630]                 }
[16:04:15.630]                 NAMES <- toupper(added)
[16:04:15.630]                 for (kk in seq_along(NAMES)) {
[16:04:15.630]                   name <- added[[kk]]
[16:04:15.630]                   NAME <- NAMES[[kk]]
[16:04:15.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.630]                     next
[16:04:15.630]                   args[[name]] <- ""
[16:04:15.630]                 }
[16:04:15.630]                 NAMES <- toupper(removed)
[16:04:15.630]                 for (kk in seq_along(NAMES)) {
[16:04:15.630]                   name <- removed[[kk]]
[16:04:15.630]                   NAME <- NAMES[[kk]]
[16:04:15.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.630]                     next
[16:04:15.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.630]                 }
[16:04:15.630]                 if (length(args) > 0) 
[16:04:15.630]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.630]             }
[16:04:15.630]             else {
[16:04:15.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.630]             }
[16:04:15.630]             {
[16:04:15.630]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.630]                   0L) {
[16:04:15.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.630]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.630]                   base::options(opts)
[16:04:15.630]                 }
[16:04:15.630]                 {
[16:04:15.630]                   {
[16:04:15.630]                     NULL
[16:04:15.630]                     RNGkind("Mersenne-Twister")
[16:04:15.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.630]                       inherits = FALSE)
[16:04:15.630]                   }
[16:04:15.630]                   options(future.plan = NULL)
[16:04:15.630]                   if (is.na(NA_character_)) 
[16:04:15.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.630]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.630]                   {
[16:04:15.630]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.630]                     if (!future$lazy) 
[16:04:15.630]                       future <- run(future)
[16:04:15.630]                     invisible(future)
[16:04:15.630]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.630]                 }
[16:04:15.630]             }
[16:04:15.630]         }
[16:04:15.630]     })
[16:04:15.630]     if (TRUE) {
[16:04:15.630]         base::sink(type = "output", split = FALSE)
[16:04:15.630]         if (TRUE) {
[16:04:15.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.630]         }
[16:04:15.630]         else {
[16:04:15.630]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.630]         }
[16:04:15.630]         base::close(...future.stdout)
[16:04:15.630]         ...future.stdout <- NULL
[16:04:15.630]     }
[16:04:15.630]     ...future.result$conditions <- ...future.conditions
[16:04:15.630]     ...future.result$finished <- base::Sys.time()
[16:04:15.630]     ...future.result
[16:04:15.630] }
[16:04:15.632] assign_globals() ...
[16:04:15.632] List of 2
[16:04:15.632]  $ x: int [1:2] 1 2
[16:04:15.632]  $ y: num 3
[16:04:15.632]  - attr(*, "where")=List of 2
[16:04:15.632]   ..$ x:<environment: R_EmptyEnv> 
[16:04:15.632]   ..$ y:<environment: R_EmptyEnv> 
[16:04:15.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.632]  - attr(*, "resolved")= logi FALSE
[16:04:15.632]  - attr(*, "total_size")= num 112
[16:04:15.632]  - attr(*, "already-done")= logi TRUE
[16:04:15.634] - copied ‘x’ to environment
[16:04:15.635] - copied ‘y’ to environment
[16:04:15.635] assign_globals() ... done
[16:04:15.635] plan(): Setting new future strategy stack:
[16:04:15.635] List of future strategies:
[16:04:15.635] 1. sequential:
[16:04:15.635]    - args: function (..., envir = parent.frame())
[16:04:15.635]    - tweaked: FALSE
[16:04:15.635]    - call: NULL
[16:04:15.635] plan(): nbrOfWorkers() = 1
[16:04:15.636] plan(): Setting new future strategy stack:
[16:04:15.636] List of future strategies:
[16:04:15.636] 1. sequential:
[16:04:15.636]    - args: function (..., envir = parent.frame())
[16:04:15.636]    - tweaked: FALSE
[16:04:15.636]    - call: plan(strategy, substitute = FALSE)
[16:04:15.636] plan(): nbrOfWorkers() = 1
[16:04:15.637] SequentialFuture started (and completed)
[16:04:15.637] - Launch lazy future ... done
[16:04:15.637] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55e6ef478610>
Arguments '...' exists: FALSE
[16:04:15.637] getGlobalsAndPackages() ...
[16:04:15.637] Searching for globals...
[16:04:15.639] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[16:04:15.639] Searching for globals ... DONE
[16:04:15.639] Resolving globals: FALSE
[16:04:15.639] Tweak future expression to call with '...' arguments ...
[16:04:15.640] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.640] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.640] - globals: [2] ‘x’, ‘y’
[16:04:15.640] 
[16:04:15.640] getGlobalsAndPackages() ... DONE
[16:04:15.640] run() for ‘Future’ ...
[16:04:15.641] - state: ‘created’
[16:04:15.641] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.641] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.641]   - Field: ‘label’
[16:04:15.641]   - Field: ‘local’
[16:04:15.641]   - Field: ‘owner’
[16:04:15.641]   - Field: ‘envir’
[16:04:15.641]   - Field: ‘packages’
[16:04:15.642]   - Field: ‘gc’
[16:04:15.642]   - Field: ‘conditions’
[16:04:15.642]   - Field: ‘expr’
[16:04:15.642]   - Field: ‘uuid’
[16:04:15.642]   - Field: ‘seed’
[16:04:15.642]   - Field: ‘version’
[16:04:15.642]   - Field: ‘result’
[16:04:15.642]   - Field: ‘asynchronous’
[16:04:15.642]   - Field: ‘calls’
[16:04:15.642]   - Field: ‘globals’
[16:04:15.642]   - Field: ‘stdout’
[16:04:15.643]   - Field: ‘earlySignal’
[16:04:15.643]   - Field: ‘lazy’
[16:04:15.643]   - Field: ‘state’
[16:04:15.643] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.643] - Launch lazy future ...
[16:04:15.643] Packages needed by the future expression (n = 0): <none>
[16:04:15.643] Packages needed by future strategies (n = 0): <none>
[16:04:15.644] {
[16:04:15.644]     {
[16:04:15.644]         {
[16:04:15.644]             ...future.startTime <- base::Sys.time()
[16:04:15.644]             {
[16:04:15.644]                 {
[16:04:15.644]                   {
[16:04:15.644]                     base::local({
[16:04:15.644]                       has_future <- base::requireNamespace("future", 
[16:04:15.644]                         quietly = TRUE)
[16:04:15.644]                       if (has_future) {
[16:04:15.644]                         ns <- base::getNamespace("future")
[16:04:15.644]                         version <- ns[[".package"]][["version"]]
[16:04:15.644]                         if (is.null(version)) 
[16:04:15.644]                           version <- utils::packageVersion("future")
[16:04:15.644]                       }
[16:04:15.644]                       else {
[16:04:15.644]                         version <- NULL
[16:04:15.644]                       }
[16:04:15.644]                       if (!has_future || version < "1.8.0") {
[16:04:15.644]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.644]                           "", base::R.version$version.string), 
[16:04:15.644]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.644]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.644]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.644]                             "release", "version")], collapse = " "), 
[16:04:15.644]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.644]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.644]                           info)
[16:04:15.644]                         info <- base::paste(info, collapse = "; ")
[16:04:15.644]                         if (!has_future) {
[16:04:15.644]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.644]                             info)
[16:04:15.644]                         }
[16:04:15.644]                         else {
[16:04:15.644]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.644]                             info, version)
[16:04:15.644]                         }
[16:04:15.644]                         base::stop(msg)
[16:04:15.644]                       }
[16:04:15.644]                     })
[16:04:15.644]                   }
[16:04:15.644]                   options(future.plan = NULL)
[16:04:15.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.644]                 }
[16:04:15.644]                 ...future.workdir <- getwd()
[16:04:15.644]             }
[16:04:15.644]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.644]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.644]         }
[16:04:15.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.644]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.644]             base::names(...future.oldOptions))
[16:04:15.644]     }
[16:04:15.644]     if (FALSE) {
[16:04:15.644]     }
[16:04:15.644]     else {
[16:04:15.644]         if (TRUE) {
[16:04:15.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.644]                 open = "w")
[16:04:15.644]         }
[16:04:15.644]         else {
[16:04:15.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.644]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.644]         }
[16:04:15.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.644]             base::sink(type = "output", split = FALSE)
[16:04:15.644]             base::close(...future.stdout)
[16:04:15.644]         }, add = TRUE)
[16:04:15.644]     }
[16:04:15.644]     ...future.frame <- base::sys.nframe()
[16:04:15.644]     ...future.conditions <- base::list()
[16:04:15.644]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.644]     if (FALSE) {
[16:04:15.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.644]     }
[16:04:15.644]     ...future.result <- base::tryCatch({
[16:04:15.644]         base::withCallingHandlers({
[16:04:15.644]             ...future.value <- base::withVisible(base::local({
[16:04:15.644]                 sum(x, y, ...)
[16:04:15.644]             }))
[16:04:15.644]             future::FutureResult(value = ...future.value$value, 
[16:04:15.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.644]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.644]                     ...future.globalenv.names))
[16:04:15.644]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.644]         }, condition = base::local({
[16:04:15.644]             c <- base::c
[16:04:15.644]             inherits <- base::inherits
[16:04:15.644]             invokeRestart <- base::invokeRestart
[16:04:15.644]             length <- base::length
[16:04:15.644]             list <- base::list
[16:04:15.644]             seq.int <- base::seq.int
[16:04:15.644]             signalCondition <- base::signalCondition
[16:04:15.644]             sys.calls <- base::sys.calls
[16:04:15.644]             `[[` <- base::`[[`
[16:04:15.644]             `+` <- base::`+`
[16:04:15.644]             `<<-` <- base::`<<-`
[16:04:15.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.644]                   3L)]
[16:04:15.644]             }
[16:04:15.644]             function(cond) {
[16:04:15.644]                 is_error <- inherits(cond, "error")
[16:04:15.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.644]                   NULL)
[16:04:15.644]                 if (is_error) {
[16:04:15.644]                   sessionInformation <- function() {
[16:04:15.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.644]                       search = base::search(), system = base::Sys.info())
[16:04:15.644]                   }
[16:04:15.644]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.644]                     cond$call), session = sessionInformation(), 
[16:04:15.644]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.644]                   signalCondition(cond)
[16:04:15.644]                 }
[16:04:15.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.644]                 "immediateCondition"))) {
[16:04:15.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.644]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.644]                   if (TRUE && !signal) {
[16:04:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.644]                     {
[16:04:15.644]                       inherits <- base::inherits
[16:04:15.644]                       invokeRestart <- base::invokeRestart
[16:04:15.644]                       is.null <- base::is.null
[16:04:15.644]                       muffled <- FALSE
[16:04:15.644]                       if (inherits(cond, "message")) {
[16:04:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.644]                         if (muffled) 
[16:04:15.644]                           invokeRestart("muffleMessage")
[16:04:15.644]                       }
[16:04:15.644]                       else if (inherits(cond, "warning")) {
[16:04:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.644]                         if (muffled) 
[16:04:15.644]                           invokeRestart("muffleWarning")
[16:04:15.644]                       }
[16:04:15.644]                       else if (inherits(cond, "condition")) {
[16:04:15.644]                         if (!is.null(pattern)) {
[16:04:15.644]                           computeRestarts <- base::computeRestarts
[16:04:15.644]                           grepl <- base::grepl
[16:04:15.644]                           restarts <- computeRestarts(cond)
[16:04:15.644]                           for (restart in restarts) {
[16:04:15.644]                             name <- restart$name
[16:04:15.644]                             if (is.null(name)) 
[16:04:15.644]                               next
[16:04:15.644]                             if (!grepl(pattern, name)) 
[16:04:15.644]                               next
[16:04:15.644]                             invokeRestart(restart)
[16:04:15.644]                             muffled <- TRUE
[16:04:15.644]                             break
[16:04:15.644]                           }
[16:04:15.644]                         }
[16:04:15.644]                       }
[16:04:15.644]                       invisible(muffled)
[16:04:15.644]                     }
[16:04:15.644]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.644]                   }
[16:04:15.644]                 }
[16:04:15.644]                 else {
[16:04:15.644]                   if (TRUE) {
[16:04:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.644]                     {
[16:04:15.644]                       inherits <- base::inherits
[16:04:15.644]                       invokeRestart <- base::invokeRestart
[16:04:15.644]                       is.null <- base::is.null
[16:04:15.644]                       muffled <- FALSE
[16:04:15.644]                       if (inherits(cond, "message")) {
[16:04:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.644]                         if (muffled) 
[16:04:15.644]                           invokeRestart("muffleMessage")
[16:04:15.644]                       }
[16:04:15.644]                       else if (inherits(cond, "warning")) {
[16:04:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.644]                         if (muffled) 
[16:04:15.644]                           invokeRestart("muffleWarning")
[16:04:15.644]                       }
[16:04:15.644]                       else if (inherits(cond, "condition")) {
[16:04:15.644]                         if (!is.null(pattern)) {
[16:04:15.644]                           computeRestarts <- base::computeRestarts
[16:04:15.644]                           grepl <- base::grepl
[16:04:15.644]                           restarts <- computeRestarts(cond)
[16:04:15.644]                           for (restart in restarts) {
[16:04:15.644]                             name <- restart$name
[16:04:15.644]                             if (is.null(name)) 
[16:04:15.644]                               next
[16:04:15.644]                             if (!grepl(pattern, name)) 
[16:04:15.644]                               next
[16:04:15.644]                             invokeRestart(restart)
[16:04:15.644]                             muffled <- TRUE
[16:04:15.644]                             break
[16:04:15.644]                           }
[16:04:15.644]                         }
[16:04:15.644]                       }
[16:04:15.644]                       invisible(muffled)
[16:04:15.644]                     }
[16:04:15.644]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.644]                   }
[16:04:15.644]                 }
[16:04:15.644]             }
[16:04:15.644]         }))
[16:04:15.644]     }, error = function(ex) {
[16:04:15.644]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.644]                 ...future.rng), started = ...future.startTime, 
[16:04:15.644]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.644]             version = "1.8"), class = "FutureResult")
[16:04:15.644]     }, finally = {
[16:04:15.644]         if (!identical(...future.workdir, getwd())) 
[16:04:15.644]             setwd(...future.workdir)
[16:04:15.644]         {
[16:04:15.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.644]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.644]             }
[16:04:15.644]             base::options(...future.oldOptions)
[16:04:15.644]             if (.Platform$OS.type == "windows") {
[16:04:15.644]                 old_names <- names(...future.oldEnvVars)
[16:04:15.644]                 envs <- base::Sys.getenv()
[16:04:15.644]                 names <- names(envs)
[16:04:15.644]                 common <- intersect(names, old_names)
[16:04:15.644]                 added <- setdiff(names, old_names)
[16:04:15.644]                 removed <- setdiff(old_names, names)
[16:04:15.644]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.644]                   envs[common]]
[16:04:15.644]                 NAMES <- toupper(changed)
[16:04:15.644]                 args <- list()
[16:04:15.644]                 for (kk in seq_along(NAMES)) {
[16:04:15.644]                   name <- changed[[kk]]
[16:04:15.644]                   NAME <- NAMES[[kk]]
[16:04:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.644]                     next
[16:04:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.644]                 }
[16:04:15.644]                 NAMES <- toupper(added)
[16:04:15.644]                 for (kk in seq_along(NAMES)) {
[16:04:15.644]                   name <- added[[kk]]
[16:04:15.644]                   NAME <- NAMES[[kk]]
[16:04:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.644]                     next
[16:04:15.644]                   args[[name]] <- ""
[16:04:15.644]                 }
[16:04:15.644]                 NAMES <- toupper(removed)
[16:04:15.644]                 for (kk in seq_along(NAMES)) {
[16:04:15.644]                   name <- removed[[kk]]
[16:04:15.644]                   NAME <- NAMES[[kk]]
[16:04:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.644]                     next
[16:04:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.644]                 }
[16:04:15.644]                 if (length(args) > 0) 
[16:04:15.644]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.644]             }
[16:04:15.644]             else {
[16:04:15.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.644]             }
[16:04:15.644]             {
[16:04:15.644]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.644]                   0L) {
[16:04:15.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.644]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.644]                   base::options(opts)
[16:04:15.644]                 }
[16:04:15.644]                 {
[16:04:15.644]                   {
[16:04:15.644]                     NULL
[16:04:15.644]                     RNGkind("Mersenne-Twister")
[16:04:15.644]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.644]                       inherits = FALSE)
[16:04:15.644]                   }
[16:04:15.644]                   options(future.plan = NULL)
[16:04:15.644]                   if (is.na(NA_character_)) 
[16:04:15.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.644]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.644]                   {
[16:04:15.644]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.644]                     if (!future$lazy) 
[16:04:15.644]                       future <- run(future)
[16:04:15.644]                     invisible(future)
[16:04:15.644]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.644]                 }
[16:04:15.644]             }
[16:04:15.644]         }
[16:04:15.644]     })
[16:04:15.644]     if (TRUE) {
[16:04:15.644]         base::sink(type = "output", split = FALSE)
[16:04:15.644]         if (TRUE) {
[16:04:15.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.644]         }
[16:04:15.644]         else {
[16:04:15.644]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.644]         }
[16:04:15.644]         base::close(...future.stdout)
[16:04:15.644]         ...future.stdout <- NULL
[16:04:15.644]     }
[16:04:15.644]     ...future.result$conditions <- ...future.conditions
[16:04:15.644]     ...future.result$finished <- base::Sys.time()
[16:04:15.644]     ...future.result
[16:04:15.644] }
[16:04:15.645] assign_globals() ...
[16:04:15.645] List of 2
[16:04:15.645]  $ x: int [1:2] 1 2
[16:04:15.645]  $ y: num 3
[16:04:15.645]  - attr(*, "where")=List of 2
[16:04:15.645]   ..$ x:<environment: R_EmptyEnv> 
[16:04:15.645]   ..$ y:<environment: R_EmptyEnv> 
[16:04:15.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.645]  - attr(*, "resolved")= logi FALSE
[16:04:15.645]  - attr(*, "total_size")= num 112
[16:04:15.645]  - attr(*, "already-done")= logi TRUE
[16:04:15.650] - copied ‘x’ to environment
[16:04:15.650] - copied ‘y’ to environment
[16:04:15.650] assign_globals() ... done
[16:04:15.650] plan(): Setting new future strategy stack:
[16:04:15.650] List of future strategies:
[16:04:15.650] 1. sequential:
[16:04:15.650]    - args: function (..., envir = parent.frame())
[16:04:15.650]    - tweaked: FALSE
[16:04:15.650]    - call: NULL
[16:04:15.650] plan(): nbrOfWorkers() = 1
[16:04:15.651] plan(): Setting new future strategy stack:
[16:04:15.652] List of future strategies:
[16:04:15.652] 1. sequential:
[16:04:15.652]    - args: function (..., envir = parent.frame())
[16:04:15.652]    - tweaked: FALSE
[16:04:15.652]    - call: plan(strategy, substitute = FALSE)
[16:04:15.652] plan(): nbrOfWorkers() = 1
[16:04:15.652] SequentialFuture started (and completed)
[16:04:15.652] signalConditions() ...
[16:04:15.652]  - include = ‘immediateCondition’
[16:04:15.652]  - exclude = 
[16:04:15.652]  - resignal = FALSE
[16:04:15.652]  - Number of conditions: 1
[16:04:15.653] signalConditions() ... done
[16:04:15.653] - Launch lazy future ... done
[16:04:15.653] run() for ‘SequentialFuture’ ... done
[16:04:15.653] signalConditions() ...
[16:04:15.653]  - include = ‘immediateCondition’
[16:04:15.653]  - exclude = 
[16:04:15.653]  - resignal = FALSE
[16:04:15.653]  - Number of conditions: 1
[16:04:15.653] signalConditions() ... done
[16:04:15.653] Future state: ‘finished’
[16:04:15.654] signalConditions() ...
[16:04:15.654]  - include = ‘condition’
[16:04:15.654]  - exclude = ‘immediateCondition’
[16:04:15.654]  - resignal = TRUE
[16:04:15.654]  - Number of conditions: 1
[16:04:15.654]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:04:15.654] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55e6ee67a488>
Arguments '...' exists: TRUE
[16:04:15.655] getGlobalsAndPackages() ...
[16:04:15.655] - globals passed as-is: [1] ‘...’
[16:04:15.655] Resolving globals: FALSE
[16:04:15.655] Tweak future expression to call with '...' arguments ...
[16:04:15.655] {
[16:04:15.655]     do.call(function(...) {
[16:04:15.655]         fcn <- function() sum(...)
[16:04:15.655]         fcn()
[16:04:15.655]     }, args = future.call.arguments)
[16:04:15.655] }
[16:04:15.656] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.656] The total size of the 1 globals is 112 bytes (112 bytes)
[16:04:15.656] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[16:04:15.656] - globals: [1] ‘future.call.arguments’
[16:04:15.656] 
[16:04:15.657] getGlobalsAndPackages() ... DONE
[16:04:15.657] run() for ‘Future’ ...
[16:04:15.657] - state: ‘created’
[16:04:15.657] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.657] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.657]   - Field: ‘label’
[16:04:15.658]   - Field: ‘local’
[16:04:15.658]   - Field: ‘owner’
[16:04:15.658]   - Field: ‘envir’
[16:04:15.658]   - Field: ‘packages’
[16:04:15.658]   - Field: ‘gc’
[16:04:15.658]   - Field: ‘conditions’
[16:04:15.658]   - Field: ‘expr’
[16:04:15.658]   - Field: ‘uuid’
[16:04:15.658]   - Field: ‘seed’
[16:04:15.658]   - Field: ‘version’
[16:04:15.659]   - Field: ‘result’
[16:04:15.659]   - Field: ‘asynchronous’
[16:04:15.659]   - Field: ‘calls’
[16:04:15.659]   - Field: ‘globals’
[16:04:15.659]   - Field: ‘stdout’
[16:04:15.659]   - Field: ‘earlySignal’
[16:04:15.659]   - Field: ‘lazy’
[16:04:15.659]   - Field: ‘state’
[16:04:15.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.659] - Launch lazy future ...
[16:04:15.660] Packages needed by the future expression (n = 0): <none>
[16:04:15.660] Packages needed by future strategies (n = 0): <none>
[16:04:15.660] {
[16:04:15.660]     {
[16:04:15.660]         {
[16:04:15.660]             ...future.startTime <- base::Sys.time()
[16:04:15.660]             {
[16:04:15.660]                 {
[16:04:15.660]                   {
[16:04:15.660]                     base::local({
[16:04:15.660]                       has_future <- base::requireNamespace("future", 
[16:04:15.660]                         quietly = TRUE)
[16:04:15.660]                       if (has_future) {
[16:04:15.660]                         ns <- base::getNamespace("future")
[16:04:15.660]                         version <- ns[[".package"]][["version"]]
[16:04:15.660]                         if (is.null(version)) 
[16:04:15.660]                           version <- utils::packageVersion("future")
[16:04:15.660]                       }
[16:04:15.660]                       else {
[16:04:15.660]                         version <- NULL
[16:04:15.660]                       }
[16:04:15.660]                       if (!has_future || version < "1.8.0") {
[16:04:15.660]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.660]                           "", base::R.version$version.string), 
[16:04:15.660]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.660]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.660]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.660]                             "release", "version")], collapse = " "), 
[16:04:15.660]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.660]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.660]                           info)
[16:04:15.660]                         info <- base::paste(info, collapse = "; ")
[16:04:15.660]                         if (!has_future) {
[16:04:15.660]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.660]                             info)
[16:04:15.660]                         }
[16:04:15.660]                         else {
[16:04:15.660]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.660]                             info, version)
[16:04:15.660]                         }
[16:04:15.660]                         base::stop(msg)
[16:04:15.660]                       }
[16:04:15.660]                     })
[16:04:15.660]                   }
[16:04:15.660]                   options(future.plan = NULL)
[16:04:15.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.660]                 }
[16:04:15.660]                 ...future.workdir <- getwd()
[16:04:15.660]             }
[16:04:15.660]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.660]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.660]         }
[16:04:15.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.660]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.660]             base::names(...future.oldOptions))
[16:04:15.660]     }
[16:04:15.660]     if (FALSE) {
[16:04:15.660]     }
[16:04:15.660]     else {
[16:04:15.660]         if (TRUE) {
[16:04:15.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.660]                 open = "w")
[16:04:15.660]         }
[16:04:15.660]         else {
[16:04:15.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.660]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.660]         }
[16:04:15.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.660]             base::sink(type = "output", split = FALSE)
[16:04:15.660]             base::close(...future.stdout)
[16:04:15.660]         }, add = TRUE)
[16:04:15.660]     }
[16:04:15.660]     ...future.frame <- base::sys.nframe()
[16:04:15.660]     ...future.conditions <- base::list()
[16:04:15.660]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.660]     if (FALSE) {
[16:04:15.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.660]     }
[16:04:15.660]     ...future.result <- base::tryCatch({
[16:04:15.660]         base::withCallingHandlers({
[16:04:15.660]             ...future.value <- base::withVisible(base::local({
[16:04:15.660]                 do.call(function(...) {
[16:04:15.660]                   fcn <- function() sum(...)
[16:04:15.660]                   fcn()
[16:04:15.660]                 }, args = future.call.arguments)
[16:04:15.660]             }))
[16:04:15.660]             future::FutureResult(value = ...future.value$value, 
[16:04:15.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.660]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.660]                     ...future.globalenv.names))
[16:04:15.660]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.660]         }, condition = base::local({
[16:04:15.660]             c <- base::c
[16:04:15.660]             inherits <- base::inherits
[16:04:15.660]             invokeRestart <- base::invokeRestart
[16:04:15.660]             length <- base::length
[16:04:15.660]             list <- base::list
[16:04:15.660]             seq.int <- base::seq.int
[16:04:15.660]             signalCondition <- base::signalCondition
[16:04:15.660]             sys.calls <- base::sys.calls
[16:04:15.660]             `[[` <- base::`[[`
[16:04:15.660]             `+` <- base::`+`
[16:04:15.660]             `<<-` <- base::`<<-`
[16:04:15.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.660]                   3L)]
[16:04:15.660]             }
[16:04:15.660]             function(cond) {
[16:04:15.660]                 is_error <- inherits(cond, "error")
[16:04:15.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.660]                   NULL)
[16:04:15.660]                 if (is_error) {
[16:04:15.660]                   sessionInformation <- function() {
[16:04:15.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.660]                       search = base::search(), system = base::Sys.info())
[16:04:15.660]                   }
[16:04:15.660]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.660]                     cond$call), session = sessionInformation(), 
[16:04:15.660]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.660]                   signalCondition(cond)
[16:04:15.660]                 }
[16:04:15.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.660]                 "immediateCondition"))) {
[16:04:15.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.660]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.660]                   if (TRUE && !signal) {
[16:04:15.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.660]                     {
[16:04:15.660]                       inherits <- base::inherits
[16:04:15.660]                       invokeRestart <- base::invokeRestart
[16:04:15.660]                       is.null <- base::is.null
[16:04:15.660]                       muffled <- FALSE
[16:04:15.660]                       if (inherits(cond, "message")) {
[16:04:15.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.660]                         if (muffled) 
[16:04:15.660]                           invokeRestart("muffleMessage")
[16:04:15.660]                       }
[16:04:15.660]                       else if (inherits(cond, "warning")) {
[16:04:15.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.660]                         if (muffled) 
[16:04:15.660]                           invokeRestart("muffleWarning")
[16:04:15.660]                       }
[16:04:15.660]                       else if (inherits(cond, "condition")) {
[16:04:15.660]                         if (!is.null(pattern)) {
[16:04:15.660]                           computeRestarts <- base::computeRestarts
[16:04:15.660]                           grepl <- base::grepl
[16:04:15.660]                           restarts <- computeRestarts(cond)
[16:04:15.660]                           for (restart in restarts) {
[16:04:15.660]                             name <- restart$name
[16:04:15.660]                             if (is.null(name)) 
[16:04:15.660]                               next
[16:04:15.660]                             if (!grepl(pattern, name)) 
[16:04:15.660]                               next
[16:04:15.660]                             invokeRestart(restart)
[16:04:15.660]                             muffled <- TRUE
[16:04:15.660]                             break
[16:04:15.660]                           }
[16:04:15.660]                         }
[16:04:15.660]                       }
[16:04:15.660]                       invisible(muffled)
[16:04:15.660]                     }
[16:04:15.660]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.660]                   }
[16:04:15.660]                 }
[16:04:15.660]                 else {
[16:04:15.660]                   if (TRUE) {
[16:04:15.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.660]                     {
[16:04:15.660]                       inherits <- base::inherits
[16:04:15.660]                       invokeRestart <- base::invokeRestart
[16:04:15.660]                       is.null <- base::is.null
[16:04:15.660]                       muffled <- FALSE
[16:04:15.660]                       if (inherits(cond, "message")) {
[16:04:15.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.660]                         if (muffled) 
[16:04:15.660]                           invokeRestart("muffleMessage")
[16:04:15.660]                       }
[16:04:15.660]                       else if (inherits(cond, "warning")) {
[16:04:15.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.660]                         if (muffled) 
[16:04:15.660]                           invokeRestart("muffleWarning")
[16:04:15.660]                       }
[16:04:15.660]                       else if (inherits(cond, "condition")) {
[16:04:15.660]                         if (!is.null(pattern)) {
[16:04:15.660]                           computeRestarts <- base::computeRestarts
[16:04:15.660]                           grepl <- base::grepl
[16:04:15.660]                           restarts <- computeRestarts(cond)
[16:04:15.660]                           for (restart in restarts) {
[16:04:15.660]                             name <- restart$name
[16:04:15.660]                             if (is.null(name)) 
[16:04:15.660]                               next
[16:04:15.660]                             if (!grepl(pattern, name)) 
[16:04:15.660]                               next
[16:04:15.660]                             invokeRestart(restart)
[16:04:15.660]                             muffled <- TRUE
[16:04:15.660]                             break
[16:04:15.660]                           }
[16:04:15.660]                         }
[16:04:15.660]                       }
[16:04:15.660]                       invisible(muffled)
[16:04:15.660]                     }
[16:04:15.660]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.660]                   }
[16:04:15.660]                 }
[16:04:15.660]             }
[16:04:15.660]         }))
[16:04:15.660]     }, error = function(ex) {
[16:04:15.660]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.660]                 ...future.rng), started = ...future.startTime, 
[16:04:15.660]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.660]             version = "1.8"), class = "FutureResult")
[16:04:15.660]     }, finally = {
[16:04:15.660]         if (!identical(...future.workdir, getwd())) 
[16:04:15.660]             setwd(...future.workdir)
[16:04:15.660]         {
[16:04:15.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.660]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.660]             }
[16:04:15.660]             base::options(...future.oldOptions)
[16:04:15.660]             if (.Platform$OS.type == "windows") {
[16:04:15.660]                 old_names <- names(...future.oldEnvVars)
[16:04:15.660]                 envs <- base::Sys.getenv()
[16:04:15.660]                 names <- names(envs)
[16:04:15.660]                 common <- intersect(names, old_names)
[16:04:15.660]                 added <- setdiff(names, old_names)
[16:04:15.660]                 removed <- setdiff(old_names, names)
[16:04:15.660]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.660]                   envs[common]]
[16:04:15.660]                 NAMES <- toupper(changed)
[16:04:15.660]                 args <- list()
[16:04:15.660]                 for (kk in seq_along(NAMES)) {
[16:04:15.660]                   name <- changed[[kk]]
[16:04:15.660]                   NAME <- NAMES[[kk]]
[16:04:15.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.660]                     next
[16:04:15.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.660]                 }
[16:04:15.660]                 NAMES <- toupper(added)
[16:04:15.660]                 for (kk in seq_along(NAMES)) {
[16:04:15.660]                   name <- added[[kk]]
[16:04:15.660]                   NAME <- NAMES[[kk]]
[16:04:15.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.660]                     next
[16:04:15.660]                   args[[name]] <- ""
[16:04:15.660]                 }
[16:04:15.660]                 NAMES <- toupper(removed)
[16:04:15.660]                 for (kk in seq_along(NAMES)) {
[16:04:15.660]                   name <- removed[[kk]]
[16:04:15.660]                   NAME <- NAMES[[kk]]
[16:04:15.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.660]                     next
[16:04:15.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.660]                 }
[16:04:15.660]                 if (length(args) > 0) 
[16:04:15.660]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.660]             }
[16:04:15.660]             else {
[16:04:15.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.660]             }
[16:04:15.660]             {
[16:04:15.660]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.660]                   0L) {
[16:04:15.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.660]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.660]                   base::options(opts)
[16:04:15.660]                 }
[16:04:15.660]                 {
[16:04:15.660]                   {
[16:04:15.660]                     NULL
[16:04:15.660]                     RNGkind("Mersenne-Twister")
[16:04:15.660]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.660]                       inherits = FALSE)
[16:04:15.660]                   }
[16:04:15.660]                   options(future.plan = NULL)
[16:04:15.660]                   if (is.na(NA_character_)) 
[16:04:15.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.660]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.660]                   {
[16:04:15.660]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.660]                     if (!future$lazy) 
[16:04:15.660]                       future <- run(future)
[16:04:15.660]                     invisible(future)
[16:04:15.660]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.660]                 }
[16:04:15.660]             }
[16:04:15.660]         }
[16:04:15.660]     })
[16:04:15.660]     if (TRUE) {
[16:04:15.660]         base::sink(type = "output", split = FALSE)
[16:04:15.660]         if (TRUE) {
[16:04:15.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.660]         }
[16:04:15.660]         else {
[16:04:15.660]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.660]         }
[16:04:15.660]         base::close(...future.stdout)
[16:04:15.660]         ...future.stdout <- NULL
[16:04:15.660]     }
[16:04:15.660]     ...future.result$conditions <- ...future.conditions
[16:04:15.660]     ...future.result$finished <- base::Sys.time()
[16:04:15.660]     ...future.result
[16:04:15.660] }
[16:04:15.662] assign_globals() ...
[16:04:15.662] List of 1
[16:04:15.662]  $ future.call.arguments:List of 2
[16:04:15.662]   ..$ : int [1:2] 1 2
[16:04:15.662]   ..$ : num 3
[16:04:15.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.662]  - attr(*, "where")=List of 1
[16:04:15.662]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.662]  - attr(*, "resolved")= logi FALSE
[16:04:15.662]  - attr(*, "total_size")= num 112
[16:04:15.662]  - attr(*, "already-done")= logi TRUE
[16:04:15.665] - copied ‘future.call.arguments’ to environment
[16:04:15.665] assign_globals() ... done
[16:04:15.665] plan(): Setting new future strategy stack:
[16:04:15.665] List of future strategies:
[16:04:15.665] 1. sequential:
[16:04:15.665]    - args: function (..., envir = parent.frame())
[16:04:15.665]    - tweaked: FALSE
[16:04:15.665]    - call: NULL
[16:04:15.666] plan(): nbrOfWorkers() = 1
[16:04:15.666] plan(): Setting new future strategy stack:
[16:04:15.667] List of future strategies:
[16:04:15.667] 1. sequential:
[16:04:15.667]    - args: function (..., envir = parent.frame())
[16:04:15.667]    - tweaked: FALSE
[16:04:15.667]    - call: plan(strategy, substitute = FALSE)
[16:04:15.667] plan(): nbrOfWorkers() = 1
[16:04:15.667] SequentialFuture started (and completed)
[16:04:15.667] - Launch lazy future ... done
[16:04:15.667] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55e6ecf4b790>
Using '...' in a formula
[16:04:15.668] getGlobalsAndPackages() ...
[16:04:15.668] Searching for globals...
[16:04:15.671] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[16:04:15.671] Searching for globals ... DONE
[16:04:15.671] Resolving globals: FALSE
[16:04:15.671] Tweak future expression to call with '...' arguments ...
[16:04:15.672] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[16:04:15.672] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.672] - globals: [3] ‘fcn’, ‘x’, ‘y’
[16:04:15.672] 
[16:04:15.672] getGlobalsAndPackages() ... DONE
[16:04:15.673] run() for ‘Future’ ...
[16:04:15.673] - state: ‘created’
[16:04:15.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:04:15.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:04:15.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:04:15.673]   - Field: ‘label’
[16:04:15.673]   - Field: ‘local’
[16:04:15.673]   - Field: ‘owner’
[16:04:15.673]   - Field: ‘envir’
[16:04:15.674]   - Field: ‘packages’
[16:04:15.674]   - Field: ‘gc’
[16:04:15.675]   - Field: ‘conditions’
[16:04:15.675]   - Field: ‘expr’
[16:04:15.675]   - Field: ‘uuid’
[16:04:15.675]   - Field: ‘seed’
[16:04:15.676]   - Field: ‘version’
[16:04:15.676]   - Field: ‘result’
[16:04:15.676]   - Field: ‘asynchronous’
[16:04:15.676]   - Field: ‘calls’
[16:04:15.676]   - Field: ‘globals’
[16:04:15.676]   - Field: ‘stdout’
[16:04:15.676]   - Field: ‘earlySignal’
[16:04:15.676]   - Field: ‘lazy’
[16:04:15.676]   - Field: ‘state’
[16:04:15.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:04:15.677] - Launch lazy future ...
[16:04:15.677] Packages needed by the future expression (n = 0): <none>
[16:04:15.677] Packages needed by future strategies (n = 0): <none>
[16:04:15.677] {
[16:04:15.677]     {
[16:04:15.677]         {
[16:04:15.677]             ...future.startTime <- base::Sys.time()
[16:04:15.677]             {
[16:04:15.677]                 {
[16:04:15.677]                   {
[16:04:15.677]                     base::local({
[16:04:15.677]                       has_future <- base::requireNamespace("future", 
[16:04:15.677]                         quietly = TRUE)
[16:04:15.677]                       if (has_future) {
[16:04:15.677]                         ns <- base::getNamespace("future")
[16:04:15.677]                         version <- ns[[".package"]][["version"]]
[16:04:15.677]                         if (is.null(version)) 
[16:04:15.677]                           version <- utils::packageVersion("future")
[16:04:15.677]                       }
[16:04:15.677]                       else {
[16:04:15.677]                         version <- NULL
[16:04:15.677]                       }
[16:04:15.677]                       if (!has_future || version < "1.8.0") {
[16:04:15.677]                         info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.677]                           "", base::R.version$version.string), 
[16:04:15.677]                           platform = base::sprintf("%s (%s-bit)", 
[16:04:15.677]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.677]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.677]                             "release", "version")], collapse = " "), 
[16:04:15.677]                           hostname = base::Sys.info()[["nodename"]])
[16:04:15.677]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.677]                           info)
[16:04:15.677]                         info <- base::paste(info, collapse = "; ")
[16:04:15.677]                         if (!has_future) {
[16:04:15.677]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.677]                             info)
[16:04:15.677]                         }
[16:04:15.677]                         else {
[16:04:15.677]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.677]                             info, version)
[16:04:15.677]                         }
[16:04:15.677]                         base::stop(msg)
[16:04:15.677]                       }
[16:04:15.677]                     })
[16:04:15.677]                   }
[16:04:15.677]                   options(future.plan = NULL)
[16:04:15.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.677]                 }
[16:04:15.677]                 ...future.workdir <- getwd()
[16:04:15.677]             }
[16:04:15.677]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.677]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.677]         }
[16:04:15.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.677]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.677]             base::names(...future.oldOptions))
[16:04:15.677]     }
[16:04:15.677]     if (FALSE) {
[16:04:15.677]     }
[16:04:15.677]     else {
[16:04:15.677]         if (TRUE) {
[16:04:15.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.677]                 open = "w")
[16:04:15.677]         }
[16:04:15.677]         else {
[16:04:15.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.677]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.677]         }
[16:04:15.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.677]             base::sink(type = "output", split = FALSE)
[16:04:15.677]             base::close(...future.stdout)
[16:04:15.677]         }, add = TRUE)
[16:04:15.677]     }
[16:04:15.677]     ...future.frame <- base::sys.nframe()
[16:04:15.677]     ...future.conditions <- base::list()
[16:04:15.677]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.677]     if (FALSE) {
[16:04:15.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.677]     }
[16:04:15.677]     ...future.result <- base::tryCatch({
[16:04:15.677]         base::withCallingHandlers({
[16:04:15.677]             ...future.value <- base::withVisible(base::local(fcn(x, 
[16:04:15.677]                 y)))
[16:04:15.677]             future::FutureResult(value = ...future.value$value, 
[16:04:15.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.677]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.677]                     ...future.globalenv.names))
[16:04:15.677]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.677]         }, condition = base::local({
[16:04:15.677]             c <- base::c
[16:04:15.677]             inherits <- base::inherits
[16:04:15.677]             invokeRestart <- base::invokeRestart
[16:04:15.677]             length <- base::length
[16:04:15.677]             list <- base::list
[16:04:15.677]             seq.int <- base::seq.int
[16:04:15.677]             signalCondition <- base::signalCondition
[16:04:15.677]             sys.calls <- base::sys.calls
[16:04:15.677]             `[[` <- base::`[[`
[16:04:15.677]             `+` <- base::`+`
[16:04:15.677]             `<<-` <- base::`<<-`
[16:04:15.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.677]                   3L)]
[16:04:15.677]             }
[16:04:15.677]             function(cond) {
[16:04:15.677]                 is_error <- inherits(cond, "error")
[16:04:15.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.677]                   NULL)
[16:04:15.677]                 if (is_error) {
[16:04:15.677]                   sessionInformation <- function() {
[16:04:15.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.677]                       search = base::search(), system = base::Sys.info())
[16:04:15.677]                   }
[16:04:15.677]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.677]                     cond$call), session = sessionInformation(), 
[16:04:15.677]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.677]                   signalCondition(cond)
[16:04:15.677]                 }
[16:04:15.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.677]                 "immediateCondition"))) {
[16:04:15.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.677]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.677]                   if (TRUE && !signal) {
[16:04:15.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.677]                     {
[16:04:15.677]                       inherits <- base::inherits
[16:04:15.677]                       invokeRestart <- base::invokeRestart
[16:04:15.677]                       is.null <- base::is.null
[16:04:15.677]                       muffled <- FALSE
[16:04:15.677]                       if (inherits(cond, "message")) {
[16:04:15.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.677]                         if (muffled) 
[16:04:15.677]                           invokeRestart("muffleMessage")
[16:04:15.677]                       }
[16:04:15.677]                       else if (inherits(cond, "warning")) {
[16:04:15.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.677]                         if (muffled) 
[16:04:15.677]                           invokeRestart("muffleWarning")
[16:04:15.677]                       }
[16:04:15.677]                       else if (inherits(cond, "condition")) {
[16:04:15.677]                         if (!is.null(pattern)) {
[16:04:15.677]                           computeRestarts <- base::computeRestarts
[16:04:15.677]                           grepl <- base::grepl
[16:04:15.677]                           restarts <- computeRestarts(cond)
[16:04:15.677]                           for (restart in restarts) {
[16:04:15.677]                             name <- restart$name
[16:04:15.677]                             if (is.null(name)) 
[16:04:15.677]                               next
[16:04:15.677]                             if (!grepl(pattern, name)) 
[16:04:15.677]                               next
[16:04:15.677]                             invokeRestart(restart)
[16:04:15.677]                             muffled <- TRUE
[16:04:15.677]                             break
[16:04:15.677]                           }
[16:04:15.677]                         }
[16:04:15.677]                       }
[16:04:15.677]                       invisible(muffled)
[16:04:15.677]                     }
[16:04:15.677]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.677]                   }
[16:04:15.677]                 }
[16:04:15.677]                 else {
[16:04:15.677]                   if (TRUE) {
[16:04:15.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.677]                     {
[16:04:15.677]                       inherits <- base::inherits
[16:04:15.677]                       invokeRestart <- base::invokeRestart
[16:04:15.677]                       is.null <- base::is.null
[16:04:15.677]                       muffled <- FALSE
[16:04:15.677]                       if (inherits(cond, "message")) {
[16:04:15.677]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.677]                         if (muffled) 
[16:04:15.677]                           invokeRestart("muffleMessage")
[16:04:15.677]                       }
[16:04:15.677]                       else if (inherits(cond, "warning")) {
[16:04:15.677]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.677]                         if (muffled) 
[16:04:15.677]                           invokeRestart("muffleWarning")
[16:04:15.677]                       }
[16:04:15.677]                       else if (inherits(cond, "condition")) {
[16:04:15.677]                         if (!is.null(pattern)) {
[16:04:15.677]                           computeRestarts <- base::computeRestarts
[16:04:15.677]                           grepl <- base::grepl
[16:04:15.677]                           restarts <- computeRestarts(cond)
[16:04:15.677]                           for (restart in restarts) {
[16:04:15.677]                             name <- restart$name
[16:04:15.677]                             if (is.null(name)) 
[16:04:15.677]                               next
[16:04:15.677]                             if (!grepl(pattern, name)) 
[16:04:15.677]                               next
[16:04:15.677]                             invokeRestart(restart)
[16:04:15.677]                             muffled <- TRUE
[16:04:15.677]                             break
[16:04:15.677]                           }
[16:04:15.677]                         }
[16:04:15.677]                       }
[16:04:15.677]                       invisible(muffled)
[16:04:15.677]                     }
[16:04:15.677]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.677]                   }
[16:04:15.677]                 }
[16:04:15.677]             }
[16:04:15.677]         }))
[16:04:15.677]     }, error = function(ex) {
[16:04:15.677]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.677]                 ...future.rng), started = ...future.startTime, 
[16:04:15.677]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.677]             version = "1.8"), class = "FutureResult")
[16:04:15.677]     }, finally = {
[16:04:15.677]         if (!identical(...future.workdir, getwd())) 
[16:04:15.677]             setwd(...future.workdir)
[16:04:15.677]         {
[16:04:15.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.677]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.677]             }
[16:04:15.677]             base::options(...future.oldOptions)
[16:04:15.677]             if (.Platform$OS.type == "windows") {
[16:04:15.677]                 old_names <- names(...future.oldEnvVars)
[16:04:15.677]                 envs <- base::Sys.getenv()
[16:04:15.677]                 names <- names(envs)
[16:04:15.677]                 common <- intersect(names, old_names)
[16:04:15.677]                 added <- setdiff(names, old_names)
[16:04:15.677]                 removed <- setdiff(old_names, names)
[16:04:15.677]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.677]                   envs[common]]
[16:04:15.677]                 NAMES <- toupper(changed)
[16:04:15.677]                 args <- list()
[16:04:15.677]                 for (kk in seq_along(NAMES)) {
[16:04:15.677]                   name <- changed[[kk]]
[16:04:15.677]                   NAME <- NAMES[[kk]]
[16:04:15.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.677]                     next
[16:04:15.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.677]                 }
[16:04:15.677]                 NAMES <- toupper(added)
[16:04:15.677]                 for (kk in seq_along(NAMES)) {
[16:04:15.677]                   name <- added[[kk]]
[16:04:15.677]                   NAME <- NAMES[[kk]]
[16:04:15.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.677]                     next
[16:04:15.677]                   args[[name]] <- ""
[16:04:15.677]                 }
[16:04:15.677]                 NAMES <- toupper(removed)
[16:04:15.677]                 for (kk in seq_along(NAMES)) {
[16:04:15.677]                   name <- removed[[kk]]
[16:04:15.677]                   NAME <- NAMES[[kk]]
[16:04:15.677]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.677]                     next
[16:04:15.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.677]                 }
[16:04:15.677]                 if (length(args) > 0) 
[16:04:15.677]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.677]             }
[16:04:15.677]             else {
[16:04:15.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.677]             }
[16:04:15.677]             {
[16:04:15.677]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.677]                   0L) {
[16:04:15.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.677]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.677]                   base::options(opts)
[16:04:15.677]                 }
[16:04:15.677]                 {
[16:04:15.677]                   {
[16:04:15.677]                     NULL
[16:04:15.677]                     RNGkind("Mersenne-Twister")
[16:04:15.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:04:15.677]                       inherits = FALSE)
[16:04:15.677]                   }
[16:04:15.677]                   options(future.plan = NULL)
[16:04:15.677]                   if (is.na(NA_character_)) 
[16:04:15.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.677]                   future::plan(list(function (..., envir = parent.frame()) 
[16:04:15.677]                   {
[16:04:15.677]                     future <- SequentialFuture(..., envir = envir)
[16:04:15.677]                     if (!future$lazy) 
[16:04:15.677]                       future <- run(future)
[16:04:15.677]                     invisible(future)
[16:04:15.677]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.677]                 }
[16:04:15.677]             }
[16:04:15.677]         }
[16:04:15.677]     })
[16:04:15.677]     if (TRUE) {
[16:04:15.677]         base::sink(type = "output", split = FALSE)
[16:04:15.677]         if (TRUE) {
[16:04:15.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.677]         }
[16:04:15.677]         else {
[16:04:15.677]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.677]         }
[16:04:15.677]         base::close(...future.stdout)
[16:04:15.677]         ...future.stdout <- NULL
[16:04:15.677]     }
[16:04:15.677]     ...future.result$conditions <- ...future.conditions
[16:04:15.677]     ...future.result$finished <- base::Sys.time()
[16:04:15.677]     ...future.result
[16:04:15.677] }
[16:04:15.679] assign_globals() ...
[16:04:15.679] List of 3
[16:04:15.679]  $ fcn:function (x, y)  
[16:04:15.679]  $ x  : int [1:2] 1 2
[16:04:15.679]  $ y  : num 3
[16:04:15.679]  - attr(*, "where")=List of 3
[16:04:15.679]   ..$ fcn:<environment: R_EmptyEnv> 
[16:04:15.679]   ..$ x  :<environment: R_EmptyEnv> 
[16:04:15.679]   ..$ y  :<environment: R_EmptyEnv> 
[16:04:15.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.679]  - attr(*, "resolved")= logi FALSE
[16:04:15.679]  - attr(*, "total_size")= num 4280
[16:04:15.679]  - attr(*, "already-done")= logi TRUE
[16:04:15.682] - reassign environment for ‘fcn’
[16:04:15.682] - copied ‘fcn’ to environment
[16:04:15.682] - copied ‘x’ to environment
[16:04:15.683] - copied ‘y’ to environment
[16:04:15.683] assign_globals() ... done
[16:04:15.683] plan(): Setting new future strategy stack:
[16:04:15.683] List of future strategies:
[16:04:15.683] 1. sequential:
[16:04:15.683]    - args: function (..., envir = parent.frame())
[16:04:15.683]    - tweaked: FALSE
[16:04:15.683]    - call: NULL
[16:04:15.683] plan(): nbrOfWorkers() = 1
[16:04:15.684] plan(): Setting new future strategy stack:
[16:04:15.684] List of future strategies:
[16:04:15.684] 1. sequential:
[16:04:15.684]    - args: function (..., envir = parent.frame())
[16:04:15.684]    - tweaked: FALSE
[16:04:15.684]    - call: plan(strategy, substitute = FALSE)
[16:04:15.684] plan(): nbrOfWorkers() = 1
[16:04:15.685] SequentialFuture started (and completed)
[16:04:15.685] - Launch lazy future ... done
[16:04:15.685] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[16:04:15.690] plan(): Setting new future strategy stack:
[16:04:15.690] List of future strategies:
[16:04:15.690] 1. multicore:
[16:04:15.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.690]    - tweaked: FALSE
[16:04:15.690]    - call: plan(strategy, substitute = FALSE)
[16:04:15.694] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55e6eee73af0>
Arguments '...' exists: TRUE
[16:04:15.694] getGlobalsAndPackages() ...
[16:04:15.694] Searching for globals...
[16:04:15.696] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:15.696] Searching for globals ... DONE
[16:04:15.696] Resolving globals: FALSE
[16:04:15.696] Tweak future expression to call with '...' arguments ...
[16:04:15.696] {
[16:04:15.696]     do.call(function(...) {
[16:04:15.696]         sum(x, ...)
[16:04:15.696]     }, args = future.call.arguments)
[16:04:15.696] }
[16:04:15.696] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.697] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.697] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:15.697] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:15.697] 
[16:04:15.698] getGlobalsAndPackages() ... DONE
[16:04:15.698] run() for ‘Future’ ...
[16:04:15.698] - state: ‘created’
[16:04:15.698] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.701] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.702] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.702]   - Field: ‘label’
[16:04:15.702]   - Field: ‘local’
[16:04:15.702]   - Field: ‘owner’
[16:04:15.702]   - Field: ‘envir’
[16:04:15.702]   - Field: ‘workers’
[16:04:15.702]   - Field: ‘packages’
[16:04:15.702]   - Field: ‘gc’
[16:04:15.702]   - Field: ‘job’
[16:04:15.702]   - Field: ‘conditions’
[16:04:15.703]   - Field: ‘expr’
[16:04:15.703]   - Field: ‘uuid’
[16:04:15.703]   - Field: ‘seed’
[16:04:15.703]   - Field: ‘version’
[16:04:15.703]   - Field: ‘result’
[16:04:15.703]   - Field: ‘asynchronous’
[16:04:15.703]   - Field: ‘calls’
[16:04:15.705]   - Field: ‘globals’
[16:04:15.705]   - Field: ‘stdout’
[16:04:15.705]   - Field: ‘earlySignal’
[16:04:15.705]   - Field: ‘lazy’
[16:04:15.705]   - Field: ‘state’
[16:04:15.705] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.705] - Launch lazy future ...
[16:04:15.706] Packages needed by the future expression (n = 0): <none>
[16:04:15.707] Packages needed by future strategies (n = 0): <none>
[16:04:15.707] {
[16:04:15.707]     {
[16:04:15.707]         {
[16:04:15.707]             ...future.startTime <- base::Sys.time()
[16:04:15.707]             {
[16:04:15.707]                 {
[16:04:15.707]                   {
[16:04:15.707]                     {
[16:04:15.707]                       base::local({
[16:04:15.707]                         has_future <- base::requireNamespace("future", 
[16:04:15.707]                           quietly = TRUE)
[16:04:15.707]                         if (has_future) {
[16:04:15.707]                           ns <- base::getNamespace("future")
[16:04:15.707]                           version <- ns[[".package"]][["version"]]
[16:04:15.707]                           if (is.null(version)) 
[16:04:15.707]                             version <- utils::packageVersion("future")
[16:04:15.707]                         }
[16:04:15.707]                         else {
[16:04:15.707]                           version <- NULL
[16:04:15.707]                         }
[16:04:15.707]                         if (!has_future || version < "1.8.0") {
[16:04:15.707]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.707]                             "", base::R.version$version.string), 
[16:04:15.707]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.707]                               "release", "version")], collapse = " "), 
[16:04:15.707]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.707]                             info)
[16:04:15.707]                           info <- base::paste(info, collapse = "; ")
[16:04:15.707]                           if (!has_future) {
[16:04:15.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.707]                               info)
[16:04:15.707]                           }
[16:04:15.707]                           else {
[16:04:15.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.707]                               info, version)
[16:04:15.707]                           }
[16:04:15.707]                           base::stop(msg)
[16:04:15.707]                         }
[16:04:15.707]                       })
[16:04:15.707]                     }
[16:04:15.707]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.707]                     base::options(mc.cores = 1L)
[16:04:15.707]                   }
[16:04:15.707]                   options(future.plan = NULL)
[16:04:15.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.707]                 }
[16:04:15.707]                 ...future.workdir <- getwd()
[16:04:15.707]             }
[16:04:15.707]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.707]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.707]         }
[16:04:15.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.707]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.707]             base::names(...future.oldOptions))
[16:04:15.707]     }
[16:04:15.707]     if (FALSE) {
[16:04:15.707]     }
[16:04:15.707]     else {
[16:04:15.707]         if (TRUE) {
[16:04:15.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.707]                 open = "w")
[16:04:15.707]         }
[16:04:15.707]         else {
[16:04:15.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.707]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.707]         }
[16:04:15.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.707]             base::sink(type = "output", split = FALSE)
[16:04:15.707]             base::close(...future.stdout)
[16:04:15.707]         }, add = TRUE)
[16:04:15.707]     }
[16:04:15.707]     ...future.frame <- base::sys.nframe()
[16:04:15.707]     ...future.conditions <- base::list()
[16:04:15.707]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.707]     if (FALSE) {
[16:04:15.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.707]     }
[16:04:15.707]     ...future.result <- base::tryCatch({
[16:04:15.707]         base::withCallingHandlers({
[16:04:15.707]             ...future.value <- base::withVisible(base::local({
[16:04:15.707]                 withCallingHandlers({
[16:04:15.707]                   {
[16:04:15.707]                     do.call(function(...) {
[16:04:15.707]                       sum(x, ...)
[16:04:15.707]                     }, args = future.call.arguments)
[16:04:15.707]                   }
[16:04:15.707]                 }, immediateCondition = function(cond) {
[16:04:15.707]                   save_rds <- function (object, pathname, ...) 
[16:04:15.707]                   {
[16:04:15.707]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.707]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.707]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.707]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.707]                         fi_tmp[["mtime"]])
[16:04:15.707]                     }
[16:04:15.707]                     tryCatch({
[16:04:15.707]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.707]                     }, error = function(ex) {
[16:04:15.707]                       msg <- conditionMessage(ex)
[16:04:15.707]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.707]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.707]                         fi_tmp[["mtime"]], msg)
[16:04:15.707]                       ex$message <- msg
[16:04:15.707]                       stop(ex)
[16:04:15.707]                     })
[16:04:15.707]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.707]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.707]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.707]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.707]                       fi <- file.info(pathname)
[16:04:15.707]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.707]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.707]                         fi[["size"]], fi[["mtime"]])
[16:04:15.707]                       stop(msg)
[16:04:15.707]                     }
[16:04:15.707]                     invisible(pathname)
[16:04:15.707]                   }
[16:04:15.707]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.707]                     rootPath = tempdir()) 
[16:04:15.707]                   {
[16:04:15.707]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.707]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.707]                       tmpdir = path, fileext = ".rds")
[16:04:15.707]                     save_rds(obj, file)
[16:04:15.707]                   }
[16:04:15.707]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.707]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.707]                   {
[16:04:15.707]                     inherits <- base::inherits
[16:04:15.707]                     invokeRestart <- base::invokeRestart
[16:04:15.707]                     is.null <- base::is.null
[16:04:15.707]                     muffled <- FALSE
[16:04:15.707]                     if (inherits(cond, "message")) {
[16:04:15.707]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.707]                       if (muffled) 
[16:04:15.707]                         invokeRestart("muffleMessage")
[16:04:15.707]                     }
[16:04:15.707]                     else if (inherits(cond, "warning")) {
[16:04:15.707]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.707]                       if (muffled) 
[16:04:15.707]                         invokeRestart("muffleWarning")
[16:04:15.707]                     }
[16:04:15.707]                     else if (inherits(cond, "condition")) {
[16:04:15.707]                       if (!is.null(pattern)) {
[16:04:15.707]                         computeRestarts <- base::computeRestarts
[16:04:15.707]                         grepl <- base::grepl
[16:04:15.707]                         restarts <- computeRestarts(cond)
[16:04:15.707]                         for (restart in restarts) {
[16:04:15.707]                           name <- restart$name
[16:04:15.707]                           if (is.null(name)) 
[16:04:15.707]                             next
[16:04:15.707]                           if (!grepl(pattern, name)) 
[16:04:15.707]                             next
[16:04:15.707]                           invokeRestart(restart)
[16:04:15.707]                           muffled <- TRUE
[16:04:15.707]                           break
[16:04:15.707]                         }
[16:04:15.707]                       }
[16:04:15.707]                     }
[16:04:15.707]                     invisible(muffled)
[16:04:15.707]                   }
[16:04:15.707]                   muffleCondition(cond)
[16:04:15.707]                 })
[16:04:15.707]             }))
[16:04:15.707]             future::FutureResult(value = ...future.value$value, 
[16:04:15.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.707]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.707]                     ...future.globalenv.names))
[16:04:15.707]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.707]         }, condition = base::local({
[16:04:15.707]             c <- base::c
[16:04:15.707]             inherits <- base::inherits
[16:04:15.707]             invokeRestart <- base::invokeRestart
[16:04:15.707]             length <- base::length
[16:04:15.707]             list <- base::list
[16:04:15.707]             seq.int <- base::seq.int
[16:04:15.707]             signalCondition <- base::signalCondition
[16:04:15.707]             sys.calls <- base::sys.calls
[16:04:15.707]             `[[` <- base::`[[`
[16:04:15.707]             `+` <- base::`+`
[16:04:15.707]             `<<-` <- base::`<<-`
[16:04:15.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.707]                   3L)]
[16:04:15.707]             }
[16:04:15.707]             function(cond) {
[16:04:15.707]                 is_error <- inherits(cond, "error")
[16:04:15.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.707]                   NULL)
[16:04:15.707]                 if (is_error) {
[16:04:15.707]                   sessionInformation <- function() {
[16:04:15.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.707]                       search = base::search(), system = base::Sys.info())
[16:04:15.707]                   }
[16:04:15.707]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.707]                     cond$call), session = sessionInformation(), 
[16:04:15.707]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.707]                   signalCondition(cond)
[16:04:15.707]                 }
[16:04:15.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.707]                 "immediateCondition"))) {
[16:04:15.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.707]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.707]                   if (TRUE && !signal) {
[16:04:15.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.707]                     {
[16:04:15.707]                       inherits <- base::inherits
[16:04:15.707]                       invokeRestart <- base::invokeRestart
[16:04:15.707]                       is.null <- base::is.null
[16:04:15.707]                       muffled <- FALSE
[16:04:15.707]                       if (inherits(cond, "message")) {
[16:04:15.707]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.707]                         if (muffled) 
[16:04:15.707]                           invokeRestart("muffleMessage")
[16:04:15.707]                       }
[16:04:15.707]                       else if (inherits(cond, "warning")) {
[16:04:15.707]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.707]                         if (muffled) 
[16:04:15.707]                           invokeRestart("muffleWarning")
[16:04:15.707]                       }
[16:04:15.707]                       else if (inherits(cond, "condition")) {
[16:04:15.707]                         if (!is.null(pattern)) {
[16:04:15.707]                           computeRestarts <- base::computeRestarts
[16:04:15.707]                           grepl <- base::grepl
[16:04:15.707]                           restarts <- computeRestarts(cond)
[16:04:15.707]                           for (restart in restarts) {
[16:04:15.707]                             name <- restart$name
[16:04:15.707]                             if (is.null(name)) 
[16:04:15.707]                               next
[16:04:15.707]                             if (!grepl(pattern, name)) 
[16:04:15.707]                               next
[16:04:15.707]                             invokeRestart(restart)
[16:04:15.707]                             muffled <- TRUE
[16:04:15.707]                             break
[16:04:15.707]                           }
[16:04:15.707]                         }
[16:04:15.707]                       }
[16:04:15.707]                       invisible(muffled)
[16:04:15.707]                     }
[16:04:15.707]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.707]                   }
[16:04:15.707]                 }
[16:04:15.707]                 else {
[16:04:15.707]                   if (TRUE) {
[16:04:15.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.707]                     {
[16:04:15.707]                       inherits <- base::inherits
[16:04:15.707]                       invokeRestart <- base::invokeRestart
[16:04:15.707]                       is.null <- base::is.null
[16:04:15.707]                       muffled <- FALSE
[16:04:15.707]                       if (inherits(cond, "message")) {
[16:04:15.707]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.707]                         if (muffled) 
[16:04:15.707]                           invokeRestart("muffleMessage")
[16:04:15.707]                       }
[16:04:15.707]                       else if (inherits(cond, "warning")) {
[16:04:15.707]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.707]                         if (muffled) 
[16:04:15.707]                           invokeRestart("muffleWarning")
[16:04:15.707]                       }
[16:04:15.707]                       else if (inherits(cond, "condition")) {
[16:04:15.707]                         if (!is.null(pattern)) {
[16:04:15.707]                           computeRestarts <- base::computeRestarts
[16:04:15.707]                           grepl <- base::grepl
[16:04:15.707]                           restarts <- computeRestarts(cond)
[16:04:15.707]                           for (restart in restarts) {
[16:04:15.707]                             name <- restart$name
[16:04:15.707]                             if (is.null(name)) 
[16:04:15.707]                               next
[16:04:15.707]                             if (!grepl(pattern, name)) 
[16:04:15.707]                               next
[16:04:15.707]                             invokeRestart(restart)
[16:04:15.707]                             muffled <- TRUE
[16:04:15.707]                             break
[16:04:15.707]                           }
[16:04:15.707]                         }
[16:04:15.707]                       }
[16:04:15.707]                       invisible(muffled)
[16:04:15.707]                     }
[16:04:15.707]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.707]                   }
[16:04:15.707]                 }
[16:04:15.707]             }
[16:04:15.707]         }))
[16:04:15.707]     }, error = function(ex) {
[16:04:15.707]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.707]                 ...future.rng), started = ...future.startTime, 
[16:04:15.707]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.707]             version = "1.8"), class = "FutureResult")
[16:04:15.707]     }, finally = {
[16:04:15.707]         if (!identical(...future.workdir, getwd())) 
[16:04:15.707]             setwd(...future.workdir)
[16:04:15.707]         {
[16:04:15.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.707]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.707]             }
[16:04:15.707]             base::options(...future.oldOptions)
[16:04:15.707]             if (.Platform$OS.type == "windows") {
[16:04:15.707]                 old_names <- names(...future.oldEnvVars)
[16:04:15.707]                 envs <- base::Sys.getenv()
[16:04:15.707]                 names <- names(envs)
[16:04:15.707]                 common <- intersect(names, old_names)
[16:04:15.707]                 added <- setdiff(names, old_names)
[16:04:15.707]                 removed <- setdiff(old_names, names)
[16:04:15.707]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.707]                   envs[common]]
[16:04:15.707]                 NAMES <- toupper(changed)
[16:04:15.707]                 args <- list()
[16:04:15.707]                 for (kk in seq_along(NAMES)) {
[16:04:15.707]                   name <- changed[[kk]]
[16:04:15.707]                   NAME <- NAMES[[kk]]
[16:04:15.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.707]                     next
[16:04:15.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.707]                 }
[16:04:15.707]                 NAMES <- toupper(added)
[16:04:15.707]                 for (kk in seq_along(NAMES)) {
[16:04:15.707]                   name <- added[[kk]]
[16:04:15.707]                   NAME <- NAMES[[kk]]
[16:04:15.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.707]                     next
[16:04:15.707]                   args[[name]] <- ""
[16:04:15.707]                 }
[16:04:15.707]                 NAMES <- toupper(removed)
[16:04:15.707]                 for (kk in seq_along(NAMES)) {
[16:04:15.707]                   name <- removed[[kk]]
[16:04:15.707]                   NAME <- NAMES[[kk]]
[16:04:15.707]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.707]                     next
[16:04:15.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.707]                 }
[16:04:15.707]                 if (length(args) > 0) 
[16:04:15.707]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.707]             }
[16:04:15.707]             else {
[16:04:15.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.707]             }
[16:04:15.707]             {
[16:04:15.707]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.707]                   0L) {
[16:04:15.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.707]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.707]                   base::options(opts)
[16:04:15.707]                 }
[16:04:15.707]                 {
[16:04:15.707]                   {
[16:04:15.707]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.707]                     NULL
[16:04:15.707]                   }
[16:04:15.707]                   options(future.plan = NULL)
[16:04:15.707]                   if (is.na(NA_character_)) 
[16:04:15.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.707]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.707]                     envir = parent.frame()) 
[16:04:15.707]                   {
[16:04:15.707]                     default_workers <- missing(workers)
[16:04:15.707]                     if (is.function(workers)) 
[16:04:15.707]                       workers <- workers()
[16:04:15.707]                     workers <- structure(as.integer(workers), 
[16:04:15.707]                       class = class(workers))
[16:04:15.707]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.707]                       1L)
[16:04:15.707]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.707]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.707]                       if (default_workers) 
[16:04:15.707]                         supportsMulticore(warn = TRUE)
[16:04:15.707]                       return(sequential(..., envir = envir))
[16:04:15.707]                     }
[16:04:15.707]                     oopts <- options(mc.cores = workers)
[16:04:15.707]                     on.exit(options(oopts))
[16:04:15.707]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.707]                       envir = envir)
[16:04:15.707]                     if (!future$lazy) 
[16:04:15.707]                       future <- run(future)
[16:04:15.707]                     invisible(future)
[16:04:15.707]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.707]                 }
[16:04:15.707]             }
[16:04:15.707]         }
[16:04:15.707]     })
[16:04:15.707]     if (TRUE) {
[16:04:15.707]         base::sink(type = "output", split = FALSE)
[16:04:15.707]         if (TRUE) {
[16:04:15.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.707]         }
[16:04:15.707]         else {
[16:04:15.707]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.707]         }
[16:04:15.707]         base::close(...future.stdout)
[16:04:15.707]         ...future.stdout <- NULL
[16:04:15.707]     }
[16:04:15.707]     ...future.result$conditions <- ...future.conditions
[16:04:15.707]     ...future.result$finished <- base::Sys.time()
[16:04:15.707]     ...future.result
[16:04:15.707] }
[16:04:15.710] assign_globals() ...
[16:04:15.710] List of 2
[16:04:15.710]  $ x                    : int [1:2] 1 2
[16:04:15.710]  $ future.call.arguments:List of 1
[16:04:15.710]   ..$ : num 3
[16:04:15.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.710]  - attr(*, "where")=List of 2
[16:04:15.710]   ..$ x                    :<environment: R_EmptyEnv> 
[16:04:15.710]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.710]  - attr(*, "resolved")= logi FALSE
[16:04:15.710]  - attr(*, "total_size")= num 112
[16:04:15.710]  - attr(*, "already-done")= logi TRUE
[16:04:15.713] - copied ‘x’ to environment
[16:04:15.713] - copied ‘future.call.arguments’ to environment
[16:04:15.713] assign_globals() ... done
[16:04:15.713] requestCore(): workers = 2
[16:04:15.716] MulticoreFuture started
[16:04:15.717] - Launch lazy future ... done
[16:04:15.717] plan(): Setting new future strategy stack:
[16:04:15.717] run() for ‘MulticoreFuture’ ... done
[16:04:15.717] List of future strategies:
[16:04:15.717] 1. sequential:
[16:04:15.717]    - args: function (..., envir = parent.frame())
[16:04:15.717]    - tweaked: FALSE
[16:04:15.717]    - call: NULL
[16:04:15.718] plan(): nbrOfWorkers() = 1
[16:04:15.718] result() for MulticoreFuture ...
[16:04:15.720] plan(): Setting new future strategy stack:
[16:04:15.720] List of future strategies:
[16:04:15.720] 1. multicore:
[16:04:15.720]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.720]    - tweaked: FALSE
[16:04:15.720]    - call: plan(strategy, substitute = FALSE)
[16:04:15.725] plan(): nbrOfWorkers() = 2
[16:04:15.729] result() for MulticoreFuture ...
[16:04:15.730] result() for MulticoreFuture ... done
[16:04:15.730] result() for MulticoreFuture ... done
[16:04:15.730] result() for MulticoreFuture ...
[16:04:15.730] result() for MulticoreFuture ... done
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55e6ef12df38>
Arguments '...' exists: TRUE
[16:04:15.731] getGlobalsAndPackages() ...
[16:04:15.731] Searching for globals...
[16:04:15.733] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:15.733] Searching for globals ... DONE
[16:04:15.733] Resolving globals: FALSE
[16:04:15.733] Tweak future expression to call with '...' arguments ...
[16:04:15.733] {
[16:04:15.733]     do.call(function(...) {
[16:04:15.733]         sum(x, ...)
[16:04:15.733]     }, args = future.call.arguments)
[16:04:15.733] }
[16:04:15.733] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.734] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.735] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:15.735] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:15.735] 
[16:04:15.735] getGlobalsAndPackages() ... DONE
[16:04:15.735] run() for ‘Future’ ...
[16:04:15.736] - state: ‘created’
[16:04:15.736] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.740] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.740]   - Field: ‘label’
[16:04:15.740]   - Field: ‘local’
[16:04:15.740]   - Field: ‘owner’
[16:04:15.740]   - Field: ‘envir’
[16:04:15.741]   - Field: ‘workers’
[16:04:15.741]   - Field: ‘packages’
[16:04:15.741]   - Field: ‘gc’
[16:04:15.741]   - Field: ‘job’
[16:04:15.741]   - Field: ‘conditions’
[16:04:15.741]   - Field: ‘expr’
[16:04:15.741]   - Field: ‘uuid’
[16:04:15.741]   - Field: ‘seed’
[16:04:15.741]   - Field: ‘version’
[16:04:15.742]   - Field: ‘result’
[16:04:15.742]   - Field: ‘asynchronous’
[16:04:15.742]   - Field: ‘calls’
[16:04:15.742]   - Field: ‘globals’
[16:04:15.742]   - Field: ‘stdout’
[16:04:15.742]   - Field: ‘earlySignal’
[16:04:15.742]   - Field: ‘lazy’
[16:04:15.742]   - Field: ‘state’
[16:04:15.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.743] - Launch lazy future ...
[16:04:15.743] Packages needed by the future expression (n = 0): <none>
[16:04:15.743] Packages needed by future strategies (n = 0): <none>
[16:04:15.744] {
[16:04:15.744]     {
[16:04:15.744]         {
[16:04:15.744]             ...future.startTime <- base::Sys.time()
[16:04:15.744]             {
[16:04:15.744]                 {
[16:04:15.744]                   {
[16:04:15.744]                     {
[16:04:15.744]                       base::local({
[16:04:15.744]                         has_future <- base::requireNamespace("future", 
[16:04:15.744]                           quietly = TRUE)
[16:04:15.744]                         if (has_future) {
[16:04:15.744]                           ns <- base::getNamespace("future")
[16:04:15.744]                           version <- ns[[".package"]][["version"]]
[16:04:15.744]                           if (is.null(version)) 
[16:04:15.744]                             version <- utils::packageVersion("future")
[16:04:15.744]                         }
[16:04:15.744]                         else {
[16:04:15.744]                           version <- NULL
[16:04:15.744]                         }
[16:04:15.744]                         if (!has_future || version < "1.8.0") {
[16:04:15.744]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.744]                             "", base::R.version$version.string), 
[16:04:15.744]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.744]                               "release", "version")], collapse = " "), 
[16:04:15.744]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.744]                             info)
[16:04:15.744]                           info <- base::paste(info, collapse = "; ")
[16:04:15.744]                           if (!has_future) {
[16:04:15.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.744]                               info)
[16:04:15.744]                           }
[16:04:15.744]                           else {
[16:04:15.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.744]                               info, version)
[16:04:15.744]                           }
[16:04:15.744]                           base::stop(msg)
[16:04:15.744]                         }
[16:04:15.744]                       })
[16:04:15.744]                     }
[16:04:15.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.744]                     base::options(mc.cores = 1L)
[16:04:15.744]                   }
[16:04:15.744]                   options(future.plan = NULL)
[16:04:15.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.744]                 }
[16:04:15.744]                 ...future.workdir <- getwd()
[16:04:15.744]             }
[16:04:15.744]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.744]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.744]         }
[16:04:15.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.744]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.744]             base::names(...future.oldOptions))
[16:04:15.744]     }
[16:04:15.744]     if (FALSE) {
[16:04:15.744]     }
[16:04:15.744]     else {
[16:04:15.744]         if (TRUE) {
[16:04:15.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.744]                 open = "w")
[16:04:15.744]         }
[16:04:15.744]         else {
[16:04:15.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.744]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.744]         }
[16:04:15.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.744]             base::sink(type = "output", split = FALSE)
[16:04:15.744]             base::close(...future.stdout)
[16:04:15.744]         }, add = TRUE)
[16:04:15.744]     }
[16:04:15.744]     ...future.frame <- base::sys.nframe()
[16:04:15.744]     ...future.conditions <- base::list()
[16:04:15.744]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.744]     if (FALSE) {
[16:04:15.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.744]     }
[16:04:15.744]     ...future.result <- base::tryCatch({
[16:04:15.744]         base::withCallingHandlers({
[16:04:15.744]             ...future.value <- base::withVisible(base::local({
[16:04:15.744]                 withCallingHandlers({
[16:04:15.744]                   {
[16:04:15.744]                     do.call(function(...) {
[16:04:15.744]                       sum(x, ...)
[16:04:15.744]                     }, args = future.call.arguments)
[16:04:15.744]                   }
[16:04:15.744]                 }, immediateCondition = function(cond) {
[16:04:15.744]                   save_rds <- function (object, pathname, ...) 
[16:04:15.744]                   {
[16:04:15.744]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.744]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.744]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.744]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.744]                         fi_tmp[["mtime"]])
[16:04:15.744]                     }
[16:04:15.744]                     tryCatch({
[16:04:15.744]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.744]                     }, error = function(ex) {
[16:04:15.744]                       msg <- conditionMessage(ex)
[16:04:15.744]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.744]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.744]                         fi_tmp[["mtime"]], msg)
[16:04:15.744]                       ex$message <- msg
[16:04:15.744]                       stop(ex)
[16:04:15.744]                     })
[16:04:15.744]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.744]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.744]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.744]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.744]                       fi <- file.info(pathname)
[16:04:15.744]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.744]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.744]                         fi[["size"]], fi[["mtime"]])
[16:04:15.744]                       stop(msg)
[16:04:15.744]                     }
[16:04:15.744]                     invisible(pathname)
[16:04:15.744]                   }
[16:04:15.744]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.744]                     rootPath = tempdir()) 
[16:04:15.744]                   {
[16:04:15.744]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.744]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.744]                       tmpdir = path, fileext = ".rds")
[16:04:15.744]                     save_rds(obj, file)
[16:04:15.744]                   }
[16:04:15.744]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.744]                   {
[16:04:15.744]                     inherits <- base::inherits
[16:04:15.744]                     invokeRestart <- base::invokeRestart
[16:04:15.744]                     is.null <- base::is.null
[16:04:15.744]                     muffled <- FALSE
[16:04:15.744]                     if (inherits(cond, "message")) {
[16:04:15.744]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.744]                       if (muffled) 
[16:04:15.744]                         invokeRestart("muffleMessage")
[16:04:15.744]                     }
[16:04:15.744]                     else if (inherits(cond, "warning")) {
[16:04:15.744]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.744]                       if (muffled) 
[16:04:15.744]                         invokeRestart("muffleWarning")
[16:04:15.744]                     }
[16:04:15.744]                     else if (inherits(cond, "condition")) {
[16:04:15.744]                       if (!is.null(pattern)) {
[16:04:15.744]                         computeRestarts <- base::computeRestarts
[16:04:15.744]                         grepl <- base::grepl
[16:04:15.744]                         restarts <- computeRestarts(cond)
[16:04:15.744]                         for (restart in restarts) {
[16:04:15.744]                           name <- restart$name
[16:04:15.744]                           if (is.null(name)) 
[16:04:15.744]                             next
[16:04:15.744]                           if (!grepl(pattern, name)) 
[16:04:15.744]                             next
[16:04:15.744]                           invokeRestart(restart)
[16:04:15.744]                           muffled <- TRUE
[16:04:15.744]                           break
[16:04:15.744]                         }
[16:04:15.744]                       }
[16:04:15.744]                     }
[16:04:15.744]                     invisible(muffled)
[16:04:15.744]                   }
[16:04:15.744]                   muffleCondition(cond)
[16:04:15.744]                 })
[16:04:15.744]             }))
[16:04:15.744]             future::FutureResult(value = ...future.value$value, 
[16:04:15.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.744]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.744]                     ...future.globalenv.names))
[16:04:15.744]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.744]         }, condition = base::local({
[16:04:15.744]             c <- base::c
[16:04:15.744]             inherits <- base::inherits
[16:04:15.744]             invokeRestart <- base::invokeRestart
[16:04:15.744]             length <- base::length
[16:04:15.744]             list <- base::list
[16:04:15.744]             seq.int <- base::seq.int
[16:04:15.744]             signalCondition <- base::signalCondition
[16:04:15.744]             sys.calls <- base::sys.calls
[16:04:15.744]             `[[` <- base::`[[`
[16:04:15.744]             `+` <- base::`+`
[16:04:15.744]             `<<-` <- base::`<<-`
[16:04:15.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.744]                   3L)]
[16:04:15.744]             }
[16:04:15.744]             function(cond) {
[16:04:15.744]                 is_error <- inherits(cond, "error")
[16:04:15.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.744]                   NULL)
[16:04:15.744]                 if (is_error) {
[16:04:15.744]                   sessionInformation <- function() {
[16:04:15.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.744]                       search = base::search(), system = base::Sys.info())
[16:04:15.744]                   }
[16:04:15.744]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.744]                     cond$call), session = sessionInformation(), 
[16:04:15.744]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.744]                   signalCondition(cond)
[16:04:15.744]                 }
[16:04:15.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.744]                 "immediateCondition"))) {
[16:04:15.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.744]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.744]                   if (TRUE && !signal) {
[16:04:15.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.744]                     {
[16:04:15.744]                       inherits <- base::inherits
[16:04:15.744]                       invokeRestart <- base::invokeRestart
[16:04:15.744]                       is.null <- base::is.null
[16:04:15.744]                       muffled <- FALSE
[16:04:15.744]                       if (inherits(cond, "message")) {
[16:04:15.744]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.744]                         if (muffled) 
[16:04:15.744]                           invokeRestart("muffleMessage")
[16:04:15.744]                       }
[16:04:15.744]                       else if (inherits(cond, "warning")) {
[16:04:15.744]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.744]                         if (muffled) 
[16:04:15.744]                           invokeRestart("muffleWarning")
[16:04:15.744]                       }
[16:04:15.744]                       else if (inherits(cond, "condition")) {
[16:04:15.744]                         if (!is.null(pattern)) {
[16:04:15.744]                           computeRestarts <- base::computeRestarts
[16:04:15.744]                           grepl <- base::grepl
[16:04:15.744]                           restarts <- computeRestarts(cond)
[16:04:15.744]                           for (restart in restarts) {
[16:04:15.744]                             name <- restart$name
[16:04:15.744]                             if (is.null(name)) 
[16:04:15.744]                               next
[16:04:15.744]                             if (!grepl(pattern, name)) 
[16:04:15.744]                               next
[16:04:15.744]                             invokeRestart(restart)
[16:04:15.744]                             muffled <- TRUE
[16:04:15.744]                             break
[16:04:15.744]                           }
[16:04:15.744]                         }
[16:04:15.744]                       }
[16:04:15.744]                       invisible(muffled)
[16:04:15.744]                     }
[16:04:15.744]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.744]                   }
[16:04:15.744]                 }
[16:04:15.744]                 else {
[16:04:15.744]                   if (TRUE) {
[16:04:15.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.744]                     {
[16:04:15.744]                       inherits <- base::inherits
[16:04:15.744]                       invokeRestart <- base::invokeRestart
[16:04:15.744]                       is.null <- base::is.null
[16:04:15.744]                       muffled <- FALSE
[16:04:15.744]                       if (inherits(cond, "message")) {
[16:04:15.744]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.744]                         if (muffled) 
[16:04:15.744]                           invokeRestart("muffleMessage")
[16:04:15.744]                       }
[16:04:15.744]                       else if (inherits(cond, "warning")) {
[16:04:15.744]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.744]                         if (muffled) 
[16:04:15.744]                           invokeRestart("muffleWarning")
[16:04:15.744]                       }
[16:04:15.744]                       else if (inherits(cond, "condition")) {
[16:04:15.744]                         if (!is.null(pattern)) {
[16:04:15.744]                           computeRestarts <- base::computeRestarts
[16:04:15.744]                           grepl <- base::grepl
[16:04:15.744]                           restarts <- computeRestarts(cond)
[16:04:15.744]                           for (restart in restarts) {
[16:04:15.744]                             name <- restart$name
[16:04:15.744]                             if (is.null(name)) 
[16:04:15.744]                               next
[16:04:15.744]                             if (!grepl(pattern, name)) 
[16:04:15.744]                               next
[16:04:15.744]                             invokeRestart(restart)
[16:04:15.744]                             muffled <- TRUE
[16:04:15.744]                             break
[16:04:15.744]                           }
[16:04:15.744]                         }
[16:04:15.744]                       }
[16:04:15.744]                       invisible(muffled)
[16:04:15.744]                     }
[16:04:15.744]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.744]                   }
[16:04:15.744]                 }
[16:04:15.744]             }
[16:04:15.744]         }))
[16:04:15.744]     }, error = function(ex) {
[16:04:15.744]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.744]                 ...future.rng), started = ...future.startTime, 
[16:04:15.744]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.744]             version = "1.8"), class = "FutureResult")
[16:04:15.744]     }, finally = {
[16:04:15.744]         if (!identical(...future.workdir, getwd())) 
[16:04:15.744]             setwd(...future.workdir)
[16:04:15.744]         {
[16:04:15.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.744]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.744]             }
[16:04:15.744]             base::options(...future.oldOptions)
[16:04:15.744]             if (.Platform$OS.type == "windows") {
[16:04:15.744]                 old_names <- names(...future.oldEnvVars)
[16:04:15.744]                 envs <- base::Sys.getenv()
[16:04:15.744]                 names <- names(envs)
[16:04:15.744]                 common <- intersect(names, old_names)
[16:04:15.744]                 added <- setdiff(names, old_names)
[16:04:15.744]                 removed <- setdiff(old_names, names)
[16:04:15.744]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.744]                   envs[common]]
[16:04:15.744]                 NAMES <- toupper(changed)
[16:04:15.744]                 args <- list()
[16:04:15.744]                 for (kk in seq_along(NAMES)) {
[16:04:15.744]                   name <- changed[[kk]]
[16:04:15.744]                   NAME <- NAMES[[kk]]
[16:04:15.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.744]                     next
[16:04:15.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.744]                 }
[16:04:15.744]                 NAMES <- toupper(added)
[16:04:15.744]                 for (kk in seq_along(NAMES)) {
[16:04:15.744]                   name <- added[[kk]]
[16:04:15.744]                   NAME <- NAMES[[kk]]
[16:04:15.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.744]                     next
[16:04:15.744]                   args[[name]] <- ""
[16:04:15.744]                 }
[16:04:15.744]                 NAMES <- toupper(removed)
[16:04:15.744]                 for (kk in seq_along(NAMES)) {
[16:04:15.744]                   name <- removed[[kk]]
[16:04:15.744]                   NAME <- NAMES[[kk]]
[16:04:15.744]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.744]                     next
[16:04:15.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.744]                 }
[16:04:15.744]                 if (length(args) > 0) 
[16:04:15.744]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.744]             }
[16:04:15.744]             else {
[16:04:15.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.744]             }
[16:04:15.744]             {
[16:04:15.744]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.744]                   0L) {
[16:04:15.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.744]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.744]                   base::options(opts)
[16:04:15.744]                 }
[16:04:15.744]                 {
[16:04:15.744]                   {
[16:04:15.744]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.744]                     NULL
[16:04:15.744]                   }
[16:04:15.744]                   options(future.plan = NULL)
[16:04:15.744]                   if (is.na(NA_character_)) 
[16:04:15.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.744]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.744]                     envir = parent.frame()) 
[16:04:15.744]                   {
[16:04:15.744]                     default_workers <- missing(workers)
[16:04:15.744]                     if (is.function(workers)) 
[16:04:15.744]                       workers <- workers()
[16:04:15.744]                     workers <- structure(as.integer(workers), 
[16:04:15.744]                       class = class(workers))
[16:04:15.744]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.744]                       1L)
[16:04:15.744]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.744]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.744]                       if (default_workers) 
[16:04:15.744]                         supportsMulticore(warn = TRUE)
[16:04:15.744]                       return(sequential(..., envir = envir))
[16:04:15.744]                     }
[16:04:15.744]                     oopts <- options(mc.cores = workers)
[16:04:15.744]                     on.exit(options(oopts))
[16:04:15.744]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.744]                       envir = envir)
[16:04:15.744]                     if (!future$lazy) 
[16:04:15.744]                       future <- run(future)
[16:04:15.744]                     invisible(future)
[16:04:15.744]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.744]                 }
[16:04:15.744]             }
[16:04:15.744]         }
[16:04:15.744]     })
[16:04:15.744]     if (TRUE) {
[16:04:15.744]         base::sink(type = "output", split = FALSE)
[16:04:15.744]         if (TRUE) {
[16:04:15.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.744]         }
[16:04:15.744]         else {
[16:04:15.744]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.744]         }
[16:04:15.744]         base::close(...future.stdout)
[16:04:15.744]         ...future.stdout <- NULL
[16:04:15.744]     }
[16:04:15.744]     ...future.result$conditions <- ...future.conditions
[16:04:15.744]     ...future.result$finished <- base::Sys.time()
[16:04:15.744]     ...future.result
[16:04:15.744] }
[16:04:15.746] assign_globals() ...
[16:04:15.746] List of 2
[16:04:15.746]  $ x                    : int [1:2] 1 2
[16:04:15.746]  $ future.call.arguments:List of 1
[16:04:15.746]   ..$ : num 3
[16:04:15.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.746]  - attr(*, "where")=List of 2
[16:04:15.746]   ..$ x                    :<environment: R_EmptyEnv> 
[16:04:15.746]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.746]  - attr(*, "resolved")= logi FALSE
[16:04:15.746]  - attr(*, "total_size")= num 112
[16:04:15.746]  - attr(*, "already-done")= logi TRUE
[16:04:15.750] - copied ‘x’ to environment
[16:04:15.751] - copied ‘future.call.arguments’ to environment
[16:04:15.751] assign_globals() ... done
[16:04:15.751] requestCore(): workers = 2
[16:04:15.755] MulticoreFuture started
[16:04:15.756] - Launch lazy future ... done
[16:04:15.756] run() for ‘MulticoreFuture’ ... done
[16:04:15.756] result() for MulticoreFuture ...
[16:04:15.756] plan(): Setting new future strategy stack:
[16:04:15.757] List of future strategies:
[16:04:15.757] 1. sequential:
[16:04:15.757]    - args: function (..., envir = parent.frame())
[16:04:15.757]    - tweaked: FALSE
[16:04:15.757]    - call: NULL
[16:04:15.758] plan(): nbrOfWorkers() = 1
[16:04:15.760] plan(): Setting new future strategy stack:
[16:04:15.760] List of future strategies:
[16:04:15.760] 1. multicore:
[16:04:15.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.760]    - tweaked: FALSE
[16:04:15.760]    - call: plan(strategy, substitute = FALSE)
[16:04:15.765] plan(): nbrOfWorkers() = 2
[16:04:15.766] result() for MulticoreFuture ...
[16:04:15.767] result() for MulticoreFuture ... done
[16:04:15.767] result() for MulticoreFuture ... done
[16:04:15.767] result() for MulticoreFuture ...
[16:04:15.767] result() for MulticoreFuture ... done
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55e6ef28ef38>
Arguments '...' exists: FALSE
[16:04:15.768] getGlobalsAndPackages() ...
[16:04:15.768] Searching for globals...
[16:04:15.770] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[16:04:15.770] Searching for globals ... DONE
[16:04:15.770] Resolving globals: FALSE
[16:04:15.771] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.771] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.771] - globals: [2] ‘x’, ‘y’
[16:04:15.772] 
[16:04:15.772] getGlobalsAndPackages() ... DONE
[16:04:15.772] run() for ‘Future’ ...
[16:04:15.772] - state: ‘created’
[16:04:15.772] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.777]   - Field: ‘label’
[16:04:15.777]   - Field: ‘local’
[16:04:15.777]   - Field: ‘owner’
[16:04:15.777]   - Field: ‘envir’
[16:04:15.777]   - Field: ‘workers’
[16:04:15.777]   - Field: ‘packages’
[16:04:15.777]   - Field: ‘gc’
[16:04:15.778]   - Field: ‘job’
[16:04:15.778]   - Field: ‘conditions’
[16:04:15.778]   - Field: ‘expr’
[16:04:15.778]   - Field: ‘uuid’
[16:04:15.778]   - Field: ‘seed’
[16:04:15.778]   - Field: ‘version’
[16:04:15.778]   - Field: ‘result’
[16:04:15.778]   - Field: ‘asynchronous’
[16:04:15.778]   - Field: ‘calls’
[16:04:15.779]   - Field: ‘globals’
[16:04:15.779]   - Field: ‘stdout’
[16:04:15.779]   - Field: ‘earlySignal’
[16:04:15.779]   - Field: ‘lazy’
[16:04:15.779]   - Field: ‘state’
[16:04:15.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.779] - Launch lazy future ...
[16:04:15.780] Packages needed by the future expression (n = 0): <none>
[16:04:15.780] Packages needed by future strategies (n = 0): <none>
[16:04:15.780] {
[16:04:15.780]     {
[16:04:15.780]         {
[16:04:15.780]             ...future.startTime <- base::Sys.time()
[16:04:15.780]             {
[16:04:15.780]                 {
[16:04:15.780]                   {
[16:04:15.780]                     {
[16:04:15.780]                       base::local({
[16:04:15.780]                         has_future <- base::requireNamespace("future", 
[16:04:15.780]                           quietly = TRUE)
[16:04:15.780]                         if (has_future) {
[16:04:15.780]                           ns <- base::getNamespace("future")
[16:04:15.780]                           version <- ns[[".package"]][["version"]]
[16:04:15.780]                           if (is.null(version)) 
[16:04:15.780]                             version <- utils::packageVersion("future")
[16:04:15.780]                         }
[16:04:15.780]                         else {
[16:04:15.780]                           version <- NULL
[16:04:15.780]                         }
[16:04:15.780]                         if (!has_future || version < "1.8.0") {
[16:04:15.780]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.780]                             "", base::R.version$version.string), 
[16:04:15.780]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.780]                               "release", "version")], collapse = " "), 
[16:04:15.780]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.780]                             info)
[16:04:15.780]                           info <- base::paste(info, collapse = "; ")
[16:04:15.780]                           if (!has_future) {
[16:04:15.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.780]                               info)
[16:04:15.780]                           }
[16:04:15.780]                           else {
[16:04:15.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.780]                               info, version)
[16:04:15.780]                           }
[16:04:15.780]                           base::stop(msg)
[16:04:15.780]                         }
[16:04:15.780]                       })
[16:04:15.780]                     }
[16:04:15.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.780]                     base::options(mc.cores = 1L)
[16:04:15.780]                   }
[16:04:15.780]                   options(future.plan = NULL)
[16:04:15.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.780]                 }
[16:04:15.780]                 ...future.workdir <- getwd()
[16:04:15.780]             }
[16:04:15.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.780]         }
[16:04:15.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.780]             base::names(...future.oldOptions))
[16:04:15.780]     }
[16:04:15.780]     if (FALSE) {
[16:04:15.780]     }
[16:04:15.780]     else {
[16:04:15.780]         if (TRUE) {
[16:04:15.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.780]                 open = "w")
[16:04:15.780]         }
[16:04:15.780]         else {
[16:04:15.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.780]         }
[16:04:15.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.780]             base::sink(type = "output", split = FALSE)
[16:04:15.780]             base::close(...future.stdout)
[16:04:15.780]         }, add = TRUE)
[16:04:15.780]     }
[16:04:15.780]     ...future.frame <- base::sys.nframe()
[16:04:15.780]     ...future.conditions <- base::list()
[16:04:15.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.780]     if (FALSE) {
[16:04:15.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.780]     }
[16:04:15.780]     ...future.result <- base::tryCatch({
[16:04:15.780]         base::withCallingHandlers({
[16:04:15.780]             ...future.value <- base::withVisible(base::local({
[16:04:15.780]                 withCallingHandlers({
[16:04:15.780]                   {
[16:04:15.780]                     sum(x, y)
[16:04:15.780]                   }
[16:04:15.780]                 }, immediateCondition = function(cond) {
[16:04:15.780]                   save_rds <- function (object, pathname, ...) 
[16:04:15.780]                   {
[16:04:15.780]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.780]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.780]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.780]                         fi_tmp[["mtime"]])
[16:04:15.780]                     }
[16:04:15.780]                     tryCatch({
[16:04:15.780]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.780]                     }, error = function(ex) {
[16:04:15.780]                       msg <- conditionMessage(ex)
[16:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.780]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.780]                         fi_tmp[["mtime"]], msg)
[16:04:15.780]                       ex$message <- msg
[16:04:15.780]                       stop(ex)
[16:04:15.780]                     })
[16:04:15.780]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.780]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.780]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.780]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.780]                       fi <- file.info(pathname)
[16:04:15.780]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.780]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.780]                         fi[["size"]], fi[["mtime"]])
[16:04:15.780]                       stop(msg)
[16:04:15.780]                     }
[16:04:15.780]                     invisible(pathname)
[16:04:15.780]                   }
[16:04:15.780]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.780]                     rootPath = tempdir()) 
[16:04:15.780]                   {
[16:04:15.780]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.780]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.780]                       tmpdir = path, fileext = ".rds")
[16:04:15.780]                     save_rds(obj, file)
[16:04:15.780]                   }
[16:04:15.780]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.780]                   {
[16:04:15.780]                     inherits <- base::inherits
[16:04:15.780]                     invokeRestart <- base::invokeRestart
[16:04:15.780]                     is.null <- base::is.null
[16:04:15.780]                     muffled <- FALSE
[16:04:15.780]                     if (inherits(cond, "message")) {
[16:04:15.780]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.780]                       if (muffled) 
[16:04:15.780]                         invokeRestart("muffleMessage")
[16:04:15.780]                     }
[16:04:15.780]                     else if (inherits(cond, "warning")) {
[16:04:15.780]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.780]                       if (muffled) 
[16:04:15.780]                         invokeRestart("muffleWarning")
[16:04:15.780]                     }
[16:04:15.780]                     else if (inherits(cond, "condition")) {
[16:04:15.780]                       if (!is.null(pattern)) {
[16:04:15.780]                         computeRestarts <- base::computeRestarts
[16:04:15.780]                         grepl <- base::grepl
[16:04:15.780]                         restarts <- computeRestarts(cond)
[16:04:15.780]                         for (restart in restarts) {
[16:04:15.780]                           name <- restart$name
[16:04:15.780]                           if (is.null(name)) 
[16:04:15.780]                             next
[16:04:15.780]                           if (!grepl(pattern, name)) 
[16:04:15.780]                             next
[16:04:15.780]                           invokeRestart(restart)
[16:04:15.780]                           muffled <- TRUE
[16:04:15.780]                           break
[16:04:15.780]                         }
[16:04:15.780]                       }
[16:04:15.780]                     }
[16:04:15.780]                     invisible(muffled)
[16:04:15.780]                   }
[16:04:15.780]                   muffleCondition(cond)
[16:04:15.780]                 })
[16:04:15.780]             }))
[16:04:15.780]             future::FutureResult(value = ...future.value$value, 
[16:04:15.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.780]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.780]                     ...future.globalenv.names))
[16:04:15.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.780]         }, condition = base::local({
[16:04:15.780]             c <- base::c
[16:04:15.780]             inherits <- base::inherits
[16:04:15.780]             invokeRestart <- base::invokeRestart
[16:04:15.780]             length <- base::length
[16:04:15.780]             list <- base::list
[16:04:15.780]             seq.int <- base::seq.int
[16:04:15.780]             signalCondition <- base::signalCondition
[16:04:15.780]             sys.calls <- base::sys.calls
[16:04:15.780]             `[[` <- base::`[[`
[16:04:15.780]             `+` <- base::`+`
[16:04:15.780]             `<<-` <- base::`<<-`
[16:04:15.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.780]                   3L)]
[16:04:15.780]             }
[16:04:15.780]             function(cond) {
[16:04:15.780]                 is_error <- inherits(cond, "error")
[16:04:15.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.780]                   NULL)
[16:04:15.780]                 if (is_error) {
[16:04:15.780]                   sessionInformation <- function() {
[16:04:15.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.780]                       search = base::search(), system = base::Sys.info())
[16:04:15.780]                   }
[16:04:15.780]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.780]                     cond$call), session = sessionInformation(), 
[16:04:15.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.780]                   signalCondition(cond)
[16:04:15.780]                 }
[16:04:15.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.780]                 "immediateCondition"))) {
[16:04:15.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.780]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.780]                   if (TRUE && !signal) {
[16:04:15.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.780]                     {
[16:04:15.780]                       inherits <- base::inherits
[16:04:15.780]                       invokeRestart <- base::invokeRestart
[16:04:15.780]                       is.null <- base::is.null
[16:04:15.780]                       muffled <- FALSE
[16:04:15.780]                       if (inherits(cond, "message")) {
[16:04:15.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.780]                         if (muffled) 
[16:04:15.780]                           invokeRestart("muffleMessage")
[16:04:15.780]                       }
[16:04:15.780]                       else if (inherits(cond, "warning")) {
[16:04:15.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.780]                         if (muffled) 
[16:04:15.780]                           invokeRestart("muffleWarning")
[16:04:15.780]                       }
[16:04:15.780]                       else if (inherits(cond, "condition")) {
[16:04:15.780]                         if (!is.null(pattern)) {
[16:04:15.780]                           computeRestarts <- base::computeRestarts
[16:04:15.780]                           grepl <- base::grepl
[16:04:15.780]                           restarts <- computeRestarts(cond)
[16:04:15.780]                           for (restart in restarts) {
[16:04:15.780]                             name <- restart$name
[16:04:15.780]                             if (is.null(name)) 
[16:04:15.780]                               next
[16:04:15.780]                             if (!grepl(pattern, name)) 
[16:04:15.780]                               next
[16:04:15.780]                             invokeRestart(restart)
[16:04:15.780]                             muffled <- TRUE
[16:04:15.780]                             break
[16:04:15.780]                           }
[16:04:15.780]                         }
[16:04:15.780]                       }
[16:04:15.780]                       invisible(muffled)
[16:04:15.780]                     }
[16:04:15.780]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.780]                   }
[16:04:15.780]                 }
[16:04:15.780]                 else {
[16:04:15.780]                   if (TRUE) {
[16:04:15.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.780]                     {
[16:04:15.780]                       inherits <- base::inherits
[16:04:15.780]                       invokeRestart <- base::invokeRestart
[16:04:15.780]                       is.null <- base::is.null
[16:04:15.780]                       muffled <- FALSE
[16:04:15.780]                       if (inherits(cond, "message")) {
[16:04:15.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.780]                         if (muffled) 
[16:04:15.780]                           invokeRestart("muffleMessage")
[16:04:15.780]                       }
[16:04:15.780]                       else if (inherits(cond, "warning")) {
[16:04:15.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.780]                         if (muffled) 
[16:04:15.780]                           invokeRestart("muffleWarning")
[16:04:15.780]                       }
[16:04:15.780]                       else if (inherits(cond, "condition")) {
[16:04:15.780]                         if (!is.null(pattern)) {
[16:04:15.780]                           computeRestarts <- base::computeRestarts
[16:04:15.780]                           grepl <- base::grepl
[16:04:15.780]                           restarts <- computeRestarts(cond)
[16:04:15.780]                           for (restart in restarts) {
[16:04:15.780]                             name <- restart$name
[16:04:15.780]                             if (is.null(name)) 
[16:04:15.780]                               next
[16:04:15.780]                             if (!grepl(pattern, name)) 
[16:04:15.780]                               next
[16:04:15.780]                             invokeRestart(restart)
[16:04:15.780]                             muffled <- TRUE
[16:04:15.780]                             break
[16:04:15.780]                           }
[16:04:15.780]                         }
[16:04:15.780]                       }
[16:04:15.780]                       invisible(muffled)
[16:04:15.780]                     }
[16:04:15.780]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.780]                   }
[16:04:15.780]                 }
[16:04:15.780]             }
[16:04:15.780]         }))
[16:04:15.780]     }, error = function(ex) {
[16:04:15.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.780]                 ...future.rng), started = ...future.startTime, 
[16:04:15.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.780]             version = "1.8"), class = "FutureResult")
[16:04:15.780]     }, finally = {
[16:04:15.780]         if (!identical(...future.workdir, getwd())) 
[16:04:15.780]             setwd(...future.workdir)
[16:04:15.780]         {
[16:04:15.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.780]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.780]             }
[16:04:15.780]             base::options(...future.oldOptions)
[16:04:15.780]             if (.Platform$OS.type == "windows") {
[16:04:15.780]                 old_names <- names(...future.oldEnvVars)
[16:04:15.780]                 envs <- base::Sys.getenv()
[16:04:15.780]                 names <- names(envs)
[16:04:15.780]                 common <- intersect(names, old_names)
[16:04:15.780]                 added <- setdiff(names, old_names)
[16:04:15.780]                 removed <- setdiff(old_names, names)
[16:04:15.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.780]                   envs[common]]
[16:04:15.780]                 NAMES <- toupper(changed)
[16:04:15.780]                 args <- list()
[16:04:15.780]                 for (kk in seq_along(NAMES)) {
[16:04:15.780]                   name <- changed[[kk]]
[16:04:15.780]                   NAME <- NAMES[[kk]]
[16:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.780]                     next
[16:04:15.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.780]                 }
[16:04:15.780]                 NAMES <- toupper(added)
[16:04:15.780]                 for (kk in seq_along(NAMES)) {
[16:04:15.780]                   name <- added[[kk]]
[16:04:15.780]                   NAME <- NAMES[[kk]]
[16:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.780]                     next
[16:04:15.780]                   args[[name]] <- ""
[16:04:15.780]                 }
[16:04:15.780]                 NAMES <- toupper(removed)
[16:04:15.780]                 for (kk in seq_along(NAMES)) {
[16:04:15.780]                   name <- removed[[kk]]
[16:04:15.780]                   NAME <- NAMES[[kk]]
[16:04:15.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.780]                     next
[16:04:15.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.780]                 }
[16:04:15.780]                 if (length(args) > 0) 
[16:04:15.780]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.780]             }
[16:04:15.780]             else {
[16:04:15.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.780]             }
[16:04:15.780]             {
[16:04:15.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.780]                   0L) {
[16:04:15.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.780]                   base::options(opts)
[16:04:15.780]                 }
[16:04:15.780]                 {
[16:04:15.780]                   {
[16:04:15.780]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.780]                     NULL
[16:04:15.780]                   }
[16:04:15.780]                   options(future.plan = NULL)
[16:04:15.780]                   if (is.na(NA_character_)) 
[16:04:15.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.780]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.780]                     envir = parent.frame()) 
[16:04:15.780]                   {
[16:04:15.780]                     default_workers <- missing(workers)
[16:04:15.780]                     if (is.function(workers)) 
[16:04:15.780]                       workers <- workers()
[16:04:15.780]                     workers <- structure(as.integer(workers), 
[16:04:15.780]                       class = class(workers))
[16:04:15.780]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.780]                       1L)
[16:04:15.780]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.780]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.780]                       if (default_workers) 
[16:04:15.780]                         supportsMulticore(warn = TRUE)
[16:04:15.780]                       return(sequential(..., envir = envir))
[16:04:15.780]                     }
[16:04:15.780]                     oopts <- options(mc.cores = workers)
[16:04:15.780]                     on.exit(options(oopts))
[16:04:15.780]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.780]                       envir = envir)
[16:04:15.780]                     if (!future$lazy) 
[16:04:15.780]                       future <- run(future)
[16:04:15.780]                     invisible(future)
[16:04:15.780]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.780]                 }
[16:04:15.780]             }
[16:04:15.780]         }
[16:04:15.780]     })
[16:04:15.780]     if (TRUE) {
[16:04:15.780]         base::sink(type = "output", split = FALSE)
[16:04:15.780]         if (TRUE) {
[16:04:15.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.780]         }
[16:04:15.780]         else {
[16:04:15.780]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.780]         }
[16:04:15.780]         base::close(...future.stdout)
[16:04:15.780]         ...future.stdout <- NULL
[16:04:15.780]     }
[16:04:15.780]     ...future.result$conditions <- ...future.conditions
[16:04:15.780]     ...future.result$finished <- base::Sys.time()
[16:04:15.780]     ...future.result
[16:04:15.780] }
[16:04:15.783] assign_globals() ...
[16:04:15.783] List of 2
[16:04:15.783]  $ x: int [1:2] 1 2
[16:04:15.783]  $ y: num 3
[16:04:15.783]  - attr(*, "where")=List of 2
[16:04:15.783]   ..$ x:<environment: R_EmptyEnv> 
[16:04:15.783]   ..$ y:<environment: R_EmptyEnv> 
[16:04:15.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.783]  - attr(*, "resolved")= logi FALSE
[16:04:15.783]  - attr(*, "total_size")= num 112
[16:04:15.783]  - attr(*, "already-done")= logi TRUE
[16:04:15.787] - copied ‘x’ to environment
[16:04:15.787] - copied ‘y’ to environment
[16:04:15.787] assign_globals() ... done
[16:04:15.787] requestCore(): workers = 2
[16:04:15.789] MulticoreFuture started
[16:04:15.789] - Launch lazy future ... done
[16:04:15.790] run() for ‘MulticoreFuture’ ... done
[16:04:15.790] result() for MulticoreFuture ...
[16:04:15.790] plan(): Setting new future strategy stack:
[16:04:15.790] List of future strategies:
[16:04:15.790] 1. sequential:
[16:04:15.790]    - args: function (..., envir = parent.frame())
[16:04:15.790]    - tweaked: FALSE
[16:04:15.790]    - call: NULL
[16:04:15.791] plan(): nbrOfWorkers() = 1
[16:04:15.793] plan(): Setting new future strategy stack:
[16:04:15.793] List of future strategies:
[16:04:15.793] 1. multicore:
[16:04:15.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.793]    - tweaked: FALSE
[16:04:15.793]    - call: plan(strategy, substitute = FALSE)
[16:04:15.798] plan(): nbrOfWorkers() = 2
[16:04:15.799] result() for MulticoreFuture ...
[16:04:15.799] result() for MulticoreFuture ... done
[16:04:15.799] result() for MulticoreFuture ... done
[16:04:15.800] result() for MulticoreFuture ...
[16:04:15.800] result() for MulticoreFuture ... done
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55e6ef478610>
Arguments '...' exists: FALSE
[16:04:15.801] getGlobalsAndPackages() ...
[16:04:15.801] Searching for globals...
[16:04:15.803] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[16:04:15.803] Searching for globals ... DONE
[16:04:15.803] Resolving globals: FALSE
[16:04:15.803] Tweak future expression to call with '...' arguments ...
[16:04:15.804] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:15.804] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.804] - globals: [2] ‘x’, ‘y’
[16:04:15.804] 
[16:04:15.805] getGlobalsAndPackages() ... DONE
[16:04:15.805] run() for ‘Future’ ...
[16:04:15.805] - state: ‘created’
[16:04:15.805] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.809] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.809] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.809]   - Field: ‘label’
[16:04:15.809]   - Field: ‘local’
[16:04:15.810]   - Field: ‘owner’
[16:04:15.810]   - Field: ‘envir’
[16:04:15.810]   - Field: ‘workers’
[16:04:15.810]   - Field: ‘packages’
[16:04:15.810]   - Field: ‘gc’
[16:04:15.810]   - Field: ‘job’
[16:04:15.810]   - Field: ‘conditions’
[16:04:15.810]   - Field: ‘expr’
[16:04:15.811]   - Field: ‘uuid’
[16:04:15.811]   - Field: ‘seed’
[16:04:15.811]   - Field: ‘version’
[16:04:15.811]   - Field: ‘result’
[16:04:15.811]   - Field: ‘asynchronous’
[16:04:15.811]   - Field: ‘calls’
[16:04:15.811]   - Field: ‘globals’
[16:04:15.811]   - Field: ‘stdout’
[16:04:15.811]   - Field: ‘earlySignal’
[16:04:15.812]   - Field: ‘lazy’
[16:04:15.812]   - Field: ‘state’
[16:04:15.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.812] - Launch lazy future ...
[16:04:15.812] Packages needed by the future expression (n = 0): <none>
[16:04:15.812] Packages needed by future strategies (n = 0): <none>
[16:04:15.813] {
[16:04:15.813]     {
[16:04:15.813]         {
[16:04:15.813]             ...future.startTime <- base::Sys.time()
[16:04:15.813]             {
[16:04:15.813]                 {
[16:04:15.813]                   {
[16:04:15.813]                     {
[16:04:15.813]                       base::local({
[16:04:15.813]                         has_future <- base::requireNamespace("future", 
[16:04:15.813]                           quietly = TRUE)
[16:04:15.813]                         if (has_future) {
[16:04:15.813]                           ns <- base::getNamespace("future")
[16:04:15.813]                           version <- ns[[".package"]][["version"]]
[16:04:15.813]                           if (is.null(version)) 
[16:04:15.813]                             version <- utils::packageVersion("future")
[16:04:15.813]                         }
[16:04:15.813]                         else {
[16:04:15.813]                           version <- NULL
[16:04:15.813]                         }
[16:04:15.813]                         if (!has_future || version < "1.8.0") {
[16:04:15.813]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.813]                             "", base::R.version$version.string), 
[16:04:15.813]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.813]                               "release", "version")], collapse = " "), 
[16:04:15.813]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.813]                             info)
[16:04:15.813]                           info <- base::paste(info, collapse = "; ")
[16:04:15.813]                           if (!has_future) {
[16:04:15.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.813]                               info)
[16:04:15.813]                           }
[16:04:15.813]                           else {
[16:04:15.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.813]                               info, version)
[16:04:15.813]                           }
[16:04:15.813]                           base::stop(msg)
[16:04:15.813]                         }
[16:04:15.813]                       })
[16:04:15.813]                     }
[16:04:15.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.813]                     base::options(mc.cores = 1L)
[16:04:15.813]                   }
[16:04:15.813]                   options(future.plan = NULL)
[16:04:15.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.813]                 }
[16:04:15.813]                 ...future.workdir <- getwd()
[16:04:15.813]             }
[16:04:15.813]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.813]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.813]         }
[16:04:15.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.813]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.813]             base::names(...future.oldOptions))
[16:04:15.813]     }
[16:04:15.813]     if (FALSE) {
[16:04:15.813]     }
[16:04:15.813]     else {
[16:04:15.813]         if (TRUE) {
[16:04:15.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.813]                 open = "w")
[16:04:15.813]         }
[16:04:15.813]         else {
[16:04:15.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.813]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.813]         }
[16:04:15.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.813]             base::sink(type = "output", split = FALSE)
[16:04:15.813]             base::close(...future.stdout)
[16:04:15.813]         }, add = TRUE)
[16:04:15.813]     }
[16:04:15.813]     ...future.frame <- base::sys.nframe()
[16:04:15.813]     ...future.conditions <- base::list()
[16:04:15.813]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.813]     if (FALSE) {
[16:04:15.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.813]     }
[16:04:15.813]     ...future.result <- base::tryCatch({
[16:04:15.813]         base::withCallingHandlers({
[16:04:15.813]             ...future.value <- base::withVisible(base::local({
[16:04:15.813]                 withCallingHandlers({
[16:04:15.813]                   {
[16:04:15.813]                     sum(x, y, ...)
[16:04:15.813]                   }
[16:04:15.813]                 }, immediateCondition = function(cond) {
[16:04:15.813]                   save_rds <- function (object, pathname, ...) 
[16:04:15.813]                   {
[16:04:15.813]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.813]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.813]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.813]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.813]                         fi_tmp[["mtime"]])
[16:04:15.813]                     }
[16:04:15.813]                     tryCatch({
[16:04:15.813]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.813]                     }, error = function(ex) {
[16:04:15.813]                       msg <- conditionMessage(ex)
[16:04:15.813]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.813]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.813]                         fi_tmp[["mtime"]], msg)
[16:04:15.813]                       ex$message <- msg
[16:04:15.813]                       stop(ex)
[16:04:15.813]                     })
[16:04:15.813]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.813]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.813]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.813]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.813]                       fi <- file.info(pathname)
[16:04:15.813]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.813]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.813]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.813]                         fi[["size"]], fi[["mtime"]])
[16:04:15.813]                       stop(msg)
[16:04:15.813]                     }
[16:04:15.813]                     invisible(pathname)
[16:04:15.813]                   }
[16:04:15.813]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.813]                     rootPath = tempdir()) 
[16:04:15.813]                   {
[16:04:15.813]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.813]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.813]                       tmpdir = path, fileext = ".rds")
[16:04:15.813]                     save_rds(obj, file)
[16:04:15.813]                   }
[16:04:15.813]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.813]                   {
[16:04:15.813]                     inherits <- base::inherits
[16:04:15.813]                     invokeRestart <- base::invokeRestart
[16:04:15.813]                     is.null <- base::is.null
[16:04:15.813]                     muffled <- FALSE
[16:04:15.813]                     if (inherits(cond, "message")) {
[16:04:15.813]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.813]                       if (muffled) 
[16:04:15.813]                         invokeRestart("muffleMessage")
[16:04:15.813]                     }
[16:04:15.813]                     else if (inherits(cond, "warning")) {
[16:04:15.813]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.813]                       if (muffled) 
[16:04:15.813]                         invokeRestart("muffleWarning")
[16:04:15.813]                     }
[16:04:15.813]                     else if (inherits(cond, "condition")) {
[16:04:15.813]                       if (!is.null(pattern)) {
[16:04:15.813]                         computeRestarts <- base::computeRestarts
[16:04:15.813]                         grepl <- base::grepl
[16:04:15.813]                         restarts <- computeRestarts(cond)
[16:04:15.813]                         for (restart in restarts) {
[16:04:15.813]                           name <- restart$name
[16:04:15.813]                           if (is.null(name)) 
[16:04:15.813]                             next
[16:04:15.813]                           if (!grepl(pattern, name)) 
[16:04:15.813]                             next
[16:04:15.813]                           invokeRestart(restart)
[16:04:15.813]                           muffled <- TRUE
[16:04:15.813]                           break
[16:04:15.813]                         }
[16:04:15.813]                       }
[16:04:15.813]                     }
[16:04:15.813]                     invisible(muffled)
[16:04:15.813]                   }
[16:04:15.813]                   muffleCondition(cond)
[16:04:15.813]                 })
[16:04:15.813]             }))
[16:04:15.813]             future::FutureResult(value = ...future.value$value, 
[16:04:15.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.813]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.813]                     ...future.globalenv.names))
[16:04:15.813]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.813]         }, condition = base::local({
[16:04:15.813]             c <- base::c
[16:04:15.813]             inherits <- base::inherits
[16:04:15.813]             invokeRestart <- base::invokeRestart
[16:04:15.813]             length <- base::length
[16:04:15.813]             list <- base::list
[16:04:15.813]             seq.int <- base::seq.int
[16:04:15.813]             signalCondition <- base::signalCondition
[16:04:15.813]             sys.calls <- base::sys.calls
[16:04:15.813]             `[[` <- base::`[[`
[16:04:15.813]             `+` <- base::`+`
[16:04:15.813]             `<<-` <- base::`<<-`
[16:04:15.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.813]                   3L)]
[16:04:15.813]             }
[16:04:15.813]             function(cond) {
[16:04:15.813]                 is_error <- inherits(cond, "error")
[16:04:15.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.813]                   NULL)
[16:04:15.813]                 if (is_error) {
[16:04:15.813]                   sessionInformation <- function() {
[16:04:15.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.813]                       search = base::search(), system = base::Sys.info())
[16:04:15.813]                   }
[16:04:15.813]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.813]                     cond$call), session = sessionInformation(), 
[16:04:15.813]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.813]                   signalCondition(cond)
[16:04:15.813]                 }
[16:04:15.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.813]                 "immediateCondition"))) {
[16:04:15.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.813]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.813]                   if (TRUE && !signal) {
[16:04:15.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.813]                     {
[16:04:15.813]                       inherits <- base::inherits
[16:04:15.813]                       invokeRestart <- base::invokeRestart
[16:04:15.813]                       is.null <- base::is.null
[16:04:15.813]                       muffled <- FALSE
[16:04:15.813]                       if (inherits(cond, "message")) {
[16:04:15.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.813]                         if (muffled) 
[16:04:15.813]                           invokeRestart("muffleMessage")
[16:04:15.813]                       }
[16:04:15.813]                       else if (inherits(cond, "warning")) {
[16:04:15.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.813]                         if (muffled) 
[16:04:15.813]                           invokeRestart("muffleWarning")
[16:04:15.813]                       }
[16:04:15.813]                       else if (inherits(cond, "condition")) {
[16:04:15.813]                         if (!is.null(pattern)) {
[16:04:15.813]                           computeRestarts <- base::computeRestarts
[16:04:15.813]                           grepl <- base::grepl
[16:04:15.813]                           restarts <- computeRestarts(cond)
[16:04:15.813]                           for (restart in restarts) {
[16:04:15.813]                             name <- restart$name
[16:04:15.813]                             if (is.null(name)) 
[16:04:15.813]                               next
[16:04:15.813]                             if (!grepl(pattern, name)) 
[16:04:15.813]                               next
[16:04:15.813]                             invokeRestart(restart)
[16:04:15.813]                             muffled <- TRUE
[16:04:15.813]                             break
[16:04:15.813]                           }
[16:04:15.813]                         }
[16:04:15.813]                       }
[16:04:15.813]                       invisible(muffled)
[16:04:15.813]                     }
[16:04:15.813]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.813]                   }
[16:04:15.813]                 }
[16:04:15.813]                 else {
[16:04:15.813]                   if (TRUE) {
[16:04:15.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.813]                     {
[16:04:15.813]                       inherits <- base::inherits
[16:04:15.813]                       invokeRestart <- base::invokeRestart
[16:04:15.813]                       is.null <- base::is.null
[16:04:15.813]                       muffled <- FALSE
[16:04:15.813]                       if (inherits(cond, "message")) {
[16:04:15.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.813]                         if (muffled) 
[16:04:15.813]                           invokeRestart("muffleMessage")
[16:04:15.813]                       }
[16:04:15.813]                       else if (inherits(cond, "warning")) {
[16:04:15.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.813]                         if (muffled) 
[16:04:15.813]                           invokeRestart("muffleWarning")
[16:04:15.813]                       }
[16:04:15.813]                       else if (inherits(cond, "condition")) {
[16:04:15.813]                         if (!is.null(pattern)) {
[16:04:15.813]                           computeRestarts <- base::computeRestarts
[16:04:15.813]                           grepl <- base::grepl
[16:04:15.813]                           restarts <- computeRestarts(cond)
[16:04:15.813]                           for (restart in restarts) {
[16:04:15.813]                             name <- restart$name
[16:04:15.813]                             if (is.null(name)) 
[16:04:15.813]                               next
[16:04:15.813]                             if (!grepl(pattern, name)) 
[16:04:15.813]                               next
[16:04:15.813]                             invokeRestart(restart)
[16:04:15.813]                             muffled <- TRUE
[16:04:15.813]                             break
[16:04:15.813]                           }
[16:04:15.813]                         }
[16:04:15.813]                       }
[16:04:15.813]                       invisible(muffled)
[16:04:15.813]                     }
[16:04:15.813]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.813]                   }
[16:04:15.813]                 }
[16:04:15.813]             }
[16:04:15.813]         }))
[16:04:15.813]     }, error = function(ex) {
[16:04:15.813]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.813]                 ...future.rng), started = ...future.startTime, 
[16:04:15.813]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.813]             version = "1.8"), class = "FutureResult")
[16:04:15.813]     }, finally = {
[16:04:15.813]         if (!identical(...future.workdir, getwd())) 
[16:04:15.813]             setwd(...future.workdir)
[16:04:15.813]         {
[16:04:15.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.813]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.813]             }
[16:04:15.813]             base::options(...future.oldOptions)
[16:04:15.813]             if (.Platform$OS.type == "windows") {
[16:04:15.813]                 old_names <- names(...future.oldEnvVars)
[16:04:15.813]                 envs <- base::Sys.getenv()
[16:04:15.813]                 names <- names(envs)
[16:04:15.813]                 common <- intersect(names, old_names)
[16:04:15.813]                 added <- setdiff(names, old_names)
[16:04:15.813]                 removed <- setdiff(old_names, names)
[16:04:15.813]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.813]                   envs[common]]
[16:04:15.813]                 NAMES <- toupper(changed)
[16:04:15.813]                 args <- list()
[16:04:15.813]                 for (kk in seq_along(NAMES)) {
[16:04:15.813]                   name <- changed[[kk]]
[16:04:15.813]                   NAME <- NAMES[[kk]]
[16:04:15.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.813]                     next
[16:04:15.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.813]                 }
[16:04:15.813]                 NAMES <- toupper(added)
[16:04:15.813]                 for (kk in seq_along(NAMES)) {
[16:04:15.813]                   name <- added[[kk]]
[16:04:15.813]                   NAME <- NAMES[[kk]]
[16:04:15.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.813]                     next
[16:04:15.813]                   args[[name]] <- ""
[16:04:15.813]                 }
[16:04:15.813]                 NAMES <- toupper(removed)
[16:04:15.813]                 for (kk in seq_along(NAMES)) {
[16:04:15.813]                   name <- removed[[kk]]
[16:04:15.813]                   NAME <- NAMES[[kk]]
[16:04:15.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.813]                     next
[16:04:15.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.813]                 }
[16:04:15.813]                 if (length(args) > 0) 
[16:04:15.813]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.813]             }
[16:04:15.813]             else {
[16:04:15.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.813]             }
[16:04:15.813]             {
[16:04:15.813]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.813]                   0L) {
[16:04:15.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.813]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.813]                   base::options(opts)
[16:04:15.813]                 }
[16:04:15.813]                 {
[16:04:15.813]                   {
[16:04:15.813]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.813]                     NULL
[16:04:15.813]                   }
[16:04:15.813]                   options(future.plan = NULL)
[16:04:15.813]                   if (is.na(NA_character_)) 
[16:04:15.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.813]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.813]                     envir = parent.frame()) 
[16:04:15.813]                   {
[16:04:15.813]                     default_workers <- missing(workers)
[16:04:15.813]                     if (is.function(workers)) 
[16:04:15.813]                       workers <- workers()
[16:04:15.813]                     workers <- structure(as.integer(workers), 
[16:04:15.813]                       class = class(workers))
[16:04:15.813]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.813]                       1L)
[16:04:15.813]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.813]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.813]                       if (default_workers) 
[16:04:15.813]                         supportsMulticore(warn = TRUE)
[16:04:15.813]                       return(sequential(..., envir = envir))
[16:04:15.813]                     }
[16:04:15.813]                     oopts <- options(mc.cores = workers)
[16:04:15.813]                     on.exit(options(oopts))
[16:04:15.813]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.813]                       envir = envir)
[16:04:15.813]                     if (!future$lazy) 
[16:04:15.813]                       future <- run(future)
[16:04:15.813]                     invisible(future)
[16:04:15.813]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.813]                 }
[16:04:15.813]             }
[16:04:15.813]         }
[16:04:15.813]     })
[16:04:15.813]     if (TRUE) {
[16:04:15.813]         base::sink(type = "output", split = FALSE)
[16:04:15.813]         if (TRUE) {
[16:04:15.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.813]         }
[16:04:15.813]         else {
[16:04:15.813]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.813]         }
[16:04:15.813]         base::close(...future.stdout)
[16:04:15.813]         ...future.stdout <- NULL
[16:04:15.813]     }
[16:04:15.813]     ...future.result$conditions <- ...future.conditions
[16:04:15.813]     ...future.result$finished <- base::Sys.time()
[16:04:15.813]     ...future.result
[16:04:15.813] }
[16:04:15.816] assign_globals() ...
[16:04:15.816] List of 2
[16:04:15.816]  $ x: int [1:2] 1 2
[16:04:15.816]  $ y: num 3
[16:04:15.816]  - attr(*, "where")=List of 2
[16:04:15.816]   ..$ x:<environment: R_EmptyEnv> 
[16:04:15.816]   ..$ y:<environment: R_EmptyEnv> 
[16:04:15.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.816]  - attr(*, "resolved")= logi FALSE
[16:04:15.816]  - attr(*, "total_size")= num 112
[16:04:15.816]  - attr(*, "already-done")= logi TRUE
[16:04:15.822] - copied ‘x’ to environment
[16:04:15.822] - copied ‘y’ to environment
[16:04:15.822] assign_globals() ... done
[16:04:15.822] requestCore(): workers = 2
[16:04:15.824] MulticoreFuture started
[16:04:15.824] - Launch lazy future ... done
[16:04:15.824] run() for ‘MulticoreFuture’ ... done
[16:04:15.825] result() for MulticoreFuture ...
[16:04:15.825] plan(): Setting new future strategy stack:
[16:04:15.825] List of future strategies:
[16:04:15.825] 1. sequential:
[16:04:15.825]    - args: function (..., envir = parent.frame())
[16:04:15.825]    - tweaked: FALSE
[16:04:15.825]    - call: NULL
[16:04:15.826] plan(): nbrOfWorkers() = 1
[16:04:15.828] plan(): Setting new future strategy stack:
[16:04:15.828] List of future strategies:
[16:04:15.828] 1. multicore:
[16:04:15.828]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.828]    - tweaked: FALSE
[16:04:15.828]    - call: plan(strategy, substitute = FALSE)
[16:04:15.833] plan(): nbrOfWorkers() = 2
[16:04:15.839] result() for MulticoreFuture ...
[16:04:15.839] result() for MulticoreFuture ... done
[16:04:15.839] signalConditions() ...
[16:04:15.839]  - include = ‘immediateCondition’
[16:04:15.839]  - exclude = 
[16:04:15.840]  - resignal = FALSE
[16:04:15.840]  - Number of conditions: 1
[16:04:15.840] signalConditions() ... done
[16:04:15.840] result() for MulticoreFuture ... done
[16:04:15.840] result() for MulticoreFuture ...
[16:04:15.840] result() for MulticoreFuture ... done
[16:04:15.841] signalConditions() ...
[16:04:15.841]  - include = ‘immediateCondition’
[16:04:15.841]  - exclude = 
[16:04:15.841]  - resignal = FALSE
[16:04:15.841]  - Number of conditions: 1
[16:04:15.841] signalConditions() ... done
[16:04:15.841] Future state: ‘finished’
[16:04:15.842] result() for MulticoreFuture ...
[16:04:15.842] result() for MulticoreFuture ... done
[16:04:15.842] signalConditions() ...
[16:04:15.842]  - include = ‘condition’
[16:04:15.842]  - exclude = ‘immediateCondition’
[16:04:15.842]  - resignal = TRUE
[16:04:15.842]  - Number of conditions: 1
[16:04:15.842]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:04:15.843] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55e6ee67a488>
Arguments '...' exists: TRUE
[16:04:15.844] getGlobalsAndPackages() ...
[16:04:15.844] - globals passed as-is: [1] ‘...’
[16:04:15.844] Resolving globals: FALSE
[16:04:15.844] Tweak future expression to call with '...' arguments ...
[16:04:15.845] {
[16:04:15.845]     do.call(function(...) {
[16:04:15.845]         fcn <- function() sum(...)
[16:04:15.845]         fcn()
[16:04:15.845]     }, args = future.call.arguments)
[16:04:15.845] }
[16:04:15.845] Tweak future expression to call with '...' arguments ... DONE
[16:04:15.845] The total size of the 1 globals is 112 bytes (112 bytes)
[16:04:15.846] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[16:04:15.846] - globals: [1] ‘future.call.arguments’
[16:04:15.846] 
[16:04:15.846] getGlobalsAndPackages() ... DONE
[16:04:15.846] run() for ‘Future’ ...
[16:04:15.847] - state: ‘created’
[16:04:15.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.851]   - Field: ‘label’
[16:04:15.851]   - Field: ‘local’
[16:04:15.851]   - Field: ‘owner’
[16:04:15.851]   - Field: ‘envir’
[16:04:15.851]   - Field: ‘workers’
[16:04:15.851]   - Field: ‘packages’
[16:04:15.852]   - Field: ‘gc’
[16:04:15.852]   - Field: ‘job’
[16:04:15.852]   - Field: ‘conditions’
[16:04:15.852]   - Field: ‘expr’
[16:04:15.852]   - Field: ‘uuid’
[16:04:15.852]   - Field: ‘seed’
[16:04:15.852]   - Field: ‘version’
[16:04:15.852]   - Field: ‘result’
[16:04:15.852]   - Field: ‘asynchronous’
[16:04:15.853]   - Field: ‘calls’
[16:04:15.853]   - Field: ‘globals’
[16:04:15.853]   - Field: ‘stdout’
[16:04:15.853]   - Field: ‘earlySignal’
[16:04:15.853]   - Field: ‘lazy’
[16:04:15.853]   - Field: ‘state’
[16:04:15.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.853] - Launch lazy future ...
[16:04:15.854] Packages needed by the future expression (n = 0): <none>
[16:04:15.854] Packages needed by future strategies (n = 0): <none>
[16:04:15.854] {
[16:04:15.854]     {
[16:04:15.854]         {
[16:04:15.854]             ...future.startTime <- base::Sys.time()
[16:04:15.854]             {
[16:04:15.854]                 {
[16:04:15.854]                   {
[16:04:15.854]                     {
[16:04:15.854]                       base::local({
[16:04:15.854]                         has_future <- base::requireNamespace("future", 
[16:04:15.854]                           quietly = TRUE)
[16:04:15.854]                         if (has_future) {
[16:04:15.854]                           ns <- base::getNamespace("future")
[16:04:15.854]                           version <- ns[[".package"]][["version"]]
[16:04:15.854]                           if (is.null(version)) 
[16:04:15.854]                             version <- utils::packageVersion("future")
[16:04:15.854]                         }
[16:04:15.854]                         else {
[16:04:15.854]                           version <- NULL
[16:04:15.854]                         }
[16:04:15.854]                         if (!has_future || version < "1.8.0") {
[16:04:15.854]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.854]                             "", base::R.version$version.string), 
[16:04:15.854]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.854]                               "release", "version")], collapse = " "), 
[16:04:15.854]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.854]                             info)
[16:04:15.854]                           info <- base::paste(info, collapse = "; ")
[16:04:15.854]                           if (!has_future) {
[16:04:15.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.854]                               info)
[16:04:15.854]                           }
[16:04:15.854]                           else {
[16:04:15.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.854]                               info, version)
[16:04:15.854]                           }
[16:04:15.854]                           base::stop(msg)
[16:04:15.854]                         }
[16:04:15.854]                       })
[16:04:15.854]                     }
[16:04:15.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.854]                     base::options(mc.cores = 1L)
[16:04:15.854]                   }
[16:04:15.854]                   options(future.plan = NULL)
[16:04:15.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.854]                 }
[16:04:15.854]                 ...future.workdir <- getwd()
[16:04:15.854]             }
[16:04:15.854]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.854]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.854]         }
[16:04:15.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.854]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.854]             base::names(...future.oldOptions))
[16:04:15.854]     }
[16:04:15.854]     if (FALSE) {
[16:04:15.854]     }
[16:04:15.854]     else {
[16:04:15.854]         if (TRUE) {
[16:04:15.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.854]                 open = "w")
[16:04:15.854]         }
[16:04:15.854]         else {
[16:04:15.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.854]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.854]         }
[16:04:15.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.854]             base::sink(type = "output", split = FALSE)
[16:04:15.854]             base::close(...future.stdout)
[16:04:15.854]         }, add = TRUE)
[16:04:15.854]     }
[16:04:15.854]     ...future.frame <- base::sys.nframe()
[16:04:15.854]     ...future.conditions <- base::list()
[16:04:15.854]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.854]     if (FALSE) {
[16:04:15.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.854]     }
[16:04:15.854]     ...future.result <- base::tryCatch({
[16:04:15.854]         base::withCallingHandlers({
[16:04:15.854]             ...future.value <- base::withVisible(base::local({
[16:04:15.854]                 withCallingHandlers({
[16:04:15.854]                   {
[16:04:15.854]                     do.call(function(...) {
[16:04:15.854]                       fcn <- function() sum(...)
[16:04:15.854]                       fcn()
[16:04:15.854]                     }, args = future.call.arguments)
[16:04:15.854]                   }
[16:04:15.854]                 }, immediateCondition = function(cond) {
[16:04:15.854]                   save_rds <- function (object, pathname, ...) 
[16:04:15.854]                   {
[16:04:15.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.854]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.854]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.854]                         fi_tmp[["mtime"]])
[16:04:15.854]                     }
[16:04:15.854]                     tryCatch({
[16:04:15.854]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.854]                     }, error = function(ex) {
[16:04:15.854]                       msg <- conditionMessage(ex)
[16:04:15.854]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.854]                         fi_tmp[["mtime"]], msg)
[16:04:15.854]                       ex$message <- msg
[16:04:15.854]                       stop(ex)
[16:04:15.854]                     })
[16:04:15.854]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.854]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.854]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.854]                       fi <- file.info(pathname)
[16:04:15.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.854]                         fi[["size"]], fi[["mtime"]])
[16:04:15.854]                       stop(msg)
[16:04:15.854]                     }
[16:04:15.854]                     invisible(pathname)
[16:04:15.854]                   }
[16:04:15.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.854]                     rootPath = tempdir()) 
[16:04:15.854]                   {
[16:04:15.854]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.854]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.854]                       tmpdir = path, fileext = ".rds")
[16:04:15.854]                     save_rds(obj, file)
[16:04:15.854]                   }
[16:04:15.854]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.854]                   {
[16:04:15.854]                     inherits <- base::inherits
[16:04:15.854]                     invokeRestart <- base::invokeRestart
[16:04:15.854]                     is.null <- base::is.null
[16:04:15.854]                     muffled <- FALSE
[16:04:15.854]                     if (inherits(cond, "message")) {
[16:04:15.854]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.854]                       if (muffled) 
[16:04:15.854]                         invokeRestart("muffleMessage")
[16:04:15.854]                     }
[16:04:15.854]                     else if (inherits(cond, "warning")) {
[16:04:15.854]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.854]                       if (muffled) 
[16:04:15.854]                         invokeRestart("muffleWarning")
[16:04:15.854]                     }
[16:04:15.854]                     else if (inherits(cond, "condition")) {
[16:04:15.854]                       if (!is.null(pattern)) {
[16:04:15.854]                         computeRestarts <- base::computeRestarts
[16:04:15.854]                         grepl <- base::grepl
[16:04:15.854]                         restarts <- computeRestarts(cond)
[16:04:15.854]                         for (restart in restarts) {
[16:04:15.854]                           name <- restart$name
[16:04:15.854]                           if (is.null(name)) 
[16:04:15.854]                             next
[16:04:15.854]                           if (!grepl(pattern, name)) 
[16:04:15.854]                             next
[16:04:15.854]                           invokeRestart(restart)
[16:04:15.854]                           muffled <- TRUE
[16:04:15.854]                           break
[16:04:15.854]                         }
[16:04:15.854]                       }
[16:04:15.854]                     }
[16:04:15.854]                     invisible(muffled)
[16:04:15.854]                   }
[16:04:15.854]                   muffleCondition(cond)
[16:04:15.854]                 })
[16:04:15.854]             }))
[16:04:15.854]             future::FutureResult(value = ...future.value$value, 
[16:04:15.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.854]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.854]                     ...future.globalenv.names))
[16:04:15.854]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.854]         }, condition = base::local({
[16:04:15.854]             c <- base::c
[16:04:15.854]             inherits <- base::inherits
[16:04:15.854]             invokeRestart <- base::invokeRestart
[16:04:15.854]             length <- base::length
[16:04:15.854]             list <- base::list
[16:04:15.854]             seq.int <- base::seq.int
[16:04:15.854]             signalCondition <- base::signalCondition
[16:04:15.854]             sys.calls <- base::sys.calls
[16:04:15.854]             `[[` <- base::`[[`
[16:04:15.854]             `+` <- base::`+`
[16:04:15.854]             `<<-` <- base::`<<-`
[16:04:15.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.854]                   3L)]
[16:04:15.854]             }
[16:04:15.854]             function(cond) {
[16:04:15.854]                 is_error <- inherits(cond, "error")
[16:04:15.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.854]                   NULL)
[16:04:15.854]                 if (is_error) {
[16:04:15.854]                   sessionInformation <- function() {
[16:04:15.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.854]                       search = base::search(), system = base::Sys.info())
[16:04:15.854]                   }
[16:04:15.854]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.854]                     cond$call), session = sessionInformation(), 
[16:04:15.854]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.854]                   signalCondition(cond)
[16:04:15.854]                 }
[16:04:15.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.854]                 "immediateCondition"))) {
[16:04:15.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.854]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.854]                   if (TRUE && !signal) {
[16:04:15.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.854]                     {
[16:04:15.854]                       inherits <- base::inherits
[16:04:15.854]                       invokeRestart <- base::invokeRestart
[16:04:15.854]                       is.null <- base::is.null
[16:04:15.854]                       muffled <- FALSE
[16:04:15.854]                       if (inherits(cond, "message")) {
[16:04:15.854]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.854]                         if (muffled) 
[16:04:15.854]                           invokeRestart("muffleMessage")
[16:04:15.854]                       }
[16:04:15.854]                       else if (inherits(cond, "warning")) {
[16:04:15.854]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.854]                         if (muffled) 
[16:04:15.854]                           invokeRestart("muffleWarning")
[16:04:15.854]                       }
[16:04:15.854]                       else if (inherits(cond, "condition")) {
[16:04:15.854]                         if (!is.null(pattern)) {
[16:04:15.854]                           computeRestarts <- base::computeRestarts
[16:04:15.854]                           grepl <- base::grepl
[16:04:15.854]                           restarts <- computeRestarts(cond)
[16:04:15.854]                           for (restart in restarts) {
[16:04:15.854]                             name <- restart$name
[16:04:15.854]                             if (is.null(name)) 
[16:04:15.854]                               next
[16:04:15.854]                             if (!grepl(pattern, name)) 
[16:04:15.854]                               next
[16:04:15.854]                             invokeRestart(restart)
[16:04:15.854]                             muffled <- TRUE
[16:04:15.854]                             break
[16:04:15.854]                           }
[16:04:15.854]                         }
[16:04:15.854]                       }
[16:04:15.854]                       invisible(muffled)
[16:04:15.854]                     }
[16:04:15.854]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.854]                   }
[16:04:15.854]                 }
[16:04:15.854]                 else {
[16:04:15.854]                   if (TRUE) {
[16:04:15.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.854]                     {
[16:04:15.854]                       inherits <- base::inherits
[16:04:15.854]                       invokeRestart <- base::invokeRestart
[16:04:15.854]                       is.null <- base::is.null
[16:04:15.854]                       muffled <- FALSE
[16:04:15.854]                       if (inherits(cond, "message")) {
[16:04:15.854]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.854]                         if (muffled) 
[16:04:15.854]                           invokeRestart("muffleMessage")
[16:04:15.854]                       }
[16:04:15.854]                       else if (inherits(cond, "warning")) {
[16:04:15.854]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.854]                         if (muffled) 
[16:04:15.854]                           invokeRestart("muffleWarning")
[16:04:15.854]                       }
[16:04:15.854]                       else if (inherits(cond, "condition")) {
[16:04:15.854]                         if (!is.null(pattern)) {
[16:04:15.854]                           computeRestarts <- base::computeRestarts
[16:04:15.854]                           grepl <- base::grepl
[16:04:15.854]                           restarts <- computeRestarts(cond)
[16:04:15.854]                           for (restart in restarts) {
[16:04:15.854]                             name <- restart$name
[16:04:15.854]                             if (is.null(name)) 
[16:04:15.854]                               next
[16:04:15.854]                             if (!grepl(pattern, name)) 
[16:04:15.854]                               next
[16:04:15.854]                             invokeRestart(restart)
[16:04:15.854]                             muffled <- TRUE
[16:04:15.854]                             break
[16:04:15.854]                           }
[16:04:15.854]                         }
[16:04:15.854]                       }
[16:04:15.854]                       invisible(muffled)
[16:04:15.854]                     }
[16:04:15.854]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.854]                   }
[16:04:15.854]                 }
[16:04:15.854]             }
[16:04:15.854]         }))
[16:04:15.854]     }, error = function(ex) {
[16:04:15.854]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.854]                 ...future.rng), started = ...future.startTime, 
[16:04:15.854]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.854]             version = "1.8"), class = "FutureResult")
[16:04:15.854]     }, finally = {
[16:04:15.854]         if (!identical(...future.workdir, getwd())) 
[16:04:15.854]             setwd(...future.workdir)
[16:04:15.854]         {
[16:04:15.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.854]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.854]             }
[16:04:15.854]             base::options(...future.oldOptions)
[16:04:15.854]             if (.Platform$OS.type == "windows") {
[16:04:15.854]                 old_names <- names(...future.oldEnvVars)
[16:04:15.854]                 envs <- base::Sys.getenv()
[16:04:15.854]                 names <- names(envs)
[16:04:15.854]                 common <- intersect(names, old_names)
[16:04:15.854]                 added <- setdiff(names, old_names)
[16:04:15.854]                 removed <- setdiff(old_names, names)
[16:04:15.854]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.854]                   envs[common]]
[16:04:15.854]                 NAMES <- toupper(changed)
[16:04:15.854]                 args <- list()
[16:04:15.854]                 for (kk in seq_along(NAMES)) {
[16:04:15.854]                   name <- changed[[kk]]
[16:04:15.854]                   NAME <- NAMES[[kk]]
[16:04:15.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.854]                     next
[16:04:15.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.854]                 }
[16:04:15.854]                 NAMES <- toupper(added)
[16:04:15.854]                 for (kk in seq_along(NAMES)) {
[16:04:15.854]                   name <- added[[kk]]
[16:04:15.854]                   NAME <- NAMES[[kk]]
[16:04:15.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.854]                     next
[16:04:15.854]                   args[[name]] <- ""
[16:04:15.854]                 }
[16:04:15.854]                 NAMES <- toupper(removed)
[16:04:15.854]                 for (kk in seq_along(NAMES)) {
[16:04:15.854]                   name <- removed[[kk]]
[16:04:15.854]                   NAME <- NAMES[[kk]]
[16:04:15.854]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.854]                     next
[16:04:15.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.854]                 }
[16:04:15.854]                 if (length(args) > 0) 
[16:04:15.854]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.854]             }
[16:04:15.854]             else {
[16:04:15.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.854]             }
[16:04:15.854]             {
[16:04:15.854]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.854]                   0L) {
[16:04:15.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.854]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.854]                   base::options(opts)
[16:04:15.854]                 }
[16:04:15.854]                 {
[16:04:15.854]                   {
[16:04:15.854]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.854]                     NULL
[16:04:15.854]                   }
[16:04:15.854]                   options(future.plan = NULL)
[16:04:15.854]                   if (is.na(NA_character_)) 
[16:04:15.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.854]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.854]                     envir = parent.frame()) 
[16:04:15.854]                   {
[16:04:15.854]                     default_workers <- missing(workers)
[16:04:15.854]                     if (is.function(workers)) 
[16:04:15.854]                       workers <- workers()
[16:04:15.854]                     workers <- structure(as.integer(workers), 
[16:04:15.854]                       class = class(workers))
[16:04:15.854]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.854]                       1L)
[16:04:15.854]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.854]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.854]                       if (default_workers) 
[16:04:15.854]                         supportsMulticore(warn = TRUE)
[16:04:15.854]                       return(sequential(..., envir = envir))
[16:04:15.854]                     }
[16:04:15.854]                     oopts <- options(mc.cores = workers)
[16:04:15.854]                     on.exit(options(oopts))
[16:04:15.854]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.854]                       envir = envir)
[16:04:15.854]                     if (!future$lazy) 
[16:04:15.854]                       future <- run(future)
[16:04:15.854]                     invisible(future)
[16:04:15.854]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.854]                 }
[16:04:15.854]             }
[16:04:15.854]         }
[16:04:15.854]     })
[16:04:15.854]     if (TRUE) {
[16:04:15.854]         base::sink(type = "output", split = FALSE)
[16:04:15.854]         if (TRUE) {
[16:04:15.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.854]         }
[16:04:15.854]         else {
[16:04:15.854]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.854]         }
[16:04:15.854]         base::close(...future.stdout)
[16:04:15.854]         ...future.stdout <- NULL
[16:04:15.854]     }
[16:04:15.854]     ...future.result$conditions <- ...future.conditions
[16:04:15.854]     ...future.result$finished <- base::Sys.time()
[16:04:15.854]     ...future.result
[16:04:15.854] }
[16:04:15.857] assign_globals() ...
[16:04:15.857] List of 1
[16:04:15.857]  $ future.call.arguments:List of 2
[16:04:15.857]   ..$ : int [1:2] 1 2
[16:04:15.857]   ..$ : num 3
[16:04:15.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:04:15.857]  - attr(*, "where")=List of 1
[16:04:15.857]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[16:04:15.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.857]  - attr(*, "resolved")= logi FALSE
[16:04:15.857]  - attr(*, "total_size")= num 112
[16:04:15.857]  - attr(*, "already-done")= logi TRUE
[16:04:15.861] - copied ‘future.call.arguments’ to environment
[16:04:15.861] assign_globals() ... done
[16:04:15.862] requestCore(): workers = 2
[16:04:15.863] MulticoreFuture started
[16:04:15.864] - Launch lazy future ... done
[16:04:15.864] run() for ‘MulticoreFuture’ ... done
[16:04:15.864] result() for MulticoreFuture ...
[16:04:15.865] plan(): Setting new future strategy stack:
[16:04:15.865] List of future strategies:
[16:04:15.865] 1. sequential:
[16:04:15.865]    - args: function (..., envir = parent.frame())
[16:04:15.865]    - tweaked: FALSE
[16:04:15.865]    - call: NULL
[16:04:15.866] plan(): nbrOfWorkers() = 1
[16:04:15.868] plan(): Setting new future strategy stack:
[16:04:15.868] List of future strategies:
[16:04:15.868] 1. multicore:
[16:04:15.868]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.868]    - tweaked: FALSE
[16:04:15.868]    - call: plan(strategy, substitute = FALSE)
[16:04:15.873] plan(): nbrOfWorkers() = 2
[16:04:15.874] result() for MulticoreFuture ...
[16:04:15.874] result() for MulticoreFuture ... done
[16:04:15.874] result() for MulticoreFuture ... done
[16:04:15.874] result() for MulticoreFuture ...
[16:04:15.875] result() for MulticoreFuture ... done
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55e6ecf4b790>
Using '...' in a formula
[16:04:15.875] getGlobalsAndPackages() ...
[16:04:15.876] Searching for globals...
[16:04:15.883] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[16:04:15.883] Searching for globals ... DONE
[16:04:15.883] Resolving globals: FALSE
[16:04:15.883] Tweak future expression to call with '...' arguments ...
[16:04:15.884] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[16:04:15.884] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:15.884] - globals: [3] ‘fcn’, ‘x’, ‘y’
[16:04:15.885] 
[16:04:15.885] getGlobalsAndPackages() ... DONE
[16:04:15.885] run() for ‘Future’ ...
[16:04:15.885] - state: ‘created’
[16:04:15.885] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:04:15.889] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:15.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:04:15.890]   - Field: ‘label’
[16:04:15.890]   - Field: ‘local’
[16:04:15.890]   - Field: ‘owner’
[16:04:15.890]   - Field: ‘envir’
[16:04:15.890]   - Field: ‘workers’
[16:04:15.890]   - Field: ‘packages’
[16:04:15.890]   - Field: ‘gc’
[16:04:15.890]   - Field: ‘job’
[16:04:15.890]   - Field: ‘conditions’
[16:04:15.891]   - Field: ‘expr’
[16:04:15.891]   - Field: ‘uuid’
[16:04:15.891]   - Field: ‘seed’
[16:04:15.891]   - Field: ‘version’
[16:04:15.891]   - Field: ‘result’
[16:04:15.891]   - Field: ‘asynchronous’
[16:04:15.891]   - Field: ‘calls’
[16:04:15.891]   - Field: ‘globals’
[16:04:15.891]   - Field: ‘stdout’
[16:04:15.892]   - Field: ‘earlySignal’
[16:04:15.892]   - Field: ‘lazy’
[16:04:15.892]   - Field: ‘state’
[16:04:15.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:04:15.892] - Launch lazy future ...
[16:04:15.892] Packages needed by the future expression (n = 0): <none>
[16:04:15.892] Packages needed by future strategies (n = 0): <none>
[16:04:15.893] {
[16:04:15.893]     {
[16:04:15.893]         {
[16:04:15.893]             ...future.startTime <- base::Sys.time()
[16:04:15.893]             {
[16:04:15.893]                 {
[16:04:15.893]                   {
[16:04:15.893]                     {
[16:04:15.893]                       base::local({
[16:04:15.893]                         has_future <- base::requireNamespace("future", 
[16:04:15.893]                           quietly = TRUE)
[16:04:15.893]                         if (has_future) {
[16:04:15.893]                           ns <- base::getNamespace("future")
[16:04:15.893]                           version <- ns[[".package"]][["version"]]
[16:04:15.893]                           if (is.null(version)) 
[16:04:15.893]                             version <- utils::packageVersion("future")
[16:04:15.893]                         }
[16:04:15.893]                         else {
[16:04:15.893]                           version <- NULL
[16:04:15.893]                         }
[16:04:15.893]                         if (!has_future || version < "1.8.0") {
[16:04:15.893]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:15.893]                             "", base::R.version$version.string), 
[16:04:15.893]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:15.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:15.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:15.893]                               "release", "version")], collapse = " "), 
[16:04:15.893]                             hostname = base::Sys.info()[["nodename"]])
[16:04:15.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:15.893]                             info)
[16:04:15.893]                           info <- base::paste(info, collapse = "; ")
[16:04:15.893]                           if (!has_future) {
[16:04:15.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:15.893]                               info)
[16:04:15.893]                           }
[16:04:15.893]                           else {
[16:04:15.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:15.893]                               info, version)
[16:04:15.893]                           }
[16:04:15.893]                           base::stop(msg)
[16:04:15.893]                         }
[16:04:15.893]                       })
[16:04:15.893]                     }
[16:04:15.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:15.893]                     base::options(mc.cores = 1L)
[16:04:15.893]                   }
[16:04:15.893]                   options(future.plan = NULL)
[16:04:15.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:15.893]                 }
[16:04:15.893]                 ...future.workdir <- getwd()
[16:04:15.893]             }
[16:04:15.893]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:15.893]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:15.893]         }
[16:04:15.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:15.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:15.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:15.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:15.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:15.893]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:15.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:15.893]             base::names(...future.oldOptions))
[16:04:15.893]     }
[16:04:15.893]     if (FALSE) {
[16:04:15.893]     }
[16:04:15.893]     else {
[16:04:15.893]         if (TRUE) {
[16:04:15.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:15.893]                 open = "w")
[16:04:15.893]         }
[16:04:15.893]         else {
[16:04:15.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:15.893]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:15.893]         }
[16:04:15.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:15.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:15.893]             base::sink(type = "output", split = FALSE)
[16:04:15.893]             base::close(...future.stdout)
[16:04:15.893]         }, add = TRUE)
[16:04:15.893]     }
[16:04:15.893]     ...future.frame <- base::sys.nframe()
[16:04:15.893]     ...future.conditions <- base::list()
[16:04:15.893]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:15.893]     if (FALSE) {
[16:04:15.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:15.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:15.893]     }
[16:04:15.893]     ...future.result <- base::tryCatch({
[16:04:15.893]         base::withCallingHandlers({
[16:04:15.893]             ...future.value <- base::withVisible(base::local({
[16:04:15.893]                 withCallingHandlers({
[16:04:15.893]                   fcn(x, y)
[16:04:15.893]                 }, immediateCondition = function(cond) {
[16:04:15.893]                   save_rds <- function (object, pathname, ...) 
[16:04:15.893]                   {
[16:04:15.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:04:15.893]                     if (file_test("-f", pathname_tmp)) {
[16:04:15.893]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:04:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.893]                         fi_tmp[["mtime"]])
[16:04:15.893]                     }
[16:04:15.893]                     tryCatch({
[16:04:15.893]                       saveRDS(object, file = pathname_tmp, ...)
[16:04:15.893]                     }, error = function(ex) {
[16:04:15.893]                       msg <- conditionMessage(ex)
[16:04:15.893]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:04:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.893]                         fi_tmp[["mtime"]], msg)
[16:04:15.893]                       ex$message <- msg
[16:04:15.893]                       stop(ex)
[16:04:15.893]                     })
[16:04:15.893]                     stopifnot(file_test("-f", pathname_tmp))
[16:04:15.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:04:15.893]                     if (!res || file_test("-f", pathname_tmp)) {
[16:04:15.893]                       fi_tmp <- file.info(pathname_tmp)
[16:04:15.893]                       fi <- file.info(pathname)
[16:04:15.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:04:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:04:15.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:04:15.893]                         fi[["size"]], fi[["mtime"]])
[16:04:15.893]                       stop(msg)
[16:04:15.893]                     }
[16:04:15.893]                     invisible(pathname)
[16:04:15.893]                   }
[16:04:15.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:04:15.893]                     rootPath = tempdir()) 
[16:04:15.893]                   {
[16:04:15.893]                     obj <- list(time = Sys.time(), condition = cond)
[16:04:15.893]                     file <- tempfile(pattern = class(cond)[1], 
[16:04:15.893]                       tmpdir = path, fileext = ".rds")
[16:04:15.893]                     save_rds(obj, file)
[16:04:15.893]                   }
[16:04:15.893]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ysvZU/.future/immediateConditions")
[16:04:15.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.893]                   {
[16:04:15.893]                     inherits <- base::inherits
[16:04:15.893]                     invokeRestart <- base::invokeRestart
[16:04:15.893]                     is.null <- base::is.null
[16:04:15.893]                     muffled <- FALSE
[16:04:15.893]                     if (inherits(cond, "message")) {
[16:04:15.893]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:15.893]                       if (muffled) 
[16:04:15.893]                         invokeRestart("muffleMessage")
[16:04:15.893]                     }
[16:04:15.893]                     else if (inherits(cond, "warning")) {
[16:04:15.893]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:15.893]                       if (muffled) 
[16:04:15.893]                         invokeRestart("muffleWarning")
[16:04:15.893]                     }
[16:04:15.893]                     else if (inherits(cond, "condition")) {
[16:04:15.893]                       if (!is.null(pattern)) {
[16:04:15.893]                         computeRestarts <- base::computeRestarts
[16:04:15.893]                         grepl <- base::grepl
[16:04:15.893]                         restarts <- computeRestarts(cond)
[16:04:15.893]                         for (restart in restarts) {
[16:04:15.893]                           name <- restart$name
[16:04:15.893]                           if (is.null(name)) 
[16:04:15.893]                             next
[16:04:15.893]                           if (!grepl(pattern, name)) 
[16:04:15.893]                             next
[16:04:15.893]                           invokeRestart(restart)
[16:04:15.893]                           muffled <- TRUE
[16:04:15.893]                           break
[16:04:15.893]                         }
[16:04:15.893]                       }
[16:04:15.893]                     }
[16:04:15.893]                     invisible(muffled)
[16:04:15.893]                   }
[16:04:15.893]                   muffleCondition(cond)
[16:04:15.893]                 })
[16:04:15.893]             }))
[16:04:15.893]             future::FutureResult(value = ...future.value$value, 
[16:04:15.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.893]                   ...future.rng), globalenv = if (FALSE) 
[16:04:15.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:15.893]                     ...future.globalenv.names))
[16:04:15.893]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:15.893]         }, condition = base::local({
[16:04:15.893]             c <- base::c
[16:04:15.893]             inherits <- base::inherits
[16:04:15.893]             invokeRestart <- base::invokeRestart
[16:04:15.893]             length <- base::length
[16:04:15.893]             list <- base::list
[16:04:15.893]             seq.int <- base::seq.int
[16:04:15.893]             signalCondition <- base::signalCondition
[16:04:15.893]             sys.calls <- base::sys.calls
[16:04:15.893]             `[[` <- base::`[[`
[16:04:15.893]             `+` <- base::`+`
[16:04:15.893]             `<<-` <- base::`<<-`
[16:04:15.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:15.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:15.893]                   3L)]
[16:04:15.893]             }
[16:04:15.893]             function(cond) {
[16:04:15.893]                 is_error <- inherits(cond, "error")
[16:04:15.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:15.893]                   NULL)
[16:04:15.893]                 if (is_error) {
[16:04:15.893]                   sessionInformation <- function() {
[16:04:15.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:15.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:15.893]                       search = base::search(), system = base::Sys.info())
[16:04:15.893]                   }
[16:04:15.893]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:15.893]                     cond$call), session = sessionInformation(), 
[16:04:15.893]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:15.893]                   signalCondition(cond)
[16:04:15.893]                 }
[16:04:15.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:15.893]                 "immediateCondition"))) {
[16:04:15.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:15.893]                   ...future.conditions[[length(...future.conditions) + 
[16:04:15.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:15.893]                   if (TRUE && !signal) {
[16:04:15.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.893]                     {
[16:04:15.893]                       inherits <- base::inherits
[16:04:15.893]                       invokeRestart <- base::invokeRestart
[16:04:15.893]                       is.null <- base::is.null
[16:04:15.893]                       muffled <- FALSE
[16:04:15.893]                       if (inherits(cond, "message")) {
[16:04:15.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.893]                         if (muffled) 
[16:04:15.893]                           invokeRestart("muffleMessage")
[16:04:15.893]                       }
[16:04:15.893]                       else if (inherits(cond, "warning")) {
[16:04:15.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.893]                         if (muffled) 
[16:04:15.893]                           invokeRestart("muffleWarning")
[16:04:15.893]                       }
[16:04:15.893]                       else if (inherits(cond, "condition")) {
[16:04:15.893]                         if (!is.null(pattern)) {
[16:04:15.893]                           computeRestarts <- base::computeRestarts
[16:04:15.893]                           grepl <- base::grepl
[16:04:15.893]                           restarts <- computeRestarts(cond)
[16:04:15.893]                           for (restart in restarts) {
[16:04:15.893]                             name <- restart$name
[16:04:15.893]                             if (is.null(name)) 
[16:04:15.893]                               next
[16:04:15.893]                             if (!grepl(pattern, name)) 
[16:04:15.893]                               next
[16:04:15.893]                             invokeRestart(restart)
[16:04:15.893]                             muffled <- TRUE
[16:04:15.893]                             break
[16:04:15.893]                           }
[16:04:15.893]                         }
[16:04:15.893]                       }
[16:04:15.893]                       invisible(muffled)
[16:04:15.893]                     }
[16:04:15.893]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.893]                   }
[16:04:15.893]                 }
[16:04:15.893]                 else {
[16:04:15.893]                   if (TRUE) {
[16:04:15.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:15.893]                     {
[16:04:15.893]                       inherits <- base::inherits
[16:04:15.893]                       invokeRestart <- base::invokeRestart
[16:04:15.893]                       is.null <- base::is.null
[16:04:15.893]                       muffled <- FALSE
[16:04:15.893]                       if (inherits(cond, "message")) {
[16:04:15.893]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:15.893]                         if (muffled) 
[16:04:15.893]                           invokeRestart("muffleMessage")
[16:04:15.893]                       }
[16:04:15.893]                       else if (inherits(cond, "warning")) {
[16:04:15.893]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:15.893]                         if (muffled) 
[16:04:15.893]                           invokeRestart("muffleWarning")
[16:04:15.893]                       }
[16:04:15.893]                       else if (inherits(cond, "condition")) {
[16:04:15.893]                         if (!is.null(pattern)) {
[16:04:15.893]                           computeRestarts <- base::computeRestarts
[16:04:15.893]                           grepl <- base::grepl
[16:04:15.893]                           restarts <- computeRestarts(cond)
[16:04:15.893]                           for (restart in restarts) {
[16:04:15.893]                             name <- restart$name
[16:04:15.893]                             if (is.null(name)) 
[16:04:15.893]                               next
[16:04:15.893]                             if (!grepl(pattern, name)) 
[16:04:15.893]                               next
[16:04:15.893]                             invokeRestart(restart)
[16:04:15.893]                             muffled <- TRUE
[16:04:15.893]                             break
[16:04:15.893]                           }
[16:04:15.893]                         }
[16:04:15.893]                       }
[16:04:15.893]                       invisible(muffled)
[16:04:15.893]                     }
[16:04:15.893]                     muffleCondition(cond, pattern = "^muffle")
[16:04:15.893]                   }
[16:04:15.893]                 }
[16:04:15.893]             }
[16:04:15.893]         }))
[16:04:15.893]     }, error = function(ex) {
[16:04:15.893]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:15.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:15.893]                 ...future.rng), started = ...future.startTime, 
[16:04:15.893]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:15.893]             version = "1.8"), class = "FutureResult")
[16:04:15.893]     }, finally = {
[16:04:15.893]         if (!identical(...future.workdir, getwd())) 
[16:04:15.893]             setwd(...future.workdir)
[16:04:15.893]         {
[16:04:15.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:15.893]                 ...future.oldOptions$nwarnings <- NULL
[16:04:15.893]             }
[16:04:15.893]             base::options(...future.oldOptions)
[16:04:15.893]             if (.Platform$OS.type == "windows") {
[16:04:15.893]                 old_names <- names(...future.oldEnvVars)
[16:04:15.893]                 envs <- base::Sys.getenv()
[16:04:15.893]                 names <- names(envs)
[16:04:15.893]                 common <- intersect(names, old_names)
[16:04:15.893]                 added <- setdiff(names, old_names)
[16:04:15.893]                 removed <- setdiff(old_names, names)
[16:04:15.893]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:15.893]                   envs[common]]
[16:04:15.893]                 NAMES <- toupper(changed)
[16:04:15.893]                 args <- list()
[16:04:15.893]                 for (kk in seq_along(NAMES)) {
[16:04:15.893]                   name <- changed[[kk]]
[16:04:15.893]                   NAME <- NAMES[[kk]]
[16:04:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.893]                     next
[16:04:15.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.893]                 }
[16:04:15.893]                 NAMES <- toupper(added)
[16:04:15.893]                 for (kk in seq_along(NAMES)) {
[16:04:15.893]                   name <- added[[kk]]
[16:04:15.893]                   NAME <- NAMES[[kk]]
[16:04:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.893]                     next
[16:04:15.893]                   args[[name]] <- ""
[16:04:15.893]                 }
[16:04:15.893]                 NAMES <- toupper(removed)
[16:04:15.893]                 for (kk in seq_along(NAMES)) {
[16:04:15.893]                   name <- removed[[kk]]
[16:04:15.893]                   NAME <- NAMES[[kk]]
[16:04:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:15.893]                     next
[16:04:15.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:15.893]                 }
[16:04:15.893]                 if (length(args) > 0) 
[16:04:15.893]                   base::do.call(base::Sys.setenv, args = args)
[16:04:15.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:15.893]             }
[16:04:15.893]             else {
[16:04:15.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:15.893]             }
[16:04:15.893]             {
[16:04:15.893]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:15.893]                   0L) {
[16:04:15.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:15.893]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:15.893]                   base::options(opts)
[16:04:15.893]                 }
[16:04:15.893]                 {
[16:04:15.893]                   {
[16:04:15.893]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:15.893]                     NULL
[16:04:15.893]                   }
[16:04:15.893]                   options(future.plan = NULL)
[16:04:15.893]                   if (is.na(NA_character_)) 
[16:04:15.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:15.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:15.893]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:04:15.893]                     envir = parent.frame()) 
[16:04:15.893]                   {
[16:04:15.893]                     default_workers <- missing(workers)
[16:04:15.893]                     if (is.function(workers)) 
[16:04:15.893]                       workers <- workers()
[16:04:15.893]                     workers <- structure(as.integer(workers), 
[16:04:15.893]                       class = class(workers))
[16:04:15.893]                     stop_if_not(is.finite(workers), workers >= 
[16:04:15.893]                       1L)
[16:04:15.893]                     if ((workers == 1L && !inherits(workers, 
[16:04:15.893]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:04:15.893]                       if (default_workers) 
[16:04:15.893]                         supportsMulticore(warn = TRUE)
[16:04:15.893]                       return(sequential(..., envir = envir))
[16:04:15.893]                     }
[16:04:15.893]                     oopts <- options(mc.cores = workers)
[16:04:15.893]                     on.exit(options(oopts))
[16:04:15.893]                     future <- MulticoreFuture(..., workers = workers, 
[16:04:15.893]                       envir = envir)
[16:04:15.893]                     if (!future$lazy) 
[16:04:15.893]                       future <- run(future)
[16:04:15.893]                     invisible(future)
[16:04:15.893]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:15.893]                 }
[16:04:15.893]             }
[16:04:15.893]         }
[16:04:15.893]     })
[16:04:15.893]     if (TRUE) {
[16:04:15.893]         base::sink(type = "output", split = FALSE)
[16:04:15.893]         if (TRUE) {
[16:04:15.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:15.893]         }
[16:04:15.893]         else {
[16:04:15.893]             ...future.result["stdout"] <- base::list(NULL)
[16:04:15.893]         }
[16:04:15.893]         base::close(...future.stdout)
[16:04:15.893]         ...future.stdout <- NULL
[16:04:15.893]     }
[16:04:15.893]     ...future.result$conditions <- ...future.conditions
[16:04:15.893]     ...future.result$finished <- base::Sys.time()
[16:04:15.893]     ...future.result
[16:04:15.893] }
[16:04:15.895] assign_globals() ...
[16:04:15.896] List of 3
[16:04:15.896]  $ fcn:function (x, y)  
[16:04:15.896]  $ x  : int [1:2] 1 2
[16:04:15.896]  $ y  : num 3
[16:04:15.896]  - attr(*, "where")=List of 3
[16:04:15.896]   ..$ fcn:<environment: R_EmptyEnv> 
[16:04:15.896]   ..$ x  :<environment: R_EmptyEnv> 
[16:04:15.896]   ..$ y  :<environment: R_EmptyEnv> 
[16:04:15.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:04:15.896]  - attr(*, "resolved")= logi FALSE
[16:04:15.896]  - attr(*, "total_size")= num 4280
[16:04:15.896]  - attr(*, "already-done")= logi TRUE
[16:04:15.900] - reassign environment for ‘fcn’
[16:04:15.900] - copied ‘fcn’ to environment
[16:04:15.900] - copied ‘x’ to environment
[16:04:15.900] - copied ‘y’ to environment
[16:04:15.900] assign_globals() ... done
[16:04:15.900] requestCore(): workers = 2
[16:04:15.902] MulticoreFuture started
[16:04:15.902] - Launch lazy future ... done
[16:04:15.903] run() for ‘MulticoreFuture’ ... done
[16:04:15.903] result() for MulticoreFuture ...
[16:04:15.903] plan(): Setting new future strategy stack:
[16:04:15.904] List of future strategies:
[16:04:15.904] 1. sequential:
[16:04:15.904]    - args: function (..., envir = parent.frame())
[16:04:15.904]    - tweaked: FALSE
[16:04:15.904]    - call: NULL
[16:04:15.904] plan(): nbrOfWorkers() = 1
[16:04:15.906] plan(): Setting new future strategy stack:
[16:04:15.906] List of future strategies:
[16:04:15.906] 1. multicore:
[16:04:15.906]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:04:15.906]    - tweaked: FALSE
[16:04:15.906]    - call: plan(strategy, substitute = FALSE)
[16:04:15.912] plan(): nbrOfWorkers() = 2
[16:04:15.913] result() for MulticoreFuture ...
[16:04:15.913] result() for MulticoreFuture ... done
[16:04:15.913] result() for MulticoreFuture ... done
[16:04:15.913] result() for MulticoreFuture ...
[16:04:15.913] result() for MulticoreFuture ... done
[1] 6
- plan('multisession') ...
[16:04:15.914] plan(): Setting new future strategy stack:
[16:04:15.914] List of future strategies:
[16:04:15.914] 1. multisession:
[16:04:15.914]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:15.914]    - tweaked: FALSE
[16:04:15.914]    - call: plan(strategy, substitute = FALSE)
[16:04:15.915] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:04:15.915] multisession:
[16:04:15.915] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:04:15.915] - tweaked: FALSE
[16:04:15.915] - call: plan(strategy, substitute = FALSE)
[16:04:15.922] getGlobalsAndPackages() ...
[16:04:15.922] Not searching for globals
[16:04:15.922] - globals: [0] <none>
[16:04:15.922] getGlobalsAndPackages() ... DONE
[16:04:15.923] [local output] makeClusterPSOCK() ...
[16:04:15.965] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:04:15.966] [local output] Base port: 11315
[16:04:15.966] [local output] Getting setup options for 2 cluster nodes ...
[16:04:15.966] [local output]  - Node 1 of 2 ...
[16:04:15.967] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:15.968] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9ysvZU/worker.rank=1.parallelly.parent=81178.13d1a4d512ee1.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp9ysvZU/worker.rank=1.parallelly.parent=81178.13d1a4d512ee1.pid")'’
[16:04:16.155] - Possible to infer worker's PID: TRUE
[16:04:16.155] [local output] Rscript port: 11315

[16:04:16.156] [local output]  - Node 2 of 2 ...
[16:04:16.156] [local output] localMachine=TRUE => revtunnel=FALSE

[16:04:16.157] [local output] Rscript port: 11315

[16:04:16.157] [local output] Getting setup options for 2 cluster nodes ... done
[16:04:16.157] [local output]  - Parallel setup requested for some PSOCK nodes
[16:04:16.158] [local output] Setting up PSOCK nodes in parallel
[16:04:16.158] List of 36
[16:04:16.158]  $ worker          : chr "localhost"
[16:04:16.158]   ..- attr(*, "localhost")= logi TRUE
[16:04:16.158]  $ master          : chr "localhost"
[16:04:16.158]  $ port            : int 11315
[16:04:16.158]  $ connectTimeout  : num 120
[16:04:16.158]  $ timeout         : num 2592000
[16:04:16.158]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:04:16.158]  $ homogeneous     : logi TRUE
[16:04:16.158]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:04:16.158]  $ rscript_envs    : NULL
[16:04:16.158]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:16.158]  $ rscript_startup : NULL
[16:04:16.158]  $ rscript_sh      : chr "sh"
[16:04:16.158]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:16.158]  $ methods         : logi TRUE
[16:04:16.158]  $ socketOptions   : chr "no-delay"
[16:04:16.158]  $ useXDR          : logi FALSE
[16:04:16.158]  $ outfile         : chr "/dev/null"
[16:04:16.158]  $ renice          : int NA
[16:04:16.158]  $ rshcmd          : NULL
[16:04:16.158]  $ user            : chr(0) 
[16:04:16.158]  $ revtunnel       : logi FALSE
[16:04:16.158]  $ rshlogfile      : NULL
[16:04:16.158]  $ rshopts         : chr(0) 
[16:04:16.158]  $ rank            : int 1
[16:04:16.158]  $ manual          : logi FALSE
[16:04:16.158]  $ dryrun          : logi FALSE
[16:04:16.158]  $ quiet           : logi FALSE
[16:04:16.158]  $ setup_strategy  : chr "parallel"
[16:04:16.158]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:16.158]  $ pidfile         : chr "/tmp/Rtmp9ysvZU/worker.rank=1.parallelly.parent=81178.13d1a4d512ee1.pid"
[16:04:16.158]  $ rshcmd_label    : NULL
[16:04:16.158]  $ rsh_call        : NULL
[16:04:16.158]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:04:16.158]  $ localMachine    : logi TRUE
[16:04:16.158]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:04:16.158]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:04:16.158]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:04:16.158]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:04:16.158]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:04:16.158]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:04:16.158]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:04:16.158]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:04:16.158]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:04:16.158]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:04:16.158]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:04:16.158]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:04:16.158]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:04:16.158]  $ arguments       :List of 28
[16:04:16.158]   ..$ worker          : chr "localhost"
[16:04:16.158]   ..$ master          : NULL
[16:04:16.158]   ..$ port            : int 11315
[16:04:16.158]   ..$ connectTimeout  : num 120
[16:04:16.158]   ..$ timeout         : num 2592000
[16:04:16.158]   ..$ rscript         : NULL
[16:04:16.158]   ..$ homogeneous     : NULL
[16:04:16.158]   ..$ rscript_args    : NULL
[16:04:16.158]   ..$ rscript_envs    : NULL
[16:04:16.158]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:04:16.158]   ..$ rscript_startup : NULL
[16:04:16.158]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:04:16.158]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:04:16.158]   ..$ methods         : logi TRUE
[16:04:16.158]   ..$ socketOptions   : chr "no-delay"
[16:04:16.158]   ..$ useXDR          : logi FALSE
[16:04:16.158]   ..$ outfile         : chr "/dev/null"
[16:04:16.158]   ..$ renice          : int NA
[16:04:16.158]   ..$ rshcmd          : NULL
[16:04:16.158]   ..$ user            : NULL
[16:04:16.158]   ..$ revtunnel       : logi NA
[16:04:16.158]   ..$ rshlogfile      : NULL
[16:04:16.158]   ..$ rshopts         : NULL
[16:04:16.158]   ..$ rank            : int 1
[16:04:16.158]   ..$ manual          : logi FALSE
[16:04:16.158]   ..$ dryrun          : logi FALSE
[16:04:16.158]   ..$ quiet           : logi FALSE
[16:04:16.158]   ..$ setup_strategy  : chr "parallel"
[16:04:16.158]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:04:16.174] [local output] System call to launch all workers:
[16:04:16.174] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9ysvZU/worker.rank=1.parallelly.parent=81178.13d1a4d512ee1.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11315 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:04:16.174] [local output] Starting PSOCK main server
[16:04:16.180] [local output] Workers launched
[16:04:16.180] [local output] Waiting for workers to connect back
[16:04:16.180]  - [local output] 0 workers out of 2 ready
[16:04:16.427]  - [local output] 0 workers out of 2 ready
[16:04:16.428]  - [local output] 1 workers out of 2 ready
[16:04:16.434]  - [local output] 1 workers out of 2 ready
[16:04:16.434]  - [local output] 2 workers out of 2 ready
[16:04:16.435] [local output] Launching of workers completed
[16:04:16.435] [local output] Collecting session information from workers
[16:04:16.436] [local output]  - Worker #1 of 2
[16:04:16.436] [local output]  - Worker #2 of 2
[16:04:16.436] [local output] makeClusterPSOCK() ... done
[16:04:16.448] Packages needed by the future expression (n = 0): <none>
[16:04:16.448] Packages needed by future strategies (n = 0): <none>
[16:04:16.448] {
[16:04:16.448]     {
[16:04:16.448]         {
[16:04:16.448]             ...future.startTime <- base::Sys.time()
[16:04:16.448]             {
[16:04:16.448]                 {
[16:04:16.448]                   {
[16:04:16.448]                     {
[16:04:16.448]                       base::local({
[16:04:16.448]                         has_future <- base::requireNamespace("future", 
[16:04:16.448]                           quietly = TRUE)
[16:04:16.448]                         if (has_future) {
[16:04:16.448]                           ns <- base::getNamespace("future")
[16:04:16.448]                           version <- ns[[".package"]][["version"]]
[16:04:16.448]                           if (is.null(version)) 
[16:04:16.448]                             version <- utils::packageVersion("future")
[16:04:16.448]                         }
[16:04:16.448]                         else {
[16:04:16.448]                           version <- NULL
[16:04:16.448]                         }
[16:04:16.448]                         if (!has_future || version < "1.8.0") {
[16:04:16.448]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.448]                             "", base::R.version$version.string), 
[16:04:16.448]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.448]                               "release", "version")], collapse = " "), 
[16:04:16.448]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.448]                             info)
[16:04:16.448]                           info <- base::paste(info, collapse = "; ")
[16:04:16.448]                           if (!has_future) {
[16:04:16.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.448]                               info)
[16:04:16.448]                           }
[16:04:16.448]                           else {
[16:04:16.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.448]                               info, version)
[16:04:16.448]                           }
[16:04:16.448]                           base::stop(msg)
[16:04:16.448]                         }
[16:04:16.448]                       })
[16:04:16.448]                     }
[16:04:16.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.448]                     base::options(mc.cores = 1L)
[16:04:16.448]                   }
[16:04:16.448]                   options(future.plan = NULL)
[16:04:16.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.448]                 }
[16:04:16.448]                 ...future.workdir <- getwd()
[16:04:16.448]             }
[16:04:16.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.448]         }
[16:04:16.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.448]             base::names(...future.oldOptions))
[16:04:16.448]     }
[16:04:16.448]     if (FALSE) {
[16:04:16.448]     }
[16:04:16.448]     else {
[16:04:16.448]         if (TRUE) {
[16:04:16.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.448]                 open = "w")
[16:04:16.448]         }
[16:04:16.448]         else {
[16:04:16.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.448]         }
[16:04:16.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.448]             base::sink(type = "output", split = FALSE)
[16:04:16.448]             base::close(...future.stdout)
[16:04:16.448]         }, add = TRUE)
[16:04:16.448]     }
[16:04:16.448]     ...future.frame <- base::sys.nframe()
[16:04:16.448]     ...future.conditions <- base::list()
[16:04:16.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.448]     if (FALSE) {
[16:04:16.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.448]     }
[16:04:16.448]     ...future.result <- base::tryCatch({
[16:04:16.448]         base::withCallingHandlers({
[16:04:16.448]             ...future.value <- base::withVisible(base::local({
[16:04:16.448]                 ...future.makeSendCondition <- base::local({
[16:04:16.448]                   sendCondition <- NULL
[16:04:16.448]                   function(frame = 1L) {
[16:04:16.448]                     if (is.function(sendCondition)) 
[16:04:16.448]                       return(sendCondition)
[16:04:16.448]                     ns <- getNamespace("parallel")
[16:04:16.448]                     if (exists("sendData", mode = "function", 
[16:04:16.448]                       envir = ns)) {
[16:04:16.448]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.448]                         envir = ns)
[16:04:16.448]                       envir <- sys.frame(frame)
[16:04:16.448]                       master <- NULL
[16:04:16.448]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.448]                         !identical(envir, emptyenv())) {
[16:04:16.448]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.448]                           inherits = FALSE)) {
[16:04:16.448]                           master <- get("master", mode = "list", 
[16:04:16.448]                             envir = envir, inherits = FALSE)
[16:04:16.448]                           if (inherits(master, c("SOCKnode", 
[16:04:16.448]                             "SOCK0node"))) {
[16:04:16.448]                             sendCondition <<- function(cond) {
[16:04:16.448]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.448]                                 success = TRUE)
[16:04:16.448]                               parallel_sendData(master, data)
[16:04:16.448]                             }
[16:04:16.448]                             return(sendCondition)
[16:04:16.448]                           }
[16:04:16.448]                         }
[16:04:16.448]                         frame <- frame + 1L
[16:04:16.448]                         envir <- sys.frame(frame)
[16:04:16.448]                       }
[16:04:16.448]                     }
[16:04:16.448]                     sendCondition <<- function(cond) NULL
[16:04:16.448]                   }
[16:04:16.448]                 })
[16:04:16.448]                 withCallingHandlers({
[16:04:16.448]                   NA
[16:04:16.448]                 }, immediateCondition = function(cond) {
[16:04:16.448]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.448]                   sendCondition(cond)
[16:04:16.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.448]                   {
[16:04:16.448]                     inherits <- base::inherits
[16:04:16.448]                     invokeRestart <- base::invokeRestart
[16:04:16.448]                     is.null <- base::is.null
[16:04:16.448]                     muffled <- FALSE
[16:04:16.448]                     if (inherits(cond, "message")) {
[16:04:16.448]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.448]                       if (muffled) 
[16:04:16.448]                         invokeRestart("muffleMessage")
[16:04:16.448]                     }
[16:04:16.448]                     else if (inherits(cond, "warning")) {
[16:04:16.448]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.448]                       if (muffled) 
[16:04:16.448]                         invokeRestart("muffleWarning")
[16:04:16.448]                     }
[16:04:16.448]                     else if (inherits(cond, "condition")) {
[16:04:16.448]                       if (!is.null(pattern)) {
[16:04:16.448]                         computeRestarts <- base::computeRestarts
[16:04:16.448]                         grepl <- base::grepl
[16:04:16.448]                         restarts <- computeRestarts(cond)
[16:04:16.448]                         for (restart in restarts) {
[16:04:16.448]                           name <- restart$name
[16:04:16.448]                           if (is.null(name)) 
[16:04:16.448]                             next
[16:04:16.448]                           if (!grepl(pattern, name)) 
[16:04:16.448]                             next
[16:04:16.448]                           invokeRestart(restart)
[16:04:16.448]                           muffled <- TRUE
[16:04:16.448]                           break
[16:04:16.448]                         }
[16:04:16.448]                       }
[16:04:16.448]                     }
[16:04:16.448]                     invisible(muffled)
[16:04:16.448]                   }
[16:04:16.448]                   muffleCondition(cond)
[16:04:16.448]                 })
[16:04:16.448]             }))
[16:04:16.448]             future::FutureResult(value = ...future.value$value, 
[16:04:16.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.448]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.448]                     ...future.globalenv.names))
[16:04:16.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.448]         }, condition = base::local({
[16:04:16.448]             c <- base::c
[16:04:16.448]             inherits <- base::inherits
[16:04:16.448]             invokeRestart <- base::invokeRestart
[16:04:16.448]             length <- base::length
[16:04:16.448]             list <- base::list
[16:04:16.448]             seq.int <- base::seq.int
[16:04:16.448]             signalCondition <- base::signalCondition
[16:04:16.448]             sys.calls <- base::sys.calls
[16:04:16.448]             `[[` <- base::`[[`
[16:04:16.448]             `+` <- base::`+`
[16:04:16.448]             `<<-` <- base::`<<-`
[16:04:16.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.448]                   3L)]
[16:04:16.448]             }
[16:04:16.448]             function(cond) {
[16:04:16.448]                 is_error <- inherits(cond, "error")
[16:04:16.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.448]                   NULL)
[16:04:16.448]                 if (is_error) {
[16:04:16.448]                   sessionInformation <- function() {
[16:04:16.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.448]                       search = base::search(), system = base::Sys.info())
[16:04:16.448]                   }
[16:04:16.448]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.448]                     cond$call), session = sessionInformation(), 
[16:04:16.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.448]                   signalCondition(cond)
[16:04:16.448]                 }
[16:04:16.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.448]                 "immediateCondition"))) {
[16:04:16.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.448]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.448]                   if (TRUE && !signal) {
[16:04:16.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.448]                     {
[16:04:16.448]                       inherits <- base::inherits
[16:04:16.448]                       invokeRestart <- base::invokeRestart
[16:04:16.448]                       is.null <- base::is.null
[16:04:16.448]                       muffled <- FALSE
[16:04:16.448]                       if (inherits(cond, "message")) {
[16:04:16.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.448]                         if (muffled) 
[16:04:16.448]                           invokeRestart("muffleMessage")
[16:04:16.448]                       }
[16:04:16.448]                       else if (inherits(cond, "warning")) {
[16:04:16.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.448]                         if (muffled) 
[16:04:16.448]                           invokeRestart("muffleWarning")
[16:04:16.448]                       }
[16:04:16.448]                       else if (inherits(cond, "condition")) {
[16:04:16.448]                         if (!is.null(pattern)) {
[16:04:16.448]                           computeRestarts <- base::computeRestarts
[16:04:16.448]                           grepl <- base::grepl
[16:04:16.448]                           restarts <- computeRestarts(cond)
[16:04:16.448]                           for (restart in restarts) {
[16:04:16.448]                             name <- restart$name
[16:04:16.448]                             if (is.null(name)) 
[16:04:16.448]                               next
[16:04:16.448]                             if (!grepl(pattern, name)) 
[16:04:16.448]                               next
[16:04:16.448]                             invokeRestart(restart)
[16:04:16.448]                             muffled <- TRUE
[16:04:16.448]                             break
[16:04:16.448]                           }
[16:04:16.448]                         }
[16:04:16.448]                       }
[16:04:16.448]                       invisible(muffled)
[16:04:16.448]                     }
[16:04:16.448]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.448]                   }
[16:04:16.448]                 }
[16:04:16.448]                 else {
[16:04:16.448]                   if (TRUE) {
[16:04:16.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.448]                     {
[16:04:16.448]                       inherits <- base::inherits
[16:04:16.448]                       invokeRestart <- base::invokeRestart
[16:04:16.448]                       is.null <- base::is.null
[16:04:16.448]                       muffled <- FALSE
[16:04:16.448]                       if (inherits(cond, "message")) {
[16:04:16.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.448]                         if (muffled) 
[16:04:16.448]                           invokeRestart("muffleMessage")
[16:04:16.448]                       }
[16:04:16.448]                       else if (inherits(cond, "warning")) {
[16:04:16.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.448]                         if (muffled) 
[16:04:16.448]                           invokeRestart("muffleWarning")
[16:04:16.448]                       }
[16:04:16.448]                       else if (inherits(cond, "condition")) {
[16:04:16.448]                         if (!is.null(pattern)) {
[16:04:16.448]                           computeRestarts <- base::computeRestarts
[16:04:16.448]                           grepl <- base::grepl
[16:04:16.448]                           restarts <- computeRestarts(cond)
[16:04:16.448]                           for (restart in restarts) {
[16:04:16.448]                             name <- restart$name
[16:04:16.448]                             if (is.null(name)) 
[16:04:16.448]                               next
[16:04:16.448]                             if (!grepl(pattern, name)) 
[16:04:16.448]                               next
[16:04:16.448]                             invokeRestart(restart)
[16:04:16.448]                             muffled <- TRUE
[16:04:16.448]                             break
[16:04:16.448]                           }
[16:04:16.448]                         }
[16:04:16.448]                       }
[16:04:16.448]                       invisible(muffled)
[16:04:16.448]                     }
[16:04:16.448]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.448]                   }
[16:04:16.448]                 }
[16:04:16.448]             }
[16:04:16.448]         }))
[16:04:16.448]     }, error = function(ex) {
[16:04:16.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.448]                 ...future.rng), started = ...future.startTime, 
[16:04:16.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.448]             version = "1.8"), class = "FutureResult")
[16:04:16.448]     }, finally = {
[16:04:16.448]         if (!identical(...future.workdir, getwd())) 
[16:04:16.448]             setwd(...future.workdir)
[16:04:16.448]         {
[16:04:16.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.448]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.448]             }
[16:04:16.448]             base::options(...future.oldOptions)
[16:04:16.448]             if (.Platform$OS.type == "windows") {
[16:04:16.448]                 old_names <- names(...future.oldEnvVars)
[16:04:16.448]                 envs <- base::Sys.getenv()
[16:04:16.448]                 names <- names(envs)
[16:04:16.448]                 common <- intersect(names, old_names)
[16:04:16.448]                 added <- setdiff(names, old_names)
[16:04:16.448]                 removed <- setdiff(old_names, names)
[16:04:16.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.448]                   envs[common]]
[16:04:16.448]                 NAMES <- toupper(changed)
[16:04:16.448]                 args <- list()
[16:04:16.448]                 for (kk in seq_along(NAMES)) {
[16:04:16.448]                   name <- changed[[kk]]
[16:04:16.448]                   NAME <- NAMES[[kk]]
[16:04:16.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.448]                     next
[16:04:16.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.448]                 }
[16:04:16.448]                 NAMES <- toupper(added)
[16:04:16.448]                 for (kk in seq_along(NAMES)) {
[16:04:16.448]                   name <- added[[kk]]
[16:04:16.448]                   NAME <- NAMES[[kk]]
[16:04:16.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.448]                     next
[16:04:16.448]                   args[[name]] <- ""
[16:04:16.448]                 }
[16:04:16.448]                 NAMES <- toupper(removed)
[16:04:16.448]                 for (kk in seq_along(NAMES)) {
[16:04:16.448]                   name <- removed[[kk]]
[16:04:16.448]                   NAME <- NAMES[[kk]]
[16:04:16.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.448]                     next
[16:04:16.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.448]                 }
[16:04:16.448]                 if (length(args) > 0) 
[16:04:16.448]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.448]             }
[16:04:16.448]             else {
[16:04:16.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.448]             }
[16:04:16.448]             {
[16:04:16.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.448]                   0L) {
[16:04:16.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.448]                   base::options(opts)
[16:04:16.448]                 }
[16:04:16.448]                 {
[16:04:16.448]                   {
[16:04:16.448]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.448]                     NULL
[16:04:16.448]                   }
[16:04:16.448]                   options(future.plan = NULL)
[16:04:16.448]                   if (is.na(NA_character_)) 
[16:04:16.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.448]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.448]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.448]                     envir = parent.frame()) 
[16:04:16.448]                   {
[16:04:16.448]                     if (is.function(workers)) 
[16:04:16.448]                       workers <- workers()
[16:04:16.448]                     workers <- structure(as.integer(workers), 
[16:04:16.448]                       class = class(workers))
[16:04:16.448]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.448]                       workers >= 1)
[16:04:16.448]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.448]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.448]                     }
[16:04:16.448]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.448]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.448]                       envir = envir)
[16:04:16.448]                     if (!future$lazy) 
[16:04:16.448]                       future <- run(future)
[16:04:16.448]                     invisible(future)
[16:04:16.448]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.448]                 }
[16:04:16.448]             }
[16:04:16.448]         }
[16:04:16.448]     })
[16:04:16.448]     if (TRUE) {
[16:04:16.448]         base::sink(type = "output", split = FALSE)
[16:04:16.448]         if (TRUE) {
[16:04:16.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.448]         }
[16:04:16.448]         else {
[16:04:16.448]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.448]         }
[16:04:16.448]         base::close(...future.stdout)
[16:04:16.448]         ...future.stdout <- NULL
[16:04:16.448]     }
[16:04:16.448]     ...future.result$conditions <- ...future.conditions
[16:04:16.448]     ...future.result$finished <- base::Sys.time()
[16:04:16.448]     ...future.result
[16:04:16.448] }
[16:04:16.501] MultisessionFuture started
[16:04:16.501] result() for ClusterFuture ...
[16:04:16.502] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.502] - Validating connection of MultisessionFuture
[16:04:16.544] - received message: FutureResult
[16:04:16.545] - Received FutureResult
[16:04:16.545] - Erased future from FutureRegistry
[16:04:16.545] result() for ClusterFuture ...
[16:04:16.545] - result already collected: FutureResult
[16:04:16.545] result() for ClusterFuture ... done
[16:04:16.545] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.545] result() for ClusterFuture ... done
[16:04:16.545] result() for ClusterFuture ...
[16:04:16.545] - result already collected: FutureResult
[16:04:16.546] result() for ClusterFuture ... done
[16:04:16.546] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:04:16.549] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x55e6eee73af0>
Arguments '...' exists: TRUE
[16:04:16.550] getGlobalsAndPackages() ...
[16:04:16.550] Searching for globals...
[16:04:16.552] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:16.552] Searching for globals ... DONE
[16:04:16.552] Resolving globals: FALSE
[16:04:16.552] Tweak future expression to call with '...' arguments ...
[16:04:16.552] {
[16:04:16.552]     do.call(function(...) {
[16:04:16.552]         sum(x, ...)
[16:04:16.552]     }, args = future.call.arguments)
[16:04:16.552] }
[16:04:16.553] Tweak future expression to call with '...' arguments ... DONE
[16:04:16.553] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:16.554] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:16.554] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:16.554] 
[16:04:16.554] getGlobalsAndPackages() ... DONE
[16:04:16.554] run() for ‘Future’ ...
[16:04:16.555] - state: ‘created’
[16:04:16.555] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.569] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.569]   - Field: ‘node’
[16:04:16.569]   - Field: ‘label’
[16:04:16.569]   - Field: ‘local’
[16:04:16.569]   - Field: ‘owner’
[16:04:16.570]   - Field: ‘envir’
[16:04:16.570]   - Field: ‘workers’
[16:04:16.570]   - Field: ‘packages’
[16:04:16.570]   - Field: ‘gc’
[16:04:16.570]   - Field: ‘conditions’
[16:04:16.570]   - Field: ‘persistent’
[16:04:16.570]   - Field: ‘expr’
[16:04:16.570]   - Field: ‘uuid’
[16:04:16.570]   - Field: ‘seed’
[16:04:16.571]   - Field: ‘version’
[16:04:16.571]   - Field: ‘result’
[16:04:16.571]   - Field: ‘asynchronous’
[16:04:16.571]   - Field: ‘calls’
[16:04:16.571]   - Field: ‘globals’
[16:04:16.571]   - Field: ‘stdout’
[16:04:16.571]   - Field: ‘earlySignal’
[16:04:16.571]   - Field: ‘lazy’
[16:04:16.572]   - Field: ‘state’
[16:04:16.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.572] - Launch lazy future ...
[16:04:16.572] Packages needed by the future expression (n = 0): <none>
[16:04:16.572] Packages needed by future strategies (n = 0): <none>
[16:04:16.573] {
[16:04:16.573]     {
[16:04:16.573]         {
[16:04:16.573]             ...future.startTime <- base::Sys.time()
[16:04:16.573]             {
[16:04:16.573]                 {
[16:04:16.573]                   {
[16:04:16.573]                     {
[16:04:16.573]                       base::local({
[16:04:16.573]                         has_future <- base::requireNamespace("future", 
[16:04:16.573]                           quietly = TRUE)
[16:04:16.573]                         if (has_future) {
[16:04:16.573]                           ns <- base::getNamespace("future")
[16:04:16.573]                           version <- ns[[".package"]][["version"]]
[16:04:16.573]                           if (is.null(version)) 
[16:04:16.573]                             version <- utils::packageVersion("future")
[16:04:16.573]                         }
[16:04:16.573]                         else {
[16:04:16.573]                           version <- NULL
[16:04:16.573]                         }
[16:04:16.573]                         if (!has_future || version < "1.8.0") {
[16:04:16.573]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.573]                             "", base::R.version$version.string), 
[16:04:16.573]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.573]                               "release", "version")], collapse = " "), 
[16:04:16.573]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.573]                             info)
[16:04:16.573]                           info <- base::paste(info, collapse = "; ")
[16:04:16.573]                           if (!has_future) {
[16:04:16.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.573]                               info)
[16:04:16.573]                           }
[16:04:16.573]                           else {
[16:04:16.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.573]                               info, version)
[16:04:16.573]                           }
[16:04:16.573]                           base::stop(msg)
[16:04:16.573]                         }
[16:04:16.573]                       })
[16:04:16.573]                     }
[16:04:16.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.573]                     base::options(mc.cores = 1L)
[16:04:16.573]                   }
[16:04:16.573]                   options(future.plan = NULL)
[16:04:16.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.573]                 }
[16:04:16.573]                 ...future.workdir <- getwd()
[16:04:16.573]             }
[16:04:16.573]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.573]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.573]         }
[16:04:16.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.573]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.573]             base::names(...future.oldOptions))
[16:04:16.573]     }
[16:04:16.573]     if (FALSE) {
[16:04:16.573]     }
[16:04:16.573]     else {
[16:04:16.573]         if (TRUE) {
[16:04:16.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.573]                 open = "w")
[16:04:16.573]         }
[16:04:16.573]         else {
[16:04:16.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.573]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.573]         }
[16:04:16.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.573]             base::sink(type = "output", split = FALSE)
[16:04:16.573]             base::close(...future.stdout)
[16:04:16.573]         }, add = TRUE)
[16:04:16.573]     }
[16:04:16.573]     ...future.frame <- base::sys.nframe()
[16:04:16.573]     ...future.conditions <- base::list()
[16:04:16.573]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.573]     if (FALSE) {
[16:04:16.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.573]     }
[16:04:16.573]     ...future.result <- base::tryCatch({
[16:04:16.573]         base::withCallingHandlers({
[16:04:16.573]             ...future.value <- base::withVisible(base::local({
[16:04:16.573]                 ...future.makeSendCondition <- base::local({
[16:04:16.573]                   sendCondition <- NULL
[16:04:16.573]                   function(frame = 1L) {
[16:04:16.573]                     if (is.function(sendCondition)) 
[16:04:16.573]                       return(sendCondition)
[16:04:16.573]                     ns <- getNamespace("parallel")
[16:04:16.573]                     if (exists("sendData", mode = "function", 
[16:04:16.573]                       envir = ns)) {
[16:04:16.573]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.573]                         envir = ns)
[16:04:16.573]                       envir <- sys.frame(frame)
[16:04:16.573]                       master <- NULL
[16:04:16.573]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.573]                         !identical(envir, emptyenv())) {
[16:04:16.573]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.573]                           inherits = FALSE)) {
[16:04:16.573]                           master <- get("master", mode = "list", 
[16:04:16.573]                             envir = envir, inherits = FALSE)
[16:04:16.573]                           if (inherits(master, c("SOCKnode", 
[16:04:16.573]                             "SOCK0node"))) {
[16:04:16.573]                             sendCondition <<- function(cond) {
[16:04:16.573]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.573]                                 success = TRUE)
[16:04:16.573]                               parallel_sendData(master, data)
[16:04:16.573]                             }
[16:04:16.573]                             return(sendCondition)
[16:04:16.573]                           }
[16:04:16.573]                         }
[16:04:16.573]                         frame <- frame + 1L
[16:04:16.573]                         envir <- sys.frame(frame)
[16:04:16.573]                       }
[16:04:16.573]                     }
[16:04:16.573]                     sendCondition <<- function(cond) NULL
[16:04:16.573]                   }
[16:04:16.573]                 })
[16:04:16.573]                 withCallingHandlers({
[16:04:16.573]                   {
[16:04:16.573]                     do.call(function(...) {
[16:04:16.573]                       sum(x, ...)
[16:04:16.573]                     }, args = future.call.arguments)
[16:04:16.573]                   }
[16:04:16.573]                 }, immediateCondition = function(cond) {
[16:04:16.573]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.573]                   sendCondition(cond)
[16:04:16.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.573]                   {
[16:04:16.573]                     inherits <- base::inherits
[16:04:16.573]                     invokeRestart <- base::invokeRestart
[16:04:16.573]                     is.null <- base::is.null
[16:04:16.573]                     muffled <- FALSE
[16:04:16.573]                     if (inherits(cond, "message")) {
[16:04:16.573]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.573]                       if (muffled) 
[16:04:16.573]                         invokeRestart("muffleMessage")
[16:04:16.573]                     }
[16:04:16.573]                     else if (inherits(cond, "warning")) {
[16:04:16.573]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.573]                       if (muffled) 
[16:04:16.573]                         invokeRestart("muffleWarning")
[16:04:16.573]                     }
[16:04:16.573]                     else if (inherits(cond, "condition")) {
[16:04:16.573]                       if (!is.null(pattern)) {
[16:04:16.573]                         computeRestarts <- base::computeRestarts
[16:04:16.573]                         grepl <- base::grepl
[16:04:16.573]                         restarts <- computeRestarts(cond)
[16:04:16.573]                         for (restart in restarts) {
[16:04:16.573]                           name <- restart$name
[16:04:16.573]                           if (is.null(name)) 
[16:04:16.573]                             next
[16:04:16.573]                           if (!grepl(pattern, name)) 
[16:04:16.573]                             next
[16:04:16.573]                           invokeRestart(restart)
[16:04:16.573]                           muffled <- TRUE
[16:04:16.573]                           break
[16:04:16.573]                         }
[16:04:16.573]                       }
[16:04:16.573]                     }
[16:04:16.573]                     invisible(muffled)
[16:04:16.573]                   }
[16:04:16.573]                   muffleCondition(cond)
[16:04:16.573]                 })
[16:04:16.573]             }))
[16:04:16.573]             future::FutureResult(value = ...future.value$value, 
[16:04:16.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.573]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.573]                     ...future.globalenv.names))
[16:04:16.573]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.573]         }, condition = base::local({
[16:04:16.573]             c <- base::c
[16:04:16.573]             inherits <- base::inherits
[16:04:16.573]             invokeRestart <- base::invokeRestart
[16:04:16.573]             length <- base::length
[16:04:16.573]             list <- base::list
[16:04:16.573]             seq.int <- base::seq.int
[16:04:16.573]             signalCondition <- base::signalCondition
[16:04:16.573]             sys.calls <- base::sys.calls
[16:04:16.573]             `[[` <- base::`[[`
[16:04:16.573]             `+` <- base::`+`
[16:04:16.573]             `<<-` <- base::`<<-`
[16:04:16.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.573]                   3L)]
[16:04:16.573]             }
[16:04:16.573]             function(cond) {
[16:04:16.573]                 is_error <- inherits(cond, "error")
[16:04:16.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.573]                   NULL)
[16:04:16.573]                 if (is_error) {
[16:04:16.573]                   sessionInformation <- function() {
[16:04:16.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.573]                       search = base::search(), system = base::Sys.info())
[16:04:16.573]                   }
[16:04:16.573]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.573]                     cond$call), session = sessionInformation(), 
[16:04:16.573]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.573]                   signalCondition(cond)
[16:04:16.573]                 }
[16:04:16.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.573]                 "immediateCondition"))) {
[16:04:16.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.573]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.573]                   if (TRUE && !signal) {
[16:04:16.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.573]                     {
[16:04:16.573]                       inherits <- base::inherits
[16:04:16.573]                       invokeRestart <- base::invokeRestart
[16:04:16.573]                       is.null <- base::is.null
[16:04:16.573]                       muffled <- FALSE
[16:04:16.573]                       if (inherits(cond, "message")) {
[16:04:16.573]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.573]                         if (muffled) 
[16:04:16.573]                           invokeRestart("muffleMessage")
[16:04:16.573]                       }
[16:04:16.573]                       else if (inherits(cond, "warning")) {
[16:04:16.573]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.573]                         if (muffled) 
[16:04:16.573]                           invokeRestart("muffleWarning")
[16:04:16.573]                       }
[16:04:16.573]                       else if (inherits(cond, "condition")) {
[16:04:16.573]                         if (!is.null(pattern)) {
[16:04:16.573]                           computeRestarts <- base::computeRestarts
[16:04:16.573]                           grepl <- base::grepl
[16:04:16.573]                           restarts <- computeRestarts(cond)
[16:04:16.573]                           for (restart in restarts) {
[16:04:16.573]                             name <- restart$name
[16:04:16.573]                             if (is.null(name)) 
[16:04:16.573]                               next
[16:04:16.573]                             if (!grepl(pattern, name)) 
[16:04:16.573]                               next
[16:04:16.573]                             invokeRestart(restart)
[16:04:16.573]                             muffled <- TRUE
[16:04:16.573]                             break
[16:04:16.573]                           }
[16:04:16.573]                         }
[16:04:16.573]                       }
[16:04:16.573]                       invisible(muffled)
[16:04:16.573]                     }
[16:04:16.573]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.573]                   }
[16:04:16.573]                 }
[16:04:16.573]                 else {
[16:04:16.573]                   if (TRUE) {
[16:04:16.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.573]                     {
[16:04:16.573]                       inherits <- base::inherits
[16:04:16.573]                       invokeRestart <- base::invokeRestart
[16:04:16.573]                       is.null <- base::is.null
[16:04:16.573]                       muffled <- FALSE
[16:04:16.573]                       if (inherits(cond, "message")) {
[16:04:16.573]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.573]                         if (muffled) 
[16:04:16.573]                           invokeRestart("muffleMessage")
[16:04:16.573]                       }
[16:04:16.573]                       else if (inherits(cond, "warning")) {
[16:04:16.573]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.573]                         if (muffled) 
[16:04:16.573]                           invokeRestart("muffleWarning")
[16:04:16.573]                       }
[16:04:16.573]                       else if (inherits(cond, "condition")) {
[16:04:16.573]                         if (!is.null(pattern)) {
[16:04:16.573]                           computeRestarts <- base::computeRestarts
[16:04:16.573]                           grepl <- base::grepl
[16:04:16.573]                           restarts <- computeRestarts(cond)
[16:04:16.573]                           for (restart in restarts) {
[16:04:16.573]                             name <- restart$name
[16:04:16.573]                             if (is.null(name)) 
[16:04:16.573]                               next
[16:04:16.573]                             if (!grepl(pattern, name)) 
[16:04:16.573]                               next
[16:04:16.573]                             invokeRestart(restart)
[16:04:16.573]                             muffled <- TRUE
[16:04:16.573]                             break
[16:04:16.573]                           }
[16:04:16.573]                         }
[16:04:16.573]                       }
[16:04:16.573]                       invisible(muffled)
[16:04:16.573]                     }
[16:04:16.573]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.573]                   }
[16:04:16.573]                 }
[16:04:16.573]             }
[16:04:16.573]         }))
[16:04:16.573]     }, error = function(ex) {
[16:04:16.573]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.573]                 ...future.rng), started = ...future.startTime, 
[16:04:16.573]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.573]             version = "1.8"), class = "FutureResult")
[16:04:16.573]     }, finally = {
[16:04:16.573]         if (!identical(...future.workdir, getwd())) 
[16:04:16.573]             setwd(...future.workdir)
[16:04:16.573]         {
[16:04:16.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.573]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.573]             }
[16:04:16.573]             base::options(...future.oldOptions)
[16:04:16.573]             if (.Platform$OS.type == "windows") {
[16:04:16.573]                 old_names <- names(...future.oldEnvVars)
[16:04:16.573]                 envs <- base::Sys.getenv()
[16:04:16.573]                 names <- names(envs)
[16:04:16.573]                 common <- intersect(names, old_names)
[16:04:16.573]                 added <- setdiff(names, old_names)
[16:04:16.573]                 removed <- setdiff(old_names, names)
[16:04:16.573]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.573]                   envs[common]]
[16:04:16.573]                 NAMES <- toupper(changed)
[16:04:16.573]                 args <- list()
[16:04:16.573]                 for (kk in seq_along(NAMES)) {
[16:04:16.573]                   name <- changed[[kk]]
[16:04:16.573]                   NAME <- NAMES[[kk]]
[16:04:16.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.573]                     next
[16:04:16.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.573]                 }
[16:04:16.573]                 NAMES <- toupper(added)
[16:04:16.573]                 for (kk in seq_along(NAMES)) {
[16:04:16.573]                   name <- added[[kk]]
[16:04:16.573]                   NAME <- NAMES[[kk]]
[16:04:16.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.573]                     next
[16:04:16.573]                   args[[name]] <- ""
[16:04:16.573]                 }
[16:04:16.573]                 NAMES <- toupper(removed)
[16:04:16.573]                 for (kk in seq_along(NAMES)) {
[16:04:16.573]                   name <- removed[[kk]]
[16:04:16.573]                   NAME <- NAMES[[kk]]
[16:04:16.573]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.573]                     next
[16:04:16.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.573]                 }
[16:04:16.573]                 if (length(args) > 0) 
[16:04:16.573]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.573]             }
[16:04:16.573]             else {
[16:04:16.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.573]             }
[16:04:16.573]             {
[16:04:16.573]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.573]                   0L) {
[16:04:16.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.573]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.573]                   base::options(opts)
[16:04:16.573]                 }
[16:04:16.573]                 {
[16:04:16.573]                   {
[16:04:16.573]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.573]                     NULL
[16:04:16.573]                   }
[16:04:16.573]                   options(future.plan = NULL)
[16:04:16.573]                   if (is.na(NA_character_)) 
[16:04:16.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.573]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.573]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.573]                     envir = parent.frame()) 
[16:04:16.573]                   {
[16:04:16.573]                     if (is.function(workers)) 
[16:04:16.573]                       workers <- workers()
[16:04:16.573]                     workers <- structure(as.integer(workers), 
[16:04:16.573]                       class = class(workers))
[16:04:16.573]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.573]                       workers >= 1)
[16:04:16.573]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.573]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.573]                     }
[16:04:16.573]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.573]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.573]                       envir = envir)
[16:04:16.573]                     if (!future$lazy) 
[16:04:16.573]                       future <- run(future)
[16:04:16.573]                     invisible(future)
[16:04:16.573]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.573]                 }
[16:04:16.573]             }
[16:04:16.573]         }
[16:04:16.573]     })
[16:04:16.573]     if (TRUE) {
[16:04:16.573]         base::sink(type = "output", split = FALSE)
[16:04:16.573]         if (TRUE) {
[16:04:16.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.573]         }
[16:04:16.573]         else {
[16:04:16.573]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.573]         }
[16:04:16.573]         base::close(...future.stdout)
[16:04:16.573]         ...future.stdout <- NULL
[16:04:16.573]     }
[16:04:16.573]     ...future.result$conditions <- ...future.conditions
[16:04:16.573]     ...future.result$finished <- base::Sys.time()
[16:04:16.573]     ...future.result
[16:04:16.573] }
[16:04:16.576] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:04:16.576] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:04:16.576] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.576] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:04:16.577] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.577] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:04:16.578] MultisessionFuture started
[16:04:16.578] - Launch lazy future ... done
[16:04:16.578] run() for ‘MultisessionFuture’ ... done
[16:04:16.578] result() for ClusterFuture ...
[16:04:16.578] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.578] - Validating connection of MultisessionFuture
[16:04:16.624] - received message: FutureResult
[16:04:16.624] - Received FutureResult
[16:04:16.624] - Erased future from FutureRegistry
[16:04:16.624] result() for ClusterFuture ...
[16:04:16.624] - result already collected: FutureResult
[16:04:16.624] result() for ClusterFuture ... done
[16:04:16.624] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.624] result() for ClusterFuture ... done
[16:04:16.625] result() for ClusterFuture ...
[16:04:16.625] - result already collected: FutureResult
[16:04:16.625] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x55e6ef12df38>
Arguments '...' exists: TRUE
[16:04:16.625] getGlobalsAndPackages() ...
[16:04:16.625] Searching for globals...
[16:04:16.627] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[16:04:16.627] Searching for globals ... DONE
[16:04:16.627] Resolving globals: FALSE
[16:04:16.627] Tweak future expression to call with '...' arguments ...
[16:04:16.628] {
[16:04:16.628]     do.call(function(...) {
[16:04:16.628]         sum(x, ...)
[16:04:16.628]     }, args = future.call.arguments)
[16:04:16.628] }
[16:04:16.628] Tweak future expression to call with '...' arguments ... DONE
[16:04:16.628] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:16.629] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[16:04:16.629] - globals: [2] ‘x’, ‘future.call.arguments’
[16:04:16.629] 
[16:04:16.629] getGlobalsAndPackages() ... DONE
[16:04:16.630] run() for ‘Future’ ...
[16:04:16.630] - state: ‘created’
[16:04:16.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.644]   - Field: ‘node’
[16:04:16.644]   - Field: ‘label’
[16:04:16.644]   - Field: ‘local’
[16:04:16.644]   - Field: ‘owner’
[16:04:16.645]   - Field: ‘envir’
[16:04:16.645]   - Field: ‘workers’
[16:04:16.645]   - Field: ‘packages’
[16:04:16.645]   - Field: ‘gc’
[16:04:16.645]   - Field: ‘conditions’
[16:04:16.645]   - Field: ‘persistent’
[16:04:16.645]   - Field: ‘expr’
[16:04:16.645]   - Field: ‘uuid’
[16:04:16.645]   - Field: ‘seed’
[16:04:16.646]   - Field: ‘version’
[16:04:16.646]   - Field: ‘result’
[16:04:16.646]   - Field: ‘asynchronous’
[16:04:16.646]   - Field: ‘calls’
[16:04:16.646]   - Field: ‘globals’
[16:04:16.646]   - Field: ‘stdout’
[16:04:16.646]   - Field: ‘earlySignal’
[16:04:16.646]   - Field: ‘lazy’
[16:04:16.646]   - Field: ‘state’
[16:04:16.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.647] - Launch lazy future ...
[16:04:16.647] Packages needed by the future expression (n = 0): <none>
[16:04:16.647] Packages needed by future strategies (n = 0): <none>
[16:04:16.648] {
[16:04:16.648]     {
[16:04:16.648]         {
[16:04:16.648]             ...future.startTime <- base::Sys.time()
[16:04:16.648]             {
[16:04:16.648]                 {
[16:04:16.648]                   {
[16:04:16.648]                     {
[16:04:16.648]                       base::local({
[16:04:16.648]                         has_future <- base::requireNamespace("future", 
[16:04:16.648]                           quietly = TRUE)
[16:04:16.648]                         if (has_future) {
[16:04:16.648]                           ns <- base::getNamespace("future")
[16:04:16.648]                           version <- ns[[".package"]][["version"]]
[16:04:16.648]                           if (is.null(version)) 
[16:04:16.648]                             version <- utils::packageVersion("future")
[16:04:16.648]                         }
[16:04:16.648]                         else {
[16:04:16.648]                           version <- NULL
[16:04:16.648]                         }
[16:04:16.648]                         if (!has_future || version < "1.8.0") {
[16:04:16.648]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.648]                             "", base::R.version$version.string), 
[16:04:16.648]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.648]                               "release", "version")], collapse = " "), 
[16:04:16.648]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.648]                             info)
[16:04:16.648]                           info <- base::paste(info, collapse = "; ")
[16:04:16.648]                           if (!has_future) {
[16:04:16.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.648]                               info)
[16:04:16.648]                           }
[16:04:16.648]                           else {
[16:04:16.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.648]                               info, version)
[16:04:16.648]                           }
[16:04:16.648]                           base::stop(msg)
[16:04:16.648]                         }
[16:04:16.648]                       })
[16:04:16.648]                     }
[16:04:16.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.648]                     base::options(mc.cores = 1L)
[16:04:16.648]                   }
[16:04:16.648]                   options(future.plan = NULL)
[16:04:16.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.648]                 }
[16:04:16.648]                 ...future.workdir <- getwd()
[16:04:16.648]             }
[16:04:16.648]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.648]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.648]         }
[16:04:16.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.648]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.648]             base::names(...future.oldOptions))
[16:04:16.648]     }
[16:04:16.648]     if (FALSE) {
[16:04:16.648]     }
[16:04:16.648]     else {
[16:04:16.648]         if (TRUE) {
[16:04:16.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.648]                 open = "w")
[16:04:16.648]         }
[16:04:16.648]         else {
[16:04:16.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.648]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.648]         }
[16:04:16.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.648]             base::sink(type = "output", split = FALSE)
[16:04:16.648]             base::close(...future.stdout)
[16:04:16.648]         }, add = TRUE)
[16:04:16.648]     }
[16:04:16.648]     ...future.frame <- base::sys.nframe()
[16:04:16.648]     ...future.conditions <- base::list()
[16:04:16.648]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.648]     if (FALSE) {
[16:04:16.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.648]     }
[16:04:16.648]     ...future.result <- base::tryCatch({
[16:04:16.648]         base::withCallingHandlers({
[16:04:16.648]             ...future.value <- base::withVisible(base::local({
[16:04:16.648]                 ...future.makeSendCondition <- base::local({
[16:04:16.648]                   sendCondition <- NULL
[16:04:16.648]                   function(frame = 1L) {
[16:04:16.648]                     if (is.function(sendCondition)) 
[16:04:16.648]                       return(sendCondition)
[16:04:16.648]                     ns <- getNamespace("parallel")
[16:04:16.648]                     if (exists("sendData", mode = "function", 
[16:04:16.648]                       envir = ns)) {
[16:04:16.648]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.648]                         envir = ns)
[16:04:16.648]                       envir <- sys.frame(frame)
[16:04:16.648]                       master <- NULL
[16:04:16.648]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.648]                         !identical(envir, emptyenv())) {
[16:04:16.648]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.648]                           inherits = FALSE)) {
[16:04:16.648]                           master <- get("master", mode = "list", 
[16:04:16.648]                             envir = envir, inherits = FALSE)
[16:04:16.648]                           if (inherits(master, c("SOCKnode", 
[16:04:16.648]                             "SOCK0node"))) {
[16:04:16.648]                             sendCondition <<- function(cond) {
[16:04:16.648]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.648]                                 success = TRUE)
[16:04:16.648]                               parallel_sendData(master, data)
[16:04:16.648]                             }
[16:04:16.648]                             return(sendCondition)
[16:04:16.648]                           }
[16:04:16.648]                         }
[16:04:16.648]                         frame <- frame + 1L
[16:04:16.648]                         envir <- sys.frame(frame)
[16:04:16.648]                       }
[16:04:16.648]                     }
[16:04:16.648]                     sendCondition <<- function(cond) NULL
[16:04:16.648]                   }
[16:04:16.648]                 })
[16:04:16.648]                 withCallingHandlers({
[16:04:16.648]                   {
[16:04:16.648]                     do.call(function(...) {
[16:04:16.648]                       sum(x, ...)
[16:04:16.648]                     }, args = future.call.arguments)
[16:04:16.648]                   }
[16:04:16.648]                 }, immediateCondition = function(cond) {
[16:04:16.648]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.648]                   sendCondition(cond)
[16:04:16.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.648]                   {
[16:04:16.648]                     inherits <- base::inherits
[16:04:16.648]                     invokeRestart <- base::invokeRestart
[16:04:16.648]                     is.null <- base::is.null
[16:04:16.648]                     muffled <- FALSE
[16:04:16.648]                     if (inherits(cond, "message")) {
[16:04:16.648]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.648]                       if (muffled) 
[16:04:16.648]                         invokeRestart("muffleMessage")
[16:04:16.648]                     }
[16:04:16.648]                     else if (inherits(cond, "warning")) {
[16:04:16.648]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.648]                       if (muffled) 
[16:04:16.648]                         invokeRestart("muffleWarning")
[16:04:16.648]                     }
[16:04:16.648]                     else if (inherits(cond, "condition")) {
[16:04:16.648]                       if (!is.null(pattern)) {
[16:04:16.648]                         computeRestarts <- base::computeRestarts
[16:04:16.648]                         grepl <- base::grepl
[16:04:16.648]                         restarts <- computeRestarts(cond)
[16:04:16.648]                         for (restart in restarts) {
[16:04:16.648]                           name <- restart$name
[16:04:16.648]                           if (is.null(name)) 
[16:04:16.648]                             next
[16:04:16.648]                           if (!grepl(pattern, name)) 
[16:04:16.648]                             next
[16:04:16.648]                           invokeRestart(restart)
[16:04:16.648]                           muffled <- TRUE
[16:04:16.648]                           break
[16:04:16.648]                         }
[16:04:16.648]                       }
[16:04:16.648]                     }
[16:04:16.648]                     invisible(muffled)
[16:04:16.648]                   }
[16:04:16.648]                   muffleCondition(cond)
[16:04:16.648]                 })
[16:04:16.648]             }))
[16:04:16.648]             future::FutureResult(value = ...future.value$value, 
[16:04:16.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.648]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.648]                     ...future.globalenv.names))
[16:04:16.648]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.648]         }, condition = base::local({
[16:04:16.648]             c <- base::c
[16:04:16.648]             inherits <- base::inherits
[16:04:16.648]             invokeRestart <- base::invokeRestart
[16:04:16.648]             length <- base::length
[16:04:16.648]             list <- base::list
[16:04:16.648]             seq.int <- base::seq.int
[16:04:16.648]             signalCondition <- base::signalCondition
[16:04:16.648]             sys.calls <- base::sys.calls
[16:04:16.648]             `[[` <- base::`[[`
[16:04:16.648]             `+` <- base::`+`
[16:04:16.648]             `<<-` <- base::`<<-`
[16:04:16.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.648]                   3L)]
[16:04:16.648]             }
[16:04:16.648]             function(cond) {
[16:04:16.648]                 is_error <- inherits(cond, "error")
[16:04:16.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.648]                   NULL)
[16:04:16.648]                 if (is_error) {
[16:04:16.648]                   sessionInformation <- function() {
[16:04:16.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.648]                       search = base::search(), system = base::Sys.info())
[16:04:16.648]                   }
[16:04:16.648]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.648]                     cond$call), session = sessionInformation(), 
[16:04:16.648]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.648]                   signalCondition(cond)
[16:04:16.648]                 }
[16:04:16.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.648]                 "immediateCondition"))) {
[16:04:16.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.648]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.648]                   if (TRUE && !signal) {
[16:04:16.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.648]                     {
[16:04:16.648]                       inherits <- base::inherits
[16:04:16.648]                       invokeRestart <- base::invokeRestart
[16:04:16.648]                       is.null <- base::is.null
[16:04:16.648]                       muffled <- FALSE
[16:04:16.648]                       if (inherits(cond, "message")) {
[16:04:16.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.648]                         if (muffled) 
[16:04:16.648]                           invokeRestart("muffleMessage")
[16:04:16.648]                       }
[16:04:16.648]                       else if (inherits(cond, "warning")) {
[16:04:16.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.648]                         if (muffled) 
[16:04:16.648]                           invokeRestart("muffleWarning")
[16:04:16.648]                       }
[16:04:16.648]                       else if (inherits(cond, "condition")) {
[16:04:16.648]                         if (!is.null(pattern)) {
[16:04:16.648]                           computeRestarts <- base::computeRestarts
[16:04:16.648]                           grepl <- base::grepl
[16:04:16.648]                           restarts <- computeRestarts(cond)
[16:04:16.648]                           for (restart in restarts) {
[16:04:16.648]                             name <- restart$name
[16:04:16.648]                             if (is.null(name)) 
[16:04:16.648]                               next
[16:04:16.648]                             if (!grepl(pattern, name)) 
[16:04:16.648]                               next
[16:04:16.648]                             invokeRestart(restart)
[16:04:16.648]                             muffled <- TRUE
[16:04:16.648]                             break
[16:04:16.648]                           }
[16:04:16.648]                         }
[16:04:16.648]                       }
[16:04:16.648]                       invisible(muffled)
[16:04:16.648]                     }
[16:04:16.648]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.648]                   }
[16:04:16.648]                 }
[16:04:16.648]                 else {
[16:04:16.648]                   if (TRUE) {
[16:04:16.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.648]                     {
[16:04:16.648]                       inherits <- base::inherits
[16:04:16.648]                       invokeRestart <- base::invokeRestart
[16:04:16.648]                       is.null <- base::is.null
[16:04:16.648]                       muffled <- FALSE
[16:04:16.648]                       if (inherits(cond, "message")) {
[16:04:16.648]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.648]                         if (muffled) 
[16:04:16.648]                           invokeRestart("muffleMessage")
[16:04:16.648]                       }
[16:04:16.648]                       else if (inherits(cond, "warning")) {
[16:04:16.648]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.648]                         if (muffled) 
[16:04:16.648]                           invokeRestart("muffleWarning")
[16:04:16.648]                       }
[16:04:16.648]                       else if (inherits(cond, "condition")) {
[16:04:16.648]                         if (!is.null(pattern)) {
[16:04:16.648]                           computeRestarts <- base::computeRestarts
[16:04:16.648]                           grepl <- base::grepl
[16:04:16.648]                           restarts <- computeRestarts(cond)
[16:04:16.648]                           for (restart in restarts) {
[16:04:16.648]                             name <- restart$name
[16:04:16.648]                             if (is.null(name)) 
[16:04:16.648]                               next
[16:04:16.648]                             if (!grepl(pattern, name)) 
[16:04:16.648]                               next
[16:04:16.648]                             invokeRestart(restart)
[16:04:16.648]                             muffled <- TRUE
[16:04:16.648]                             break
[16:04:16.648]                           }
[16:04:16.648]                         }
[16:04:16.648]                       }
[16:04:16.648]                       invisible(muffled)
[16:04:16.648]                     }
[16:04:16.648]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.648]                   }
[16:04:16.648]                 }
[16:04:16.648]             }
[16:04:16.648]         }))
[16:04:16.648]     }, error = function(ex) {
[16:04:16.648]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.648]                 ...future.rng), started = ...future.startTime, 
[16:04:16.648]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.648]             version = "1.8"), class = "FutureResult")
[16:04:16.648]     }, finally = {
[16:04:16.648]         if (!identical(...future.workdir, getwd())) 
[16:04:16.648]             setwd(...future.workdir)
[16:04:16.648]         {
[16:04:16.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.648]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.648]             }
[16:04:16.648]             base::options(...future.oldOptions)
[16:04:16.648]             if (.Platform$OS.type == "windows") {
[16:04:16.648]                 old_names <- names(...future.oldEnvVars)
[16:04:16.648]                 envs <- base::Sys.getenv()
[16:04:16.648]                 names <- names(envs)
[16:04:16.648]                 common <- intersect(names, old_names)
[16:04:16.648]                 added <- setdiff(names, old_names)
[16:04:16.648]                 removed <- setdiff(old_names, names)
[16:04:16.648]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.648]                   envs[common]]
[16:04:16.648]                 NAMES <- toupper(changed)
[16:04:16.648]                 args <- list()
[16:04:16.648]                 for (kk in seq_along(NAMES)) {
[16:04:16.648]                   name <- changed[[kk]]
[16:04:16.648]                   NAME <- NAMES[[kk]]
[16:04:16.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.648]                     next
[16:04:16.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.648]                 }
[16:04:16.648]                 NAMES <- toupper(added)
[16:04:16.648]                 for (kk in seq_along(NAMES)) {
[16:04:16.648]                   name <- added[[kk]]
[16:04:16.648]                   NAME <- NAMES[[kk]]
[16:04:16.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.648]                     next
[16:04:16.648]                   args[[name]] <- ""
[16:04:16.648]                 }
[16:04:16.648]                 NAMES <- toupper(removed)
[16:04:16.648]                 for (kk in seq_along(NAMES)) {
[16:04:16.648]                   name <- removed[[kk]]
[16:04:16.648]                   NAME <- NAMES[[kk]]
[16:04:16.648]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.648]                     next
[16:04:16.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.648]                 }
[16:04:16.648]                 if (length(args) > 0) 
[16:04:16.648]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.648]             }
[16:04:16.648]             else {
[16:04:16.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.648]             }
[16:04:16.648]             {
[16:04:16.648]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.648]                   0L) {
[16:04:16.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.648]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.648]                   base::options(opts)
[16:04:16.648]                 }
[16:04:16.648]                 {
[16:04:16.648]                   {
[16:04:16.648]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.648]                     NULL
[16:04:16.648]                   }
[16:04:16.648]                   options(future.plan = NULL)
[16:04:16.648]                   if (is.na(NA_character_)) 
[16:04:16.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.648]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.648]                     envir = parent.frame()) 
[16:04:16.648]                   {
[16:04:16.648]                     if (is.function(workers)) 
[16:04:16.648]                       workers <- workers()
[16:04:16.648]                     workers <- structure(as.integer(workers), 
[16:04:16.648]                       class = class(workers))
[16:04:16.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.648]                       workers >= 1)
[16:04:16.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.648]                     }
[16:04:16.648]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.648]                       envir = envir)
[16:04:16.648]                     if (!future$lazy) 
[16:04:16.648]                       future <- run(future)
[16:04:16.648]                     invisible(future)
[16:04:16.648]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.648]                 }
[16:04:16.648]             }
[16:04:16.648]         }
[16:04:16.648]     })
[16:04:16.648]     if (TRUE) {
[16:04:16.648]         base::sink(type = "output", split = FALSE)
[16:04:16.648]         if (TRUE) {
[16:04:16.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.648]         }
[16:04:16.648]         else {
[16:04:16.648]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.648]         }
[16:04:16.648]         base::close(...future.stdout)
[16:04:16.648]         ...future.stdout <- NULL
[16:04:16.648]     }
[16:04:16.648]     ...future.result$conditions <- ...future.conditions
[16:04:16.648]     ...future.result$finished <- base::Sys.time()
[16:04:16.648]     ...future.result
[16:04:16.648] }
[16:04:16.651] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:04:16.651] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:04:16.651] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.651] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:04:16.652] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.652] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:04:16.652] MultisessionFuture started
[16:04:16.653] - Launch lazy future ... done
[16:04:16.653] run() for ‘MultisessionFuture’ ... done
[16:04:16.653] result() for ClusterFuture ...
[16:04:16.653] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.653] - Validating connection of MultisessionFuture
[16:04:16.699] - received message: FutureResult
[16:04:16.699] - Received FutureResult
[16:04:16.700] - Erased future from FutureRegistry
[16:04:16.700] result() for ClusterFuture ...
[16:04:16.700] - result already collected: FutureResult
[16:04:16.700] result() for ClusterFuture ... done
[16:04:16.700] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.700] result() for ClusterFuture ... done
[16:04:16.700] result() for ClusterFuture ...
[16:04:16.700] - result already collected: FutureResult
[16:04:16.700] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55e6ef28ef38>
Arguments '...' exists: FALSE
[16:04:16.701] getGlobalsAndPackages() ...
[16:04:16.701] Searching for globals...
[16:04:16.703] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[16:04:16.703] Searching for globals ... DONE
[16:04:16.703] Resolving globals: FALSE
[16:04:16.703] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:16.704] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:16.704] - globals: [2] ‘x’, ‘y’
[16:04:16.704] 
[16:04:16.704] getGlobalsAndPackages() ... DONE
[16:04:16.704] run() for ‘Future’ ...
[16:04:16.705] - state: ‘created’
[16:04:16.705] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.719] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.720]   - Field: ‘node’
[16:04:16.720]   - Field: ‘label’
[16:04:16.720]   - Field: ‘local’
[16:04:16.720]   - Field: ‘owner’
[16:04:16.720]   - Field: ‘envir’
[16:04:16.720]   - Field: ‘workers’
[16:04:16.720]   - Field: ‘packages’
[16:04:16.720]   - Field: ‘gc’
[16:04:16.720]   - Field: ‘conditions’
[16:04:16.720]   - Field: ‘persistent’
[16:04:16.721]   - Field: ‘expr’
[16:04:16.721]   - Field: ‘uuid’
[16:04:16.721]   - Field: ‘seed’
[16:04:16.721]   - Field: ‘version’
[16:04:16.721]   - Field: ‘result’
[16:04:16.721]   - Field: ‘asynchronous’
[16:04:16.721]   - Field: ‘calls’
[16:04:16.721]   - Field: ‘globals’
[16:04:16.721]   - Field: ‘stdout’
[16:04:16.722]   - Field: ‘earlySignal’
[16:04:16.722]   - Field: ‘lazy’
[16:04:16.722]   - Field: ‘state’
[16:04:16.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.722] - Launch lazy future ...
[16:04:16.722] Packages needed by the future expression (n = 0): <none>
[16:04:16.723] Packages needed by future strategies (n = 0): <none>
[16:04:16.723] {
[16:04:16.723]     {
[16:04:16.723]         {
[16:04:16.723]             ...future.startTime <- base::Sys.time()
[16:04:16.723]             {
[16:04:16.723]                 {
[16:04:16.723]                   {
[16:04:16.723]                     {
[16:04:16.723]                       base::local({
[16:04:16.723]                         has_future <- base::requireNamespace("future", 
[16:04:16.723]                           quietly = TRUE)
[16:04:16.723]                         if (has_future) {
[16:04:16.723]                           ns <- base::getNamespace("future")
[16:04:16.723]                           version <- ns[[".package"]][["version"]]
[16:04:16.723]                           if (is.null(version)) 
[16:04:16.723]                             version <- utils::packageVersion("future")
[16:04:16.723]                         }
[16:04:16.723]                         else {
[16:04:16.723]                           version <- NULL
[16:04:16.723]                         }
[16:04:16.723]                         if (!has_future || version < "1.8.0") {
[16:04:16.723]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.723]                             "", base::R.version$version.string), 
[16:04:16.723]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.723]                               "release", "version")], collapse = " "), 
[16:04:16.723]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.723]                             info)
[16:04:16.723]                           info <- base::paste(info, collapse = "; ")
[16:04:16.723]                           if (!has_future) {
[16:04:16.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.723]                               info)
[16:04:16.723]                           }
[16:04:16.723]                           else {
[16:04:16.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.723]                               info, version)
[16:04:16.723]                           }
[16:04:16.723]                           base::stop(msg)
[16:04:16.723]                         }
[16:04:16.723]                       })
[16:04:16.723]                     }
[16:04:16.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.723]                     base::options(mc.cores = 1L)
[16:04:16.723]                   }
[16:04:16.723]                   options(future.plan = NULL)
[16:04:16.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.723]                 }
[16:04:16.723]                 ...future.workdir <- getwd()
[16:04:16.723]             }
[16:04:16.723]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.723]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.723]         }
[16:04:16.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.723]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.723]             base::names(...future.oldOptions))
[16:04:16.723]     }
[16:04:16.723]     if (FALSE) {
[16:04:16.723]     }
[16:04:16.723]     else {
[16:04:16.723]         if (TRUE) {
[16:04:16.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.723]                 open = "w")
[16:04:16.723]         }
[16:04:16.723]         else {
[16:04:16.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.723]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.723]         }
[16:04:16.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.723]             base::sink(type = "output", split = FALSE)
[16:04:16.723]             base::close(...future.stdout)
[16:04:16.723]         }, add = TRUE)
[16:04:16.723]     }
[16:04:16.723]     ...future.frame <- base::sys.nframe()
[16:04:16.723]     ...future.conditions <- base::list()
[16:04:16.723]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.723]     if (FALSE) {
[16:04:16.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.723]     }
[16:04:16.723]     ...future.result <- base::tryCatch({
[16:04:16.723]         base::withCallingHandlers({
[16:04:16.723]             ...future.value <- base::withVisible(base::local({
[16:04:16.723]                 ...future.makeSendCondition <- base::local({
[16:04:16.723]                   sendCondition <- NULL
[16:04:16.723]                   function(frame = 1L) {
[16:04:16.723]                     if (is.function(sendCondition)) 
[16:04:16.723]                       return(sendCondition)
[16:04:16.723]                     ns <- getNamespace("parallel")
[16:04:16.723]                     if (exists("sendData", mode = "function", 
[16:04:16.723]                       envir = ns)) {
[16:04:16.723]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.723]                         envir = ns)
[16:04:16.723]                       envir <- sys.frame(frame)
[16:04:16.723]                       master <- NULL
[16:04:16.723]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.723]                         !identical(envir, emptyenv())) {
[16:04:16.723]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.723]                           inherits = FALSE)) {
[16:04:16.723]                           master <- get("master", mode = "list", 
[16:04:16.723]                             envir = envir, inherits = FALSE)
[16:04:16.723]                           if (inherits(master, c("SOCKnode", 
[16:04:16.723]                             "SOCK0node"))) {
[16:04:16.723]                             sendCondition <<- function(cond) {
[16:04:16.723]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.723]                                 success = TRUE)
[16:04:16.723]                               parallel_sendData(master, data)
[16:04:16.723]                             }
[16:04:16.723]                             return(sendCondition)
[16:04:16.723]                           }
[16:04:16.723]                         }
[16:04:16.723]                         frame <- frame + 1L
[16:04:16.723]                         envir <- sys.frame(frame)
[16:04:16.723]                       }
[16:04:16.723]                     }
[16:04:16.723]                     sendCondition <<- function(cond) NULL
[16:04:16.723]                   }
[16:04:16.723]                 })
[16:04:16.723]                 withCallingHandlers({
[16:04:16.723]                   {
[16:04:16.723]                     sum(x, y)
[16:04:16.723]                   }
[16:04:16.723]                 }, immediateCondition = function(cond) {
[16:04:16.723]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.723]                   sendCondition(cond)
[16:04:16.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.723]                   {
[16:04:16.723]                     inherits <- base::inherits
[16:04:16.723]                     invokeRestart <- base::invokeRestart
[16:04:16.723]                     is.null <- base::is.null
[16:04:16.723]                     muffled <- FALSE
[16:04:16.723]                     if (inherits(cond, "message")) {
[16:04:16.723]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.723]                       if (muffled) 
[16:04:16.723]                         invokeRestart("muffleMessage")
[16:04:16.723]                     }
[16:04:16.723]                     else if (inherits(cond, "warning")) {
[16:04:16.723]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.723]                       if (muffled) 
[16:04:16.723]                         invokeRestart("muffleWarning")
[16:04:16.723]                     }
[16:04:16.723]                     else if (inherits(cond, "condition")) {
[16:04:16.723]                       if (!is.null(pattern)) {
[16:04:16.723]                         computeRestarts <- base::computeRestarts
[16:04:16.723]                         grepl <- base::grepl
[16:04:16.723]                         restarts <- computeRestarts(cond)
[16:04:16.723]                         for (restart in restarts) {
[16:04:16.723]                           name <- restart$name
[16:04:16.723]                           if (is.null(name)) 
[16:04:16.723]                             next
[16:04:16.723]                           if (!grepl(pattern, name)) 
[16:04:16.723]                             next
[16:04:16.723]                           invokeRestart(restart)
[16:04:16.723]                           muffled <- TRUE
[16:04:16.723]                           break
[16:04:16.723]                         }
[16:04:16.723]                       }
[16:04:16.723]                     }
[16:04:16.723]                     invisible(muffled)
[16:04:16.723]                   }
[16:04:16.723]                   muffleCondition(cond)
[16:04:16.723]                 })
[16:04:16.723]             }))
[16:04:16.723]             future::FutureResult(value = ...future.value$value, 
[16:04:16.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.723]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.723]                     ...future.globalenv.names))
[16:04:16.723]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.723]         }, condition = base::local({
[16:04:16.723]             c <- base::c
[16:04:16.723]             inherits <- base::inherits
[16:04:16.723]             invokeRestart <- base::invokeRestart
[16:04:16.723]             length <- base::length
[16:04:16.723]             list <- base::list
[16:04:16.723]             seq.int <- base::seq.int
[16:04:16.723]             signalCondition <- base::signalCondition
[16:04:16.723]             sys.calls <- base::sys.calls
[16:04:16.723]             `[[` <- base::`[[`
[16:04:16.723]             `+` <- base::`+`
[16:04:16.723]             `<<-` <- base::`<<-`
[16:04:16.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.723]                   3L)]
[16:04:16.723]             }
[16:04:16.723]             function(cond) {
[16:04:16.723]                 is_error <- inherits(cond, "error")
[16:04:16.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.723]                   NULL)
[16:04:16.723]                 if (is_error) {
[16:04:16.723]                   sessionInformation <- function() {
[16:04:16.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.723]                       search = base::search(), system = base::Sys.info())
[16:04:16.723]                   }
[16:04:16.723]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.723]                     cond$call), session = sessionInformation(), 
[16:04:16.723]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.723]                   signalCondition(cond)
[16:04:16.723]                 }
[16:04:16.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.723]                 "immediateCondition"))) {
[16:04:16.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.723]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.723]                   if (TRUE && !signal) {
[16:04:16.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.723]                     {
[16:04:16.723]                       inherits <- base::inherits
[16:04:16.723]                       invokeRestart <- base::invokeRestart
[16:04:16.723]                       is.null <- base::is.null
[16:04:16.723]                       muffled <- FALSE
[16:04:16.723]                       if (inherits(cond, "message")) {
[16:04:16.723]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.723]                         if (muffled) 
[16:04:16.723]                           invokeRestart("muffleMessage")
[16:04:16.723]                       }
[16:04:16.723]                       else if (inherits(cond, "warning")) {
[16:04:16.723]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.723]                         if (muffled) 
[16:04:16.723]                           invokeRestart("muffleWarning")
[16:04:16.723]                       }
[16:04:16.723]                       else if (inherits(cond, "condition")) {
[16:04:16.723]                         if (!is.null(pattern)) {
[16:04:16.723]                           computeRestarts <- base::computeRestarts
[16:04:16.723]                           grepl <- base::grepl
[16:04:16.723]                           restarts <- computeRestarts(cond)
[16:04:16.723]                           for (restart in restarts) {
[16:04:16.723]                             name <- restart$name
[16:04:16.723]                             if (is.null(name)) 
[16:04:16.723]                               next
[16:04:16.723]                             if (!grepl(pattern, name)) 
[16:04:16.723]                               next
[16:04:16.723]                             invokeRestart(restart)
[16:04:16.723]                             muffled <- TRUE
[16:04:16.723]                             break
[16:04:16.723]                           }
[16:04:16.723]                         }
[16:04:16.723]                       }
[16:04:16.723]                       invisible(muffled)
[16:04:16.723]                     }
[16:04:16.723]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.723]                   }
[16:04:16.723]                 }
[16:04:16.723]                 else {
[16:04:16.723]                   if (TRUE) {
[16:04:16.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.723]                     {
[16:04:16.723]                       inherits <- base::inherits
[16:04:16.723]                       invokeRestart <- base::invokeRestart
[16:04:16.723]                       is.null <- base::is.null
[16:04:16.723]                       muffled <- FALSE
[16:04:16.723]                       if (inherits(cond, "message")) {
[16:04:16.723]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.723]                         if (muffled) 
[16:04:16.723]                           invokeRestart("muffleMessage")
[16:04:16.723]                       }
[16:04:16.723]                       else if (inherits(cond, "warning")) {
[16:04:16.723]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.723]                         if (muffled) 
[16:04:16.723]                           invokeRestart("muffleWarning")
[16:04:16.723]                       }
[16:04:16.723]                       else if (inherits(cond, "condition")) {
[16:04:16.723]                         if (!is.null(pattern)) {
[16:04:16.723]                           computeRestarts <- base::computeRestarts
[16:04:16.723]                           grepl <- base::grepl
[16:04:16.723]                           restarts <- computeRestarts(cond)
[16:04:16.723]                           for (restart in restarts) {
[16:04:16.723]                             name <- restart$name
[16:04:16.723]                             if (is.null(name)) 
[16:04:16.723]                               next
[16:04:16.723]                             if (!grepl(pattern, name)) 
[16:04:16.723]                               next
[16:04:16.723]                             invokeRestart(restart)
[16:04:16.723]                             muffled <- TRUE
[16:04:16.723]                             break
[16:04:16.723]                           }
[16:04:16.723]                         }
[16:04:16.723]                       }
[16:04:16.723]                       invisible(muffled)
[16:04:16.723]                     }
[16:04:16.723]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.723]                   }
[16:04:16.723]                 }
[16:04:16.723]             }
[16:04:16.723]         }))
[16:04:16.723]     }, error = function(ex) {
[16:04:16.723]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.723]                 ...future.rng), started = ...future.startTime, 
[16:04:16.723]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.723]             version = "1.8"), class = "FutureResult")
[16:04:16.723]     }, finally = {
[16:04:16.723]         if (!identical(...future.workdir, getwd())) 
[16:04:16.723]             setwd(...future.workdir)
[16:04:16.723]         {
[16:04:16.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.723]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.723]             }
[16:04:16.723]             base::options(...future.oldOptions)
[16:04:16.723]             if (.Platform$OS.type == "windows") {
[16:04:16.723]                 old_names <- names(...future.oldEnvVars)
[16:04:16.723]                 envs <- base::Sys.getenv()
[16:04:16.723]                 names <- names(envs)
[16:04:16.723]                 common <- intersect(names, old_names)
[16:04:16.723]                 added <- setdiff(names, old_names)
[16:04:16.723]                 removed <- setdiff(old_names, names)
[16:04:16.723]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.723]                   envs[common]]
[16:04:16.723]                 NAMES <- toupper(changed)
[16:04:16.723]                 args <- list()
[16:04:16.723]                 for (kk in seq_along(NAMES)) {
[16:04:16.723]                   name <- changed[[kk]]
[16:04:16.723]                   NAME <- NAMES[[kk]]
[16:04:16.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.723]                     next
[16:04:16.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.723]                 }
[16:04:16.723]                 NAMES <- toupper(added)
[16:04:16.723]                 for (kk in seq_along(NAMES)) {
[16:04:16.723]                   name <- added[[kk]]
[16:04:16.723]                   NAME <- NAMES[[kk]]
[16:04:16.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.723]                     next
[16:04:16.723]                   args[[name]] <- ""
[16:04:16.723]                 }
[16:04:16.723]                 NAMES <- toupper(removed)
[16:04:16.723]                 for (kk in seq_along(NAMES)) {
[16:04:16.723]                   name <- removed[[kk]]
[16:04:16.723]                   NAME <- NAMES[[kk]]
[16:04:16.723]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.723]                     next
[16:04:16.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.723]                 }
[16:04:16.723]                 if (length(args) > 0) 
[16:04:16.723]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.723]             }
[16:04:16.723]             else {
[16:04:16.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.723]             }
[16:04:16.723]             {
[16:04:16.723]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.723]                   0L) {
[16:04:16.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.723]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.723]                   base::options(opts)
[16:04:16.723]                 }
[16:04:16.723]                 {
[16:04:16.723]                   {
[16:04:16.723]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.723]                     NULL
[16:04:16.723]                   }
[16:04:16.723]                   options(future.plan = NULL)
[16:04:16.723]                   if (is.na(NA_character_)) 
[16:04:16.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.723]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.723]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.723]                     envir = parent.frame()) 
[16:04:16.723]                   {
[16:04:16.723]                     if (is.function(workers)) 
[16:04:16.723]                       workers <- workers()
[16:04:16.723]                     workers <- structure(as.integer(workers), 
[16:04:16.723]                       class = class(workers))
[16:04:16.723]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.723]                       workers >= 1)
[16:04:16.723]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.723]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.723]                     }
[16:04:16.723]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.723]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.723]                       envir = envir)
[16:04:16.723]                     if (!future$lazy) 
[16:04:16.723]                       future <- run(future)
[16:04:16.723]                     invisible(future)
[16:04:16.723]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.723]                 }
[16:04:16.723]             }
[16:04:16.723]         }
[16:04:16.723]     })
[16:04:16.723]     if (TRUE) {
[16:04:16.723]         base::sink(type = "output", split = FALSE)
[16:04:16.723]         if (TRUE) {
[16:04:16.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.723]         }
[16:04:16.723]         else {
[16:04:16.723]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.723]         }
[16:04:16.723]         base::close(...future.stdout)
[16:04:16.723]         ...future.stdout <- NULL
[16:04:16.723]     }
[16:04:16.723]     ...future.result$conditions <- ...future.conditions
[16:04:16.723]     ...future.result$finished <- base::Sys.time()
[16:04:16.723]     ...future.result
[16:04:16.723] }
[16:04:16.726] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:04:16.728] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:04:16.729] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.729] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[16:04:16.729] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.729] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:04:16.730] MultisessionFuture started
[16:04:16.730] - Launch lazy future ... done
[16:04:16.730] run() for ‘MultisessionFuture’ ... done
[16:04:16.730] result() for ClusterFuture ...
[16:04:16.730] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.730] - Validating connection of MultisessionFuture
[16:04:16.775] - received message: FutureResult
[16:04:16.776] - Received FutureResult
[16:04:16.776] - Erased future from FutureRegistry
[16:04:16.776] result() for ClusterFuture ...
[16:04:16.776] - result already collected: FutureResult
[16:04:16.776] result() for ClusterFuture ... done
[16:04:16.776] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.776] result() for ClusterFuture ... done
[16:04:16.776] result() for ClusterFuture ...
[16:04:16.776] - result already collected: FutureResult
[16:04:16.776] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x55e6ef478610>
Arguments '...' exists: FALSE
[16:04:16.777] getGlobalsAndPackages() ...
[16:04:16.777] Searching for globals...
[16:04:16.778] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[16:04:16.778] Searching for globals ... DONE
[16:04:16.778] Resolving globals: FALSE
[16:04:16.779] Tweak future expression to call with '...' arguments ...
[16:04:16.779] The total size of the 2 globals is 112 bytes (112 bytes)
[16:04:16.779] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:16.780] - globals: [2] ‘x’, ‘y’
[16:04:16.780] 
[16:04:16.780] getGlobalsAndPackages() ... DONE
[16:04:16.780] run() for ‘Future’ ...
[16:04:16.780] - state: ‘created’
[16:04:16.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.794]   - Field: ‘node’
[16:04:16.794]   - Field: ‘label’
[16:04:16.794]   - Field: ‘local’
[16:04:16.794]   - Field: ‘owner’
[16:04:16.794]   - Field: ‘envir’
[16:04:16.794]   - Field: ‘workers’
[16:04:16.794]   - Field: ‘packages’
[16:04:16.794]   - Field: ‘gc’
[16:04:16.794]   - Field: ‘conditions’
[16:04:16.795]   - Field: ‘persistent’
[16:04:16.795]   - Field: ‘expr’
[16:04:16.795]   - Field: ‘uuid’
[16:04:16.795]   - Field: ‘seed’
[16:04:16.795]   - Field: ‘version’
[16:04:16.795]   - Field: ‘result’
[16:04:16.795]   - Field: ‘asynchronous’
[16:04:16.795]   - Field: ‘calls’
[16:04:16.795]   - Field: ‘globals’
[16:04:16.795]   - Field: ‘stdout’
[16:04:16.795]   - Field: ‘earlySignal’
[16:04:16.796]   - Field: ‘lazy’
[16:04:16.796]   - Field: ‘state’
[16:04:16.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.796] - Launch lazy future ...
[16:04:16.796] Packages needed by the future expression (n = 0): <none>
[16:04:16.796] Packages needed by future strategies (n = 0): <none>
[16:04:16.797] {
[16:04:16.797]     {
[16:04:16.797]         {
[16:04:16.797]             ...future.startTime <- base::Sys.time()
[16:04:16.797]             {
[16:04:16.797]                 {
[16:04:16.797]                   {
[16:04:16.797]                     {
[16:04:16.797]                       base::local({
[16:04:16.797]                         has_future <- base::requireNamespace("future", 
[16:04:16.797]                           quietly = TRUE)
[16:04:16.797]                         if (has_future) {
[16:04:16.797]                           ns <- base::getNamespace("future")
[16:04:16.797]                           version <- ns[[".package"]][["version"]]
[16:04:16.797]                           if (is.null(version)) 
[16:04:16.797]                             version <- utils::packageVersion("future")
[16:04:16.797]                         }
[16:04:16.797]                         else {
[16:04:16.797]                           version <- NULL
[16:04:16.797]                         }
[16:04:16.797]                         if (!has_future || version < "1.8.0") {
[16:04:16.797]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.797]                             "", base::R.version$version.string), 
[16:04:16.797]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.797]                               "release", "version")], collapse = " "), 
[16:04:16.797]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.797]                             info)
[16:04:16.797]                           info <- base::paste(info, collapse = "; ")
[16:04:16.797]                           if (!has_future) {
[16:04:16.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.797]                               info)
[16:04:16.797]                           }
[16:04:16.797]                           else {
[16:04:16.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.797]                               info, version)
[16:04:16.797]                           }
[16:04:16.797]                           base::stop(msg)
[16:04:16.797]                         }
[16:04:16.797]                       })
[16:04:16.797]                     }
[16:04:16.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.797]                     base::options(mc.cores = 1L)
[16:04:16.797]                   }
[16:04:16.797]                   options(future.plan = NULL)
[16:04:16.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.797]                 }
[16:04:16.797]                 ...future.workdir <- getwd()
[16:04:16.797]             }
[16:04:16.797]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.797]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.797]         }
[16:04:16.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.797]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.797]             base::names(...future.oldOptions))
[16:04:16.797]     }
[16:04:16.797]     if (FALSE) {
[16:04:16.797]     }
[16:04:16.797]     else {
[16:04:16.797]         if (TRUE) {
[16:04:16.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.797]                 open = "w")
[16:04:16.797]         }
[16:04:16.797]         else {
[16:04:16.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.797]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.797]         }
[16:04:16.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.797]             base::sink(type = "output", split = FALSE)
[16:04:16.797]             base::close(...future.stdout)
[16:04:16.797]         }, add = TRUE)
[16:04:16.797]     }
[16:04:16.797]     ...future.frame <- base::sys.nframe()
[16:04:16.797]     ...future.conditions <- base::list()
[16:04:16.797]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.797]     if (FALSE) {
[16:04:16.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.797]     }
[16:04:16.797]     ...future.result <- base::tryCatch({
[16:04:16.797]         base::withCallingHandlers({
[16:04:16.797]             ...future.value <- base::withVisible(base::local({
[16:04:16.797]                 ...future.makeSendCondition <- base::local({
[16:04:16.797]                   sendCondition <- NULL
[16:04:16.797]                   function(frame = 1L) {
[16:04:16.797]                     if (is.function(sendCondition)) 
[16:04:16.797]                       return(sendCondition)
[16:04:16.797]                     ns <- getNamespace("parallel")
[16:04:16.797]                     if (exists("sendData", mode = "function", 
[16:04:16.797]                       envir = ns)) {
[16:04:16.797]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.797]                         envir = ns)
[16:04:16.797]                       envir <- sys.frame(frame)
[16:04:16.797]                       master <- NULL
[16:04:16.797]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.797]                         !identical(envir, emptyenv())) {
[16:04:16.797]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.797]                           inherits = FALSE)) {
[16:04:16.797]                           master <- get("master", mode = "list", 
[16:04:16.797]                             envir = envir, inherits = FALSE)
[16:04:16.797]                           if (inherits(master, c("SOCKnode", 
[16:04:16.797]                             "SOCK0node"))) {
[16:04:16.797]                             sendCondition <<- function(cond) {
[16:04:16.797]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.797]                                 success = TRUE)
[16:04:16.797]                               parallel_sendData(master, data)
[16:04:16.797]                             }
[16:04:16.797]                             return(sendCondition)
[16:04:16.797]                           }
[16:04:16.797]                         }
[16:04:16.797]                         frame <- frame + 1L
[16:04:16.797]                         envir <- sys.frame(frame)
[16:04:16.797]                       }
[16:04:16.797]                     }
[16:04:16.797]                     sendCondition <<- function(cond) NULL
[16:04:16.797]                   }
[16:04:16.797]                 })
[16:04:16.797]                 withCallingHandlers({
[16:04:16.797]                   {
[16:04:16.797]                     sum(x, y, ...)
[16:04:16.797]                   }
[16:04:16.797]                 }, immediateCondition = function(cond) {
[16:04:16.797]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.797]                   sendCondition(cond)
[16:04:16.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.797]                   {
[16:04:16.797]                     inherits <- base::inherits
[16:04:16.797]                     invokeRestart <- base::invokeRestart
[16:04:16.797]                     is.null <- base::is.null
[16:04:16.797]                     muffled <- FALSE
[16:04:16.797]                     if (inherits(cond, "message")) {
[16:04:16.797]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.797]                       if (muffled) 
[16:04:16.797]                         invokeRestart("muffleMessage")
[16:04:16.797]                     }
[16:04:16.797]                     else if (inherits(cond, "warning")) {
[16:04:16.797]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.797]                       if (muffled) 
[16:04:16.797]                         invokeRestart("muffleWarning")
[16:04:16.797]                     }
[16:04:16.797]                     else if (inherits(cond, "condition")) {
[16:04:16.797]                       if (!is.null(pattern)) {
[16:04:16.797]                         computeRestarts <- base::computeRestarts
[16:04:16.797]                         grepl <- base::grepl
[16:04:16.797]                         restarts <- computeRestarts(cond)
[16:04:16.797]                         for (restart in restarts) {
[16:04:16.797]                           name <- restart$name
[16:04:16.797]                           if (is.null(name)) 
[16:04:16.797]                             next
[16:04:16.797]                           if (!grepl(pattern, name)) 
[16:04:16.797]                             next
[16:04:16.797]                           invokeRestart(restart)
[16:04:16.797]                           muffled <- TRUE
[16:04:16.797]                           break
[16:04:16.797]                         }
[16:04:16.797]                       }
[16:04:16.797]                     }
[16:04:16.797]                     invisible(muffled)
[16:04:16.797]                   }
[16:04:16.797]                   muffleCondition(cond)
[16:04:16.797]                 })
[16:04:16.797]             }))
[16:04:16.797]             future::FutureResult(value = ...future.value$value, 
[16:04:16.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.797]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.797]                     ...future.globalenv.names))
[16:04:16.797]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.797]         }, condition = base::local({
[16:04:16.797]             c <- base::c
[16:04:16.797]             inherits <- base::inherits
[16:04:16.797]             invokeRestart <- base::invokeRestart
[16:04:16.797]             length <- base::length
[16:04:16.797]             list <- base::list
[16:04:16.797]             seq.int <- base::seq.int
[16:04:16.797]             signalCondition <- base::signalCondition
[16:04:16.797]             sys.calls <- base::sys.calls
[16:04:16.797]             `[[` <- base::`[[`
[16:04:16.797]             `+` <- base::`+`
[16:04:16.797]             `<<-` <- base::`<<-`
[16:04:16.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.797]                   3L)]
[16:04:16.797]             }
[16:04:16.797]             function(cond) {
[16:04:16.797]                 is_error <- inherits(cond, "error")
[16:04:16.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.797]                   NULL)
[16:04:16.797]                 if (is_error) {
[16:04:16.797]                   sessionInformation <- function() {
[16:04:16.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.797]                       search = base::search(), system = base::Sys.info())
[16:04:16.797]                   }
[16:04:16.797]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.797]                     cond$call), session = sessionInformation(), 
[16:04:16.797]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.797]                   signalCondition(cond)
[16:04:16.797]                 }
[16:04:16.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.797]                 "immediateCondition"))) {
[16:04:16.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.797]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.797]                   if (TRUE && !signal) {
[16:04:16.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.797]                     {
[16:04:16.797]                       inherits <- base::inherits
[16:04:16.797]                       invokeRestart <- base::invokeRestart
[16:04:16.797]                       is.null <- base::is.null
[16:04:16.797]                       muffled <- FALSE
[16:04:16.797]                       if (inherits(cond, "message")) {
[16:04:16.797]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.797]                         if (muffled) 
[16:04:16.797]                           invokeRestart("muffleMessage")
[16:04:16.797]                       }
[16:04:16.797]                       else if (inherits(cond, "warning")) {
[16:04:16.797]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.797]                         if (muffled) 
[16:04:16.797]                           invokeRestart("muffleWarning")
[16:04:16.797]                       }
[16:04:16.797]                       else if (inherits(cond, "condition")) {
[16:04:16.797]                         if (!is.null(pattern)) {
[16:04:16.797]                           computeRestarts <- base::computeRestarts
[16:04:16.797]                           grepl <- base::grepl
[16:04:16.797]                           restarts <- computeRestarts(cond)
[16:04:16.797]                           for (restart in restarts) {
[16:04:16.797]                             name <- restart$name
[16:04:16.797]                             if (is.null(name)) 
[16:04:16.797]                               next
[16:04:16.797]                             if (!grepl(pattern, name)) 
[16:04:16.797]                               next
[16:04:16.797]                             invokeRestart(restart)
[16:04:16.797]                             muffled <- TRUE
[16:04:16.797]                             break
[16:04:16.797]                           }
[16:04:16.797]                         }
[16:04:16.797]                       }
[16:04:16.797]                       invisible(muffled)
[16:04:16.797]                     }
[16:04:16.797]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.797]                   }
[16:04:16.797]                 }
[16:04:16.797]                 else {
[16:04:16.797]                   if (TRUE) {
[16:04:16.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.797]                     {
[16:04:16.797]                       inherits <- base::inherits
[16:04:16.797]                       invokeRestart <- base::invokeRestart
[16:04:16.797]                       is.null <- base::is.null
[16:04:16.797]                       muffled <- FALSE
[16:04:16.797]                       if (inherits(cond, "message")) {
[16:04:16.797]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.797]                         if (muffled) 
[16:04:16.797]                           invokeRestart("muffleMessage")
[16:04:16.797]                       }
[16:04:16.797]                       else if (inherits(cond, "warning")) {
[16:04:16.797]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.797]                         if (muffled) 
[16:04:16.797]                           invokeRestart("muffleWarning")
[16:04:16.797]                       }
[16:04:16.797]                       else if (inherits(cond, "condition")) {
[16:04:16.797]                         if (!is.null(pattern)) {
[16:04:16.797]                           computeRestarts <- base::computeRestarts
[16:04:16.797]                           grepl <- base::grepl
[16:04:16.797]                           restarts <- computeRestarts(cond)
[16:04:16.797]                           for (restart in restarts) {
[16:04:16.797]                             name <- restart$name
[16:04:16.797]                             if (is.null(name)) 
[16:04:16.797]                               next
[16:04:16.797]                             if (!grepl(pattern, name)) 
[16:04:16.797]                               next
[16:04:16.797]                             invokeRestart(restart)
[16:04:16.797]                             muffled <- TRUE
[16:04:16.797]                             break
[16:04:16.797]                           }
[16:04:16.797]                         }
[16:04:16.797]                       }
[16:04:16.797]                       invisible(muffled)
[16:04:16.797]                     }
[16:04:16.797]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.797]                   }
[16:04:16.797]                 }
[16:04:16.797]             }
[16:04:16.797]         }))
[16:04:16.797]     }, error = function(ex) {
[16:04:16.797]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.797]                 ...future.rng), started = ...future.startTime, 
[16:04:16.797]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.797]             version = "1.8"), class = "FutureResult")
[16:04:16.797]     }, finally = {
[16:04:16.797]         if (!identical(...future.workdir, getwd())) 
[16:04:16.797]             setwd(...future.workdir)
[16:04:16.797]         {
[16:04:16.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.797]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.797]             }
[16:04:16.797]             base::options(...future.oldOptions)
[16:04:16.797]             if (.Platform$OS.type == "windows") {
[16:04:16.797]                 old_names <- names(...future.oldEnvVars)
[16:04:16.797]                 envs <- base::Sys.getenv()
[16:04:16.797]                 names <- names(envs)
[16:04:16.797]                 common <- intersect(names, old_names)
[16:04:16.797]                 added <- setdiff(names, old_names)
[16:04:16.797]                 removed <- setdiff(old_names, names)
[16:04:16.797]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.797]                   envs[common]]
[16:04:16.797]                 NAMES <- toupper(changed)
[16:04:16.797]                 args <- list()
[16:04:16.797]                 for (kk in seq_along(NAMES)) {
[16:04:16.797]                   name <- changed[[kk]]
[16:04:16.797]                   NAME <- NAMES[[kk]]
[16:04:16.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.797]                     next
[16:04:16.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.797]                 }
[16:04:16.797]                 NAMES <- toupper(added)
[16:04:16.797]                 for (kk in seq_along(NAMES)) {
[16:04:16.797]                   name <- added[[kk]]
[16:04:16.797]                   NAME <- NAMES[[kk]]
[16:04:16.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.797]                     next
[16:04:16.797]                   args[[name]] <- ""
[16:04:16.797]                 }
[16:04:16.797]                 NAMES <- toupper(removed)
[16:04:16.797]                 for (kk in seq_along(NAMES)) {
[16:04:16.797]                   name <- removed[[kk]]
[16:04:16.797]                   NAME <- NAMES[[kk]]
[16:04:16.797]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.797]                     next
[16:04:16.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.797]                 }
[16:04:16.797]                 if (length(args) > 0) 
[16:04:16.797]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.797]             }
[16:04:16.797]             else {
[16:04:16.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.797]             }
[16:04:16.797]             {
[16:04:16.797]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.797]                   0L) {
[16:04:16.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.797]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.797]                   base::options(opts)
[16:04:16.797]                 }
[16:04:16.797]                 {
[16:04:16.797]                   {
[16:04:16.797]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.797]                     NULL
[16:04:16.797]                   }
[16:04:16.797]                   options(future.plan = NULL)
[16:04:16.797]                   if (is.na(NA_character_)) 
[16:04:16.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.797]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.797]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.797]                     envir = parent.frame()) 
[16:04:16.797]                   {
[16:04:16.797]                     if (is.function(workers)) 
[16:04:16.797]                       workers <- workers()
[16:04:16.797]                     workers <- structure(as.integer(workers), 
[16:04:16.797]                       class = class(workers))
[16:04:16.797]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.797]                       workers >= 1)
[16:04:16.797]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.797]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.797]                     }
[16:04:16.797]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.797]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.797]                       envir = envir)
[16:04:16.797]                     if (!future$lazy) 
[16:04:16.797]                       future <- run(future)
[16:04:16.797]                     invisible(future)
[16:04:16.797]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.797]                 }
[16:04:16.797]             }
[16:04:16.797]         }
[16:04:16.797]     })
[16:04:16.797]     if (TRUE) {
[16:04:16.797]         base::sink(type = "output", split = FALSE)
[16:04:16.797]         if (TRUE) {
[16:04:16.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.797]         }
[16:04:16.797]         else {
[16:04:16.797]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.797]         }
[16:04:16.797]         base::close(...future.stdout)
[16:04:16.797]         ...future.stdout <- NULL
[16:04:16.797]     }
[16:04:16.797]     ...future.result$conditions <- ...future.conditions
[16:04:16.797]     ...future.result$finished <- base::Sys.time()
[16:04:16.797]     ...future.result
[16:04:16.797] }
[16:04:16.799] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[16:04:16.799] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:04:16.799] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.800] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[16:04:16.800] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.800] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[16:04:16.800] MultisessionFuture started
[16:04:16.801] - Launch lazy future ... done
[16:04:16.801] run() for ‘MultisessionFuture’ ... done
[16:04:16.801] result() for ClusterFuture ...
[16:04:16.801] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.801] - Validating connection of MultisessionFuture
[16:04:16.848] - received message: FutureResult
[16:04:16.848] - Received FutureResult
[16:04:16.848] - Erased future from FutureRegistry
[16:04:16.848] result() for ClusterFuture ...
[16:04:16.848] - result already collected: FutureResult
[16:04:16.848] result() for ClusterFuture ... done
[16:04:16.848] signalConditions() ...
[16:04:16.848]  - include = ‘immediateCondition’
[16:04:16.849]  - exclude = 
[16:04:16.849]  - resignal = FALSE
[16:04:16.849]  - Number of conditions: 1
[16:04:16.849] signalConditions() ... done
[16:04:16.849] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.849] result() for ClusterFuture ... done
[16:04:16.849] result() for ClusterFuture ...
[16:04:16.849] - result already collected: FutureResult
[16:04:16.849] result() for ClusterFuture ... done
[16:04:16.849] signalConditions() ...
[16:04:16.849]  - include = ‘immediateCondition’
[16:04:16.849]  - exclude = 
[16:04:16.850]  - resignal = FALSE
[16:04:16.850]  - Number of conditions: 1
[16:04:16.850] signalConditions() ... done
[16:04:16.850] Future state: ‘finished’
[16:04:16.850] result() for ClusterFuture ...
[16:04:16.850] - result already collected: FutureResult
[16:04:16.850] result() for ClusterFuture ... done
[16:04:16.850] signalConditions() ...
[16:04:16.850]  - include = ‘condition’
[16:04:16.850]  - exclude = ‘immediateCondition’
[16:04:16.850]  - resignal = TRUE
[16:04:16.851]  - Number of conditions: 1
[16:04:16.851]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[16:04:16.851] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x55e6ee67a488>
Arguments '...' exists: TRUE
[16:04:16.852] getGlobalsAndPackages() ...
[16:04:16.852] - globals passed as-is: [1] ‘...’
[16:04:16.852] Resolving globals: FALSE
[16:04:16.852] Tweak future expression to call with '...' arguments ...
[16:04:16.852] {
[16:04:16.852]     do.call(function(...) {
[16:04:16.852]         fcn <- function() sum(...)
[16:04:16.852]         fcn()
[16:04:16.852]     }, args = future.call.arguments)
[16:04:16.852] }
[16:04:16.852] Tweak future expression to call with '...' arguments ... DONE
[16:04:16.853] The total size of the 1 globals is 112 bytes (112 bytes)
[16:04:16.853] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[16:04:16.853] - globals: [1] ‘future.call.arguments’
[16:04:16.853] 
[16:04:16.853] getGlobalsAndPackages() ... DONE
[16:04:16.853] run() for ‘Future’ ...
[16:04:16.854] - state: ‘created’
[16:04:16.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.868]   - Field: ‘node’
[16:04:16.868]   - Field: ‘label’
[16:04:16.868]   - Field: ‘local’
[16:04:16.868]   - Field: ‘owner’
[16:04:16.868]   - Field: ‘envir’
[16:04:16.869]   - Field: ‘workers’
[16:04:16.869]   - Field: ‘packages’
[16:04:16.869]   - Field: ‘gc’
[16:04:16.869]   - Field: ‘conditions’
[16:04:16.869]   - Field: ‘persistent’
[16:04:16.869]   - Field: ‘expr’
[16:04:16.869]   - Field: ‘uuid’
[16:04:16.869]   - Field: ‘seed’
[16:04:16.869]   - Field: ‘version’
[16:04:16.869]   - Field: ‘result’
[16:04:16.869]   - Field: ‘asynchronous’
[16:04:16.870]   - Field: ‘calls’
[16:04:16.870]   - Field: ‘globals’
[16:04:16.870]   - Field: ‘stdout’
[16:04:16.870]   - Field: ‘earlySignal’
[16:04:16.870]   - Field: ‘lazy’
[16:04:16.870]   - Field: ‘state’
[16:04:16.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.870] - Launch lazy future ...
[16:04:16.870] Packages needed by the future expression (n = 0): <none>
[16:04:16.871] Packages needed by future strategies (n = 0): <none>
[16:04:16.871] {
[16:04:16.871]     {
[16:04:16.871]         {
[16:04:16.871]             ...future.startTime <- base::Sys.time()
[16:04:16.871]             {
[16:04:16.871]                 {
[16:04:16.871]                   {
[16:04:16.871]                     {
[16:04:16.871]                       base::local({
[16:04:16.871]                         has_future <- base::requireNamespace("future", 
[16:04:16.871]                           quietly = TRUE)
[16:04:16.871]                         if (has_future) {
[16:04:16.871]                           ns <- base::getNamespace("future")
[16:04:16.871]                           version <- ns[[".package"]][["version"]]
[16:04:16.871]                           if (is.null(version)) 
[16:04:16.871]                             version <- utils::packageVersion("future")
[16:04:16.871]                         }
[16:04:16.871]                         else {
[16:04:16.871]                           version <- NULL
[16:04:16.871]                         }
[16:04:16.871]                         if (!has_future || version < "1.8.0") {
[16:04:16.871]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.871]                             "", base::R.version$version.string), 
[16:04:16.871]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.871]                               "release", "version")], collapse = " "), 
[16:04:16.871]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.871]                             info)
[16:04:16.871]                           info <- base::paste(info, collapse = "; ")
[16:04:16.871]                           if (!has_future) {
[16:04:16.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.871]                               info)
[16:04:16.871]                           }
[16:04:16.871]                           else {
[16:04:16.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.871]                               info, version)
[16:04:16.871]                           }
[16:04:16.871]                           base::stop(msg)
[16:04:16.871]                         }
[16:04:16.871]                       })
[16:04:16.871]                     }
[16:04:16.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.871]                     base::options(mc.cores = 1L)
[16:04:16.871]                   }
[16:04:16.871]                   options(future.plan = NULL)
[16:04:16.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.871]                 }
[16:04:16.871]                 ...future.workdir <- getwd()
[16:04:16.871]             }
[16:04:16.871]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.871]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.871]         }
[16:04:16.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.871]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.871]             base::names(...future.oldOptions))
[16:04:16.871]     }
[16:04:16.871]     if (FALSE) {
[16:04:16.871]     }
[16:04:16.871]     else {
[16:04:16.871]         if (TRUE) {
[16:04:16.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.871]                 open = "w")
[16:04:16.871]         }
[16:04:16.871]         else {
[16:04:16.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.871]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.871]         }
[16:04:16.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.871]             base::sink(type = "output", split = FALSE)
[16:04:16.871]             base::close(...future.stdout)
[16:04:16.871]         }, add = TRUE)
[16:04:16.871]     }
[16:04:16.871]     ...future.frame <- base::sys.nframe()
[16:04:16.871]     ...future.conditions <- base::list()
[16:04:16.871]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.871]     if (FALSE) {
[16:04:16.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.871]     }
[16:04:16.871]     ...future.result <- base::tryCatch({
[16:04:16.871]         base::withCallingHandlers({
[16:04:16.871]             ...future.value <- base::withVisible(base::local({
[16:04:16.871]                 ...future.makeSendCondition <- base::local({
[16:04:16.871]                   sendCondition <- NULL
[16:04:16.871]                   function(frame = 1L) {
[16:04:16.871]                     if (is.function(sendCondition)) 
[16:04:16.871]                       return(sendCondition)
[16:04:16.871]                     ns <- getNamespace("parallel")
[16:04:16.871]                     if (exists("sendData", mode = "function", 
[16:04:16.871]                       envir = ns)) {
[16:04:16.871]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.871]                         envir = ns)
[16:04:16.871]                       envir <- sys.frame(frame)
[16:04:16.871]                       master <- NULL
[16:04:16.871]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.871]                         !identical(envir, emptyenv())) {
[16:04:16.871]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.871]                           inherits = FALSE)) {
[16:04:16.871]                           master <- get("master", mode = "list", 
[16:04:16.871]                             envir = envir, inherits = FALSE)
[16:04:16.871]                           if (inherits(master, c("SOCKnode", 
[16:04:16.871]                             "SOCK0node"))) {
[16:04:16.871]                             sendCondition <<- function(cond) {
[16:04:16.871]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.871]                                 success = TRUE)
[16:04:16.871]                               parallel_sendData(master, data)
[16:04:16.871]                             }
[16:04:16.871]                             return(sendCondition)
[16:04:16.871]                           }
[16:04:16.871]                         }
[16:04:16.871]                         frame <- frame + 1L
[16:04:16.871]                         envir <- sys.frame(frame)
[16:04:16.871]                       }
[16:04:16.871]                     }
[16:04:16.871]                     sendCondition <<- function(cond) NULL
[16:04:16.871]                   }
[16:04:16.871]                 })
[16:04:16.871]                 withCallingHandlers({
[16:04:16.871]                   {
[16:04:16.871]                     do.call(function(...) {
[16:04:16.871]                       fcn <- function() sum(...)
[16:04:16.871]                       fcn()
[16:04:16.871]                     }, args = future.call.arguments)
[16:04:16.871]                   }
[16:04:16.871]                 }, immediateCondition = function(cond) {
[16:04:16.871]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.871]                   sendCondition(cond)
[16:04:16.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.871]                   {
[16:04:16.871]                     inherits <- base::inherits
[16:04:16.871]                     invokeRestart <- base::invokeRestart
[16:04:16.871]                     is.null <- base::is.null
[16:04:16.871]                     muffled <- FALSE
[16:04:16.871]                     if (inherits(cond, "message")) {
[16:04:16.871]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.871]                       if (muffled) 
[16:04:16.871]                         invokeRestart("muffleMessage")
[16:04:16.871]                     }
[16:04:16.871]                     else if (inherits(cond, "warning")) {
[16:04:16.871]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.871]                       if (muffled) 
[16:04:16.871]                         invokeRestart("muffleWarning")
[16:04:16.871]                     }
[16:04:16.871]                     else if (inherits(cond, "condition")) {
[16:04:16.871]                       if (!is.null(pattern)) {
[16:04:16.871]                         computeRestarts <- base::computeRestarts
[16:04:16.871]                         grepl <- base::grepl
[16:04:16.871]                         restarts <- computeRestarts(cond)
[16:04:16.871]                         for (restart in restarts) {
[16:04:16.871]                           name <- restart$name
[16:04:16.871]                           if (is.null(name)) 
[16:04:16.871]                             next
[16:04:16.871]                           if (!grepl(pattern, name)) 
[16:04:16.871]                             next
[16:04:16.871]                           invokeRestart(restart)
[16:04:16.871]                           muffled <- TRUE
[16:04:16.871]                           break
[16:04:16.871]                         }
[16:04:16.871]                       }
[16:04:16.871]                     }
[16:04:16.871]                     invisible(muffled)
[16:04:16.871]                   }
[16:04:16.871]                   muffleCondition(cond)
[16:04:16.871]                 })
[16:04:16.871]             }))
[16:04:16.871]             future::FutureResult(value = ...future.value$value, 
[16:04:16.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.871]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.871]                     ...future.globalenv.names))
[16:04:16.871]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.871]         }, condition = base::local({
[16:04:16.871]             c <- base::c
[16:04:16.871]             inherits <- base::inherits
[16:04:16.871]             invokeRestart <- base::invokeRestart
[16:04:16.871]             length <- base::length
[16:04:16.871]             list <- base::list
[16:04:16.871]             seq.int <- base::seq.int
[16:04:16.871]             signalCondition <- base::signalCondition
[16:04:16.871]             sys.calls <- base::sys.calls
[16:04:16.871]             `[[` <- base::`[[`
[16:04:16.871]             `+` <- base::`+`
[16:04:16.871]             `<<-` <- base::`<<-`
[16:04:16.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.871]                   3L)]
[16:04:16.871]             }
[16:04:16.871]             function(cond) {
[16:04:16.871]                 is_error <- inherits(cond, "error")
[16:04:16.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.871]                   NULL)
[16:04:16.871]                 if (is_error) {
[16:04:16.871]                   sessionInformation <- function() {
[16:04:16.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.871]                       search = base::search(), system = base::Sys.info())
[16:04:16.871]                   }
[16:04:16.871]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.871]                     cond$call), session = sessionInformation(), 
[16:04:16.871]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.871]                   signalCondition(cond)
[16:04:16.871]                 }
[16:04:16.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.871]                 "immediateCondition"))) {
[16:04:16.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.871]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.871]                   if (TRUE && !signal) {
[16:04:16.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.871]                     {
[16:04:16.871]                       inherits <- base::inherits
[16:04:16.871]                       invokeRestart <- base::invokeRestart
[16:04:16.871]                       is.null <- base::is.null
[16:04:16.871]                       muffled <- FALSE
[16:04:16.871]                       if (inherits(cond, "message")) {
[16:04:16.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.871]                         if (muffled) 
[16:04:16.871]                           invokeRestart("muffleMessage")
[16:04:16.871]                       }
[16:04:16.871]                       else if (inherits(cond, "warning")) {
[16:04:16.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.871]                         if (muffled) 
[16:04:16.871]                           invokeRestart("muffleWarning")
[16:04:16.871]                       }
[16:04:16.871]                       else if (inherits(cond, "condition")) {
[16:04:16.871]                         if (!is.null(pattern)) {
[16:04:16.871]                           computeRestarts <- base::computeRestarts
[16:04:16.871]                           grepl <- base::grepl
[16:04:16.871]                           restarts <- computeRestarts(cond)
[16:04:16.871]                           for (restart in restarts) {
[16:04:16.871]                             name <- restart$name
[16:04:16.871]                             if (is.null(name)) 
[16:04:16.871]                               next
[16:04:16.871]                             if (!grepl(pattern, name)) 
[16:04:16.871]                               next
[16:04:16.871]                             invokeRestart(restart)
[16:04:16.871]                             muffled <- TRUE
[16:04:16.871]                             break
[16:04:16.871]                           }
[16:04:16.871]                         }
[16:04:16.871]                       }
[16:04:16.871]                       invisible(muffled)
[16:04:16.871]                     }
[16:04:16.871]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.871]                   }
[16:04:16.871]                 }
[16:04:16.871]                 else {
[16:04:16.871]                   if (TRUE) {
[16:04:16.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.871]                     {
[16:04:16.871]                       inherits <- base::inherits
[16:04:16.871]                       invokeRestart <- base::invokeRestart
[16:04:16.871]                       is.null <- base::is.null
[16:04:16.871]                       muffled <- FALSE
[16:04:16.871]                       if (inherits(cond, "message")) {
[16:04:16.871]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.871]                         if (muffled) 
[16:04:16.871]                           invokeRestart("muffleMessage")
[16:04:16.871]                       }
[16:04:16.871]                       else if (inherits(cond, "warning")) {
[16:04:16.871]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.871]                         if (muffled) 
[16:04:16.871]                           invokeRestart("muffleWarning")
[16:04:16.871]                       }
[16:04:16.871]                       else if (inherits(cond, "condition")) {
[16:04:16.871]                         if (!is.null(pattern)) {
[16:04:16.871]                           computeRestarts <- base::computeRestarts
[16:04:16.871]                           grepl <- base::grepl
[16:04:16.871]                           restarts <- computeRestarts(cond)
[16:04:16.871]                           for (restart in restarts) {
[16:04:16.871]                             name <- restart$name
[16:04:16.871]                             if (is.null(name)) 
[16:04:16.871]                               next
[16:04:16.871]                             if (!grepl(pattern, name)) 
[16:04:16.871]                               next
[16:04:16.871]                             invokeRestart(restart)
[16:04:16.871]                             muffled <- TRUE
[16:04:16.871]                             break
[16:04:16.871]                           }
[16:04:16.871]                         }
[16:04:16.871]                       }
[16:04:16.871]                       invisible(muffled)
[16:04:16.871]                     }
[16:04:16.871]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.871]                   }
[16:04:16.871]                 }
[16:04:16.871]             }
[16:04:16.871]         }))
[16:04:16.871]     }, error = function(ex) {
[16:04:16.871]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.871]                 ...future.rng), started = ...future.startTime, 
[16:04:16.871]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.871]             version = "1.8"), class = "FutureResult")
[16:04:16.871]     }, finally = {
[16:04:16.871]         if (!identical(...future.workdir, getwd())) 
[16:04:16.871]             setwd(...future.workdir)
[16:04:16.871]         {
[16:04:16.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.871]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.871]             }
[16:04:16.871]             base::options(...future.oldOptions)
[16:04:16.871]             if (.Platform$OS.type == "windows") {
[16:04:16.871]                 old_names <- names(...future.oldEnvVars)
[16:04:16.871]                 envs <- base::Sys.getenv()
[16:04:16.871]                 names <- names(envs)
[16:04:16.871]                 common <- intersect(names, old_names)
[16:04:16.871]                 added <- setdiff(names, old_names)
[16:04:16.871]                 removed <- setdiff(old_names, names)
[16:04:16.871]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.871]                   envs[common]]
[16:04:16.871]                 NAMES <- toupper(changed)
[16:04:16.871]                 args <- list()
[16:04:16.871]                 for (kk in seq_along(NAMES)) {
[16:04:16.871]                   name <- changed[[kk]]
[16:04:16.871]                   NAME <- NAMES[[kk]]
[16:04:16.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.871]                     next
[16:04:16.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.871]                 }
[16:04:16.871]                 NAMES <- toupper(added)
[16:04:16.871]                 for (kk in seq_along(NAMES)) {
[16:04:16.871]                   name <- added[[kk]]
[16:04:16.871]                   NAME <- NAMES[[kk]]
[16:04:16.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.871]                     next
[16:04:16.871]                   args[[name]] <- ""
[16:04:16.871]                 }
[16:04:16.871]                 NAMES <- toupper(removed)
[16:04:16.871]                 for (kk in seq_along(NAMES)) {
[16:04:16.871]                   name <- removed[[kk]]
[16:04:16.871]                   NAME <- NAMES[[kk]]
[16:04:16.871]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.871]                     next
[16:04:16.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.871]                 }
[16:04:16.871]                 if (length(args) > 0) 
[16:04:16.871]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.871]             }
[16:04:16.871]             else {
[16:04:16.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.871]             }
[16:04:16.871]             {
[16:04:16.871]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.871]                   0L) {
[16:04:16.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.871]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.871]                   base::options(opts)
[16:04:16.871]                 }
[16:04:16.871]                 {
[16:04:16.871]                   {
[16:04:16.871]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.871]                     NULL
[16:04:16.871]                   }
[16:04:16.871]                   options(future.plan = NULL)
[16:04:16.871]                   if (is.na(NA_character_)) 
[16:04:16.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.871]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.871]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.871]                     envir = parent.frame()) 
[16:04:16.871]                   {
[16:04:16.871]                     if (is.function(workers)) 
[16:04:16.871]                       workers <- workers()
[16:04:16.871]                     workers <- structure(as.integer(workers), 
[16:04:16.871]                       class = class(workers))
[16:04:16.871]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.871]                       workers >= 1)
[16:04:16.871]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.871]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.871]                     }
[16:04:16.871]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.871]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.871]                       envir = envir)
[16:04:16.871]                     if (!future$lazy) 
[16:04:16.871]                       future <- run(future)
[16:04:16.871]                     invisible(future)
[16:04:16.871]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.871]                 }
[16:04:16.871]             }
[16:04:16.871]         }
[16:04:16.871]     })
[16:04:16.871]     if (TRUE) {
[16:04:16.871]         base::sink(type = "output", split = FALSE)
[16:04:16.871]         if (TRUE) {
[16:04:16.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.871]         }
[16:04:16.871]         else {
[16:04:16.871]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.871]         }
[16:04:16.871]         base::close(...future.stdout)
[16:04:16.871]         ...future.stdout <- NULL
[16:04:16.871]     }
[16:04:16.871]     ...future.result$conditions <- ...future.conditions
[16:04:16.871]     ...future.result$finished <- base::Sys.time()
[16:04:16.871]     ...future.result
[16:04:16.871] }
[16:04:16.873] Exporting 1 global objects (112 bytes) to cluster node #1 ...
[16:04:16.874] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ...
[16:04:16.874] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ... DONE
[16:04:16.874] Exporting 1 global objects (112 bytes) to cluster node #1 ... DONE
[16:04:16.875] MultisessionFuture started
[16:04:16.875] - Launch lazy future ... done
[16:04:16.875] run() for ‘MultisessionFuture’ ... done
[16:04:16.875] result() for ClusterFuture ...
[16:04:16.875] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.875] - Validating connection of MultisessionFuture
[16:04:16.919] - received message: FutureResult
[16:04:16.919] - Received FutureResult
[16:04:16.919] - Erased future from FutureRegistry
[16:04:16.920] result() for ClusterFuture ...
[16:04:16.920] - result already collected: FutureResult
[16:04:16.920] result() for ClusterFuture ... done
[16:04:16.920] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.920] result() for ClusterFuture ... done
[16:04:16.920] result() for ClusterFuture ...
[16:04:16.920] - result already collected: FutureResult
[16:04:16.920] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x55e6ecf4b790>
Using '...' in a formula
[16:04:16.921] getGlobalsAndPackages() ...
[16:04:16.921] Searching for globals...
[16:04:16.923] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[16:04:16.923] Searching for globals ... DONE
[16:04:16.923] Resolving globals: FALSE
[16:04:16.923] Tweak future expression to call with '...' arguments ...
[16:04:16.924] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[16:04:16.924] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[16:04:16.924] - globals: [3] ‘fcn’, ‘x’, ‘y’
[16:04:16.925] 
[16:04:16.925] getGlobalsAndPackages() ... DONE
[16:04:16.925] run() for ‘Future’ ...
[16:04:16.925] - state: ‘created’
[16:04:16.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:04:16.938] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:04:16.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:04:16.939]   - Field: ‘node’
[16:04:16.939]   - Field: ‘label’
[16:04:16.939]   - Field: ‘local’
[16:04:16.939]   - Field: ‘owner’
[16:04:16.939]   - Field: ‘envir’
[16:04:16.939]   - Field: ‘workers’
[16:04:16.939]   - Field: ‘packages’
[16:04:16.939]   - Field: ‘gc’
[16:04:16.939]   - Field: ‘conditions’
[16:04:16.940]   - Field: ‘persistent’
[16:04:16.940]   - Field: ‘expr’
[16:04:16.940]   - Field: ‘uuid’
[16:04:16.940]   - Field: ‘seed’
[16:04:16.940]   - Field: ‘version’
[16:04:16.940]   - Field: ‘result’
[16:04:16.940]   - Field: ‘asynchronous’
[16:04:16.940]   - Field: ‘calls’
[16:04:16.940]   - Field: ‘globals’
[16:04:16.940]   - Field: ‘stdout’
[16:04:16.940]   - Field: ‘earlySignal’
[16:04:16.941]   - Field: ‘lazy’
[16:04:16.941]   - Field: ‘state’
[16:04:16.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:04:16.941] - Launch lazy future ...
[16:04:16.941] Packages needed by the future expression (n = 0): <none>
[16:04:16.941] Packages needed by future strategies (n = 0): <none>
[16:04:16.942] {
[16:04:16.942]     {
[16:04:16.942]         {
[16:04:16.942]             ...future.startTime <- base::Sys.time()
[16:04:16.942]             {
[16:04:16.942]                 {
[16:04:16.942]                   {
[16:04:16.942]                     {
[16:04:16.942]                       base::local({
[16:04:16.942]                         has_future <- base::requireNamespace("future", 
[16:04:16.942]                           quietly = TRUE)
[16:04:16.942]                         if (has_future) {
[16:04:16.942]                           ns <- base::getNamespace("future")
[16:04:16.942]                           version <- ns[[".package"]][["version"]]
[16:04:16.942]                           if (is.null(version)) 
[16:04:16.942]                             version <- utils::packageVersion("future")
[16:04:16.942]                         }
[16:04:16.942]                         else {
[16:04:16.942]                           version <- NULL
[16:04:16.942]                         }
[16:04:16.942]                         if (!has_future || version < "1.8.0") {
[16:04:16.942]                           info <- base::c(r_version = base::gsub("R version ", 
[16:04:16.942]                             "", base::R.version$version.string), 
[16:04:16.942]                             platform = base::sprintf("%s (%s-bit)", 
[16:04:16.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:04:16.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:04:16.942]                               "release", "version")], collapse = " "), 
[16:04:16.942]                             hostname = base::Sys.info()[["nodename"]])
[16:04:16.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:04:16.942]                             info)
[16:04:16.942]                           info <- base::paste(info, collapse = "; ")
[16:04:16.942]                           if (!has_future) {
[16:04:16.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:04:16.942]                               info)
[16:04:16.942]                           }
[16:04:16.942]                           else {
[16:04:16.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:04:16.942]                               info, version)
[16:04:16.942]                           }
[16:04:16.942]                           base::stop(msg)
[16:04:16.942]                         }
[16:04:16.942]                       })
[16:04:16.942]                     }
[16:04:16.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:04:16.942]                     base::options(mc.cores = 1L)
[16:04:16.942]                   }
[16:04:16.942]                   options(future.plan = NULL)
[16:04:16.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:04:16.942]                 }
[16:04:16.942]                 ...future.workdir <- getwd()
[16:04:16.942]             }
[16:04:16.942]             ...future.oldOptions <- base::as.list(base::.Options)
[16:04:16.942]             ...future.oldEnvVars <- base::Sys.getenv()
[16:04:16.942]         }
[16:04:16.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:04:16.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:04:16.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:04:16.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:04:16.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:04:16.942]             future.stdout.windows.reencode = NULL, width = 80L)
[16:04:16.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:04:16.942]             base::names(...future.oldOptions))
[16:04:16.942]     }
[16:04:16.942]     if (FALSE) {
[16:04:16.942]     }
[16:04:16.942]     else {
[16:04:16.942]         if (TRUE) {
[16:04:16.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:04:16.942]                 open = "w")
[16:04:16.942]         }
[16:04:16.942]         else {
[16:04:16.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:04:16.942]                 windows = "NUL", "/dev/null"), open = "w")
[16:04:16.942]         }
[16:04:16.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:04:16.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:04:16.942]             base::sink(type = "output", split = FALSE)
[16:04:16.942]             base::close(...future.stdout)
[16:04:16.942]         }, add = TRUE)
[16:04:16.942]     }
[16:04:16.942]     ...future.frame <- base::sys.nframe()
[16:04:16.942]     ...future.conditions <- base::list()
[16:04:16.942]     ...future.rng <- base::globalenv()$.Random.seed
[16:04:16.942]     if (FALSE) {
[16:04:16.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:04:16.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:04:16.942]     }
[16:04:16.942]     ...future.result <- base::tryCatch({
[16:04:16.942]         base::withCallingHandlers({
[16:04:16.942]             ...future.value <- base::withVisible(base::local({
[16:04:16.942]                 ...future.makeSendCondition <- base::local({
[16:04:16.942]                   sendCondition <- NULL
[16:04:16.942]                   function(frame = 1L) {
[16:04:16.942]                     if (is.function(sendCondition)) 
[16:04:16.942]                       return(sendCondition)
[16:04:16.942]                     ns <- getNamespace("parallel")
[16:04:16.942]                     if (exists("sendData", mode = "function", 
[16:04:16.942]                       envir = ns)) {
[16:04:16.942]                       parallel_sendData <- get("sendData", mode = "function", 
[16:04:16.942]                         envir = ns)
[16:04:16.942]                       envir <- sys.frame(frame)
[16:04:16.942]                       master <- NULL
[16:04:16.942]                       while (!identical(envir, .GlobalEnv) && 
[16:04:16.942]                         !identical(envir, emptyenv())) {
[16:04:16.942]                         if (exists("master", mode = "list", envir = envir, 
[16:04:16.942]                           inherits = FALSE)) {
[16:04:16.942]                           master <- get("master", mode = "list", 
[16:04:16.942]                             envir = envir, inherits = FALSE)
[16:04:16.942]                           if (inherits(master, c("SOCKnode", 
[16:04:16.942]                             "SOCK0node"))) {
[16:04:16.942]                             sendCondition <<- function(cond) {
[16:04:16.942]                               data <- list(type = "VALUE", value = cond, 
[16:04:16.942]                                 success = TRUE)
[16:04:16.942]                               parallel_sendData(master, data)
[16:04:16.942]                             }
[16:04:16.942]                             return(sendCondition)
[16:04:16.942]                           }
[16:04:16.942]                         }
[16:04:16.942]                         frame <- frame + 1L
[16:04:16.942]                         envir <- sys.frame(frame)
[16:04:16.942]                       }
[16:04:16.942]                     }
[16:04:16.942]                     sendCondition <<- function(cond) NULL
[16:04:16.942]                   }
[16:04:16.942]                 })
[16:04:16.942]                 withCallingHandlers({
[16:04:16.942]                   fcn(x, y)
[16:04:16.942]                 }, immediateCondition = function(cond) {
[16:04:16.942]                   sendCondition <- ...future.makeSendCondition()
[16:04:16.942]                   sendCondition(cond)
[16:04:16.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.942]                   {
[16:04:16.942]                     inherits <- base::inherits
[16:04:16.942]                     invokeRestart <- base::invokeRestart
[16:04:16.942]                     is.null <- base::is.null
[16:04:16.942]                     muffled <- FALSE
[16:04:16.942]                     if (inherits(cond, "message")) {
[16:04:16.942]                       muffled <- grepl(pattern, "muffleMessage")
[16:04:16.942]                       if (muffled) 
[16:04:16.942]                         invokeRestart("muffleMessage")
[16:04:16.942]                     }
[16:04:16.942]                     else if (inherits(cond, "warning")) {
[16:04:16.942]                       muffled <- grepl(pattern, "muffleWarning")
[16:04:16.942]                       if (muffled) 
[16:04:16.942]                         invokeRestart("muffleWarning")
[16:04:16.942]                     }
[16:04:16.942]                     else if (inherits(cond, "condition")) {
[16:04:16.942]                       if (!is.null(pattern)) {
[16:04:16.942]                         computeRestarts <- base::computeRestarts
[16:04:16.942]                         grepl <- base::grepl
[16:04:16.942]                         restarts <- computeRestarts(cond)
[16:04:16.942]                         for (restart in restarts) {
[16:04:16.942]                           name <- restart$name
[16:04:16.942]                           if (is.null(name)) 
[16:04:16.942]                             next
[16:04:16.942]                           if (!grepl(pattern, name)) 
[16:04:16.942]                             next
[16:04:16.942]                           invokeRestart(restart)
[16:04:16.942]                           muffled <- TRUE
[16:04:16.942]                           break
[16:04:16.942]                         }
[16:04:16.942]                       }
[16:04:16.942]                     }
[16:04:16.942]                     invisible(muffled)
[16:04:16.942]                   }
[16:04:16.942]                   muffleCondition(cond)
[16:04:16.942]                 })
[16:04:16.942]             }))
[16:04:16.942]             future::FutureResult(value = ...future.value$value, 
[16:04:16.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.942]                   ...future.rng), globalenv = if (FALSE) 
[16:04:16.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:04:16.942]                     ...future.globalenv.names))
[16:04:16.942]                 else NULL, started = ...future.startTime, version = "1.8")
[16:04:16.942]         }, condition = base::local({
[16:04:16.942]             c <- base::c
[16:04:16.942]             inherits <- base::inherits
[16:04:16.942]             invokeRestart <- base::invokeRestart
[16:04:16.942]             length <- base::length
[16:04:16.942]             list <- base::list
[16:04:16.942]             seq.int <- base::seq.int
[16:04:16.942]             signalCondition <- base::signalCondition
[16:04:16.942]             sys.calls <- base::sys.calls
[16:04:16.942]             `[[` <- base::`[[`
[16:04:16.942]             `+` <- base::`+`
[16:04:16.942]             `<<-` <- base::`<<-`
[16:04:16.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:04:16.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:04:16.942]                   3L)]
[16:04:16.942]             }
[16:04:16.942]             function(cond) {
[16:04:16.942]                 is_error <- inherits(cond, "error")
[16:04:16.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:04:16.942]                   NULL)
[16:04:16.942]                 if (is_error) {
[16:04:16.942]                   sessionInformation <- function() {
[16:04:16.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:04:16.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:04:16.942]                       search = base::search(), system = base::Sys.info())
[16:04:16.942]                   }
[16:04:16.942]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:04:16.942]                     cond$call), session = sessionInformation(), 
[16:04:16.942]                     timestamp = base::Sys.time(), signaled = 0L)
[16:04:16.942]                   signalCondition(cond)
[16:04:16.942]                 }
[16:04:16.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:04:16.942]                 "immediateCondition"))) {
[16:04:16.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:04:16.942]                   ...future.conditions[[length(...future.conditions) + 
[16:04:16.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:04:16.942]                   if (TRUE && !signal) {
[16:04:16.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.942]                     {
[16:04:16.942]                       inherits <- base::inherits
[16:04:16.942]                       invokeRestart <- base::invokeRestart
[16:04:16.942]                       is.null <- base::is.null
[16:04:16.942]                       muffled <- FALSE
[16:04:16.942]                       if (inherits(cond, "message")) {
[16:04:16.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.942]                         if (muffled) 
[16:04:16.942]                           invokeRestart("muffleMessage")
[16:04:16.942]                       }
[16:04:16.942]                       else if (inherits(cond, "warning")) {
[16:04:16.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.942]                         if (muffled) 
[16:04:16.942]                           invokeRestart("muffleWarning")
[16:04:16.942]                       }
[16:04:16.942]                       else if (inherits(cond, "condition")) {
[16:04:16.942]                         if (!is.null(pattern)) {
[16:04:16.942]                           computeRestarts <- base::computeRestarts
[16:04:16.942]                           grepl <- base::grepl
[16:04:16.942]                           restarts <- computeRestarts(cond)
[16:04:16.942]                           for (restart in restarts) {
[16:04:16.942]                             name <- restart$name
[16:04:16.942]                             if (is.null(name)) 
[16:04:16.942]                               next
[16:04:16.942]                             if (!grepl(pattern, name)) 
[16:04:16.942]                               next
[16:04:16.942]                             invokeRestart(restart)
[16:04:16.942]                             muffled <- TRUE
[16:04:16.942]                             break
[16:04:16.942]                           }
[16:04:16.942]                         }
[16:04:16.942]                       }
[16:04:16.942]                       invisible(muffled)
[16:04:16.942]                     }
[16:04:16.942]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.942]                   }
[16:04:16.942]                 }
[16:04:16.942]                 else {
[16:04:16.942]                   if (TRUE) {
[16:04:16.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:04:16.942]                     {
[16:04:16.942]                       inherits <- base::inherits
[16:04:16.942]                       invokeRestart <- base::invokeRestart
[16:04:16.942]                       is.null <- base::is.null
[16:04:16.942]                       muffled <- FALSE
[16:04:16.942]                       if (inherits(cond, "message")) {
[16:04:16.942]                         muffled <- grepl(pattern, "muffleMessage")
[16:04:16.942]                         if (muffled) 
[16:04:16.942]                           invokeRestart("muffleMessage")
[16:04:16.942]                       }
[16:04:16.942]                       else if (inherits(cond, "warning")) {
[16:04:16.942]                         muffled <- grepl(pattern, "muffleWarning")
[16:04:16.942]                         if (muffled) 
[16:04:16.942]                           invokeRestart("muffleWarning")
[16:04:16.942]                       }
[16:04:16.942]                       else if (inherits(cond, "condition")) {
[16:04:16.942]                         if (!is.null(pattern)) {
[16:04:16.942]                           computeRestarts <- base::computeRestarts
[16:04:16.942]                           grepl <- base::grepl
[16:04:16.942]                           restarts <- computeRestarts(cond)
[16:04:16.942]                           for (restart in restarts) {
[16:04:16.942]                             name <- restart$name
[16:04:16.942]                             if (is.null(name)) 
[16:04:16.942]                               next
[16:04:16.942]                             if (!grepl(pattern, name)) 
[16:04:16.942]                               next
[16:04:16.942]                             invokeRestart(restart)
[16:04:16.942]                             muffled <- TRUE
[16:04:16.942]                             break
[16:04:16.942]                           }
[16:04:16.942]                         }
[16:04:16.942]                       }
[16:04:16.942]                       invisible(muffled)
[16:04:16.942]                     }
[16:04:16.942]                     muffleCondition(cond, pattern = "^muffle")
[16:04:16.942]                   }
[16:04:16.942]                 }
[16:04:16.942]             }
[16:04:16.942]         }))
[16:04:16.942]     }, error = function(ex) {
[16:04:16.942]         base::structure(base::list(value = NULL, visible = NULL, 
[16:04:16.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:04:16.942]                 ...future.rng), started = ...future.startTime, 
[16:04:16.942]             finished = Sys.time(), session_uuid = NA_character_, 
[16:04:16.942]             version = "1.8"), class = "FutureResult")
[16:04:16.942]     }, finally = {
[16:04:16.942]         if (!identical(...future.workdir, getwd())) 
[16:04:16.942]             setwd(...future.workdir)
[16:04:16.942]         {
[16:04:16.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:04:16.942]                 ...future.oldOptions$nwarnings <- NULL
[16:04:16.942]             }
[16:04:16.942]             base::options(...future.oldOptions)
[16:04:16.942]             if (.Platform$OS.type == "windows") {
[16:04:16.942]                 old_names <- names(...future.oldEnvVars)
[16:04:16.942]                 envs <- base::Sys.getenv()
[16:04:16.942]                 names <- names(envs)
[16:04:16.942]                 common <- intersect(names, old_names)
[16:04:16.942]                 added <- setdiff(names, old_names)
[16:04:16.942]                 removed <- setdiff(old_names, names)
[16:04:16.942]                 changed <- common[...future.oldEnvVars[common] != 
[16:04:16.942]                   envs[common]]
[16:04:16.942]                 NAMES <- toupper(changed)
[16:04:16.942]                 args <- list()
[16:04:16.942]                 for (kk in seq_along(NAMES)) {
[16:04:16.942]                   name <- changed[[kk]]
[16:04:16.942]                   NAME <- NAMES[[kk]]
[16:04:16.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.942]                     next
[16:04:16.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.942]                 }
[16:04:16.942]                 NAMES <- toupper(added)
[16:04:16.942]                 for (kk in seq_along(NAMES)) {
[16:04:16.942]                   name <- added[[kk]]
[16:04:16.942]                   NAME <- NAMES[[kk]]
[16:04:16.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.942]                     next
[16:04:16.942]                   args[[name]] <- ""
[16:04:16.942]                 }
[16:04:16.942]                 NAMES <- toupper(removed)
[16:04:16.942]                 for (kk in seq_along(NAMES)) {
[16:04:16.942]                   name <- removed[[kk]]
[16:04:16.942]                   NAME <- NAMES[[kk]]
[16:04:16.942]                   if (name != NAME && is.element(NAME, old_names)) 
[16:04:16.942]                     next
[16:04:16.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:04:16.942]                 }
[16:04:16.942]                 if (length(args) > 0) 
[16:04:16.942]                   base::do.call(base::Sys.setenv, args = args)
[16:04:16.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:04:16.942]             }
[16:04:16.942]             else {
[16:04:16.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:04:16.942]             }
[16:04:16.942]             {
[16:04:16.942]                 if (base::length(...future.futureOptionsAdded) > 
[16:04:16.942]                   0L) {
[16:04:16.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:04:16.942]                   base::names(opts) <- ...future.futureOptionsAdded
[16:04:16.942]                   base::options(opts)
[16:04:16.942]                 }
[16:04:16.942]                 {
[16:04:16.942]                   {
[16:04:16.942]                     base::options(mc.cores = ...future.mc.cores.old)
[16:04:16.942]                     NULL
[16:04:16.942]                   }
[16:04:16.942]                   options(future.plan = NULL)
[16:04:16.942]                   if (is.na(NA_character_)) 
[16:04:16.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:04:16.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:04:16.942]                   future::plan(list(function (..., workers = availableCores(), 
[16:04:16.942]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:04:16.942]                     envir = parent.frame()) 
[16:04:16.942]                   {
[16:04:16.942]                     if (is.function(workers)) 
[16:04:16.942]                       workers <- workers()
[16:04:16.942]                     workers <- structure(as.integer(workers), 
[16:04:16.942]                       class = class(workers))
[16:04:16.942]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:04:16.942]                       workers >= 1)
[16:04:16.942]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:04:16.942]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:04:16.942]                     }
[16:04:16.942]                     future <- MultisessionFuture(..., workers = workers, 
[16:04:16.942]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:04:16.942]                       envir = envir)
[16:04:16.942]                     if (!future$lazy) 
[16:04:16.942]                       future <- run(future)
[16:04:16.942]                     invisible(future)
[16:04:16.942]                   }), .cleanup = FALSE, .init = FALSE)
[16:04:16.942]                 }
[16:04:16.942]             }
[16:04:16.942]         }
[16:04:16.942]     })
[16:04:16.942]     if (TRUE) {
[16:04:16.942]         base::sink(type = "output", split = FALSE)
[16:04:16.942]         if (TRUE) {
[16:04:16.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:04:16.942]         }
[16:04:16.942]         else {
[16:04:16.942]             ...future.result["stdout"] <- base::list(NULL)
[16:04:16.942]         }
[16:04:16.942]         base::close(...future.stdout)
[16:04:16.942]         ...future.stdout <- NULL
[16:04:16.942]     }
[16:04:16.942]     ...future.result$conditions <- ...future.conditions
[16:04:16.942]     ...future.result$finished <- base::Sys.time()
[16:04:16.942]     ...future.result
[16:04:16.942] }
[16:04:16.944] Exporting 3 global objects (4.18 KiB) to cluster node #1 ...
[16:04:16.944] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ...
[16:04:16.945] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ... DONE
[16:04:16.945] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[16:04:16.945] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.945] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[16:04:16.945] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[16:04:16.946] Exporting 3 global objects (4.18 KiB) to cluster node #1 ... DONE
[16:04:16.946] MultisessionFuture started
[16:04:16.946] - Launch lazy future ... done
[16:04:16.946] run() for ‘MultisessionFuture’ ... done
[16:04:16.946] result() for ClusterFuture ...
[16:04:16.946] receiveMessageFromWorker() for ClusterFuture ...
[16:04:16.947] - Validating connection of MultisessionFuture
[16:04:16.992] - received message: FutureResult
[16:04:16.992] - Received FutureResult
[16:04:16.992] - Erased future from FutureRegistry
[16:04:16.992] result() for ClusterFuture ...
[16:04:16.992] - result already collected: FutureResult
[16:04:16.992] result() for ClusterFuture ... done
[16:04:16.992] receiveMessageFromWorker() for ClusterFuture ... done
[16:04:16.992] result() for ClusterFuture ... done
[16:04:16.992] result() for ClusterFuture ...
[16:04:16.993] - result already collected: FutureResult
[16:04:16.993] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[16:04:16.993] plan(): Setting new future strategy stack:
[16:04:16.994] List of future strategies:
[16:04:16.994] 1. FutureStrategy:
[16:04:16.994]    - args: function (..., envir = parent.frame())
[16:04:16.994]    - tweaked: FALSE
[16:04:16.994]    - call: future::plan(oplan)
[16:04:16.994] plan(): nbrOfWorkers() = 1
> 
