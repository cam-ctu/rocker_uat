
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:25:20.311] plan(): Setting new future strategy stack:
[10:25:20.311] List of future strategies:
[10:25:20.311] 1. sequential:
[10:25:20.311]    - args: function (..., envir = parent.frame())
[10:25:20.311]    - tweaked: FALSE
[10:25:20.311]    - call: future::plan("sequential")
[10:25:20.325] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[10:25:20.371] plan(): Setting new future strategy stack:
[10:25:20.371] List of future strategies:
[10:25:20.371] 1. sequential:
[10:25:20.371]    - args: function (..., envir = parent.frame())
[10:25:20.371]    - tweaked: FALSE
[10:25:20.371]    - call: plan(strategy, substitute = FALSE)
[10:25:20.381] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x558a91ddaab8>
Arguments '...' exists: TRUE
[10:25:20.383] getGlobalsAndPackages() ...
[10:25:20.383] Searching for globals...
[10:25:20.392] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:20.392] Searching for globals ... DONE
[10:25:20.392] Resolving globals: FALSE
[10:25:20.392] Tweak future expression to call with '...' arguments ...
[10:25:20.392] {
[10:25:20.392]     do.call(function(...) {
[10:25:20.392]         sum(x, ...)
[10:25:20.392]     }, args = future.call.arguments)
[10:25:20.392] }
[10:25:20.392] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.394] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.394] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:20.394] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:20.394] 
[10:25:20.394] getGlobalsAndPackages() ... DONE
[10:25:20.395] run() for ‘Future’ ...
[10:25:20.395] - state: ‘created’
[10:25:20.396] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.396] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.396]   - Field: ‘label’
[10:25:20.396]   - Field: ‘local’
[10:25:20.396]   - Field: ‘owner’
[10:25:20.396]   - Field: ‘envir’
[10:25:20.396]   - Field: ‘packages’
[10:25:20.397]   - Field: ‘gc’
[10:25:20.397]   - Field: ‘conditions’
[10:25:20.397]   - Field: ‘expr’
[10:25:20.397]   - Field: ‘uuid’
[10:25:20.397]   - Field: ‘seed’
[10:25:20.397]   - Field: ‘version’
[10:25:20.397]   - Field: ‘result’
[10:25:20.397]   - Field: ‘asynchronous’
[10:25:20.397]   - Field: ‘calls’
[10:25:20.397]   - Field: ‘globals’
[10:25:20.397]   - Field: ‘stdout’
[10:25:20.398]   - Field: ‘earlySignal’
[10:25:20.398]   - Field: ‘lazy’
[10:25:20.398]   - Field: ‘state’
[10:25:20.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.398] - Launch lazy future ...
[10:25:20.399] Packages needed by the future expression (n = 0): <none>
[10:25:20.399] Packages needed by future strategies (n = 0): <none>
[10:25:20.400] {
[10:25:20.400]     {
[10:25:20.400]         {
[10:25:20.400]             ...future.startTime <- base::Sys.time()
[10:25:20.400]             {
[10:25:20.400]                 {
[10:25:20.400]                   {
[10:25:20.400]                     base::local({
[10:25:20.400]                       has_future <- base::requireNamespace("future", 
[10:25:20.400]                         quietly = TRUE)
[10:25:20.400]                       if (has_future) {
[10:25:20.400]                         ns <- base::getNamespace("future")
[10:25:20.400]                         version <- ns[[".package"]][["version"]]
[10:25:20.400]                         if (is.null(version)) 
[10:25:20.400]                           version <- utils::packageVersion("future")
[10:25:20.400]                       }
[10:25:20.400]                       else {
[10:25:20.400]                         version <- NULL
[10:25:20.400]                       }
[10:25:20.400]                       if (!has_future || version < "1.8.0") {
[10:25:20.400]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.400]                           "", base::R.version$version.string), 
[10:25:20.400]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.400]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.400]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.400]                             "release", "version")], collapse = " "), 
[10:25:20.400]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.400]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.400]                           info)
[10:25:20.400]                         info <- base::paste(info, collapse = "; ")
[10:25:20.400]                         if (!has_future) {
[10:25:20.400]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.400]                             info)
[10:25:20.400]                         }
[10:25:20.400]                         else {
[10:25:20.400]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.400]                             info, version)
[10:25:20.400]                         }
[10:25:20.400]                         base::stop(msg)
[10:25:20.400]                       }
[10:25:20.400]                     })
[10:25:20.400]                   }
[10:25:20.400]                   options(future.plan = NULL)
[10:25:20.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.400]                 }
[10:25:20.400]                 ...future.workdir <- getwd()
[10:25:20.400]             }
[10:25:20.400]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.400]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.400]         }
[10:25:20.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.400]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.400]             base::names(...future.oldOptions))
[10:25:20.400]     }
[10:25:20.400]     if (FALSE) {
[10:25:20.400]     }
[10:25:20.400]     else {
[10:25:20.400]         if (TRUE) {
[10:25:20.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.400]                 open = "w")
[10:25:20.400]         }
[10:25:20.400]         else {
[10:25:20.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.400]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.400]         }
[10:25:20.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.400]             base::sink(type = "output", split = FALSE)
[10:25:20.400]             base::close(...future.stdout)
[10:25:20.400]         }, add = TRUE)
[10:25:20.400]     }
[10:25:20.400]     ...future.frame <- base::sys.nframe()
[10:25:20.400]     ...future.conditions <- base::list()
[10:25:20.400]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.400]     if (FALSE) {
[10:25:20.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.400]     }
[10:25:20.400]     ...future.result <- base::tryCatch({
[10:25:20.400]         base::withCallingHandlers({
[10:25:20.400]             ...future.value <- base::withVisible(base::local({
[10:25:20.400]                 do.call(function(...) {
[10:25:20.400]                   sum(x, ...)
[10:25:20.400]                 }, args = future.call.arguments)
[10:25:20.400]             }))
[10:25:20.400]             future::FutureResult(value = ...future.value$value, 
[10:25:20.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.400]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.400]                     ...future.globalenv.names))
[10:25:20.400]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.400]         }, condition = base::local({
[10:25:20.400]             c <- base::c
[10:25:20.400]             inherits <- base::inherits
[10:25:20.400]             invokeRestart <- base::invokeRestart
[10:25:20.400]             length <- base::length
[10:25:20.400]             list <- base::list
[10:25:20.400]             seq.int <- base::seq.int
[10:25:20.400]             signalCondition <- base::signalCondition
[10:25:20.400]             sys.calls <- base::sys.calls
[10:25:20.400]             `[[` <- base::`[[`
[10:25:20.400]             `+` <- base::`+`
[10:25:20.400]             `<<-` <- base::`<<-`
[10:25:20.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.400]                   3L)]
[10:25:20.400]             }
[10:25:20.400]             function(cond) {
[10:25:20.400]                 is_error <- inherits(cond, "error")
[10:25:20.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.400]                   NULL)
[10:25:20.400]                 if (is_error) {
[10:25:20.400]                   sessionInformation <- function() {
[10:25:20.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.400]                       search = base::search(), system = base::Sys.info())
[10:25:20.400]                   }
[10:25:20.400]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.400]                     cond$call), session = sessionInformation(), 
[10:25:20.400]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.400]                   signalCondition(cond)
[10:25:20.400]                 }
[10:25:20.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.400]                 "immediateCondition"))) {
[10:25:20.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.400]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.400]                   if (TRUE && !signal) {
[10:25:20.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.400]                     {
[10:25:20.400]                       inherits <- base::inherits
[10:25:20.400]                       invokeRestart <- base::invokeRestart
[10:25:20.400]                       is.null <- base::is.null
[10:25:20.400]                       muffled <- FALSE
[10:25:20.400]                       if (inherits(cond, "message")) {
[10:25:20.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.400]                         if (muffled) 
[10:25:20.400]                           invokeRestart("muffleMessage")
[10:25:20.400]                       }
[10:25:20.400]                       else if (inherits(cond, "warning")) {
[10:25:20.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.400]                         if (muffled) 
[10:25:20.400]                           invokeRestart("muffleWarning")
[10:25:20.400]                       }
[10:25:20.400]                       else if (inherits(cond, "condition")) {
[10:25:20.400]                         if (!is.null(pattern)) {
[10:25:20.400]                           computeRestarts <- base::computeRestarts
[10:25:20.400]                           grepl <- base::grepl
[10:25:20.400]                           restarts <- computeRestarts(cond)
[10:25:20.400]                           for (restart in restarts) {
[10:25:20.400]                             name <- restart$name
[10:25:20.400]                             if (is.null(name)) 
[10:25:20.400]                               next
[10:25:20.400]                             if (!grepl(pattern, name)) 
[10:25:20.400]                               next
[10:25:20.400]                             invokeRestart(restart)
[10:25:20.400]                             muffled <- TRUE
[10:25:20.400]                             break
[10:25:20.400]                           }
[10:25:20.400]                         }
[10:25:20.400]                       }
[10:25:20.400]                       invisible(muffled)
[10:25:20.400]                     }
[10:25:20.400]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.400]                   }
[10:25:20.400]                 }
[10:25:20.400]                 else {
[10:25:20.400]                   if (TRUE) {
[10:25:20.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.400]                     {
[10:25:20.400]                       inherits <- base::inherits
[10:25:20.400]                       invokeRestart <- base::invokeRestart
[10:25:20.400]                       is.null <- base::is.null
[10:25:20.400]                       muffled <- FALSE
[10:25:20.400]                       if (inherits(cond, "message")) {
[10:25:20.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.400]                         if (muffled) 
[10:25:20.400]                           invokeRestart("muffleMessage")
[10:25:20.400]                       }
[10:25:20.400]                       else if (inherits(cond, "warning")) {
[10:25:20.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.400]                         if (muffled) 
[10:25:20.400]                           invokeRestart("muffleWarning")
[10:25:20.400]                       }
[10:25:20.400]                       else if (inherits(cond, "condition")) {
[10:25:20.400]                         if (!is.null(pattern)) {
[10:25:20.400]                           computeRestarts <- base::computeRestarts
[10:25:20.400]                           grepl <- base::grepl
[10:25:20.400]                           restarts <- computeRestarts(cond)
[10:25:20.400]                           for (restart in restarts) {
[10:25:20.400]                             name <- restart$name
[10:25:20.400]                             if (is.null(name)) 
[10:25:20.400]                               next
[10:25:20.400]                             if (!grepl(pattern, name)) 
[10:25:20.400]                               next
[10:25:20.400]                             invokeRestart(restart)
[10:25:20.400]                             muffled <- TRUE
[10:25:20.400]                             break
[10:25:20.400]                           }
[10:25:20.400]                         }
[10:25:20.400]                       }
[10:25:20.400]                       invisible(muffled)
[10:25:20.400]                     }
[10:25:20.400]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.400]                   }
[10:25:20.400]                 }
[10:25:20.400]             }
[10:25:20.400]         }))
[10:25:20.400]     }, error = function(ex) {
[10:25:20.400]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.400]                 ...future.rng), started = ...future.startTime, 
[10:25:20.400]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.400]             version = "1.8"), class = "FutureResult")
[10:25:20.400]     }, finally = {
[10:25:20.400]         if (!identical(...future.workdir, getwd())) 
[10:25:20.400]             setwd(...future.workdir)
[10:25:20.400]         {
[10:25:20.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.400]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.400]             }
[10:25:20.400]             base::options(...future.oldOptions)
[10:25:20.400]             if (.Platform$OS.type == "windows") {
[10:25:20.400]                 old_names <- names(...future.oldEnvVars)
[10:25:20.400]                 envs <- base::Sys.getenv()
[10:25:20.400]                 names <- names(envs)
[10:25:20.400]                 common <- intersect(names, old_names)
[10:25:20.400]                 added <- setdiff(names, old_names)
[10:25:20.400]                 removed <- setdiff(old_names, names)
[10:25:20.400]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.400]                   envs[common]]
[10:25:20.400]                 NAMES <- toupper(changed)
[10:25:20.400]                 args <- list()
[10:25:20.400]                 for (kk in seq_along(NAMES)) {
[10:25:20.400]                   name <- changed[[kk]]
[10:25:20.400]                   NAME <- NAMES[[kk]]
[10:25:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.400]                     next
[10:25:20.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.400]                 }
[10:25:20.400]                 NAMES <- toupper(added)
[10:25:20.400]                 for (kk in seq_along(NAMES)) {
[10:25:20.400]                   name <- added[[kk]]
[10:25:20.400]                   NAME <- NAMES[[kk]]
[10:25:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.400]                     next
[10:25:20.400]                   args[[name]] <- ""
[10:25:20.400]                 }
[10:25:20.400]                 NAMES <- toupper(removed)
[10:25:20.400]                 for (kk in seq_along(NAMES)) {
[10:25:20.400]                   name <- removed[[kk]]
[10:25:20.400]                   NAME <- NAMES[[kk]]
[10:25:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.400]                     next
[10:25:20.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.400]                 }
[10:25:20.400]                 if (length(args) > 0) 
[10:25:20.400]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.400]             }
[10:25:20.400]             else {
[10:25:20.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.400]             }
[10:25:20.400]             {
[10:25:20.400]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.400]                   0L) {
[10:25:20.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.400]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.400]                   base::options(opts)
[10:25:20.400]                 }
[10:25:20.400]                 {
[10:25:20.400]                   {
[10:25:20.400]                     NULL
[10:25:20.400]                     RNGkind("Mersenne-Twister")
[10:25:20.400]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.400]                       inherits = FALSE)
[10:25:20.400]                   }
[10:25:20.400]                   options(future.plan = NULL)
[10:25:20.400]                   if (is.na(NA_character_)) 
[10:25:20.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.400]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.400]                   {
[10:25:20.400]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.400]                     if (!future$lazy) 
[10:25:20.400]                       future <- run(future)
[10:25:20.400]                     invisible(future)
[10:25:20.400]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.400]                 }
[10:25:20.400]             }
[10:25:20.400]         }
[10:25:20.400]     })
[10:25:20.400]     if (TRUE) {
[10:25:20.400]         base::sink(type = "output", split = FALSE)
[10:25:20.400]         if (TRUE) {
[10:25:20.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.400]         }
[10:25:20.400]         else {
[10:25:20.400]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.400]         }
[10:25:20.400]         base::close(...future.stdout)
[10:25:20.400]         ...future.stdout <- NULL
[10:25:20.400]     }
[10:25:20.400]     ...future.result$conditions <- ...future.conditions
[10:25:20.400]     ...future.result$finished <- base::Sys.time()
[10:25:20.400]     ...future.result
[10:25:20.400] }
[10:25:20.401] assign_globals() ...
[10:25:20.401] List of 2
[10:25:20.401]  $ x                    : int [1:2] 1 2
[10:25:20.401]  $ future.call.arguments:List of 1
[10:25:20.401]   ..$ : num 3
[10:25:20.401]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.401]  - attr(*, "where")=List of 2
[10:25:20.401]   ..$ x                    :<environment: R_EmptyEnv> 
[10:25:20.401]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.401]  - attr(*, "resolved")= logi FALSE
[10:25:20.401]  - attr(*, "total_size")= num 112
[10:25:20.401]  - attr(*, "already-done")= logi TRUE
[10:25:20.407] - copied ‘x’ to environment
[10:25:20.407] - copied ‘future.call.arguments’ to environment
[10:25:20.407] assign_globals() ... done
[10:25:20.408] plan(): Setting new future strategy stack:
[10:25:20.408] List of future strategies:
[10:25:20.408] 1. sequential:
[10:25:20.408]    - args: function (..., envir = parent.frame())
[10:25:20.408]    - tweaked: FALSE
[10:25:20.408]    - call: NULL
[10:25:20.408] plan(): nbrOfWorkers() = 1
[10:25:20.409] plan(): Setting new future strategy stack:
[10:25:20.409] List of future strategies:
[10:25:20.409] 1. sequential:
[10:25:20.409]    - args: function (..., envir = parent.frame())
[10:25:20.409]    - tweaked: FALSE
[10:25:20.409]    - call: plan(strategy, substitute = FALSE)
[10:25:20.410] plan(): nbrOfWorkers() = 1
[10:25:20.410] SequentialFuture started (and completed)
[10:25:20.410] - Launch lazy future ... done
[10:25:20.410] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x558a92094f00>
Arguments '...' exists: TRUE
[10:25:20.411] getGlobalsAndPackages() ...
[10:25:20.411] Searching for globals...
[10:25:20.413] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:20.413] Searching for globals ... DONE
[10:25:20.413] Resolving globals: FALSE
[10:25:20.413] Tweak future expression to call with '...' arguments ...
[10:25:20.413] {
[10:25:20.413]     do.call(function(...) {
[10:25:20.413]         sum(x, ...)
[10:25:20.413]     }, args = future.call.arguments)
[10:25:20.413] }
[10:25:20.413] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.414] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.414] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:20.414] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:20.414] 
[10:25:20.414] getGlobalsAndPackages() ... DONE
[10:25:20.415] run() for ‘Future’ ...
[10:25:20.415] - state: ‘created’
[10:25:20.415] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.415] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.415]   - Field: ‘label’
[10:25:20.415]   - Field: ‘local’
[10:25:20.415]   - Field: ‘owner’
[10:25:20.416]   - Field: ‘envir’
[10:25:20.416]   - Field: ‘packages’
[10:25:20.416]   - Field: ‘gc’
[10:25:20.416]   - Field: ‘conditions’
[10:25:20.416]   - Field: ‘expr’
[10:25:20.416]   - Field: ‘uuid’
[10:25:20.416]   - Field: ‘seed’
[10:25:20.416]   - Field: ‘version’
[10:25:20.416]   - Field: ‘result’
[10:25:20.416]   - Field: ‘asynchronous’
[10:25:20.416]   - Field: ‘calls’
[10:25:20.417]   - Field: ‘globals’
[10:25:20.417]   - Field: ‘stdout’
[10:25:20.417]   - Field: ‘earlySignal’
[10:25:20.417]   - Field: ‘lazy’
[10:25:20.417]   - Field: ‘state’
[10:25:20.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.417] - Launch lazy future ...
[10:25:20.417] Packages needed by the future expression (n = 0): <none>
[10:25:20.417] Packages needed by future strategies (n = 0): <none>
[10:25:20.418] {
[10:25:20.418]     {
[10:25:20.418]         {
[10:25:20.418]             ...future.startTime <- base::Sys.time()
[10:25:20.418]             {
[10:25:20.418]                 {
[10:25:20.418]                   {
[10:25:20.418]                     base::local({
[10:25:20.418]                       has_future <- base::requireNamespace("future", 
[10:25:20.418]                         quietly = TRUE)
[10:25:20.418]                       if (has_future) {
[10:25:20.418]                         ns <- base::getNamespace("future")
[10:25:20.418]                         version <- ns[[".package"]][["version"]]
[10:25:20.418]                         if (is.null(version)) 
[10:25:20.418]                           version <- utils::packageVersion("future")
[10:25:20.418]                       }
[10:25:20.418]                       else {
[10:25:20.418]                         version <- NULL
[10:25:20.418]                       }
[10:25:20.418]                       if (!has_future || version < "1.8.0") {
[10:25:20.418]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.418]                           "", base::R.version$version.string), 
[10:25:20.418]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.418]                             "release", "version")], collapse = " "), 
[10:25:20.418]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.418]                           info)
[10:25:20.418]                         info <- base::paste(info, collapse = "; ")
[10:25:20.418]                         if (!has_future) {
[10:25:20.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.418]                             info)
[10:25:20.418]                         }
[10:25:20.418]                         else {
[10:25:20.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.418]                             info, version)
[10:25:20.418]                         }
[10:25:20.418]                         base::stop(msg)
[10:25:20.418]                       }
[10:25:20.418]                     })
[10:25:20.418]                   }
[10:25:20.418]                   options(future.plan = NULL)
[10:25:20.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.418]                 }
[10:25:20.418]                 ...future.workdir <- getwd()
[10:25:20.418]             }
[10:25:20.418]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.418]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.418]         }
[10:25:20.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.418]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.418]             base::names(...future.oldOptions))
[10:25:20.418]     }
[10:25:20.418]     if (FALSE) {
[10:25:20.418]     }
[10:25:20.418]     else {
[10:25:20.418]         if (TRUE) {
[10:25:20.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.418]                 open = "w")
[10:25:20.418]         }
[10:25:20.418]         else {
[10:25:20.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.418]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.418]         }
[10:25:20.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.418]             base::sink(type = "output", split = FALSE)
[10:25:20.418]             base::close(...future.stdout)
[10:25:20.418]         }, add = TRUE)
[10:25:20.418]     }
[10:25:20.418]     ...future.frame <- base::sys.nframe()
[10:25:20.418]     ...future.conditions <- base::list()
[10:25:20.418]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.418]     if (FALSE) {
[10:25:20.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.418]     }
[10:25:20.418]     ...future.result <- base::tryCatch({
[10:25:20.418]         base::withCallingHandlers({
[10:25:20.418]             ...future.value <- base::withVisible(base::local({
[10:25:20.418]                 do.call(function(...) {
[10:25:20.418]                   sum(x, ...)
[10:25:20.418]                 }, args = future.call.arguments)
[10:25:20.418]             }))
[10:25:20.418]             future::FutureResult(value = ...future.value$value, 
[10:25:20.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.418]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.418]                     ...future.globalenv.names))
[10:25:20.418]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.418]         }, condition = base::local({
[10:25:20.418]             c <- base::c
[10:25:20.418]             inherits <- base::inherits
[10:25:20.418]             invokeRestart <- base::invokeRestart
[10:25:20.418]             length <- base::length
[10:25:20.418]             list <- base::list
[10:25:20.418]             seq.int <- base::seq.int
[10:25:20.418]             signalCondition <- base::signalCondition
[10:25:20.418]             sys.calls <- base::sys.calls
[10:25:20.418]             `[[` <- base::`[[`
[10:25:20.418]             `+` <- base::`+`
[10:25:20.418]             `<<-` <- base::`<<-`
[10:25:20.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.418]                   3L)]
[10:25:20.418]             }
[10:25:20.418]             function(cond) {
[10:25:20.418]                 is_error <- inherits(cond, "error")
[10:25:20.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.418]                   NULL)
[10:25:20.418]                 if (is_error) {
[10:25:20.418]                   sessionInformation <- function() {
[10:25:20.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.418]                       search = base::search(), system = base::Sys.info())
[10:25:20.418]                   }
[10:25:20.418]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.418]                     cond$call), session = sessionInformation(), 
[10:25:20.418]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.418]                   signalCondition(cond)
[10:25:20.418]                 }
[10:25:20.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.418]                 "immediateCondition"))) {
[10:25:20.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.418]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.418]                   if (TRUE && !signal) {
[10:25:20.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.418]                     {
[10:25:20.418]                       inherits <- base::inherits
[10:25:20.418]                       invokeRestart <- base::invokeRestart
[10:25:20.418]                       is.null <- base::is.null
[10:25:20.418]                       muffled <- FALSE
[10:25:20.418]                       if (inherits(cond, "message")) {
[10:25:20.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.418]                         if (muffled) 
[10:25:20.418]                           invokeRestart("muffleMessage")
[10:25:20.418]                       }
[10:25:20.418]                       else if (inherits(cond, "warning")) {
[10:25:20.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.418]                         if (muffled) 
[10:25:20.418]                           invokeRestart("muffleWarning")
[10:25:20.418]                       }
[10:25:20.418]                       else if (inherits(cond, "condition")) {
[10:25:20.418]                         if (!is.null(pattern)) {
[10:25:20.418]                           computeRestarts <- base::computeRestarts
[10:25:20.418]                           grepl <- base::grepl
[10:25:20.418]                           restarts <- computeRestarts(cond)
[10:25:20.418]                           for (restart in restarts) {
[10:25:20.418]                             name <- restart$name
[10:25:20.418]                             if (is.null(name)) 
[10:25:20.418]                               next
[10:25:20.418]                             if (!grepl(pattern, name)) 
[10:25:20.418]                               next
[10:25:20.418]                             invokeRestart(restart)
[10:25:20.418]                             muffled <- TRUE
[10:25:20.418]                             break
[10:25:20.418]                           }
[10:25:20.418]                         }
[10:25:20.418]                       }
[10:25:20.418]                       invisible(muffled)
[10:25:20.418]                     }
[10:25:20.418]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.418]                   }
[10:25:20.418]                 }
[10:25:20.418]                 else {
[10:25:20.418]                   if (TRUE) {
[10:25:20.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.418]                     {
[10:25:20.418]                       inherits <- base::inherits
[10:25:20.418]                       invokeRestart <- base::invokeRestart
[10:25:20.418]                       is.null <- base::is.null
[10:25:20.418]                       muffled <- FALSE
[10:25:20.418]                       if (inherits(cond, "message")) {
[10:25:20.418]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.418]                         if (muffled) 
[10:25:20.418]                           invokeRestart("muffleMessage")
[10:25:20.418]                       }
[10:25:20.418]                       else if (inherits(cond, "warning")) {
[10:25:20.418]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.418]                         if (muffled) 
[10:25:20.418]                           invokeRestart("muffleWarning")
[10:25:20.418]                       }
[10:25:20.418]                       else if (inherits(cond, "condition")) {
[10:25:20.418]                         if (!is.null(pattern)) {
[10:25:20.418]                           computeRestarts <- base::computeRestarts
[10:25:20.418]                           grepl <- base::grepl
[10:25:20.418]                           restarts <- computeRestarts(cond)
[10:25:20.418]                           for (restart in restarts) {
[10:25:20.418]                             name <- restart$name
[10:25:20.418]                             if (is.null(name)) 
[10:25:20.418]                               next
[10:25:20.418]                             if (!grepl(pattern, name)) 
[10:25:20.418]                               next
[10:25:20.418]                             invokeRestart(restart)
[10:25:20.418]                             muffled <- TRUE
[10:25:20.418]                             break
[10:25:20.418]                           }
[10:25:20.418]                         }
[10:25:20.418]                       }
[10:25:20.418]                       invisible(muffled)
[10:25:20.418]                     }
[10:25:20.418]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.418]                   }
[10:25:20.418]                 }
[10:25:20.418]             }
[10:25:20.418]         }))
[10:25:20.418]     }, error = function(ex) {
[10:25:20.418]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.418]                 ...future.rng), started = ...future.startTime, 
[10:25:20.418]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.418]             version = "1.8"), class = "FutureResult")
[10:25:20.418]     }, finally = {
[10:25:20.418]         if (!identical(...future.workdir, getwd())) 
[10:25:20.418]             setwd(...future.workdir)
[10:25:20.418]         {
[10:25:20.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.418]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.418]             }
[10:25:20.418]             base::options(...future.oldOptions)
[10:25:20.418]             if (.Platform$OS.type == "windows") {
[10:25:20.418]                 old_names <- names(...future.oldEnvVars)
[10:25:20.418]                 envs <- base::Sys.getenv()
[10:25:20.418]                 names <- names(envs)
[10:25:20.418]                 common <- intersect(names, old_names)
[10:25:20.418]                 added <- setdiff(names, old_names)
[10:25:20.418]                 removed <- setdiff(old_names, names)
[10:25:20.418]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.418]                   envs[common]]
[10:25:20.418]                 NAMES <- toupper(changed)
[10:25:20.418]                 args <- list()
[10:25:20.418]                 for (kk in seq_along(NAMES)) {
[10:25:20.418]                   name <- changed[[kk]]
[10:25:20.418]                   NAME <- NAMES[[kk]]
[10:25:20.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.418]                     next
[10:25:20.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.418]                 }
[10:25:20.418]                 NAMES <- toupper(added)
[10:25:20.418]                 for (kk in seq_along(NAMES)) {
[10:25:20.418]                   name <- added[[kk]]
[10:25:20.418]                   NAME <- NAMES[[kk]]
[10:25:20.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.418]                     next
[10:25:20.418]                   args[[name]] <- ""
[10:25:20.418]                 }
[10:25:20.418]                 NAMES <- toupper(removed)
[10:25:20.418]                 for (kk in seq_along(NAMES)) {
[10:25:20.418]                   name <- removed[[kk]]
[10:25:20.418]                   NAME <- NAMES[[kk]]
[10:25:20.418]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.418]                     next
[10:25:20.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.418]                 }
[10:25:20.418]                 if (length(args) > 0) 
[10:25:20.418]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.418]             }
[10:25:20.418]             else {
[10:25:20.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.418]             }
[10:25:20.418]             {
[10:25:20.418]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.418]                   0L) {
[10:25:20.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.418]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.418]                   base::options(opts)
[10:25:20.418]                 }
[10:25:20.418]                 {
[10:25:20.418]                   {
[10:25:20.418]                     NULL
[10:25:20.418]                     RNGkind("Mersenne-Twister")
[10:25:20.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.418]                       inherits = FALSE)
[10:25:20.418]                   }
[10:25:20.418]                   options(future.plan = NULL)
[10:25:20.418]                   if (is.na(NA_character_)) 
[10:25:20.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.418]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.418]                   {
[10:25:20.418]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.418]                     if (!future$lazy) 
[10:25:20.418]                       future <- run(future)
[10:25:20.418]                     invisible(future)
[10:25:20.418]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.418]                 }
[10:25:20.418]             }
[10:25:20.418]         }
[10:25:20.418]     })
[10:25:20.418]     if (TRUE) {
[10:25:20.418]         base::sink(type = "output", split = FALSE)
[10:25:20.418]         if (TRUE) {
[10:25:20.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.418]         }
[10:25:20.418]         else {
[10:25:20.418]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.418]         }
[10:25:20.418]         base::close(...future.stdout)
[10:25:20.418]         ...future.stdout <- NULL
[10:25:20.418]     }
[10:25:20.418]     ...future.result$conditions <- ...future.conditions
[10:25:20.418]     ...future.result$finished <- base::Sys.time()
[10:25:20.418]     ...future.result
[10:25:20.418] }
[10:25:20.419] assign_globals() ...
[10:25:20.419] List of 2
[10:25:20.419]  $ x                    : int [1:2] 1 2
[10:25:20.419]  $ future.call.arguments:List of 1
[10:25:20.419]   ..$ : num 3
[10:25:20.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.419]  - attr(*, "where")=List of 2
[10:25:20.419]   ..$ x                    :<environment: R_EmptyEnv> 
[10:25:20.419]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.419]  - attr(*, "resolved")= logi FALSE
[10:25:20.419]  - attr(*, "total_size")= num 112
[10:25:20.419]  - attr(*, "already-done")= logi TRUE
[10:25:20.425] - copied ‘x’ to environment
[10:25:20.425] - copied ‘future.call.arguments’ to environment
[10:25:20.425] assign_globals() ... done
[10:25:20.425] plan(): Setting new future strategy stack:
[10:25:20.425] List of future strategies:
[10:25:20.425] 1. sequential:
[10:25:20.425]    - args: function (..., envir = parent.frame())
[10:25:20.425]    - tweaked: FALSE
[10:25:20.425]    - call: NULL
[10:25:20.426] plan(): nbrOfWorkers() = 1
[10:25:20.426] plan(): Setting new future strategy stack:
[10:25:20.426] List of future strategies:
[10:25:20.426] 1. sequential:
[10:25:20.426]    - args: function (..., envir = parent.frame())
[10:25:20.426]    - tweaked: FALSE
[10:25:20.426]    - call: plan(strategy, substitute = FALSE)
[10:25:20.427] plan(): nbrOfWorkers() = 1
[10:25:20.427] SequentialFuture started (and completed)
[10:25:20.427] - Launch lazy future ... done
[10:25:20.427] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x558a921f5f00>
Arguments '...' exists: FALSE
[10:25:20.428] getGlobalsAndPackages() ...
[10:25:20.428] Searching for globals...
[10:25:20.429] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[10:25:20.429] Searching for globals ... DONE
[10:25:20.429] Resolving globals: FALSE
[10:25:20.429] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.430] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.430] - globals: [2] ‘x’, ‘y’
[10:25:20.430] 
[10:25:20.430] getGlobalsAndPackages() ... DONE
[10:25:20.430] run() for ‘Future’ ...
[10:25:20.430] - state: ‘created’
[10:25:20.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.431]   - Field: ‘label’
[10:25:20.431]   - Field: ‘local’
[10:25:20.431]   - Field: ‘owner’
[10:25:20.431]   - Field: ‘envir’
[10:25:20.431]   - Field: ‘packages’
[10:25:20.431]   - Field: ‘gc’
[10:25:20.431]   - Field: ‘conditions’
[10:25:20.431]   - Field: ‘expr’
[10:25:20.432]   - Field: ‘uuid’
[10:25:20.432]   - Field: ‘seed’
[10:25:20.432]   - Field: ‘version’
[10:25:20.432]   - Field: ‘result’
[10:25:20.432]   - Field: ‘asynchronous’
[10:25:20.432]   - Field: ‘calls’
[10:25:20.432]   - Field: ‘globals’
[10:25:20.432]   - Field: ‘stdout’
[10:25:20.432]   - Field: ‘earlySignal’
[10:25:20.432]   - Field: ‘lazy’
[10:25:20.432]   - Field: ‘state’
[10:25:20.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.433] - Launch lazy future ...
[10:25:20.433] Packages needed by the future expression (n = 0): <none>
[10:25:20.433] Packages needed by future strategies (n = 0): <none>
[10:25:20.433] {
[10:25:20.433]     {
[10:25:20.433]         {
[10:25:20.433]             ...future.startTime <- base::Sys.time()
[10:25:20.433]             {
[10:25:20.433]                 {
[10:25:20.433]                   {
[10:25:20.433]                     base::local({
[10:25:20.433]                       has_future <- base::requireNamespace("future", 
[10:25:20.433]                         quietly = TRUE)
[10:25:20.433]                       if (has_future) {
[10:25:20.433]                         ns <- base::getNamespace("future")
[10:25:20.433]                         version <- ns[[".package"]][["version"]]
[10:25:20.433]                         if (is.null(version)) 
[10:25:20.433]                           version <- utils::packageVersion("future")
[10:25:20.433]                       }
[10:25:20.433]                       else {
[10:25:20.433]                         version <- NULL
[10:25:20.433]                       }
[10:25:20.433]                       if (!has_future || version < "1.8.0") {
[10:25:20.433]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.433]                           "", base::R.version$version.string), 
[10:25:20.433]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.433]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.433]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.433]                             "release", "version")], collapse = " "), 
[10:25:20.433]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.433]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.433]                           info)
[10:25:20.433]                         info <- base::paste(info, collapse = "; ")
[10:25:20.433]                         if (!has_future) {
[10:25:20.433]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.433]                             info)
[10:25:20.433]                         }
[10:25:20.433]                         else {
[10:25:20.433]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.433]                             info, version)
[10:25:20.433]                         }
[10:25:20.433]                         base::stop(msg)
[10:25:20.433]                       }
[10:25:20.433]                     })
[10:25:20.433]                   }
[10:25:20.433]                   options(future.plan = NULL)
[10:25:20.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.433]                 }
[10:25:20.433]                 ...future.workdir <- getwd()
[10:25:20.433]             }
[10:25:20.433]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.433]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.433]         }
[10:25:20.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.433]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.433]             base::names(...future.oldOptions))
[10:25:20.433]     }
[10:25:20.433]     if (FALSE) {
[10:25:20.433]     }
[10:25:20.433]     else {
[10:25:20.433]         if (TRUE) {
[10:25:20.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.433]                 open = "w")
[10:25:20.433]         }
[10:25:20.433]         else {
[10:25:20.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.433]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.433]         }
[10:25:20.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.433]             base::sink(type = "output", split = FALSE)
[10:25:20.433]             base::close(...future.stdout)
[10:25:20.433]         }, add = TRUE)
[10:25:20.433]     }
[10:25:20.433]     ...future.frame <- base::sys.nframe()
[10:25:20.433]     ...future.conditions <- base::list()
[10:25:20.433]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.433]     if (FALSE) {
[10:25:20.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.433]     }
[10:25:20.433]     ...future.result <- base::tryCatch({
[10:25:20.433]         base::withCallingHandlers({
[10:25:20.433]             ...future.value <- base::withVisible(base::local({
[10:25:20.433]                 sum(x, y)
[10:25:20.433]             }))
[10:25:20.433]             future::FutureResult(value = ...future.value$value, 
[10:25:20.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.433]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.433]                     ...future.globalenv.names))
[10:25:20.433]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.433]         }, condition = base::local({
[10:25:20.433]             c <- base::c
[10:25:20.433]             inherits <- base::inherits
[10:25:20.433]             invokeRestart <- base::invokeRestart
[10:25:20.433]             length <- base::length
[10:25:20.433]             list <- base::list
[10:25:20.433]             seq.int <- base::seq.int
[10:25:20.433]             signalCondition <- base::signalCondition
[10:25:20.433]             sys.calls <- base::sys.calls
[10:25:20.433]             `[[` <- base::`[[`
[10:25:20.433]             `+` <- base::`+`
[10:25:20.433]             `<<-` <- base::`<<-`
[10:25:20.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.433]                   3L)]
[10:25:20.433]             }
[10:25:20.433]             function(cond) {
[10:25:20.433]                 is_error <- inherits(cond, "error")
[10:25:20.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.433]                   NULL)
[10:25:20.433]                 if (is_error) {
[10:25:20.433]                   sessionInformation <- function() {
[10:25:20.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.433]                       search = base::search(), system = base::Sys.info())
[10:25:20.433]                   }
[10:25:20.433]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.433]                     cond$call), session = sessionInformation(), 
[10:25:20.433]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.433]                   signalCondition(cond)
[10:25:20.433]                 }
[10:25:20.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.433]                 "immediateCondition"))) {
[10:25:20.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.433]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.433]                   if (TRUE && !signal) {
[10:25:20.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.433]                     {
[10:25:20.433]                       inherits <- base::inherits
[10:25:20.433]                       invokeRestart <- base::invokeRestart
[10:25:20.433]                       is.null <- base::is.null
[10:25:20.433]                       muffled <- FALSE
[10:25:20.433]                       if (inherits(cond, "message")) {
[10:25:20.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.433]                         if (muffled) 
[10:25:20.433]                           invokeRestart("muffleMessage")
[10:25:20.433]                       }
[10:25:20.433]                       else if (inherits(cond, "warning")) {
[10:25:20.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.433]                         if (muffled) 
[10:25:20.433]                           invokeRestart("muffleWarning")
[10:25:20.433]                       }
[10:25:20.433]                       else if (inherits(cond, "condition")) {
[10:25:20.433]                         if (!is.null(pattern)) {
[10:25:20.433]                           computeRestarts <- base::computeRestarts
[10:25:20.433]                           grepl <- base::grepl
[10:25:20.433]                           restarts <- computeRestarts(cond)
[10:25:20.433]                           for (restart in restarts) {
[10:25:20.433]                             name <- restart$name
[10:25:20.433]                             if (is.null(name)) 
[10:25:20.433]                               next
[10:25:20.433]                             if (!grepl(pattern, name)) 
[10:25:20.433]                               next
[10:25:20.433]                             invokeRestart(restart)
[10:25:20.433]                             muffled <- TRUE
[10:25:20.433]                             break
[10:25:20.433]                           }
[10:25:20.433]                         }
[10:25:20.433]                       }
[10:25:20.433]                       invisible(muffled)
[10:25:20.433]                     }
[10:25:20.433]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.433]                   }
[10:25:20.433]                 }
[10:25:20.433]                 else {
[10:25:20.433]                   if (TRUE) {
[10:25:20.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.433]                     {
[10:25:20.433]                       inherits <- base::inherits
[10:25:20.433]                       invokeRestart <- base::invokeRestart
[10:25:20.433]                       is.null <- base::is.null
[10:25:20.433]                       muffled <- FALSE
[10:25:20.433]                       if (inherits(cond, "message")) {
[10:25:20.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.433]                         if (muffled) 
[10:25:20.433]                           invokeRestart("muffleMessage")
[10:25:20.433]                       }
[10:25:20.433]                       else if (inherits(cond, "warning")) {
[10:25:20.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.433]                         if (muffled) 
[10:25:20.433]                           invokeRestart("muffleWarning")
[10:25:20.433]                       }
[10:25:20.433]                       else if (inherits(cond, "condition")) {
[10:25:20.433]                         if (!is.null(pattern)) {
[10:25:20.433]                           computeRestarts <- base::computeRestarts
[10:25:20.433]                           grepl <- base::grepl
[10:25:20.433]                           restarts <- computeRestarts(cond)
[10:25:20.433]                           for (restart in restarts) {
[10:25:20.433]                             name <- restart$name
[10:25:20.433]                             if (is.null(name)) 
[10:25:20.433]                               next
[10:25:20.433]                             if (!grepl(pattern, name)) 
[10:25:20.433]                               next
[10:25:20.433]                             invokeRestart(restart)
[10:25:20.433]                             muffled <- TRUE
[10:25:20.433]                             break
[10:25:20.433]                           }
[10:25:20.433]                         }
[10:25:20.433]                       }
[10:25:20.433]                       invisible(muffled)
[10:25:20.433]                     }
[10:25:20.433]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.433]                   }
[10:25:20.433]                 }
[10:25:20.433]             }
[10:25:20.433]         }))
[10:25:20.433]     }, error = function(ex) {
[10:25:20.433]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.433]                 ...future.rng), started = ...future.startTime, 
[10:25:20.433]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.433]             version = "1.8"), class = "FutureResult")
[10:25:20.433]     }, finally = {
[10:25:20.433]         if (!identical(...future.workdir, getwd())) 
[10:25:20.433]             setwd(...future.workdir)
[10:25:20.433]         {
[10:25:20.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.433]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.433]             }
[10:25:20.433]             base::options(...future.oldOptions)
[10:25:20.433]             if (.Platform$OS.type == "windows") {
[10:25:20.433]                 old_names <- names(...future.oldEnvVars)
[10:25:20.433]                 envs <- base::Sys.getenv()
[10:25:20.433]                 names <- names(envs)
[10:25:20.433]                 common <- intersect(names, old_names)
[10:25:20.433]                 added <- setdiff(names, old_names)
[10:25:20.433]                 removed <- setdiff(old_names, names)
[10:25:20.433]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.433]                   envs[common]]
[10:25:20.433]                 NAMES <- toupper(changed)
[10:25:20.433]                 args <- list()
[10:25:20.433]                 for (kk in seq_along(NAMES)) {
[10:25:20.433]                   name <- changed[[kk]]
[10:25:20.433]                   NAME <- NAMES[[kk]]
[10:25:20.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.433]                     next
[10:25:20.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.433]                 }
[10:25:20.433]                 NAMES <- toupper(added)
[10:25:20.433]                 for (kk in seq_along(NAMES)) {
[10:25:20.433]                   name <- added[[kk]]
[10:25:20.433]                   NAME <- NAMES[[kk]]
[10:25:20.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.433]                     next
[10:25:20.433]                   args[[name]] <- ""
[10:25:20.433]                 }
[10:25:20.433]                 NAMES <- toupper(removed)
[10:25:20.433]                 for (kk in seq_along(NAMES)) {
[10:25:20.433]                   name <- removed[[kk]]
[10:25:20.433]                   NAME <- NAMES[[kk]]
[10:25:20.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.433]                     next
[10:25:20.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.433]                 }
[10:25:20.433]                 if (length(args) > 0) 
[10:25:20.433]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.433]             }
[10:25:20.433]             else {
[10:25:20.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.433]             }
[10:25:20.433]             {
[10:25:20.433]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.433]                   0L) {
[10:25:20.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.433]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.433]                   base::options(opts)
[10:25:20.433]                 }
[10:25:20.433]                 {
[10:25:20.433]                   {
[10:25:20.433]                     NULL
[10:25:20.433]                     RNGkind("Mersenne-Twister")
[10:25:20.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.433]                       inherits = FALSE)
[10:25:20.433]                   }
[10:25:20.433]                   options(future.plan = NULL)
[10:25:20.433]                   if (is.na(NA_character_)) 
[10:25:20.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.433]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.433]                   {
[10:25:20.433]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.433]                     if (!future$lazy) 
[10:25:20.433]                       future <- run(future)
[10:25:20.433]                     invisible(future)
[10:25:20.433]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.433]                 }
[10:25:20.433]             }
[10:25:20.433]         }
[10:25:20.433]     })
[10:25:20.433]     if (TRUE) {
[10:25:20.433]         base::sink(type = "output", split = FALSE)
[10:25:20.433]         if (TRUE) {
[10:25:20.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.433]         }
[10:25:20.433]         else {
[10:25:20.433]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.433]         }
[10:25:20.433]         base::close(...future.stdout)
[10:25:20.433]         ...future.stdout <- NULL
[10:25:20.433]     }
[10:25:20.433]     ...future.result$conditions <- ...future.conditions
[10:25:20.433]     ...future.result$finished <- base::Sys.time()
[10:25:20.433]     ...future.result
[10:25:20.433] }
[10:25:20.435] assign_globals() ...
[10:25:20.435] List of 2
[10:25:20.435]  $ x: int [1:2] 1 2
[10:25:20.435]  $ y: num 3
[10:25:20.435]  - attr(*, "where")=List of 2
[10:25:20.435]   ..$ x:<environment: R_EmptyEnv> 
[10:25:20.435]   ..$ y:<environment: R_EmptyEnv> 
[10:25:20.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.435]  - attr(*, "resolved")= logi FALSE
[10:25:20.435]  - attr(*, "total_size")= num 112
[10:25:20.435]  - attr(*, "already-done")= logi TRUE
[10:25:20.438] - copied ‘x’ to environment
[10:25:20.438] - copied ‘y’ to environment
[10:25:20.438] assign_globals() ... done
[10:25:20.438] plan(): Setting new future strategy stack:
[10:25:20.438] List of future strategies:
[10:25:20.438] 1. sequential:
[10:25:20.438]    - args: function (..., envir = parent.frame())
[10:25:20.438]    - tweaked: FALSE
[10:25:20.438]    - call: NULL
[10:25:20.439] plan(): nbrOfWorkers() = 1
[10:25:20.439] plan(): Setting new future strategy stack:
[10:25:20.439] List of future strategies:
[10:25:20.439] 1. sequential:
[10:25:20.439]    - args: function (..., envir = parent.frame())
[10:25:20.439]    - tweaked: FALSE
[10:25:20.439]    - call: plan(strategy, substitute = FALSE)
[10:25:20.440] plan(): nbrOfWorkers() = 1
[10:25:20.440] SequentialFuture started (and completed)
[10:25:20.440] - Launch lazy future ... done
[10:25:20.440] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x558a923df5d8>
Arguments '...' exists: FALSE
[10:25:20.441] getGlobalsAndPackages() ...
[10:25:20.441] Searching for globals...
[10:25:20.442] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[10:25:20.442] Searching for globals ... DONE
[10:25:20.442] Resolving globals: FALSE
[10:25:20.442] Tweak future expression to call with '...' arguments ...
[10:25:20.443] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.443] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.443] - globals: [2] ‘x’, ‘y’
[10:25:20.443] 
[10:25:20.443] getGlobalsAndPackages() ... DONE
[10:25:20.444] run() for ‘Future’ ...
[10:25:20.444] - state: ‘created’
[10:25:20.444] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.444]   - Field: ‘label’
[10:25:20.444]   - Field: ‘local’
[10:25:20.445]   - Field: ‘owner’
[10:25:20.445]   - Field: ‘envir’
[10:25:20.445]   - Field: ‘packages’
[10:25:20.445]   - Field: ‘gc’
[10:25:20.445]   - Field: ‘conditions’
[10:25:20.445]   - Field: ‘expr’
[10:25:20.445]   - Field: ‘uuid’
[10:25:20.445]   - Field: ‘seed’
[10:25:20.445]   - Field: ‘version’
[10:25:20.445]   - Field: ‘result’
[10:25:20.445]   - Field: ‘asynchronous’
[10:25:20.446]   - Field: ‘calls’
[10:25:20.446]   - Field: ‘globals’
[10:25:20.446]   - Field: ‘stdout’
[10:25:20.446]   - Field: ‘earlySignal’
[10:25:20.446]   - Field: ‘lazy’
[10:25:20.446]   - Field: ‘state’
[10:25:20.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.446] - Launch lazy future ...
[10:25:20.446] Packages needed by the future expression (n = 0): <none>
[10:25:20.446] Packages needed by future strategies (n = 0): <none>
[10:25:20.447] {
[10:25:20.447]     {
[10:25:20.447]         {
[10:25:20.447]             ...future.startTime <- base::Sys.time()
[10:25:20.447]             {
[10:25:20.447]                 {
[10:25:20.447]                   {
[10:25:20.447]                     base::local({
[10:25:20.447]                       has_future <- base::requireNamespace("future", 
[10:25:20.447]                         quietly = TRUE)
[10:25:20.447]                       if (has_future) {
[10:25:20.447]                         ns <- base::getNamespace("future")
[10:25:20.447]                         version <- ns[[".package"]][["version"]]
[10:25:20.447]                         if (is.null(version)) 
[10:25:20.447]                           version <- utils::packageVersion("future")
[10:25:20.447]                       }
[10:25:20.447]                       else {
[10:25:20.447]                         version <- NULL
[10:25:20.447]                       }
[10:25:20.447]                       if (!has_future || version < "1.8.0") {
[10:25:20.447]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.447]                           "", base::R.version$version.string), 
[10:25:20.447]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.447]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.447]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.447]                             "release", "version")], collapse = " "), 
[10:25:20.447]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.447]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.447]                           info)
[10:25:20.447]                         info <- base::paste(info, collapse = "; ")
[10:25:20.447]                         if (!has_future) {
[10:25:20.447]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.447]                             info)
[10:25:20.447]                         }
[10:25:20.447]                         else {
[10:25:20.447]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.447]                             info, version)
[10:25:20.447]                         }
[10:25:20.447]                         base::stop(msg)
[10:25:20.447]                       }
[10:25:20.447]                     })
[10:25:20.447]                   }
[10:25:20.447]                   options(future.plan = NULL)
[10:25:20.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.447]                 }
[10:25:20.447]                 ...future.workdir <- getwd()
[10:25:20.447]             }
[10:25:20.447]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.447]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.447]         }
[10:25:20.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.447]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.447]             base::names(...future.oldOptions))
[10:25:20.447]     }
[10:25:20.447]     if (FALSE) {
[10:25:20.447]     }
[10:25:20.447]     else {
[10:25:20.447]         if (TRUE) {
[10:25:20.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.447]                 open = "w")
[10:25:20.447]         }
[10:25:20.447]         else {
[10:25:20.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.447]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.447]         }
[10:25:20.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.447]             base::sink(type = "output", split = FALSE)
[10:25:20.447]             base::close(...future.stdout)
[10:25:20.447]         }, add = TRUE)
[10:25:20.447]     }
[10:25:20.447]     ...future.frame <- base::sys.nframe()
[10:25:20.447]     ...future.conditions <- base::list()
[10:25:20.447]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.447]     if (FALSE) {
[10:25:20.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.447]     }
[10:25:20.447]     ...future.result <- base::tryCatch({
[10:25:20.447]         base::withCallingHandlers({
[10:25:20.447]             ...future.value <- base::withVisible(base::local({
[10:25:20.447]                 sum(x, y, ...)
[10:25:20.447]             }))
[10:25:20.447]             future::FutureResult(value = ...future.value$value, 
[10:25:20.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.447]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.447]                     ...future.globalenv.names))
[10:25:20.447]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.447]         }, condition = base::local({
[10:25:20.447]             c <- base::c
[10:25:20.447]             inherits <- base::inherits
[10:25:20.447]             invokeRestart <- base::invokeRestart
[10:25:20.447]             length <- base::length
[10:25:20.447]             list <- base::list
[10:25:20.447]             seq.int <- base::seq.int
[10:25:20.447]             signalCondition <- base::signalCondition
[10:25:20.447]             sys.calls <- base::sys.calls
[10:25:20.447]             `[[` <- base::`[[`
[10:25:20.447]             `+` <- base::`+`
[10:25:20.447]             `<<-` <- base::`<<-`
[10:25:20.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.447]                   3L)]
[10:25:20.447]             }
[10:25:20.447]             function(cond) {
[10:25:20.447]                 is_error <- inherits(cond, "error")
[10:25:20.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.447]                   NULL)
[10:25:20.447]                 if (is_error) {
[10:25:20.447]                   sessionInformation <- function() {
[10:25:20.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.447]                       search = base::search(), system = base::Sys.info())
[10:25:20.447]                   }
[10:25:20.447]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.447]                     cond$call), session = sessionInformation(), 
[10:25:20.447]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.447]                   signalCondition(cond)
[10:25:20.447]                 }
[10:25:20.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.447]                 "immediateCondition"))) {
[10:25:20.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.447]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.447]                   if (TRUE && !signal) {
[10:25:20.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.447]                     {
[10:25:20.447]                       inherits <- base::inherits
[10:25:20.447]                       invokeRestart <- base::invokeRestart
[10:25:20.447]                       is.null <- base::is.null
[10:25:20.447]                       muffled <- FALSE
[10:25:20.447]                       if (inherits(cond, "message")) {
[10:25:20.447]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.447]                         if (muffled) 
[10:25:20.447]                           invokeRestart("muffleMessage")
[10:25:20.447]                       }
[10:25:20.447]                       else if (inherits(cond, "warning")) {
[10:25:20.447]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.447]                         if (muffled) 
[10:25:20.447]                           invokeRestart("muffleWarning")
[10:25:20.447]                       }
[10:25:20.447]                       else if (inherits(cond, "condition")) {
[10:25:20.447]                         if (!is.null(pattern)) {
[10:25:20.447]                           computeRestarts <- base::computeRestarts
[10:25:20.447]                           grepl <- base::grepl
[10:25:20.447]                           restarts <- computeRestarts(cond)
[10:25:20.447]                           for (restart in restarts) {
[10:25:20.447]                             name <- restart$name
[10:25:20.447]                             if (is.null(name)) 
[10:25:20.447]                               next
[10:25:20.447]                             if (!grepl(pattern, name)) 
[10:25:20.447]                               next
[10:25:20.447]                             invokeRestart(restart)
[10:25:20.447]                             muffled <- TRUE
[10:25:20.447]                             break
[10:25:20.447]                           }
[10:25:20.447]                         }
[10:25:20.447]                       }
[10:25:20.447]                       invisible(muffled)
[10:25:20.447]                     }
[10:25:20.447]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.447]                   }
[10:25:20.447]                 }
[10:25:20.447]                 else {
[10:25:20.447]                   if (TRUE) {
[10:25:20.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.447]                     {
[10:25:20.447]                       inherits <- base::inherits
[10:25:20.447]                       invokeRestart <- base::invokeRestart
[10:25:20.447]                       is.null <- base::is.null
[10:25:20.447]                       muffled <- FALSE
[10:25:20.447]                       if (inherits(cond, "message")) {
[10:25:20.447]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.447]                         if (muffled) 
[10:25:20.447]                           invokeRestart("muffleMessage")
[10:25:20.447]                       }
[10:25:20.447]                       else if (inherits(cond, "warning")) {
[10:25:20.447]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.447]                         if (muffled) 
[10:25:20.447]                           invokeRestart("muffleWarning")
[10:25:20.447]                       }
[10:25:20.447]                       else if (inherits(cond, "condition")) {
[10:25:20.447]                         if (!is.null(pattern)) {
[10:25:20.447]                           computeRestarts <- base::computeRestarts
[10:25:20.447]                           grepl <- base::grepl
[10:25:20.447]                           restarts <- computeRestarts(cond)
[10:25:20.447]                           for (restart in restarts) {
[10:25:20.447]                             name <- restart$name
[10:25:20.447]                             if (is.null(name)) 
[10:25:20.447]                               next
[10:25:20.447]                             if (!grepl(pattern, name)) 
[10:25:20.447]                               next
[10:25:20.447]                             invokeRestart(restart)
[10:25:20.447]                             muffled <- TRUE
[10:25:20.447]                             break
[10:25:20.447]                           }
[10:25:20.447]                         }
[10:25:20.447]                       }
[10:25:20.447]                       invisible(muffled)
[10:25:20.447]                     }
[10:25:20.447]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.447]                   }
[10:25:20.447]                 }
[10:25:20.447]             }
[10:25:20.447]         }))
[10:25:20.447]     }, error = function(ex) {
[10:25:20.447]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.447]                 ...future.rng), started = ...future.startTime, 
[10:25:20.447]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.447]             version = "1.8"), class = "FutureResult")
[10:25:20.447]     }, finally = {
[10:25:20.447]         if (!identical(...future.workdir, getwd())) 
[10:25:20.447]             setwd(...future.workdir)
[10:25:20.447]         {
[10:25:20.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.447]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.447]             }
[10:25:20.447]             base::options(...future.oldOptions)
[10:25:20.447]             if (.Platform$OS.type == "windows") {
[10:25:20.447]                 old_names <- names(...future.oldEnvVars)
[10:25:20.447]                 envs <- base::Sys.getenv()
[10:25:20.447]                 names <- names(envs)
[10:25:20.447]                 common <- intersect(names, old_names)
[10:25:20.447]                 added <- setdiff(names, old_names)
[10:25:20.447]                 removed <- setdiff(old_names, names)
[10:25:20.447]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.447]                   envs[common]]
[10:25:20.447]                 NAMES <- toupper(changed)
[10:25:20.447]                 args <- list()
[10:25:20.447]                 for (kk in seq_along(NAMES)) {
[10:25:20.447]                   name <- changed[[kk]]
[10:25:20.447]                   NAME <- NAMES[[kk]]
[10:25:20.447]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.447]                     next
[10:25:20.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.447]                 }
[10:25:20.447]                 NAMES <- toupper(added)
[10:25:20.447]                 for (kk in seq_along(NAMES)) {
[10:25:20.447]                   name <- added[[kk]]
[10:25:20.447]                   NAME <- NAMES[[kk]]
[10:25:20.447]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.447]                     next
[10:25:20.447]                   args[[name]] <- ""
[10:25:20.447]                 }
[10:25:20.447]                 NAMES <- toupper(removed)
[10:25:20.447]                 for (kk in seq_along(NAMES)) {
[10:25:20.447]                   name <- removed[[kk]]
[10:25:20.447]                   NAME <- NAMES[[kk]]
[10:25:20.447]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.447]                     next
[10:25:20.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.447]                 }
[10:25:20.447]                 if (length(args) > 0) 
[10:25:20.447]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.447]             }
[10:25:20.447]             else {
[10:25:20.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.447]             }
[10:25:20.447]             {
[10:25:20.447]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.447]                   0L) {
[10:25:20.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.447]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.447]                   base::options(opts)
[10:25:20.447]                 }
[10:25:20.447]                 {
[10:25:20.447]                   {
[10:25:20.447]                     NULL
[10:25:20.447]                     RNGkind("Mersenne-Twister")
[10:25:20.447]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.447]                       inherits = FALSE)
[10:25:20.447]                   }
[10:25:20.447]                   options(future.plan = NULL)
[10:25:20.447]                   if (is.na(NA_character_)) 
[10:25:20.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.447]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.447]                   {
[10:25:20.447]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.447]                     if (!future$lazy) 
[10:25:20.447]                       future <- run(future)
[10:25:20.447]                     invisible(future)
[10:25:20.447]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.447]                 }
[10:25:20.447]             }
[10:25:20.447]         }
[10:25:20.447]     })
[10:25:20.447]     if (TRUE) {
[10:25:20.447]         base::sink(type = "output", split = FALSE)
[10:25:20.447]         if (TRUE) {
[10:25:20.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.447]         }
[10:25:20.447]         else {
[10:25:20.447]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.447]         }
[10:25:20.447]         base::close(...future.stdout)
[10:25:20.447]         ...future.stdout <- NULL
[10:25:20.447]     }
[10:25:20.447]     ...future.result$conditions <- ...future.conditions
[10:25:20.447]     ...future.result$finished <- base::Sys.time()
[10:25:20.447]     ...future.result
[10:25:20.447] }
[10:25:20.448] assign_globals() ...
[10:25:20.448] List of 2
[10:25:20.448]  $ x: int [1:2] 1 2
[10:25:20.448]  $ y: num 3
[10:25:20.448]  - attr(*, "where")=List of 2
[10:25:20.448]   ..$ x:<environment: R_EmptyEnv> 
[10:25:20.448]   ..$ y:<environment: R_EmptyEnv> 
[10:25:20.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.448]  - attr(*, "resolved")= logi FALSE
[10:25:20.448]  - attr(*, "total_size")= num 112
[10:25:20.448]  - attr(*, "already-done")= logi TRUE
[10:25:20.452] - copied ‘x’ to environment
[10:25:20.453] - copied ‘y’ to environment
[10:25:20.453] assign_globals() ... done
[10:25:20.453] plan(): Setting new future strategy stack:
[10:25:20.453] List of future strategies:
[10:25:20.453] 1. sequential:
[10:25:20.453]    - args: function (..., envir = parent.frame())
[10:25:20.453]    - tweaked: FALSE
[10:25:20.453]    - call: NULL
[10:25:20.453] plan(): nbrOfWorkers() = 1
[10:25:20.454] plan(): Setting new future strategy stack:
[10:25:20.454] List of future strategies:
[10:25:20.454] 1. sequential:
[10:25:20.454]    - args: function (..., envir = parent.frame())
[10:25:20.454]    - tweaked: FALSE
[10:25:20.454]    - call: plan(strategy, substitute = FALSE)
[10:25:20.455] plan(): nbrOfWorkers() = 1
[10:25:20.455] SequentialFuture started (and completed)
[10:25:20.455] signalConditions() ...
[10:25:20.455]  - include = ‘immediateCondition’
[10:25:20.455]  - exclude = 
[10:25:20.455]  - resignal = FALSE
[10:25:20.455]  - Number of conditions: 1
[10:25:20.455] signalConditions() ... done
[10:25:20.455] - Launch lazy future ... done
[10:25:20.455] run() for ‘SequentialFuture’ ... done
[10:25:20.456] signalConditions() ...
[10:25:20.456]  - include = ‘immediateCondition’
[10:25:20.456]  - exclude = 
[10:25:20.456]  - resignal = FALSE
[10:25:20.456]  - Number of conditions: 1
[10:25:20.456] signalConditions() ... done
[10:25:20.456] Future state: ‘finished’
[10:25:20.456] signalConditions() ...
[10:25:20.456]  - include = ‘condition’
[10:25:20.456]  - exclude = ‘immediateCondition’
[10:25:20.456]  - resignal = TRUE
[10:25:20.457]  - Number of conditions: 1
[10:25:20.457]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:25:20.457] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x558a915e1568>
Arguments '...' exists: TRUE
[10:25:20.457] getGlobalsAndPackages() ...
[10:25:20.458] - globals passed as-is: [1] ‘...’
[10:25:20.458] Resolving globals: FALSE
[10:25:20.458] Tweak future expression to call with '...' arguments ...
[10:25:20.458] {
[10:25:20.458]     do.call(function(...) {
[10:25:20.458]         fcn <- function() sum(...)
[10:25:20.458]         fcn()
[10:25:20.458]     }, args = future.call.arguments)
[10:25:20.458] }
[10:25:20.458] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.458] The total size of the 1 globals is 112 bytes (112 bytes)
[10:25:20.459] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[10:25:20.459] - globals: [1] ‘future.call.arguments’
[10:25:20.459] 
[10:25:20.459] getGlobalsAndPackages() ... DONE
[10:25:20.459] run() for ‘Future’ ...
[10:25:20.459] - state: ‘created’
[10:25:20.459] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.460]   - Field: ‘label’
[10:25:20.460]   - Field: ‘local’
[10:25:20.460]   - Field: ‘owner’
[10:25:20.460]   - Field: ‘envir’
[10:25:20.460]   - Field: ‘packages’
[10:25:20.460]   - Field: ‘gc’
[10:25:20.460]   - Field: ‘conditions’
[10:25:20.461]   - Field: ‘expr’
[10:25:20.461]   - Field: ‘uuid’
[10:25:20.461]   - Field: ‘seed’
[10:25:20.461]   - Field: ‘version’
[10:25:20.461]   - Field: ‘result’
[10:25:20.461]   - Field: ‘asynchronous’
[10:25:20.461]   - Field: ‘calls’
[10:25:20.461]   - Field: ‘globals’
[10:25:20.461]   - Field: ‘stdout’
[10:25:20.461]   - Field: ‘earlySignal’
[10:25:20.461]   - Field: ‘lazy’
[10:25:20.461]   - Field: ‘state’
[10:25:20.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.462] - Launch lazy future ...
[10:25:20.462] Packages needed by the future expression (n = 0): <none>
[10:25:20.462] Packages needed by future strategies (n = 0): <none>
[10:25:20.462] {
[10:25:20.462]     {
[10:25:20.462]         {
[10:25:20.462]             ...future.startTime <- base::Sys.time()
[10:25:20.462]             {
[10:25:20.462]                 {
[10:25:20.462]                   {
[10:25:20.462]                     base::local({
[10:25:20.462]                       has_future <- base::requireNamespace("future", 
[10:25:20.462]                         quietly = TRUE)
[10:25:20.462]                       if (has_future) {
[10:25:20.462]                         ns <- base::getNamespace("future")
[10:25:20.462]                         version <- ns[[".package"]][["version"]]
[10:25:20.462]                         if (is.null(version)) 
[10:25:20.462]                           version <- utils::packageVersion("future")
[10:25:20.462]                       }
[10:25:20.462]                       else {
[10:25:20.462]                         version <- NULL
[10:25:20.462]                       }
[10:25:20.462]                       if (!has_future || version < "1.8.0") {
[10:25:20.462]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.462]                           "", base::R.version$version.string), 
[10:25:20.462]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.462]                             "release", "version")], collapse = " "), 
[10:25:20.462]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.462]                           info)
[10:25:20.462]                         info <- base::paste(info, collapse = "; ")
[10:25:20.462]                         if (!has_future) {
[10:25:20.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.462]                             info)
[10:25:20.462]                         }
[10:25:20.462]                         else {
[10:25:20.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.462]                             info, version)
[10:25:20.462]                         }
[10:25:20.462]                         base::stop(msg)
[10:25:20.462]                       }
[10:25:20.462]                     })
[10:25:20.462]                   }
[10:25:20.462]                   options(future.plan = NULL)
[10:25:20.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.462]                 }
[10:25:20.462]                 ...future.workdir <- getwd()
[10:25:20.462]             }
[10:25:20.462]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.462]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.462]         }
[10:25:20.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.462]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.462]             base::names(...future.oldOptions))
[10:25:20.462]     }
[10:25:20.462]     if (FALSE) {
[10:25:20.462]     }
[10:25:20.462]     else {
[10:25:20.462]         if (TRUE) {
[10:25:20.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.462]                 open = "w")
[10:25:20.462]         }
[10:25:20.462]         else {
[10:25:20.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.462]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.462]         }
[10:25:20.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.462]             base::sink(type = "output", split = FALSE)
[10:25:20.462]             base::close(...future.stdout)
[10:25:20.462]         }, add = TRUE)
[10:25:20.462]     }
[10:25:20.462]     ...future.frame <- base::sys.nframe()
[10:25:20.462]     ...future.conditions <- base::list()
[10:25:20.462]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.462]     if (FALSE) {
[10:25:20.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.462]     }
[10:25:20.462]     ...future.result <- base::tryCatch({
[10:25:20.462]         base::withCallingHandlers({
[10:25:20.462]             ...future.value <- base::withVisible(base::local({
[10:25:20.462]                 do.call(function(...) {
[10:25:20.462]                   fcn <- function() sum(...)
[10:25:20.462]                   fcn()
[10:25:20.462]                 }, args = future.call.arguments)
[10:25:20.462]             }))
[10:25:20.462]             future::FutureResult(value = ...future.value$value, 
[10:25:20.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.462]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.462]                     ...future.globalenv.names))
[10:25:20.462]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.462]         }, condition = base::local({
[10:25:20.462]             c <- base::c
[10:25:20.462]             inherits <- base::inherits
[10:25:20.462]             invokeRestart <- base::invokeRestart
[10:25:20.462]             length <- base::length
[10:25:20.462]             list <- base::list
[10:25:20.462]             seq.int <- base::seq.int
[10:25:20.462]             signalCondition <- base::signalCondition
[10:25:20.462]             sys.calls <- base::sys.calls
[10:25:20.462]             `[[` <- base::`[[`
[10:25:20.462]             `+` <- base::`+`
[10:25:20.462]             `<<-` <- base::`<<-`
[10:25:20.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.462]                   3L)]
[10:25:20.462]             }
[10:25:20.462]             function(cond) {
[10:25:20.462]                 is_error <- inherits(cond, "error")
[10:25:20.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.462]                   NULL)
[10:25:20.462]                 if (is_error) {
[10:25:20.462]                   sessionInformation <- function() {
[10:25:20.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.462]                       search = base::search(), system = base::Sys.info())
[10:25:20.462]                   }
[10:25:20.462]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.462]                     cond$call), session = sessionInformation(), 
[10:25:20.462]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.462]                   signalCondition(cond)
[10:25:20.462]                 }
[10:25:20.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.462]                 "immediateCondition"))) {
[10:25:20.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.462]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.462]                   if (TRUE && !signal) {
[10:25:20.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.462]                     {
[10:25:20.462]                       inherits <- base::inherits
[10:25:20.462]                       invokeRestart <- base::invokeRestart
[10:25:20.462]                       is.null <- base::is.null
[10:25:20.462]                       muffled <- FALSE
[10:25:20.462]                       if (inherits(cond, "message")) {
[10:25:20.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.462]                         if (muffled) 
[10:25:20.462]                           invokeRestart("muffleMessage")
[10:25:20.462]                       }
[10:25:20.462]                       else if (inherits(cond, "warning")) {
[10:25:20.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.462]                         if (muffled) 
[10:25:20.462]                           invokeRestart("muffleWarning")
[10:25:20.462]                       }
[10:25:20.462]                       else if (inherits(cond, "condition")) {
[10:25:20.462]                         if (!is.null(pattern)) {
[10:25:20.462]                           computeRestarts <- base::computeRestarts
[10:25:20.462]                           grepl <- base::grepl
[10:25:20.462]                           restarts <- computeRestarts(cond)
[10:25:20.462]                           for (restart in restarts) {
[10:25:20.462]                             name <- restart$name
[10:25:20.462]                             if (is.null(name)) 
[10:25:20.462]                               next
[10:25:20.462]                             if (!grepl(pattern, name)) 
[10:25:20.462]                               next
[10:25:20.462]                             invokeRestart(restart)
[10:25:20.462]                             muffled <- TRUE
[10:25:20.462]                             break
[10:25:20.462]                           }
[10:25:20.462]                         }
[10:25:20.462]                       }
[10:25:20.462]                       invisible(muffled)
[10:25:20.462]                     }
[10:25:20.462]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.462]                   }
[10:25:20.462]                 }
[10:25:20.462]                 else {
[10:25:20.462]                   if (TRUE) {
[10:25:20.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.462]                     {
[10:25:20.462]                       inherits <- base::inherits
[10:25:20.462]                       invokeRestart <- base::invokeRestart
[10:25:20.462]                       is.null <- base::is.null
[10:25:20.462]                       muffled <- FALSE
[10:25:20.462]                       if (inherits(cond, "message")) {
[10:25:20.462]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.462]                         if (muffled) 
[10:25:20.462]                           invokeRestart("muffleMessage")
[10:25:20.462]                       }
[10:25:20.462]                       else if (inherits(cond, "warning")) {
[10:25:20.462]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.462]                         if (muffled) 
[10:25:20.462]                           invokeRestart("muffleWarning")
[10:25:20.462]                       }
[10:25:20.462]                       else if (inherits(cond, "condition")) {
[10:25:20.462]                         if (!is.null(pattern)) {
[10:25:20.462]                           computeRestarts <- base::computeRestarts
[10:25:20.462]                           grepl <- base::grepl
[10:25:20.462]                           restarts <- computeRestarts(cond)
[10:25:20.462]                           for (restart in restarts) {
[10:25:20.462]                             name <- restart$name
[10:25:20.462]                             if (is.null(name)) 
[10:25:20.462]                               next
[10:25:20.462]                             if (!grepl(pattern, name)) 
[10:25:20.462]                               next
[10:25:20.462]                             invokeRestart(restart)
[10:25:20.462]                             muffled <- TRUE
[10:25:20.462]                             break
[10:25:20.462]                           }
[10:25:20.462]                         }
[10:25:20.462]                       }
[10:25:20.462]                       invisible(muffled)
[10:25:20.462]                     }
[10:25:20.462]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.462]                   }
[10:25:20.462]                 }
[10:25:20.462]             }
[10:25:20.462]         }))
[10:25:20.462]     }, error = function(ex) {
[10:25:20.462]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.462]                 ...future.rng), started = ...future.startTime, 
[10:25:20.462]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.462]             version = "1.8"), class = "FutureResult")
[10:25:20.462]     }, finally = {
[10:25:20.462]         if (!identical(...future.workdir, getwd())) 
[10:25:20.462]             setwd(...future.workdir)
[10:25:20.462]         {
[10:25:20.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.462]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.462]             }
[10:25:20.462]             base::options(...future.oldOptions)
[10:25:20.462]             if (.Platform$OS.type == "windows") {
[10:25:20.462]                 old_names <- names(...future.oldEnvVars)
[10:25:20.462]                 envs <- base::Sys.getenv()
[10:25:20.462]                 names <- names(envs)
[10:25:20.462]                 common <- intersect(names, old_names)
[10:25:20.462]                 added <- setdiff(names, old_names)
[10:25:20.462]                 removed <- setdiff(old_names, names)
[10:25:20.462]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.462]                   envs[common]]
[10:25:20.462]                 NAMES <- toupper(changed)
[10:25:20.462]                 args <- list()
[10:25:20.462]                 for (kk in seq_along(NAMES)) {
[10:25:20.462]                   name <- changed[[kk]]
[10:25:20.462]                   NAME <- NAMES[[kk]]
[10:25:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.462]                     next
[10:25:20.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.462]                 }
[10:25:20.462]                 NAMES <- toupper(added)
[10:25:20.462]                 for (kk in seq_along(NAMES)) {
[10:25:20.462]                   name <- added[[kk]]
[10:25:20.462]                   NAME <- NAMES[[kk]]
[10:25:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.462]                     next
[10:25:20.462]                   args[[name]] <- ""
[10:25:20.462]                 }
[10:25:20.462]                 NAMES <- toupper(removed)
[10:25:20.462]                 for (kk in seq_along(NAMES)) {
[10:25:20.462]                   name <- removed[[kk]]
[10:25:20.462]                   NAME <- NAMES[[kk]]
[10:25:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.462]                     next
[10:25:20.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.462]                 }
[10:25:20.462]                 if (length(args) > 0) 
[10:25:20.462]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.462]             }
[10:25:20.462]             else {
[10:25:20.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.462]             }
[10:25:20.462]             {
[10:25:20.462]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.462]                   0L) {
[10:25:20.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.462]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.462]                   base::options(opts)
[10:25:20.462]                 }
[10:25:20.462]                 {
[10:25:20.462]                   {
[10:25:20.462]                     NULL
[10:25:20.462]                     RNGkind("Mersenne-Twister")
[10:25:20.462]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.462]                       inherits = FALSE)
[10:25:20.462]                   }
[10:25:20.462]                   options(future.plan = NULL)
[10:25:20.462]                   if (is.na(NA_character_)) 
[10:25:20.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.462]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.462]                   {
[10:25:20.462]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.462]                     if (!future$lazy) 
[10:25:20.462]                       future <- run(future)
[10:25:20.462]                     invisible(future)
[10:25:20.462]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.462]                 }
[10:25:20.462]             }
[10:25:20.462]         }
[10:25:20.462]     })
[10:25:20.462]     if (TRUE) {
[10:25:20.462]         base::sink(type = "output", split = FALSE)
[10:25:20.462]         if (TRUE) {
[10:25:20.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.462]         }
[10:25:20.462]         else {
[10:25:20.462]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.462]         }
[10:25:20.462]         base::close(...future.stdout)
[10:25:20.462]         ...future.stdout <- NULL
[10:25:20.462]     }
[10:25:20.462]     ...future.result$conditions <- ...future.conditions
[10:25:20.462]     ...future.result$finished <- base::Sys.time()
[10:25:20.462]     ...future.result
[10:25:20.462] }
[10:25:20.464] assign_globals() ...
[10:25:20.464] List of 1
[10:25:20.464]  $ future.call.arguments:List of 2
[10:25:20.464]   ..$ : int [1:2] 1 2
[10:25:20.464]   ..$ : num 3
[10:25:20.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.464]  - attr(*, "where")=List of 1
[10:25:20.464]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.464]  - attr(*, "resolved")= logi FALSE
[10:25:20.464]  - attr(*, "total_size")= num 112
[10:25:20.464]  - attr(*, "already-done")= logi TRUE
[10:25:20.467] - copied ‘future.call.arguments’ to environment
[10:25:20.467] assign_globals() ... done
[10:25:20.467] plan(): Setting new future strategy stack:
[10:25:20.467] List of future strategies:
[10:25:20.467] 1. sequential:
[10:25:20.467]    - args: function (..., envir = parent.frame())
[10:25:20.467]    - tweaked: FALSE
[10:25:20.467]    - call: NULL
[10:25:20.468] plan(): nbrOfWorkers() = 1
[10:25:20.468] plan(): Setting new future strategy stack:
[10:25:20.469] List of future strategies:
[10:25:20.469] 1. sequential:
[10:25:20.469]    - args: function (..., envir = parent.frame())
[10:25:20.469]    - tweaked: FALSE
[10:25:20.469]    - call: plan(strategy, substitute = FALSE)
[10:25:20.469] plan(): nbrOfWorkers() = 1
[10:25:20.469] SequentialFuture started (and completed)
[10:25:20.469] - Launch lazy future ... done
[10:25:20.469] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x558a8feb2800>
Using '...' in a formula
[10:25:20.470] getGlobalsAndPackages() ...
[10:25:20.470] Searching for globals...
[10:25:20.472] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[10:25:20.473] Searching for globals ... DONE
[10:25:20.473] Resolving globals: FALSE
[10:25:20.473] Tweak future expression to call with '...' arguments ...
[10:25:20.473] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[10:25:20.474] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.474] - globals: [3] ‘fcn’, ‘x’, ‘y’
[10:25:20.474] 
[10:25:20.474] getGlobalsAndPackages() ... DONE
[10:25:20.474] run() for ‘Future’ ...
[10:25:20.474] - state: ‘created’
[10:25:20.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:25:20.475] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:25:20.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:25:20.475]   - Field: ‘label’
[10:25:20.475]   - Field: ‘local’
[10:25:20.475]   - Field: ‘owner’
[10:25:20.475]   - Field: ‘envir’
[10:25:20.475]   - Field: ‘packages’
[10:25:20.475]   - Field: ‘gc’
[10:25:20.476]   - Field: ‘conditions’
[10:25:20.477]   - Field: ‘expr’
[10:25:20.477]   - Field: ‘uuid’
[10:25:20.477]   - Field: ‘seed’
[10:25:20.477]   - Field: ‘version’
[10:25:20.477]   - Field: ‘result’
[10:25:20.477]   - Field: ‘asynchronous’
[10:25:20.477]   - Field: ‘calls’
[10:25:20.477]   - Field: ‘globals’
[10:25:20.477]   - Field: ‘stdout’
[10:25:20.477]   - Field: ‘earlySignal’
[10:25:20.477]   - Field: ‘lazy’
[10:25:20.478]   - Field: ‘state’
[10:25:20.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:25:20.478] - Launch lazy future ...
[10:25:20.478] Packages needed by the future expression (n = 0): <none>
[10:25:20.478] Packages needed by future strategies (n = 0): <none>
[10:25:20.478] {
[10:25:20.478]     {
[10:25:20.478]         {
[10:25:20.478]             ...future.startTime <- base::Sys.time()
[10:25:20.478]             {
[10:25:20.478]                 {
[10:25:20.478]                   {
[10:25:20.478]                     base::local({
[10:25:20.478]                       has_future <- base::requireNamespace("future", 
[10:25:20.478]                         quietly = TRUE)
[10:25:20.478]                       if (has_future) {
[10:25:20.478]                         ns <- base::getNamespace("future")
[10:25:20.478]                         version <- ns[[".package"]][["version"]]
[10:25:20.478]                         if (is.null(version)) 
[10:25:20.478]                           version <- utils::packageVersion("future")
[10:25:20.478]                       }
[10:25:20.478]                       else {
[10:25:20.478]                         version <- NULL
[10:25:20.478]                       }
[10:25:20.478]                       if (!has_future || version < "1.8.0") {
[10:25:20.478]                         info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.478]                           "", base::R.version$version.string), 
[10:25:20.478]                           platform = base::sprintf("%s (%s-bit)", 
[10:25:20.478]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.478]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.478]                             "release", "version")], collapse = " "), 
[10:25:20.478]                           hostname = base::Sys.info()[["nodename"]])
[10:25:20.478]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.478]                           info)
[10:25:20.478]                         info <- base::paste(info, collapse = "; ")
[10:25:20.478]                         if (!has_future) {
[10:25:20.478]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.478]                             info)
[10:25:20.478]                         }
[10:25:20.478]                         else {
[10:25:20.478]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.478]                             info, version)
[10:25:20.478]                         }
[10:25:20.478]                         base::stop(msg)
[10:25:20.478]                       }
[10:25:20.478]                     })
[10:25:20.478]                   }
[10:25:20.478]                   options(future.plan = NULL)
[10:25:20.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.478]                 }
[10:25:20.478]                 ...future.workdir <- getwd()
[10:25:20.478]             }
[10:25:20.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.478]         }
[10:25:20.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.478]             base::names(...future.oldOptions))
[10:25:20.478]     }
[10:25:20.478]     if (FALSE) {
[10:25:20.478]     }
[10:25:20.478]     else {
[10:25:20.478]         if (TRUE) {
[10:25:20.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.478]                 open = "w")
[10:25:20.478]         }
[10:25:20.478]         else {
[10:25:20.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.478]         }
[10:25:20.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.478]             base::sink(type = "output", split = FALSE)
[10:25:20.478]             base::close(...future.stdout)
[10:25:20.478]         }, add = TRUE)
[10:25:20.478]     }
[10:25:20.478]     ...future.frame <- base::sys.nframe()
[10:25:20.478]     ...future.conditions <- base::list()
[10:25:20.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.478]     if (FALSE) {
[10:25:20.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.478]     }
[10:25:20.478]     ...future.result <- base::tryCatch({
[10:25:20.478]         base::withCallingHandlers({
[10:25:20.478]             ...future.value <- base::withVisible(base::local(fcn(x, 
[10:25:20.478]                 y)))
[10:25:20.478]             future::FutureResult(value = ...future.value$value, 
[10:25:20.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.478]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.478]                     ...future.globalenv.names))
[10:25:20.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.478]         }, condition = base::local({
[10:25:20.478]             c <- base::c
[10:25:20.478]             inherits <- base::inherits
[10:25:20.478]             invokeRestart <- base::invokeRestart
[10:25:20.478]             length <- base::length
[10:25:20.478]             list <- base::list
[10:25:20.478]             seq.int <- base::seq.int
[10:25:20.478]             signalCondition <- base::signalCondition
[10:25:20.478]             sys.calls <- base::sys.calls
[10:25:20.478]             `[[` <- base::`[[`
[10:25:20.478]             `+` <- base::`+`
[10:25:20.478]             `<<-` <- base::`<<-`
[10:25:20.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.478]                   3L)]
[10:25:20.478]             }
[10:25:20.478]             function(cond) {
[10:25:20.478]                 is_error <- inherits(cond, "error")
[10:25:20.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.478]                   NULL)
[10:25:20.478]                 if (is_error) {
[10:25:20.478]                   sessionInformation <- function() {
[10:25:20.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.478]                       search = base::search(), system = base::Sys.info())
[10:25:20.478]                   }
[10:25:20.478]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.478]                     cond$call), session = sessionInformation(), 
[10:25:20.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.478]                   signalCondition(cond)
[10:25:20.478]                 }
[10:25:20.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.478]                 "immediateCondition"))) {
[10:25:20.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.478]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.478]                   if (TRUE && !signal) {
[10:25:20.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.478]                     {
[10:25:20.478]                       inherits <- base::inherits
[10:25:20.478]                       invokeRestart <- base::invokeRestart
[10:25:20.478]                       is.null <- base::is.null
[10:25:20.478]                       muffled <- FALSE
[10:25:20.478]                       if (inherits(cond, "message")) {
[10:25:20.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.478]                         if (muffled) 
[10:25:20.478]                           invokeRestart("muffleMessage")
[10:25:20.478]                       }
[10:25:20.478]                       else if (inherits(cond, "warning")) {
[10:25:20.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.478]                         if (muffled) 
[10:25:20.478]                           invokeRestart("muffleWarning")
[10:25:20.478]                       }
[10:25:20.478]                       else if (inherits(cond, "condition")) {
[10:25:20.478]                         if (!is.null(pattern)) {
[10:25:20.478]                           computeRestarts <- base::computeRestarts
[10:25:20.478]                           grepl <- base::grepl
[10:25:20.478]                           restarts <- computeRestarts(cond)
[10:25:20.478]                           for (restart in restarts) {
[10:25:20.478]                             name <- restart$name
[10:25:20.478]                             if (is.null(name)) 
[10:25:20.478]                               next
[10:25:20.478]                             if (!grepl(pattern, name)) 
[10:25:20.478]                               next
[10:25:20.478]                             invokeRestart(restart)
[10:25:20.478]                             muffled <- TRUE
[10:25:20.478]                             break
[10:25:20.478]                           }
[10:25:20.478]                         }
[10:25:20.478]                       }
[10:25:20.478]                       invisible(muffled)
[10:25:20.478]                     }
[10:25:20.478]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.478]                   }
[10:25:20.478]                 }
[10:25:20.478]                 else {
[10:25:20.478]                   if (TRUE) {
[10:25:20.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.478]                     {
[10:25:20.478]                       inherits <- base::inherits
[10:25:20.478]                       invokeRestart <- base::invokeRestart
[10:25:20.478]                       is.null <- base::is.null
[10:25:20.478]                       muffled <- FALSE
[10:25:20.478]                       if (inherits(cond, "message")) {
[10:25:20.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.478]                         if (muffled) 
[10:25:20.478]                           invokeRestart("muffleMessage")
[10:25:20.478]                       }
[10:25:20.478]                       else if (inherits(cond, "warning")) {
[10:25:20.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.478]                         if (muffled) 
[10:25:20.478]                           invokeRestart("muffleWarning")
[10:25:20.478]                       }
[10:25:20.478]                       else if (inherits(cond, "condition")) {
[10:25:20.478]                         if (!is.null(pattern)) {
[10:25:20.478]                           computeRestarts <- base::computeRestarts
[10:25:20.478]                           grepl <- base::grepl
[10:25:20.478]                           restarts <- computeRestarts(cond)
[10:25:20.478]                           for (restart in restarts) {
[10:25:20.478]                             name <- restart$name
[10:25:20.478]                             if (is.null(name)) 
[10:25:20.478]                               next
[10:25:20.478]                             if (!grepl(pattern, name)) 
[10:25:20.478]                               next
[10:25:20.478]                             invokeRestart(restart)
[10:25:20.478]                             muffled <- TRUE
[10:25:20.478]                             break
[10:25:20.478]                           }
[10:25:20.478]                         }
[10:25:20.478]                       }
[10:25:20.478]                       invisible(muffled)
[10:25:20.478]                     }
[10:25:20.478]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.478]                   }
[10:25:20.478]                 }
[10:25:20.478]             }
[10:25:20.478]         }))
[10:25:20.478]     }, error = function(ex) {
[10:25:20.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.478]                 ...future.rng), started = ...future.startTime, 
[10:25:20.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.478]             version = "1.8"), class = "FutureResult")
[10:25:20.478]     }, finally = {
[10:25:20.478]         if (!identical(...future.workdir, getwd())) 
[10:25:20.478]             setwd(...future.workdir)
[10:25:20.478]         {
[10:25:20.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.478]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.478]             }
[10:25:20.478]             base::options(...future.oldOptions)
[10:25:20.478]             if (.Platform$OS.type == "windows") {
[10:25:20.478]                 old_names <- names(...future.oldEnvVars)
[10:25:20.478]                 envs <- base::Sys.getenv()
[10:25:20.478]                 names <- names(envs)
[10:25:20.478]                 common <- intersect(names, old_names)
[10:25:20.478]                 added <- setdiff(names, old_names)
[10:25:20.478]                 removed <- setdiff(old_names, names)
[10:25:20.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.478]                   envs[common]]
[10:25:20.478]                 NAMES <- toupper(changed)
[10:25:20.478]                 args <- list()
[10:25:20.478]                 for (kk in seq_along(NAMES)) {
[10:25:20.478]                   name <- changed[[kk]]
[10:25:20.478]                   NAME <- NAMES[[kk]]
[10:25:20.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.478]                     next
[10:25:20.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.478]                 }
[10:25:20.478]                 NAMES <- toupper(added)
[10:25:20.478]                 for (kk in seq_along(NAMES)) {
[10:25:20.478]                   name <- added[[kk]]
[10:25:20.478]                   NAME <- NAMES[[kk]]
[10:25:20.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.478]                     next
[10:25:20.478]                   args[[name]] <- ""
[10:25:20.478]                 }
[10:25:20.478]                 NAMES <- toupper(removed)
[10:25:20.478]                 for (kk in seq_along(NAMES)) {
[10:25:20.478]                   name <- removed[[kk]]
[10:25:20.478]                   NAME <- NAMES[[kk]]
[10:25:20.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.478]                     next
[10:25:20.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.478]                 }
[10:25:20.478]                 if (length(args) > 0) 
[10:25:20.478]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.478]             }
[10:25:20.478]             else {
[10:25:20.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.478]             }
[10:25:20.478]             {
[10:25:20.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.478]                   0L) {
[10:25:20.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.478]                   base::options(opts)
[10:25:20.478]                 }
[10:25:20.478]                 {
[10:25:20.478]                   {
[10:25:20.478]                     NULL
[10:25:20.478]                     RNGkind("Mersenne-Twister")
[10:25:20.478]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:25:20.478]                       inherits = FALSE)
[10:25:20.478]                   }
[10:25:20.478]                   options(future.plan = NULL)
[10:25:20.478]                   if (is.na(NA_character_)) 
[10:25:20.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.478]                   future::plan(list(function (..., envir = parent.frame()) 
[10:25:20.478]                   {
[10:25:20.478]                     future <- SequentialFuture(..., envir = envir)
[10:25:20.478]                     if (!future$lazy) 
[10:25:20.478]                       future <- run(future)
[10:25:20.478]                     invisible(future)
[10:25:20.478]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.478]                 }
[10:25:20.478]             }
[10:25:20.478]         }
[10:25:20.478]     })
[10:25:20.478]     if (TRUE) {
[10:25:20.478]         base::sink(type = "output", split = FALSE)
[10:25:20.478]         if (TRUE) {
[10:25:20.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.478]         }
[10:25:20.478]         else {
[10:25:20.478]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.478]         }
[10:25:20.478]         base::close(...future.stdout)
[10:25:20.478]         ...future.stdout <- NULL
[10:25:20.478]     }
[10:25:20.478]     ...future.result$conditions <- ...future.conditions
[10:25:20.478]     ...future.result$finished <- base::Sys.time()
[10:25:20.478]     ...future.result
[10:25:20.478] }
[10:25:20.480] assign_globals() ...
[10:25:20.480] List of 3
[10:25:20.480]  $ fcn:function (x, y)  
[10:25:20.480]  $ x  : int [1:2] 1 2
[10:25:20.480]  $ y  : num 3
[10:25:20.480]  - attr(*, "where")=List of 3
[10:25:20.480]   ..$ fcn:<environment: R_EmptyEnv> 
[10:25:20.480]   ..$ x  :<environment: R_EmptyEnv> 
[10:25:20.480]   ..$ y  :<environment: R_EmptyEnv> 
[10:25:20.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.480]  - attr(*, "resolved")= logi FALSE
[10:25:20.480]  - attr(*, "total_size")= num 4280
[10:25:20.480]  - attr(*, "already-done")= logi TRUE
[10:25:20.483] - reassign environment for ‘fcn’
[10:25:20.483] - copied ‘fcn’ to environment
[10:25:20.483] - copied ‘x’ to environment
[10:25:20.484] - copied ‘y’ to environment
[10:25:20.484] assign_globals() ... done
[10:25:20.484] plan(): Setting new future strategy stack:
[10:25:20.484] List of future strategies:
[10:25:20.484] 1. sequential:
[10:25:20.484]    - args: function (..., envir = parent.frame())
[10:25:20.484]    - tweaked: FALSE
[10:25:20.484]    - call: NULL
[10:25:20.484] plan(): nbrOfWorkers() = 1
[10:25:20.485] plan(): Setting new future strategy stack:
[10:25:20.485] List of future strategies:
[10:25:20.485] 1. sequential:
[10:25:20.485]    - args: function (..., envir = parent.frame())
[10:25:20.485]    - tweaked: FALSE
[10:25:20.485]    - call: plan(strategy, substitute = FALSE)
[10:25:20.485] plan(): nbrOfWorkers() = 1
[10:25:20.486] SequentialFuture started (and completed)
[10:25:20.486] - Launch lazy future ... done
[10:25:20.486] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[10:25:20.491] plan(): Setting new future strategy stack:
[10:25:20.491] List of future strategies:
[10:25:20.491] 1. multicore:
[10:25:20.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.491]    - tweaked: FALSE
[10:25:20.491]    - call: plan(strategy, substitute = FALSE)
[10:25:20.495] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x558a91ddaab8>
Arguments '...' exists: TRUE
[10:25:20.495] getGlobalsAndPackages() ...
[10:25:20.495] Searching for globals...
[10:25:20.496] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:20.497] Searching for globals ... DONE
[10:25:20.497] Resolving globals: FALSE
[10:25:20.497] Tweak future expression to call with '...' arguments ...
[10:25:20.497] {
[10:25:20.497]     do.call(function(...) {
[10:25:20.497]         sum(x, ...)
[10:25:20.497]     }, args = future.call.arguments)
[10:25:20.497] }
[10:25:20.497] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.498] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.498] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:20.498] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:20.498] 
[10:25:20.498] getGlobalsAndPackages() ... DONE
[10:25:20.499] run() for ‘Future’ ...
[10:25:20.499] - state: ‘created’
[10:25:20.499] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.502] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.503]   - Field: ‘label’
[10:25:20.503]   - Field: ‘local’
[10:25:20.503]   - Field: ‘owner’
[10:25:20.503]   - Field: ‘envir’
[10:25:20.503]   - Field: ‘workers’
[10:25:20.503]   - Field: ‘packages’
[10:25:20.503]   - Field: ‘gc’
[10:25:20.503]   - Field: ‘job’
[10:25:20.503]   - Field: ‘conditions’
[10:25:20.503]   - Field: ‘expr’
[10:25:20.503]   - Field: ‘uuid’
[10:25:20.504]   - Field: ‘seed’
[10:25:20.504]   - Field: ‘version’
[10:25:20.504]   - Field: ‘result’
[10:25:20.504]   - Field: ‘asynchronous’
[10:25:20.504]   - Field: ‘calls’
[10:25:20.505]   - Field: ‘globals’
[10:25:20.505]   - Field: ‘stdout’
[10:25:20.506]   - Field: ‘earlySignal’
[10:25:20.506]   - Field: ‘lazy’
[10:25:20.506]   - Field: ‘state’
[10:25:20.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.506] - Launch lazy future ...
[10:25:20.507] Packages needed by the future expression (n = 0): <none>
[10:25:20.507] Packages needed by future strategies (n = 0): <none>
[10:25:20.508] {
[10:25:20.508]     {
[10:25:20.508]         {
[10:25:20.508]             ...future.startTime <- base::Sys.time()
[10:25:20.508]             {
[10:25:20.508]                 {
[10:25:20.508]                   {
[10:25:20.508]                     {
[10:25:20.508]                       base::local({
[10:25:20.508]                         has_future <- base::requireNamespace("future", 
[10:25:20.508]                           quietly = TRUE)
[10:25:20.508]                         if (has_future) {
[10:25:20.508]                           ns <- base::getNamespace("future")
[10:25:20.508]                           version <- ns[[".package"]][["version"]]
[10:25:20.508]                           if (is.null(version)) 
[10:25:20.508]                             version <- utils::packageVersion("future")
[10:25:20.508]                         }
[10:25:20.508]                         else {
[10:25:20.508]                           version <- NULL
[10:25:20.508]                         }
[10:25:20.508]                         if (!has_future || version < "1.8.0") {
[10:25:20.508]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.508]                             "", base::R.version$version.string), 
[10:25:20.508]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.508]                               "release", "version")], collapse = " "), 
[10:25:20.508]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.508]                             info)
[10:25:20.508]                           info <- base::paste(info, collapse = "; ")
[10:25:20.508]                           if (!has_future) {
[10:25:20.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.508]                               info)
[10:25:20.508]                           }
[10:25:20.508]                           else {
[10:25:20.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.508]                               info, version)
[10:25:20.508]                           }
[10:25:20.508]                           base::stop(msg)
[10:25:20.508]                         }
[10:25:20.508]                       })
[10:25:20.508]                     }
[10:25:20.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.508]                     base::options(mc.cores = 1L)
[10:25:20.508]                   }
[10:25:20.508]                   options(future.plan = NULL)
[10:25:20.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.508]                 }
[10:25:20.508]                 ...future.workdir <- getwd()
[10:25:20.508]             }
[10:25:20.508]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.508]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.508]         }
[10:25:20.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.508]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.508]             base::names(...future.oldOptions))
[10:25:20.508]     }
[10:25:20.508]     if (FALSE) {
[10:25:20.508]     }
[10:25:20.508]     else {
[10:25:20.508]         if (TRUE) {
[10:25:20.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.508]                 open = "w")
[10:25:20.508]         }
[10:25:20.508]         else {
[10:25:20.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.508]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.508]         }
[10:25:20.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.508]             base::sink(type = "output", split = FALSE)
[10:25:20.508]             base::close(...future.stdout)
[10:25:20.508]         }, add = TRUE)
[10:25:20.508]     }
[10:25:20.508]     ...future.frame <- base::sys.nframe()
[10:25:20.508]     ...future.conditions <- base::list()
[10:25:20.508]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.508]     if (FALSE) {
[10:25:20.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.508]     }
[10:25:20.508]     ...future.result <- base::tryCatch({
[10:25:20.508]         base::withCallingHandlers({
[10:25:20.508]             ...future.value <- base::withVisible(base::local({
[10:25:20.508]                 withCallingHandlers({
[10:25:20.508]                   {
[10:25:20.508]                     do.call(function(...) {
[10:25:20.508]                       sum(x, ...)
[10:25:20.508]                     }, args = future.call.arguments)
[10:25:20.508]                   }
[10:25:20.508]                 }, immediateCondition = function(cond) {
[10:25:20.508]                   save_rds <- function (object, pathname, ...) 
[10:25:20.508]                   {
[10:25:20.508]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.508]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.508]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.508]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.508]                         fi_tmp[["mtime"]])
[10:25:20.508]                     }
[10:25:20.508]                     tryCatch({
[10:25:20.508]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.508]                     }, error = function(ex) {
[10:25:20.508]                       msg <- conditionMessage(ex)
[10:25:20.508]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.508]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.508]                         fi_tmp[["mtime"]], msg)
[10:25:20.508]                       ex$message <- msg
[10:25:20.508]                       stop(ex)
[10:25:20.508]                     })
[10:25:20.508]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.508]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.508]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.508]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.508]                       fi <- file.info(pathname)
[10:25:20.508]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.508]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.508]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.508]                         fi[["size"]], fi[["mtime"]])
[10:25:20.508]                       stop(msg)
[10:25:20.508]                     }
[10:25:20.508]                     invisible(pathname)
[10:25:20.508]                   }
[10:25:20.508]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.508]                     rootPath = tempdir()) 
[10:25:20.508]                   {
[10:25:20.508]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.508]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.508]                       tmpdir = path, fileext = ".rds")
[10:25:20.508]                     save_rds(obj, file)
[10:25:20.508]                   }
[10:25:20.508]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.508]                   {
[10:25:20.508]                     inherits <- base::inherits
[10:25:20.508]                     invokeRestart <- base::invokeRestart
[10:25:20.508]                     is.null <- base::is.null
[10:25:20.508]                     muffled <- FALSE
[10:25:20.508]                     if (inherits(cond, "message")) {
[10:25:20.508]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.508]                       if (muffled) 
[10:25:20.508]                         invokeRestart("muffleMessage")
[10:25:20.508]                     }
[10:25:20.508]                     else if (inherits(cond, "warning")) {
[10:25:20.508]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.508]                       if (muffled) 
[10:25:20.508]                         invokeRestart("muffleWarning")
[10:25:20.508]                     }
[10:25:20.508]                     else if (inherits(cond, "condition")) {
[10:25:20.508]                       if (!is.null(pattern)) {
[10:25:20.508]                         computeRestarts <- base::computeRestarts
[10:25:20.508]                         grepl <- base::grepl
[10:25:20.508]                         restarts <- computeRestarts(cond)
[10:25:20.508]                         for (restart in restarts) {
[10:25:20.508]                           name <- restart$name
[10:25:20.508]                           if (is.null(name)) 
[10:25:20.508]                             next
[10:25:20.508]                           if (!grepl(pattern, name)) 
[10:25:20.508]                             next
[10:25:20.508]                           invokeRestart(restart)
[10:25:20.508]                           muffled <- TRUE
[10:25:20.508]                           break
[10:25:20.508]                         }
[10:25:20.508]                       }
[10:25:20.508]                     }
[10:25:20.508]                     invisible(muffled)
[10:25:20.508]                   }
[10:25:20.508]                   muffleCondition(cond)
[10:25:20.508]                 })
[10:25:20.508]             }))
[10:25:20.508]             future::FutureResult(value = ...future.value$value, 
[10:25:20.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.508]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.508]                     ...future.globalenv.names))
[10:25:20.508]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.508]         }, condition = base::local({
[10:25:20.508]             c <- base::c
[10:25:20.508]             inherits <- base::inherits
[10:25:20.508]             invokeRestart <- base::invokeRestart
[10:25:20.508]             length <- base::length
[10:25:20.508]             list <- base::list
[10:25:20.508]             seq.int <- base::seq.int
[10:25:20.508]             signalCondition <- base::signalCondition
[10:25:20.508]             sys.calls <- base::sys.calls
[10:25:20.508]             `[[` <- base::`[[`
[10:25:20.508]             `+` <- base::`+`
[10:25:20.508]             `<<-` <- base::`<<-`
[10:25:20.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.508]                   3L)]
[10:25:20.508]             }
[10:25:20.508]             function(cond) {
[10:25:20.508]                 is_error <- inherits(cond, "error")
[10:25:20.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.508]                   NULL)
[10:25:20.508]                 if (is_error) {
[10:25:20.508]                   sessionInformation <- function() {
[10:25:20.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.508]                       search = base::search(), system = base::Sys.info())
[10:25:20.508]                   }
[10:25:20.508]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.508]                     cond$call), session = sessionInformation(), 
[10:25:20.508]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.508]                   signalCondition(cond)
[10:25:20.508]                 }
[10:25:20.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.508]                 "immediateCondition"))) {
[10:25:20.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.508]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.508]                   if (TRUE && !signal) {
[10:25:20.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.508]                     {
[10:25:20.508]                       inherits <- base::inherits
[10:25:20.508]                       invokeRestart <- base::invokeRestart
[10:25:20.508]                       is.null <- base::is.null
[10:25:20.508]                       muffled <- FALSE
[10:25:20.508]                       if (inherits(cond, "message")) {
[10:25:20.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.508]                         if (muffled) 
[10:25:20.508]                           invokeRestart("muffleMessage")
[10:25:20.508]                       }
[10:25:20.508]                       else if (inherits(cond, "warning")) {
[10:25:20.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.508]                         if (muffled) 
[10:25:20.508]                           invokeRestart("muffleWarning")
[10:25:20.508]                       }
[10:25:20.508]                       else if (inherits(cond, "condition")) {
[10:25:20.508]                         if (!is.null(pattern)) {
[10:25:20.508]                           computeRestarts <- base::computeRestarts
[10:25:20.508]                           grepl <- base::grepl
[10:25:20.508]                           restarts <- computeRestarts(cond)
[10:25:20.508]                           for (restart in restarts) {
[10:25:20.508]                             name <- restart$name
[10:25:20.508]                             if (is.null(name)) 
[10:25:20.508]                               next
[10:25:20.508]                             if (!grepl(pattern, name)) 
[10:25:20.508]                               next
[10:25:20.508]                             invokeRestart(restart)
[10:25:20.508]                             muffled <- TRUE
[10:25:20.508]                             break
[10:25:20.508]                           }
[10:25:20.508]                         }
[10:25:20.508]                       }
[10:25:20.508]                       invisible(muffled)
[10:25:20.508]                     }
[10:25:20.508]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.508]                   }
[10:25:20.508]                 }
[10:25:20.508]                 else {
[10:25:20.508]                   if (TRUE) {
[10:25:20.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.508]                     {
[10:25:20.508]                       inherits <- base::inherits
[10:25:20.508]                       invokeRestart <- base::invokeRestart
[10:25:20.508]                       is.null <- base::is.null
[10:25:20.508]                       muffled <- FALSE
[10:25:20.508]                       if (inherits(cond, "message")) {
[10:25:20.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.508]                         if (muffled) 
[10:25:20.508]                           invokeRestart("muffleMessage")
[10:25:20.508]                       }
[10:25:20.508]                       else if (inherits(cond, "warning")) {
[10:25:20.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.508]                         if (muffled) 
[10:25:20.508]                           invokeRestart("muffleWarning")
[10:25:20.508]                       }
[10:25:20.508]                       else if (inherits(cond, "condition")) {
[10:25:20.508]                         if (!is.null(pattern)) {
[10:25:20.508]                           computeRestarts <- base::computeRestarts
[10:25:20.508]                           grepl <- base::grepl
[10:25:20.508]                           restarts <- computeRestarts(cond)
[10:25:20.508]                           for (restart in restarts) {
[10:25:20.508]                             name <- restart$name
[10:25:20.508]                             if (is.null(name)) 
[10:25:20.508]                               next
[10:25:20.508]                             if (!grepl(pattern, name)) 
[10:25:20.508]                               next
[10:25:20.508]                             invokeRestart(restart)
[10:25:20.508]                             muffled <- TRUE
[10:25:20.508]                             break
[10:25:20.508]                           }
[10:25:20.508]                         }
[10:25:20.508]                       }
[10:25:20.508]                       invisible(muffled)
[10:25:20.508]                     }
[10:25:20.508]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.508]                   }
[10:25:20.508]                 }
[10:25:20.508]             }
[10:25:20.508]         }))
[10:25:20.508]     }, error = function(ex) {
[10:25:20.508]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.508]                 ...future.rng), started = ...future.startTime, 
[10:25:20.508]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.508]             version = "1.8"), class = "FutureResult")
[10:25:20.508]     }, finally = {
[10:25:20.508]         if (!identical(...future.workdir, getwd())) 
[10:25:20.508]             setwd(...future.workdir)
[10:25:20.508]         {
[10:25:20.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.508]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.508]             }
[10:25:20.508]             base::options(...future.oldOptions)
[10:25:20.508]             if (.Platform$OS.type == "windows") {
[10:25:20.508]                 old_names <- names(...future.oldEnvVars)
[10:25:20.508]                 envs <- base::Sys.getenv()
[10:25:20.508]                 names <- names(envs)
[10:25:20.508]                 common <- intersect(names, old_names)
[10:25:20.508]                 added <- setdiff(names, old_names)
[10:25:20.508]                 removed <- setdiff(old_names, names)
[10:25:20.508]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.508]                   envs[common]]
[10:25:20.508]                 NAMES <- toupper(changed)
[10:25:20.508]                 args <- list()
[10:25:20.508]                 for (kk in seq_along(NAMES)) {
[10:25:20.508]                   name <- changed[[kk]]
[10:25:20.508]                   NAME <- NAMES[[kk]]
[10:25:20.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.508]                     next
[10:25:20.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.508]                 }
[10:25:20.508]                 NAMES <- toupper(added)
[10:25:20.508]                 for (kk in seq_along(NAMES)) {
[10:25:20.508]                   name <- added[[kk]]
[10:25:20.508]                   NAME <- NAMES[[kk]]
[10:25:20.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.508]                     next
[10:25:20.508]                   args[[name]] <- ""
[10:25:20.508]                 }
[10:25:20.508]                 NAMES <- toupper(removed)
[10:25:20.508]                 for (kk in seq_along(NAMES)) {
[10:25:20.508]                   name <- removed[[kk]]
[10:25:20.508]                   NAME <- NAMES[[kk]]
[10:25:20.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.508]                     next
[10:25:20.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.508]                 }
[10:25:20.508]                 if (length(args) > 0) 
[10:25:20.508]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.508]             }
[10:25:20.508]             else {
[10:25:20.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.508]             }
[10:25:20.508]             {
[10:25:20.508]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.508]                   0L) {
[10:25:20.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.508]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.508]                   base::options(opts)
[10:25:20.508]                 }
[10:25:20.508]                 {
[10:25:20.508]                   {
[10:25:20.508]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.508]                     NULL
[10:25:20.508]                   }
[10:25:20.508]                   options(future.plan = NULL)
[10:25:20.508]                   if (is.na(NA_character_)) 
[10:25:20.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.508]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.508]                     envir = parent.frame()) 
[10:25:20.508]                   {
[10:25:20.508]                     default_workers <- missing(workers)
[10:25:20.508]                     if (is.function(workers)) 
[10:25:20.508]                       workers <- workers()
[10:25:20.508]                     workers <- structure(as.integer(workers), 
[10:25:20.508]                       class = class(workers))
[10:25:20.508]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.508]                       1L)
[10:25:20.508]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.508]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.508]                       if (default_workers) 
[10:25:20.508]                         supportsMulticore(warn = TRUE)
[10:25:20.508]                       return(sequential(..., envir = envir))
[10:25:20.508]                     }
[10:25:20.508]                     oopts <- options(mc.cores = workers)
[10:25:20.508]                     on.exit(options(oopts))
[10:25:20.508]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.508]                       envir = envir)
[10:25:20.508]                     if (!future$lazy) 
[10:25:20.508]                       future <- run(future)
[10:25:20.508]                     invisible(future)
[10:25:20.508]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.508]                 }
[10:25:20.508]             }
[10:25:20.508]         }
[10:25:20.508]     })
[10:25:20.508]     if (TRUE) {
[10:25:20.508]         base::sink(type = "output", split = FALSE)
[10:25:20.508]         if (TRUE) {
[10:25:20.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.508]         }
[10:25:20.508]         else {
[10:25:20.508]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.508]         }
[10:25:20.508]         base::close(...future.stdout)
[10:25:20.508]         ...future.stdout <- NULL
[10:25:20.508]     }
[10:25:20.508]     ...future.result$conditions <- ...future.conditions
[10:25:20.508]     ...future.result$finished <- base::Sys.time()
[10:25:20.508]     ...future.result
[10:25:20.508] }
[10:25:20.510] assign_globals() ...
[10:25:20.510] List of 2
[10:25:20.510]  $ x                    : int [1:2] 1 2
[10:25:20.510]  $ future.call.arguments:List of 1
[10:25:20.510]   ..$ : num 3
[10:25:20.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.510]  - attr(*, "where")=List of 2
[10:25:20.510]   ..$ x                    :<environment: R_EmptyEnv> 
[10:25:20.510]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.510]  - attr(*, "resolved")= logi FALSE
[10:25:20.510]  - attr(*, "total_size")= num 112
[10:25:20.510]  - attr(*, "already-done")= logi TRUE
[10:25:20.514] - copied ‘x’ to environment
[10:25:20.514] - copied ‘future.call.arguments’ to environment
[10:25:20.514] assign_globals() ... done
[10:25:20.514] requestCore(): workers = 2
[10:25:20.517] MulticoreFuture started
[10:25:20.517] - Launch lazy future ... done
[10:25:20.517] plan(): Setting new future strategy stack:
[10:25:20.517] run() for ‘MulticoreFuture’ ... done
[10:25:20.518] List of future strategies:
[10:25:20.518] 1. sequential:
[10:25:20.518]    - args: function (..., envir = parent.frame())
[10:25:20.518]    - tweaked: FALSE
[10:25:20.518]    - call: NULL
[10:25:20.519] result() for MulticoreFuture ...
[10:25:20.519] plan(): nbrOfWorkers() = 1
[10:25:20.520] plan(): Setting new future strategy stack:
[10:25:20.521] List of future strategies:
[10:25:20.521] 1. multicore:
[10:25:20.521]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.521]    - tweaked: FALSE
[10:25:20.521]    - call: plan(strategy, substitute = FALSE)
[10:25:20.526] plan(): nbrOfWorkers() = 2
[10:25:20.531] result() for MulticoreFuture ...
[10:25:20.531] result() for MulticoreFuture ... done
[10:25:20.531] result() for MulticoreFuture ... done
[10:25:20.531] result() for MulticoreFuture ...
[10:25:20.531] result() for MulticoreFuture ... done
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x558a92094f00>
Arguments '...' exists: TRUE
[10:25:20.532] getGlobalsAndPackages() ...
[10:25:20.532] Searching for globals...
[10:25:20.534] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:20.534] Searching for globals ... DONE
[10:25:20.534] Resolving globals: FALSE
[10:25:20.535] Tweak future expression to call with '...' arguments ...
[10:25:20.535] {
[10:25:20.535]     do.call(function(...) {
[10:25:20.535]         sum(x, ...)
[10:25:20.535]     }, args = future.call.arguments)
[10:25:20.535] }
[10:25:20.535] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.536] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.536] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:20.536] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:20.536] 
[10:25:20.537] getGlobalsAndPackages() ... DONE
[10:25:20.537] run() for ‘Future’ ...
[10:25:20.537] - state: ‘created’
[10:25:20.537] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.541] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.541]   - Field: ‘label’
[10:25:20.541]   - Field: ‘local’
[10:25:20.541]   - Field: ‘owner’
[10:25:20.542]   - Field: ‘envir’
[10:25:20.542]   - Field: ‘workers’
[10:25:20.542]   - Field: ‘packages’
[10:25:20.542]   - Field: ‘gc’
[10:25:20.542]   - Field: ‘job’
[10:25:20.542]   - Field: ‘conditions’
[10:25:20.542]   - Field: ‘expr’
[10:25:20.542]   - Field: ‘uuid’
[10:25:20.542]   - Field: ‘seed’
[10:25:20.543]   - Field: ‘version’
[10:25:20.543]   - Field: ‘result’
[10:25:20.543]   - Field: ‘asynchronous’
[10:25:20.543]   - Field: ‘calls’
[10:25:20.543]   - Field: ‘globals’
[10:25:20.543]   - Field: ‘stdout’
[10:25:20.543]   - Field: ‘earlySignal’
[10:25:20.543]   - Field: ‘lazy’
[10:25:20.543]   - Field: ‘state’
[10:25:20.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.544] - Launch lazy future ...
[10:25:20.544] Packages needed by the future expression (n = 0): <none>
[10:25:20.544] Packages needed by future strategies (n = 0): <none>
[10:25:20.545] {
[10:25:20.545]     {
[10:25:20.545]         {
[10:25:20.545]             ...future.startTime <- base::Sys.time()
[10:25:20.545]             {
[10:25:20.545]                 {
[10:25:20.545]                   {
[10:25:20.545]                     {
[10:25:20.545]                       base::local({
[10:25:20.545]                         has_future <- base::requireNamespace("future", 
[10:25:20.545]                           quietly = TRUE)
[10:25:20.545]                         if (has_future) {
[10:25:20.545]                           ns <- base::getNamespace("future")
[10:25:20.545]                           version <- ns[[".package"]][["version"]]
[10:25:20.545]                           if (is.null(version)) 
[10:25:20.545]                             version <- utils::packageVersion("future")
[10:25:20.545]                         }
[10:25:20.545]                         else {
[10:25:20.545]                           version <- NULL
[10:25:20.545]                         }
[10:25:20.545]                         if (!has_future || version < "1.8.0") {
[10:25:20.545]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.545]                             "", base::R.version$version.string), 
[10:25:20.545]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.545]                               "release", "version")], collapse = " "), 
[10:25:20.545]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.545]                             info)
[10:25:20.545]                           info <- base::paste(info, collapse = "; ")
[10:25:20.545]                           if (!has_future) {
[10:25:20.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.545]                               info)
[10:25:20.545]                           }
[10:25:20.545]                           else {
[10:25:20.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.545]                               info, version)
[10:25:20.545]                           }
[10:25:20.545]                           base::stop(msg)
[10:25:20.545]                         }
[10:25:20.545]                       })
[10:25:20.545]                     }
[10:25:20.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.545]                     base::options(mc.cores = 1L)
[10:25:20.545]                   }
[10:25:20.545]                   options(future.plan = NULL)
[10:25:20.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.545]                 }
[10:25:20.545]                 ...future.workdir <- getwd()
[10:25:20.545]             }
[10:25:20.545]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.545]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.545]         }
[10:25:20.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.545]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.545]             base::names(...future.oldOptions))
[10:25:20.545]     }
[10:25:20.545]     if (FALSE) {
[10:25:20.545]     }
[10:25:20.545]     else {
[10:25:20.545]         if (TRUE) {
[10:25:20.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.545]                 open = "w")
[10:25:20.545]         }
[10:25:20.545]         else {
[10:25:20.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.545]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.545]         }
[10:25:20.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.545]             base::sink(type = "output", split = FALSE)
[10:25:20.545]             base::close(...future.stdout)
[10:25:20.545]         }, add = TRUE)
[10:25:20.545]     }
[10:25:20.545]     ...future.frame <- base::sys.nframe()
[10:25:20.545]     ...future.conditions <- base::list()
[10:25:20.545]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.545]     if (FALSE) {
[10:25:20.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.545]     }
[10:25:20.545]     ...future.result <- base::tryCatch({
[10:25:20.545]         base::withCallingHandlers({
[10:25:20.545]             ...future.value <- base::withVisible(base::local({
[10:25:20.545]                 withCallingHandlers({
[10:25:20.545]                   {
[10:25:20.545]                     do.call(function(...) {
[10:25:20.545]                       sum(x, ...)
[10:25:20.545]                     }, args = future.call.arguments)
[10:25:20.545]                   }
[10:25:20.545]                 }, immediateCondition = function(cond) {
[10:25:20.545]                   save_rds <- function (object, pathname, ...) 
[10:25:20.545]                   {
[10:25:20.545]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.545]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.545]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.545]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.545]                         fi_tmp[["mtime"]])
[10:25:20.545]                     }
[10:25:20.545]                     tryCatch({
[10:25:20.545]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.545]                     }, error = function(ex) {
[10:25:20.545]                       msg <- conditionMessage(ex)
[10:25:20.545]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.545]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.545]                         fi_tmp[["mtime"]], msg)
[10:25:20.545]                       ex$message <- msg
[10:25:20.545]                       stop(ex)
[10:25:20.545]                     })
[10:25:20.545]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.545]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.545]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.545]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.545]                       fi <- file.info(pathname)
[10:25:20.545]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.545]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.545]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.545]                         fi[["size"]], fi[["mtime"]])
[10:25:20.545]                       stop(msg)
[10:25:20.545]                     }
[10:25:20.545]                     invisible(pathname)
[10:25:20.545]                   }
[10:25:20.545]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.545]                     rootPath = tempdir()) 
[10:25:20.545]                   {
[10:25:20.545]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.545]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.545]                       tmpdir = path, fileext = ".rds")
[10:25:20.545]                     save_rds(obj, file)
[10:25:20.545]                   }
[10:25:20.545]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.545]                   {
[10:25:20.545]                     inherits <- base::inherits
[10:25:20.545]                     invokeRestart <- base::invokeRestart
[10:25:20.545]                     is.null <- base::is.null
[10:25:20.545]                     muffled <- FALSE
[10:25:20.545]                     if (inherits(cond, "message")) {
[10:25:20.545]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.545]                       if (muffled) 
[10:25:20.545]                         invokeRestart("muffleMessage")
[10:25:20.545]                     }
[10:25:20.545]                     else if (inherits(cond, "warning")) {
[10:25:20.545]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.545]                       if (muffled) 
[10:25:20.545]                         invokeRestart("muffleWarning")
[10:25:20.545]                     }
[10:25:20.545]                     else if (inherits(cond, "condition")) {
[10:25:20.545]                       if (!is.null(pattern)) {
[10:25:20.545]                         computeRestarts <- base::computeRestarts
[10:25:20.545]                         grepl <- base::grepl
[10:25:20.545]                         restarts <- computeRestarts(cond)
[10:25:20.545]                         for (restart in restarts) {
[10:25:20.545]                           name <- restart$name
[10:25:20.545]                           if (is.null(name)) 
[10:25:20.545]                             next
[10:25:20.545]                           if (!grepl(pattern, name)) 
[10:25:20.545]                             next
[10:25:20.545]                           invokeRestart(restart)
[10:25:20.545]                           muffled <- TRUE
[10:25:20.545]                           break
[10:25:20.545]                         }
[10:25:20.545]                       }
[10:25:20.545]                     }
[10:25:20.545]                     invisible(muffled)
[10:25:20.545]                   }
[10:25:20.545]                   muffleCondition(cond)
[10:25:20.545]                 })
[10:25:20.545]             }))
[10:25:20.545]             future::FutureResult(value = ...future.value$value, 
[10:25:20.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.545]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.545]                     ...future.globalenv.names))
[10:25:20.545]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.545]         }, condition = base::local({
[10:25:20.545]             c <- base::c
[10:25:20.545]             inherits <- base::inherits
[10:25:20.545]             invokeRestart <- base::invokeRestart
[10:25:20.545]             length <- base::length
[10:25:20.545]             list <- base::list
[10:25:20.545]             seq.int <- base::seq.int
[10:25:20.545]             signalCondition <- base::signalCondition
[10:25:20.545]             sys.calls <- base::sys.calls
[10:25:20.545]             `[[` <- base::`[[`
[10:25:20.545]             `+` <- base::`+`
[10:25:20.545]             `<<-` <- base::`<<-`
[10:25:20.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.545]                   3L)]
[10:25:20.545]             }
[10:25:20.545]             function(cond) {
[10:25:20.545]                 is_error <- inherits(cond, "error")
[10:25:20.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.545]                   NULL)
[10:25:20.545]                 if (is_error) {
[10:25:20.545]                   sessionInformation <- function() {
[10:25:20.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.545]                       search = base::search(), system = base::Sys.info())
[10:25:20.545]                   }
[10:25:20.545]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.545]                     cond$call), session = sessionInformation(), 
[10:25:20.545]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.545]                   signalCondition(cond)
[10:25:20.545]                 }
[10:25:20.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.545]                 "immediateCondition"))) {
[10:25:20.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.545]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.545]                   if (TRUE && !signal) {
[10:25:20.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.545]                     {
[10:25:20.545]                       inherits <- base::inherits
[10:25:20.545]                       invokeRestart <- base::invokeRestart
[10:25:20.545]                       is.null <- base::is.null
[10:25:20.545]                       muffled <- FALSE
[10:25:20.545]                       if (inherits(cond, "message")) {
[10:25:20.545]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.545]                         if (muffled) 
[10:25:20.545]                           invokeRestart("muffleMessage")
[10:25:20.545]                       }
[10:25:20.545]                       else if (inherits(cond, "warning")) {
[10:25:20.545]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.545]                         if (muffled) 
[10:25:20.545]                           invokeRestart("muffleWarning")
[10:25:20.545]                       }
[10:25:20.545]                       else if (inherits(cond, "condition")) {
[10:25:20.545]                         if (!is.null(pattern)) {
[10:25:20.545]                           computeRestarts <- base::computeRestarts
[10:25:20.545]                           grepl <- base::grepl
[10:25:20.545]                           restarts <- computeRestarts(cond)
[10:25:20.545]                           for (restart in restarts) {
[10:25:20.545]                             name <- restart$name
[10:25:20.545]                             if (is.null(name)) 
[10:25:20.545]                               next
[10:25:20.545]                             if (!grepl(pattern, name)) 
[10:25:20.545]                               next
[10:25:20.545]                             invokeRestart(restart)
[10:25:20.545]                             muffled <- TRUE
[10:25:20.545]                             break
[10:25:20.545]                           }
[10:25:20.545]                         }
[10:25:20.545]                       }
[10:25:20.545]                       invisible(muffled)
[10:25:20.545]                     }
[10:25:20.545]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.545]                   }
[10:25:20.545]                 }
[10:25:20.545]                 else {
[10:25:20.545]                   if (TRUE) {
[10:25:20.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.545]                     {
[10:25:20.545]                       inherits <- base::inherits
[10:25:20.545]                       invokeRestart <- base::invokeRestart
[10:25:20.545]                       is.null <- base::is.null
[10:25:20.545]                       muffled <- FALSE
[10:25:20.545]                       if (inherits(cond, "message")) {
[10:25:20.545]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.545]                         if (muffled) 
[10:25:20.545]                           invokeRestart("muffleMessage")
[10:25:20.545]                       }
[10:25:20.545]                       else if (inherits(cond, "warning")) {
[10:25:20.545]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.545]                         if (muffled) 
[10:25:20.545]                           invokeRestart("muffleWarning")
[10:25:20.545]                       }
[10:25:20.545]                       else if (inherits(cond, "condition")) {
[10:25:20.545]                         if (!is.null(pattern)) {
[10:25:20.545]                           computeRestarts <- base::computeRestarts
[10:25:20.545]                           grepl <- base::grepl
[10:25:20.545]                           restarts <- computeRestarts(cond)
[10:25:20.545]                           for (restart in restarts) {
[10:25:20.545]                             name <- restart$name
[10:25:20.545]                             if (is.null(name)) 
[10:25:20.545]                               next
[10:25:20.545]                             if (!grepl(pattern, name)) 
[10:25:20.545]                               next
[10:25:20.545]                             invokeRestart(restart)
[10:25:20.545]                             muffled <- TRUE
[10:25:20.545]                             break
[10:25:20.545]                           }
[10:25:20.545]                         }
[10:25:20.545]                       }
[10:25:20.545]                       invisible(muffled)
[10:25:20.545]                     }
[10:25:20.545]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.545]                   }
[10:25:20.545]                 }
[10:25:20.545]             }
[10:25:20.545]         }))
[10:25:20.545]     }, error = function(ex) {
[10:25:20.545]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.545]                 ...future.rng), started = ...future.startTime, 
[10:25:20.545]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.545]             version = "1.8"), class = "FutureResult")
[10:25:20.545]     }, finally = {
[10:25:20.545]         if (!identical(...future.workdir, getwd())) 
[10:25:20.545]             setwd(...future.workdir)
[10:25:20.545]         {
[10:25:20.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.545]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.545]             }
[10:25:20.545]             base::options(...future.oldOptions)
[10:25:20.545]             if (.Platform$OS.type == "windows") {
[10:25:20.545]                 old_names <- names(...future.oldEnvVars)
[10:25:20.545]                 envs <- base::Sys.getenv()
[10:25:20.545]                 names <- names(envs)
[10:25:20.545]                 common <- intersect(names, old_names)
[10:25:20.545]                 added <- setdiff(names, old_names)
[10:25:20.545]                 removed <- setdiff(old_names, names)
[10:25:20.545]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.545]                   envs[common]]
[10:25:20.545]                 NAMES <- toupper(changed)
[10:25:20.545]                 args <- list()
[10:25:20.545]                 for (kk in seq_along(NAMES)) {
[10:25:20.545]                   name <- changed[[kk]]
[10:25:20.545]                   NAME <- NAMES[[kk]]
[10:25:20.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.545]                     next
[10:25:20.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.545]                 }
[10:25:20.545]                 NAMES <- toupper(added)
[10:25:20.545]                 for (kk in seq_along(NAMES)) {
[10:25:20.545]                   name <- added[[kk]]
[10:25:20.545]                   NAME <- NAMES[[kk]]
[10:25:20.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.545]                     next
[10:25:20.545]                   args[[name]] <- ""
[10:25:20.545]                 }
[10:25:20.545]                 NAMES <- toupper(removed)
[10:25:20.545]                 for (kk in seq_along(NAMES)) {
[10:25:20.545]                   name <- removed[[kk]]
[10:25:20.545]                   NAME <- NAMES[[kk]]
[10:25:20.545]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.545]                     next
[10:25:20.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.545]                 }
[10:25:20.545]                 if (length(args) > 0) 
[10:25:20.545]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.545]             }
[10:25:20.545]             else {
[10:25:20.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.545]             }
[10:25:20.545]             {
[10:25:20.545]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.545]                   0L) {
[10:25:20.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.545]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.545]                   base::options(opts)
[10:25:20.545]                 }
[10:25:20.545]                 {
[10:25:20.545]                   {
[10:25:20.545]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.545]                     NULL
[10:25:20.545]                   }
[10:25:20.545]                   options(future.plan = NULL)
[10:25:20.545]                   if (is.na(NA_character_)) 
[10:25:20.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.545]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.545]                     envir = parent.frame()) 
[10:25:20.545]                   {
[10:25:20.545]                     default_workers <- missing(workers)
[10:25:20.545]                     if (is.function(workers)) 
[10:25:20.545]                       workers <- workers()
[10:25:20.545]                     workers <- structure(as.integer(workers), 
[10:25:20.545]                       class = class(workers))
[10:25:20.545]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.545]                       1L)
[10:25:20.545]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.545]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.545]                       if (default_workers) 
[10:25:20.545]                         supportsMulticore(warn = TRUE)
[10:25:20.545]                       return(sequential(..., envir = envir))
[10:25:20.545]                     }
[10:25:20.545]                     oopts <- options(mc.cores = workers)
[10:25:20.545]                     on.exit(options(oopts))
[10:25:20.545]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.545]                       envir = envir)
[10:25:20.545]                     if (!future$lazy) 
[10:25:20.545]                       future <- run(future)
[10:25:20.545]                     invisible(future)
[10:25:20.545]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.545]                 }
[10:25:20.545]             }
[10:25:20.545]         }
[10:25:20.545]     })
[10:25:20.545]     if (TRUE) {
[10:25:20.545]         base::sink(type = "output", split = FALSE)
[10:25:20.545]         if (TRUE) {
[10:25:20.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.545]         }
[10:25:20.545]         else {
[10:25:20.545]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.545]         }
[10:25:20.545]         base::close(...future.stdout)
[10:25:20.545]         ...future.stdout <- NULL
[10:25:20.545]     }
[10:25:20.545]     ...future.result$conditions <- ...future.conditions
[10:25:20.545]     ...future.result$finished <- base::Sys.time()
[10:25:20.545]     ...future.result
[10:25:20.545] }
[10:25:20.547] assign_globals() ...
[10:25:20.547] List of 2
[10:25:20.547]  $ x                    : int [1:2] 1 2
[10:25:20.547]  $ future.call.arguments:List of 1
[10:25:20.547]   ..$ : num 3
[10:25:20.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.547]  - attr(*, "where")=List of 2
[10:25:20.547]   ..$ x                    :<environment: R_EmptyEnv> 
[10:25:20.547]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.547]  - attr(*, "resolved")= logi FALSE
[10:25:20.547]  - attr(*, "total_size")= num 112
[10:25:20.547]  - attr(*, "already-done")= logi TRUE
[10:25:20.552] - copied ‘x’ to environment
[10:25:20.552] - copied ‘future.call.arguments’ to environment
[10:25:20.552] assign_globals() ... done
[10:25:20.554] requestCore(): workers = 2
[10:25:20.556] MulticoreFuture started
[10:25:20.556] - Launch lazy future ... done
[10:25:20.557] run() for ‘MulticoreFuture’ ... done
[10:25:20.557] result() for MulticoreFuture ...
[10:25:20.557] plan(): Setting new future strategy stack:
[10:25:20.558] List of future strategies:
[10:25:20.558] 1. sequential:
[10:25:20.558]    - args: function (..., envir = parent.frame())
[10:25:20.558]    - tweaked: FALSE
[10:25:20.558]    - call: NULL
[10:25:20.559] plan(): nbrOfWorkers() = 1
[10:25:20.561] plan(): Setting new future strategy stack:
[10:25:20.561] List of future strategies:
[10:25:20.561] 1. multicore:
[10:25:20.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.561]    - tweaked: FALSE
[10:25:20.561]    - call: plan(strategy, substitute = FALSE)
[10:25:20.566] plan(): nbrOfWorkers() = 2
[10:25:20.567] result() for MulticoreFuture ...
[10:25:20.567] result() for MulticoreFuture ... done
[10:25:20.567] result() for MulticoreFuture ... done
[10:25:20.567] result() for MulticoreFuture ...
[10:25:20.567] result() for MulticoreFuture ... done
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x558a921f5f00>
Arguments '...' exists: FALSE
[10:25:20.568] getGlobalsAndPackages() ...
[10:25:20.568] Searching for globals...
[10:25:20.570] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[10:25:20.570] Searching for globals ... DONE
[10:25:20.570] Resolving globals: FALSE
[10:25:20.571] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.572] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.572] - globals: [2] ‘x’, ‘y’
[10:25:20.572] 
[10:25:20.572] getGlobalsAndPackages() ... DONE
[10:25:20.572] run() for ‘Future’ ...
[10:25:20.572] - state: ‘created’
[10:25:20.573] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.577] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.577] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.577]   - Field: ‘label’
[10:25:20.577]   - Field: ‘local’
[10:25:20.577]   - Field: ‘owner’
[10:25:20.577]   - Field: ‘envir’
[10:25:20.577]   - Field: ‘workers’
[10:25:20.578]   - Field: ‘packages’
[10:25:20.578]   - Field: ‘gc’
[10:25:20.578]   - Field: ‘job’
[10:25:20.578]   - Field: ‘conditions’
[10:25:20.578]   - Field: ‘expr’
[10:25:20.578]   - Field: ‘uuid’
[10:25:20.578]   - Field: ‘seed’
[10:25:20.578]   - Field: ‘version’
[10:25:20.578]   - Field: ‘result’
[10:25:20.579]   - Field: ‘asynchronous’
[10:25:20.579]   - Field: ‘calls’
[10:25:20.579]   - Field: ‘globals’
[10:25:20.579]   - Field: ‘stdout’
[10:25:20.579]   - Field: ‘earlySignal’
[10:25:20.579]   - Field: ‘lazy’
[10:25:20.579]   - Field: ‘state’
[10:25:20.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.579] - Launch lazy future ...
[10:25:20.580] Packages needed by the future expression (n = 0): <none>
[10:25:20.580] Packages needed by future strategies (n = 0): <none>
[10:25:20.580] {
[10:25:20.580]     {
[10:25:20.580]         {
[10:25:20.580]             ...future.startTime <- base::Sys.time()
[10:25:20.580]             {
[10:25:20.580]                 {
[10:25:20.580]                   {
[10:25:20.580]                     {
[10:25:20.580]                       base::local({
[10:25:20.580]                         has_future <- base::requireNamespace("future", 
[10:25:20.580]                           quietly = TRUE)
[10:25:20.580]                         if (has_future) {
[10:25:20.580]                           ns <- base::getNamespace("future")
[10:25:20.580]                           version <- ns[[".package"]][["version"]]
[10:25:20.580]                           if (is.null(version)) 
[10:25:20.580]                             version <- utils::packageVersion("future")
[10:25:20.580]                         }
[10:25:20.580]                         else {
[10:25:20.580]                           version <- NULL
[10:25:20.580]                         }
[10:25:20.580]                         if (!has_future || version < "1.8.0") {
[10:25:20.580]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.580]                             "", base::R.version$version.string), 
[10:25:20.580]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.580]                               "release", "version")], collapse = " "), 
[10:25:20.580]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.580]                             info)
[10:25:20.580]                           info <- base::paste(info, collapse = "; ")
[10:25:20.580]                           if (!has_future) {
[10:25:20.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.580]                               info)
[10:25:20.580]                           }
[10:25:20.580]                           else {
[10:25:20.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.580]                               info, version)
[10:25:20.580]                           }
[10:25:20.580]                           base::stop(msg)
[10:25:20.580]                         }
[10:25:20.580]                       })
[10:25:20.580]                     }
[10:25:20.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.580]                     base::options(mc.cores = 1L)
[10:25:20.580]                   }
[10:25:20.580]                   options(future.plan = NULL)
[10:25:20.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.580]                 }
[10:25:20.580]                 ...future.workdir <- getwd()
[10:25:20.580]             }
[10:25:20.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.580]         }
[10:25:20.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.580]             base::names(...future.oldOptions))
[10:25:20.580]     }
[10:25:20.580]     if (FALSE) {
[10:25:20.580]     }
[10:25:20.580]     else {
[10:25:20.580]         if (TRUE) {
[10:25:20.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.580]                 open = "w")
[10:25:20.580]         }
[10:25:20.580]         else {
[10:25:20.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.580]         }
[10:25:20.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.580]             base::sink(type = "output", split = FALSE)
[10:25:20.580]             base::close(...future.stdout)
[10:25:20.580]         }, add = TRUE)
[10:25:20.580]     }
[10:25:20.580]     ...future.frame <- base::sys.nframe()
[10:25:20.580]     ...future.conditions <- base::list()
[10:25:20.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.580]     if (FALSE) {
[10:25:20.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.580]     }
[10:25:20.580]     ...future.result <- base::tryCatch({
[10:25:20.580]         base::withCallingHandlers({
[10:25:20.580]             ...future.value <- base::withVisible(base::local({
[10:25:20.580]                 withCallingHandlers({
[10:25:20.580]                   {
[10:25:20.580]                     sum(x, y)
[10:25:20.580]                   }
[10:25:20.580]                 }, immediateCondition = function(cond) {
[10:25:20.580]                   save_rds <- function (object, pathname, ...) 
[10:25:20.580]                   {
[10:25:20.580]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.580]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.580]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.580]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.580]                         fi_tmp[["mtime"]])
[10:25:20.580]                     }
[10:25:20.580]                     tryCatch({
[10:25:20.580]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.580]                     }, error = function(ex) {
[10:25:20.580]                       msg <- conditionMessage(ex)
[10:25:20.580]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.580]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.580]                         fi_tmp[["mtime"]], msg)
[10:25:20.580]                       ex$message <- msg
[10:25:20.580]                       stop(ex)
[10:25:20.580]                     })
[10:25:20.580]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.580]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.580]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.580]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.580]                       fi <- file.info(pathname)
[10:25:20.580]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.580]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.580]                         fi[["size"]], fi[["mtime"]])
[10:25:20.580]                       stop(msg)
[10:25:20.580]                     }
[10:25:20.580]                     invisible(pathname)
[10:25:20.580]                   }
[10:25:20.580]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.580]                     rootPath = tempdir()) 
[10:25:20.580]                   {
[10:25:20.580]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.580]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.580]                       tmpdir = path, fileext = ".rds")
[10:25:20.580]                     save_rds(obj, file)
[10:25:20.580]                   }
[10:25:20.580]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.580]                   {
[10:25:20.580]                     inherits <- base::inherits
[10:25:20.580]                     invokeRestart <- base::invokeRestart
[10:25:20.580]                     is.null <- base::is.null
[10:25:20.580]                     muffled <- FALSE
[10:25:20.580]                     if (inherits(cond, "message")) {
[10:25:20.580]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.580]                       if (muffled) 
[10:25:20.580]                         invokeRestart("muffleMessage")
[10:25:20.580]                     }
[10:25:20.580]                     else if (inherits(cond, "warning")) {
[10:25:20.580]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.580]                       if (muffled) 
[10:25:20.580]                         invokeRestart("muffleWarning")
[10:25:20.580]                     }
[10:25:20.580]                     else if (inherits(cond, "condition")) {
[10:25:20.580]                       if (!is.null(pattern)) {
[10:25:20.580]                         computeRestarts <- base::computeRestarts
[10:25:20.580]                         grepl <- base::grepl
[10:25:20.580]                         restarts <- computeRestarts(cond)
[10:25:20.580]                         for (restart in restarts) {
[10:25:20.580]                           name <- restart$name
[10:25:20.580]                           if (is.null(name)) 
[10:25:20.580]                             next
[10:25:20.580]                           if (!grepl(pattern, name)) 
[10:25:20.580]                             next
[10:25:20.580]                           invokeRestart(restart)
[10:25:20.580]                           muffled <- TRUE
[10:25:20.580]                           break
[10:25:20.580]                         }
[10:25:20.580]                       }
[10:25:20.580]                     }
[10:25:20.580]                     invisible(muffled)
[10:25:20.580]                   }
[10:25:20.580]                   muffleCondition(cond)
[10:25:20.580]                 })
[10:25:20.580]             }))
[10:25:20.580]             future::FutureResult(value = ...future.value$value, 
[10:25:20.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.580]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.580]                     ...future.globalenv.names))
[10:25:20.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.580]         }, condition = base::local({
[10:25:20.580]             c <- base::c
[10:25:20.580]             inherits <- base::inherits
[10:25:20.580]             invokeRestart <- base::invokeRestart
[10:25:20.580]             length <- base::length
[10:25:20.580]             list <- base::list
[10:25:20.580]             seq.int <- base::seq.int
[10:25:20.580]             signalCondition <- base::signalCondition
[10:25:20.580]             sys.calls <- base::sys.calls
[10:25:20.580]             `[[` <- base::`[[`
[10:25:20.580]             `+` <- base::`+`
[10:25:20.580]             `<<-` <- base::`<<-`
[10:25:20.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.580]                   3L)]
[10:25:20.580]             }
[10:25:20.580]             function(cond) {
[10:25:20.580]                 is_error <- inherits(cond, "error")
[10:25:20.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.580]                   NULL)
[10:25:20.580]                 if (is_error) {
[10:25:20.580]                   sessionInformation <- function() {
[10:25:20.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.580]                       search = base::search(), system = base::Sys.info())
[10:25:20.580]                   }
[10:25:20.580]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.580]                     cond$call), session = sessionInformation(), 
[10:25:20.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.580]                   signalCondition(cond)
[10:25:20.580]                 }
[10:25:20.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.580]                 "immediateCondition"))) {
[10:25:20.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.580]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.580]                   if (TRUE && !signal) {
[10:25:20.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.580]                     {
[10:25:20.580]                       inherits <- base::inherits
[10:25:20.580]                       invokeRestart <- base::invokeRestart
[10:25:20.580]                       is.null <- base::is.null
[10:25:20.580]                       muffled <- FALSE
[10:25:20.580]                       if (inherits(cond, "message")) {
[10:25:20.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.580]                         if (muffled) 
[10:25:20.580]                           invokeRestart("muffleMessage")
[10:25:20.580]                       }
[10:25:20.580]                       else if (inherits(cond, "warning")) {
[10:25:20.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.580]                         if (muffled) 
[10:25:20.580]                           invokeRestart("muffleWarning")
[10:25:20.580]                       }
[10:25:20.580]                       else if (inherits(cond, "condition")) {
[10:25:20.580]                         if (!is.null(pattern)) {
[10:25:20.580]                           computeRestarts <- base::computeRestarts
[10:25:20.580]                           grepl <- base::grepl
[10:25:20.580]                           restarts <- computeRestarts(cond)
[10:25:20.580]                           for (restart in restarts) {
[10:25:20.580]                             name <- restart$name
[10:25:20.580]                             if (is.null(name)) 
[10:25:20.580]                               next
[10:25:20.580]                             if (!grepl(pattern, name)) 
[10:25:20.580]                               next
[10:25:20.580]                             invokeRestart(restart)
[10:25:20.580]                             muffled <- TRUE
[10:25:20.580]                             break
[10:25:20.580]                           }
[10:25:20.580]                         }
[10:25:20.580]                       }
[10:25:20.580]                       invisible(muffled)
[10:25:20.580]                     }
[10:25:20.580]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.580]                   }
[10:25:20.580]                 }
[10:25:20.580]                 else {
[10:25:20.580]                   if (TRUE) {
[10:25:20.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.580]                     {
[10:25:20.580]                       inherits <- base::inherits
[10:25:20.580]                       invokeRestart <- base::invokeRestart
[10:25:20.580]                       is.null <- base::is.null
[10:25:20.580]                       muffled <- FALSE
[10:25:20.580]                       if (inherits(cond, "message")) {
[10:25:20.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.580]                         if (muffled) 
[10:25:20.580]                           invokeRestart("muffleMessage")
[10:25:20.580]                       }
[10:25:20.580]                       else if (inherits(cond, "warning")) {
[10:25:20.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.580]                         if (muffled) 
[10:25:20.580]                           invokeRestart("muffleWarning")
[10:25:20.580]                       }
[10:25:20.580]                       else if (inherits(cond, "condition")) {
[10:25:20.580]                         if (!is.null(pattern)) {
[10:25:20.580]                           computeRestarts <- base::computeRestarts
[10:25:20.580]                           grepl <- base::grepl
[10:25:20.580]                           restarts <- computeRestarts(cond)
[10:25:20.580]                           for (restart in restarts) {
[10:25:20.580]                             name <- restart$name
[10:25:20.580]                             if (is.null(name)) 
[10:25:20.580]                               next
[10:25:20.580]                             if (!grepl(pattern, name)) 
[10:25:20.580]                               next
[10:25:20.580]                             invokeRestart(restart)
[10:25:20.580]                             muffled <- TRUE
[10:25:20.580]                             break
[10:25:20.580]                           }
[10:25:20.580]                         }
[10:25:20.580]                       }
[10:25:20.580]                       invisible(muffled)
[10:25:20.580]                     }
[10:25:20.580]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.580]                   }
[10:25:20.580]                 }
[10:25:20.580]             }
[10:25:20.580]         }))
[10:25:20.580]     }, error = function(ex) {
[10:25:20.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.580]                 ...future.rng), started = ...future.startTime, 
[10:25:20.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.580]             version = "1.8"), class = "FutureResult")
[10:25:20.580]     }, finally = {
[10:25:20.580]         if (!identical(...future.workdir, getwd())) 
[10:25:20.580]             setwd(...future.workdir)
[10:25:20.580]         {
[10:25:20.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.580]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.580]             }
[10:25:20.580]             base::options(...future.oldOptions)
[10:25:20.580]             if (.Platform$OS.type == "windows") {
[10:25:20.580]                 old_names <- names(...future.oldEnvVars)
[10:25:20.580]                 envs <- base::Sys.getenv()
[10:25:20.580]                 names <- names(envs)
[10:25:20.580]                 common <- intersect(names, old_names)
[10:25:20.580]                 added <- setdiff(names, old_names)
[10:25:20.580]                 removed <- setdiff(old_names, names)
[10:25:20.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.580]                   envs[common]]
[10:25:20.580]                 NAMES <- toupper(changed)
[10:25:20.580]                 args <- list()
[10:25:20.580]                 for (kk in seq_along(NAMES)) {
[10:25:20.580]                   name <- changed[[kk]]
[10:25:20.580]                   NAME <- NAMES[[kk]]
[10:25:20.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.580]                     next
[10:25:20.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.580]                 }
[10:25:20.580]                 NAMES <- toupper(added)
[10:25:20.580]                 for (kk in seq_along(NAMES)) {
[10:25:20.580]                   name <- added[[kk]]
[10:25:20.580]                   NAME <- NAMES[[kk]]
[10:25:20.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.580]                     next
[10:25:20.580]                   args[[name]] <- ""
[10:25:20.580]                 }
[10:25:20.580]                 NAMES <- toupper(removed)
[10:25:20.580]                 for (kk in seq_along(NAMES)) {
[10:25:20.580]                   name <- removed[[kk]]
[10:25:20.580]                   NAME <- NAMES[[kk]]
[10:25:20.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.580]                     next
[10:25:20.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.580]                 }
[10:25:20.580]                 if (length(args) > 0) 
[10:25:20.580]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.580]             }
[10:25:20.580]             else {
[10:25:20.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.580]             }
[10:25:20.580]             {
[10:25:20.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.580]                   0L) {
[10:25:20.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.580]                   base::options(opts)
[10:25:20.580]                 }
[10:25:20.580]                 {
[10:25:20.580]                   {
[10:25:20.580]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.580]                     NULL
[10:25:20.580]                   }
[10:25:20.580]                   options(future.plan = NULL)
[10:25:20.580]                   if (is.na(NA_character_)) 
[10:25:20.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.580]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.580]                     envir = parent.frame()) 
[10:25:20.580]                   {
[10:25:20.580]                     default_workers <- missing(workers)
[10:25:20.580]                     if (is.function(workers)) 
[10:25:20.580]                       workers <- workers()
[10:25:20.580]                     workers <- structure(as.integer(workers), 
[10:25:20.580]                       class = class(workers))
[10:25:20.580]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.580]                       1L)
[10:25:20.580]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.580]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.580]                       if (default_workers) 
[10:25:20.580]                         supportsMulticore(warn = TRUE)
[10:25:20.580]                       return(sequential(..., envir = envir))
[10:25:20.580]                     }
[10:25:20.580]                     oopts <- options(mc.cores = workers)
[10:25:20.580]                     on.exit(options(oopts))
[10:25:20.580]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.580]                       envir = envir)
[10:25:20.580]                     if (!future$lazy) 
[10:25:20.580]                       future <- run(future)
[10:25:20.580]                     invisible(future)
[10:25:20.580]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.580]                 }
[10:25:20.580]             }
[10:25:20.580]         }
[10:25:20.580]     })
[10:25:20.580]     if (TRUE) {
[10:25:20.580]         base::sink(type = "output", split = FALSE)
[10:25:20.580]         if (TRUE) {
[10:25:20.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.580]         }
[10:25:20.580]         else {
[10:25:20.580]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.580]         }
[10:25:20.580]         base::close(...future.stdout)
[10:25:20.580]         ...future.stdout <- NULL
[10:25:20.580]     }
[10:25:20.580]     ...future.result$conditions <- ...future.conditions
[10:25:20.580]     ...future.result$finished <- base::Sys.time()
[10:25:20.580]     ...future.result
[10:25:20.580] }
[10:25:20.583] assign_globals() ...
[10:25:20.583] List of 2
[10:25:20.583]  $ x: int [1:2] 1 2
[10:25:20.583]  $ y: num 3
[10:25:20.583]  - attr(*, "where")=List of 2
[10:25:20.583]   ..$ x:<environment: R_EmptyEnv> 
[10:25:20.583]   ..$ y:<environment: R_EmptyEnv> 
[10:25:20.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.583]  - attr(*, "resolved")= logi FALSE
[10:25:20.583]  - attr(*, "total_size")= num 112
[10:25:20.583]  - attr(*, "already-done")= logi TRUE
[10:25:20.587] - copied ‘x’ to environment
[10:25:20.587] - copied ‘y’ to environment
[10:25:20.587] assign_globals() ... done
[10:25:20.587] requestCore(): workers = 2
[10:25:20.589] MulticoreFuture started
[10:25:20.589] - Launch lazy future ... done
[10:25:20.590] run() for ‘MulticoreFuture’ ... done
[10:25:20.590] result() for MulticoreFuture ...
[10:25:20.590] plan(): Setting new future strategy stack:
[10:25:20.590] List of future strategies:
[10:25:20.590] 1. sequential:
[10:25:20.590]    - args: function (..., envir = parent.frame())
[10:25:20.590]    - tweaked: FALSE
[10:25:20.590]    - call: NULL
[10:25:20.591] plan(): nbrOfWorkers() = 1
[10:25:20.593] plan(): Setting new future strategy stack:
[10:25:20.593] List of future strategies:
[10:25:20.593] 1. multicore:
[10:25:20.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.593]    - tweaked: FALSE
[10:25:20.593]    - call: plan(strategy, substitute = FALSE)
[10:25:20.598] plan(): nbrOfWorkers() = 2
[10:25:20.599] result() for MulticoreFuture ...
[10:25:20.599] result() for MulticoreFuture ... done
[10:25:20.599] result() for MulticoreFuture ... done
[10:25:20.599] result() for MulticoreFuture ...
[10:25:20.599] result() for MulticoreFuture ... done
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x558a923df5d8>
Arguments '...' exists: FALSE
[10:25:20.600] getGlobalsAndPackages() ...
[10:25:20.600] Searching for globals...
[10:25:20.602] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[10:25:20.602] Searching for globals ... DONE
[10:25:20.603] Resolving globals: FALSE
[10:25:20.603] Tweak future expression to call with '...' arguments ...
[10:25:20.603] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:20.604] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.604] - globals: [2] ‘x’, ‘y’
[10:25:20.604] 
[10:25:20.604] getGlobalsAndPackages() ... DONE
[10:25:20.604] run() for ‘Future’ ...
[10:25:20.605] - state: ‘created’
[10:25:20.605] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.609]   - Field: ‘label’
[10:25:20.609]   - Field: ‘local’
[10:25:20.609]   - Field: ‘owner’
[10:25:20.609]   - Field: ‘envir’
[10:25:20.609]   - Field: ‘workers’
[10:25:20.610]   - Field: ‘packages’
[10:25:20.610]   - Field: ‘gc’
[10:25:20.610]   - Field: ‘job’
[10:25:20.610]   - Field: ‘conditions’
[10:25:20.610]   - Field: ‘expr’
[10:25:20.610]   - Field: ‘uuid’
[10:25:20.610]   - Field: ‘seed’
[10:25:20.610]   - Field: ‘version’
[10:25:20.610]   - Field: ‘result’
[10:25:20.611]   - Field: ‘asynchronous’
[10:25:20.611]   - Field: ‘calls’
[10:25:20.611]   - Field: ‘globals’
[10:25:20.611]   - Field: ‘stdout’
[10:25:20.611]   - Field: ‘earlySignal’
[10:25:20.611]   - Field: ‘lazy’
[10:25:20.611]   - Field: ‘state’
[10:25:20.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.611] - Launch lazy future ...
[10:25:20.612] Packages needed by the future expression (n = 0): <none>
[10:25:20.612] Packages needed by future strategies (n = 0): <none>
[10:25:20.612] {
[10:25:20.612]     {
[10:25:20.612]         {
[10:25:20.612]             ...future.startTime <- base::Sys.time()
[10:25:20.612]             {
[10:25:20.612]                 {
[10:25:20.612]                   {
[10:25:20.612]                     {
[10:25:20.612]                       base::local({
[10:25:20.612]                         has_future <- base::requireNamespace("future", 
[10:25:20.612]                           quietly = TRUE)
[10:25:20.612]                         if (has_future) {
[10:25:20.612]                           ns <- base::getNamespace("future")
[10:25:20.612]                           version <- ns[[".package"]][["version"]]
[10:25:20.612]                           if (is.null(version)) 
[10:25:20.612]                             version <- utils::packageVersion("future")
[10:25:20.612]                         }
[10:25:20.612]                         else {
[10:25:20.612]                           version <- NULL
[10:25:20.612]                         }
[10:25:20.612]                         if (!has_future || version < "1.8.0") {
[10:25:20.612]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.612]                             "", base::R.version$version.string), 
[10:25:20.612]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.612]                               "release", "version")], collapse = " "), 
[10:25:20.612]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.612]                             info)
[10:25:20.612]                           info <- base::paste(info, collapse = "; ")
[10:25:20.612]                           if (!has_future) {
[10:25:20.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.612]                               info)
[10:25:20.612]                           }
[10:25:20.612]                           else {
[10:25:20.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.612]                               info, version)
[10:25:20.612]                           }
[10:25:20.612]                           base::stop(msg)
[10:25:20.612]                         }
[10:25:20.612]                       })
[10:25:20.612]                     }
[10:25:20.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.612]                     base::options(mc.cores = 1L)
[10:25:20.612]                   }
[10:25:20.612]                   options(future.plan = NULL)
[10:25:20.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.612]                 }
[10:25:20.612]                 ...future.workdir <- getwd()
[10:25:20.612]             }
[10:25:20.612]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.612]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.612]         }
[10:25:20.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.612]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.612]             base::names(...future.oldOptions))
[10:25:20.612]     }
[10:25:20.612]     if (FALSE) {
[10:25:20.612]     }
[10:25:20.612]     else {
[10:25:20.612]         if (TRUE) {
[10:25:20.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.612]                 open = "w")
[10:25:20.612]         }
[10:25:20.612]         else {
[10:25:20.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.612]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.612]         }
[10:25:20.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.612]             base::sink(type = "output", split = FALSE)
[10:25:20.612]             base::close(...future.stdout)
[10:25:20.612]         }, add = TRUE)
[10:25:20.612]     }
[10:25:20.612]     ...future.frame <- base::sys.nframe()
[10:25:20.612]     ...future.conditions <- base::list()
[10:25:20.612]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.612]     if (FALSE) {
[10:25:20.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.612]     }
[10:25:20.612]     ...future.result <- base::tryCatch({
[10:25:20.612]         base::withCallingHandlers({
[10:25:20.612]             ...future.value <- base::withVisible(base::local({
[10:25:20.612]                 withCallingHandlers({
[10:25:20.612]                   {
[10:25:20.612]                     sum(x, y, ...)
[10:25:20.612]                   }
[10:25:20.612]                 }, immediateCondition = function(cond) {
[10:25:20.612]                   save_rds <- function (object, pathname, ...) 
[10:25:20.612]                   {
[10:25:20.612]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.612]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.612]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.612]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.612]                         fi_tmp[["mtime"]])
[10:25:20.612]                     }
[10:25:20.612]                     tryCatch({
[10:25:20.612]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.612]                     }, error = function(ex) {
[10:25:20.612]                       msg <- conditionMessage(ex)
[10:25:20.612]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.612]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.612]                         fi_tmp[["mtime"]], msg)
[10:25:20.612]                       ex$message <- msg
[10:25:20.612]                       stop(ex)
[10:25:20.612]                     })
[10:25:20.612]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.612]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.612]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.612]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.612]                       fi <- file.info(pathname)
[10:25:20.612]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.612]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.612]                         fi[["size"]], fi[["mtime"]])
[10:25:20.612]                       stop(msg)
[10:25:20.612]                     }
[10:25:20.612]                     invisible(pathname)
[10:25:20.612]                   }
[10:25:20.612]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.612]                     rootPath = tempdir()) 
[10:25:20.612]                   {
[10:25:20.612]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.612]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.612]                       tmpdir = path, fileext = ".rds")
[10:25:20.612]                     save_rds(obj, file)
[10:25:20.612]                   }
[10:25:20.612]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.612]                   {
[10:25:20.612]                     inherits <- base::inherits
[10:25:20.612]                     invokeRestart <- base::invokeRestart
[10:25:20.612]                     is.null <- base::is.null
[10:25:20.612]                     muffled <- FALSE
[10:25:20.612]                     if (inherits(cond, "message")) {
[10:25:20.612]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.612]                       if (muffled) 
[10:25:20.612]                         invokeRestart("muffleMessage")
[10:25:20.612]                     }
[10:25:20.612]                     else if (inherits(cond, "warning")) {
[10:25:20.612]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.612]                       if (muffled) 
[10:25:20.612]                         invokeRestart("muffleWarning")
[10:25:20.612]                     }
[10:25:20.612]                     else if (inherits(cond, "condition")) {
[10:25:20.612]                       if (!is.null(pattern)) {
[10:25:20.612]                         computeRestarts <- base::computeRestarts
[10:25:20.612]                         grepl <- base::grepl
[10:25:20.612]                         restarts <- computeRestarts(cond)
[10:25:20.612]                         for (restart in restarts) {
[10:25:20.612]                           name <- restart$name
[10:25:20.612]                           if (is.null(name)) 
[10:25:20.612]                             next
[10:25:20.612]                           if (!grepl(pattern, name)) 
[10:25:20.612]                             next
[10:25:20.612]                           invokeRestart(restart)
[10:25:20.612]                           muffled <- TRUE
[10:25:20.612]                           break
[10:25:20.612]                         }
[10:25:20.612]                       }
[10:25:20.612]                     }
[10:25:20.612]                     invisible(muffled)
[10:25:20.612]                   }
[10:25:20.612]                   muffleCondition(cond)
[10:25:20.612]                 })
[10:25:20.612]             }))
[10:25:20.612]             future::FutureResult(value = ...future.value$value, 
[10:25:20.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.612]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.612]                     ...future.globalenv.names))
[10:25:20.612]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.612]         }, condition = base::local({
[10:25:20.612]             c <- base::c
[10:25:20.612]             inherits <- base::inherits
[10:25:20.612]             invokeRestart <- base::invokeRestart
[10:25:20.612]             length <- base::length
[10:25:20.612]             list <- base::list
[10:25:20.612]             seq.int <- base::seq.int
[10:25:20.612]             signalCondition <- base::signalCondition
[10:25:20.612]             sys.calls <- base::sys.calls
[10:25:20.612]             `[[` <- base::`[[`
[10:25:20.612]             `+` <- base::`+`
[10:25:20.612]             `<<-` <- base::`<<-`
[10:25:20.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.612]                   3L)]
[10:25:20.612]             }
[10:25:20.612]             function(cond) {
[10:25:20.612]                 is_error <- inherits(cond, "error")
[10:25:20.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.612]                   NULL)
[10:25:20.612]                 if (is_error) {
[10:25:20.612]                   sessionInformation <- function() {
[10:25:20.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.612]                       search = base::search(), system = base::Sys.info())
[10:25:20.612]                   }
[10:25:20.612]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.612]                     cond$call), session = sessionInformation(), 
[10:25:20.612]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.612]                   signalCondition(cond)
[10:25:20.612]                 }
[10:25:20.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.612]                 "immediateCondition"))) {
[10:25:20.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.612]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.612]                   if (TRUE && !signal) {
[10:25:20.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.612]                     {
[10:25:20.612]                       inherits <- base::inherits
[10:25:20.612]                       invokeRestart <- base::invokeRestart
[10:25:20.612]                       is.null <- base::is.null
[10:25:20.612]                       muffled <- FALSE
[10:25:20.612]                       if (inherits(cond, "message")) {
[10:25:20.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.612]                         if (muffled) 
[10:25:20.612]                           invokeRestart("muffleMessage")
[10:25:20.612]                       }
[10:25:20.612]                       else if (inherits(cond, "warning")) {
[10:25:20.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.612]                         if (muffled) 
[10:25:20.612]                           invokeRestart("muffleWarning")
[10:25:20.612]                       }
[10:25:20.612]                       else if (inherits(cond, "condition")) {
[10:25:20.612]                         if (!is.null(pattern)) {
[10:25:20.612]                           computeRestarts <- base::computeRestarts
[10:25:20.612]                           grepl <- base::grepl
[10:25:20.612]                           restarts <- computeRestarts(cond)
[10:25:20.612]                           for (restart in restarts) {
[10:25:20.612]                             name <- restart$name
[10:25:20.612]                             if (is.null(name)) 
[10:25:20.612]                               next
[10:25:20.612]                             if (!grepl(pattern, name)) 
[10:25:20.612]                               next
[10:25:20.612]                             invokeRestart(restart)
[10:25:20.612]                             muffled <- TRUE
[10:25:20.612]                             break
[10:25:20.612]                           }
[10:25:20.612]                         }
[10:25:20.612]                       }
[10:25:20.612]                       invisible(muffled)
[10:25:20.612]                     }
[10:25:20.612]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.612]                   }
[10:25:20.612]                 }
[10:25:20.612]                 else {
[10:25:20.612]                   if (TRUE) {
[10:25:20.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.612]                     {
[10:25:20.612]                       inherits <- base::inherits
[10:25:20.612]                       invokeRestart <- base::invokeRestart
[10:25:20.612]                       is.null <- base::is.null
[10:25:20.612]                       muffled <- FALSE
[10:25:20.612]                       if (inherits(cond, "message")) {
[10:25:20.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.612]                         if (muffled) 
[10:25:20.612]                           invokeRestart("muffleMessage")
[10:25:20.612]                       }
[10:25:20.612]                       else if (inherits(cond, "warning")) {
[10:25:20.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.612]                         if (muffled) 
[10:25:20.612]                           invokeRestart("muffleWarning")
[10:25:20.612]                       }
[10:25:20.612]                       else if (inherits(cond, "condition")) {
[10:25:20.612]                         if (!is.null(pattern)) {
[10:25:20.612]                           computeRestarts <- base::computeRestarts
[10:25:20.612]                           grepl <- base::grepl
[10:25:20.612]                           restarts <- computeRestarts(cond)
[10:25:20.612]                           for (restart in restarts) {
[10:25:20.612]                             name <- restart$name
[10:25:20.612]                             if (is.null(name)) 
[10:25:20.612]                               next
[10:25:20.612]                             if (!grepl(pattern, name)) 
[10:25:20.612]                               next
[10:25:20.612]                             invokeRestart(restart)
[10:25:20.612]                             muffled <- TRUE
[10:25:20.612]                             break
[10:25:20.612]                           }
[10:25:20.612]                         }
[10:25:20.612]                       }
[10:25:20.612]                       invisible(muffled)
[10:25:20.612]                     }
[10:25:20.612]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.612]                   }
[10:25:20.612]                 }
[10:25:20.612]             }
[10:25:20.612]         }))
[10:25:20.612]     }, error = function(ex) {
[10:25:20.612]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.612]                 ...future.rng), started = ...future.startTime, 
[10:25:20.612]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.612]             version = "1.8"), class = "FutureResult")
[10:25:20.612]     }, finally = {
[10:25:20.612]         if (!identical(...future.workdir, getwd())) 
[10:25:20.612]             setwd(...future.workdir)
[10:25:20.612]         {
[10:25:20.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.612]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.612]             }
[10:25:20.612]             base::options(...future.oldOptions)
[10:25:20.612]             if (.Platform$OS.type == "windows") {
[10:25:20.612]                 old_names <- names(...future.oldEnvVars)
[10:25:20.612]                 envs <- base::Sys.getenv()
[10:25:20.612]                 names <- names(envs)
[10:25:20.612]                 common <- intersect(names, old_names)
[10:25:20.612]                 added <- setdiff(names, old_names)
[10:25:20.612]                 removed <- setdiff(old_names, names)
[10:25:20.612]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.612]                   envs[common]]
[10:25:20.612]                 NAMES <- toupper(changed)
[10:25:20.612]                 args <- list()
[10:25:20.612]                 for (kk in seq_along(NAMES)) {
[10:25:20.612]                   name <- changed[[kk]]
[10:25:20.612]                   NAME <- NAMES[[kk]]
[10:25:20.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.612]                     next
[10:25:20.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.612]                 }
[10:25:20.612]                 NAMES <- toupper(added)
[10:25:20.612]                 for (kk in seq_along(NAMES)) {
[10:25:20.612]                   name <- added[[kk]]
[10:25:20.612]                   NAME <- NAMES[[kk]]
[10:25:20.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.612]                     next
[10:25:20.612]                   args[[name]] <- ""
[10:25:20.612]                 }
[10:25:20.612]                 NAMES <- toupper(removed)
[10:25:20.612]                 for (kk in seq_along(NAMES)) {
[10:25:20.612]                   name <- removed[[kk]]
[10:25:20.612]                   NAME <- NAMES[[kk]]
[10:25:20.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.612]                     next
[10:25:20.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.612]                 }
[10:25:20.612]                 if (length(args) > 0) 
[10:25:20.612]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.612]             }
[10:25:20.612]             else {
[10:25:20.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.612]             }
[10:25:20.612]             {
[10:25:20.612]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.612]                   0L) {
[10:25:20.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.612]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.612]                   base::options(opts)
[10:25:20.612]                 }
[10:25:20.612]                 {
[10:25:20.612]                   {
[10:25:20.612]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.612]                     NULL
[10:25:20.612]                   }
[10:25:20.612]                   options(future.plan = NULL)
[10:25:20.612]                   if (is.na(NA_character_)) 
[10:25:20.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.612]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.612]                     envir = parent.frame()) 
[10:25:20.612]                   {
[10:25:20.612]                     default_workers <- missing(workers)
[10:25:20.612]                     if (is.function(workers)) 
[10:25:20.612]                       workers <- workers()
[10:25:20.612]                     workers <- structure(as.integer(workers), 
[10:25:20.612]                       class = class(workers))
[10:25:20.612]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.612]                       1L)
[10:25:20.612]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.612]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.612]                       if (default_workers) 
[10:25:20.612]                         supportsMulticore(warn = TRUE)
[10:25:20.612]                       return(sequential(..., envir = envir))
[10:25:20.612]                     }
[10:25:20.612]                     oopts <- options(mc.cores = workers)
[10:25:20.612]                     on.exit(options(oopts))
[10:25:20.612]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.612]                       envir = envir)
[10:25:20.612]                     if (!future$lazy) 
[10:25:20.612]                       future <- run(future)
[10:25:20.612]                     invisible(future)
[10:25:20.612]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.612]                 }
[10:25:20.612]             }
[10:25:20.612]         }
[10:25:20.612]     })
[10:25:20.612]     if (TRUE) {
[10:25:20.612]         base::sink(type = "output", split = FALSE)
[10:25:20.612]         if (TRUE) {
[10:25:20.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.612]         }
[10:25:20.612]         else {
[10:25:20.612]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.612]         }
[10:25:20.612]         base::close(...future.stdout)
[10:25:20.612]         ...future.stdout <- NULL
[10:25:20.612]     }
[10:25:20.612]     ...future.result$conditions <- ...future.conditions
[10:25:20.612]     ...future.result$finished <- base::Sys.time()
[10:25:20.612]     ...future.result
[10:25:20.612] }
[10:25:20.615] assign_globals() ...
[10:25:20.615] List of 2
[10:25:20.615]  $ x: int [1:2] 1 2
[10:25:20.615]  $ y: num 3
[10:25:20.615]  - attr(*, "where")=List of 2
[10:25:20.615]   ..$ x:<environment: R_EmptyEnv> 
[10:25:20.615]   ..$ y:<environment: R_EmptyEnv> 
[10:25:20.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.615]  - attr(*, "resolved")= logi FALSE
[10:25:20.615]  - attr(*, "total_size")= num 112
[10:25:20.615]  - attr(*, "already-done")= logi TRUE
[10:25:20.621] - copied ‘x’ to environment
[10:25:20.621] - copied ‘y’ to environment
[10:25:20.622] assign_globals() ... done
[10:25:20.622] requestCore(): workers = 2
[10:25:20.623] MulticoreFuture started
[10:25:20.624] - Launch lazy future ... done
[10:25:20.624] run() for ‘MulticoreFuture’ ... done
[10:25:20.624] result() for MulticoreFuture ...
[10:25:20.625] plan(): Setting new future strategy stack:
[10:25:20.625] List of future strategies:
[10:25:20.625] 1. sequential:
[10:25:20.625]    - args: function (..., envir = parent.frame())
[10:25:20.625]    - tweaked: FALSE
[10:25:20.625]    - call: NULL
[10:25:20.626] plan(): nbrOfWorkers() = 1
[10:25:20.628] plan(): Setting new future strategy stack:
[10:25:20.628] List of future strategies:
[10:25:20.628] 1. multicore:
[10:25:20.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.628]    - tweaked: FALSE
[10:25:20.628]    - call: plan(strategy, substitute = FALSE)
[10:25:20.633] plan(): nbrOfWorkers() = 2
[10:25:20.639] result() for MulticoreFuture ...
[10:25:20.639] result() for MulticoreFuture ... done
[10:25:20.639] signalConditions() ...
[10:25:20.639]  - include = ‘immediateCondition’
[10:25:20.640]  - exclude = 
[10:25:20.640]  - resignal = FALSE
[10:25:20.640]  - Number of conditions: 1
[10:25:20.640] signalConditions() ... done
[10:25:20.640] result() for MulticoreFuture ... done
[10:25:20.640] result() for MulticoreFuture ...
[10:25:20.640] result() for MulticoreFuture ... done
[10:25:20.640] signalConditions() ...
[10:25:20.641]  - include = ‘immediateCondition’
[10:25:20.641]  - exclude = 
[10:25:20.641]  - resignal = FALSE
[10:25:20.641]  - Number of conditions: 1
[10:25:20.641] signalConditions() ... done
[10:25:20.641] Future state: ‘finished’
[10:25:20.641] result() for MulticoreFuture ...
[10:25:20.641] result() for MulticoreFuture ... done
[10:25:20.642] signalConditions() ...
[10:25:20.642]  - include = ‘condition’
[10:25:20.642]  - exclude = ‘immediateCondition’
[10:25:20.642]  - resignal = TRUE
[10:25:20.642]  - Number of conditions: 1
[10:25:20.642]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:25:20.642] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x558a915e1568>
Arguments '...' exists: TRUE
[10:25:20.644] getGlobalsAndPackages() ...
[10:25:20.644] - globals passed as-is: [1] ‘...’
[10:25:20.644] Resolving globals: FALSE
[10:25:20.644] Tweak future expression to call with '...' arguments ...
[10:25:20.644] {
[10:25:20.644]     do.call(function(...) {
[10:25:20.644]         fcn <- function() sum(...)
[10:25:20.644]         fcn()
[10:25:20.644]     }, args = future.call.arguments)
[10:25:20.644] }
[10:25:20.645] Tweak future expression to call with '...' arguments ... DONE
[10:25:20.645] The total size of the 1 globals is 112 bytes (112 bytes)
[10:25:20.646] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[10:25:20.646] - globals: [1] ‘future.call.arguments’
[10:25:20.646] 
[10:25:20.646] getGlobalsAndPackages() ... DONE
[10:25:20.646] run() for ‘Future’ ...
[10:25:20.646] - state: ‘created’
[10:25:20.647] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.650] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.651]   - Field: ‘label’
[10:25:20.651]   - Field: ‘local’
[10:25:20.651]   - Field: ‘owner’
[10:25:20.651]   - Field: ‘envir’
[10:25:20.651]   - Field: ‘workers’
[10:25:20.651]   - Field: ‘packages’
[10:25:20.651]   - Field: ‘gc’
[10:25:20.652]   - Field: ‘job’
[10:25:20.652]   - Field: ‘conditions’
[10:25:20.652]   - Field: ‘expr’
[10:25:20.652]   - Field: ‘uuid’
[10:25:20.652]   - Field: ‘seed’
[10:25:20.652]   - Field: ‘version’
[10:25:20.652]   - Field: ‘result’
[10:25:20.652]   - Field: ‘asynchronous’
[10:25:20.652]   - Field: ‘calls’
[10:25:20.652]   - Field: ‘globals’
[10:25:20.653]   - Field: ‘stdout’
[10:25:20.653]   - Field: ‘earlySignal’
[10:25:20.653]   - Field: ‘lazy’
[10:25:20.653]   - Field: ‘state’
[10:25:20.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.653] - Launch lazy future ...
[10:25:20.654] Packages needed by the future expression (n = 0): <none>
[10:25:20.654] Packages needed by future strategies (n = 0): <none>
[10:25:20.654] {
[10:25:20.654]     {
[10:25:20.654]         {
[10:25:20.654]             ...future.startTime <- base::Sys.time()
[10:25:20.654]             {
[10:25:20.654]                 {
[10:25:20.654]                   {
[10:25:20.654]                     {
[10:25:20.654]                       base::local({
[10:25:20.654]                         has_future <- base::requireNamespace("future", 
[10:25:20.654]                           quietly = TRUE)
[10:25:20.654]                         if (has_future) {
[10:25:20.654]                           ns <- base::getNamespace("future")
[10:25:20.654]                           version <- ns[[".package"]][["version"]]
[10:25:20.654]                           if (is.null(version)) 
[10:25:20.654]                             version <- utils::packageVersion("future")
[10:25:20.654]                         }
[10:25:20.654]                         else {
[10:25:20.654]                           version <- NULL
[10:25:20.654]                         }
[10:25:20.654]                         if (!has_future || version < "1.8.0") {
[10:25:20.654]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.654]                             "", base::R.version$version.string), 
[10:25:20.654]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.654]                               "release", "version")], collapse = " "), 
[10:25:20.654]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.654]                             info)
[10:25:20.654]                           info <- base::paste(info, collapse = "; ")
[10:25:20.654]                           if (!has_future) {
[10:25:20.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.654]                               info)
[10:25:20.654]                           }
[10:25:20.654]                           else {
[10:25:20.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.654]                               info, version)
[10:25:20.654]                           }
[10:25:20.654]                           base::stop(msg)
[10:25:20.654]                         }
[10:25:20.654]                       })
[10:25:20.654]                     }
[10:25:20.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.654]                     base::options(mc.cores = 1L)
[10:25:20.654]                   }
[10:25:20.654]                   options(future.plan = NULL)
[10:25:20.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.654]                 }
[10:25:20.654]                 ...future.workdir <- getwd()
[10:25:20.654]             }
[10:25:20.654]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.654]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.654]         }
[10:25:20.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.654]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.654]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.654]             base::names(...future.oldOptions))
[10:25:20.654]     }
[10:25:20.654]     if (FALSE) {
[10:25:20.654]     }
[10:25:20.654]     else {
[10:25:20.654]         if (TRUE) {
[10:25:20.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.654]                 open = "w")
[10:25:20.654]         }
[10:25:20.654]         else {
[10:25:20.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.654]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.654]         }
[10:25:20.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.654]             base::sink(type = "output", split = FALSE)
[10:25:20.654]             base::close(...future.stdout)
[10:25:20.654]         }, add = TRUE)
[10:25:20.654]     }
[10:25:20.654]     ...future.frame <- base::sys.nframe()
[10:25:20.654]     ...future.conditions <- base::list()
[10:25:20.654]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.654]     if (FALSE) {
[10:25:20.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.654]     }
[10:25:20.654]     ...future.result <- base::tryCatch({
[10:25:20.654]         base::withCallingHandlers({
[10:25:20.654]             ...future.value <- base::withVisible(base::local({
[10:25:20.654]                 withCallingHandlers({
[10:25:20.654]                   {
[10:25:20.654]                     do.call(function(...) {
[10:25:20.654]                       fcn <- function() sum(...)
[10:25:20.654]                       fcn()
[10:25:20.654]                     }, args = future.call.arguments)
[10:25:20.654]                   }
[10:25:20.654]                 }, immediateCondition = function(cond) {
[10:25:20.654]                   save_rds <- function (object, pathname, ...) 
[10:25:20.654]                   {
[10:25:20.654]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.654]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.654]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.654]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.654]                         fi_tmp[["mtime"]])
[10:25:20.654]                     }
[10:25:20.654]                     tryCatch({
[10:25:20.654]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.654]                     }, error = function(ex) {
[10:25:20.654]                       msg <- conditionMessage(ex)
[10:25:20.654]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.654]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.654]                         fi_tmp[["mtime"]], msg)
[10:25:20.654]                       ex$message <- msg
[10:25:20.654]                       stop(ex)
[10:25:20.654]                     })
[10:25:20.654]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.654]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.654]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.654]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.654]                       fi <- file.info(pathname)
[10:25:20.654]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.654]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.654]                         fi[["size"]], fi[["mtime"]])
[10:25:20.654]                       stop(msg)
[10:25:20.654]                     }
[10:25:20.654]                     invisible(pathname)
[10:25:20.654]                   }
[10:25:20.654]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.654]                     rootPath = tempdir()) 
[10:25:20.654]                   {
[10:25:20.654]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.654]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.654]                       tmpdir = path, fileext = ".rds")
[10:25:20.654]                     save_rds(obj, file)
[10:25:20.654]                   }
[10:25:20.654]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.654]                   {
[10:25:20.654]                     inherits <- base::inherits
[10:25:20.654]                     invokeRestart <- base::invokeRestart
[10:25:20.654]                     is.null <- base::is.null
[10:25:20.654]                     muffled <- FALSE
[10:25:20.654]                     if (inherits(cond, "message")) {
[10:25:20.654]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.654]                       if (muffled) 
[10:25:20.654]                         invokeRestart("muffleMessage")
[10:25:20.654]                     }
[10:25:20.654]                     else if (inherits(cond, "warning")) {
[10:25:20.654]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.654]                       if (muffled) 
[10:25:20.654]                         invokeRestart("muffleWarning")
[10:25:20.654]                     }
[10:25:20.654]                     else if (inherits(cond, "condition")) {
[10:25:20.654]                       if (!is.null(pattern)) {
[10:25:20.654]                         computeRestarts <- base::computeRestarts
[10:25:20.654]                         grepl <- base::grepl
[10:25:20.654]                         restarts <- computeRestarts(cond)
[10:25:20.654]                         for (restart in restarts) {
[10:25:20.654]                           name <- restart$name
[10:25:20.654]                           if (is.null(name)) 
[10:25:20.654]                             next
[10:25:20.654]                           if (!grepl(pattern, name)) 
[10:25:20.654]                             next
[10:25:20.654]                           invokeRestart(restart)
[10:25:20.654]                           muffled <- TRUE
[10:25:20.654]                           break
[10:25:20.654]                         }
[10:25:20.654]                       }
[10:25:20.654]                     }
[10:25:20.654]                     invisible(muffled)
[10:25:20.654]                   }
[10:25:20.654]                   muffleCondition(cond)
[10:25:20.654]                 })
[10:25:20.654]             }))
[10:25:20.654]             future::FutureResult(value = ...future.value$value, 
[10:25:20.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.654]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.654]                     ...future.globalenv.names))
[10:25:20.654]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.654]         }, condition = base::local({
[10:25:20.654]             c <- base::c
[10:25:20.654]             inherits <- base::inherits
[10:25:20.654]             invokeRestart <- base::invokeRestart
[10:25:20.654]             length <- base::length
[10:25:20.654]             list <- base::list
[10:25:20.654]             seq.int <- base::seq.int
[10:25:20.654]             signalCondition <- base::signalCondition
[10:25:20.654]             sys.calls <- base::sys.calls
[10:25:20.654]             `[[` <- base::`[[`
[10:25:20.654]             `+` <- base::`+`
[10:25:20.654]             `<<-` <- base::`<<-`
[10:25:20.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.654]                   3L)]
[10:25:20.654]             }
[10:25:20.654]             function(cond) {
[10:25:20.654]                 is_error <- inherits(cond, "error")
[10:25:20.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.654]                   NULL)
[10:25:20.654]                 if (is_error) {
[10:25:20.654]                   sessionInformation <- function() {
[10:25:20.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.654]                       search = base::search(), system = base::Sys.info())
[10:25:20.654]                   }
[10:25:20.654]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.654]                     cond$call), session = sessionInformation(), 
[10:25:20.654]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.654]                   signalCondition(cond)
[10:25:20.654]                 }
[10:25:20.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.654]                 "immediateCondition"))) {
[10:25:20.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.654]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.654]                   if (TRUE && !signal) {
[10:25:20.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.654]                     {
[10:25:20.654]                       inherits <- base::inherits
[10:25:20.654]                       invokeRestart <- base::invokeRestart
[10:25:20.654]                       is.null <- base::is.null
[10:25:20.654]                       muffled <- FALSE
[10:25:20.654]                       if (inherits(cond, "message")) {
[10:25:20.654]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.654]                         if (muffled) 
[10:25:20.654]                           invokeRestart("muffleMessage")
[10:25:20.654]                       }
[10:25:20.654]                       else if (inherits(cond, "warning")) {
[10:25:20.654]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.654]                         if (muffled) 
[10:25:20.654]                           invokeRestart("muffleWarning")
[10:25:20.654]                       }
[10:25:20.654]                       else if (inherits(cond, "condition")) {
[10:25:20.654]                         if (!is.null(pattern)) {
[10:25:20.654]                           computeRestarts <- base::computeRestarts
[10:25:20.654]                           grepl <- base::grepl
[10:25:20.654]                           restarts <- computeRestarts(cond)
[10:25:20.654]                           for (restart in restarts) {
[10:25:20.654]                             name <- restart$name
[10:25:20.654]                             if (is.null(name)) 
[10:25:20.654]                               next
[10:25:20.654]                             if (!grepl(pattern, name)) 
[10:25:20.654]                               next
[10:25:20.654]                             invokeRestart(restart)
[10:25:20.654]                             muffled <- TRUE
[10:25:20.654]                             break
[10:25:20.654]                           }
[10:25:20.654]                         }
[10:25:20.654]                       }
[10:25:20.654]                       invisible(muffled)
[10:25:20.654]                     }
[10:25:20.654]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.654]                   }
[10:25:20.654]                 }
[10:25:20.654]                 else {
[10:25:20.654]                   if (TRUE) {
[10:25:20.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.654]                     {
[10:25:20.654]                       inherits <- base::inherits
[10:25:20.654]                       invokeRestart <- base::invokeRestart
[10:25:20.654]                       is.null <- base::is.null
[10:25:20.654]                       muffled <- FALSE
[10:25:20.654]                       if (inherits(cond, "message")) {
[10:25:20.654]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.654]                         if (muffled) 
[10:25:20.654]                           invokeRestart("muffleMessage")
[10:25:20.654]                       }
[10:25:20.654]                       else if (inherits(cond, "warning")) {
[10:25:20.654]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.654]                         if (muffled) 
[10:25:20.654]                           invokeRestart("muffleWarning")
[10:25:20.654]                       }
[10:25:20.654]                       else if (inherits(cond, "condition")) {
[10:25:20.654]                         if (!is.null(pattern)) {
[10:25:20.654]                           computeRestarts <- base::computeRestarts
[10:25:20.654]                           grepl <- base::grepl
[10:25:20.654]                           restarts <- computeRestarts(cond)
[10:25:20.654]                           for (restart in restarts) {
[10:25:20.654]                             name <- restart$name
[10:25:20.654]                             if (is.null(name)) 
[10:25:20.654]                               next
[10:25:20.654]                             if (!grepl(pattern, name)) 
[10:25:20.654]                               next
[10:25:20.654]                             invokeRestart(restart)
[10:25:20.654]                             muffled <- TRUE
[10:25:20.654]                             break
[10:25:20.654]                           }
[10:25:20.654]                         }
[10:25:20.654]                       }
[10:25:20.654]                       invisible(muffled)
[10:25:20.654]                     }
[10:25:20.654]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.654]                   }
[10:25:20.654]                 }
[10:25:20.654]             }
[10:25:20.654]         }))
[10:25:20.654]     }, error = function(ex) {
[10:25:20.654]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.654]                 ...future.rng), started = ...future.startTime, 
[10:25:20.654]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.654]             version = "1.8"), class = "FutureResult")
[10:25:20.654]     }, finally = {
[10:25:20.654]         if (!identical(...future.workdir, getwd())) 
[10:25:20.654]             setwd(...future.workdir)
[10:25:20.654]         {
[10:25:20.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.654]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.654]             }
[10:25:20.654]             base::options(...future.oldOptions)
[10:25:20.654]             if (.Platform$OS.type == "windows") {
[10:25:20.654]                 old_names <- names(...future.oldEnvVars)
[10:25:20.654]                 envs <- base::Sys.getenv()
[10:25:20.654]                 names <- names(envs)
[10:25:20.654]                 common <- intersect(names, old_names)
[10:25:20.654]                 added <- setdiff(names, old_names)
[10:25:20.654]                 removed <- setdiff(old_names, names)
[10:25:20.654]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.654]                   envs[common]]
[10:25:20.654]                 NAMES <- toupper(changed)
[10:25:20.654]                 args <- list()
[10:25:20.654]                 for (kk in seq_along(NAMES)) {
[10:25:20.654]                   name <- changed[[kk]]
[10:25:20.654]                   NAME <- NAMES[[kk]]
[10:25:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.654]                     next
[10:25:20.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.654]                 }
[10:25:20.654]                 NAMES <- toupper(added)
[10:25:20.654]                 for (kk in seq_along(NAMES)) {
[10:25:20.654]                   name <- added[[kk]]
[10:25:20.654]                   NAME <- NAMES[[kk]]
[10:25:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.654]                     next
[10:25:20.654]                   args[[name]] <- ""
[10:25:20.654]                 }
[10:25:20.654]                 NAMES <- toupper(removed)
[10:25:20.654]                 for (kk in seq_along(NAMES)) {
[10:25:20.654]                   name <- removed[[kk]]
[10:25:20.654]                   NAME <- NAMES[[kk]]
[10:25:20.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.654]                     next
[10:25:20.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.654]                 }
[10:25:20.654]                 if (length(args) > 0) 
[10:25:20.654]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.654]             }
[10:25:20.654]             else {
[10:25:20.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.654]             }
[10:25:20.654]             {
[10:25:20.654]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.654]                   0L) {
[10:25:20.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.654]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.654]                   base::options(opts)
[10:25:20.654]                 }
[10:25:20.654]                 {
[10:25:20.654]                   {
[10:25:20.654]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.654]                     NULL
[10:25:20.654]                   }
[10:25:20.654]                   options(future.plan = NULL)
[10:25:20.654]                   if (is.na(NA_character_)) 
[10:25:20.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.654]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.654]                     envir = parent.frame()) 
[10:25:20.654]                   {
[10:25:20.654]                     default_workers <- missing(workers)
[10:25:20.654]                     if (is.function(workers)) 
[10:25:20.654]                       workers <- workers()
[10:25:20.654]                     workers <- structure(as.integer(workers), 
[10:25:20.654]                       class = class(workers))
[10:25:20.654]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.654]                       1L)
[10:25:20.654]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.654]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.654]                       if (default_workers) 
[10:25:20.654]                         supportsMulticore(warn = TRUE)
[10:25:20.654]                       return(sequential(..., envir = envir))
[10:25:20.654]                     }
[10:25:20.654]                     oopts <- options(mc.cores = workers)
[10:25:20.654]                     on.exit(options(oopts))
[10:25:20.654]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.654]                       envir = envir)
[10:25:20.654]                     if (!future$lazy) 
[10:25:20.654]                       future <- run(future)
[10:25:20.654]                     invisible(future)
[10:25:20.654]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.654]                 }
[10:25:20.654]             }
[10:25:20.654]         }
[10:25:20.654]     })
[10:25:20.654]     if (TRUE) {
[10:25:20.654]         base::sink(type = "output", split = FALSE)
[10:25:20.654]         if (TRUE) {
[10:25:20.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.654]         }
[10:25:20.654]         else {
[10:25:20.654]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.654]         }
[10:25:20.654]         base::close(...future.stdout)
[10:25:20.654]         ...future.stdout <- NULL
[10:25:20.654]     }
[10:25:20.654]     ...future.result$conditions <- ...future.conditions
[10:25:20.654]     ...future.result$finished <- base::Sys.time()
[10:25:20.654]     ...future.result
[10:25:20.654] }
[10:25:20.657] assign_globals() ...
[10:25:20.657] List of 1
[10:25:20.657]  $ future.call.arguments:List of 2
[10:25:20.657]   ..$ : int [1:2] 1 2
[10:25:20.657]   ..$ : num 3
[10:25:20.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:25:20.657]  - attr(*, "where")=List of 1
[10:25:20.657]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[10:25:20.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.657]  - attr(*, "resolved")= logi FALSE
[10:25:20.657]  - attr(*, "total_size")= num 112
[10:25:20.657]  - attr(*, "already-done")= logi TRUE
[10:25:20.661] - copied ‘future.call.arguments’ to environment
[10:25:20.661] assign_globals() ... done
[10:25:20.661] requestCore(): workers = 2
[10:25:20.663] MulticoreFuture started
[10:25:20.663] - Launch lazy future ... done
[10:25:20.663] run() for ‘MulticoreFuture’ ... done
[10:25:20.664] result() for MulticoreFuture ...
[10:25:20.664] plan(): Setting new future strategy stack:
[10:25:20.664] List of future strategies:
[10:25:20.664] 1. sequential:
[10:25:20.664]    - args: function (..., envir = parent.frame())
[10:25:20.664]    - tweaked: FALSE
[10:25:20.664]    - call: NULL
[10:25:20.665] plan(): nbrOfWorkers() = 1
[10:25:20.667] plan(): Setting new future strategy stack:
[10:25:20.667] List of future strategies:
[10:25:20.667] 1. multicore:
[10:25:20.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.667]    - tweaked: FALSE
[10:25:20.667]    - call: plan(strategy, substitute = FALSE)
[10:25:20.672] plan(): nbrOfWorkers() = 2
[10:25:20.673] result() for MulticoreFuture ...
[10:25:20.673] result() for MulticoreFuture ... done
[10:25:20.673] result() for MulticoreFuture ... done
[10:25:20.673] result() for MulticoreFuture ...
[10:25:20.673] result() for MulticoreFuture ... done
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x558a8feb2800>
Using '...' in a formula
[10:25:20.674] getGlobalsAndPackages() ...
[10:25:20.674] Searching for globals...
[10:25:20.681] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[10:25:20.681] Searching for globals ... DONE
[10:25:20.681] Resolving globals: FALSE
[10:25:20.681] Tweak future expression to call with '...' arguments ...
[10:25:20.682] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[10:25:20.682] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:20.682] - globals: [3] ‘fcn’, ‘x’, ‘y’
[10:25:20.683] 
[10:25:20.683] getGlobalsAndPackages() ... DONE
[10:25:20.683] run() for ‘Future’ ...
[10:25:20.683] - state: ‘created’
[10:25:20.683] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:25:20.687] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:20.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:25:20.687]   - Field: ‘label’
[10:25:20.688]   - Field: ‘local’
[10:25:20.688]   - Field: ‘owner’
[10:25:20.688]   - Field: ‘envir’
[10:25:20.688]   - Field: ‘workers’
[10:25:20.688]   - Field: ‘packages’
[10:25:20.688]   - Field: ‘gc’
[10:25:20.688]   - Field: ‘job’
[10:25:20.688]   - Field: ‘conditions’
[10:25:20.688]   - Field: ‘expr’
[10:25:20.689]   - Field: ‘uuid’
[10:25:20.689]   - Field: ‘seed’
[10:25:20.689]   - Field: ‘version’
[10:25:20.689]   - Field: ‘result’
[10:25:20.689]   - Field: ‘asynchronous’
[10:25:20.689]   - Field: ‘calls’
[10:25:20.689]   - Field: ‘globals’
[10:25:20.689]   - Field: ‘stdout’
[10:25:20.690]   - Field: ‘earlySignal’
[10:25:20.690]   - Field: ‘lazy’
[10:25:20.690]   - Field: ‘state’
[10:25:20.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:25:20.690] - Launch lazy future ...
[10:25:20.690] Packages needed by the future expression (n = 0): <none>
[10:25:20.690] Packages needed by future strategies (n = 0): <none>
[10:25:20.691] {
[10:25:20.691]     {
[10:25:20.691]         {
[10:25:20.691]             ...future.startTime <- base::Sys.time()
[10:25:20.691]             {
[10:25:20.691]                 {
[10:25:20.691]                   {
[10:25:20.691]                     {
[10:25:20.691]                       base::local({
[10:25:20.691]                         has_future <- base::requireNamespace("future", 
[10:25:20.691]                           quietly = TRUE)
[10:25:20.691]                         if (has_future) {
[10:25:20.691]                           ns <- base::getNamespace("future")
[10:25:20.691]                           version <- ns[[".package"]][["version"]]
[10:25:20.691]                           if (is.null(version)) 
[10:25:20.691]                             version <- utils::packageVersion("future")
[10:25:20.691]                         }
[10:25:20.691]                         else {
[10:25:20.691]                           version <- NULL
[10:25:20.691]                         }
[10:25:20.691]                         if (!has_future || version < "1.8.0") {
[10:25:20.691]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:20.691]                             "", base::R.version$version.string), 
[10:25:20.691]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:20.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:20.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:20.691]                               "release", "version")], collapse = " "), 
[10:25:20.691]                             hostname = base::Sys.info()[["nodename"]])
[10:25:20.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:20.691]                             info)
[10:25:20.691]                           info <- base::paste(info, collapse = "; ")
[10:25:20.691]                           if (!has_future) {
[10:25:20.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:20.691]                               info)
[10:25:20.691]                           }
[10:25:20.691]                           else {
[10:25:20.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:20.691]                               info, version)
[10:25:20.691]                           }
[10:25:20.691]                           base::stop(msg)
[10:25:20.691]                         }
[10:25:20.691]                       })
[10:25:20.691]                     }
[10:25:20.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:20.691]                     base::options(mc.cores = 1L)
[10:25:20.691]                   }
[10:25:20.691]                   options(future.plan = NULL)
[10:25:20.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:20.691]                 }
[10:25:20.691]                 ...future.workdir <- getwd()
[10:25:20.691]             }
[10:25:20.691]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:20.691]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:20.691]         }
[10:25:20.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:20.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:20.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:20.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:20.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:20.691]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:20.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:20.691]             base::names(...future.oldOptions))
[10:25:20.691]     }
[10:25:20.691]     if (FALSE) {
[10:25:20.691]     }
[10:25:20.691]     else {
[10:25:20.691]         if (TRUE) {
[10:25:20.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:20.691]                 open = "w")
[10:25:20.691]         }
[10:25:20.691]         else {
[10:25:20.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:20.691]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:20.691]         }
[10:25:20.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:20.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:20.691]             base::sink(type = "output", split = FALSE)
[10:25:20.691]             base::close(...future.stdout)
[10:25:20.691]         }, add = TRUE)
[10:25:20.691]     }
[10:25:20.691]     ...future.frame <- base::sys.nframe()
[10:25:20.691]     ...future.conditions <- base::list()
[10:25:20.691]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:20.691]     if (FALSE) {
[10:25:20.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:20.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:20.691]     }
[10:25:20.691]     ...future.result <- base::tryCatch({
[10:25:20.691]         base::withCallingHandlers({
[10:25:20.691]             ...future.value <- base::withVisible(base::local({
[10:25:20.691]                 withCallingHandlers({
[10:25:20.691]                   fcn(x, y)
[10:25:20.691]                 }, immediateCondition = function(cond) {
[10:25:20.691]                   save_rds <- function (object, pathname, ...) 
[10:25:20.691]                   {
[10:25:20.691]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:25:20.691]                     if (file_test("-f", pathname_tmp)) {
[10:25:20.691]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.691]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:25:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.691]                         fi_tmp[["mtime"]])
[10:25:20.691]                     }
[10:25:20.691]                     tryCatch({
[10:25:20.691]                       saveRDS(object, file = pathname_tmp, ...)
[10:25:20.691]                     }, error = function(ex) {
[10:25:20.691]                       msg <- conditionMessage(ex)
[10:25:20.691]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.691]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:25:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.691]                         fi_tmp[["mtime"]], msg)
[10:25:20.691]                       ex$message <- msg
[10:25:20.691]                       stop(ex)
[10:25:20.691]                     })
[10:25:20.691]                     stopifnot(file_test("-f", pathname_tmp))
[10:25:20.691]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:25:20.691]                     if (!res || file_test("-f", pathname_tmp)) {
[10:25:20.691]                       fi_tmp <- file.info(pathname_tmp)
[10:25:20.691]                       fi <- file.info(pathname)
[10:25:20.691]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:25:20.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:25:20.691]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:25:20.691]                         fi[["size"]], fi[["mtime"]])
[10:25:20.691]                       stop(msg)
[10:25:20.691]                     }
[10:25:20.691]                     invisible(pathname)
[10:25:20.691]                   }
[10:25:20.691]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:25:20.691]                     rootPath = tempdir()) 
[10:25:20.691]                   {
[10:25:20.691]                     obj <- list(time = Sys.time(), condition = cond)
[10:25:20.691]                     file <- tempfile(pattern = class(cond)[1], 
[10:25:20.691]                       tmpdir = path, fileext = ".rds")
[10:25:20.691]                     save_rds(obj, file)
[10:25:20.691]                   }
[10:25:20.691]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2TwYFY/.future/immediateConditions")
[10:25:20.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.691]                   {
[10:25:20.691]                     inherits <- base::inherits
[10:25:20.691]                     invokeRestart <- base::invokeRestart
[10:25:20.691]                     is.null <- base::is.null
[10:25:20.691]                     muffled <- FALSE
[10:25:20.691]                     if (inherits(cond, "message")) {
[10:25:20.691]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:20.691]                       if (muffled) 
[10:25:20.691]                         invokeRestart("muffleMessage")
[10:25:20.691]                     }
[10:25:20.691]                     else if (inherits(cond, "warning")) {
[10:25:20.691]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:20.691]                       if (muffled) 
[10:25:20.691]                         invokeRestart("muffleWarning")
[10:25:20.691]                     }
[10:25:20.691]                     else if (inherits(cond, "condition")) {
[10:25:20.691]                       if (!is.null(pattern)) {
[10:25:20.691]                         computeRestarts <- base::computeRestarts
[10:25:20.691]                         grepl <- base::grepl
[10:25:20.691]                         restarts <- computeRestarts(cond)
[10:25:20.691]                         for (restart in restarts) {
[10:25:20.691]                           name <- restart$name
[10:25:20.691]                           if (is.null(name)) 
[10:25:20.691]                             next
[10:25:20.691]                           if (!grepl(pattern, name)) 
[10:25:20.691]                             next
[10:25:20.691]                           invokeRestart(restart)
[10:25:20.691]                           muffled <- TRUE
[10:25:20.691]                           break
[10:25:20.691]                         }
[10:25:20.691]                       }
[10:25:20.691]                     }
[10:25:20.691]                     invisible(muffled)
[10:25:20.691]                   }
[10:25:20.691]                   muffleCondition(cond)
[10:25:20.691]                 })
[10:25:20.691]             }))
[10:25:20.691]             future::FutureResult(value = ...future.value$value, 
[10:25:20.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.691]                   ...future.rng), globalenv = if (FALSE) 
[10:25:20.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:20.691]                     ...future.globalenv.names))
[10:25:20.691]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:20.691]         }, condition = base::local({
[10:25:20.691]             c <- base::c
[10:25:20.691]             inherits <- base::inherits
[10:25:20.691]             invokeRestart <- base::invokeRestart
[10:25:20.691]             length <- base::length
[10:25:20.691]             list <- base::list
[10:25:20.691]             seq.int <- base::seq.int
[10:25:20.691]             signalCondition <- base::signalCondition
[10:25:20.691]             sys.calls <- base::sys.calls
[10:25:20.691]             `[[` <- base::`[[`
[10:25:20.691]             `+` <- base::`+`
[10:25:20.691]             `<<-` <- base::`<<-`
[10:25:20.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:20.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:20.691]                   3L)]
[10:25:20.691]             }
[10:25:20.691]             function(cond) {
[10:25:20.691]                 is_error <- inherits(cond, "error")
[10:25:20.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:20.691]                   NULL)
[10:25:20.691]                 if (is_error) {
[10:25:20.691]                   sessionInformation <- function() {
[10:25:20.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:20.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:20.691]                       search = base::search(), system = base::Sys.info())
[10:25:20.691]                   }
[10:25:20.691]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:20.691]                     cond$call), session = sessionInformation(), 
[10:25:20.691]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:20.691]                   signalCondition(cond)
[10:25:20.691]                 }
[10:25:20.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:20.691]                 "immediateCondition"))) {
[10:25:20.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:20.691]                   ...future.conditions[[length(...future.conditions) + 
[10:25:20.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:20.691]                   if (TRUE && !signal) {
[10:25:20.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.691]                     {
[10:25:20.691]                       inherits <- base::inherits
[10:25:20.691]                       invokeRestart <- base::invokeRestart
[10:25:20.691]                       is.null <- base::is.null
[10:25:20.691]                       muffled <- FALSE
[10:25:20.691]                       if (inherits(cond, "message")) {
[10:25:20.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.691]                         if (muffled) 
[10:25:20.691]                           invokeRestart("muffleMessage")
[10:25:20.691]                       }
[10:25:20.691]                       else if (inherits(cond, "warning")) {
[10:25:20.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.691]                         if (muffled) 
[10:25:20.691]                           invokeRestart("muffleWarning")
[10:25:20.691]                       }
[10:25:20.691]                       else if (inherits(cond, "condition")) {
[10:25:20.691]                         if (!is.null(pattern)) {
[10:25:20.691]                           computeRestarts <- base::computeRestarts
[10:25:20.691]                           grepl <- base::grepl
[10:25:20.691]                           restarts <- computeRestarts(cond)
[10:25:20.691]                           for (restart in restarts) {
[10:25:20.691]                             name <- restart$name
[10:25:20.691]                             if (is.null(name)) 
[10:25:20.691]                               next
[10:25:20.691]                             if (!grepl(pattern, name)) 
[10:25:20.691]                               next
[10:25:20.691]                             invokeRestart(restart)
[10:25:20.691]                             muffled <- TRUE
[10:25:20.691]                             break
[10:25:20.691]                           }
[10:25:20.691]                         }
[10:25:20.691]                       }
[10:25:20.691]                       invisible(muffled)
[10:25:20.691]                     }
[10:25:20.691]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.691]                   }
[10:25:20.691]                 }
[10:25:20.691]                 else {
[10:25:20.691]                   if (TRUE) {
[10:25:20.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:20.691]                     {
[10:25:20.691]                       inherits <- base::inherits
[10:25:20.691]                       invokeRestart <- base::invokeRestart
[10:25:20.691]                       is.null <- base::is.null
[10:25:20.691]                       muffled <- FALSE
[10:25:20.691]                       if (inherits(cond, "message")) {
[10:25:20.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:20.691]                         if (muffled) 
[10:25:20.691]                           invokeRestart("muffleMessage")
[10:25:20.691]                       }
[10:25:20.691]                       else if (inherits(cond, "warning")) {
[10:25:20.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:20.691]                         if (muffled) 
[10:25:20.691]                           invokeRestart("muffleWarning")
[10:25:20.691]                       }
[10:25:20.691]                       else if (inherits(cond, "condition")) {
[10:25:20.691]                         if (!is.null(pattern)) {
[10:25:20.691]                           computeRestarts <- base::computeRestarts
[10:25:20.691]                           grepl <- base::grepl
[10:25:20.691]                           restarts <- computeRestarts(cond)
[10:25:20.691]                           for (restart in restarts) {
[10:25:20.691]                             name <- restart$name
[10:25:20.691]                             if (is.null(name)) 
[10:25:20.691]                               next
[10:25:20.691]                             if (!grepl(pattern, name)) 
[10:25:20.691]                               next
[10:25:20.691]                             invokeRestart(restart)
[10:25:20.691]                             muffled <- TRUE
[10:25:20.691]                             break
[10:25:20.691]                           }
[10:25:20.691]                         }
[10:25:20.691]                       }
[10:25:20.691]                       invisible(muffled)
[10:25:20.691]                     }
[10:25:20.691]                     muffleCondition(cond, pattern = "^muffle")
[10:25:20.691]                   }
[10:25:20.691]                 }
[10:25:20.691]             }
[10:25:20.691]         }))
[10:25:20.691]     }, error = function(ex) {
[10:25:20.691]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:20.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:20.691]                 ...future.rng), started = ...future.startTime, 
[10:25:20.691]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:20.691]             version = "1.8"), class = "FutureResult")
[10:25:20.691]     }, finally = {
[10:25:20.691]         if (!identical(...future.workdir, getwd())) 
[10:25:20.691]             setwd(...future.workdir)
[10:25:20.691]         {
[10:25:20.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:20.691]                 ...future.oldOptions$nwarnings <- NULL
[10:25:20.691]             }
[10:25:20.691]             base::options(...future.oldOptions)
[10:25:20.691]             if (.Platform$OS.type == "windows") {
[10:25:20.691]                 old_names <- names(...future.oldEnvVars)
[10:25:20.691]                 envs <- base::Sys.getenv()
[10:25:20.691]                 names <- names(envs)
[10:25:20.691]                 common <- intersect(names, old_names)
[10:25:20.691]                 added <- setdiff(names, old_names)
[10:25:20.691]                 removed <- setdiff(old_names, names)
[10:25:20.691]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:20.691]                   envs[common]]
[10:25:20.691]                 NAMES <- toupper(changed)
[10:25:20.691]                 args <- list()
[10:25:20.691]                 for (kk in seq_along(NAMES)) {
[10:25:20.691]                   name <- changed[[kk]]
[10:25:20.691]                   NAME <- NAMES[[kk]]
[10:25:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.691]                     next
[10:25:20.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.691]                 }
[10:25:20.691]                 NAMES <- toupper(added)
[10:25:20.691]                 for (kk in seq_along(NAMES)) {
[10:25:20.691]                   name <- added[[kk]]
[10:25:20.691]                   NAME <- NAMES[[kk]]
[10:25:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.691]                     next
[10:25:20.691]                   args[[name]] <- ""
[10:25:20.691]                 }
[10:25:20.691]                 NAMES <- toupper(removed)
[10:25:20.691]                 for (kk in seq_along(NAMES)) {
[10:25:20.691]                   name <- removed[[kk]]
[10:25:20.691]                   NAME <- NAMES[[kk]]
[10:25:20.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:20.691]                     next
[10:25:20.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:20.691]                 }
[10:25:20.691]                 if (length(args) > 0) 
[10:25:20.691]                   base::do.call(base::Sys.setenv, args = args)
[10:25:20.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:20.691]             }
[10:25:20.691]             else {
[10:25:20.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:20.691]             }
[10:25:20.691]             {
[10:25:20.691]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:20.691]                   0L) {
[10:25:20.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:20.691]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:20.691]                   base::options(opts)
[10:25:20.691]                 }
[10:25:20.691]                 {
[10:25:20.691]                   {
[10:25:20.691]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:20.691]                     NULL
[10:25:20.691]                   }
[10:25:20.691]                   options(future.plan = NULL)
[10:25:20.691]                   if (is.na(NA_character_)) 
[10:25:20.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:20.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:20.691]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:25:20.691]                     envir = parent.frame()) 
[10:25:20.691]                   {
[10:25:20.691]                     default_workers <- missing(workers)
[10:25:20.691]                     if (is.function(workers)) 
[10:25:20.691]                       workers <- workers()
[10:25:20.691]                     workers <- structure(as.integer(workers), 
[10:25:20.691]                       class = class(workers))
[10:25:20.691]                     stop_if_not(is.finite(workers), workers >= 
[10:25:20.691]                       1L)
[10:25:20.691]                     if ((workers == 1L && !inherits(workers, 
[10:25:20.691]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:25:20.691]                       if (default_workers) 
[10:25:20.691]                         supportsMulticore(warn = TRUE)
[10:25:20.691]                       return(sequential(..., envir = envir))
[10:25:20.691]                     }
[10:25:20.691]                     oopts <- options(mc.cores = workers)
[10:25:20.691]                     on.exit(options(oopts))
[10:25:20.691]                     future <- MulticoreFuture(..., workers = workers, 
[10:25:20.691]                       envir = envir)
[10:25:20.691]                     if (!future$lazy) 
[10:25:20.691]                       future <- run(future)
[10:25:20.691]                     invisible(future)
[10:25:20.691]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:20.691]                 }
[10:25:20.691]             }
[10:25:20.691]         }
[10:25:20.691]     })
[10:25:20.691]     if (TRUE) {
[10:25:20.691]         base::sink(type = "output", split = FALSE)
[10:25:20.691]         if (TRUE) {
[10:25:20.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:20.691]         }
[10:25:20.691]         else {
[10:25:20.691]             ...future.result["stdout"] <- base::list(NULL)
[10:25:20.691]         }
[10:25:20.691]         base::close(...future.stdout)
[10:25:20.691]         ...future.stdout <- NULL
[10:25:20.691]     }
[10:25:20.691]     ...future.result$conditions <- ...future.conditions
[10:25:20.691]     ...future.result$finished <- base::Sys.time()
[10:25:20.691]     ...future.result
[10:25:20.691] }
[10:25:20.693] assign_globals() ...
[10:25:20.693] List of 3
[10:25:20.693]  $ fcn:function (x, y)  
[10:25:20.693]  $ x  : int [1:2] 1 2
[10:25:20.693]  $ y  : num 3
[10:25:20.693]  - attr(*, "where")=List of 3
[10:25:20.693]   ..$ fcn:<environment: R_EmptyEnv> 
[10:25:20.693]   ..$ x  :<environment: R_EmptyEnv> 
[10:25:20.693]   ..$ y  :<environment: R_EmptyEnv> 
[10:25:20.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:25:20.693]  - attr(*, "resolved")= logi FALSE
[10:25:20.693]  - attr(*, "total_size")= num 4280
[10:25:20.693]  - attr(*, "already-done")= logi TRUE
[10:25:20.697] - reassign environment for ‘fcn’
[10:25:20.697] - copied ‘fcn’ to environment
[10:25:20.698] - copied ‘x’ to environment
[10:25:20.698] - copied ‘y’ to environment
[10:25:20.698] assign_globals() ... done
[10:25:20.698] requestCore(): workers = 2
[10:25:20.700] MulticoreFuture started
[10:25:20.700] - Launch lazy future ... done
[10:25:20.700] run() for ‘MulticoreFuture’ ... done
[10:25:20.701] result() for MulticoreFuture ...
[10:25:20.701] plan(): Setting new future strategy stack:
[10:25:20.701] List of future strategies:
[10:25:20.701] 1. sequential:
[10:25:20.701]    - args: function (..., envir = parent.frame())
[10:25:20.701]    - tweaked: FALSE
[10:25:20.701]    - call: NULL
[10:25:20.702] plan(): nbrOfWorkers() = 1
[10:25:20.704] plan(): Setting new future strategy stack:
[10:25:20.704] List of future strategies:
[10:25:20.704] 1. multicore:
[10:25:20.704]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:25:20.704]    - tweaked: FALSE
[10:25:20.704]    - call: plan(strategy, substitute = FALSE)
[10:25:20.709] plan(): nbrOfWorkers() = 2
[10:25:20.710] result() for MulticoreFuture ...
[10:25:20.710] result() for MulticoreFuture ... done
[10:25:20.710] result() for MulticoreFuture ... done
[10:25:20.710] result() for MulticoreFuture ...
[10:25:20.710] result() for MulticoreFuture ... done
[1] 6
- plan('multisession') ...
[10:25:20.711] plan(): Setting new future strategy stack:
[10:25:20.711] List of future strategies:
[10:25:20.711] 1. multisession:
[10:25:20.711]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:20.711]    - tweaked: FALSE
[10:25:20.711]    - call: plan(strategy, substitute = FALSE)
[10:25:20.712] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:25:20.712] multisession:
[10:25:20.712] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:25:20.712] - tweaked: FALSE
[10:25:20.712] - call: plan(strategy, substitute = FALSE)
[10:25:20.719] getGlobalsAndPackages() ...
[10:25:20.719] Not searching for globals
[10:25:20.719] - globals: [0] <none>
[10:25:20.719] getGlobalsAndPackages() ... DONE
[10:25:20.720] [local output] makeClusterPSOCK() ...
[10:25:20.762] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:25:20.763] [local output] Base port: 11698
[10:25:20.764] [local output] Getting setup options for 2 cluster nodes ...
[10:25:20.764] [local output]  - Node 1 of 2 ...
[10:25:20.764] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:20.765] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp2TwYFY/worker.rank=1.parallelly.parent=81441.13e2149341bb4.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp2TwYFY/worker.rank=1.parallelly.parent=81441.13e2149341bb4.pid")'’
[10:25:20.951] - Possible to infer worker's PID: TRUE
[10:25:20.952] [local output] Rscript port: 11698

[10:25:20.952] [local output]  - Node 2 of 2 ...
[10:25:20.953] [local output] localMachine=TRUE => revtunnel=FALSE

[10:25:20.953] [local output] Rscript port: 11698

[10:25:20.954] [local output] Getting setup options for 2 cluster nodes ... done
[10:25:20.954] [local output]  - Parallel setup requested for some PSOCK nodes
[10:25:20.954] [local output] Setting up PSOCK nodes in parallel
[10:25:20.954] List of 36
[10:25:20.954]  $ worker          : chr "localhost"
[10:25:20.954]   ..- attr(*, "localhost")= logi TRUE
[10:25:20.954]  $ master          : chr "localhost"
[10:25:20.954]  $ port            : int 11698
[10:25:20.954]  $ connectTimeout  : num 120
[10:25:20.954]  $ timeout         : num 2592000
[10:25:20.954]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:25:20.954]  $ homogeneous     : logi TRUE
[10:25:20.954]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:25:20.954]  $ rscript_envs    : NULL
[10:25:20.954]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:20.954]  $ rscript_startup : NULL
[10:25:20.954]  $ rscript_sh      : chr "sh"
[10:25:20.954]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:20.954]  $ methods         : logi TRUE
[10:25:20.954]  $ socketOptions   : chr "no-delay"
[10:25:20.954]  $ useXDR          : logi FALSE
[10:25:20.954]  $ outfile         : chr "/dev/null"
[10:25:20.954]  $ renice          : int NA
[10:25:20.954]  $ rshcmd          : NULL
[10:25:20.954]  $ user            : chr(0) 
[10:25:20.954]  $ revtunnel       : logi FALSE
[10:25:20.954]  $ rshlogfile      : NULL
[10:25:20.954]  $ rshopts         : chr(0) 
[10:25:20.954]  $ rank            : int 1
[10:25:20.954]  $ manual          : logi FALSE
[10:25:20.954]  $ dryrun          : logi FALSE
[10:25:20.954]  $ quiet           : logi FALSE
[10:25:20.954]  $ setup_strategy  : chr "parallel"
[10:25:20.954]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:20.954]  $ pidfile         : chr "/tmp/Rtmp2TwYFY/worker.rank=1.parallelly.parent=81441.13e2149341bb4.pid"
[10:25:20.954]  $ rshcmd_label    : NULL
[10:25:20.954]  $ rsh_call        : NULL
[10:25:20.954]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:25:20.954]  $ localMachine    : logi TRUE
[10:25:20.954]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:25:20.954]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:25:20.954]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:25:20.954]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:25:20.954]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:25:20.954]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:25:20.954]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:25:20.954]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:25:20.954]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:25:20.954]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:25:20.954]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:25:20.954]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:25:20.954]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:25:20.954]  $ arguments       :List of 28
[10:25:20.954]   ..$ worker          : chr "localhost"
[10:25:20.954]   ..$ master          : NULL
[10:25:20.954]   ..$ port            : int 11698
[10:25:20.954]   ..$ connectTimeout  : num 120
[10:25:20.954]   ..$ timeout         : num 2592000
[10:25:20.954]   ..$ rscript         : NULL
[10:25:20.954]   ..$ homogeneous     : NULL
[10:25:20.954]   ..$ rscript_args    : NULL
[10:25:20.954]   ..$ rscript_envs    : NULL
[10:25:20.954]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:25:20.954]   ..$ rscript_startup : NULL
[10:25:20.954]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:25:20.954]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:25:20.954]   ..$ methods         : logi TRUE
[10:25:20.954]   ..$ socketOptions   : chr "no-delay"
[10:25:20.954]   ..$ useXDR          : logi FALSE
[10:25:20.954]   ..$ outfile         : chr "/dev/null"
[10:25:20.954]   ..$ renice          : int NA
[10:25:20.954]   ..$ rshcmd          : NULL
[10:25:20.954]   ..$ user            : NULL
[10:25:20.954]   ..$ revtunnel       : logi NA
[10:25:20.954]   ..$ rshlogfile      : NULL
[10:25:20.954]   ..$ rshopts         : NULL
[10:25:20.954]   ..$ rank            : int 1
[10:25:20.954]   ..$ manual          : logi FALSE
[10:25:20.954]   ..$ dryrun          : logi FALSE
[10:25:20.954]   ..$ quiet           : logi FALSE
[10:25:20.954]   ..$ setup_strategy  : chr "parallel"
[10:25:20.954]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:25:20.971] [local output] System call to launch all workers:
[10:25:20.971] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp2TwYFY/worker.rank=1.parallelly.parent=81441.13e2149341bb4.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11698 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:25:20.971] [local output] Starting PSOCK main server
[10:25:20.977] [local output] Workers launched
[10:25:20.977] [local output] Waiting for workers to connect back
[10:25:20.977]  - [local output] 0 workers out of 2 ready
[10:25:21.260]  - [local output] 0 workers out of 2 ready
[10:25:21.261]  - [local output] 1 workers out of 2 ready
[10:25:21.271]  - [local output] 1 workers out of 2 ready
[10:25:21.271]  - [local output] 2 workers out of 2 ready
[10:25:21.271] [local output] Launching of workers completed
[10:25:21.272] [local output] Collecting session information from workers
[10:25:21.273] [local output]  - Worker #1 of 2
[10:25:21.273] [local output]  - Worker #2 of 2
[10:25:21.273] [local output] makeClusterPSOCK() ... done
[10:25:21.284] Packages needed by the future expression (n = 0): <none>
[10:25:21.285] Packages needed by future strategies (n = 0): <none>
[10:25:21.285] {
[10:25:21.285]     {
[10:25:21.285]         {
[10:25:21.285]             ...future.startTime <- base::Sys.time()
[10:25:21.285]             {
[10:25:21.285]                 {
[10:25:21.285]                   {
[10:25:21.285]                     {
[10:25:21.285]                       base::local({
[10:25:21.285]                         has_future <- base::requireNamespace("future", 
[10:25:21.285]                           quietly = TRUE)
[10:25:21.285]                         if (has_future) {
[10:25:21.285]                           ns <- base::getNamespace("future")
[10:25:21.285]                           version <- ns[[".package"]][["version"]]
[10:25:21.285]                           if (is.null(version)) 
[10:25:21.285]                             version <- utils::packageVersion("future")
[10:25:21.285]                         }
[10:25:21.285]                         else {
[10:25:21.285]                           version <- NULL
[10:25:21.285]                         }
[10:25:21.285]                         if (!has_future || version < "1.8.0") {
[10:25:21.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.285]                             "", base::R.version$version.string), 
[10:25:21.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.285]                               "release", "version")], collapse = " "), 
[10:25:21.285]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.285]                             info)
[10:25:21.285]                           info <- base::paste(info, collapse = "; ")
[10:25:21.285]                           if (!has_future) {
[10:25:21.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.285]                               info)
[10:25:21.285]                           }
[10:25:21.285]                           else {
[10:25:21.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.285]                               info, version)
[10:25:21.285]                           }
[10:25:21.285]                           base::stop(msg)
[10:25:21.285]                         }
[10:25:21.285]                       })
[10:25:21.285]                     }
[10:25:21.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.285]                     base::options(mc.cores = 1L)
[10:25:21.285]                   }
[10:25:21.285]                   options(future.plan = NULL)
[10:25:21.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.285]                 }
[10:25:21.285]                 ...future.workdir <- getwd()
[10:25:21.285]             }
[10:25:21.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.285]         }
[10:25:21.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.285]             base::names(...future.oldOptions))
[10:25:21.285]     }
[10:25:21.285]     if (FALSE) {
[10:25:21.285]     }
[10:25:21.285]     else {
[10:25:21.285]         if (TRUE) {
[10:25:21.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.285]                 open = "w")
[10:25:21.285]         }
[10:25:21.285]         else {
[10:25:21.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.285]         }
[10:25:21.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.285]             base::sink(type = "output", split = FALSE)
[10:25:21.285]             base::close(...future.stdout)
[10:25:21.285]         }, add = TRUE)
[10:25:21.285]     }
[10:25:21.285]     ...future.frame <- base::sys.nframe()
[10:25:21.285]     ...future.conditions <- base::list()
[10:25:21.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.285]     if (FALSE) {
[10:25:21.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.285]     }
[10:25:21.285]     ...future.result <- base::tryCatch({
[10:25:21.285]         base::withCallingHandlers({
[10:25:21.285]             ...future.value <- base::withVisible(base::local({
[10:25:21.285]                 ...future.makeSendCondition <- base::local({
[10:25:21.285]                   sendCondition <- NULL
[10:25:21.285]                   function(frame = 1L) {
[10:25:21.285]                     if (is.function(sendCondition)) 
[10:25:21.285]                       return(sendCondition)
[10:25:21.285]                     ns <- getNamespace("parallel")
[10:25:21.285]                     if (exists("sendData", mode = "function", 
[10:25:21.285]                       envir = ns)) {
[10:25:21.285]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.285]                         envir = ns)
[10:25:21.285]                       envir <- sys.frame(frame)
[10:25:21.285]                       master <- NULL
[10:25:21.285]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.285]                         !identical(envir, emptyenv())) {
[10:25:21.285]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.285]                           inherits = FALSE)) {
[10:25:21.285]                           master <- get("master", mode = "list", 
[10:25:21.285]                             envir = envir, inherits = FALSE)
[10:25:21.285]                           if (inherits(master, c("SOCKnode", 
[10:25:21.285]                             "SOCK0node"))) {
[10:25:21.285]                             sendCondition <<- function(cond) {
[10:25:21.285]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.285]                                 success = TRUE)
[10:25:21.285]                               parallel_sendData(master, data)
[10:25:21.285]                             }
[10:25:21.285]                             return(sendCondition)
[10:25:21.285]                           }
[10:25:21.285]                         }
[10:25:21.285]                         frame <- frame + 1L
[10:25:21.285]                         envir <- sys.frame(frame)
[10:25:21.285]                       }
[10:25:21.285]                     }
[10:25:21.285]                     sendCondition <<- function(cond) NULL
[10:25:21.285]                   }
[10:25:21.285]                 })
[10:25:21.285]                 withCallingHandlers({
[10:25:21.285]                   NA
[10:25:21.285]                 }, immediateCondition = function(cond) {
[10:25:21.285]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.285]                   sendCondition(cond)
[10:25:21.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.285]                   {
[10:25:21.285]                     inherits <- base::inherits
[10:25:21.285]                     invokeRestart <- base::invokeRestart
[10:25:21.285]                     is.null <- base::is.null
[10:25:21.285]                     muffled <- FALSE
[10:25:21.285]                     if (inherits(cond, "message")) {
[10:25:21.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.285]                       if (muffled) 
[10:25:21.285]                         invokeRestart("muffleMessage")
[10:25:21.285]                     }
[10:25:21.285]                     else if (inherits(cond, "warning")) {
[10:25:21.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.285]                       if (muffled) 
[10:25:21.285]                         invokeRestart("muffleWarning")
[10:25:21.285]                     }
[10:25:21.285]                     else if (inherits(cond, "condition")) {
[10:25:21.285]                       if (!is.null(pattern)) {
[10:25:21.285]                         computeRestarts <- base::computeRestarts
[10:25:21.285]                         grepl <- base::grepl
[10:25:21.285]                         restarts <- computeRestarts(cond)
[10:25:21.285]                         for (restart in restarts) {
[10:25:21.285]                           name <- restart$name
[10:25:21.285]                           if (is.null(name)) 
[10:25:21.285]                             next
[10:25:21.285]                           if (!grepl(pattern, name)) 
[10:25:21.285]                             next
[10:25:21.285]                           invokeRestart(restart)
[10:25:21.285]                           muffled <- TRUE
[10:25:21.285]                           break
[10:25:21.285]                         }
[10:25:21.285]                       }
[10:25:21.285]                     }
[10:25:21.285]                     invisible(muffled)
[10:25:21.285]                   }
[10:25:21.285]                   muffleCondition(cond)
[10:25:21.285]                 })
[10:25:21.285]             }))
[10:25:21.285]             future::FutureResult(value = ...future.value$value, 
[10:25:21.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.285]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.285]                     ...future.globalenv.names))
[10:25:21.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.285]         }, condition = base::local({
[10:25:21.285]             c <- base::c
[10:25:21.285]             inherits <- base::inherits
[10:25:21.285]             invokeRestart <- base::invokeRestart
[10:25:21.285]             length <- base::length
[10:25:21.285]             list <- base::list
[10:25:21.285]             seq.int <- base::seq.int
[10:25:21.285]             signalCondition <- base::signalCondition
[10:25:21.285]             sys.calls <- base::sys.calls
[10:25:21.285]             `[[` <- base::`[[`
[10:25:21.285]             `+` <- base::`+`
[10:25:21.285]             `<<-` <- base::`<<-`
[10:25:21.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.285]                   3L)]
[10:25:21.285]             }
[10:25:21.285]             function(cond) {
[10:25:21.285]                 is_error <- inherits(cond, "error")
[10:25:21.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.285]                   NULL)
[10:25:21.285]                 if (is_error) {
[10:25:21.285]                   sessionInformation <- function() {
[10:25:21.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.285]                       search = base::search(), system = base::Sys.info())
[10:25:21.285]                   }
[10:25:21.285]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.285]                     cond$call), session = sessionInformation(), 
[10:25:21.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.285]                   signalCondition(cond)
[10:25:21.285]                 }
[10:25:21.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.285]                 "immediateCondition"))) {
[10:25:21.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.285]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.285]                   if (TRUE && !signal) {
[10:25:21.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.285]                     {
[10:25:21.285]                       inherits <- base::inherits
[10:25:21.285]                       invokeRestart <- base::invokeRestart
[10:25:21.285]                       is.null <- base::is.null
[10:25:21.285]                       muffled <- FALSE
[10:25:21.285]                       if (inherits(cond, "message")) {
[10:25:21.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.285]                         if (muffled) 
[10:25:21.285]                           invokeRestart("muffleMessage")
[10:25:21.285]                       }
[10:25:21.285]                       else if (inherits(cond, "warning")) {
[10:25:21.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.285]                         if (muffled) 
[10:25:21.285]                           invokeRestart("muffleWarning")
[10:25:21.285]                       }
[10:25:21.285]                       else if (inherits(cond, "condition")) {
[10:25:21.285]                         if (!is.null(pattern)) {
[10:25:21.285]                           computeRestarts <- base::computeRestarts
[10:25:21.285]                           grepl <- base::grepl
[10:25:21.285]                           restarts <- computeRestarts(cond)
[10:25:21.285]                           for (restart in restarts) {
[10:25:21.285]                             name <- restart$name
[10:25:21.285]                             if (is.null(name)) 
[10:25:21.285]                               next
[10:25:21.285]                             if (!grepl(pattern, name)) 
[10:25:21.285]                               next
[10:25:21.285]                             invokeRestart(restart)
[10:25:21.285]                             muffled <- TRUE
[10:25:21.285]                             break
[10:25:21.285]                           }
[10:25:21.285]                         }
[10:25:21.285]                       }
[10:25:21.285]                       invisible(muffled)
[10:25:21.285]                     }
[10:25:21.285]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.285]                   }
[10:25:21.285]                 }
[10:25:21.285]                 else {
[10:25:21.285]                   if (TRUE) {
[10:25:21.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.285]                     {
[10:25:21.285]                       inherits <- base::inherits
[10:25:21.285]                       invokeRestart <- base::invokeRestart
[10:25:21.285]                       is.null <- base::is.null
[10:25:21.285]                       muffled <- FALSE
[10:25:21.285]                       if (inherits(cond, "message")) {
[10:25:21.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.285]                         if (muffled) 
[10:25:21.285]                           invokeRestart("muffleMessage")
[10:25:21.285]                       }
[10:25:21.285]                       else if (inherits(cond, "warning")) {
[10:25:21.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.285]                         if (muffled) 
[10:25:21.285]                           invokeRestart("muffleWarning")
[10:25:21.285]                       }
[10:25:21.285]                       else if (inherits(cond, "condition")) {
[10:25:21.285]                         if (!is.null(pattern)) {
[10:25:21.285]                           computeRestarts <- base::computeRestarts
[10:25:21.285]                           grepl <- base::grepl
[10:25:21.285]                           restarts <- computeRestarts(cond)
[10:25:21.285]                           for (restart in restarts) {
[10:25:21.285]                             name <- restart$name
[10:25:21.285]                             if (is.null(name)) 
[10:25:21.285]                               next
[10:25:21.285]                             if (!grepl(pattern, name)) 
[10:25:21.285]                               next
[10:25:21.285]                             invokeRestart(restart)
[10:25:21.285]                             muffled <- TRUE
[10:25:21.285]                             break
[10:25:21.285]                           }
[10:25:21.285]                         }
[10:25:21.285]                       }
[10:25:21.285]                       invisible(muffled)
[10:25:21.285]                     }
[10:25:21.285]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.285]                   }
[10:25:21.285]                 }
[10:25:21.285]             }
[10:25:21.285]         }))
[10:25:21.285]     }, error = function(ex) {
[10:25:21.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.285]                 ...future.rng), started = ...future.startTime, 
[10:25:21.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.285]             version = "1.8"), class = "FutureResult")
[10:25:21.285]     }, finally = {
[10:25:21.285]         if (!identical(...future.workdir, getwd())) 
[10:25:21.285]             setwd(...future.workdir)
[10:25:21.285]         {
[10:25:21.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.285]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.285]             }
[10:25:21.285]             base::options(...future.oldOptions)
[10:25:21.285]             if (.Platform$OS.type == "windows") {
[10:25:21.285]                 old_names <- names(...future.oldEnvVars)
[10:25:21.285]                 envs <- base::Sys.getenv()
[10:25:21.285]                 names <- names(envs)
[10:25:21.285]                 common <- intersect(names, old_names)
[10:25:21.285]                 added <- setdiff(names, old_names)
[10:25:21.285]                 removed <- setdiff(old_names, names)
[10:25:21.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.285]                   envs[common]]
[10:25:21.285]                 NAMES <- toupper(changed)
[10:25:21.285]                 args <- list()
[10:25:21.285]                 for (kk in seq_along(NAMES)) {
[10:25:21.285]                   name <- changed[[kk]]
[10:25:21.285]                   NAME <- NAMES[[kk]]
[10:25:21.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.285]                     next
[10:25:21.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.285]                 }
[10:25:21.285]                 NAMES <- toupper(added)
[10:25:21.285]                 for (kk in seq_along(NAMES)) {
[10:25:21.285]                   name <- added[[kk]]
[10:25:21.285]                   NAME <- NAMES[[kk]]
[10:25:21.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.285]                     next
[10:25:21.285]                   args[[name]] <- ""
[10:25:21.285]                 }
[10:25:21.285]                 NAMES <- toupper(removed)
[10:25:21.285]                 for (kk in seq_along(NAMES)) {
[10:25:21.285]                   name <- removed[[kk]]
[10:25:21.285]                   NAME <- NAMES[[kk]]
[10:25:21.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.285]                     next
[10:25:21.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.285]                 }
[10:25:21.285]                 if (length(args) > 0) 
[10:25:21.285]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.285]             }
[10:25:21.285]             else {
[10:25:21.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.285]             }
[10:25:21.285]             {
[10:25:21.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.285]                   0L) {
[10:25:21.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.285]                   base::options(opts)
[10:25:21.285]                 }
[10:25:21.285]                 {
[10:25:21.285]                   {
[10:25:21.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.285]                     NULL
[10:25:21.285]                   }
[10:25:21.285]                   options(future.plan = NULL)
[10:25:21.285]                   if (is.na(NA_character_)) 
[10:25:21.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.285]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.285]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.285]                     envir = parent.frame()) 
[10:25:21.285]                   {
[10:25:21.285]                     if (is.function(workers)) 
[10:25:21.285]                       workers <- workers()
[10:25:21.285]                     workers <- structure(as.integer(workers), 
[10:25:21.285]                       class = class(workers))
[10:25:21.285]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.285]                       workers >= 1)
[10:25:21.285]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.285]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.285]                     }
[10:25:21.285]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.285]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.285]                       envir = envir)
[10:25:21.285]                     if (!future$lazy) 
[10:25:21.285]                       future <- run(future)
[10:25:21.285]                     invisible(future)
[10:25:21.285]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.285]                 }
[10:25:21.285]             }
[10:25:21.285]         }
[10:25:21.285]     })
[10:25:21.285]     if (TRUE) {
[10:25:21.285]         base::sink(type = "output", split = FALSE)
[10:25:21.285]         if (TRUE) {
[10:25:21.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.285]         }
[10:25:21.285]         else {
[10:25:21.285]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.285]         }
[10:25:21.285]         base::close(...future.stdout)
[10:25:21.285]         ...future.stdout <- NULL
[10:25:21.285]     }
[10:25:21.285]     ...future.result$conditions <- ...future.conditions
[10:25:21.285]     ...future.result$finished <- base::Sys.time()
[10:25:21.285]     ...future.result
[10:25:21.285] }
[10:25:21.339] MultisessionFuture started
[10:25:21.339] result() for ClusterFuture ...
[10:25:21.340] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.340] - Validating connection of MultisessionFuture
[10:25:21.383] - received message: FutureResult
[10:25:21.383] - Received FutureResult
[10:25:21.383] - Erased future from FutureRegistry
[10:25:21.383] result() for ClusterFuture ...
[10:25:21.383] - result already collected: FutureResult
[10:25:21.384] result() for ClusterFuture ... done
[10:25:21.384] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.384] result() for ClusterFuture ... done
[10:25:21.384] result() for ClusterFuture ...
[10:25:21.384] - result already collected: FutureResult
[10:25:21.384] result() for ClusterFuture ... done
[10:25:21.384] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:25:21.388] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x558a91ddaab8>
Arguments '...' exists: TRUE
[10:25:21.389] getGlobalsAndPackages() ...
[10:25:21.389] Searching for globals...
[10:25:21.391] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:21.391] Searching for globals ... DONE
[10:25:21.391] Resolving globals: FALSE
[10:25:21.391] Tweak future expression to call with '...' arguments ...
[10:25:21.391] {
[10:25:21.391]     do.call(function(...) {
[10:25:21.391]         sum(x, ...)
[10:25:21.391]     }, args = future.call.arguments)
[10:25:21.391] }
[10:25:21.392] Tweak future expression to call with '...' arguments ... DONE
[10:25:21.392] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:21.393] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:21.393] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:21.393] 
[10:25:21.393] getGlobalsAndPackages() ... DONE
[10:25:21.393] run() for ‘Future’ ...
[10:25:21.394] - state: ‘created’
[10:25:21.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.408]   - Field: ‘node’
[10:25:21.408]   - Field: ‘label’
[10:25:21.408]   - Field: ‘local’
[10:25:21.408]   - Field: ‘owner’
[10:25:21.409]   - Field: ‘envir’
[10:25:21.409]   - Field: ‘workers’
[10:25:21.409]   - Field: ‘packages’
[10:25:21.409]   - Field: ‘gc’
[10:25:21.409]   - Field: ‘conditions’
[10:25:21.409]   - Field: ‘persistent’
[10:25:21.409]   - Field: ‘expr’
[10:25:21.409]   - Field: ‘uuid’
[10:25:21.409]   - Field: ‘seed’
[10:25:21.410]   - Field: ‘version’
[10:25:21.410]   - Field: ‘result’
[10:25:21.410]   - Field: ‘asynchronous’
[10:25:21.410]   - Field: ‘calls’
[10:25:21.410]   - Field: ‘globals’
[10:25:21.410]   - Field: ‘stdout’
[10:25:21.410]   - Field: ‘earlySignal’
[10:25:21.410]   - Field: ‘lazy’
[10:25:21.411]   - Field: ‘state’
[10:25:21.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.411] - Launch lazy future ...
[10:25:21.411] Packages needed by the future expression (n = 0): <none>
[10:25:21.411] Packages needed by future strategies (n = 0): <none>
[10:25:21.412] {
[10:25:21.412]     {
[10:25:21.412]         {
[10:25:21.412]             ...future.startTime <- base::Sys.time()
[10:25:21.412]             {
[10:25:21.412]                 {
[10:25:21.412]                   {
[10:25:21.412]                     {
[10:25:21.412]                       base::local({
[10:25:21.412]                         has_future <- base::requireNamespace("future", 
[10:25:21.412]                           quietly = TRUE)
[10:25:21.412]                         if (has_future) {
[10:25:21.412]                           ns <- base::getNamespace("future")
[10:25:21.412]                           version <- ns[[".package"]][["version"]]
[10:25:21.412]                           if (is.null(version)) 
[10:25:21.412]                             version <- utils::packageVersion("future")
[10:25:21.412]                         }
[10:25:21.412]                         else {
[10:25:21.412]                           version <- NULL
[10:25:21.412]                         }
[10:25:21.412]                         if (!has_future || version < "1.8.0") {
[10:25:21.412]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.412]                             "", base::R.version$version.string), 
[10:25:21.412]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.412]                               "release", "version")], collapse = " "), 
[10:25:21.412]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.412]                             info)
[10:25:21.412]                           info <- base::paste(info, collapse = "; ")
[10:25:21.412]                           if (!has_future) {
[10:25:21.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.412]                               info)
[10:25:21.412]                           }
[10:25:21.412]                           else {
[10:25:21.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.412]                               info, version)
[10:25:21.412]                           }
[10:25:21.412]                           base::stop(msg)
[10:25:21.412]                         }
[10:25:21.412]                       })
[10:25:21.412]                     }
[10:25:21.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.412]                     base::options(mc.cores = 1L)
[10:25:21.412]                   }
[10:25:21.412]                   options(future.plan = NULL)
[10:25:21.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.412]                 }
[10:25:21.412]                 ...future.workdir <- getwd()
[10:25:21.412]             }
[10:25:21.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.412]         }
[10:25:21.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.412]             base::names(...future.oldOptions))
[10:25:21.412]     }
[10:25:21.412]     if (FALSE) {
[10:25:21.412]     }
[10:25:21.412]     else {
[10:25:21.412]         if (TRUE) {
[10:25:21.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.412]                 open = "w")
[10:25:21.412]         }
[10:25:21.412]         else {
[10:25:21.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.412]         }
[10:25:21.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.412]             base::sink(type = "output", split = FALSE)
[10:25:21.412]             base::close(...future.stdout)
[10:25:21.412]         }, add = TRUE)
[10:25:21.412]     }
[10:25:21.412]     ...future.frame <- base::sys.nframe()
[10:25:21.412]     ...future.conditions <- base::list()
[10:25:21.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.412]     if (FALSE) {
[10:25:21.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.412]     }
[10:25:21.412]     ...future.result <- base::tryCatch({
[10:25:21.412]         base::withCallingHandlers({
[10:25:21.412]             ...future.value <- base::withVisible(base::local({
[10:25:21.412]                 ...future.makeSendCondition <- base::local({
[10:25:21.412]                   sendCondition <- NULL
[10:25:21.412]                   function(frame = 1L) {
[10:25:21.412]                     if (is.function(sendCondition)) 
[10:25:21.412]                       return(sendCondition)
[10:25:21.412]                     ns <- getNamespace("parallel")
[10:25:21.412]                     if (exists("sendData", mode = "function", 
[10:25:21.412]                       envir = ns)) {
[10:25:21.412]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.412]                         envir = ns)
[10:25:21.412]                       envir <- sys.frame(frame)
[10:25:21.412]                       master <- NULL
[10:25:21.412]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.412]                         !identical(envir, emptyenv())) {
[10:25:21.412]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.412]                           inherits = FALSE)) {
[10:25:21.412]                           master <- get("master", mode = "list", 
[10:25:21.412]                             envir = envir, inherits = FALSE)
[10:25:21.412]                           if (inherits(master, c("SOCKnode", 
[10:25:21.412]                             "SOCK0node"))) {
[10:25:21.412]                             sendCondition <<- function(cond) {
[10:25:21.412]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.412]                                 success = TRUE)
[10:25:21.412]                               parallel_sendData(master, data)
[10:25:21.412]                             }
[10:25:21.412]                             return(sendCondition)
[10:25:21.412]                           }
[10:25:21.412]                         }
[10:25:21.412]                         frame <- frame + 1L
[10:25:21.412]                         envir <- sys.frame(frame)
[10:25:21.412]                       }
[10:25:21.412]                     }
[10:25:21.412]                     sendCondition <<- function(cond) NULL
[10:25:21.412]                   }
[10:25:21.412]                 })
[10:25:21.412]                 withCallingHandlers({
[10:25:21.412]                   {
[10:25:21.412]                     do.call(function(...) {
[10:25:21.412]                       sum(x, ...)
[10:25:21.412]                     }, args = future.call.arguments)
[10:25:21.412]                   }
[10:25:21.412]                 }, immediateCondition = function(cond) {
[10:25:21.412]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.412]                   sendCondition(cond)
[10:25:21.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.412]                   {
[10:25:21.412]                     inherits <- base::inherits
[10:25:21.412]                     invokeRestart <- base::invokeRestart
[10:25:21.412]                     is.null <- base::is.null
[10:25:21.412]                     muffled <- FALSE
[10:25:21.412]                     if (inherits(cond, "message")) {
[10:25:21.412]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.412]                       if (muffled) 
[10:25:21.412]                         invokeRestart("muffleMessage")
[10:25:21.412]                     }
[10:25:21.412]                     else if (inherits(cond, "warning")) {
[10:25:21.412]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.412]                       if (muffled) 
[10:25:21.412]                         invokeRestart("muffleWarning")
[10:25:21.412]                     }
[10:25:21.412]                     else if (inherits(cond, "condition")) {
[10:25:21.412]                       if (!is.null(pattern)) {
[10:25:21.412]                         computeRestarts <- base::computeRestarts
[10:25:21.412]                         grepl <- base::grepl
[10:25:21.412]                         restarts <- computeRestarts(cond)
[10:25:21.412]                         for (restart in restarts) {
[10:25:21.412]                           name <- restart$name
[10:25:21.412]                           if (is.null(name)) 
[10:25:21.412]                             next
[10:25:21.412]                           if (!grepl(pattern, name)) 
[10:25:21.412]                             next
[10:25:21.412]                           invokeRestart(restart)
[10:25:21.412]                           muffled <- TRUE
[10:25:21.412]                           break
[10:25:21.412]                         }
[10:25:21.412]                       }
[10:25:21.412]                     }
[10:25:21.412]                     invisible(muffled)
[10:25:21.412]                   }
[10:25:21.412]                   muffleCondition(cond)
[10:25:21.412]                 })
[10:25:21.412]             }))
[10:25:21.412]             future::FutureResult(value = ...future.value$value, 
[10:25:21.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.412]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.412]                     ...future.globalenv.names))
[10:25:21.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.412]         }, condition = base::local({
[10:25:21.412]             c <- base::c
[10:25:21.412]             inherits <- base::inherits
[10:25:21.412]             invokeRestart <- base::invokeRestart
[10:25:21.412]             length <- base::length
[10:25:21.412]             list <- base::list
[10:25:21.412]             seq.int <- base::seq.int
[10:25:21.412]             signalCondition <- base::signalCondition
[10:25:21.412]             sys.calls <- base::sys.calls
[10:25:21.412]             `[[` <- base::`[[`
[10:25:21.412]             `+` <- base::`+`
[10:25:21.412]             `<<-` <- base::`<<-`
[10:25:21.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.412]                   3L)]
[10:25:21.412]             }
[10:25:21.412]             function(cond) {
[10:25:21.412]                 is_error <- inherits(cond, "error")
[10:25:21.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.412]                   NULL)
[10:25:21.412]                 if (is_error) {
[10:25:21.412]                   sessionInformation <- function() {
[10:25:21.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.412]                       search = base::search(), system = base::Sys.info())
[10:25:21.412]                   }
[10:25:21.412]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.412]                     cond$call), session = sessionInformation(), 
[10:25:21.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.412]                   signalCondition(cond)
[10:25:21.412]                 }
[10:25:21.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.412]                 "immediateCondition"))) {
[10:25:21.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.412]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.412]                   if (TRUE && !signal) {
[10:25:21.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.412]                     {
[10:25:21.412]                       inherits <- base::inherits
[10:25:21.412]                       invokeRestart <- base::invokeRestart
[10:25:21.412]                       is.null <- base::is.null
[10:25:21.412]                       muffled <- FALSE
[10:25:21.412]                       if (inherits(cond, "message")) {
[10:25:21.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.412]                         if (muffled) 
[10:25:21.412]                           invokeRestart("muffleMessage")
[10:25:21.412]                       }
[10:25:21.412]                       else if (inherits(cond, "warning")) {
[10:25:21.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.412]                         if (muffled) 
[10:25:21.412]                           invokeRestart("muffleWarning")
[10:25:21.412]                       }
[10:25:21.412]                       else if (inherits(cond, "condition")) {
[10:25:21.412]                         if (!is.null(pattern)) {
[10:25:21.412]                           computeRestarts <- base::computeRestarts
[10:25:21.412]                           grepl <- base::grepl
[10:25:21.412]                           restarts <- computeRestarts(cond)
[10:25:21.412]                           for (restart in restarts) {
[10:25:21.412]                             name <- restart$name
[10:25:21.412]                             if (is.null(name)) 
[10:25:21.412]                               next
[10:25:21.412]                             if (!grepl(pattern, name)) 
[10:25:21.412]                               next
[10:25:21.412]                             invokeRestart(restart)
[10:25:21.412]                             muffled <- TRUE
[10:25:21.412]                             break
[10:25:21.412]                           }
[10:25:21.412]                         }
[10:25:21.412]                       }
[10:25:21.412]                       invisible(muffled)
[10:25:21.412]                     }
[10:25:21.412]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.412]                   }
[10:25:21.412]                 }
[10:25:21.412]                 else {
[10:25:21.412]                   if (TRUE) {
[10:25:21.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.412]                     {
[10:25:21.412]                       inherits <- base::inherits
[10:25:21.412]                       invokeRestart <- base::invokeRestart
[10:25:21.412]                       is.null <- base::is.null
[10:25:21.412]                       muffled <- FALSE
[10:25:21.412]                       if (inherits(cond, "message")) {
[10:25:21.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.412]                         if (muffled) 
[10:25:21.412]                           invokeRestart("muffleMessage")
[10:25:21.412]                       }
[10:25:21.412]                       else if (inherits(cond, "warning")) {
[10:25:21.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.412]                         if (muffled) 
[10:25:21.412]                           invokeRestart("muffleWarning")
[10:25:21.412]                       }
[10:25:21.412]                       else if (inherits(cond, "condition")) {
[10:25:21.412]                         if (!is.null(pattern)) {
[10:25:21.412]                           computeRestarts <- base::computeRestarts
[10:25:21.412]                           grepl <- base::grepl
[10:25:21.412]                           restarts <- computeRestarts(cond)
[10:25:21.412]                           for (restart in restarts) {
[10:25:21.412]                             name <- restart$name
[10:25:21.412]                             if (is.null(name)) 
[10:25:21.412]                               next
[10:25:21.412]                             if (!grepl(pattern, name)) 
[10:25:21.412]                               next
[10:25:21.412]                             invokeRestart(restart)
[10:25:21.412]                             muffled <- TRUE
[10:25:21.412]                             break
[10:25:21.412]                           }
[10:25:21.412]                         }
[10:25:21.412]                       }
[10:25:21.412]                       invisible(muffled)
[10:25:21.412]                     }
[10:25:21.412]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.412]                   }
[10:25:21.412]                 }
[10:25:21.412]             }
[10:25:21.412]         }))
[10:25:21.412]     }, error = function(ex) {
[10:25:21.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.412]                 ...future.rng), started = ...future.startTime, 
[10:25:21.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.412]             version = "1.8"), class = "FutureResult")
[10:25:21.412]     }, finally = {
[10:25:21.412]         if (!identical(...future.workdir, getwd())) 
[10:25:21.412]             setwd(...future.workdir)
[10:25:21.412]         {
[10:25:21.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.412]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.412]             }
[10:25:21.412]             base::options(...future.oldOptions)
[10:25:21.412]             if (.Platform$OS.type == "windows") {
[10:25:21.412]                 old_names <- names(...future.oldEnvVars)
[10:25:21.412]                 envs <- base::Sys.getenv()
[10:25:21.412]                 names <- names(envs)
[10:25:21.412]                 common <- intersect(names, old_names)
[10:25:21.412]                 added <- setdiff(names, old_names)
[10:25:21.412]                 removed <- setdiff(old_names, names)
[10:25:21.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.412]                   envs[common]]
[10:25:21.412]                 NAMES <- toupper(changed)
[10:25:21.412]                 args <- list()
[10:25:21.412]                 for (kk in seq_along(NAMES)) {
[10:25:21.412]                   name <- changed[[kk]]
[10:25:21.412]                   NAME <- NAMES[[kk]]
[10:25:21.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.412]                     next
[10:25:21.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.412]                 }
[10:25:21.412]                 NAMES <- toupper(added)
[10:25:21.412]                 for (kk in seq_along(NAMES)) {
[10:25:21.412]                   name <- added[[kk]]
[10:25:21.412]                   NAME <- NAMES[[kk]]
[10:25:21.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.412]                     next
[10:25:21.412]                   args[[name]] <- ""
[10:25:21.412]                 }
[10:25:21.412]                 NAMES <- toupper(removed)
[10:25:21.412]                 for (kk in seq_along(NAMES)) {
[10:25:21.412]                   name <- removed[[kk]]
[10:25:21.412]                   NAME <- NAMES[[kk]]
[10:25:21.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.412]                     next
[10:25:21.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.412]                 }
[10:25:21.412]                 if (length(args) > 0) 
[10:25:21.412]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.412]             }
[10:25:21.412]             else {
[10:25:21.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.412]             }
[10:25:21.412]             {
[10:25:21.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.412]                   0L) {
[10:25:21.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.412]                   base::options(opts)
[10:25:21.412]                 }
[10:25:21.412]                 {
[10:25:21.412]                   {
[10:25:21.412]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.412]                     NULL
[10:25:21.412]                   }
[10:25:21.412]                   options(future.plan = NULL)
[10:25:21.412]                   if (is.na(NA_character_)) 
[10:25:21.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.412]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.412]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.412]                     envir = parent.frame()) 
[10:25:21.412]                   {
[10:25:21.412]                     if (is.function(workers)) 
[10:25:21.412]                       workers <- workers()
[10:25:21.412]                     workers <- structure(as.integer(workers), 
[10:25:21.412]                       class = class(workers))
[10:25:21.412]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.412]                       workers >= 1)
[10:25:21.412]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.412]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.412]                     }
[10:25:21.412]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.412]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.412]                       envir = envir)
[10:25:21.412]                     if (!future$lazy) 
[10:25:21.412]                       future <- run(future)
[10:25:21.412]                     invisible(future)
[10:25:21.412]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.412]                 }
[10:25:21.412]             }
[10:25:21.412]         }
[10:25:21.412]     })
[10:25:21.412]     if (TRUE) {
[10:25:21.412]         base::sink(type = "output", split = FALSE)
[10:25:21.412]         if (TRUE) {
[10:25:21.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.412]         }
[10:25:21.412]         else {
[10:25:21.412]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.412]         }
[10:25:21.412]         base::close(...future.stdout)
[10:25:21.412]         ...future.stdout <- NULL
[10:25:21.412]     }
[10:25:21.412]     ...future.result$conditions <- ...future.conditions
[10:25:21.412]     ...future.result$finished <- base::Sys.time()
[10:25:21.412]     ...future.result
[10:25:21.412] }
[10:25:21.415] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:25:21.415] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:25:21.415] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.416] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:25:21.416] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.416] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:25:21.417] MultisessionFuture started
[10:25:21.417] - Launch lazy future ... done
[10:25:21.417] run() for ‘MultisessionFuture’ ... done
[10:25:21.417] result() for ClusterFuture ...
[10:25:21.417] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.418] - Validating connection of MultisessionFuture
[10:25:21.462] - received message: FutureResult
[10:25:21.462] - Received FutureResult
[10:25:21.462] - Erased future from FutureRegistry
[10:25:21.463] result() for ClusterFuture ...
[10:25:21.463] - result already collected: FutureResult
[10:25:21.463] result() for ClusterFuture ... done
[10:25:21.463] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.463] result() for ClusterFuture ... done
[10:25:21.463] result() for ClusterFuture ...
[10:25:21.463] - result already collected: FutureResult
[10:25:21.463] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x558a92094f00>
Arguments '...' exists: TRUE
[10:25:21.464] getGlobalsAndPackages() ...
[10:25:21.464] Searching for globals...
[10:25:21.466] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[10:25:21.466] Searching for globals ... DONE
[10:25:21.466] Resolving globals: FALSE
[10:25:21.466] Tweak future expression to call with '...' arguments ...
[10:25:21.466] {
[10:25:21.466]     do.call(function(...) {
[10:25:21.466]         sum(x, ...)
[10:25:21.466]     }, args = future.call.arguments)
[10:25:21.466] }
[10:25:21.467] Tweak future expression to call with '...' arguments ... DONE
[10:25:21.467] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:21.468] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘future.call.arguments’ (56 bytes of class ‘list’)
[10:25:21.468] - globals: [2] ‘x’, ‘future.call.arguments’
[10:25:21.468] 
[10:25:21.468] getGlobalsAndPackages() ... DONE
[10:25:21.468] run() for ‘Future’ ...
[10:25:21.469] - state: ‘created’
[10:25:21.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.483]   - Field: ‘node’
[10:25:21.483]   - Field: ‘label’
[10:25:21.483]   - Field: ‘local’
[10:25:21.484]   - Field: ‘owner’
[10:25:21.484]   - Field: ‘envir’
[10:25:21.484]   - Field: ‘workers’
[10:25:21.484]   - Field: ‘packages’
[10:25:21.484]   - Field: ‘gc’
[10:25:21.484]   - Field: ‘conditions’
[10:25:21.484]   - Field: ‘persistent’
[10:25:21.484]   - Field: ‘expr’
[10:25:21.484]   - Field: ‘uuid’
[10:25:21.484]   - Field: ‘seed’
[10:25:21.485]   - Field: ‘version’
[10:25:21.485]   - Field: ‘result’
[10:25:21.485]   - Field: ‘asynchronous’
[10:25:21.485]   - Field: ‘calls’
[10:25:21.485]   - Field: ‘globals’
[10:25:21.485]   - Field: ‘stdout’
[10:25:21.485]   - Field: ‘earlySignal’
[10:25:21.485]   - Field: ‘lazy’
[10:25:21.486]   - Field: ‘state’
[10:25:21.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.486] - Launch lazy future ...
[10:25:21.486] Packages needed by the future expression (n = 0): <none>
[10:25:21.486] Packages needed by future strategies (n = 0): <none>
[10:25:21.487] {
[10:25:21.487]     {
[10:25:21.487]         {
[10:25:21.487]             ...future.startTime <- base::Sys.time()
[10:25:21.487]             {
[10:25:21.487]                 {
[10:25:21.487]                   {
[10:25:21.487]                     {
[10:25:21.487]                       base::local({
[10:25:21.487]                         has_future <- base::requireNamespace("future", 
[10:25:21.487]                           quietly = TRUE)
[10:25:21.487]                         if (has_future) {
[10:25:21.487]                           ns <- base::getNamespace("future")
[10:25:21.487]                           version <- ns[[".package"]][["version"]]
[10:25:21.487]                           if (is.null(version)) 
[10:25:21.487]                             version <- utils::packageVersion("future")
[10:25:21.487]                         }
[10:25:21.487]                         else {
[10:25:21.487]                           version <- NULL
[10:25:21.487]                         }
[10:25:21.487]                         if (!has_future || version < "1.8.0") {
[10:25:21.487]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.487]                             "", base::R.version$version.string), 
[10:25:21.487]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.487]                               "release", "version")], collapse = " "), 
[10:25:21.487]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.487]                             info)
[10:25:21.487]                           info <- base::paste(info, collapse = "; ")
[10:25:21.487]                           if (!has_future) {
[10:25:21.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.487]                               info)
[10:25:21.487]                           }
[10:25:21.487]                           else {
[10:25:21.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.487]                               info, version)
[10:25:21.487]                           }
[10:25:21.487]                           base::stop(msg)
[10:25:21.487]                         }
[10:25:21.487]                       })
[10:25:21.487]                     }
[10:25:21.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.487]                     base::options(mc.cores = 1L)
[10:25:21.487]                   }
[10:25:21.487]                   options(future.plan = NULL)
[10:25:21.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.487]                 }
[10:25:21.487]                 ...future.workdir <- getwd()
[10:25:21.487]             }
[10:25:21.487]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.487]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.487]         }
[10:25:21.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.487]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.487]             base::names(...future.oldOptions))
[10:25:21.487]     }
[10:25:21.487]     if (FALSE) {
[10:25:21.487]     }
[10:25:21.487]     else {
[10:25:21.487]         if (TRUE) {
[10:25:21.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.487]                 open = "w")
[10:25:21.487]         }
[10:25:21.487]         else {
[10:25:21.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.487]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.487]         }
[10:25:21.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.487]             base::sink(type = "output", split = FALSE)
[10:25:21.487]             base::close(...future.stdout)
[10:25:21.487]         }, add = TRUE)
[10:25:21.487]     }
[10:25:21.487]     ...future.frame <- base::sys.nframe()
[10:25:21.487]     ...future.conditions <- base::list()
[10:25:21.487]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.487]     if (FALSE) {
[10:25:21.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.487]     }
[10:25:21.487]     ...future.result <- base::tryCatch({
[10:25:21.487]         base::withCallingHandlers({
[10:25:21.487]             ...future.value <- base::withVisible(base::local({
[10:25:21.487]                 ...future.makeSendCondition <- base::local({
[10:25:21.487]                   sendCondition <- NULL
[10:25:21.487]                   function(frame = 1L) {
[10:25:21.487]                     if (is.function(sendCondition)) 
[10:25:21.487]                       return(sendCondition)
[10:25:21.487]                     ns <- getNamespace("parallel")
[10:25:21.487]                     if (exists("sendData", mode = "function", 
[10:25:21.487]                       envir = ns)) {
[10:25:21.487]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.487]                         envir = ns)
[10:25:21.487]                       envir <- sys.frame(frame)
[10:25:21.487]                       master <- NULL
[10:25:21.487]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.487]                         !identical(envir, emptyenv())) {
[10:25:21.487]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.487]                           inherits = FALSE)) {
[10:25:21.487]                           master <- get("master", mode = "list", 
[10:25:21.487]                             envir = envir, inherits = FALSE)
[10:25:21.487]                           if (inherits(master, c("SOCKnode", 
[10:25:21.487]                             "SOCK0node"))) {
[10:25:21.487]                             sendCondition <<- function(cond) {
[10:25:21.487]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.487]                                 success = TRUE)
[10:25:21.487]                               parallel_sendData(master, data)
[10:25:21.487]                             }
[10:25:21.487]                             return(sendCondition)
[10:25:21.487]                           }
[10:25:21.487]                         }
[10:25:21.487]                         frame <- frame + 1L
[10:25:21.487]                         envir <- sys.frame(frame)
[10:25:21.487]                       }
[10:25:21.487]                     }
[10:25:21.487]                     sendCondition <<- function(cond) NULL
[10:25:21.487]                   }
[10:25:21.487]                 })
[10:25:21.487]                 withCallingHandlers({
[10:25:21.487]                   {
[10:25:21.487]                     do.call(function(...) {
[10:25:21.487]                       sum(x, ...)
[10:25:21.487]                     }, args = future.call.arguments)
[10:25:21.487]                   }
[10:25:21.487]                 }, immediateCondition = function(cond) {
[10:25:21.487]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.487]                   sendCondition(cond)
[10:25:21.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.487]                   {
[10:25:21.487]                     inherits <- base::inherits
[10:25:21.487]                     invokeRestart <- base::invokeRestart
[10:25:21.487]                     is.null <- base::is.null
[10:25:21.487]                     muffled <- FALSE
[10:25:21.487]                     if (inherits(cond, "message")) {
[10:25:21.487]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.487]                       if (muffled) 
[10:25:21.487]                         invokeRestart("muffleMessage")
[10:25:21.487]                     }
[10:25:21.487]                     else if (inherits(cond, "warning")) {
[10:25:21.487]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.487]                       if (muffled) 
[10:25:21.487]                         invokeRestart("muffleWarning")
[10:25:21.487]                     }
[10:25:21.487]                     else if (inherits(cond, "condition")) {
[10:25:21.487]                       if (!is.null(pattern)) {
[10:25:21.487]                         computeRestarts <- base::computeRestarts
[10:25:21.487]                         grepl <- base::grepl
[10:25:21.487]                         restarts <- computeRestarts(cond)
[10:25:21.487]                         for (restart in restarts) {
[10:25:21.487]                           name <- restart$name
[10:25:21.487]                           if (is.null(name)) 
[10:25:21.487]                             next
[10:25:21.487]                           if (!grepl(pattern, name)) 
[10:25:21.487]                             next
[10:25:21.487]                           invokeRestart(restart)
[10:25:21.487]                           muffled <- TRUE
[10:25:21.487]                           break
[10:25:21.487]                         }
[10:25:21.487]                       }
[10:25:21.487]                     }
[10:25:21.487]                     invisible(muffled)
[10:25:21.487]                   }
[10:25:21.487]                   muffleCondition(cond)
[10:25:21.487]                 })
[10:25:21.487]             }))
[10:25:21.487]             future::FutureResult(value = ...future.value$value, 
[10:25:21.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.487]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.487]                     ...future.globalenv.names))
[10:25:21.487]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.487]         }, condition = base::local({
[10:25:21.487]             c <- base::c
[10:25:21.487]             inherits <- base::inherits
[10:25:21.487]             invokeRestart <- base::invokeRestart
[10:25:21.487]             length <- base::length
[10:25:21.487]             list <- base::list
[10:25:21.487]             seq.int <- base::seq.int
[10:25:21.487]             signalCondition <- base::signalCondition
[10:25:21.487]             sys.calls <- base::sys.calls
[10:25:21.487]             `[[` <- base::`[[`
[10:25:21.487]             `+` <- base::`+`
[10:25:21.487]             `<<-` <- base::`<<-`
[10:25:21.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.487]                   3L)]
[10:25:21.487]             }
[10:25:21.487]             function(cond) {
[10:25:21.487]                 is_error <- inherits(cond, "error")
[10:25:21.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.487]                   NULL)
[10:25:21.487]                 if (is_error) {
[10:25:21.487]                   sessionInformation <- function() {
[10:25:21.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.487]                       search = base::search(), system = base::Sys.info())
[10:25:21.487]                   }
[10:25:21.487]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.487]                     cond$call), session = sessionInformation(), 
[10:25:21.487]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.487]                   signalCondition(cond)
[10:25:21.487]                 }
[10:25:21.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.487]                 "immediateCondition"))) {
[10:25:21.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.487]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.487]                   if (TRUE && !signal) {
[10:25:21.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.487]                     {
[10:25:21.487]                       inherits <- base::inherits
[10:25:21.487]                       invokeRestart <- base::invokeRestart
[10:25:21.487]                       is.null <- base::is.null
[10:25:21.487]                       muffled <- FALSE
[10:25:21.487]                       if (inherits(cond, "message")) {
[10:25:21.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.487]                         if (muffled) 
[10:25:21.487]                           invokeRestart("muffleMessage")
[10:25:21.487]                       }
[10:25:21.487]                       else if (inherits(cond, "warning")) {
[10:25:21.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.487]                         if (muffled) 
[10:25:21.487]                           invokeRestart("muffleWarning")
[10:25:21.487]                       }
[10:25:21.487]                       else if (inherits(cond, "condition")) {
[10:25:21.487]                         if (!is.null(pattern)) {
[10:25:21.487]                           computeRestarts <- base::computeRestarts
[10:25:21.487]                           grepl <- base::grepl
[10:25:21.487]                           restarts <- computeRestarts(cond)
[10:25:21.487]                           for (restart in restarts) {
[10:25:21.487]                             name <- restart$name
[10:25:21.487]                             if (is.null(name)) 
[10:25:21.487]                               next
[10:25:21.487]                             if (!grepl(pattern, name)) 
[10:25:21.487]                               next
[10:25:21.487]                             invokeRestart(restart)
[10:25:21.487]                             muffled <- TRUE
[10:25:21.487]                             break
[10:25:21.487]                           }
[10:25:21.487]                         }
[10:25:21.487]                       }
[10:25:21.487]                       invisible(muffled)
[10:25:21.487]                     }
[10:25:21.487]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.487]                   }
[10:25:21.487]                 }
[10:25:21.487]                 else {
[10:25:21.487]                   if (TRUE) {
[10:25:21.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.487]                     {
[10:25:21.487]                       inherits <- base::inherits
[10:25:21.487]                       invokeRestart <- base::invokeRestart
[10:25:21.487]                       is.null <- base::is.null
[10:25:21.487]                       muffled <- FALSE
[10:25:21.487]                       if (inherits(cond, "message")) {
[10:25:21.487]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.487]                         if (muffled) 
[10:25:21.487]                           invokeRestart("muffleMessage")
[10:25:21.487]                       }
[10:25:21.487]                       else if (inherits(cond, "warning")) {
[10:25:21.487]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.487]                         if (muffled) 
[10:25:21.487]                           invokeRestart("muffleWarning")
[10:25:21.487]                       }
[10:25:21.487]                       else if (inherits(cond, "condition")) {
[10:25:21.487]                         if (!is.null(pattern)) {
[10:25:21.487]                           computeRestarts <- base::computeRestarts
[10:25:21.487]                           grepl <- base::grepl
[10:25:21.487]                           restarts <- computeRestarts(cond)
[10:25:21.487]                           for (restart in restarts) {
[10:25:21.487]                             name <- restart$name
[10:25:21.487]                             if (is.null(name)) 
[10:25:21.487]                               next
[10:25:21.487]                             if (!grepl(pattern, name)) 
[10:25:21.487]                               next
[10:25:21.487]                             invokeRestart(restart)
[10:25:21.487]                             muffled <- TRUE
[10:25:21.487]                             break
[10:25:21.487]                           }
[10:25:21.487]                         }
[10:25:21.487]                       }
[10:25:21.487]                       invisible(muffled)
[10:25:21.487]                     }
[10:25:21.487]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.487]                   }
[10:25:21.487]                 }
[10:25:21.487]             }
[10:25:21.487]         }))
[10:25:21.487]     }, error = function(ex) {
[10:25:21.487]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.487]                 ...future.rng), started = ...future.startTime, 
[10:25:21.487]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.487]             version = "1.8"), class = "FutureResult")
[10:25:21.487]     }, finally = {
[10:25:21.487]         if (!identical(...future.workdir, getwd())) 
[10:25:21.487]             setwd(...future.workdir)
[10:25:21.487]         {
[10:25:21.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.487]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.487]             }
[10:25:21.487]             base::options(...future.oldOptions)
[10:25:21.487]             if (.Platform$OS.type == "windows") {
[10:25:21.487]                 old_names <- names(...future.oldEnvVars)
[10:25:21.487]                 envs <- base::Sys.getenv()
[10:25:21.487]                 names <- names(envs)
[10:25:21.487]                 common <- intersect(names, old_names)
[10:25:21.487]                 added <- setdiff(names, old_names)
[10:25:21.487]                 removed <- setdiff(old_names, names)
[10:25:21.487]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.487]                   envs[common]]
[10:25:21.487]                 NAMES <- toupper(changed)
[10:25:21.487]                 args <- list()
[10:25:21.487]                 for (kk in seq_along(NAMES)) {
[10:25:21.487]                   name <- changed[[kk]]
[10:25:21.487]                   NAME <- NAMES[[kk]]
[10:25:21.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.487]                     next
[10:25:21.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.487]                 }
[10:25:21.487]                 NAMES <- toupper(added)
[10:25:21.487]                 for (kk in seq_along(NAMES)) {
[10:25:21.487]                   name <- added[[kk]]
[10:25:21.487]                   NAME <- NAMES[[kk]]
[10:25:21.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.487]                     next
[10:25:21.487]                   args[[name]] <- ""
[10:25:21.487]                 }
[10:25:21.487]                 NAMES <- toupper(removed)
[10:25:21.487]                 for (kk in seq_along(NAMES)) {
[10:25:21.487]                   name <- removed[[kk]]
[10:25:21.487]                   NAME <- NAMES[[kk]]
[10:25:21.487]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.487]                     next
[10:25:21.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.487]                 }
[10:25:21.487]                 if (length(args) > 0) 
[10:25:21.487]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.487]             }
[10:25:21.487]             else {
[10:25:21.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.487]             }
[10:25:21.487]             {
[10:25:21.487]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.487]                   0L) {
[10:25:21.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.487]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.487]                   base::options(opts)
[10:25:21.487]                 }
[10:25:21.487]                 {
[10:25:21.487]                   {
[10:25:21.487]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.487]                     NULL
[10:25:21.487]                   }
[10:25:21.487]                   options(future.plan = NULL)
[10:25:21.487]                   if (is.na(NA_character_)) 
[10:25:21.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.487]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.487]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.487]                     envir = parent.frame()) 
[10:25:21.487]                   {
[10:25:21.487]                     if (is.function(workers)) 
[10:25:21.487]                       workers <- workers()
[10:25:21.487]                     workers <- structure(as.integer(workers), 
[10:25:21.487]                       class = class(workers))
[10:25:21.487]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.487]                       workers >= 1)
[10:25:21.487]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.487]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.487]                     }
[10:25:21.487]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.487]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.487]                       envir = envir)
[10:25:21.487]                     if (!future$lazy) 
[10:25:21.487]                       future <- run(future)
[10:25:21.487]                     invisible(future)
[10:25:21.487]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.487]                 }
[10:25:21.487]             }
[10:25:21.487]         }
[10:25:21.487]     })
[10:25:21.487]     if (TRUE) {
[10:25:21.487]         base::sink(type = "output", split = FALSE)
[10:25:21.487]         if (TRUE) {
[10:25:21.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.487]         }
[10:25:21.487]         else {
[10:25:21.487]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.487]         }
[10:25:21.487]         base::close(...future.stdout)
[10:25:21.487]         ...future.stdout <- NULL
[10:25:21.487]     }
[10:25:21.487]     ...future.result$conditions <- ...future.conditions
[10:25:21.487]     ...future.result$finished <- base::Sys.time()
[10:25:21.487]     ...future.result
[10:25:21.487] }
[10:25:21.490] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:25:21.490] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:25:21.490] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.491] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:25:21.491] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.491] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:25:21.492] MultisessionFuture started
[10:25:21.492] - Launch lazy future ... done
[10:25:21.492] run() for ‘MultisessionFuture’ ... done
[10:25:21.492] result() for ClusterFuture ...
[10:25:21.492] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.492] - Validating connection of MultisessionFuture
[10:25:21.538] - received message: FutureResult
[10:25:21.538] - Received FutureResult
[10:25:21.539] - Erased future from FutureRegistry
[10:25:21.539] result() for ClusterFuture ...
[10:25:21.539] - result already collected: FutureResult
[10:25:21.539] result() for ClusterFuture ... done
[10:25:21.539] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.539] result() for ClusterFuture ... done
[10:25:21.539] result() for ClusterFuture ...
[10:25:21.539] - result already collected: FutureResult
[10:25:21.540] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x558a921f5f00>
Arguments '...' exists: FALSE
[10:25:21.540] getGlobalsAndPackages() ...
[10:25:21.540] Searching for globals...
[10:25:21.542] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[10:25:21.542] Searching for globals ... DONE
[10:25:21.542] Resolving globals: FALSE
[10:25:21.543] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:21.543] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:21.543] - globals: [2] ‘x’, ‘y’
[10:25:21.543] 
[10:25:21.543] getGlobalsAndPackages() ... DONE
[10:25:21.544] run() for ‘Future’ ...
[10:25:21.544] - state: ‘created’
[10:25:21.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.558] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.559]   - Field: ‘node’
[10:25:21.559]   - Field: ‘label’
[10:25:21.559]   - Field: ‘local’
[10:25:21.559]   - Field: ‘owner’
[10:25:21.559]   - Field: ‘envir’
[10:25:21.559]   - Field: ‘workers’
[10:25:21.559]   - Field: ‘packages’
[10:25:21.559]   - Field: ‘gc’
[10:25:21.559]   - Field: ‘conditions’
[10:25:21.560]   - Field: ‘persistent’
[10:25:21.560]   - Field: ‘expr’
[10:25:21.560]   - Field: ‘uuid’
[10:25:21.560]   - Field: ‘seed’
[10:25:21.560]   - Field: ‘version’
[10:25:21.560]   - Field: ‘result’
[10:25:21.560]   - Field: ‘asynchronous’
[10:25:21.560]   - Field: ‘calls’
[10:25:21.561]   - Field: ‘globals’
[10:25:21.561]   - Field: ‘stdout’
[10:25:21.561]   - Field: ‘earlySignal’
[10:25:21.561]   - Field: ‘lazy’
[10:25:21.561]   - Field: ‘state’
[10:25:21.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.561] - Launch lazy future ...
[10:25:21.562] Packages needed by the future expression (n = 0): <none>
[10:25:21.562] Packages needed by future strategies (n = 0): <none>
[10:25:21.562] {
[10:25:21.562]     {
[10:25:21.562]         {
[10:25:21.562]             ...future.startTime <- base::Sys.time()
[10:25:21.562]             {
[10:25:21.562]                 {
[10:25:21.562]                   {
[10:25:21.562]                     {
[10:25:21.562]                       base::local({
[10:25:21.562]                         has_future <- base::requireNamespace("future", 
[10:25:21.562]                           quietly = TRUE)
[10:25:21.562]                         if (has_future) {
[10:25:21.562]                           ns <- base::getNamespace("future")
[10:25:21.562]                           version <- ns[[".package"]][["version"]]
[10:25:21.562]                           if (is.null(version)) 
[10:25:21.562]                             version <- utils::packageVersion("future")
[10:25:21.562]                         }
[10:25:21.562]                         else {
[10:25:21.562]                           version <- NULL
[10:25:21.562]                         }
[10:25:21.562]                         if (!has_future || version < "1.8.0") {
[10:25:21.562]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.562]                             "", base::R.version$version.string), 
[10:25:21.562]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.562]                               "release", "version")], collapse = " "), 
[10:25:21.562]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.562]                             info)
[10:25:21.562]                           info <- base::paste(info, collapse = "; ")
[10:25:21.562]                           if (!has_future) {
[10:25:21.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.562]                               info)
[10:25:21.562]                           }
[10:25:21.562]                           else {
[10:25:21.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.562]                               info, version)
[10:25:21.562]                           }
[10:25:21.562]                           base::stop(msg)
[10:25:21.562]                         }
[10:25:21.562]                       })
[10:25:21.562]                     }
[10:25:21.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.562]                     base::options(mc.cores = 1L)
[10:25:21.562]                   }
[10:25:21.562]                   options(future.plan = NULL)
[10:25:21.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.562]                 }
[10:25:21.562]                 ...future.workdir <- getwd()
[10:25:21.562]             }
[10:25:21.562]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.562]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.562]         }
[10:25:21.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.562]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.562]             base::names(...future.oldOptions))
[10:25:21.562]     }
[10:25:21.562]     if (FALSE) {
[10:25:21.562]     }
[10:25:21.562]     else {
[10:25:21.562]         if (TRUE) {
[10:25:21.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.562]                 open = "w")
[10:25:21.562]         }
[10:25:21.562]         else {
[10:25:21.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.562]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.562]         }
[10:25:21.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.562]             base::sink(type = "output", split = FALSE)
[10:25:21.562]             base::close(...future.stdout)
[10:25:21.562]         }, add = TRUE)
[10:25:21.562]     }
[10:25:21.562]     ...future.frame <- base::sys.nframe()
[10:25:21.562]     ...future.conditions <- base::list()
[10:25:21.562]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.562]     if (FALSE) {
[10:25:21.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.562]     }
[10:25:21.562]     ...future.result <- base::tryCatch({
[10:25:21.562]         base::withCallingHandlers({
[10:25:21.562]             ...future.value <- base::withVisible(base::local({
[10:25:21.562]                 ...future.makeSendCondition <- base::local({
[10:25:21.562]                   sendCondition <- NULL
[10:25:21.562]                   function(frame = 1L) {
[10:25:21.562]                     if (is.function(sendCondition)) 
[10:25:21.562]                       return(sendCondition)
[10:25:21.562]                     ns <- getNamespace("parallel")
[10:25:21.562]                     if (exists("sendData", mode = "function", 
[10:25:21.562]                       envir = ns)) {
[10:25:21.562]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.562]                         envir = ns)
[10:25:21.562]                       envir <- sys.frame(frame)
[10:25:21.562]                       master <- NULL
[10:25:21.562]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.562]                         !identical(envir, emptyenv())) {
[10:25:21.562]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.562]                           inherits = FALSE)) {
[10:25:21.562]                           master <- get("master", mode = "list", 
[10:25:21.562]                             envir = envir, inherits = FALSE)
[10:25:21.562]                           if (inherits(master, c("SOCKnode", 
[10:25:21.562]                             "SOCK0node"))) {
[10:25:21.562]                             sendCondition <<- function(cond) {
[10:25:21.562]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.562]                                 success = TRUE)
[10:25:21.562]                               parallel_sendData(master, data)
[10:25:21.562]                             }
[10:25:21.562]                             return(sendCondition)
[10:25:21.562]                           }
[10:25:21.562]                         }
[10:25:21.562]                         frame <- frame + 1L
[10:25:21.562]                         envir <- sys.frame(frame)
[10:25:21.562]                       }
[10:25:21.562]                     }
[10:25:21.562]                     sendCondition <<- function(cond) NULL
[10:25:21.562]                   }
[10:25:21.562]                 })
[10:25:21.562]                 withCallingHandlers({
[10:25:21.562]                   {
[10:25:21.562]                     sum(x, y)
[10:25:21.562]                   }
[10:25:21.562]                 }, immediateCondition = function(cond) {
[10:25:21.562]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.562]                   sendCondition(cond)
[10:25:21.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.562]                   {
[10:25:21.562]                     inherits <- base::inherits
[10:25:21.562]                     invokeRestart <- base::invokeRestart
[10:25:21.562]                     is.null <- base::is.null
[10:25:21.562]                     muffled <- FALSE
[10:25:21.562]                     if (inherits(cond, "message")) {
[10:25:21.562]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.562]                       if (muffled) 
[10:25:21.562]                         invokeRestart("muffleMessage")
[10:25:21.562]                     }
[10:25:21.562]                     else if (inherits(cond, "warning")) {
[10:25:21.562]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.562]                       if (muffled) 
[10:25:21.562]                         invokeRestart("muffleWarning")
[10:25:21.562]                     }
[10:25:21.562]                     else if (inherits(cond, "condition")) {
[10:25:21.562]                       if (!is.null(pattern)) {
[10:25:21.562]                         computeRestarts <- base::computeRestarts
[10:25:21.562]                         grepl <- base::grepl
[10:25:21.562]                         restarts <- computeRestarts(cond)
[10:25:21.562]                         for (restart in restarts) {
[10:25:21.562]                           name <- restart$name
[10:25:21.562]                           if (is.null(name)) 
[10:25:21.562]                             next
[10:25:21.562]                           if (!grepl(pattern, name)) 
[10:25:21.562]                             next
[10:25:21.562]                           invokeRestart(restart)
[10:25:21.562]                           muffled <- TRUE
[10:25:21.562]                           break
[10:25:21.562]                         }
[10:25:21.562]                       }
[10:25:21.562]                     }
[10:25:21.562]                     invisible(muffled)
[10:25:21.562]                   }
[10:25:21.562]                   muffleCondition(cond)
[10:25:21.562]                 })
[10:25:21.562]             }))
[10:25:21.562]             future::FutureResult(value = ...future.value$value, 
[10:25:21.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.562]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.562]                     ...future.globalenv.names))
[10:25:21.562]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.562]         }, condition = base::local({
[10:25:21.562]             c <- base::c
[10:25:21.562]             inherits <- base::inherits
[10:25:21.562]             invokeRestart <- base::invokeRestart
[10:25:21.562]             length <- base::length
[10:25:21.562]             list <- base::list
[10:25:21.562]             seq.int <- base::seq.int
[10:25:21.562]             signalCondition <- base::signalCondition
[10:25:21.562]             sys.calls <- base::sys.calls
[10:25:21.562]             `[[` <- base::`[[`
[10:25:21.562]             `+` <- base::`+`
[10:25:21.562]             `<<-` <- base::`<<-`
[10:25:21.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.562]                   3L)]
[10:25:21.562]             }
[10:25:21.562]             function(cond) {
[10:25:21.562]                 is_error <- inherits(cond, "error")
[10:25:21.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.562]                   NULL)
[10:25:21.562]                 if (is_error) {
[10:25:21.562]                   sessionInformation <- function() {
[10:25:21.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.562]                       search = base::search(), system = base::Sys.info())
[10:25:21.562]                   }
[10:25:21.562]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.562]                     cond$call), session = sessionInformation(), 
[10:25:21.562]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.562]                   signalCondition(cond)
[10:25:21.562]                 }
[10:25:21.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.562]                 "immediateCondition"))) {
[10:25:21.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.562]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.562]                   if (TRUE && !signal) {
[10:25:21.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.562]                     {
[10:25:21.562]                       inherits <- base::inherits
[10:25:21.562]                       invokeRestart <- base::invokeRestart
[10:25:21.562]                       is.null <- base::is.null
[10:25:21.562]                       muffled <- FALSE
[10:25:21.562]                       if (inherits(cond, "message")) {
[10:25:21.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.562]                         if (muffled) 
[10:25:21.562]                           invokeRestart("muffleMessage")
[10:25:21.562]                       }
[10:25:21.562]                       else if (inherits(cond, "warning")) {
[10:25:21.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.562]                         if (muffled) 
[10:25:21.562]                           invokeRestart("muffleWarning")
[10:25:21.562]                       }
[10:25:21.562]                       else if (inherits(cond, "condition")) {
[10:25:21.562]                         if (!is.null(pattern)) {
[10:25:21.562]                           computeRestarts <- base::computeRestarts
[10:25:21.562]                           grepl <- base::grepl
[10:25:21.562]                           restarts <- computeRestarts(cond)
[10:25:21.562]                           for (restart in restarts) {
[10:25:21.562]                             name <- restart$name
[10:25:21.562]                             if (is.null(name)) 
[10:25:21.562]                               next
[10:25:21.562]                             if (!grepl(pattern, name)) 
[10:25:21.562]                               next
[10:25:21.562]                             invokeRestart(restart)
[10:25:21.562]                             muffled <- TRUE
[10:25:21.562]                             break
[10:25:21.562]                           }
[10:25:21.562]                         }
[10:25:21.562]                       }
[10:25:21.562]                       invisible(muffled)
[10:25:21.562]                     }
[10:25:21.562]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.562]                   }
[10:25:21.562]                 }
[10:25:21.562]                 else {
[10:25:21.562]                   if (TRUE) {
[10:25:21.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.562]                     {
[10:25:21.562]                       inherits <- base::inherits
[10:25:21.562]                       invokeRestart <- base::invokeRestart
[10:25:21.562]                       is.null <- base::is.null
[10:25:21.562]                       muffled <- FALSE
[10:25:21.562]                       if (inherits(cond, "message")) {
[10:25:21.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.562]                         if (muffled) 
[10:25:21.562]                           invokeRestart("muffleMessage")
[10:25:21.562]                       }
[10:25:21.562]                       else if (inherits(cond, "warning")) {
[10:25:21.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.562]                         if (muffled) 
[10:25:21.562]                           invokeRestart("muffleWarning")
[10:25:21.562]                       }
[10:25:21.562]                       else if (inherits(cond, "condition")) {
[10:25:21.562]                         if (!is.null(pattern)) {
[10:25:21.562]                           computeRestarts <- base::computeRestarts
[10:25:21.562]                           grepl <- base::grepl
[10:25:21.562]                           restarts <- computeRestarts(cond)
[10:25:21.562]                           for (restart in restarts) {
[10:25:21.562]                             name <- restart$name
[10:25:21.562]                             if (is.null(name)) 
[10:25:21.562]                               next
[10:25:21.562]                             if (!grepl(pattern, name)) 
[10:25:21.562]                               next
[10:25:21.562]                             invokeRestart(restart)
[10:25:21.562]                             muffled <- TRUE
[10:25:21.562]                             break
[10:25:21.562]                           }
[10:25:21.562]                         }
[10:25:21.562]                       }
[10:25:21.562]                       invisible(muffled)
[10:25:21.562]                     }
[10:25:21.562]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.562]                   }
[10:25:21.562]                 }
[10:25:21.562]             }
[10:25:21.562]         }))
[10:25:21.562]     }, error = function(ex) {
[10:25:21.562]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.562]                 ...future.rng), started = ...future.startTime, 
[10:25:21.562]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.562]             version = "1.8"), class = "FutureResult")
[10:25:21.562]     }, finally = {
[10:25:21.562]         if (!identical(...future.workdir, getwd())) 
[10:25:21.562]             setwd(...future.workdir)
[10:25:21.562]         {
[10:25:21.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.562]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.562]             }
[10:25:21.562]             base::options(...future.oldOptions)
[10:25:21.562]             if (.Platform$OS.type == "windows") {
[10:25:21.562]                 old_names <- names(...future.oldEnvVars)
[10:25:21.562]                 envs <- base::Sys.getenv()
[10:25:21.562]                 names <- names(envs)
[10:25:21.562]                 common <- intersect(names, old_names)
[10:25:21.562]                 added <- setdiff(names, old_names)
[10:25:21.562]                 removed <- setdiff(old_names, names)
[10:25:21.562]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.562]                   envs[common]]
[10:25:21.562]                 NAMES <- toupper(changed)
[10:25:21.562]                 args <- list()
[10:25:21.562]                 for (kk in seq_along(NAMES)) {
[10:25:21.562]                   name <- changed[[kk]]
[10:25:21.562]                   NAME <- NAMES[[kk]]
[10:25:21.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.562]                     next
[10:25:21.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.562]                 }
[10:25:21.562]                 NAMES <- toupper(added)
[10:25:21.562]                 for (kk in seq_along(NAMES)) {
[10:25:21.562]                   name <- added[[kk]]
[10:25:21.562]                   NAME <- NAMES[[kk]]
[10:25:21.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.562]                     next
[10:25:21.562]                   args[[name]] <- ""
[10:25:21.562]                 }
[10:25:21.562]                 NAMES <- toupper(removed)
[10:25:21.562]                 for (kk in seq_along(NAMES)) {
[10:25:21.562]                   name <- removed[[kk]]
[10:25:21.562]                   NAME <- NAMES[[kk]]
[10:25:21.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.562]                     next
[10:25:21.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.562]                 }
[10:25:21.562]                 if (length(args) > 0) 
[10:25:21.562]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.562]             }
[10:25:21.562]             else {
[10:25:21.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.562]             }
[10:25:21.562]             {
[10:25:21.562]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.562]                   0L) {
[10:25:21.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.562]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.562]                   base::options(opts)
[10:25:21.562]                 }
[10:25:21.562]                 {
[10:25:21.562]                   {
[10:25:21.562]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.562]                     NULL
[10:25:21.562]                   }
[10:25:21.562]                   options(future.plan = NULL)
[10:25:21.562]                   if (is.na(NA_character_)) 
[10:25:21.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.562]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.562]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.562]                     envir = parent.frame()) 
[10:25:21.562]                   {
[10:25:21.562]                     if (is.function(workers)) 
[10:25:21.562]                       workers <- workers()
[10:25:21.562]                     workers <- structure(as.integer(workers), 
[10:25:21.562]                       class = class(workers))
[10:25:21.562]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.562]                       workers >= 1)
[10:25:21.562]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.562]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.562]                     }
[10:25:21.562]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.562]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.562]                       envir = envir)
[10:25:21.562]                     if (!future$lazy) 
[10:25:21.562]                       future <- run(future)
[10:25:21.562]                     invisible(future)
[10:25:21.562]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.562]                 }
[10:25:21.562]             }
[10:25:21.562]         }
[10:25:21.562]     })
[10:25:21.562]     if (TRUE) {
[10:25:21.562]         base::sink(type = "output", split = FALSE)
[10:25:21.562]         if (TRUE) {
[10:25:21.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.562]         }
[10:25:21.562]         else {
[10:25:21.562]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.562]         }
[10:25:21.562]         base::close(...future.stdout)
[10:25:21.562]         ...future.stdout <- NULL
[10:25:21.562]     }
[10:25:21.562]     ...future.result$conditions <- ...future.conditions
[10:25:21.562]     ...future.result$finished <- base::Sys.time()
[10:25:21.562]     ...future.result
[10:25:21.562] }
[10:25:21.565] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:25:21.568] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:25:21.568] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.568] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[10:25:21.568] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.569] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:25:21.569] MultisessionFuture started
[10:25:21.569] - Launch lazy future ... done
[10:25:21.569] run() for ‘MultisessionFuture’ ... done
[10:25:21.569] result() for ClusterFuture ...
[10:25:21.569] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.570] - Validating connection of MultisessionFuture
[10:25:21.614] - received message: FutureResult
[10:25:21.614] - Received FutureResult
[10:25:21.614] - Erased future from FutureRegistry
[10:25:21.614] result() for ClusterFuture ...
[10:25:21.614] - result already collected: FutureResult
[10:25:21.614] result() for ClusterFuture ... done
[10:25:21.615] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.615] result() for ClusterFuture ... done
[10:25:21.615] result() for ClusterFuture ...
[10:25:21.615] - result already collected: FutureResult
[10:25:21.615] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x558a923df5d8>
Arguments '...' exists: FALSE
[10:25:21.615] getGlobalsAndPackages() ...
[10:25:21.616] Searching for globals...
[10:25:21.617] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[10:25:21.617] Searching for globals ... DONE
[10:25:21.617] Resolving globals: FALSE
[10:25:21.617] Tweak future expression to call with '...' arguments ...
[10:25:21.618] The total size of the 2 globals is 112 bytes (112 bytes)
[10:25:21.618] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:21.618] - globals: [2] ‘x’, ‘y’
[10:25:21.618] 
[10:25:21.618] getGlobalsAndPackages() ... DONE
[10:25:21.619] run() for ‘Future’ ...
[10:25:21.619] - state: ‘created’
[10:25:21.619] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.632]   - Field: ‘node’
[10:25:21.632]   - Field: ‘label’
[10:25:21.633]   - Field: ‘local’
[10:25:21.633]   - Field: ‘owner’
[10:25:21.633]   - Field: ‘envir’
[10:25:21.633]   - Field: ‘workers’
[10:25:21.633]   - Field: ‘packages’
[10:25:21.633]   - Field: ‘gc’
[10:25:21.633]   - Field: ‘conditions’
[10:25:21.633]   - Field: ‘persistent’
[10:25:21.633]   - Field: ‘expr’
[10:25:21.633]   - Field: ‘uuid’
[10:25:21.634]   - Field: ‘seed’
[10:25:21.634]   - Field: ‘version’
[10:25:21.634]   - Field: ‘result’
[10:25:21.634]   - Field: ‘asynchronous’
[10:25:21.634]   - Field: ‘calls’
[10:25:21.634]   - Field: ‘globals’
[10:25:21.634]   - Field: ‘stdout’
[10:25:21.634]   - Field: ‘earlySignal’
[10:25:21.634]   - Field: ‘lazy’
[10:25:21.634]   - Field: ‘state’
[10:25:21.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.635] - Launch lazy future ...
[10:25:21.635] Packages needed by the future expression (n = 0): <none>
[10:25:21.635] Packages needed by future strategies (n = 0): <none>
[10:25:21.635] {
[10:25:21.635]     {
[10:25:21.635]         {
[10:25:21.635]             ...future.startTime <- base::Sys.time()
[10:25:21.635]             {
[10:25:21.635]                 {
[10:25:21.635]                   {
[10:25:21.635]                     {
[10:25:21.635]                       base::local({
[10:25:21.635]                         has_future <- base::requireNamespace("future", 
[10:25:21.635]                           quietly = TRUE)
[10:25:21.635]                         if (has_future) {
[10:25:21.635]                           ns <- base::getNamespace("future")
[10:25:21.635]                           version <- ns[[".package"]][["version"]]
[10:25:21.635]                           if (is.null(version)) 
[10:25:21.635]                             version <- utils::packageVersion("future")
[10:25:21.635]                         }
[10:25:21.635]                         else {
[10:25:21.635]                           version <- NULL
[10:25:21.635]                         }
[10:25:21.635]                         if (!has_future || version < "1.8.0") {
[10:25:21.635]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.635]                             "", base::R.version$version.string), 
[10:25:21.635]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.635]                               "release", "version")], collapse = " "), 
[10:25:21.635]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.635]                             info)
[10:25:21.635]                           info <- base::paste(info, collapse = "; ")
[10:25:21.635]                           if (!has_future) {
[10:25:21.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.635]                               info)
[10:25:21.635]                           }
[10:25:21.635]                           else {
[10:25:21.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.635]                               info, version)
[10:25:21.635]                           }
[10:25:21.635]                           base::stop(msg)
[10:25:21.635]                         }
[10:25:21.635]                       })
[10:25:21.635]                     }
[10:25:21.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.635]                     base::options(mc.cores = 1L)
[10:25:21.635]                   }
[10:25:21.635]                   options(future.plan = NULL)
[10:25:21.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.635]                 }
[10:25:21.635]                 ...future.workdir <- getwd()
[10:25:21.635]             }
[10:25:21.635]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.635]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.635]         }
[10:25:21.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.635]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.635]             base::names(...future.oldOptions))
[10:25:21.635]     }
[10:25:21.635]     if (FALSE) {
[10:25:21.635]     }
[10:25:21.635]     else {
[10:25:21.635]         if (TRUE) {
[10:25:21.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.635]                 open = "w")
[10:25:21.635]         }
[10:25:21.635]         else {
[10:25:21.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.635]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.635]         }
[10:25:21.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.635]             base::sink(type = "output", split = FALSE)
[10:25:21.635]             base::close(...future.stdout)
[10:25:21.635]         }, add = TRUE)
[10:25:21.635]     }
[10:25:21.635]     ...future.frame <- base::sys.nframe()
[10:25:21.635]     ...future.conditions <- base::list()
[10:25:21.635]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.635]     if (FALSE) {
[10:25:21.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.635]     }
[10:25:21.635]     ...future.result <- base::tryCatch({
[10:25:21.635]         base::withCallingHandlers({
[10:25:21.635]             ...future.value <- base::withVisible(base::local({
[10:25:21.635]                 ...future.makeSendCondition <- base::local({
[10:25:21.635]                   sendCondition <- NULL
[10:25:21.635]                   function(frame = 1L) {
[10:25:21.635]                     if (is.function(sendCondition)) 
[10:25:21.635]                       return(sendCondition)
[10:25:21.635]                     ns <- getNamespace("parallel")
[10:25:21.635]                     if (exists("sendData", mode = "function", 
[10:25:21.635]                       envir = ns)) {
[10:25:21.635]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.635]                         envir = ns)
[10:25:21.635]                       envir <- sys.frame(frame)
[10:25:21.635]                       master <- NULL
[10:25:21.635]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.635]                         !identical(envir, emptyenv())) {
[10:25:21.635]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.635]                           inherits = FALSE)) {
[10:25:21.635]                           master <- get("master", mode = "list", 
[10:25:21.635]                             envir = envir, inherits = FALSE)
[10:25:21.635]                           if (inherits(master, c("SOCKnode", 
[10:25:21.635]                             "SOCK0node"))) {
[10:25:21.635]                             sendCondition <<- function(cond) {
[10:25:21.635]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.635]                                 success = TRUE)
[10:25:21.635]                               parallel_sendData(master, data)
[10:25:21.635]                             }
[10:25:21.635]                             return(sendCondition)
[10:25:21.635]                           }
[10:25:21.635]                         }
[10:25:21.635]                         frame <- frame + 1L
[10:25:21.635]                         envir <- sys.frame(frame)
[10:25:21.635]                       }
[10:25:21.635]                     }
[10:25:21.635]                     sendCondition <<- function(cond) NULL
[10:25:21.635]                   }
[10:25:21.635]                 })
[10:25:21.635]                 withCallingHandlers({
[10:25:21.635]                   {
[10:25:21.635]                     sum(x, y, ...)
[10:25:21.635]                   }
[10:25:21.635]                 }, immediateCondition = function(cond) {
[10:25:21.635]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.635]                   sendCondition(cond)
[10:25:21.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.635]                   {
[10:25:21.635]                     inherits <- base::inherits
[10:25:21.635]                     invokeRestart <- base::invokeRestart
[10:25:21.635]                     is.null <- base::is.null
[10:25:21.635]                     muffled <- FALSE
[10:25:21.635]                     if (inherits(cond, "message")) {
[10:25:21.635]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.635]                       if (muffled) 
[10:25:21.635]                         invokeRestart("muffleMessage")
[10:25:21.635]                     }
[10:25:21.635]                     else if (inherits(cond, "warning")) {
[10:25:21.635]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.635]                       if (muffled) 
[10:25:21.635]                         invokeRestart("muffleWarning")
[10:25:21.635]                     }
[10:25:21.635]                     else if (inherits(cond, "condition")) {
[10:25:21.635]                       if (!is.null(pattern)) {
[10:25:21.635]                         computeRestarts <- base::computeRestarts
[10:25:21.635]                         grepl <- base::grepl
[10:25:21.635]                         restarts <- computeRestarts(cond)
[10:25:21.635]                         for (restart in restarts) {
[10:25:21.635]                           name <- restart$name
[10:25:21.635]                           if (is.null(name)) 
[10:25:21.635]                             next
[10:25:21.635]                           if (!grepl(pattern, name)) 
[10:25:21.635]                             next
[10:25:21.635]                           invokeRestart(restart)
[10:25:21.635]                           muffled <- TRUE
[10:25:21.635]                           break
[10:25:21.635]                         }
[10:25:21.635]                       }
[10:25:21.635]                     }
[10:25:21.635]                     invisible(muffled)
[10:25:21.635]                   }
[10:25:21.635]                   muffleCondition(cond)
[10:25:21.635]                 })
[10:25:21.635]             }))
[10:25:21.635]             future::FutureResult(value = ...future.value$value, 
[10:25:21.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.635]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.635]                     ...future.globalenv.names))
[10:25:21.635]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.635]         }, condition = base::local({
[10:25:21.635]             c <- base::c
[10:25:21.635]             inherits <- base::inherits
[10:25:21.635]             invokeRestart <- base::invokeRestart
[10:25:21.635]             length <- base::length
[10:25:21.635]             list <- base::list
[10:25:21.635]             seq.int <- base::seq.int
[10:25:21.635]             signalCondition <- base::signalCondition
[10:25:21.635]             sys.calls <- base::sys.calls
[10:25:21.635]             `[[` <- base::`[[`
[10:25:21.635]             `+` <- base::`+`
[10:25:21.635]             `<<-` <- base::`<<-`
[10:25:21.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.635]                   3L)]
[10:25:21.635]             }
[10:25:21.635]             function(cond) {
[10:25:21.635]                 is_error <- inherits(cond, "error")
[10:25:21.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.635]                   NULL)
[10:25:21.635]                 if (is_error) {
[10:25:21.635]                   sessionInformation <- function() {
[10:25:21.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.635]                       search = base::search(), system = base::Sys.info())
[10:25:21.635]                   }
[10:25:21.635]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.635]                     cond$call), session = sessionInformation(), 
[10:25:21.635]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.635]                   signalCondition(cond)
[10:25:21.635]                 }
[10:25:21.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.635]                 "immediateCondition"))) {
[10:25:21.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.635]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.635]                   if (TRUE && !signal) {
[10:25:21.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.635]                     {
[10:25:21.635]                       inherits <- base::inherits
[10:25:21.635]                       invokeRestart <- base::invokeRestart
[10:25:21.635]                       is.null <- base::is.null
[10:25:21.635]                       muffled <- FALSE
[10:25:21.635]                       if (inherits(cond, "message")) {
[10:25:21.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.635]                         if (muffled) 
[10:25:21.635]                           invokeRestart("muffleMessage")
[10:25:21.635]                       }
[10:25:21.635]                       else if (inherits(cond, "warning")) {
[10:25:21.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.635]                         if (muffled) 
[10:25:21.635]                           invokeRestart("muffleWarning")
[10:25:21.635]                       }
[10:25:21.635]                       else if (inherits(cond, "condition")) {
[10:25:21.635]                         if (!is.null(pattern)) {
[10:25:21.635]                           computeRestarts <- base::computeRestarts
[10:25:21.635]                           grepl <- base::grepl
[10:25:21.635]                           restarts <- computeRestarts(cond)
[10:25:21.635]                           for (restart in restarts) {
[10:25:21.635]                             name <- restart$name
[10:25:21.635]                             if (is.null(name)) 
[10:25:21.635]                               next
[10:25:21.635]                             if (!grepl(pattern, name)) 
[10:25:21.635]                               next
[10:25:21.635]                             invokeRestart(restart)
[10:25:21.635]                             muffled <- TRUE
[10:25:21.635]                             break
[10:25:21.635]                           }
[10:25:21.635]                         }
[10:25:21.635]                       }
[10:25:21.635]                       invisible(muffled)
[10:25:21.635]                     }
[10:25:21.635]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.635]                   }
[10:25:21.635]                 }
[10:25:21.635]                 else {
[10:25:21.635]                   if (TRUE) {
[10:25:21.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.635]                     {
[10:25:21.635]                       inherits <- base::inherits
[10:25:21.635]                       invokeRestart <- base::invokeRestart
[10:25:21.635]                       is.null <- base::is.null
[10:25:21.635]                       muffled <- FALSE
[10:25:21.635]                       if (inherits(cond, "message")) {
[10:25:21.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.635]                         if (muffled) 
[10:25:21.635]                           invokeRestart("muffleMessage")
[10:25:21.635]                       }
[10:25:21.635]                       else if (inherits(cond, "warning")) {
[10:25:21.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.635]                         if (muffled) 
[10:25:21.635]                           invokeRestart("muffleWarning")
[10:25:21.635]                       }
[10:25:21.635]                       else if (inherits(cond, "condition")) {
[10:25:21.635]                         if (!is.null(pattern)) {
[10:25:21.635]                           computeRestarts <- base::computeRestarts
[10:25:21.635]                           grepl <- base::grepl
[10:25:21.635]                           restarts <- computeRestarts(cond)
[10:25:21.635]                           for (restart in restarts) {
[10:25:21.635]                             name <- restart$name
[10:25:21.635]                             if (is.null(name)) 
[10:25:21.635]                               next
[10:25:21.635]                             if (!grepl(pattern, name)) 
[10:25:21.635]                               next
[10:25:21.635]                             invokeRestart(restart)
[10:25:21.635]                             muffled <- TRUE
[10:25:21.635]                             break
[10:25:21.635]                           }
[10:25:21.635]                         }
[10:25:21.635]                       }
[10:25:21.635]                       invisible(muffled)
[10:25:21.635]                     }
[10:25:21.635]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.635]                   }
[10:25:21.635]                 }
[10:25:21.635]             }
[10:25:21.635]         }))
[10:25:21.635]     }, error = function(ex) {
[10:25:21.635]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.635]                 ...future.rng), started = ...future.startTime, 
[10:25:21.635]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.635]             version = "1.8"), class = "FutureResult")
[10:25:21.635]     }, finally = {
[10:25:21.635]         if (!identical(...future.workdir, getwd())) 
[10:25:21.635]             setwd(...future.workdir)
[10:25:21.635]         {
[10:25:21.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.635]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.635]             }
[10:25:21.635]             base::options(...future.oldOptions)
[10:25:21.635]             if (.Platform$OS.type == "windows") {
[10:25:21.635]                 old_names <- names(...future.oldEnvVars)
[10:25:21.635]                 envs <- base::Sys.getenv()
[10:25:21.635]                 names <- names(envs)
[10:25:21.635]                 common <- intersect(names, old_names)
[10:25:21.635]                 added <- setdiff(names, old_names)
[10:25:21.635]                 removed <- setdiff(old_names, names)
[10:25:21.635]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.635]                   envs[common]]
[10:25:21.635]                 NAMES <- toupper(changed)
[10:25:21.635]                 args <- list()
[10:25:21.635]                 for (kk in seq_along(NAMES)) {
[10:25:21.635]                   name <- changed[[kk]]
[10:25:21.635]                   NAME <- NAMES[[kk]]
[10:25:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.635]                     next
[10:25:21.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.635]                 }
[10:25:21.635]                 NAMES <- toupper(added)
[10:25:21.635]                 for (kk in seq_along(NAMES)) {
[10:25:21.635]                   name <- added[[kk]]
[10:25:21.635]                   NAME <- NAMES[[kk]]
[10:25:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.635]                     next
[10:25:21.635]                   args[[name]] <- ""
[10:25:21.635]                 }
[10:25:21.635]                 NAMES <- toupper(removed)
[10:25:21.635]                 for (kk in seq_along(NAMES)) {
[10:25:21.635]                   name <- removed[[kk]]
[10:25:21.635]                   NAME <- NAMES[[kk]]
[10:25:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.635]                     next
[10:25:21.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.635]                 }
[10:25:21.635]                 if (length(args) > 0) 
[10:25:21.635]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.635]             }
[10:25:21.635]             else {
[10:25:21.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.635]             }
[10:25:21.635]             {
[10:25:21.635]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.635]                   0L) {
[10:25:21.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.635]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.635]                   base::options(opts)
[10:25:21.635]                 }
[10:25:21.635]                 {
[10:25:21.635]                   {
[10:25:21.635]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.635]                     NULL
[10:25:21.635]                   }
[10:25:21.635]                   options(future.plan = NULL)
[10:25:21.635]                   if (is.na(NA_character_)) 
[10:25:21.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.635]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.635]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.635]                     envir = parent.frame()) 
[10:25:21.635]                   {
[10:25:21.635]                     if (is.function(workers)) 
[10:25:21.635]                       workers <- workers()
[10:25:21.635]                     workers <- structure(as.integer(workers), 
[10:25:21.635]                       class = class(workers))
[10:25:21.635]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.635]                       workers >= 1)
[10:25:21.635]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.635]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.635]                     }
[10:25:21.635]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.635]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.635]                       envir = envir)
[10:25:21.635]                     if (!future$lazy) 
[10:25:21.635]                       future <- run(future)
[10:25:21.635]                     invisible(future)
[10:25:21.635]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.635]                 }
[10:25:21.635]             }
[10:25:21.635]         }
[10:25:21.635]     })
[10:25:21.635]     if (TRUE) {
[10:25:21.635]         base::sink(type = "output", split = FALSE)
[10:25:21.635]         if (TRUE) {
[10:25:21.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.635]         }
[10:25:21.635]         else {
[10:25:21.635]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.635]         }
[10:25:21.635]         base::close(...future.stdout)
[10:25:21.635]         ...future.stdout <- NULL
[10:25:21.635]     }
[10:25:21.635]     ...future.result$conditions <- ...future.conditions
[10:25:21.635]     ...future.result$finished <- base::Sys.time()
[10:25:21.635]     ...future.result
[10:25:21.635] }
[10:25:21.638] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[10:25:21.638] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:25:21.638] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.638] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[10:25:21.639] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.639] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[10:25:21.639] MultisessionFuture started
[10:25:21.639] - Launch lazy future ... done
[10:25:21.640] run() for ‘MultisessionFuture’ ... done
[10:25:21.640] result() for ClusterFuture ...
[10:25:21.640] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.640] - Validating connection of MultisessionFuture
[10:25:21.686] - received message: FutureResult
[10:25:21.687] - Received FutureResult
[10:25:21.687] - Erased future from FutureRegistry
[10:25:21.687] result() for ClusterFuture ...
[10:25:21.687] - result already collected: FutureResult
[10:25:21.687] result() for ClusterFuture ... done
[10:25:21.687] signalConditions() ...
[10:25:21.687]  - include = ‘immediateCondition’
[10:25:21.688]  - exclude = 
[10:25:21.688]  - resignal = FALSE
[10:25:21.688]  - Number of conditions: 1
[10:25:21.688] signalConditions() ... done
[10:25:21.688] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.688] result() for ClusterFuture ... done
[10:25:21.688] result() for ClusterFuture ...
[10:25:21.688] - result already collected: FutureResult
[10:25:21.688] result() for ClusterFuture ... done
[10:25:21.688] signalConditions() ...
[10:25:21.688]  - include = ‘immediateCondition’
[10:25:21.689]  - exclude = 
[10:25:21.689]  - resignal = FALSE
[10:25:21.689]  - Number of conditions: 1
[10:25:21.689] signalConditions() ... done
[10:25:21.689] Future state: ‘finished’
[10:25:21.689] result() for ClusterFuture ...
[10:25:21.689] - result already collected: FutureResult
[10:25:21.689] result() for ClusterFuture ... done
[10:25:21.689] signalConditions() ...
[10:25:21.689]  - include = ‘condition’
[10:25:21.689]  - exclude = ‘immediateCondition’
[10:25:21.690]  - resignal = TRUE
[10:25:21.690]  - Number of conditions: 1
[10:25:21.690]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:25:21.690] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x558a915e1568>
Arguments '...' exists: TRUE
[10:25:21.691] getGlobalsAndPackages() ...
[10:25:21.691] - globals passed as-is: [1] ‘...’
[10:25:21.691] Resolving globals: FALSE
[10:25:21.691] Tweak future expression to call with '...' arguments ...
[10:25:21.691] {
[10:25:21.691]     do.call(function(...) {
[10:25:21.691]         fcn <- function() sum(...)
[10:25:21.691]         fcn()
[10:25:21.691]     }, args = future.call.arguments)
[10:25:21.691] }
[10:25:21.691] Tweak future expression to call with '...' arguments ... DONE
[10:25:21.692] The total size of the 1 globals is 112 bytes (112 bytes)
[10:25:21.692] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (112 bytes of class ‘list’)
[10:25:21.692] - globals: [1] ‘future.call.arguments’
[10:25:21.692] 
[10:25:21.692] getGlobalsAndPackages() ... DONE
[10:25:21.693] run() for ‘Future’ ...
[10:25:21.693] - state: ‘created’
[10:25:21.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.707]   - Field: ‘node’
[10:25:21.707]   - Field: ‘label’
[10:25:21.707]   - Field: ‘local’
[10:25:21.707]   - Field: ‘owner’
[10:25:21.707]   - Field: ‘envir’
[10:25:21.707]   - Field: ‘workers’
[10:25:21.707]   - Field: ‘packages’
[10:25:21.707]   - Field: ‘gc’
[10:25:21.708]   - Field: ‘conditions’
[10:25:21.708]   - Field: ‘persistent’
[10:25:21.708]   - Field: ‘expr’
[10:25:21.708]   - Field: ‘uuid’
[10:25:21.708]   - Field: ‘seed’
[10:25:21.708]   - Field: ‘version’
[10:25:21.708]   - Field: ‘result’
[10:25:21.708]   - Field: ‘asynchronous’
[10:25:21.708]   - Field: ‘calls’
[10:25:21.708]   - Field: ‘globals’
[10:25:21.709]   - Field: ‘stdout’
[10:25:21.709]   - Field: ‘earlySignal’
[10:25:21.709]   - Field: ‘lazy’
[10:25:21.709]   - Field: ‘state’
[10:25:21.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.709] - Launch lazy future ...
[10:25:21.709] Packages needed by the future expression (n = 0): <none>
[10:25:21.709] Packages needed by future strategies (n = 0): <none>
[10:25:21.710] {
[10:25:21.710]     {
[10:25:21.710]         {
[10:25:21.710]             ...future.startTime <- base::Sys.time()
[10:25:21.710]             {
[10:25:21.710]                 {
[10:25:21.710]                   {
[10:25:21.710]                     {
[10:25:21.710]                       base::local({
[10:25:21.710]                         has_future <- base::requireNamespace("future", 
[10:25:21.710]                           quietly = TRUE)
[10:25:21.710]                         if (has_future) {
[10:25:21.710]                           ns <- base::getNamespace("future")
[10:25:21.710]                           version <- ns[[".package"]][["version"]]
[10:25:21.710]                           if (is.null(version)) 
[10:25:21.710]                             version <- utils::packageVersion("future")
[10:25:21.710]                         }
[10:25:21.710]                         else {
[10:25:21.710]                           version <- NULL
[10:25:21.710]                         }
[10:25:21.710]                         if (!has_future || version < "1.8.0") {
[10:25:21.710]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.710]                             "", base::R.version$version.string), 
[10:25:21.710]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.710]                               "release", "version")], collapse = " "), 
[10:25:21.710]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.710]                             info)
[10:25:21.710]                           info <- base::paste(info, collapse = "; ")
[10:25:21.710]                           if (!has_future) {
[10:25:21.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.710]                               info)
[10:25:21.710]                           }
[10:25:21.710]                           else {
[10:25:21.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.710]                               info, version)
[10:25:21.710]                           }
[10:25:21.710]                           base::stop(msg)
[10:25:21.710]                         }
[10:25:21.710]                       })
[10:25:21.710]                     }
[10:25:21.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.710]                     base::options(mc.cores = 1L)
[10:25:21.710]                   }
[10:25:21.710]                   options(future.plan = NULL)
[10:25:21.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.710]                 }
[10:25:21.710]                 ...future.workdir <- getwd()
[10:25:21.710]             }
[10:25:21.710]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.710]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.710]         }
[10:25:21.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.710]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.710]             base::names(...future.oldOptions))
[10:25:21.710]     }
[10:25:21.710]     if (FALSE) {
[10:25:21.710]     }
[10:25:21.710]     else {
[10:25:21.710]         if (TRUE) {
[10:25:21.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.710]                 open = "w")
[10:25:21.710]         }
[10:25:21.710]         else {
[10:25:21.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.710]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.710]         }
[10:25:21.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.710]             base::sink(type = "output", split = FALSE)
[10:25:21.710]             base::close(...future.stdout)
[10:25:21.710]         }, add = TRUE)
[10:25:21.710]     }
[10:25:21.710]     ...future.frame <- base::sys.nframe()
[10:25:21.710]     ...future.conditions <- base::list()
[10:25:21.710]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.710]     if (FALSE) {
[10:25:21.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.710]     }
[10:25:21.710]     ...future.result <- base::tryCatch({
[10:25:21.710]         base::withCallingHandlers({
[10:25:21.710]             ...future.value <- base::withVisible(base::local({
[10:25:21.710]                 ...future.makeSendCondition <- base::local({
[10:25:21.710]                   sendCondition <- NULL
[10:25:21.710]                   function(frame = 1L) {
[10:25:21.710]                     if (is.function(sendCondition)) 
[10:25:21.710]                       return(sendCondition)
[10:25:21.710]                     ns <- getNamespace("parallel")
[10:25:21.710]                     if (exists("sendData", mode = "function", 
[10:25:21.710]                       envir = ns)) {
[10:25:21.710]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.710]                         envir = ns)
[10:25:21.710]                       envir <- sys.frame(frame)
[10:25:21.710]                       master <- NULL
[10:25:21.710]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.710]                         !identical(envir, emptyenv())) {
[10:25:21.710]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.710]                           inherits = FALSE)) {
[10:25:21.710]                           master <- get("master", mode = "list", 
[10:25:21.710]                             envir = envir, inherits = FALSE)
[10:25:21.710]                           if (inherits(master, c("SOCKnode", 
[10:25:21.710]                             "SOCK0node"))) {
[10:25:21.710]                             sendCondition <<- function(cond) {
[10:25:21.710]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.710]                                 success = TRUE)
[10:25:21.710]                               parallel_sendData(master, data)
[10:25:21.710]                             }
[10:25:21.710]                             return(sendCondition)
[10:25:21.710]                           }
[10:25:21.710]                         }
[10:25:21.710]                         frame <- frame + 1L
[10:25:21.710]                         envir <- sys.frame(frame)
[10:25:21.710]                       }
[10:25:21.710]                     }
[10:25:21.710]                     sendCondition <<- function(cond) NULL
[10:25:21.710]                   }
[10:25:21.710]                 })
[10:25:21.710]                 withCallingHandlers({
[10:25:21.710]                   {
[10:25:21.710]                     do.call(function(...) {
[10:25:21.710]                       fcn <- function() sum(...)
[10:25:21.710]                       fcn()
[10:25:21.710]                     }, args = future.call.arguments)
[10:25:21.710]                   }
[10:25:21.710]                 }, immediateCondition = function(cond) {
[10:25:21.710]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.710]                   sendCondition(cond)
[10:25:21.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.710]                   {
[10:25:21.710]                     inherits <- base::inherits
[10:25:21.710]                     invokeRestart <- base::invokeRestart
[10:25:21.710]                     is.null <- base::is.null
[10:25:21.710]                     muffled <- FALSE
[10:25:21.710]                     if (inherits(cond, "message")) {
[10:25:21.710]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.710]                       if (muffled) 
[10:25:21.710]                         invokeRestart("muffleMessage")
[10:25:21.710]                     }
[10:25:21.710]                     else if (inherits(cond, "warning")) {
[10:25:21.710]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.710]                       if (muffled) 
[10:25:21.710]                         invokeRestart("muffleWarning")
[10:25:21.710]                     }
[10:25:21.710]                     else if (inherits(cond, "condition")) {
[10:25:21.710]                       if (!is.null(pattern)) {
[10:25:21.710]                         computeRestarts <- base::computeRestarts
[10:25:21.710]                         grepl <- base::grepl
[10:25:21.710]                         restarts <- computeRestarts(cond)
[10:25:21.710]                         for (restart in restarts) {
[10:25:21.710]                           name <- restart$name
[10:25:21.710]                           if (is.null(name)) 
[10:25:21.710]                             next
[10:25:21.710]                           if (!grepl(pattern, name)) 
[10:25:21.710]                             next
[10:25:21.710]                           invokeRestart(restart)
[10:25:21.710]                           muffled <- TRUE
[10:25:21.710]                           break
[10:25:21.710]                         }
[10:25:21.710]                       }
[10:25:21.710]                     }
[10:25:21.710]                     invisible(muffled)
[10:25:21.710]                   }
[10:25:21.710]                   muffleCondition(cond)
[10:25:21.710]                 })
[10:25:21.710]             }))
[10:25:21.710]             future::FutureResult(value = ...future.value$value, 
[10:25:21.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.710]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.710]                     ...future.globalenv.names))
[10:25:21.710]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.710]         }, condition = base::local({
[10:25:21.710]             c <- base::c
[10:25:21.710]             inherits <- base::inherits
[10:25:21.710]             invokeRestart <- base::invokeRestart
[10:25:21.710]             length <- base::length
[10:25:21.710]             list <- base::list
[10:25:21.710]             seq.int <- base::seq.int
[10:25:21.710]             signalCondition <- base::signalCondition
[10:25:21.710]             sys.calls <- base::sys.calls
[10:25:21.710]             `[[` <- base::`[[`
[10:25:21.710]             `+` <- base::`+`
[10:25:21.710]             `<<-` <- base::`<<-`
[10:25:21.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.710]                   3L)]
[10:25:21.710]             }
[10:25:21.710]             function(cond) {
[10:25:21.710]                 is_error <- inherits(cond, "error")
[10:25:21.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.710]                   NULL)
[10:25:21.710]                 if (is_error) {
[10:25:21.710]                   sessionInformation <- function() {
[10:25:21.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.710]                       search = base::search(), system = base::Sys.info())
[10:25:21.710]                   }
[10:25:21.710]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.710]                     cond$call), session = sessionInformation(), 
[10:25:21.710]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.710]                   signalCondition(cond)
[10:25:21.710]                 }
[10:25:21.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.710]                 "immediateCondition"))) {
[10:25:21.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.710]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.710]                   if (TRUE && !signal) {
[10:25:21.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.710]                     {
[10:25:21.710]                       inherits <- base::inherits
[10:25:21.710]                       invokeRestart <- base::invokeRestart
[10:25:21.710]                       is.null <- base::is.null
[10:25:21.710]                       muffled <- FALSE
[10:25:21.710]                       if (inherits(cond, "message")) {
[10:25:21.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.710]                         if (muffled) 
[10:25:21.710]                           invokeRestart("muffleMessage")
[10:25:21.710]                       }
[10:25:21.710]                       else if (inherits(cond, "warning")) {
[10:25:21.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.710]                         if (muffled) 
[10:25:21.710]                           invokeRestart("muffleWarning")
[10:25:21.710]                       }
[10:25:21.710]                       else if (inherits(cond, "condition")) {
[10:25:21.710]                         if (!is.null(pattern)) {
[10:25:21.710]                           computeRestarts <- base::computeRestarts
[10:25:21.710]                           grepl <- base::grepl
[10:25:21.710]                           restarts <- computeRestarts(cond)
[10:25:21.710]                           for (restart in restarts) {
[10:25:21.710]                             name <- restart$name
[10:25:21.710]                             if (is.null(name)) 
[10:25:21.710]                               next
[10:25:21.710]                             if (!grepl(pattern, name)) 
[10:25:21.710]                               next
[10:25:21.710]                             invokeRestart(restart)
[10:25:21.710]                             muffled <- TRUE
[10:25:21.710]                             break
[10:25:21.710]                           }
[10:25:21.710]                         }
[10:25:21.710]                       }
[10:25:21.710]                       invisible(muffled)
[10:25:21.710]                     }
[10:25:21.710]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.710]                   }
[10:25:21.710]                 }
[10:25:21.710]                 else {
[10:25:21.710]                   if (TRUE) {
[10:25:21.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.710]                     {
[10:25:21.710]                       inherits <- base::inherits
[10:25:21.710]                       invokeRestart <- base::invokeRestart
[10:25:21.710]                       is.null <- base::is.null
[10:25:21.710]                       muffled <- FALSE
[10:25:21.710]                       if (inherits(cond, "message")) {
[10:25:21.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.710]                         if (muffled) 
[10:25:21.710]                           invokeRestart("muffleMessage")
[10:25:21.710]                       }
[10:25:21.710]                       else if (inherits(cond, "warning")) {
[10:25:21.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.710]                         if (muffled) 
[10:25:21.710]                           invokeRestart("muffleWarning")
[10:25:21.710]                       }
[10:25:21.710]                       else if (inherits(cond, "condition")) {
[10:25:21.710]                         if (!is.null(pattern)) {
[10:25:21.710]                           computeRestarts <- base::computeRestarts
[10:25:21.710]                           grepl <- base::grepl
[10:25:21.710]                           restarts <- computeRestarts(cond)
[10:25:21.710]                           for (restart in restarts) {
[10:25:21.710]                             name <- restart$name
[10:25:21.710]                             if (is.null(name)) 
[10:25:21.710]                               next
[10:25:21.710]                             if (!grepl(pattern, name)) 
[10:25:21.710]                               next
[10:25:21.710]                             invokeRestart(restart)
[10:25:21.710]                             muffled <- TRUE
[10:25:21.710]                             break
[10:25:21.710]                           }
[10:25:21.710]                         }
[10:25:21.710]                       }
[10:25:21.710]                       invisible(muffled)
[10:25:21.710]                     }
[10:25:21.710]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.710]                   }
[10:25:21.710]                 }
[10:25:21.710]             }
[10:25:21.710]         }))
[10:25:21.710]     }, error = function(ex) {
[10:25:21.710]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.710]                 ...future.rng), started = ...future.startTime, 
[10:25:21.710]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.710]             version = "1.8"), class = "FutureResult")
[10:25:21.710]     }, finally = {
[10:25:21.710]         if (!identical(...future.workdir, getwd())) 
[10:25:21.710]             setwd(...future.workdir)
[10:25:21.710]         {
[10:25:21.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.710]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.710]             }
[10:25:21.710]             base::options(...future.oldOptions)
[10:25:21.710]             if (.Platform$OS.type == "windows") {
[10:25:21.710]                 old_names <- names(...future.oldEnvVars)
[10:25:21.710]                 envs <- base::Sys.getenv()
[10:25:21.710]                 names <- names(envs)
[10:25:21.710]                 common <- intersect(names, old_names)
[10:25:21.710]                 added <- setdiff(names, old_names)
[10:25:21.710]                 removed <- setdiff(old_names, names)
[10:25:21.710]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.710]                   envs[common]]
[10:25:21.710]                 NAMES <- toupper(changed)
[10:25:21.710]                 args <- list()
[10:25:21.710]                 for (kk in seq_along(NAMES)) {
[10:25:21.710]                   name <- changed[[kk]]
[10:25:21.710]                   NAME <- NAMES[[kk]]
[10:25:21.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.710]                     next
[10:25:21.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.710]                 }
[10:25:21.710]                 NAMES <- toupper(added)
[10:25:21.710]                 for (kk in seq_along(NAMES)) {
[10:25:21.710]                   name <- added[[kk]]
[10:25:21.710]                   NAME <- NAMES[[kk]]
[10:25:21.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.710]                     next
[10:25:21.710]                   args[[name]] <- ""
[10:25:21.710]                 }
[10:25:21.710]                 NAMES <- toupper(removed)
[10:25:21.710]                 for (kk in seq_along(NAMES)) {
[10:25:21.710]                   name <- removed[[kk]]
[10:25:21.710]                   NAME <- NAMES[[kk]]
[10:25:21.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.710]                     next
[10:25:21.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.710]                 }
[10:25:21.710]                 if (length(args) > 0) 
[10:25:21.710]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.710]             }
[10:25:21.710]             else {
[10:25:21.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.710]             }
[10:25:21.710]             {
[10:25:21.710]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.710]                   0L) {
[10:25:21.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.710]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.710]                   base::options(opts)
[10:25:21.710]                 }
[10:25:21.710]                 {
[10:25:21.710]                   {
[10:25:21.710]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.710]                     NULL
[10:25:21.710]                   }
[10:25:21.710]                   options(future.plan = NULL)
[10:25:21.710]                   if (is.na(NA_character_)) 
[10:25:21.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.710]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.710]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.710]                     envir = parent.frame()) 
[10:25:21.710]                   {
[10:25:21.710]                     if (is.function(workers)) 
[10:25:21.710]                       workers <- workers()
[10:25:21.710]                     workers <- structure(as.integer(workers), 
[10:25:21.710]                       class = class(workers))
[10:25:21.710]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.710]                       workers >= 1)
[10:25:21.710]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.710]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.710]                     }
[10:25:21.710]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.710]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.710]                       envir = envir)
[10:25:21.710]                     if (!future$lazy) 
[10:25:21.710]                       future <- run(future)
[10:25:21.710]                     invisible(future)
[10:25:21.710]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.710]                 }
[10:25:21.710]             }
[10:25:21.710]         }
[10:25:21.710]     })
[10:25:21.710]     if (TRUE) {
[10:25:21.710]         base::sink(type = "output", split = FALSE)
[10:25:21.710]         if (TRUE) {
[10:25:21.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.710]         }
[10:25:21.710]         else {
[10:25:21.710]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.710]         }
[10:25:21.710]         base::close(...future.stdout)
[10:25:21.710]         ...future.stdout <- NULL
[10:25:21.710]     }
[10:25:21.710]     ...future.result$conditions <- ...future.conditions
[10:25:21.710]     ...future.result$finished <- base::Sys.time()
[10:25:21.710]     ...future.result
[10:25:21.710] }
[10:25:21.712] Exporting 1 global objects (112 bytes) to cluster node #1 ...
[10:25:21.713] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ...
[10:25:21.713] Exporting ‘future.call.arguments’ (112 bytes) to cluster node #1 ... DONE
[10:25:21.713] Exporting 1 global objects (112 bytes) to cluster node #1 ... DONE
[10:25:21.714] MultisessionFuture started
[10:25:21.714] - Launch lazy future ... done
[10:25:21.714] run() for ‘MultisessionFuture’ ... done
[10:25:21.714] result() for ClusterFuture ...
[10:25:21.714] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.714] - Validating connection of MultisessionFuture
[10:25:21.762] - received message: FutureResult
[10:25:21.762] - Received FutureResult
[10:25:21.762] - Erased future from FutureRegistry
[10:25:21.762] result() for ClusterFuture ...
[10:25:21.762] - result already collected: FutureResult
[10:25:21.763] result() for ClusterFuture ... done
[10:25:21.763] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.763] result() for ClusterFuture ... done
[10:25:21.763] result() for ClusterFuture ...
[10:25:21.763] - result already collected: FutureResult
[10:25:21.763] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x558a8feb2800>
Using '...' in a formula
[10:25:21.763] getGlobalsAndPackages() ...
[10:25:21.763] Searching for globals...
[10:25:21.766] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘sum’, ‘...’
[10:25:21.766] Searching for globals ... DONE
[10:25:21.766] Resolving globals: FALSE
[10:25:21.766] Tweak future expression to call with '...' arguments ...
[10:25:21.767] The total size of the 3 globals is 4.18 KiB (4280 bytes)
[10:25:21.767] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 4.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (4.07 KiB of class ‘function’), ‘x’ (56 bytes of class ‘numeric’) and ‘y’ (56 bytes of class ‘numeric’)
[10:25:21.767] - globals: [3] ‘fcn’, ‘x’, ‘y’
[10:25:21.768] 
[10:25:21.768] getGlobalsAndPackages() ... DONE
[10:25:21.768] run() for ‘Future’ ...
[10:25:21.768] - state: ‘created’
[10:25:21.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:25:21.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:25:21.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:25:21.782]   - Field: ‘node’
[10:25:21.782]   - Field: ‘label’
[10:25:21.782]   - Field: ‘local’
[10:25:21.782]   - Field: ‘owner’
[10:25:21.782]   - Field: ‘envir’
[10:25:21.782]   - Field: ‘workers’
[10:25:21.782]   - Field: ‘packages’
[10:25:21.782]   - Field: ‘gc’
[10:25:21.783]   - Field: ‘conditions’
[10:25:21.783]   - Field: ‘persistent’
[10:25:21.783]   - Field: ‘expr’
[10:25:21.783]   - Field: ‘uuid’
[10:25:21.783]   - Field: ‘seed’
[10:25:21.783]   - Field: ‘version’
[10:25:21.783]   - Field: ‘result’
[10:25:21.783]   - Field: ‘asynchronous’
[10:25:21.783]   - Field: ‘calls’
[10:25:21.783]   - Field: ‘globals’
[10:25:21.783]   - Field: ‘stdout’
[10:25:21.784]   - Field: ‘earlySignal’
[10:25:21.784]   - Field: ‘lazy’
[10:25:21.784]   - Field: ‘state’
[10:25:21.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:25:21.784] - Launch lazy future ...
[10:25:21.784] Packages needed by the future expression (n = 0): <none>
[10:25:21.784] Packages needed by future strategies (n = 0): <none>
[10:25:21.785] {
[10:25:21.785]     {
[10:25:21.785]         {
[10:25:21.785]             ...future.startTime <- base::Sys.time()
[10:25:21.785]             {
[10:25:21.785]                 {
[10:25:21.785]                   {
[10:25:21.785]                     {
[10:25:21.785]                       base::local({
[10:25:21.785]                         has_future <- base::requireNamespace("future", 
[10:25:21.785]                           quietly = TRUE)
[10:25:21.785]                         if (has_future) {
[10:25:21.785]                           ns <- base::getNamespace("future")
[10:25:21.785]                           version <- ns[[".package"]][["version"]]
[10:25:21.785]                           if (is.null(version)) 
[10:25:21.785]                             version <- utils::packageVersion("future")
[10:25:21.785]                         }
[10:25:21.785]                         else {
[10:25:21.785]                           version <- NULL
[10:25:21.785]                         }
[10:25:21.785]                         if (!has_future || version < "1.8.0") {
[10:25:21.785]                           info <- base::c(r_version = base::gsub("R version ", 
[10:25:21.785]                             "", base::R.version$version.string), 
[10:25:21.785]                             platform = base::sprintf("%s (%s-bit)", 
[10:25:21.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:25:21.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:25:21.785]                               "release", "version")], collapse = " "), 
[10:25:21.785]                             hostname = base::Sys.info()[["nodename"]])
[10:25:21.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:25:21.785]                             info)
[10:25:21.785]                           info <- base::paste(info, collapse = "; ")
[10:25:21.785]                           if (!has_future) {
[10:25:21.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:25:21.785]                               info)
[10:25:21.785]                           }
[10:25:21.785]                           else {
[10:25:21.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:25:21.785]                               info, version)
[10:25:21.785]                           }
[10:25:21.785]                           base::stop(msg)
[10:25:21.785]                         }
[10:25:21.785]                       })
[10:25:21.785]                     }
[10:25:21.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:25:21.785]                     base::options(mc.cores = 1L)
[10:25:21.785]                   }
[10:25:21.785]                   options(future.plan = NULL)
[10:25:21.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:25:21.785]                 }
[10:25:21.785]                 ...future.workdir <- getwd()
[10:25:21.785]             }
[10:25:21.785]             ...future.oldOptions <- base::as.list(base::.Options)
[10:25:21.785]             ...future.oldEnvVars <- base::Sys.getenv()
[10:25:21.785]         }
[10:25:21.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:25:21.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:25:21.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:25:21.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:25:21.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:25:21.785]             future.stdout.windows.reencode = NULL, width = 80L)
[10:25:21.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:25:21.785]             base::names(...future.oldOptions))
[10:25:21.785]     }
[10:25:21.785]     if (FALSE) {
[10:25:21.785]     }
[10:25:21.785]     else {
[10:25:21.785]         if (TRUE) {
[10:25:21.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:25:21.785]                 open = "w")
[10:25:21.785]         }
[10:25:21.785]         else {
[10:25:21.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:25:21.785]                 windows = "NUL", "/dev/null"), open = "w")
[10:25:21.785]         }
[10:25:21.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:25:21.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:25:21.785]             base::sink(type = "output", split = FALSE)
[10:25:21.785]             base::close(...future.stdout)
[10:25:21.785]         }, add = TRUE)
[10:25:21.785]     }
[10:25:21.785]     ...future.frame <- base::sys.nframe()
[10:25:21.785]     ...future.conditions <- base::list()
[10:25:21.785]     ...future.rng <- base::globalenv()$.Random.seed
[10:25:21.785]     if (FALSE) {
[10:25:21.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:25:21.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:25:21.785]     }
[10:25:21.785]     ...future.result <- base::tryCatch({
[10:25:21.785]         base::withCallingHandlers({
[10:25:21.785]             ...future.value <- base::withVisible(base::local({
[10:25:21.785]                 ...future.makeSendCondition <- base::local({
[10:25:21.785]                   sendCondition <- NULL
[10:25:21.785]                   function(frame = 1L) {
[10:25:21.785]                     if (is.function(sendCondition)) 
[10:25:21.785]                       return(sendCondition)
[10:25:21.785]                     ns <- getNamespace("parallel")
[10:25:21.785]                     if (exists("sendData", mode = "function", 
[10:25:21.785]                       envir = ns)) {
[10:25:21.785]                       parallel_sendData <- get("sendData", mode = "function", 
[10:25:21.785]                         envir = ns)
[10:25:21.785]                       envir <- sys.frame(frame)
[10:25:21.785]                       master <- NULL
[10:25:21.785]                       while (!identical(envir, .GlobalEnv) && 
[10:25:21.785]                         !identical(envir, emptyenv())) {
[10:25:21.785]                         if (exists("master", mode = "list", envir = envir, 
[10:25:21.785]                           inherits = FALSE)) {
[10:25:21.785]                           master <- get("master", mode = "list", 
[10:25:21.785]                             envir = envir, inherits = FALSE)
[10:25:21.785]                           if (inherits(master, c("SOCKnode", 
[10:25:21.785]                             "SOCK0node"))) {
[10:25:21.785]                             sendCondition <<- function(cond) {
[10:25:21.785]                               data <- list(type = "VALUE", value = cond, 
[10:25:21.785]                                 success = TRUE)
[10:25:21.785]                               parallel_sendData(master, data)
[10:25:21.785]                             }
[10:25:21.785]                             return(sendCondition)
[10:25:21.785]                           }
[10:25:21.785]                         }
[10:25:21.785]                         frame <- frame + 1L
[10:25:21.785]                         envir <- sys.frame(frame)
[10:25:21.785]                       }
[10:25:21.785]                     }
[10:25:21.785]                     sendCondition <<- function(cond) NULL
[10:25:21.785]                   }
[10:25:21.785]                 })
[10:25:21.785]                 withCallingHandlers({
[10:25:21.785]                   fcn(x, y)
[10:25:21.785]                 }, immediateCondition = function(cond) {
[10:25:21.785]                   sendCondition <- ...future.makeSendCondition()
[10:25:21.785]                   sendCondition(cond)
[10:25:21.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.785]                   {
[10:25:21.785]                     inherits <- base::inherits
[10:25:21.785]                     invokeRestart <- base::invokeRestart
[10:25:21.785]                     is.null <- base::is.null
[10:25:21.785]                     muffled <- FALSE
[10:25:21.785]                     if (inherits(cond, "message")) {
[10:25:21.785]                       muffled <- grepl(pattern, "muffleMessage")
[10:25:21.785]                       if (muffled) 
[10:25:21.785]                         invokeRestart("muffleMessage")
[10:25:21.785]                     }
[10:25:21.785]                     else if (inherits(cond, "warning")) {
[10:25:21.785]                       muffled <- grepl(pattern, "muffleWarning")
[10:25:21.785]                       if (muffled) 
[10:25:21.785]                         invokeRestart("muffleWarning")
[10:25:21.785]                     }
[10:25:21.785]                     else if (inherits(cond, "condition")) {
[10:25:21.785]                       if (!is.null(pattern)) {
[10:25:21.785]                         computeRestarts <- base::computeRestarts
[10:25:21.785]                         grepl <- base::grepl
[10:25:21.785]                         restarts <- computeRestarts(cond)
[10:25:21.785]                         for (restart in restarts) {
[10:25:21.785]                           name <- restart$name
[10:25:21.785]                           if (is.null(name)) 
[10:25:21.785]                             next
[10:25:21.785]                           if (!grepl(pattern, name)) 
[10:25:21.785]                             next
[10:25:21.785]                           invokeRestart(restart)
[10:25:21.785]                           muffled <- TRUE
[10:25:21.785]                           break
[10:25:21.785]                         }
[10:25:21.785]                       }
[10:25:21.785]                     }
[10:25:21.785]                     invisible(muffled)
[10:25:21.785]                   }
[10:25:21.785]                   muffleCondition(cond)
[10:25:21.785]                 })
[10:25:21.785]             }))
[10:25:21.785]             future::FutureResult(value = ...future.value$value, 
[10:25:21.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.785]                   ...future.rng), globalenv = if (FALSE) 
[10:25:21.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:25:21.785]                     ...future.globalenv.names))
[10:25:21.785]                 else NULL, started = ...future.startTime, version = "1.8")
[10:25:21.785]         }, condition = base::local({
[10:25:21.785]             c <- base::c
[10:25:21.785]             inherits <- base::inherits
[10:25:21.785]             invokeRestart <- base::invokeRestart
[10:25:21.785]             length <- base::length
[10:25:21.785]             list <- base::list
[10:25:21.785]             seq.int <- base::seq.int
[10:25:21.785]             signalCondition <- base::signalCondition
[10:25:21.785]             sys.calls <- base::sys.calls
[10:25:21.785]             `[[` <- base::`[[`
[10:25:21.785]             `+` <- base::`+`
[10:25:21.785]             `<<-` <- base::`<<-`
[10:25:21.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:25:21.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:25:21.785]                   3L)]
[10:25:21.785]             }
[10:25:21.785]             function(cond) {
[10:25:21.785]                 is_error <- inherits(cond, "error")
[10:25:21.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:25:21.785]                   NULL)
[10:25:21.785]                 if (is_error) {
[10:25:21.785]                   sessionInformation <- function() {
[10:25:21.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:25:21.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:25:21.785]                       search = base::search(), system = base::Sys.info())
[10:25:21.785]                   }
[10:25:21.785]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:25:21.785]                     cond$call), session = sessionInformation(), 
[10:25:21.785]                     timestamp = base::Sys.time(), signaled = 0L)
[10:25:21.785]                   signalCondition(cond)
[10:25:21.785]                 }
[10:25:21.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:25:21.785]                 "immediateCondition"))) {
[10:25:21.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:25:21.785]                   ...future.conditions[[length(...future.conditions) + 
[10:25:21.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:25:21.785]                   if (TRUE && !signal) {
[10:25:21.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.785]                     {
[10:25:21.785]                       inherits <- base::inherits
[10:25:21.785]                       invokeRestart <- base::invokeRestart
[10:25:21.785]                       is.null <- base::is.null
[10:25:21.785]                       muffled <- FALSE
[10:25:21.785]                       if (inherits(cond, "message")) {
[10:25:21.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.785]                         if (muffled) 
[10:25:21.785]                           invokeRestart("muffleMessage")
[10:25:21.785]                       }
[10:25:21.785]                       else if (inherits(cond, "warning")) {
[10:25:21.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.785]                         if (muffled) 
[10:25:21.785]                           invokeRestart("muffleWarning")
[10:25:21.785]                       }
[10:25:21.785]                       else if (inherits(cond, "condition")) {
[10:25:21.785]                         if (!is.null(pattern)) {
[10:25:21.785]                           computeRestarts <- base::computeRestarts
[10:25:21.785]                           grepl <- base::grepl
[10:25:21.785]                           restarts <- computeRestarts(cond)
[10:25:21.785]                           for (restart in restarts) {
[10:25:21.785]                             name <- restart$name
[10:25:21.785]                             if (is.null(name)) 
[10:25:21.785]                               next
[10:25:21.785]                             if (!grepl(pattern, name)) 
[10:25:21.785]                               next
[10:25:21.785]                             invokeRestart(restart)
[10:25:21.785]                             muffled <- TRUE
[10:25:21.785]                             break
[10:25:21.785]                           }
[10:25:21.785]                         }
[10:25:21.785]                       }
[10:25:21.785]                       invisible(muffled)
[10:25:21.785]                     }
[10:25:21.785]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.785]                   }
[10:25:21.785]                 }
[10:25:21.785]                 else {
[10:25:21.785]                   if (TRUE) {
[10:25:21.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:25:21.785]                     {
[10:25:21.785]                       inherits <- base::inherits
[10:25:21.785]                       invokeRestart <- base::invokeRestart
[10:25:21.785]                       is.null <- base::is.null
[10:25:21.785]                       muffled <- FALSE
[10:25:21.785]                       if (inherits(cond, "message")) {
[10:25:21.785]                         muffled <- grepl(pattern, "muffleMessage")
[10:25:21.785]                         if (muffled) 
[10:25:21.785]                           invokeRestart("muffleMessage")
[10:25:21.785]                       }
[10:25:21.785]                       else if (inherits(cond, "warning")) {
[10:25:21.785]                         muffled <- grepl(pattern, "muffleWarning")
[10:25:21.785]                         if (muffled) 
[10:25:21.785]                           invokeRestart("muffleWarning")
[10:25:21.785]                       }
[10:25:21.785]                       else if (inherits(cond, "condition")) {
[10:25:21.785]                         if (!is.null(pattern)) {
[10:25:21.785]                           computeRestarts <- base::computeRestarts
[10:25:21.785]                           grepl <- base::grepl
[10:25:21.785]                           restarts <- computeRestarts(cond)
[10:25:21.785]                           for (restart in restarts) {
[10:25:21.785]                             name <- restart$name
[10:25:21.785]                             if (is.null(name)) 
[10:25:21.785]                               next
[10:25:21.785]                             if (!grepl(pattern, name)) 
[10:25:21.785]                               next
[10:25:21.785]                             invokeRestart(restart)
[10:25:21.785]                             muffled <- TRUE
[10:25:21.785]                             break
[10:25:21.785]                           }
[10:25:21.785]                         }
[10:25:21.785]                       }
[10:25:21.785]                       invisible(muffled)
[10:25:21.785]                     }
[10:25:21.785]                     muffleCondition(cond, pattern = "^muffle")
[10:25:21.785]                   }
[10:25:21.785]                 }
[10:25:21.785]             }
[10:25:21.785]         }))
[10:25:21.785]     }, error = function(ex) {
[10:25:21.785]         base::structure(base::list(value = NULL, visible = NULL, 
[10:25:21.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:25:21.785]                 ...future.rng), started = ...future.startTime, 
[10:25:21.785]             finished = Sys.time(), session_uuid = NA_character_, 
[10:25:21.785]             version = "1.8"), class = "FutureResult")
[10:25:21.785]     }, finally = {
[10:25:21.785]         if (!identical(...future.workdir, getwd())) 
[10:25:21.785]             setwd(...future.workdir)
[10:25:21.785]         {
[10:25:21.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:25:21.785]                 ...future.oldOptions$nwarnings <- NULL
[10:25:21.785]             }
[10:25:21.785]             base::options(...future.oldOptions)
[10:25:21.785]             if (.Platform$OS.type == "windows") {
[10:25:21.785]                 old_names <- names(...future.oldEnvVars)
[10:25:21.785]                 envs <- base::Sys.getenv()
[10:25:21.785]                 names <- names(envs)
[10:25:21.785]                 common <- intersect(names, old_names)
[10:25:21.785]                 added <- setdiff(names, old_names)
[10:25:21.785]                 removed <- setdiff(old_names, names)
[10:25:21.785]                 changed <- common[...future.oldEnvVars[common] != 
[10:25:21.785]                   envs[common]]
[10:25:21.785]                 NAMES <- toupper(changed)
[10:25:21.785]                 args <- list()
[10:25:21.785]                 for (kk in seq_along(NAMES)) {
[10:25:21.785]                   name <- changed[[kk]]
[10:25:21.785]                   NAME <- NAMES[[kk]]
[10:25:21.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.785]                     next
[10:25:21.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.785]                 }
[10:25:21.785]                 NAMES <- toupper(added)
[10:25:21.785]                 for (kk in seq_along(NAMES)) {
[10:25:21.785]                   name <- added[[kk]]
[10:25:21.785]                   NAME <- NAMES[[kk]]
[10:25:21.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.785]                     next
[10:25:21.785]                   args[[name]] <- ""
[10:25:21.785]                 }
[10:25:21.785]                 NAMES <- toupper(removed)
[10:25:21.785]                 for (kk in seq_along(NAMES)) {
[10:25:21.785]                   name <- removed[[kk]]
[10:25:21.785]                   NAME <- NAMES[[kk]]
[10:25:21.785]                   if (name != NAME && is.element(NAME, old_names)) 
[10:25:21.785]                     next
[10:25:21.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:25:21.785]                 }
[10:25:21.785]                 if (length(args) > 0) 
[10:25:21.785]                   base::do.call(base::Sys.setenv, args = args)
[10:25:21.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:25:21.785]             }
[10:25:21.785]             else {
[10:25:21.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:25:21.785]             }
[10:25:21.785]             {
[10:25:21.785]                 if (base::length(...future.futureOptionsAdded) > 
[10:25:21.785]                   0L) {
[10:25:21.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:25:21.785]                   base::names(opts) <- ...future.futureOptionsAdded
[10:25:21.785]                   base::options(opts)
[10:25:21.785]                 }
[10:25:21.785]                 {
[10:25:21.785]                   {
[10:25:21.785]                     base::options(mc.cores = ...future.mc.cores.old)
[10:25:21.785]                     NULL
[10:25:21.785]                   }
[10:25:21.785]                   options(future.plan = NULL)
[10:25:21.785]                   if (is.na(NA_character_)) 
[10:25:21.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:25:21.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:25:21.785]                   future::plan(list(function (..., workers = availableCores(), 
[10:25:21.785]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:25:21.785]                     envir = parent.frame()) 
[10:25:21.785]                   {
[10:25:21.785]                     if (is.function(workers)) 
[10:25:21.785]                       workers <- workers()
[10:25:21.785]                     workers <- structure(as.integer(workers), 
[10:25:21.785]                       class = class(workers))
[10:25:21.785]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:25:21.785]                       workers >= 1)
[10:25:21.785]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:25:21.785]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:25:21.785]                     }
[10:25:21.785]                     future <- MultisessionFuture(..., workers = workers, 
[10:25:21.785]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:25:21.785]                       envir = envir)
[10:25:21.785]                     if (!future$lazy) 
[10:25:21.785]                       future <- run(future)
[10:25:21.785]                     invisible(future)
[10:25:21.785]                   }), .cleanup = FALSE, .init = FALSE)
[10:25:21.785]                 }
[10:25:21.785]             }
[10:25:21.785]         }
[10:25:21.785]     })
[10:25:21.785]     if (TRUE) {
[10:25:21.785]         base::sink(type = "output", split = FALSE)
[10:25:21.785]         if (TRUE) {
[10:25:21.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:25:21.785]         }
[10:25:21.785]         else {
[10:25:21.785]             ...future.result["stdout"] <- base::list(NULL)
[10:25:21.785]         }
[10:25:21.785]         base::close(...future.stdout)
[10:25:21.785]         ...future.stdout <- NULL
[10:25:21.785]     }
[10:25:21.785]     ...future.result$conditions <- ...future.conditions
[10:25:21.785]     ...future.result$finished <- base::Sys.time()
[10:25:21.785]     ...future.result
[10:25:21.785] }
[10:25:21.787] Exporting 3 global objects (4.18 KiB) to cluster node #1 ...
[10:25:21.787] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ...
[10:25:21.788] Exporting ‘fcn’ (4.07 KiB) to cluster node #1 ... DONE
[10:25:21.788] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[10:25:21.788] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.788] Exporting ‘y’ (56 bytes) to cluster node #1 ...
[10:25:21.789] Exporting ‘y’ (56 bytes) to cluster node #1 ... DONE
[10:25:21.789] Exporting 3 global objects (4.18 KiB) to cluster node #1 ... DONE
[10:25:21.789] MultisessionFuture started
[10:25:21.789] - Launch lazy future ... done
[10:25:21.790] run() for ‘MultisessionFuture’ ... done
[10:25:21.790] result() for ClusterFuture ...
[10:25:21.790] receiveMessageFromWorker() for ClusterFuture ...
[10:25:21.790] - Validating connection of MultisessionFuture
[10:25:21.834] - received message: FutureResult
[10:25:21.834] - Received FutureResult
[10:25:21.834] - Erased future from FutureRegistry
[10:25:21.834] result() for ClusterFuture ...
[10:25:21.834] - result already collected: FutureResult
[10:25:21.834] result() for ClusterFuture ... done
[10:25:21.834] receiveMessageFromWorker() for ClusterFuture ... done
[10:25:21.835] result() for ClusterFuture ... done
[10:25:21.835] result() for ClusterFuture ...
[10:25:21.835] - result already collected: FutureResult
[10:25:21.835] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[10:25:21.836] plan(): Setting new future strategy stack:
[10:25:21.836] List of future strategies:
[10:25:21.836] 1. FutureStrategy:
[10:25:21.836]    - args: function (..., envir = parent.frame())
[10:25:21.836]    - tweaked: FALSE
[10:25:21.836]    - call: future::plan(oplan)
[10:25:21.836] plan(): nbrOfWorkers() = 1
> 
